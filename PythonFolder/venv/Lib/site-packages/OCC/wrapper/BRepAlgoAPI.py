# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BRepAlgoAPI')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BRepAlgoAPI')
    _BRepAlgoAPI = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRepAlgoAPI', [dirname(__file__)])
        except ImportError:
            import _BRepAlgoAPI
            return _BRepAlgoAPI
        try:
            _mod = imp.load_module('_BRepAlgoAPI', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BRepAlgoAPI = swig_import_helper()
    del swig_import_helper
else:
    import _BRepAlgoAPI
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepAlgoAPI.delete_SwigPyIterator

    def value(self):
        return _BRepAlgoAPI.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BRepAlgoAPI.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BRepAlgoAPI.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BRepAlgoAPI.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BRepAlgoAPI.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BRepAlgoAPI.SwigPyIterator_copy(self)

    def next(self):
        return _BRepAlgoAPI.SwigPyIterator_next(self)

    def __next__(self):
        return _BRepAlgoAPI.SwigPyIterator___next__(self)

    def previous(self):
        return _BRepAlgoAPI.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BRepAlgoAPI.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BRepAlgoAPI.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BRepAlgoAPI.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BRepAlgoAPI.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BRepAlgoAPI.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BRepAlgoAPI.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BRepAlgoAPI.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BRepAlgoAPI.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepAlgoAPI.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BRepAlgoAPI.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepAlgoAPI.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepAlgoAPI.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepAlgoAPI.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BRepAlgoAPI.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BRepAlgoAPI.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BRepAlgoAPI.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepAlgoAPI.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BRepAlgoAPI.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepAlgoAPI.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepAlgoAPI.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepAlgoAPI.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BRepAlgoAPI.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BRepAlgoAPI.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BRepAlgoAPI.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BRepAlgoAPI.ptr_to_number(item)
ptr_to_number = _BRepAlgoAPI.ptr_to_number

def HashCode(*args):
    return _BRepAlgoAPI.HashCode(*args)
HashCode = _BRepAlgoAPI.HashCode

def ptr_equal(a, b):
    return _BRepAlgoAPI.ptr_equal(a, b)
ptr_equal = _BRepAlgoAPI.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BOPAlgo
else:
    import BOPAlgo
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BOPTools
else:
    import BOPTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntTools
else:
    import IntTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAPI
else:
    import GeomAPI
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Approx
else:
    import Approx
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppCont
else:
    import AppCont
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppParCurves
else:
    import AppParCurves
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AdvApprox
else:
    import AdvApprox
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PLib
else:
    import PLib
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Extrema
else:
    import Extrema
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dHatch
else:
    import Geom2dHatch
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import HatchGen
else:
    import HatchGen
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntRes2d
else:
    import IntRes2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dInt
else:
    import Geom2dInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Intf
else:
    import Intf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurve
else:
    import IntCurve
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntPatch
else:
    import IntPatch
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntSurf
else:
    import IntSurf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntAna
else:
    import IntAna
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntWalk
else:
    import IntWalk
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntImp
else:
    import IntImp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepClass3d
else:
    import BRepClass3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurveSurface
else:
    import IntCurveSurface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurvesFace
else:
    import IntCurvesFace
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomInt
else:
    import GeomInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ApproxInt
else:
    import ApproxInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BOPDS
else:
    import BOPDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepTools
else:
    import BRepTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRep
else:
    import BRep
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepBuilderAPI
else:
    import BRepBuilderAPI
del _swig_python_version_info
class BRepAlgoAPI_Algo(BRepBuilderAPI.BRepBuilderAPI_MakeShape):
    """Provides the root interface for the API algorithms"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Shape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepAlgoAPI.BRepAlgoAPI_Algo_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(BRepAlgoAPI_Algo self)

        Clears all warnings and errors, and any data cached by the algorithm.
        User defined options are not cleared.


        """
        return _BRepAlgoAPI.BRepAlgoAPI_Algo_Clear(self, *args)


    def SetRunParallel(self, *args):
        """
        SetRunParallel(BRepAlgoAPI_Algo self, Standard_Boolean const theFlag)

        Set the flag of parallel processing
        if <theFlag> is true  the parallel processing is switched on
        if <theFlag> is false the parallel processing is switched off

        :type theFlag: bool

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Algo_SetRunParallel(self, *args)


    def RunParallel(self, *args):
        """
        RunParallel(BRepAlgoAPI_Algo self) -> Standard_Boolean

        Returns the flag of parallel processing

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Algo_RunParallel(self, *args)


    def SetFuzzyValue(self, *args):
        """
        SetFuzzyValue(BRepAlgoAPI_Algo self, Standard_Real const theFuzz)

        Sets the additional tolerance

        :type theFuzz: float

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Algo_SetFuzzyValue(self, *args)


    def FuzzyValue(self, *args):
        """
        FuzzyValue(BRepAlgoAPI_Algo self) -> Standard_Real

        Returns the additional tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Algo_FuzzyValue(self, *args)


    def HasErrors(self, *args):
        """
        HasErrors(BRepAlgoAPI_Algo self) -> Standard_Boolean

        Returns true if algorithm has failed

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Algo_HasErrors(self, *args)


    def HasWarnings(self, *args):
        """
        HasWarnings(BRepAlgoAPI_Algo self) -> Standard_Boolean

        Returns true if algorithm has generated some warning alerts

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Algo_HasWarnings(self, *args)


    def HasError(self, *args):
        """
        HasError(BRepAlgoAPI_Algo self, Handle_Standard_Type theType) -> Standard_Boolean

        Returns true if algorithm has generated error of specified type

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Algo_HasError(self, *args)


    def HasWarning(self, *args):
        """
        HasWarning(BRepAlgoAPI_Algo self, Handle_Standard_Type theType) -> Standard_Boolean

        Returns true if algorithm has generated warning of specified type

        :type theType: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Algo_HasWarning(self, *args)


    def DumpErrors(self, *args):
        """
        DumpErrors(BRepAlgoAPI_Algo self, Standard_OStream & theOS)

        Dumps the error status into the given stream

        :type theOS: OCC.wrapper.Standard.Standard_OStream

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Algo_DumpErrors(self, *args)


    def DumpWarnings(self, *args):
        """
        DumpWarnings(BRepAlgoAPI_Algo self, Standard_OStream & theOS)

        Dumps the warning statuses into the given stream

        :type theOS: OCC.wrapper.Standard.Standard_OStream

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Algo_DumpWarnings(self, *args)


    def ClearWarnings(self, *args):
        """
        ClearWarnings(BRepAlgoAPI_Algo self)

        Clears the warnings of the algorithm


        """
        return _BRepAlgoAPI.BRepAlgoAPI_Algo_ClearWarnings(self, *args)


    def GetReport(self, *args):
        """
        GetReport(BRepAlgoAPI_Algo self) -> Handle_Message_Report

        Returns report collecting all errors and warnings

        :rtype: OCC.wrapper.Message.Handle_Message_Report

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Algo_GetReport(self, *args)


    def SetProgressIndicator(self, *args):
        """
        SetProgressIndicator(BRepAlgoAPI_Algo self, Handle_Message_ProgressIndicator theObj)

        Set the Progress Indicator object.

        :type theObj: OCC.wrapper.Message.Handle_Message_ProgressIndicator

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Algo_SetProgressIndicator(self, *args)


    def SetUseOBB(self, *args):
        """
        SetUseOBB(BRepAlgoAPI_Algo self, Standard_Boolean const theUseOBB)

        Enables/Disables the usage of OBB

        :type theUseOBB: bool

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Algo_SetUseOBB(self, *args)

BRepAlgoAPI_Algo_swigregister = _BRepAlgoAPI.BRepAlgoAPI_Algo_swigregister
BRepAlgoAPI_Algo_swigregister(BRepAlgoAPI_Algo)

class BRepAlgoAPI_BuilderAlgo(BRepAlgoAPI_Algo):
    """
    The class contains API level of the General Fuse algorithm.<br>

    Additionally to the options defined in the base class, the algorithm has
    the following options:<br>
    - *Safe processing mode* - allows to avoid modification of the input
    shapes during the operation (by default it is off);
    - *Gluing options* - allows to speed up the calculation of the intersections
    on the special cases, in which some sub-shapes are coinciding.
    - *Disabling the check for inverted solids* - Disables/Enables the check of the input solids
    for inverted status (holes in the space). The default value is TRUE,
    i.e. the check is performed. Setting this flag to FALSE for inverted solids,
    most likely will lead to incorrect results.

    It returns the following Error statuses:<br>
    - 0 - in case of success;<br>
    - *BOPAlgo_AlertTooFewArguments* - in case there are no enough arguments to perform the operation;<br>
    - *BOPAlgo_AlertIntersectionFailed* - in case the intersection of the arguments has failed;<br>
    - *BOPAlgo_AlertBuilderFailed* - in case building of the result shape has failed.<br>

    Warnings statuses from underlying DS Filler and Builder algorithms
    are collected in the report.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepAlgoAPI_BuilderAlgo self) -> BRepAlgoAPI_BuilderAlgo
        __init__(BRepAlgoAPI_BuilderAlgo self, BOPAlgo_PaveFiller thePF) -> BRepAlgoAPI_BuilderAlgo

        Empty constructor

        :type thePF: OCC.wrapper.BOPAlgo.BOPAlgo_PaveFiller

        """
        this = _BRepAlgoAPI.new_BRepAlgoAPI_BuilderAlgo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetNonDestructive(self, *args):
        """
        SetNonDestructive(BRepAlgoAPI_BuilderAlgo self, Standard_Boolean const theFlag)

        Sets the flag that defines the mode of treatment.
        In non-destructive mode the argument shapes are not modified. Instead
        a copy of a sub-shape is created in the result if it is needed to be updated.

        :type theFlag: bool

        """
        return _BRepAlgoAPI.BRepAlgoAPI_BuilderAlgo_SetNonDestructive(self, *args)


    def NonDestructive(self, *args):
        """
        NonDestructive(BRepAlgoAPI_BuilderAlgo self) -> Standard_Boolean

        Returns the flag that defines the mode of treatment.
        In non-destructive mode the argument shapes are not modified. Instead
        a copy of a sub-shape is created in the result if it is needed to be updated.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgoAPI.BRepAlgoAPI_BuilderAlgo_NonDestructive(self, *args)


    def SetGlue(self, *args):
        """
        SetGlue(BRepAlgoAPI_BuilderAlgo self, BOPAlgo_GlueEnum const theGlue)

        Sets the glue option for the algorithm

        :type theGlue: OCC.wrapper.BOPAlgo.BOPAlgo_GlueEnum

        """
        return _BRepAlgoAPI.BRepAlgoAPI_BuilderAlgo_SetGlue(self, *args)


    def Glue(self, *args):
        """
        Glue(BRepAlgoAPI_BuilderAlgo self) -> BOPAlgo_GlueEnum

        Returns the glue option of the algorithm

        :rtype: OCC.wrapper.BOPAlgo.BOPAlgo_GlueEnum

        """
        return _BRepAlgoAPI.BRepAlgoAPI_BuilderAlgo_Glue(self, *args)


    def SetCheckInverted(self, *args):
        """
        SetCheckInverted(BRepAlgoAPI_BuilderAlgo self, Standard_Boolean const theCheck)

        Enables/Disables the check of the input solids for inverted status

        :type theCheck: bool

        """
        return _BRepAlgoAPI.BRepAlgoAPI_BuilderAlgo_SetCheckInverted(self, *args)


    def CheckInverted(self, *args):
        """
        CheckInverted(BRepAlgoAPI_BuilderAlgo self) -> Standard_Boolean

        Returns the flag defining whether the check for input solids on inverted status
        should be performed or not.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgoAPI.BRepAlgoAPI_BuilderAlgo_CheckInverted(self, *args)


    def SetArguments(self, *args):
        """
        SetArguments(BRepAlgoAPI_BuilderAlgo self, NCollection_List_TopoDS_Shape theLS)

        Sets the arguments

        :type theLS: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepAlgoAPI.BRepAlgoAPI_BuilderAlgo_SetArguments(self, *args)


    def Arguments(self, *args):
        """
        Gets the arguments

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepAlgoAPI.BRepAlgoAPI_BuilderAlgo_Arguments(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Build(self, *args):
        """
        Build(BRepAlgoAPI_BuilderAlgo self)

        Performs the algorithm

        H  I  S  T  O  R  Y


        """
        return _BRepAlgoAPI.BRepAlgoAPI_BuilderAlgo_Build(self, *args)


    def Modified(self, *args):
        """
        Returns the list  of shapes modified from the shape <S>.

        :type aS: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepAlgoAPI.BRepAlgoAPI_BuilderAlgo_Modified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDeleted(self, *args):
        """
        IsDeleted(BRepAlgoAPI_BuilderAlgo self, TopoDS_Shape aS) -> Standard_Boolean

        Returns true if the shape S has been deleted. The
        result shape of the operation does not contain the shape S.

        :type aS: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgoAPI.BRepAlgoAPI_BuilderAlgo_IsDeleted(self, *args)


    def Generated(self, *args):
        """
        Returns the list  of shapes generated from the shape <S>.
        For use in BRepNaming.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepAlgoAPI.BRepAlgoAPI_BuilderAlgo_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasModified(self, *args):
        """
        HasModified(BRepAlgoAPI_BuilderAlgo self) -> Standard_Boolean

        Returns true if there is at least one modified shape.
        For use in BRepNaming.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgoAPI.BRepAlgoAPI_BuilderAlgo_HasModified(self, *args)


    def HasGenerated(self, *args):
        """
        HasGenerated(BRepAlgoAPI_BuilderAlgo self) -> Standard_Boolean

        Returns true if there is at least one generated shape.
        For use in BRepNaming.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgoAPI.BRepAlgoAPI_BuilderAlgo_HasGenerated(self, *args)


    def HasDeleted(self, *args):
        """
        HasDeleted(BRepAlgoAPI_BuilderAlgo self) -> Standard_Boolean

        Returns true if there is at least one deleted shape.
        For use in BRepNaming.

        protected methods

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgoAPI.BRepAlgoAPI_BuilderAlgo_HasDeleted(self, *args)


    def DSFiller(self, *args):
        """
        Returns the Intersection tool

        :rtype: OCC.wrapper.BOPAlgo.BOPAlgo_PPaveFiller

        """
        res = _BRepAlgoAPI.BRepAlgoAPI_BuilderAlgo_DSFiller(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Builder(self, *args):
        """
        Returns the Building tool

        :rtype: OCC.wrapper.BOPAlgo.BOPAlgo_PBuilder

        """
        res = _BRepAlgoAPI.BRepAlgoAPI_BuilderAlgo_Builder(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepAlgoAPI.delete_BRepAlgoAPI_BuilderAlgo
BRepAlgoAPI_BuilderAlgo_swigregister = _BRepAlgoAPI.BRepAlgoAPI_BuilderAlgo_swigregister
BRepAlgoAPI_BuilderAlgo_swigregister(BRepAlgoAPI_BuilderAlgo)

class BRepAlgoAPI_BooleanOperation(BRepAlgoAPI_BuilderAlgo):
    """
    The abstract class BooleanOperation is the root
    class of Boolean Operations (see Overview).
    Boolean Operations algorithm is divided onto two parts:<br>
    - The first one is computing interference between arguments;<br>
    - The second one is building the result of operation;<br>
    The class BooleanOperation provides API level of both parts.<br>

    Additionally to the errors of the parent class the algorithm
    returns the following Error statuses:<br>
    - 0 - in case of success;<br>
    - *BOPAlgo_AlertBOPNotSet* - in case the type of Boolean Operation is not set.<br>

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Shape1(self, *args):
        """
        Returns the first argument involved in this Boolean operation.
        Obsolete

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepAlgoAPI.BRepAlgoAPI_BooleanOperation_Shape1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shape2(self, *args):
        """
        Returns the second argument involved in this Boolean operation.
        Obsolete

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepAlgoAPI.BRepAlgoAPI_BooleanOperation_Shape2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTools(self, *args):
        """
        SetTools(BRepAlgoAPI_BooleanOperation self, NCollection_List_TopoDS_Shape theLS)

        Sets the tools

        :type theLS: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepAlgoAPI.BRepAlgoAPI_BooleanOperation_SetTools(self, *args)


    def Tools(self, *args):
        """
        Gets the tools

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepAlgoAPI.BRepAlgoAPI_BooleanOperation_Tools(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOperation(self, *args):
        """
        SetOperation(BRepAlgoAPI_BooleanOperation self, BOPAlgo_Operation const anOp)

        Sets the type of Boolean operation

        :type anOp: OCC.wrapper.BOPAlgo.BOPAlgo_Operation

        """
        return _BRepAlgoAPI.BRepAlgoAPI_BooleanOperation_SetOperation(self, *args)


    def Operation(self, *args):
        """
        Operation(BRepAlgoAPI_BooleanOperation self) -> BOPAlgo_Operation

        Returns the type of Boolean Operation

        :rtype: OCC.wrapper.BOPAlgo.BOPAlgo_Operation

        """
        return _BRepAlgoAPI.BRepAlgoAPI_BooleanOperation_Operation(self, *args)


    def Build(self, *args):
        """
        Build(BRepAlgoAPI_BooleanOperation self)

        Performs the algorithm
        Filling interference Data Structure (if it is necessary)
        Building the result of the operation.


        """
        return _BRepAlgoAPI.BRepAlgoAPI_BooleanOperation_Build(self, *args)


    def BuilderCanWork(self, *args):
        """
        BuilderCanWork(BRepAlgoAPI_BooleanOperation self) -> Standard_Boolean

        Returns True if there was no errors occured
        obsolete

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgoAPI.BRepAlgoAPI_BooleanOperation_BuilderCanWork(self, *args)


    def FuseEdges(self, *args):
        """
        FuseEdges(BRepAlgoAPI_BooleanOperation self) -> Standard_Boolean

        Returns the flag of edge refining

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgoAPI.BRepAlgoAPI_BooleanOperation_FuseEdges(self, *args)


    def RefineEdges(self, *args):
        """
        RefineEdges(BRepAlgoAPI_BooleanOperation self)

        Fuse C1 edges


        """
        return _BRepAlgoAPI.BRepAlgoAPI_BooleanOperation_RefineEdges(self, *args)


    def SectionEdges(self, *args):
        """
        Returns a list of section edges.
        The edges represent the result of intersection between arguments of
        Boolean Operation. They are computed during operation execution.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepAlgoAPI.BRepAlgoAPI_BooleanOperation_SectionEdges(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Modified(self, *args):
        """
        Returns the list  of shapes modified from the shape <S>.

        :type aS: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepAlgoAPI.BRepAlgoAPI_BooleanOperation_Modified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDeleted(self, *args):
        """
        IsDeleted(BRepAlgoAPI_BooleanOperation self, TopoDS_Shape aS) -> Standard_Boolean

        Returns true if the shape S has been deleted. The
        result shape of the operation does not contain the shape S.

        :type aS: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgoAPI.BRepAlgoAPI_BooleanOperation_IsDeleted(self, *args)


    def Generated(self, *args):
        """
        Returns the list  of shapes generated from the shape <S>.
        For use in BRepNaming.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepAlgoAPI.BRepAlgoAPI_BooleanOperation_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasModified(self, *args):
        """
        HasModified(BRepAlgoAPI_BooleanOperation self) -> Standard_Boolean

        Returns true if there is at least one modified shape.
        For use in BRepNaming.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgoAPI.BRepAlgoAPI_BooleanOperation_HasModified(self, *args)


    def HasGenerated(self, *args):
        """
        HasGenerated(BRepAlgoAPI_BooleanOperation self) -> Standard_Boolean

        Returns true if there is at least one generated shape.
        For use in BRepNaming.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgoAPI.BRepAlgoAPI_BooleanOperation_HasGenerated(self, *args)


    def HasDeleted(self, *args):
        """
        HasDeleted(BRepAlgoAPI_BooleanOperation self) -> Standard_Boolean

        Returns true if there is at least one deleted shape.
        For use in BRepNaming.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgoAPI.BRepAlgoAPI_BooleanOperation_HasDeleted(self, *args)

    __swig_destroy__ = _BRepAlgoAPI.delete_BRepAlgoAPI_BooleanOperation
BRepAlgoAPI_BooleanOperation_swigregister = _BRepAlgoAPI.BRepAlgoAPI_BooleanOperation_swigregister
BRepAlgoAPI_BooleanOperation_swigregister(BRepAlgoAPI_BooleanOperation)

class BRepAlgoAPI_Splitter(BRepAlgoAPI_BuilderAlgo):
    """
    The class contains API level of the **Splitter** algorithm,
    which allows splitting a group of arbitrary shapes by the
    other group of arbitrary shapes.<br>
    The arguments of the operation are divided on two groups:<br>
    *Objects* - shapes that will be split;<br>
    *Tools*   - shapes by which the *Objects* will be split.<br>
    The result of the operation contains only the split parts
    of the shapes from the group of *Objects*.<br>
    The split parts of the shapes from the group of *Tools* are excluded
    from the result.<br>
    The shapes can be split by the other shapes from the same group
    (in case these shapes are interfering).

    The class is a General Fuse based algorithm. Thus, all options
    of the General Fuse algorithm such as Fuzzy mode, safe processing mode,
    parallel processing mode, gluing mode and history support are also
    available in this algorithm.<br>
    There is no requirement on the existence of the *Tools* shapes.
    And if there are no *Tools* shapes, the result of the splitting
    operation will be equivalent to the General Fuse result.

    The algorithm returns the following Error statuses:<br>
    - 0 - in case of success;<br>
    - *BOPAlgo_AlertTooFewArguments*    - in case there is no enough arguments for the operation;<br>
    - *BOPAlgo_AlertIntersectionFailed* - in case the Intersection of the arguments has failed;<br>
    - *BOPAlgo_AlertBuilderFailed*      - in case the Building of the result has failed.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepAlgoAPI_Splitter self) -> BRepAlgoAPI_Splitter
        __init__(BRepAlgoAPI_Splitter self, BOPAlgo_PaveFiller thePF) -> BRepAlgoAPI_Splitter

        Constructor with already filled PaveFiller

        :type thePF: OCC.wrapper.BOPAlgo.BOPAlgo_PaveFiller

        """
        this = _BRepAlgoAPI.new_BRepAlgoAPI_Splitter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Build(self, *args):
        """
        Build(BRepAlgoAPI_Splitter self)

        Performs the algorithm.<br>
        Performs the intersection of the objects with tools and build the result of the operation.


        """
        return _BRepAlgoAPI.BRepAlgoAPI_Splitter_Build(self, *args)


    def SetTools(self, *args):
        """
        SetTools(BRepAlgoAPI_Splitter self, NCollection_List_TopoDS_Shape theLS)

        Sets the tools

        :type theLS: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Splitter_SetTools(self, *args)


    def Tools(self, *args):
        """
        Gets the tools

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepAlgoAPI.BRepAlgoAPI_Splitter_Tools(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepAlgoAPI.delete_BRepAlgoAPI_Splitter
BRepAlgoAPI_Splitter_swigregister = _BRepAlgoAPI.BRepAlgoAPI_Splitter_swigregister
BRepAlgoAPI_Splitter_swigregister(BRepAlgoAPI_Splitter)

class BRepAlgoAPI_Common(BRepAlgoAPI_BooleanOperation):
    """
    The class provides Boolean common operation
    between arguments and tools (Boolean Intersection).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepAlgoAPI_Common self) -> BRepAlgoAPI_Common
        __init__(BRepAlgoAPI_Common self, BOPAlgo_PaveFiller PF) -> BRepAlgoAPI_Common
        __init__(BRepAlgoAPI_Common self, TopoDS_Shape S1, TopoDS_Shape S2) -> BRepAlgoAPI_Common
        __init__(BRepAlgoAPI_Common self, TopoDS_Shape S1, TopoDS_Shape S2, BOPAlgo_PaveFiller PF) -> BRepAlgoAPI_Common

        Constructor with two shapes
        <S1>  -argument
        <S2>  -tool
        <anOperation> - the type of the operation
        <PF> - PaveFiller object that is carried out
        Obsolete

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type PF: OCC.wrapper.BOPAlgo.BOPAlgo_PaveFiller

        """
        this = _BRepAlgoAPI.new_BRepAlgoAPI_Common(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepAlgoAPI.delete_BRepAlgoAPI_Common
BRepAlgoAPI_Common_swigregister = _BRepAlgoAPI.BRepAlgoAPI_Common_swigregister
BRepAlgoAPI_Common_swigregister(BRepAlgoAPI_Common)

class BRepAlgoAPI_Check(BOPAlgo.BOPAlgo_Options):
    """
    The class Check provides a diagnostic tool for checking the validity
    of the single shape or couple of shapes.
    The shapes are checked on:
    - Topological validity;
    - Small edges;
    - Self-interference;
    - Validity for Boolean operation of certain type (for couple of shapes only).

    The class provides two ways of checking shape(-s)
    1. Constructors
    BRepAlgoAPI_Check aCh(theS);
    Standard_Boolean isValid = aCh.IsValid();
    2. Methods SetData and Perform
    BRepAlgoAPI_Check aCh;
    aCh.SetData(theS1, theS2, BOPAlgo_FUSE, Standard_False);
    aCh.Perform();
    Standard_Boolean isValid = aCh.IsValid();

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepAlgoAPI_Check self) -> BRepAlgoAPI_Check
        __init__(BRepAlgoAPI_Check self, TopoDS_Shape theS, Standard_Boolean const bTestSE, Standard_Boolean const bTestSI) -> BRepAlgoAPI_Check
        __init__(BRepAlgoAPI_Check self, TopoDS_Shape theS1, TopoDS_Shape theS2, BOPAlgo_Operation const theOp=BOPAlgo_UNKNOWN, Standard_Boolean const bTestSE, Standard_Boolean const bTestSI) -> BRepAlgoAPI_Check

        Constructor for checking the couple of shapes.
        Additionally to the validity checks of each given shape,
        the types of the given shapes will be checked on validity
        for Boolean operation of given type.

        @param theS1 [in] - the first shape to check;
        @param theS2 [in] - the second shape to check;
        @param theOp [in] - the type of Boolean Operation for which the validity
        of given shapes should be checked.
        @param bTestSE [in] - flag which specifies whether to check the shape
        on small edges or not; by default it is set to TRUE;
        @param bTestSI [in] - flag which specifies whether to check the shape
        on self-interference or not; by default it is set to TRUE;

        :type theS1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theS2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theOp: OCC.wrapper.BOPAlgo.BOPAlgo_Operation
        :type bTestSE: bool
        :type bTestSI: bool

        """
        this = _BRepAlgoAPI.new_BRepAlgoAPI_Check(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetData(self, *args):
        """
        SetData(BRepAlgoAPI_Check self, TopoDS_Shape theS, Standard_Boolean const bTestSE, Standard_Boolean const bTestSI)
        SetData(BRepAlgoAPI_Check self, TopoDS_Shape theS1, TopoDS_Shape theS2, BOPAlgo_Operation const theOp=BOPAlgo_UNKNOWN, Standard_Boolean const bTestSE, Standard_Boolean const bTestSI)

        Initializes the algorithm with couple of shapes.
        Additionally to the validity checks of each given shape,
        the types of the given shapes will be checked on validity
        for Boolean operation of given type.

        @param theS1 [in] - the first shape to check;
        @param theS2 [in] - the second shape to check;
        @param theOp [in] - the type of Boolean Operation for which the validity
        of given shapes should be checked.
        @param bTestSE [in] - flag which specifies whether to check the shape
        on small edges or not; by default it is set to TRUE;
        @param bTestSI [in] - flag which specifies whether to check the shape
        on self-interference or not; by default it is set to TRUE;

        :type theS1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theS2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theOp: OCC.wrapper.BOPAlgo.BOPAlgo_Operation
        :type bTestSE: bool
        :type bTestSI: bool

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Check_SetData(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepAlgoAPI_Check self)

        Performs the check.


        """
        return _BRepAlgoAPI.BRepAlgoAPI_Check_Perform(self, *args)


    def IsValid(self, *args):
        """
        IsValid(BRepAlgoAPI_Check self) -> Standard_Boolean

        Shows whether shape(s) valid or not.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Check_IsValid(self, *args)


    def Result(self, *args):
        """
        Returns faulty shapes.

        :rtype: OCC.wrapper.BOPAlgo.BOPAlgo_ListOfCheckResult

        """
        res = _BRepAlgoAPI.BRepAlgoAPI_Check_Result(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepAlgoAPI.delete_BRepAlgoAPI_Check
BRepAlgoAPI_Check_swigregister = _BRepAlgoAPI.BRepAlgoAPI_Check_swigregister
BRepAlgoAPI_Check_swigregister(BRepAlgoAPI_Check)

class BRepAlgoAPI_Fuse(BRepAlgoAPI_BooleanOperation):
    """
    The class provides Boolean fusion operation
    between arguments and tools  (Boolean Union).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepAlgoAPI_Fuse self) -> BRepAlgoAPI_Fuse
        __init__(BRepAlgoAPI_Fuse self, BOPAlgo_PaveFiller PF) -> BRepAlgoAPI_Fuse
        __init__(BRepAlgoAPI_Fuse self, TopoDS_Shape S1, TopoDS_Shape S2) -> BRepAlgoAPI_Fuse
        __init__(BRepAlgoAPI_Fuse self, TopoDS_Shape S1, TopoDS_Shape S2, BOPAlgo_PaveFiller aDSF) -> BRepAlgoAPI_Fuse

        Constructor with two shapes
        <S1>  -argument
        <S2>  -tool
        <anOperation> - the type of the operation
        <PF> - PaveFiller object that is carried out
        Obsolete

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aDSF: OCC.wrapper.BOPAlgo.BOPAlgo_PaveFiller

        """
        this = _BRepAlgoAPI.new_BRepAlgoAPI_Fuse(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepAlgoAPI.delete_BRepAlgoAPI_Fuse
BRepAlgoAPI_Fuse_swigregister = _BRepAlgoAPI.BRepAlgoAPI_Fuse_swigregister
BRepAlgoAPI_Fuse_swigregister(BRepAlgoAPI_Fuse)

class BRepAlgoAPI_Section(BRepAlgoAPI_BooleanOperation):
    """
    The algorithm is to build a Secton operation between arguments and tools.
    The result of Section operation consists of vertices and edges.
    The result of Section operation contains:
    1. new vertices that are subjects of V/V, E/E, E/F, F/F interferences
    2. vertices that are subjects of V/E, V/F interferences
    3. new edges that are subjects of F/F interferences
    4. edges that are Common Blocks
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepAlgoAPI_Section self) -> BRepAlgoAPI_Section
        __init__(BRepAlgoAPI_Section self, BOPAlgo_PaveFiller PF) -> BRepAlgoAPI_Section
        __init__(BRepAlgoAPI_Section self, TopoDS_Shape S1, TopoDS_Shape S2, Standard_Boolean const PerformNow) -> BRepAlgoAPI_Section
        __init__(BRepAlgoAPI_Section self, TopoDS_Shape S1, TopoDS_Shape S2, BOPAlgo_PaveFiller aDSF, Standard_Boolean const PerformNow) -> BRepAlgoAPI_Section
        __init__(BRepAlgoAPI_Section self, TopoDS_Shape S1, gp_Pln Pl, Standard_Boolean const PerformNow) -> BRepAlgoAPI_Section
        __init__(BRepAlgoAPI_Section self, TopoDS_Shape S1, Handle_Geom_Surface Sf, Standard_Boolean const PerformNow) -> BRepAlgoAPI_Section
        __init__(BRepAlgoAPI_Section self, Handle_Geom_Surface Sf, TopoDS_Shape S2, Standard_Boolean const PerformNow) -> BRepAlgoAPI_Section
        __init__(BRepAlgoAPI_Section self, Handle_Geom_Surface Sf1, Handle_Geom_Surface Sf2, Standard_Boolean const PerformNow) -> BRepAlgoAPI_Section

        Constructor with two shapes
        <Sf1>  - argument
        <Sf2>  - tool
        <PerformNow> - the flag:
        if <PerformNow>=True - the algorithm is performed immediatly
        Obsolete

        :type Sf1: OCC.wrapper.Geom.Handle_Geom_Surface
        :type Sf2: OCC.wrapper.Geom.Handle_Geom_Surface
        :type PerformNow: bool

        """
        this = _BRepAlgoAPI.new_BRepAlgoAPI_Section(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init1(self, *args):
        """
        Init1(BRepAlgoAPI_Section self, TopoDS_Shape S1)
        Init1(BRepAlgoAPI_Section self, gp_Pln Pl)
        Init1(BRepAlgoAPI_Section self, Handle_Geom_Surface Sf)

        initialize the argument
        <Sf>  - argument
        Obsolete

        :type Sf: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Section_Init1(self, *args)


    def Init2(self, *args):
        """
        Init2(BRepAlgoAPI_Section self, TopoDS_Shape S2)
        Init2(BRepAlgoAPI_Section self, gp_Pln Pl)
        Init2(BRepAlgoAPI_Section self, Handle_Geom_Surface Sf)

        initialize the tool
        <Sf>  - tool
        Obsolete

        :type Sf: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Section_Init2(self, *args)


    def Approximation(self, *args):
        """
        Approximation(BRepAlgoAPI_Section self, Standard_Boolean const B)

        :type B: bool

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Section_Approximation(self, *args)


    def ComputePCurveOn1(self, *args):
        """
        ComputePCurveOn1(BRepAlgoAPI_Section self, Standard_Boolean const B)

        Indicates whether the P-Curve should be (or not)
        performed on the argument.
        By default, no parametric 2D curve (pcurve) is defined for the
        edges of the result.
        If ComputePCurve1 equals true, further computations performed
        to attach an P-Curve in the parametric space of the argument
        to the constructed edges.
        Obsolete

        :type B: bool

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Section_ComputePCurveOn1(self, *args)


    def ComputePCurveOn2(self, *args):
        """
        ComputePCurveOn2(BRepAlgoAPI_Section self, Standard_Boolean const B)

        Indicates whether the P-Curve should be (or not)
        performed on the tool.
        By default, no parametric 2D curve (pcurve) is defined for the
        edges of the result.
        If ComputePCurve1 equals true, further computations performed
        to attach an P-Curve in the parametric space of the tool
        to the constructed edges.
        Obsolete

        :type B: bool

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Section_ComputePCurveOn2(self, *args)


    def Build(self, *args):
        """
        Build(BRepAlgoAPI_Section self)

        Performs the algorithm
        Filling interference Data Structure (if it is necessary)
        Building the result of the operation.


        """
        return _BRepAlgoAPI.BRepAlgoAPI_Section_Build(self, *args)


    def HasAncestorFaceOn1(self, *args):
        """
        HasAncestorFaceOn1(BRepAlgoAPI_Section self, TopoDS_Shape E, TopoDS_Shape F) -> Standard_Boolean

        get the face of the first part giving section edge <E>.
        Returns True on the 3 following conditions :
        1/ <E> is an edge returned by the Shape() metwod.
        2/ First part of section performed is a shape.
        3/ <E> is built on a intersection curve (i.e <E>
        is not the result of common edges)
        When False, F remains untouched.
        Obsolete

        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :type F: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Section_HasAncestorFaceOn1(self, *args)


    def HasAncestorFaceOn2(self, *args):
        """
        HasAncestorFaceOn2(BRepAlgoAPI_Section self, TopoDS_Shape E, TopoDS_Shape F) -> Standard_Boolean

        Identifies the ancestor faces of
        the intersection edge E resulting from the last
        computation performed in this framework, that is, the faces of
        the two original shapes on which the edge E lies:
        -      HasAncestorFaceOn1 gives the ancestor face in the first shape, and
        -      HasAncestorFaceOn2 gives the ancestor face in the second shape.
        These functions return true if an ancestor face F is found, or false if not.
        An ancestor face is identifiable for the edge E if the following
        conditions are satisfied:
        -  the first part on which this algorithm performed its
        last computation is a shape, that is, it was not given as
        a surface or a plane at the time of construction of this
        algorithm or at a later time by the Init1 function,
        - E is one of the elementary edges built by the
        last computation of this section algorithm.
        To use these functions properly, you have to test the returned
        Boolean value before using the ancestor face: F is significant
        only if the returned Boolean value equals true.
        Obsolete

        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :type F: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Section_HasAncestorFaceOn2(self, *args)

    __swig_destroy__ = _BRepAlgoAPI.delete_BRepAlgoAPI_Section
BRepAlgoAPI_Section_swigregister = _BRepAlgoAPI.BRepAlgoAPI_Section_swigregister
BRepAlgoAPI_Section_swigregister(BRepAlgoAPI_Section)

class BRepAlgoAPI_Cut(BRepAlgoAPI_BooleanOperation):
    """
    The class Cut provides Boolean cut operation
    between arguments and tools (Boolean Subtraction).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepAlgoAPI_Cut self) -> BRepAlgoAPI_Cut
        __init__(BRepAlgoAPI_Cut self, BOPAlgo_PaveFiller PF) -> BRepAlgoAPI_Cut
        __init__(BRepAlgoAPI_Cut self, TopoDS_Shape S1, TopoDS_Shape S2) -> BRepAlgoAPI_Cut
        __init__(BRepAlgoAPI_Cut self, TopoDS_Shape S1, TopoDS_Shape S2, BOPAlgo_PaveFiller aDSF, Standard_Boolean const bFWD) -> BRepAlgoAPI_Cut

        Constructor with two shapes
        <S1>  -argument
        <S2>  -tool
        <anOperation> - the type of the operation
        <PF> - PaveFiller object that is carried out
        Obsolete

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aDSF: OCC.wrapper.BOPAlgo.BOPAlgo_PaveFiller
        :type bFWD: bool

        """
        this = _BRepAlgoAPI.new_BRepAlgoAPI_Cut(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepAlgoAPI.delete_BRepAlgoAPI_Cut
BRepAlgoAPI_Cut_swigregister = _BRepAlgoAPI.BRepAlgoAPI_Cut_swigregister
BRepAlgoAPI_Cut_swigregister(BRepAlgoAPI_Cut)

class BRepAlgoAPI_Defeaturing(BRepAlgoAPI_Algo):
    """
    The BRepAlgoAPI_Defeaturing algorithm is the API algorithm intended for
    removal of the unwanted parts from the shape. The unwanted parts 
    (or features) can be holes, protrusions, gaps, chamfers, fillets etc.
    The shape itself is not modified, the new shape is built as the result.

    The actual removal of the features from the shape is performed by
    the low-level *BOPAlgo_RemoveFeatures* tool. So the defeaturing algorithm
    has the same options, input data requirements, limitations as the
    low-level algorithm.

    <b>Input data</b>

    Currently, only the shapes of type SOLID, COMPSOLID, and COMPOUND of Solids
    are supported. And only the FACEs can be removed from the shape.

    On the input the algorithm accepts the shape itself and the
    features which have to be removed. It does not matter how the features
    are given. It could be the separate faces or the collections
    of faces. The faces should belong to the initial shape, and those that
    do not belong will be ignored.

    <b>Options</b>

    The algorithm has the following options:
    - History support;

    and the options available from base class:
    - Error/Warning reporting system;
    - Parallel processing mode.

    Please note that the other options of the base class are not supported
    here and will have no effect.

    For the details on the available options please refer to the description
    of *BOPAlgo_RemoveFeatures* algorithm.

    <b>Limitations</b>

    The defeaturing algorithm has the same limitations as *BOPAlgo_RemoveFeatures*
    algorithm.

    <b>Example</b>

    Here is the example of usage of the algorithm:
    ~~~~
    TopoDS_Shape aSolid = ...;               // Input shape to remove the features from
    TopTools_ListOfShape aFeatures = ...;    // Features to remove from the shape
    Standard_Boolean bRunParallel = ...;     // Parallel processing mode
    Standard_Boolean isHistoryNeeded = ...;  // History support

    BRepAlgoAPI_Defeaturing aDF;             // De-Featuring algorithm
    aDF.SetShape(aSolid);                    // Set the shape
    aDF.AddFacesToRemove(aFaces);            // Add faces to remove
    aDF.SetRunParallel(bRunParallel);        // Define the processing mode (parallel or single)
    aDF.TrackHistory(isHistoryNeeded);       // Define whether to track the shapes modifications
    aDF.Build();                             // Perform the operation
    if (!aDF.IsDone())                       // Check for the errors
    {
    // error treatment
    Standard_SStream aSStream;
    aDF.DumpErrors(aSStream);
    return;
    }
    if (aDF.HasWarnings())                   // Check for the warnings
    {
    // warnings treatment
    Standard_SStream aSStream;
    aDF.DumpWarnings(aSStream);
    }
    const TopoDS_Shape& aResult = aDF.Shape(); // Result shape
    ~~~~

    The algorithm preserves the type of the input shape in the result shape. Thus,
    if the input shape is a COMPSOLID, the resulting solids will also be put into a COMPSOLID.

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepAlgoAPI_Defeaturing self) -> BRepAlgoAPI_Defeaturing

        Empty constructor


        """
        this = _BRepAlgoAPI.new_BRepAlgoAPI_Defeaturing(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetShape(self, *args):
        """
        SetShape(BRepAlgoAPI_Defeaturing self, TopoDS_Shape theShape)

        Sets the shape for processing.
        @param theShape [in] The shape to remove the features from.
        It should either be the SOLID, COMPSOLID or COMPOUND of Solids.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Defeaturing_SetShape(self, *args)


    def InputShape(self, *args):
        """
        Returns the input shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepAlgoAPI.BRepAlgoAPI_Defeaturing_InputShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddFaceToRemove(self, *args):
        """
        AddFaceToRemove(BRepAlgoAPI_Defeaturing self, TopoDS_Shape theFace)

        Adds the features to remove from the input shape.
        @param theFace [in] The shape to extract the faces for removal.

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Defeaturing_AddFaceToRemove(self, *args)


    def AddFacesToRemove(self, *args):
        """
        AddFacesToRemove(BRepAlgoAPI_Defeaturing self, NCollection_List_TopoDS_Shape theFaces)

        Adds the faces to remove from the input shape.
        @param theFaces [in] The list of shapes to extract the faces for removal.

        :type theFaces: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Defeaturing_AddFacesToRemove(self, *args)


    def FacesToRemove(self, *args):
        """
        Returns the list of faces which have been requested for removal
        from the input shape.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepAlgoAPI.BRepAlgoAPI_Defeaturing_FacesToRemove(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Build(self, *args):
        """
        Build(BRepAlgoAPI_Defeaturing self)

        Performs the operation


        """
        return _BRepAlgoAPI.BRepAlgoAPI_Defeaturing_Build(self, *args)


    def TrackHistory(self, *args):
        """
        TrackHistory(BRepAlgoAPI_Defeaturing self, Standard_Boolean const theFlag)

        Defines whether to track the modification of the shapes or not.

        :type theFlag: bool

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Defeaturing_TrackHistory(self, *args)


    def HasHistory(self, *args):
        """
        HasHistory(BRepAlgoAPI_Defeaturing self) -> Standard_Boolean

        Returns whether the history was requested or not.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Defeaturing_HasHistory(self, *args)


    def Modified(self, *args):
        """
        Returns the list of shapes modified from the shape <theS> during the operation.

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepAlgoAPI.BRepAlgoAPI_Defeaturing_Modified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Generated(self, *args):
        """
        Returns the list of shapes generated from the shape <theS> during the operation.

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepAlgoAPI.BRepAlgoAPI_Defeaturing_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDeleted(self, *args):
        """
        IsDeleted(BRepAlgoAPI_Defeaturing self, TopoDS_Shape theS) -> Standard_Boolean

        Returns true if the shape <theS> has been deleted during the operation.
        It means that the shape has no any trace in the result.
        Otherwise it returns false.

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Defeaturing_IsDeleted(self, *args)


    def GetHistory(self, *args):
        """
        GetHistory(BRepAlgoAPI_Defeaturing self) -> Handle_BRepTools_History

        Returns the History of shapes modifications

        :rtype: OCC.wrapper.BRepTools.Handle_BRepTools_History

        """
        return _BRepAlgoAPI.BRepAlgoAPI_Defeaturing_GetHistory(self, *args)

    __swig_destroy__ = _BRepAlgoAPI.delete_BRepAlgoAPI_Defeaturing
BRepAlgoAPI_Defeaturing_swigregister = _BRepAlgoAPI.BRepAlgoAPI_Defeaturing_swigregister
BRepAlgoAPI_Defeaturing_swigregister(BRepAlgoAPI_Defeaturing)




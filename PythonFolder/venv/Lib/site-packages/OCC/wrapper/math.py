# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_math')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_math')
    _math = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_math', [dirname(__file__)])
        except ImportError:
            import _math
            return _math
        try:
            _mod = imp.load_module('_math', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _math = swig_import_helper()
    del swig_import_helper
else:
    import _math
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _math.delete_SwigPyIterator

    def value(self):
        return _math.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _math.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _math.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _math.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _math.SwigPyIterator_equal(self, x)

    def copy(self):
        return _math.SwigPyIterator_copy(self)

    def next(self):
        return _math.SwigPyIterator_next(self)

    def __next__(self):
        return _math.SwigPyIterator___next__(self)

    def previous(self):
        return _math.SwigPyIterator_previous(self)

    def advance(self, n):
        return _math.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _math.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _math.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _math.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _math.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _math.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _math.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _math.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _math.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_math.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _math.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _math.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _math.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _math.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _math.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _math.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _math.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_math.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _math.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _math.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _math.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _math.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _math.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _math.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _math.ptr_to_number(item)
ptr_to_number = _math.ptr_to_number

def HashCode(*args):
    return _math.HashCode(*args)
HashCode = _math.HashCode

def ptr_equal(a, b):
    return _math.ptr_equal(a, b)
ptr_equal = _math.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
math_OK = _math.math_OK
math_TooManyIterations = _math.math_TooManyIterations
math_FunctionError = _math.math_FunctionError
math_DirectionSearchError = _math.math_DirectionSearchError
math_NotBracketed = _math.math_NotBracketed
class math_SingularMatrix(Standard.Standard_Failure):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_math_SingularMatrix
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_math_SingularMatrix(self) 
            return h


    def __init__(self, *args):
        """
        __init__(math_SingularMatrix self) -> math_SingularMatrix
        __init__(math_SingularMatrix self, Standard_CString const theMessage) -> math_SingularMatrix

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _math.new_math_SingularMatrix(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_math_SingularMatrix

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.math.Handle_math_SingularMatrix

        """
        return _math.math_SingularMatrix_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _math.math_SingularMatrix_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _math.math_SingularMatrix_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _math.math_SingularMatrix_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _math.delete_math_SingularMatrix
math_SingularMatrix_swigregister = _math.math_SingularMatrix_swigregister
math_SingularMatrix_swigregister(math_SingularMatrix)

def math_SingularMatrix_NewInstance(*args):
    """
    math_SingularMatrix_NewInstance(Standard_CString const theMessage) -> Handle_math_SingularMatrix

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.math.Handle_math_SingularMatrix

    """
    return _math.math_SingularMatrix_NewInstance(*args)

def math_SingularMatrix_get_type_name(*args):
    """
    math_SingularMatrix_get_type_name() -> char const *

    :rtype: const char *

    """
    return _math.math_SingularMatrix_get_type_name(*args)

def math_SingularMatrix_get_type_descriptor(*args):
    """
    math_SingularMatrix_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _math.math_SingularMatrix_get_type_descriptor(*args)

class math_FunctionSet(object):
    """
    This abstract class describes the virtual functions associated to
    a set on N Functions of M independant variables.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def NbVariables(self, *args):
        """
        NbVariables(math_FunctionSet self) -> Standard_Integer

        Returns the number of variables of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_FunctionSet_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(math_FunctionSet self) -> Standard_Integer

        Returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_FunctionSet_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(math_FunctionSet self, math_Vector X, math_Vector F) -> Standard_Boolean

        Computes the values <F> of the functions for the
        variable <X>.
        returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_FunctionSet_Value(self, *args)


    def GetStateNumber(self, *args):
        """
        GetStateNumber(math_FunctionSet self) -> Standard_Integer

        Returns the state of the function corresponding to the
        latestcall of any methods associated with the function.
        This function is called by each of the algorithms
        described later which define the function Integer
        Algorithm::StateNumber(). The algorithm has the
        responsibility to call this function when it has found
        a solution (i.e. a root or a minimum) and has to maintain
        the association between the solution found and this
        StateNumber.
        Byu default, this method returns 0 (which means for the
        algorithm: no state has been saved). It is the
        responsibility of the programmer to decide if he needs
        to save the current state of the function and to return
        an Integer that allows retrieval of the state.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_FunctionSet_GetStateNumber(self, *args)

    __swig_destroy__ = _math.delete_math_FunctionSet
math_FunctionSet_swigregister = _math.math_FunctionSet_swigregister
math_FunctionSet_swigregister(math_FunctionSet)

class math_ValueAndWeight(object):
    """Simple container storing two reals: value and weight"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_ValueAndWeight self) -> math_ValueAndWeight
        __init__(math_ValueAndWeight self, Standard_Real theValue, Standard_Real theWeight) -> math_ValueAndWeight

        :type theValue: float
        :type theWeight: float

        """
        this = _math.new_math_ValueAndWeight(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Value(math_ValueAndWeight self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_ValueAndWeight_Value(self, *args)


    def Weight(self, *args):
        """
        Weight(math_ValueAndWeight self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_ValueAndWeight_Weight(self, *args)

    __swig_destroy__ = _math.delete_math_ValueAndWeight
math_ValueAndWeight_swigregister = _math.math_ValueAndWeight_swigregister
math_ValueAndWeight_swigregister(math_ValueAndWeight)

class math_Gauss(object):
    """
    This class implements the Gauss LU decomposition (Crout algorithm)
    with partial pivoting (rows interchange) of a square matrix and
    the different possible derived calculation :
    - solution of a set of linear equations.
    - inverse of a matrix.
    - determinant of a matrix.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_Gauss self, math_Matrix A, Standard_Real const MinPivot=1.0e-20) -> math_Gauss

        Given an input n X n matrix A this constructor performs its LU
        decomposition with partial pivoting (interchange of rows).
        This LU decomposition is stored internally and may be used to
        do subsequent calculation.
        If the largest pivot found is less than MinPivot the matrix A is
        considered as singular.
        Exception NotSquare is raised if A is not a square matrix.

        :type A: OCC.wrapper.math.math_Matrix
        :type MinPivot: float

        """
        this = _math.new_math_Gauss(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(math_Gauss self) -> Standard_Boolean

        Returns true if the computations are successful, otherwise returns false

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_Gauss_IsDone(self, *args)


    def Solve(self, *args):
        """
        Solve(math_Gauss self, math_Vector B, math_Vector X)
        Solve(math_Gauss self, math_Vector B)

        Given the input Vector B this routine solves the set of linear
        equations A . X = B. B is replaced by the vector solution X.
        Exception NotDone is raised if the decomposition of A was not done
        successfully.
        Exception DimensionError is raised if the range of B is not
        equal to the number of rows of A.

        :type B: OCC.wrapper.math.math_Vector

        """
        return _math.math_Gauss_Solve(self, *args)


    def Determinant(self, *args):
        """
        Determinant(math_Gauss self) -> Standard_Real

        This routine returns the value of the determinant of the previously LU
        decomposed matrix A.
        Exception NotDone may be raised if the decomposition of A was not done
        successfully, zero is returned if the matrix A was considered as singular.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_Gauss_Determinant(self, *args)


    def Invert(self, *args):
        """
        Invert(math_Gauss self, math_Matrix Inv)

        This routine outputs Inv the inverse of the previously LU decomposed
        matrix A.
        Exception DimensionError is raised if the ranges of B are not
        equal to the ranges of A.

        :type Inv: OCC.wrapper.math.math_Matrix

        """
        return _math.math_Gauss_Invert(self, *args)


    def Dump(self, *args):
        """
        Dump(math_Gauss self, Standard_OStream & o)

        Prints on the stream o information on the current state
        of the object.
        Is used to redefine the operator <<.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_Gauss_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_Gauss
math_Gauss_swigregister = _math.math_Gauss_swigregister
math_Gauss_swigregister(math_Gauss)

class math_FunctionSetRoot(object):
    """
    The math_FunctionSetRoot class calculates the root
    of a set of N functions of M variables (N<M, N=M or N>M). Knowing
    an initial guess of the solution and using a minimization algorithm, a search
    is made in the Newton direction and then in the Gradient direction if there
    is no success in the Newton direction. This algorithm can also be
    used for functions minimization. Knowledge of all the partial
    derivatives (the Jacobian) is required.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_FunctionSetRoot self, math_FunctionSetWithDerivatives F, math_Vector Tolerance, Standard_Integer const NbIterations=100) -> math_FunctionSetRoot
        __init__(math_FunctionSetRoot self, math_FunctionSetWithDerivatives F, Standard_Integer const NbIterations=100) -> math_FunctionSetRoot

        is used in a sub-class to initialize correctly all the fields
        of this class.
        The range (1, F.NbVariables()) must be especially
        respected for all vectors and matrix declarations.
        The method SetTolerance must be called after this
        constructor.

        :type F: OCC.wrapper.math.math_FunctionSetWithDerivatives
        :type NbIterations: int

        """
        this = _math.new_math_FunctionSetRoot(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetTolerance(self, *args):
        """
        SetTolerance(math_FunctionSetRoot self, math_Vector Tolerance)

        Initializes the tolerance values.

        :type Tolerance: OCC.wrapper.math.math_Vector

        """
        return _math.math_FunctionSetRoot_SetTolerance(self, *args)


    def IsSolutionReached(self, *args):
        """
        IsSolutionReached(math_FunctionSetRoot self, math_FunctionSetWithDerivatives F) -> Standard_Boolean

        This routine is called at the end of each iteration
        to check if the solution was found. It can be redefined
        in a sub-class to implement a specific test to stop the iterations.
        In this case, the solution is found when: abs(Xi - Xi-1) <= Tolerance
        for all unknowns.

        :type F: OCC.wrapper.math.math_FunctionSetWithDerivatives
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_FunctionSetRoot_IsSolutionReached(self, *args)


    def Perform(self, *args):
        """
        Perform(math_FunctionSetRoot self, math_FunctionSetWithDerivatives theFunction, math_Vector theStartingPoint, Standard_Boolean const theStopOnDivergent)
        Perform(math_FunctionSetRoot self, math_FunctionSetWithDerivatives theFunction, math_Vector theStartingPoint, math_Vector theInfBound, math_Vector theSupBound, Standard_Boolean const theStopOnDivergent)

        Improves the root of function from the initial guess point.
        The infinum and supremum may be given to constrain the solution.
        In this case, the solution is found when: abs(Xi - Xi-1) <= Tolerance
        for all unknowns.

        :type theFunction: OCC.wrapper.math.math_FunctionSetWithDerivatives
        :type theStartingPoint: OCC.wrapper.math.math_Vector
        :type theInfBound: OCC.wrapper.math.math_Vector
        :type theSupBound: OCC.wrapper.math.math_Vector
        :type theStopOnDivergent: bool

        """
        return _math.math_FunctionSetRoot_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(math_FunctionSetRoot self) -> Standard_Boolean

        Returns true if the computations are successful, otherwise returns false.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_FunctionSetRoot_IsDone(self, *args)


    def NbIterations(self, *args):
        """
        NbIterations(math_FunctionSetRoot self) -> Standard_Integer

        Returns the number of iterations really done
        during the computation of the root.
        Exception NotDone is raised if the root was not found.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_FunctionSetRoot_NbIterations(self, *args)


    def StateNumber(self, *args):
        """
        StateNumber(math_FunctionSetRoot self) -> Standard_Integer

        returns the stateNumber (as returned by
        F.GetStateNumber()) associated to the root found.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_FunctionSetRoot_StateNumber(self, *args)


    def Root(self, *args):
        """
        Returns the value of the root of function F.
        Exception NotDone is raised if the root was not found.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _math.math_FunctionSetRoot_Root(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Derivative(self, *args):
        """
        Returns the matrix value of the derivative at the root.
        Exception NotDone is raised if the root was not found.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _math.math_FunctionSetRoot_Derivative(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FunctionSetErrors(self, *args):
        """
        returns the vector value of the error done
        on the functions at the root.
        Exception NotDone is raised if the root was not found.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _math.math_FunctionSetRoot_FunctionSetErrors(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Dump(self, *args):
        """
        Dump(math_FunctionSetRoot self, Standard_OStream & o)

        Prints on the stream o information on the current state
        of the object.
        Is used to redefine the operator <<.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_FunctionSetRoot_Dump(self, *args)


    def IsDivergent(self, *args):
        """
        IsDivergent(math_FunctionSetRoot self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_FunctionSetRoot_IsDivergent(self, *args)

    __swig_destroy__ = _math.delete_math_FunctionSetRoot
math_FunctionSetRoot_swigregister = _math.math_FunctionSetRoot_swigregister
math_FunctionSetRoot_swigregister(math_FunctionSetRoot)

class math_NewtonMinimum(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_NewtonMinimum self, math_MultipleVarFunctionWithHessian theFunction, Standard_Real const theTolerance, Standard_Integer const theNbIterations=40, Standard_Real const theConvexity=1.0e-6, Standard_Boolean const theWithSingularity) -> math_NewtonMinimum

        The tolerance required on the solution is given by Tolerance.
        Iteration are  stopped if (!WithSingularity) and H(F(Xi)) is not definite
        positive (if the smaller eigenvalue of H < Convexity)
        or IsConverged() returns True for 2 successives Iterations.
        Warning: This constructor does not perform computation.

        :type theFunction: OCC.wrapper.math.math_MultipleVarFunctionWithHessian
        :type theTolerance: float
        :type theNbIterations: int
        :type theConvexity: float
        :type theWithSingularity: bool

        """
        this = _math.new_math_NewtonMinimum(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(math_NewtonMinimum self, math_MultipleVarFunctionWithHessian theFunction, math_Vector theStartingPoint)

        Search the solution.

        :type theFunction: OCC.wrapper.math.math_MultipleVarFunctionWithHessian
        :type theStartingPoint: OCC.wrapper.math.math_Vector

        """
        return _math.math_NewtonMinimum_Perform(self, *args)


    def IsConverged(self, *args):
        """
        IsConverged(math_NewtonMinimum self) -> Standard_Boolean

        This method is called at the end of each iteration to check the convergence:
        || Xi+1 - Xi || < Tolerance or || F(Xi+1) - F(Xi)|| < Tolerance * || F(Xi) ||
        It can be redefined in a sub-class to implement a specific test.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_NewtonMinimum_IsConverged(self, *args)


    def IsDone(self, *args):
        """
        IsDone(math_NewtonMinimum self) -> Standard_Boolean

        Tests if an error has occured.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_NewtonMinimum_IsDone(self, *args)


    def Location(self, *args):
        """
        returns the location vector of the minimum.
        Exception NotDone is raised if an error has occured.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _math.math_NewtonMinimum_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetBoundary(self, *args):
        """
        SetBoundary(math_NewtonMinimum self, math_Vector theLeftBorder, math_Vector theRightBorder)

        Set boundaries.

        :type theLeftBorder: OCC.wrapper.math.math_Vector
        :type theRightBorder: OCC.wrapper.math.math_Vector

        """
        return _math.math_NewtonMinimum_SetBoundary(self, *args)


    def Minimum(self, *args):
        """
        Minimum(math_NewtonMinimum self) -> Standard_Real

        returns the value of the minimum.
        Exception NotDone is raised if the minimum was not found.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_NewtonMinimum_Minimum(self, *args)


    def Gradient(self, *args):
        """
        returns the gradient vector at the minimum.
        Exception NotDone is raised if an error has occured.the minimum was not found.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _math.math_NewtonMinimum_Gradient(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbIterations(self, *args):
        """
        NbIterations(math_NewtonMinimum self) -> Standard_Integer

        returns the number of iterations really done in the
        calculation of the minimum.
        The exception NotDone is raised if an error has occured.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_NewtonMinimum_NbIterations(self, *args)


    def GetStatus(self, *args):
        """
        GetStatus(math_NewtonMinimum self) -> math_Status

        Returns the Status of computation.
        The exception NotDone is raised if an error has occured.

        :rtype: OCC.wrapper.math.math_Status

        """
        return _math.math_NewtonMinimum_GetStatus(self, *args)


    def Dump(self, *args):
        """
        Dump(math_NewtonMinimum self, Standard_OStream & o)

        Prints on the stream o information on the current state
        of the object.
        Is used to redefine the operator <<.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_NewtonMinimum_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_NewtonMinimum
math_NewtonMinimum_swigregister = _math.math_NewtonMinimum_swigregister
math_NewtonMinimum_swigregister(math_NewtonMinimum)

class math_Function(object):
    """
    This abstract class describes the virtual functions
    associated with a Function of a single variable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Value(self, *args):
        """
        Value(math_Function self, Standard_Real const X) -> Standard_Boolean

        Computes the value of the function <F> for a given value of
        variable <X>.
        returns True if the computation was done successfully,
        False otherwise.

        :type X: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_Function_Value(self, *args)


    def GetStateNumber(self, *args):
        """
        GetStateNumber(math_Function self) -> Standard_Integer

        returns the state of the function corresponding to the
        latest call of any methods associated with the function.
        This function is called by each of the algorithms
        described later which defined the function Integer
        Algorithm::StateNumber(). The algorithm has the
        responsibility to call this function when it has found
        a solution (i.e. a root or a minimum) and has to maintain
        the association between the solution found and this
        StateNumber.
        Byu default, this method returns 0 (which means for the
        algorithm: no state has been saved). It is the
        responsibility of the programmer to decide if he needs
        to save the current state of the function and to return
        an Integer that allows retrieval of the state.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_Function_GetStateNumber(self, *args)

    __swig_destroy__ = _math.delete_math_Function
math_Function_swigregister = _math.math_Function_swigregister
math_Function_swigregister(math_Function)

class math_BrentMinimum(object):
    """
    This class implements the Brent's method to find the minimum of
    a function of a single variable.
    No knowledge of the derivative is required.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_BrentMinimum self, Standard_Real const TolX, Standard_Integer const NbIterations=100, Standard_Real const ZEPS=1.0e-12) -> math_BrentMinimum
        __init__(math_BrentMinimum self, Standard_Real const TolX, Standard_Real const Fbx, Standard_Integer const NbIterations=100, Standard_Real const ZEPS=1.0e-12) -> math_BrentMinimum

        This constructor should be used in a sub-class to initialize
        correctly all the fields of this class.
        It has to be used if F(Bx) is known.

        :type TolX: float
        :type Fbx: float
        :type NbIterations: int
        :type ZEPS: float

        """
        this = _math.new_math_BrentMinimum(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(math_BrentMinimum self, math_Function F, Standard_Real const Ax, Standard_Real const Bx, Standard_Real const Cx)

        Brent minimization is performed on function F from a given
        bracketing triplet of abscissas Ax, Bx, Cx (such that Bx is
        between Ax and Cx, F(Bx) is less than both F(Bx) and F(Cx))
        The solution is found when: abs(Xi - Xi-1) <= TolX * abs(Xi) + ZEPS;

        :type F: OCC.wrapper.math.math_Function
        :type Ax: float
        :type Bx: float
        :type Cx: float

        """
        return _math.math_BrentMinimum_Perform(self, *args)


    def IsSolutionReached(self, *args):
        """
        IsSolutionReached(math_BrentMinimum self, math_Function theFunction) -> Standard_Boolean

        This method is called at the end of each iteration to check if the
        solution is found.
        It can be redefined in a sub-class to implement a specific test to
        stop the iterations.

        :type theFunction: OCC.wrapper.math.math_Function
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_BrentMinimum_IsSolutionReached(self, *args)


    def IsDone(self, *args):
        """
        IsDone(math_BrentMinimum self) -> Standard_Boolean

        Returns true if the computations are successful, otherwise returns false.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_BrentMinimum_IsDone(self, *args)


    def Location(self, *args):
        """
        Location(math_BrentMinimum self) -> Standard_Real

        returns the location value of the minimum.
        Exception NotDone is raised if the minimum was not found.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_BrentMinimum_Location(self, *args)


    def Minimum(self, *args):
        """
        Minimum(math_BrentMinimum self) -> Standard_Real

        returns the value of the minimum.
        Exception NotDone is raised if the minimum was not found.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_BrentMinimum_Minimum(self, *args)


    def NbIterations(self, *args):
        """
        NbIterations(math_BrentMinimum self) -> Standard_Integer

        returns the number of iterations really done during the
        computation of the minimum.
        Exception NotDone is raised if the minimum was not found.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_BrentMinimum_NbIterations(self, *args)


    def Dump(self, *args):
        """
        Dump(math_BrentMinimum self, Standard_OStream & o)

        Prints on the stream o information on the current state
        of the object.
        Is used to redefine the operator <<.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_BrentMinimum_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_BrentMinimum
math_BrentMinimum_swigregister = _math.math_BrentMinimum_swigregister
math_BrentMinimum_swigregister(math_BrentMinimum)

class math_BullardGenerator(object):
    """Fast random number generator (the algorithm proposed by Ian C. Bullard)."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_BullardGenerator self, unsigned int theSeed=1) -> math_BullardGenerator

        Creates new Xorshift 64-bit RNG.

        :type theSeed: unsigned int

        """
        this = _math.new_math_BullardGenerator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetSeed(self, *args):
        """
        SetSeed(math_BullardGenerator self, unsigned int theSeed=1)

        Setup new seed / reset defaults.

        :type theSeed: unsigned int

        """
        return _math.math_BullardGenerator_SetSeed(self, *args)


    def NextInt(self, *args):
        """
        NextInt(math_BullardGenerator self) -> unsigned int

        Generates new 64-bit integer value.

        :rtype: unsigned int

        """
        return _math.math_BullardGenerator_NextInt(self, *args)


    def NextReal(self, *args):
        """
        NextReal(math_BullardGenerator self) -> Standard_Real

        Generates new floating-point value.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_BullardGenerator_NextReal(self, *args)

    __swig_destroy__ = _math.delete_math_BullardGenerator
math_BullardGenerator_swigregister = _math.math_BullardGenerator_swigregister
math_BullardGenerator_swigregister(math_BullardGenerator)

class math_TrigonometricFunctionRoots(object):
    """
    This class implements the solutions of the equation
    a*Cos(x)*Cos(x) + 2*b*Cos(x)*Sin(x) + c*Cos(x) + d*Sin(x) + e
    The degree of this equation can be 4, 3 or 2.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_TrigonometricFunctionRoots self, Standard_Real const A, Standard_Real const B, Standard_Real const C, Standard_Real const D, Standard_Real const E, Standard_Real const InfBound, Standard_Real const SupBound) -> math_TrigonometricFunctionRoots
        __init__(math_TrigonometricFunctionRoots self, Standard_Real const D, Standard_Real const E, Standard_Real const InfBound, Standard_Real const SupBound) -> math_TrigonometricFunctionRoots
        __init__(math_TrigonometricFunctionRoots self, Standard_Real const C, Standard_Real const D, Standard_Real const E, Standard_Real const InfBound, Standard_Real const SupBound) -> math_TrigonometricFunctionRoots

        Given the three coefficients c, d and e, it performs
        the resolution of c*Cos(x) + d*sin(x) + e = 0.
        The solutions must be contained in [InfBound, SupBound].
        InfBound and SupBound can be set by default to 0 and 2*PI.

        :type C: float
        :type D: float
        :type E: float
        :type InfBound: float
        :type SupBound: float

        """
        this = _math.new_math_TrigonometricFunctionRoots(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(math_TrigonometricFunctionRoots self) -> Standard_Boolean

        Returns true if the computations are successful, otherwise returns false.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_TrigonometricFunctionRoots_IsDone(self, *args)


    def InfiniteRoots(self, *args):
        """
        InfiniteRoots(math_TrigonometricFunctionRoots self) -> Standard_Boolean

        Returns true if there is an infinity of roots, otherwise returns false.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_TrigonometricFunctionRoots_InfiniteRoots(self, *args)


    def Value(self, *args):
        """
        Value(math_TrigonometricFunctionRoots self, Standard_Integer const Index) -> Standard_Real

        Returns the solution of range Index.
        An exception is raised if NotDone.
        An exception is raised if Index>NbSolutions.
        An exception is raised if there is an infinity of solutions.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_TrigonometricFunctionRoots_Value(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(math_TrigonometricFunctionRoots self) -> Standard_Integer

        Returns the number of solutions found.
        An exception is raised if NotDone.
        An exception is raised if there is an infinity of solutions.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_TrigonometricFunctionRoots_NbSolutions(self, *args)


    def Dump(self, *args):
        """
        Dump(math_TrigonometricFunctionRoots self, Standard_OStream & o)

        Prints information on the current state of the object.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_TrigonometricFunctionRoots_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_TrigonometricFunctionRoots
math_TrigonometricFunctionRoots_swigregister = _math.math_TrigonometricFunctionRoots_swigregister
math_TrigonometricFunctionRoots_swigregister(math_TrigonometricFunctionRoots)

class math_GaussSingleIntegration(object):
    """
    This class implements the integration of a function of a single variable
    between the parameter bounds Lower and Upper.
    Warning: Order must be inferior or equal to 61.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_GaussSingleIntegration self) -> math_GaussSingleIntegration
        __init__(math_GaussSingleIntegration self, math_Function F, Standard_Real const Lower, Standard_Real const Upper, Standard_Integer const Order) -> math_GaussSingleIntegration
        __init__(math_GaussSingleIntegration self, math_Function F, Standard_Real const Lower, Standard_Real const Upper, Standard_Integer const Order, Standard_Real const Tol) -> math_GaussSingleIntegration

        The Gauss-Legendre integration with N = Order points of integration  and
        given tolerance = Tol is done on the function F between the bounds
        Lower and Upper.

        :type F: OCC.wrapper.math.math_Function
        :type Lower: float
        :type Upper: float
        :type Order: int
        :type Tol: float

        """
        this = _math.new_math_GaussSingleIntegration(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(math_GaussSingleIntegration self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_GaussSingleIntegration_IsDone(self, *args)


    def Value(self, *args):
        """
        Value(math_GaussSingleIntegration self) -> Standard_Real

        returns the value of the integral.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_GaussSingleIntegration_Value(self, *args)


    def Dump(self, *args):
        """
        Dump(math_GaussSingleIntegration self, Standard_OStream & o)

        Prints information on the current state of the object.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_GaussSingleIntegration_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_GaussSingleIntegration
math_GaussSingleIntegration_swigregister = _math.math_GaussSingleIntegration_swigregister
math_GaussSingleIntegration_swigregister(math_GaussSingleIntegration)

class math_DirectPolynomialRoots(object):
    """
    This class implements the calculation of all the real roots of a real
    polynomial of degree <= 4 using a direct method. Once found,
    the roots are polished using the Newton method.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_DirectPolynomialRoots self, Standard_Real const A, Standard_Real const B, Standard_Real const C, Standard_Real const D, Standard_Real const E) -> math_DirectPolynomialRoots
        __init__(math_DirectPolynomialRoots self, Standard_Real const A, Standard_Real const B, Standard_Real const C, Standard_Real const D) -> math_DirectPolynomialRoots
        __init__(math_DirectPolynomialRoots self, Standard_Real const A, Standard_Real const B, Standard_Real const C) -> math_DirectPolynomialRoots
        __init__(math_DirectPolynomialRoots self, Standard_Real const A, Standard_Real const B) -> math_DirectPolynomialRoots

        computes the real root of the polynomial Ax + B.

        :type A: float
        :type B: float

        """
        this = _math.new_math_DirectPolynomialRoots(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(math_DirectPolynomialRoots self) -> Standard_Boolean

        Returns true if the computations are successful, otherwise returns false.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_DirectPolynomialRoots_IsDone(self, *args)


    def InfiniteRoots(self, *args):
        """
        InfiniteRoots(math_DirectPolynomialRoots self) -> Standard_Boolean

        Returns true if there is an infinity of roots, otherwise returns false.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_DirectPolynomialRoots_InfiniteRoots(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(math_DirectPolynomialRoots self) -> Standard_Integer

        returns the number of solutions.
        An exception is raised if there are an infinity of roots.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_DirectPolynomialRoots_NbSolutions(self, *args)


    def Value(self, *args):
        """
        Value(math_DirectPolynomialRoots self, Standard_Integer const Nieme) -> Standard_Real

        returns the value of the Nieme root.
        An exception is raised if there are an infinity of roots.
        Exception RangeError is raised if Nieme is < 1
        or Nieme > NbSolutions.

        :type Nieme: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_DirectPolynomialRoots_Value(self, *args)


    def Dump(self, *args):
        """
        Dump(math_DirectPolynomialRoots self, Standard_OStream & o)

        Prints on the stream o information on the current state
        of the object.
        Is used to redefine the operator <<.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_DirectPolynomialRoots_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_DirectPolynomialRoots
math_DirectPolynomialRoots_swigregister = _math.math_DirectPolynomialRoots_swigregister
math_DirectPolynomialRoots_swigregister(math_DirectPolynomialRoots)

class math_BracketMinimum(object):
    """
    Given two distinct initial points, BracketMinimum
    implements the computation of three points (a, b, c) which
    bracket the minimum of the function and verify A less than
    B, B less than C and F(B) less than F(A), F(B) less than F(C).

    The algorithm supports conditional optimization. By default no limits are
    applied to the parameter change. The method SetLimits defines the allowed range.
    If no minimum is found in limits then IsDone() will return false. The user
    is in charge of providing A and B to be in limits.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_BracketMinimum self, Standard_Real const A, Standard_Real const B) -> math_BracketMinimum
        __init__(math_BracketMinimum self, math_Function F, Standard_Real const A, Standard_Real const B) -> math_BracketMinimum
        __init__(math_BracketMinimum self, math_Function F, Standard_Real const A, Standard_Real const B, Standard_Real const FA) -> math_BracketMinimum
        __init__(math_BracketMinimum self, math_Function F, Standard_Real const A, Standard_Real const B, Standard_Real const FA, Standard_Real const FB) -> math_BracketMinimum

        Given two initial values this class computes a
        bracketing triplet of abscissae Ax, Bx, Cx
        (such that Bx is between Ax and Cx, F(Bx) is
        less than both F(Bx) and F(Cx)) the Brent minimization is done
        on the function F.
        This constructor has to be used if F(A) and F(B) are known.

        :type F: OCC.wrapper.math.math_Function
        :type A: float
        :type B: float
        :type FA: float
        :type FB: float

        """
        this = _math.new_math_BracketMinimum(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetLimits(self, *args):
        """
        SetLimits(math_BracketMinimum self, Standard_Real const theLeft, Standard_Real const theRight)

        Set limits of the parameter. By default no limits are applied to the parameter change.
        If no minimum is found in limits then IsDone() will return false. The user
        is in charge of providing A and B to be in limits.

        :type theLeft: float
        :type theRight: float

        """
        return _math.math_BracketMinimum_SetLimits(self, *args)


    def SetFA(self, *args):
        """
        SetFA(math_BracketMinimum self, Standard_Real const theValue)

        Set function value at A

        :type theValue: float

        """
        return _math.math_BracketMinimum_SetFA(self, *args)


    def SetFB(self, *args):
        """
        SetFB(math_BracketMinimum self, Standard_Real const theValue)

        Set function value at B

        :type theValue: float

        """
        return _math.math_BracketMinimum_SetFB(self, *args)


    def Perform(self, *args):
        """
        Perform(math_BracketMinimum self, math_Function F)

        The method performing the job. It is called automatically by constructors with the function.

        :type F: OCC.wrapper.math.math_Function

        """
        return _math.math_BracketMinimum_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(math_BracketMinimum self) -> Standard_Boolean

        Returns true if the computations are successful, otherwise returns false.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_BracketMinimum_IsDone(self, *args)


    def Values(self, *args):
        """
        Values(math_BracketMinimum self)

        Returns the bracketed triplet of abscissae.
        Exceptions
        StdFail_NotDone if the algorithm fails (and IsDone returns false).

        :type A: float
        :type B: float
        :type C: float

        """
        return _math.math_BracketMinimum_Values(self, *args)


    def FunctionValues(self, *args):
        """
        FunctionValues(math_BracketMinimum self)

        returns the bracketed triplet function values.
        Exceptions
        StdFail_NotDone if the algorithm fails (and IsDone returns false).

        :type FA: float
        :type FB: float
        :type FC: float

        """
        return _math.math_BracketMinimum_FunctionValues(self, *args)


    def Dump(self, *args):
        """
        Dump(math_BracketMinimum self, Standard_OStream & o)

        Prints on the stream o information on the current state
        of the object.
        Is used to redefine the operator <<.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_BracketMinimum_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_BracketMinimum
math_BracketMinimum_swigregister = _math.math_BracketMinimum_swigregister
math_BracketMinimum_swigregister(math_BracketMinimum)

class math_NotSquare(Standard.Standard_DimensionError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_math_NotSquare
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_math_NotSquare(self) 
            return h


    def __init__(self, *args):
        """
        __init__(math_NotSquare self) -> math_NotSquare
        __init__(math_NotSquare self, Standard_CString const theMessage) -> math_NotSquare

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _math.new_math_NotSquare(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_math_NotSquare

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.math.Handle_math_NotSquare

        """
        return _math.math_NotSquare_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _math.math_NotSquare_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _math.math_NotSquare_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _math.math_NotSquare_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _math.delete_math_NotSquare
math_NotSquare_swigregister = _math.math_NotSquare_swigregister
math_NotSquare_swigregister(math_NotSquare)

def math_NotSquare_NewInstance(*args):
    """
    math_NotSquare_NewInstance(Standard_CString const theMessage) -> Handle_math_NotSquare

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.math.Handle_math_NotSquare

    """
    return _math.math_NotSquare_NewInstance(*args)

def math_NotSquare_get_type_name(*args):
    """
    math_NotSquare_get_type_name() -> char const *

    :rtype: const char *

    """
    return _math.math_NotSquare_get_type_name(*args)

def math_NotSquare_get_type_descriptor(*args):
    """
    math_NotSquare_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _math.math_NotSquare_get_type_descriptor(*args)

class math_IntegerVector(object):
    """
    This class implements the real IntegerVector abstract data type.
    IntegerVectors can have an arbitrary range which must be define at
    the declaration and cannot be changed after this declaration.
    Example:
    @code
    math_IntegerVector V1(-3, 5); // an IntegerVector with range [-3..5]
    @endcode

    IntegerVector is copied through assignement :
    @code
    math_IntegerVector V2( 1, 9);
    ....
    V2 = V1;
    V1(1) = 2.0; // the IntegerVector V2 will not be modified.
    @endcode

    The Exception RangeError is raised when trying to access outside
    the range of an IntegerVector :
    @code
    V1(11) = 0 // --> will raise RangeError;
    @endcode

    The Exception DimensionError is raised when the dimensions of two
    IntegerVectors are not compatible :
    @code
    math_IntegerVector V3(1, 2);
    V3 = V1;    // --> will raise DimensionError;
    V1.Add(V3)  // --> will raise DimensionError;
    @endcode
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Init(self, *args):
        """
        Init(math_IntegerVector self, Standard_Integer const theInitialValue)

        Initialize an IntegerVector with all the elements
        set to theInitialValue.

        :type theInitialValue: int

        """
        return _math.math_IntegerVector_Init(self, *args)


    def __init__(self, *args):
        """
        __init__(math_IntegerVector self, Standard_Integer const theFirst, Standard_Integer const theLast) -> math_IntegerVector
        __init__(math_IntegerVector self, Standard_Integer const theFirst, Standard_Integer const theLast, Standard_Integer const theInitialValue) -> math_IntegerVector
        __init__(math_IntegerVector self, Standard_Address const theTab, Standard_Integer const theFirst, Standard_Integer const theLast) -> math_IntegerVector
        __init__(math_IntegerVector self, math_IntegerVector theOther) -> math_IntegerVector

        constructs a copy for initialization.
        An exception is raised if the lengths of the IntegerVectors
        are different.

        :type theOther: OCC.wrapper.math.math_IntegerVector

        """
        this = _math.new_math_IntegerVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(math_IntegerVector self) -> Standard_Integer

        returns the length of an IntegerVector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_IntegerVector_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(math_IntegerVector self) -> Standard_Integer

        returns the value of the Lower index of an IntegerVector.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_IntegerVector_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(math_IntegerVector self) -> Standard_Integer

        returns the value of the Upper index of an IntegerVector.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_IntegerVector_Upper(self, *args)


    def Norm(self, *args):
        """
        Norm(math_IntegerVector self) -> Standard_Real

        returns the value of the norm of an IntegerVector.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_IntegerVector_Norm(self, *args)


    def Norm2(self, *args):
        """
        Norm2(math_IntegerVector self) -> Standard_Real

        returns the value of the square of the norm of an IntegerVector.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_IntegerVector_Norm2(self, *args)


    def Max(self, *args):
        """
        Max(math_IntegerVector self) -> Standard_Integer

        returns the value of the Index of the maximum element of an IntegerVector.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_IntegerVector_Max(self, *args)


    def Min(self, *args):
        """
        Min(math_IntegerVector self) -> Standard_Integer

        returns the value of the Index of the minimum element of an IntegerVector.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_IntegerVector_Min(self, *args)


    def Invert(self, *args):
        """
        Invert(math_IntegerVector self)

        inverses an IntegerVector.


        """
        return _math.math_IntegerVector_Invert(self, *args)


    def Inverse(self, *args):
        """
        Inverse(math_IntegerVector self) -> math_IntegerVector

        returns the inverse IntegerVector of an IntegerVector.

        :rtype: OCC.wrapper.math.math_IntegerVector

        """
        return _math.math_IntegerVector_Inverse(self, *args)


    def Set(self, *args):
        """
        Set(math_IntegerVector self, Standard_Integer const theI1, Standard_Integer const theI2, math_IntegerVector theV)

        sets an IntegerVector from "theI1" to "theI2" to the IntegerVector "theV";
        An exception is raised if "theI1" is less than "LowerIndex" or "theI2" is greater than "UpperIndex" or "theI1" is greater than "theI2".
        An exception is raised if "theI2-theI1+1" is different from the Length of "theV".

        :type theI1: int
        :type theI2: int
        :type theV: OCC.wrapper.math.math_IntegerVector

        """
        return _math.math_IntegerVector_Set(self, *args)


    def Slice(self, *args):
        """
        Slice(math_IntegerVector self, Standard_Integer const theI1, Standard_Integer const theI2) -> math_IntegerVector

        slices the values of the IntegerVector between "theI1" and "theI2":
        Example: [2, 1, 2, 3, 4, 5] becomes [2, 4, 3, 2, 1, 5] between 2 and 5.
        An exception is raised if "theI1" is less than "LowerIndex" or "theI2" is greater than "UpperIndex".

        :type theI1: int
        :type theI2: int
        :rtype: OCC.wrapper.math.math_IntegerVector

        """
        return _math.math_IntegerVector_Slice(self, *args)


    def __imul__(self, *args):
        """
        __imul__(math_IntegerVector self, Standard_Integer const theRight)

        :type theRight: int

        """
        return _math.math_IntegerVector___imul__(self, *args)


    def TMultiplied(self, *args):
        """
        TMultiplied(math_IntegerVector self, Standard_Integer const theRight) -> math_IntegerVector

        returns the product of a vector and a real value.

        :type theRight: int
        :rtype: OCC.wrapper.math.math_IntegerVector

        """
        return _math.math_IntegerVector_TMultiplied(self, *args)


    def __iadd__(self, *args):
        """
        __iadd__(math_IntegerVector self, math_IntegerVector theRight)

        :type theRight: OCC.wrapper.math.math_IntegerVector

        """
        return _math.math_IntegerVector___iadd__(self, *args)


    def Added(self, *args):
        """
        Added(math_IntegerVector self, math_IntegerVector theRight) -> math_IntegerVector

        adds the IntegerVector "theRight" to an IntegerVector.
        An exception is raised if the IntegerVectors have not the same length.
        An exception is raised if the lengths are not equal.

        :type theRight: OCC.wrapper.math.math_IntegerVector
        :rtype: OCC.wrapper.math.math_IntegerVector

        """
        return _math.math_IntegerVector_Added(self, *args)


    def __add__(self, *args):
        """
        __add__(math_IntegerVector self, math_IntegerVector theRight) -> math_IntegerVector

        :type theRight: OCC.wrapper.math.math_IntegerVector
        :rtype: OCC.wrapper.math.math_IntegerVector

        """
        return _math.math_IntegerVector___add__(self, *args)


    def Add(self, *args):
        """
        Add(math_IntegerVector self, math_IntegerVector theRight)
        Add(math_IntegerVector self, math_IntegerVector theLeft, math_IntegerVector theRight)

        sets an IntegerVector to the sum of the IntegerVector
        "theLeft" and the IntegerVector "theRight".
        An exception is raised if the lengths are different.

        :type theLeft: OCC.wrapper.math.math_IntegerVector
        :type theRight: OCC.wrapper.math.math_IntegerVector

        """
        return _math.math_IntegerVector_Add(self, *args)


    def Value(self, *args):
        """
        Value(math_IntegerVector self, Standard_Integer const theNum) -> Standard_Integer &

        accesses (in read or write mode) the value of index theNum of an IntegerVector.

        :type theNum: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_IntegerVector_Value(self, *args)


    def __call__(self, *args):
        """
        __call__(math_IntegerVector self, Standard_Integer const theNum) -> Standard_Integer &

        :type theNum: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_IntegerVector___call__(self, *args)


    def Initialized(self, *args):
        """
        Initialized(math_IntegerVector self, math_IntegerVector theOther) -> math_IntegerVector

        Initialises an IntegerVector by copying "theOther".
        An exception is raised if the Lengths are different.

        :type theOther: OCC.wrapper.math.math_IntegerVector
        :rtype: OCC.wrapper.math.math_IntegerVector

        """
        return _math.math_IntegerVector_Initialized(self, *args)


    def assign(self, *args):
        """
        assign(math_IntegerVector self, math_IntegerVector theOther) -> math_IntegerVector

        :type theOther: OCC.wrapper.math.math_IntegerVector
        :rtype: OCC.wrapper.math.math_IntegerVector

        """
        return _math.math_IntegerVector_assign(self, *args)


    def Multiplied(self, *args):
        """
        Multiplied(math_IntegerVector self, Standard_Integer const theRight) -> math_IntegerVector
        Multiplied(math_IntegerVector self, math_IntegerVector theRight) -> Standard_Integer

        returns the inner product of 2 IntegerVectors.
        An exception is raised if the lengths are not equal.

        :type theRight: OCC.wrapper.math.math_IntegerVector
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_IntegerVector_Multiplied(self, *args)


    def __mul__(self, *args):
        """
        __mul__(math_IntegerVector self, Standard_Integer const theRight) -> math_IntegerVector
        __mul__(math_IntegerVector self, math_IntegerVector theRight) -> Standard_Integer

        :type theRight: OCC.wrapper.math.math_IntegerVector
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_IntegerVector___mul__(self, *args)


    def Opposite(self, *args):
        """
        Opposite(math_IntegerVector self) -> math_IntegerVector

        returns the opposite of an IntegerVector.

        :rtype: OCC.wrapper.math.math_IntegerVector

        """
        return _math.math_IntegerVector_Opposite(self, *args)


    def __neg__(self, *args):
        """
        __neg__(math_IntegerVector self) -> math_IntegerVector

        :rtype: OCC.wrapper.math.math_IntegerVector

        """
        return _math.math_IntegerVector___neg__(self, *args)


    def Subtract(self, *args):
        """
        Subtract(math_IntegerVector self, math_IntegerVector theLeft, math_IntegerVector theRight)
        Subtract(math_IntegerVector self, math_IntegerVector theRight)

        returns the subtraction of "theRight" from "me".
        An exception is raised if the IntegerVectors have not the same length.

        :type theRight: OCC.wrapper.math.math_IntegerVector

        """
        return _math.math_IntegerVector_Subtract(self, *args)


    def __isub__(self, *args):
        """
        __isub__(math_IntegerVector self, math_IntegerVector theRight)

        :type theRight: OCC.wrapper.math.math_IntegerVector

        """
        return _math.math_IntegerVector___isub__(self, *args)


    def Subtracted(self, *args):
        """
        Subtracted(math_IntegerVector self, math_IntegerVector theRight) -> math_IntegerVector

        returns the subtraction of "theRight" from "me".
        An exception is raised if the IntegerVectors have not the same length.

        :type theRight: OCC.wrapper.math.math_IntegerVector
        :rtype: OCC.wrapper.math.math_IntegerVector

        """
        return _math.math_IntegerVector_Subtracted(self, *args)


    def __sub__(self, *args):
        """
        __sub__(math_IntegerVector self, math_IntegerVector theRight) -> math_IntegerVector

        :type theRight: OCC.wrapper.math.math_IntegerVector
        :rtype: OCC.wrapper.math.math_IntegerVector

        """
        return _math.math_IntegerVector___sub__(self, *args)


    def Multiply(self, *args):
        """
        Multiply(math_IntegerVector self, Standard_Integer const theRight)
        Multiply(math_IntegerVector self, Standard_Integer const theLeft, math_IntegerVector theRight)

        returns the multiplication of an integer by an IntegerVector.

        :type theLeft: int
        :type theRight: OCC.wrapper.math.math_IntegerVector

        """
        return _math.math_IntegerVector_Multiply(self, *args)


    def Dump(self, *args):
        """
        Dump(math_IntegerVector self, Standard_OStream & theO)

        Prints on the stream theO information on the current state of the object.
        Is used to redefine the operator <<.

        :type theO: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_IntegerVector_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_IntegerVector
math_IntegerVector_swigregister = _math.math_IntegerVector_swigregister
math_IntegerVector_swigregister(math_IntegerVector)

class math_NewtonFunctionRoot(object):
    """
    This class implements the calculation of a root of a function of
    a single variable starting from an initial near guess using the
    Newton algorithm. Knowledge of the derivative is required.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_NewtonFunctionRoot self, math_FunctionWithDerivative F, Standard_Real const Guess, Standard_Real const EpsX, Standard_Real const EpsF, Standard_Integer const NbIterations=100) -> math_NewtonFunctionRoot
        __init__(math_NewtonFunctionRoot self, math_FunctionWithDerivative F, Standard_Real const Guess, Standard_Real const EpsX, Standard_Real const EpsF, Standard_Real const A, Standard_Real const B, Standard_Integer const NbIterations=100) -> math_NewtonFunctionRoot
        __init__(math_NewtonFunctionRoot self, Standard_Real const A, Standard_Real const B, Standard_Real const EpsX, Standard_Real const EpsF, Standard_Integer const NbIterations=100) -> math_NewtonFunctionRoot

        is used in a sub-class to initialize correctly all the fields
        of this class.

        :type A: float
        :type B: float
        :type EpsX: float
        :type EpsF: float
        :type NbIterations: int

        """
        this = _math.new_math_NewtonFunctionRoot(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(math_NewtonFunctionRoot self, math_FunctionWithDerivative F, Standard_Real const Guess)

        is used internally by the constructors.

        :type F: OCC.wrapper.math.math_FunctionWithDerivative
        :type Guess: float

        """
        return _math.math_NewtonFunctionRoot_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(math_NewtonFunctionRoot self) -> Standard_Boolean

        Returns true if the computations are successful, otherwise returns false.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_NewtonFunctionRoot_IsDone(self, *args)


    def Root(self, *args):
        """
        Root(math_NewtonFunctionRoot self) -> Standard_Real

        Returns the value of the root of function <F>.
        Exception NotDone is raised if the root was not found.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_NewtonFunctionRoot_Root(self, *args)


    def Derivative(self, *args):
        """
        Derivative(math_NewtonFunctionRoot self) -> Standard_Real

        returns the value of the derivative at the root.
        Exception NotDone is raised if the root was not found.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_NewtonFunctionRoot_Derivative(self, *args)


    def Value(self, *args):
        """
        Value(math_NewtonFunctionRoot self) -> Standard_Real

        returns the value of the function at the root.
        Exception NotDone is raised if the root was not found.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_NewtonFunctionRoot_Value(self, *args)


    def NbIterations(self, *args):
        """
        NbIterations(math_NewtonFunctionRoot self) -> Standard_Integer

        Returns the number of iterations really done on the
        computation of the Root.
        Exception NotDone is raised if the root was not found.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_NewtonFunctionRoot_NbIterations(self, *args)


    def Dump(self, *args):
        """
        Dump(math_NewtonFunctionRoot self, Standard_OStream & o)

        Prints information on the current state of the object.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_NewtonFunctionRoot_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_NewtonFunctionRoot
math_NewtonFunctionRoot_swigregister = _math.math_NewtonFunctionRoot_swigregister
math_NewtonFunctionRoot_swigregister(math_NewtonFunctionRoot)

class math_MultipleVarFunction(object):
    """Describes the virtual functions associated with a multiple variable function."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def NbVariables(self, *args):
        """
        NbVariables(math_MultipleVarFunction self) -> Standard_Integer

        Returns the number of variables of the function

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_MultipleVarFunction_NbVariables(self, *args)


    def Value(self, *args):
        """
        Value(math_MultipleVarFunction self, math_Vector X) -> Standard_Boolean

        Computes the values of the Functions <F> for the
        variable <X>.
        returns True if the computation was done successfully,
        otherwise false.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_MultipleVarFunction_Value(self, *args)


    def GetStateNumber(self, *args):
        """
        GetStateNumber(math_MultipleVarFunction self) -> Standard_Integer

        return the state of the function corresponding to the latestt
        call of any methods associated to the function. This
        function is called by each of the algorithms described
        later which define the function Integer
        Algorithm::StateNumber(). The algorithm has the
        responsibility to call this function when it has found
        a solution (i.e. a root or a minimum) and has to maintain
        the association between the solution found and this
        StateNumber.
        Byu default, this method returns 0 (which means for the
        algorithm: no state has been saved). It is the
        responsibility of the programmer to decide if he needs
        to save the current state of the function and to return
        an Integer that allows retrieval of the state.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_MultipleVarFunction_GetStateNumber(self, *args)

    __swig_destroy__ = _math.delete_math_MultipleVarFunction
math_MultipleVarFunction_swigregister = _math.math_MultipleVarFunction_swigregister
math_MultipleVarFunction_swigregister(math_MultipleVarFunction)

class math_BissecNewton(object):
    """
    This class implements a combination of Newton-Raphson and bissection
    methods to find the root of the function between two bounds.
    Knowledge of the derivative is required.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_BissecNewton self, Standard_Real const theXTolerance) -> math_BissecNewton

        Constructor.
        @param theXTolerance - algorithm tolerance.

        :type theXTolerance: float

        """
        this = _math.new_math_BissecNewton(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(math_BissecNewton self, math_FunctionWithDerivative F, Standard_Real const Bound1, Standard_Real const Bound2, Standard_Integer const NbIterations=100)

        A combination of Newton-Raphson and bissection methods is done to find
        the root of the function F between the bounds Bound1 and Bound2
        on the function F.
        The tolerance required on the root is given by TolX.
        The solution is found when:
        abs(Xi - Xi-1) <= TolX and F(Xi) * F(Xi-1) <= 0
        The maximum number of iterations allowed is given by NbIterations.

        :type F: OCC.wrapper.math.math_FunctionWithDerivative
        :type Bound1: float
        :type Bound2: float
        :type NbIterations: int

        """
        return _math.math_BissecNewton_Perform(self, *args)


    def IsSolutionReached(self, *args):
        """
        IsSolutionReached(math_BissecNewton self, math_FunctionWithDerivative theFunction) -> Standard_Boolean

        This method is called at the end of each iteration to check if the
        solution has been found.
        It can be redefined in a sub-class to implement a specific test to
        stop the iterations.

        :type theFunction: OCC.wrapper.math.math_FunctionWithDerivative
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_BissecNewton_IsSolutionReached(self, *args)


    def IsDone(self, *args):
        """
        IsDone(math_BissecNewton self) -> Standard_Boolean

        Tests is the root has been successfully found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_BissecNewton_IsDone(self, *args)


    def Root(self, *args):
        """
        Root(math_BissecNewton self) -> Standard_Real

        returns the value of the root.
        Exception NotDone is raised if the minimum was not found.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_BissecNewton_Root(self, *args)


    def Derivative(self, *args):
        """
        Derivative(math_BissecNewton self) -> Standard_Real

        returns the value of the derivative at the root.
        Exception NotDone is raised if the minimum was not found.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_BissecNewton_Derivative(self, *args)


    def Value(self, *args):
        """
        Value(math_BissecNewton self) -> Standard_Real

        returns the value of the function at the root.
        Exception NotDone is raised if the minimum was not found.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_BissecNewton_Value(self, *args)


    def Dump(self, *args):
        """
        Dump(math_BissecNewton self, Standard_OStream & o)

        Prints on the stream o information on the current state
        of the object.
        Is used to redifine the operator <<.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_BissecNewton_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_BissecNewton
math_BissecNewton_swigregister = _math.math_BissecNewton_swigregister
math_BissecNewton_swigregister(math_BissecNewton)

class math_Jacobi(object):
    """
    This class implements the Jacobi method to find the eigenvalues and
    the eigenvectors of a real symmetric square matrix.
    A sort of eigenvalues is done.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_Jacobi self, math_Matrix A) -> math_Jacobi

        Given a Real n X n matrix A, this constructor computes all its
        eigenvalues and eigenvectors using the Jacobi method.
        The exception NotSquare is raised if the matrix is not square.
        No verification that the matrix A is really symmetric is done.

        :type A: OCC.wrapper.math.math_Matrix

        """
        this = _math.new_math_Jacobi(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(math_Jacobi self) -> Standard_Boolean

        Returns true if the computations are successful, otherwise returns false.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_Jacobi_IsDone(self, *args)


    def Values(self, *args):
        """
        Returns the eigenvalues vector.
        Exception NotDone is raised if calculation is not done successfully.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _math.math_Jacobi_Values(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Value(self, *args):
        """
        Value(math_Jacobi self, Standard_Integer const Num) -> Standard_Real

        returns the eigenvalue number Num.
        Eigenvalues are in the range (1..n).
        Exception NotDone is raised if calculation is not done successfully.

        :type Num: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_Jacobi_Value(self, *args)


    def Vectors(self, *args):
        """
        returns the eigenvectors matrix.
        Exception NotDone is raised if calculation is not done successfully.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _math.math_Jacobi_Vectors(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Vector(self, *args):
        """
        Vector(math_Jacobi self, Standard_Integer const Num, math_Vector V)

        Returns the eigenvector V of number Num.
        Eigenvectors are in the range (1..n).
        Exception NotDone is raised if calculation is not done successfully.

        :type Num: int
        :type V: OCC.wrapper.math.math_Vector

        """
        return _math.math_Jacobi_Vector(self, *args)


    def Dump(self, *args):
        """
        Dump(math_Jacobi self, Standard_OStream & o)

        Prints information on the current state of the object.
        Is used to redefine the operator <<.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_Jacobi_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_Jacobi
math_Jacobi_swigregister = _math.math_Jacobi_swigregister
math_Jacobi_swigregister(math_Jacobi)

class math_FunctionSetWithDerivatives(math_FunctionSet):
    """
    This abstract class describes the virtual functions associated
    with a set of N Functions each of M independant variables.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def NbVariables(self, *args):
        """
        NbVariables(math_FunctionSetWithDerivatives self) -> Standard_Integer

        Returns the number of variables of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_FunctionSetWithDerivatives_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(math_FunctionSetWithDerivatives self) -> Standard_Integer

        Returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_FunctionSetWithDerivatives_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(math_FunctionSetWithDerivatives self, math_Vector X, math_Vector F) -> Standard_Boolean

        Computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_FunctionSetWithDerivatives_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(math_FunctionSetWithDerivatives self, math_Vector X, math_Matrix D) -> Standard_Boolean

        Returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_FunctionSetWithDerivatives_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(math_FunctionSetWithDerivatives self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_FunctionSetWithDerivatives_Values(self, *args)

    __swig_destroy__ = _math.delete_math_FunctionSetWithDerivatives
math_FunctionSetWithDerivatives_swigregister = _math.math_FunctionSetWithDerivatives_swigregister
math_FunctionSetWithDerivatives_swigregister(math_FunctionSetWithDerivatives)

class math_Crout(object):
    """
    This class implements the Crout algorithm used to solve a
    system A*X = B where A is a symmetric matrix. It can be used to
    invert a symmetric matrix.
    This algorithm is similar to Gauss but is faster than Gauss.
    Only the inferior triangle of A and the diagonal can be given.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_Crout self, math_Matrix A, Standard_Real const MinPivot=1.0e-20) -> math_Crout

        Given an input matrix A, this algorithm inverts A by the
        Crout algorithm. The user can give only the inferior
        triangle for the implementation.
        A can be decomposed like this:
        A = L * D * T(L) where L is triangular inferior and D is
        diagonal.
        If one element of A is less than MinPivot, A is
        considered as singular.
        Exception NotSquare is raised if A is not a square matrix.

        :type A: OCC.wrapper.math.math_Matrix
        :type MinPivot: float

        """
        this = _math.new_math_Crout(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(math_Crout self) -> Standard_Boolean

        Returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_Crout_IsDone(self, *args)


    def Solve(self, *args):
        """
        Solve(math_Crout self, math_Vector B, math_Vector X)

        Given an input vector <B>, this routine returns the
        solution of the set of linear equations A . X = B.
        Exception NotDone is raised if the decomposition was not
        done successfully.
        Exception DimensionError is raised if the range of B is
        not equal to the rowrange of A.

        :type B: OCC.wrapper.math.math_Vector
        :type X: OCC.wrapper.math.math_Vector

        """
        return _math.math_Crout_Solve(self, *args)


    def Inverse(self, *args):
        """
        returns the inverse matrix of A. Only the inferior
        triangle is returned.
        Exception NotDone is raised if NotDone.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _math.math_Crout_Inverse(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Invert(self, *args):
        """
        Invert(math_Crout self, math_Matrix Inv)

        returns in Inv the inverse matrix of A. Only the inferior
        triangle is returned.
        Exception NotDone is raised if NotDone.

        :type Inv: OCC.wrapper.math.math_Matrix

        """
        return _math.math_Crout_Invert(self, *args)


    def Determinant(self, *args):
        """
        Determinant(math_Crout self) -> Standard_Real

        Returns the value of the determinant of the previously LU
        decomposed matrix A. Zero is returned if the matrix A is considered as singular.
        Exceptions
        StdFail_NotDone if the algorithm fails (and IsDone returns false).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_Crout_Determinant(self, *args)


    def Dump(self, *args):
        """
        Dump(math_Crout self, Standard_OStream & o)

        Prints on the stream o information on the current state
        of the object.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_Crout_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_Crout
math_Crout_swigregister = _math.math_Crout_swigregister
math_Crout_swigregister(math_Crout)

class Handle_math_SingularMatrix(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_math_SingularMatrix self)

        Nullify the handle


        """
        return _math.Handle_math_SingularMatrix_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_math_SingularMatrix self) -> bool

        Check for being null

        :rtype: bool

        """
        return _math.Handle_math_SingularMatrix_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_math_SingularMatrix self, math_SingularMatrix thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _math.Handle_math_SingularMatrix_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_math_SingularMatrix self, Handle_math_SingularMatrix theHandle) -> Handle_math_SingularMatrix
        assign(Handle_math_SingularMatrix self, math_SingularMatrix thePtr) -> Handle_math_SingularMatrix
        assign(Handle_math_SingularMatrix self, Handle_math_SingularMatrix theHandle) -> Handle_math_SingularMatrix

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _math.Handle_math_SingularMatrix_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_math_SingularMatrix self) -> math_SingularMatrix

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _math.Handle_math_SingularMatrix_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_math_SingularMatrix self) -> math_SingularMatrix

        Member access operator (note non-const)

        :rtype: T *

        """
        return _math.Handle_math_SingularMatrix___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_math_SingularMatrix self) -> math_SingularMatrix

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _math.Handle_math_SingularMatrix___ref__(self, *args)


    def __hash__(self):
        return _math.Handle_math_SingularMatrix___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _math.Handle_math_SingularMatrix___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _math.new_Handle_math_SingularMatrix(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_math.Handle_math_SingularMatrix_DownCast)
    __swig_destroy__ = _math.delete_Handle_math_SingularMatrix

    def NewInstance(self, *args):
        """
        NewInstance(Handle_math_SingularMatrix self, Standard_CString const theMessage) -> Handle_math_SingularMatrix

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.math.Handle_math_SingularMatrix

        """
        return _math.Handle_math_SingularMatrix_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_math_SingularMatrix self) -> char const *

        :rtype: const char *

        """
        return _math.Handle_math_SingularMatrix_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _math.Handle_math_SingularMatrix_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _math.Handle_math_SingularMatrix_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_math_SingularMatrix self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.Handle_math_SingularMatrix_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_math_SingularMatrix self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _math.Handle_math_SingularMatrix_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_math_SingularMatrix self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _math.Handle_math_SingularMatrix_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_math_SingularMatrix self)
        Reraise(Handle_math_SingularMatrix self, Standard_CString const aMessage)
        Reraise(Handle_math_SingularMatrix self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _math.Handle_math_SingularMatrix_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_math_SingularMatrix self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _math.Handle_math_SingularMatrix_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_math_SingularMatrix self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _math.Handle_math_SingularMatrix_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_math_SingularMatrix self)

        Memory deallocator for transient classes


        """
        return _math.Handle_math_SingularMatrix_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_math_SingularMatrix self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_math_SingularMatrix self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.Handle_math_SingularMatrix_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_math_SingularMatrix self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_math_SingularMatrix self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.Handle_math_SingularMatrix_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_math_SingularMatrix self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _math.Handle_math_SingularMatrix_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_math_SingularMatrix self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.Handle_math_SingularMatrix_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_math_SingularMatrix self)

        Increments the reference counter of this object


        """
        return _math.Handle_math_SingularMatrix_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_math_SingularMatrix self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.Handle_math_SingularMatrix_DecrementRefCounter(self, *args)

Handle_math_SingularMatrix_swigregister = _math.Handle_math_SingularMatrix_swigregister
Handle_math_SingularMatrix_swigregister(Handle_math_SingularMatrix)

def Handle_math_SingularMatrix_DownCast(thing):
    return _math.Handle_math_SingularMatrix_DownCast(thing)
Handle_math_SingularMatrix_DownCast = _math.Handle_math_SingularMatrix_DownCast

class math_Uzawa(object):
    """
    This class implements a system resolution C*X = B with
    an approach solution X0. There are no conditions on the
    number of equations. The algorithm used is the Uzawa
    algorithm. It is possible to have equal or inequal  (<)
    equations to solve. The resolution is done with a
    minimization of Norm(X-X0).
    If there are only equal equations, the resolution is directly
    done and is similar to Gauss resolution with an optimisation
    because the matrix is a symmetric matrix.
    (The resolution is done with Crout algorithm)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_Uzawa self, math_Matrix Cont, math_Vector Secont, math_Vector StartingPoint, Standard_Real const EpsLix=1.0e-06, Standard_Real const EpsLic=1.0e-06, Standard_Integer const NbIterations=500) -> math_Uzawa
        __init__(math_Uzawa self, math_Matrix Cont, math_Vector Secont, math_Vector StartingPoint, Standard_Integer const Nci, Standard_Integer const Nce, Standard_Real const EpsLix=1.0e-06, Standard_Real const EpsLic=1.0e-06, Standard_Integer const NbIterations=500) -> math_Uzawa

        Given an input matrix Cont, two input vectors Secont
        and StartingPoint, it solves Cont*X = Secont (the Nce
        first equations are equal equations and the Nci last
        equations are inequalities <) with a minimization
        of Norme(X-X0).
        The maximun iterations number allowed is fixed to
        NbIterations.
        The tolerance EpsLic is fixed for the dual variable
        convergence. The tolerance EpsLix is used for the
        convergence of X.
        There are no conditions on Nce and Nci.
        Exception ConstuctionError is raised if the line number
        of Cont is different from the length of Secont and from
        Nce + Nci.

        :type Cont: OCC.wrapper.math.math_Matrix
        :type Secont: OCC.wrapper.math.math_Vector
        :type StartingPoint: OCC.wrapper.math.math_Vector
        :type Nci: int
        :type Nce: int
        :type EpsLix: float
        :type EpsLic: float
        :type NbIterations: int

        """
        this = _math.new_math_Uzawa(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(math_Uzawa self) -> Standard_Boolean

        Returns true if the computations are successful, otherwise returns false.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_Uzawa_IsDone(self, *args)


    def Value(self, *args):
        """
        Returns the vector solution of the system above.
        An exception is raised if NotDone.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _math.math_Uzawa_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InitialError(self, *args):
        """
        Returns the initial error Cont*StartingPoint-Secont.
        An exception is raised if NotDone.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _math.math_Uzawa_InitialError(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Duale(self, *args):
        """
        Duale(math_Uzawa self, math_Vector V)

        returns the duale variables V of the systeme.

        :type V: OCC.wrapper.math.math_Vector

        """
        return _math.math_Uzawa_Duale(self, *args)


    def Error(self, *args):
        """
        Returns the difference between X solution and the
        StartingPoint.
        An exception is raised if NotDone.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _math.math_Uzawa_Error(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbIterations(self, *args):
        """
        NbIterations(math_Uzawa self) -> Standard_Integer

        returns the number of iterations really done.
        An exception is raised if NotDone.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_Uzawa_NbIterations(self, *args)


    def InverseCont(self, *args):
        """
        returns the inverse matrix of (C * Transposed(C)).
        This result is needed for the computation of the gradient
        when approximating a curve.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _math.math_Uzawa_InverseCont(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Dump(self, *args):
        """
        Dump(math_Uzawa self, Standard_OStream & o)

        Prints information on the current state of the object.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_Uzawa_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_Uzawa
math_Uzawa_swigregister = _math.math_Uzawa_swigregister
math_Uzawa_swigregister(math_Uzawa)

class math_BracketedRoot(object):
    """
    This class implements the Brent method to find the root of a function
    located within two bounds. No knowledge of the derivative is required.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_BracketedRoot self, math_Function F, Standard_Real const Bound1, Standard_Real const Bound2, Standard_Real const Tolerance, Standard_Integer const NbIterations=100, Standard_Real const ZEPS=1.0e-12) -> math_BracketedRoot

        The Brent method is used to find the root of the function F between
        the bounds Bound1 and Bound2 on the function F.
        If F(Bound1)*F(Bound2) >0 the Brent method fails.
        The tolerance required for the root is given by Tolerance.
        The solution is found when :
        abs(Xi - Xi-1) <= Tolerance;
        The maximum number of iterations allowed is given by NbIterations.

        :type F: OCC.wrapper.math.math_Function
        :type Bound1: float
        :type Bound2: float
        :type Tolerance: float
        :type NbIterations: int
        :type ZEPS: float

        """
        this = _math.new_math_BracketedRoot(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(math_BracketedRoot self) -> Standard_Boolean

        Returns true if the computations are successful, otherwise returns false.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_BracketedRoot_IsDone(self, *args)


    def Root(self, *args):
        """
        Root(math_BracketedRoot self) -> Standard_Real

        returns the value of the root.
        Exception NotDone is raised if the minimum was not found.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_BracketedRoot_Root(self, *args)


    def Value(self, *args):
        """
        Value(math_BracketedRoot self) -> Standard_Real

        returns the value of the function at the root.
        Exception NotDone is raised if the minimum was not found.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_BracketedRoot_Value(self, *args)


    def NbIterations(self, *args):
        """
        NbIterations(math_BracketedRoot self) -> Standard_Integer

        returns the number of iterations really done during the
        computation of the Root.
        Exception NotDone is raised if the minimum was not found.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_BracketedRoot_NbIterations(self, *args)


    def Dump(self, *args):
        """
        Dump(math_BracketedRoot self, Standard_OStream & o)

        Prints on the stream o information on the current state
        of the object.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_BracketedRoot_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_BracketedRoot
math_BracketedRoot_swigregister = _math.math_BracketedRoot_swigregister
math_BracketedRoot_swigregister(math_BracketedRoot)

class math_Householder(object):
    """
    This class implements the least square solution of a set of
    linear equations of m unknowns (n >= m) using the Householder
    method. It solves A.X = B.
    This algorithm has more numerical stability than
    GaussLeastSquare but is longer.
    It must be used if the matrix is singular or nearly singular.
    It is about 16% longer than GaussLeastSquare if there is only
    one member B to solve.
    It is about 30% longer if there are twenty B members to solve.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_Householder self, math_Matrix A, math_Matrix B, Standard_Real const EPS=1.0e-20) -> math_Householder
        __init__(math_Householder self, math_Matrix A, math_Matrix B, Standard_Integer const lowerArow, Standard_Integer const upperArow, Standard_Integer const lowerAcol, Standard_Integer const upperAcol, Standard_Real const EPS=1.0e-20) -> math_Householder
        __init__(math_Householder self, math_Matrix A, math_Vector B, Standard_Real const EPS=1.0e-20) -> math_Householder

        Given an input matrix A with n>= m, given an input vector B
        this constructor performs the least square resolution of
        the set of linear equations A.X = B.
        If a column norm is less than EPS, the resolution can't
        be done.
        Exception DimensionError is raised if the length of B
        is different from the A row number.

        :type A: OCC.wrapper.math.math_Matrix
        :type B: OCC.wrapper.math.math_Vector
        :type EPS: float

        """
        this = _math.new_math_Householder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(math_Householder self) -> Standard_Boolean

        Returns true if the computations are successful, otherwise returns false.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_Householder_IsDone(self, *args)


    def Value(self, *args):
        """
        Value(math_Householder self, math_Vector sol, Standard_Integer const Index=1)

        Given the integer Index, this routine returns the
        corresponding least square solution sol.
        Exception NotDone is raised if the resolution has not be
        done.
        Exception OutOfRange is raised if Index <=0 or
        Index is more than the number of columns of B.

        :type sol: OCC.wrapper.math.math_Vector
        :type Index: int

        """
        return _math.math_Householder_Value(self, *args)


    def AllValues(self, *args):
        """
        Returns the matrix sol of all the solutions of the system
        A.X = B.
        Exception NotDone is raised is the resolution has not be
        done.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _math.math_Householder_AllValues(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Dump(self, *args):
        """
        Dump(math_Householder self, Standard_OStream & o)

        Prints informations on the current state of the object.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_Householder_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_Householder
math_Householder_swigregister = _math.math_Householder_swigregister
math_Householder_swigregister(math_Householder)

class math_BFGS(object):
    """
    This class implements the Broyden-Fletcher-Goldfarb-Shanno variant of
    Davidson-Fletcher-Powell minimization algorithm of a function of
    multiple variables.Knowledge of the function's gradient is required.

    It is possible to solve conditional optimization problem on hyperparallelepiped.
    Method SetBoundary is used to define hyperparallelepiped borders. With boundaries
    defined, the algorithm will not make evaluations of the function outside of the
    borders.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_BFGS self, Standard_Integer const NbVariables, Standard_Real const Tolerance=1.0e-8, Standard_Integer const NbIterations=200, Standard_Real const ZEPS=1.0e-12) -> math_BFGS

        Initializes the computation of the minimum of a function with
        NbVariables.
        Tolerance, ZEPS and NbIterations are described in the method Perform.
        Warning:
        A call to the Perform method must be made after this
        initialization to effectively compute the minimum of the
        function F.

        :type NbVariables: int
        :type Tolerance: float
        :type NbIterations: int
        :type ZEPS: float

        """
        this = _math.new_math_BFGS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetBoundary(self, *args):
        """
        SetBoundary(math_BFGS self, math_Vector theLeftBorder, math_Vector theRightBorder)

        Set boundaries for conditional optimization.
        The expected indices range of vectors is [1, NbVariables].

        :type theLeftBorder: OCC.wrapper.math.math_Vector
        :type theRightBorder: OCC.wrapper.math.math_Vector

        """
        return _math.math_BFGS_SetBoundary(self, *args)


    def Perform(self, *args):
        """
        Perform(math_BFGS self, math_MultipleVarFunctionWithGradient F, math_Vector StartingPoint)

        Given the starting point StartingPoint,
        minimization is done on the function F.
        The solution F = Fi is found when :
        2.0 * abs(Fi - Fi-1) <= Tolerance * (abs(Fi) + abs(Fi-1) + ZEPS).
        Tolerance, ZEPS and maximum number of iterations are given
        in the constructor.

        :type F: OCC.wrapper.math.math_MultipleVarFunctionWithGradient
        :type StartingPoint: OCC.wrapper.math.math_Vector

        """
        return _math.math_BFGS_Perform(self, *args)


    def IsSolutionReached(self, *args):
        """
        IsSolutionReached(math_BFGS self, math_MultipleVarFunctionWithGradient F) -> Standard_Boolean

        This method is called at the end of each iteration to check if the
        solution is found.
        It can be redefined in a sub-class to implement a specific test to
        stop the iterations.

        :type F: OCC.wrapper.math.math_MultipleVarFunctionWithGradient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_BFGS_IsSolutionReached(self, *args)


    def IsDone(self, *args):
        """
        IsDone(math_BFGS self) -> Standard_Boolean

        Returns true if the computations are successful, otherwise returns false.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_BFGS_IsDone(self, *args)


    def Location(self, *args):
        """
        returns the location vector of the minimum.
        Exception NotDone is raised if the minimum was not found.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _math.math_BFGS_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Minimum(self, *args):
        """
        Minimum(math_BFGS self) -> Standard_Real

        returns the value of the minimum.
        Exception NotDone is raised if the minimum was not found.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_BFGS_Minimum(self, *args)


    def Gradient(self, *args):
        """
        Returns the gradient vector at the minimum.
        Exception NotDone is raised if the minimum was not found.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _math.math_BFGS_Gradient(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbIterations(self, *args):
        """
        NbIterations(math_BFGS self) -> Standard_Integer

        Returns the number of iterations really done in the
        calculation of the minimum.
        The exception NotDone is raised if the minimum was not found.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_BFGS_NbIterations(self, *args)


    def Dump(self, *args):
        """
        Dump(math_BFGS self, Standard_OStream & o)

        Prints on the stream o information on the current state
        of the object.
        Is used to redefine the operator <<.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_BFGS_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_BFGS
math_BFGS_swigregister = _math.math_BFGS_swigregister
math_BFGS_swigregister(math_BFGS)

class math_ComputeGaussPointsAndWeights(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_ComputeGaussPointsAndWeights self, Standard_Integer const Number) -> math_ComputeGaussPointsAndWeights

        :type Number: int

        """
        this = _math.new_math_ComputeGaussPointsAndWeights(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(math_ComputeGaussPointsAndWeights self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_ComputeGaussPointsAndWeights_IsDone(self, *args)


    def Points(self, *args):
        """
        Points(math_ComputeGaussPointsAndWeights self) -> math_Vector

        :rtype: OCC.wrapper.math.math_Vector

        """
        return _math.math_ComputeGaussPointsAndWeights_Points(self, *args)


    def Weights(self, *args):
        """
        Weights(math_ComputeGaussPointsAndWeights self) -> math_Vector

        :rtype: OCC.wrapper.math.math_Vector

        """
        return _math.math_ComputeGaussPointsAndWeights_Weights(self, *args)

    __swig_destroy__ = _math.delete_math_ComputeGaussPointsAndWeights
math_ComputeGaussPointsAndWeights_swigregister = _math.math_ComputeGaussPointsAndWeights_swigregister
math_ComputeGaussPointsAndWeights_swigregister(math_ComputeGaussPointsAndWeights)

class math_FunctionSample(object):
    """
    This class gives a default sample (constant difference
    of parameter) for a function defined between
    two bound A,B.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_FunctionSample self, Standard_Real const A, Standard_Real const B, Standard_Integer const N) -> math_FunctionSample

        :type A: float
        :type B: float
        :type N: int

        """
        this = _math.new_math_FunctionSample(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Bounds(self, *args):
        """
        Bounds(math_FunctionSample self)

        Returns the bounds of parameters.

        :type A: float
        :type B: float

        """
        return _math.math_FunctionSample_Bounds(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(math_FunctionSample self) -> Standard_Integer

        Returns the number of sample points.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_FunctionSample_NbPoints(self, *args)


    def GetParameter(self, *args):
        """
        GetParameter(math_FunctionSample self, Standard_Integer const Index) -> Standard_Real

        Returns the value of parameter of the point of
        range Index : A + ((Index-1)/(NbPoints-1))*B.
        An exception is raised if Index<=0 or Index>NbPoints.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_FunctionSample_GetParameter(self, *args)

    __swig_destroy__ = _math.delete_math_FunctionSample
math_FunctionSample_swigregister = _math.math_FunctionSample_swigregister
math_FunctionSample_swigregister(math_FunctionSample)

class math_PSOParticlesPool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_PSOParticlesPool self, Standard_Integer const theParticlesCount, Standard_Integer const theDimensionCount) -> math_PSOParticlesPool

        :type theParticlesCount: int
        :type theDimensionCount: int

        """
        this = _math.new_math_PSOParticlesPool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetParticle(self, *args):
        """
        GetParticle(math_PSOParticlesPool self, Standard_Integer const theIdx) -> PSO_Particle *

        :type theIdx: int
        :rtype: PSO_Particle

        """
        return _math.math_PSOParticlesPool_GetParticle(self, *args)


    def GetBestParticle(self, *args):
        """
        GetBestParticle(math_PSOParticlesPool self) -> PSO_Particle *

        :rtype: PSO_Particle

        """
        return _math.math_PSOParticlesPool_GetBestParticle(self, *args)


    def GetWorstParticle(self, *args):
        """
        GetWorstParticle(math_PSOParticlesPool self) -> PSO_Particle *

        :rtype: PSO_Particle

        """
        return _math.math_PSOParticlesPool_GetWorstParticle(self, *args)

    __swig_destroy__ = _math.delete_math_PSOParticlesPool
math_PSOParticlesPool_swigregister = _math.math_PSOParticlesPool_swigregister
math_PSOParticlesPool_swigregister(math_PSOParticlesPool)

class math_FunctionAllRoots(object):
    """
    This algorithm uses a sample of the function to find
    all intervals on which the function is null, and afterwards
    uses the FunctionRoots algorithm to find the points
    where the function is null outside the "null intervals".
    Knowledge of the derivative is required.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_FunctionAllRoots self, math_FunctionWithDerivative F, math_FunctionSample S, Standard_Real const EpsX, Standard_Real const EpsF, Standard_Real const EpsNul) -> math_FunctionAllRoots

        The algorithm uses the sample to find intervals on which
        the function is null. An interval is found if, for at least
        two consecutive points of the sample, Ui and Ui+1, we get
        |F(Ui)|<=EpsNul and |F(Ui+1)|<=EpsNul. The real bounds of
        an interval are computed with the FunctionRoots.
        algorithm.
        Between two intervals, the roots of the function F are
        calculated using the FunctionRoots algorithm.

        :type F: OCC.wrapper.math.math_FunctionWithDerivative
        :type S: OCC.wrapper.math.math_FunctionSample
        :type EpsX: float
        :type EpsF: float
        :type EpsNul: float

        """
        this = _math.new_math_FunctionAllRoots(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(math_FunctionAllRoots self) -> Standard_Boolean

        Returns True if the computation has been done successfully.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_FunctionAllRoots_IsDone(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(math_FunctionAllRoots self) -> Standard_Integer

        Returns the number of intervals on which the function
        is Null.
        An exception is raised if IsDone returns False.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_FunctionAllRoots_NbIntervals(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(math_FunctionAllRoots self, Standard_Integer const Index)

        Returns the interval of parameter of range Index.
        An exception is raised if IsDone returns False;
        An exception is raised if Index<=0 or Index >Nbintervals.

        :type Index: int
        :type A: float
        :type B: float

        """
        return _math.math_FunctionAllRoots_GetInterval(self, *args)


    def GetIntervalState(self, *args):
        """
        GetIntervalState(math_FunctionAllRoots self, Standard_Integer const Index)

        returns the State Number associated to the interval Index.
        An exception is raised if IsDone returns False;
        An exception is raised if Index<=0 or Index >Nbintervals.

        :type Index: int
        :type IFirst: int
        :type ILast: int

        """
        return _math.math_FunctionAllRoots_GetIntervalState(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(math_FunctionAllRoots self) -> Standard_Integer

        returns the number of points where the function is Null.
        An exception is raised if IsDone returns False.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_FunctionAllRoots_NbPoints(self, *args)


    def GetPoint(self, *args):
        """
        GetPoint(math_FunctionAllRoots self, Standard_Integer const Index) -> Standard_Real

        Returns the parameter of the point of range Index.
        An exception is raised if IsDone returns False;
        An exception is raised if Index<=0 or Index >NbPoints.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_FunctionAllRoots_GetPoint(self, *args)


    def GetPointState(self, *args):
        """
        GetPointState(math_FunctionAllRoots self, Standard_Integer const Index) -> Standard_Integer

        returns the State Number associated to the point Index.
        An exception is raised if IsDone returns False;
        An exception is raised if Index<=0 or Index >Nbintervals.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_FunctionAllRoots_GetPointState(self, *args)


    def Dump(self, *args):
        """
        Dump(math_FunctionAllRoots self, Standard_OStream & o)

        Prints on the stream o information on the current state
        of the object.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_FunctionAllRoots_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_FunctionAllRoots
math_FunctionAllRoots_swigregister = _math.math_FunctionAllRoots_swigregister
math_FunctionAllRoots_swigregister(math_FunctionAllRoots)

class math_GlobOptMin(object):
    """
    This class represents Evtushenko's algorithm of global optimization based on non-uniform mesh.
    Article: Yu. Evtushenko. Numerical methods for finding global extreme (case of a non-uniform mesh).
    U.S.S.R. Comput. Maths. Math. Phys., Vol. 11, N 6, pp. 38-54.

    This method performs search on non-uniform mesh. The search space is a box in R^n space.
    The default behavior is to find all minimums in that box. Computation of maximums is not supported.

    The search box can be split into smaller boxes by discontinuity criteria.
    This functionality is covered by SetGlobalParams and SetLocalParams API.

    It is possible to set continuity of the local boxes.
    Such option can forcibly change local extrema search.
    In other words if theFunc can be casted to the function with Hessian but, continuity is set to 1
    Gradient based local optimization method will be used, not Hessian based method.
    This functionality is covered by SetContinuity and GetContinuity API.

    It is possible to freeze Lipschitz const to avoid internal modifications on it.
    This functionality is covered by SetLipConstState and GetLipConstState API.

    It is possible to perform single solution search.
    This functionality is covered by first parameter in Perform method.

    It is possible to set / get minimal value of the functional.
    It works well together with single solution search.
    This functionality is covered by SetFunctionalMinimalValue and GetFunctionalMinimalValue API.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_GlobOptMin self, math_MultipleVarFunction theFunc, math_Vector theLowerBorder, math_Vector theUpperBorder, Standard_Real const theC=9, Standard_Real const theDiscretizationTol=1.0e-2, Standard_Real const theSameTol=1.0e-7) -> math_GlobOptMin

        Constructor. Perform method is not called from it.
        @param theFunc - objective functional.
        @param theLowerBorder - lower corner of the search box.
        @param theUpperBorder - upper corner of the search box.
        @param theC - Lipschitz constant.
        @param theDiscretizationTol - parameter space discretization tolerance.
        @param theSameTol - functional value space indifference tolerance.

        :type theFunc: OCC.wrapper.math.math_MultipleVarFunction
        :type theLowerBorder: OCC.wrapper.math.math_Vector
        :type theUpperBorder: OCC.wrapper.math.math_Vector
        :type theC: float
        :type theDiscretizationTol: float
        :type theSameTol: float

        """
        this = _math.new_math_GlobOptMin(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetGlobalParams(self, *args):
        """
        SetGlobalParams(math_GlobOptMin self, math_MultipleVarFunction theFunc, math_Vector theLowerBorder, math_Vector theUpperBorder, Standard_Real const theC=9, Standard_Real const theDiscretizationTol=1.0e-2, Standard_Real const theSameTol=1.0e-7)

        @param theFunc - objective functional.
        @param theLowerBorder - lower corner of the search box.
        @param theUpperBorder - upper corner of the search box.
        @param theC - Lipschitz constant.
        @param theDiscretizationTol - parameter space discretization tolerance.
        @param theSameTol - functional value space indifference tolerance.

        :type theFunc: OCC.wrapper.math.math_MultipleVarFunction
        :type theLowerBorder: OCC.wrapper.math.math_Vector
        :type theUpperBorder: OCC.wrapper.math.math_Vector
        :type theC: float
        :type theDiscretizationTol: float
        :type theSameTol: float

        """
        return _math.math_GlobOptMin_SetGlobalParams(self, *args)


    def SetLocalParams(self, *args):
        """
        SetLocalParams(math_GlobOptMin self, math_Vector theLocalA, math_Vector theLocalB)

        Method to reduce bounding box. Perform will use this box.
        @param theLocalA - lower corner of the local box.
        @param theLocalB - upper corner of the local box.

        :type theLocalA: OCC.wrapper.math.math_Vector
        :type theLocalB: OCC.wrapper.math.math_Vector

        """
        return _math.math_GlobOptMin_SetLocalParams(self, *args)


    def SetTol(self, *args):
        """
        SetTol(math_GlobOptMin self, Standard_Real const theDiscretizationTol, Standard_Real const theSameTol)

        Method to set tolerances.
        @param theDiscretizationTol - parameter space discretization tolerance.
        @param theSameTol - functional value space indifference tolerance.

        :type theDiscretizationTol: float
        :type theSameTol: float

        """
        return _math.math_GlobOptMin_SetTol(self, *args)


    def GetTol(self, *args):
        """
        GetTol(math_GlobOptMin self)

        Method to get tolerances.
        @param theDiscretizationTol - parameter space discretization tolerance.
        @param theSameTol - functional value space indifference tolerance.

        :type theDiscretizationTol: float
        :type theSameTol: float

        """
        return _math.math_GlobOptMin_GetTol(self, *args)


    def Perform(self, *args):
        """
        Perform(math_GlobOptMin self, Standard_Boolean const isFindSingleSolution)

        @param isFindSingleSolution - defines whether to find single solution or all solutions.

        :type isFindSingleSolution: bool

        """
        return _math.math_GlobOptMin_Perform(self, *args)


    def Points(self, *args):
        """
        Points(math_GlobOptMin self, Standard_Integer const theIndex, math_Vector theSol)

        Return solution theIndex, 1 <= theIndex <= NbExtrema.

        :type theIndex: int
        :type theSol: OCC.wrapper.math.math_Vector

        """
        return _math.math_GlobOptMin_Points(self, *args)


    def SetContinuity(self, *args):
        """
        SetContinuity(math_GlobOptMin self, Standard_Integer const theCont)

        Set / Get continuity of local borders splits (0 ~ C0, 1 ~ C1, 2 ~ C2).

        :type theCont: int

        """
        return _math.math_GlobOptMin_SetContinuity(self, *args)


    def GetContinuity(self, *args):
        """
        GetContinuity(math_GlobOptMin self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_GlobOptMin_GetContinuity(self, *args)


    def SetFunctionalMinimalValue(self, *args):
        """
        SetFunctionalMinimalValue(math_GlobOptMin self, Standard_Real const theMinimalValue)

        Set / Get functional minimal value.

        :type theMinimalValue: float

        """
        return _math.math_GlobOptMin_SetFunctionalMinimalValue(self, *args)


    def GetFunctionalMinimalValue(self, *args):
        """
        GetFunctionalMinimalValue(math_GlobOptMin self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_GlobOptMin_GetFunctionalMinimalValue(self, *args)


    def SetLipConstState(self, *args):
        """
        SetLipConstState(math_GlobOptMin self, Standard_Boolean const theFlag)

        Set / Get Lipchitz constant modification state. 
        True means that the constant is locked and unlocked otherwise.

        :type theFlag: bool

        """
        return _math.math_GlobOptMin_SetLipConstState(self, *args)


    def GetLipConstState(self, *args):
        """
        GetLipConstState(math_GlobOptMin self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_GlobOptMin_GetLipConstState(self, *args)


    def isDone(self, *args):
        """
        isDone(math_GlobOptMin self) -> Standard_Boolean

        Return computation state of the algorithm.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_GlobOptMin_isDone(self, *args)


    def GetF(self, *args):
        """
        GetF(math_GlobOptMin self) -> Standard_Real

        Get best functional value.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_GlobOptMin_GetF(self, *args)


    def NbExtrema(self, *args):
        """
        NbExtrema(math_GlobOptMin self) -> Standard_Integer

        Return count of global extremas.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_GlobOptMin_NbExtrema(self, *args)

    __swig_destroy__ = _math.delete_math_GlobOptMin
math_GlobOptMin_swigregister = _math.math_GlobOptMin_swigregister
math_GlobOptMin_swigregister(math_GlobOptMin)

class math_MultipleVarFunctionWithGradient(math_MultipleVarFunction):
    """
    The abstract class MultipleVarFunctionWithGradient
    describes the virtual functions associated with a multiple variable function.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def NbVariables(self, *args):
        """
        NbVariables(math_MultipleVarFunctionWithGradient self) -> Standard_Integer

        Returns the number of variables of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_MultipleVarFunctionWithGradient_NbVariables(self, *args)


    def Value(self, *args):
        """
        Value(math_MultipleVarFunctionWithGradient self, math_Vector X) -> Standard_Boolean

        Computes the values of the Functions <F> for the   variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_MultipleVarFunctionWithGradient_Value(self, *args)


    def Gradient(self, *args):
        """
        Gradient(math_MultipleVarFunctionWithGradient self, math_Vector X, math_Vector G) -> Standard_Boolean

        Computes the gradient <G> of the functions for the   variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_MultipleVarFunctionWithGradient_Gradient(self, *args)


    def Values(self, *args):
        """
        Values(math_MultipleVarFunctionWithGradient self, math_Vector X, math_Vector G) -> Standard_Boolean

        computes the value <F> and the gradient <G> of the
        functions for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_MultipleVarFunctionWithGradient_Values(self, *args)

    __swig_destroy__ = _math.delete_math_MultipleVarFunctionWithGradient
math_MultipleVarFunctionWithGradient_swigregister = _math.math_MultipleVarFunctionWithGradient_swigregister
math_MultipleVarFunctionWithGradient_swigregister(math_MultipleVarFunctionWithGradient)

class math_(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GaussPointsMax(*args):
        """
        GaussPointsMax() -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math__GaussPointsMax(*args)

    GaussPointsMax = staticmethod(GaussPointsMax)

    def GaussPoints(*args):
        """
        GaussPoints(Standard_Integer const Index, math_Vector Points)

        :type Index: int
        :type Points: OCC.wrapper.math.math_Vector

        """
        return _math.math__GaussPoints(*args)

    GaussPoints = staticmethod(GaussPoints)

    def GaussWeights(*args):
        """
        GaussWeights(Standard_Integer const Index, math_Vector Weights)

        :type Index: int
        :type Weights: OCC.wrapper.math.math_Vector

        """
        return _math.math__GaussWeights(*args)

    GaussWeights = staticmethod(GaussWeights)

    def KronrodPointsMax(*args):
        """
        KronrodPointsMax() -> Standard_Integer

        Returns the maximal number of points for that the values
        are stored in the table. If the number is greater then
        KronrodPointsMax, the points will be computed.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math__KronrodPointsMax(*args)

    KronrodPointsMax = staticmethod(KronrodPointsMax)

    def OrderedGaussPointsAndWeights(*args):
        """
        OrderedGaussPointsAndWeights(Standard_Integer const Index, math_Vector Points, math_Vector Weights) -> Standard_Boolean

        Returns a vector of Gauss points and a vector of their weights.
        The difference with the
        method GaussPoints is the following:
        - the points are returned in increasing order.
        - if Index is greater then GaussPointsMax, the points are
        computed.
        Returns Standard_True if Index is positive, Points' and Weights'
        length is equal to Index, Points and Weights are successfully computed.

        :type Index: int
        :type Points: OCC.wrapper.math.math_Vector
        :type Weights: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math__OrderedGaussPointsAndWeights(*args)

    OrderedGaussPointsAndWeights = staticmethod(OrderedGaussPointsAndWeights)

    def KronrodPointsAndWeights(*args):
        """
        KronrodPointsAndWeights(Standard_Integer const Index, math_Vector Points, math_Vector Weights) -> Standard_Boolean

        Returns a vector of Kronrod points and a vector of their
        weights for Gauss-Kronrod computation method.
        Index should be odd and greater then or equal to 3,
        as the number of Kronrod points is equal to 2*N + 1,
        where N is a number of Gauss points. Points and Weights should
        have the size equal to Index. Each even element of Points
        represents a Gauss point value of N-th Gauss quadrature.
        The values from Index equal to 3 to 123 are stored in a
        table (see the file math_Kronrod.cxx). If Index is greater,
        then points and weights will be computed. Returns Standard_True
        if Index is odd, it is equal to the size of Points and Weights
        and the computation of Points and Weights is performed successfully.
        Otherwise this method returns Standard_False.

        :type Index: int
        :type Points: OCC.wrapper.math.math_Vector
        :type Weights: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math__KronrodPointsAndWeights(*args)

    KronrodPointsAndWeights = staticmethod(KronrodPointsAndWeights)

    def __init__(self):
        this = _math.new_math_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _math.delete_math_
math__swigregister = _math.math__swigregister
math__swigregister(math_)

def math__GaussPointsMax(*args):
    """
    math__GaussPointsMax() -> Standard_Integer

    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _math.math__GaussPointsMax(*args)

def math__GaussPoints(*args):
    """
    math__GaussPoints(Standard_Integer const Index, math_Vector Points)

    :type Index: int
    :type Points: OCC.wrapper.math.math_Vector

    """
    return _math.math__GaussPoints(*args)

def math__GaussWeights(*args):
    """
    math__GaussWeights(Standard_Integer const Index, math_Vector Weights)

    :type Index: int
    :type Weights: OCC.wrapper.math.math_Vector

    """
    return _math.math__GaussWeights(*args)

def math__KronrodPointsMax(*args):
    """
    math__KronrodPointsMax() -> Standard_Integer

    Returns the maximal number of points for that the values
    are stored in the table. If the number is greater then
    KronrodPointsMax, the points will be computed.

    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _math.math__KronrodPointsMax(*args)

def math__OrderedGaussPointsAndWeights(*args):
    """
    math__OrderedGaussPointsAndWeights(Standard_Integer const Index, math_Vector Points, math_Vector Weights) -> Standard_Boolean

    Returns a vector of Gauss points and a vector of their weights.
    The difference with the
    method GaussPoints is the following:
    - the points are returned in increasing order.
    - if Index is greater then GaussPointsMax, the points are
    computed.
    Returns Standard_True if Index is positive, Points' and Weights'
    length is equal to Index, Points and Weights are successfully computed.

    :type Index: int
    :type Points: OCC.wrapper.math.math_Vector
    :type Weights: OCC.wrapper.math.math_Vector
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _math.math__OrderedGaussPointsAndWeights(*args)

def math__KronrodPointsAndWeights(*args):
    """
    math__KronrodPointsAndWeights(Standard_Integer const Index, math_Vector Points, math_Vector Weights) -> Standard_Boolean

    Returns a vector of Kronrod points and a vector of their
    weights for Gauss-Kronrod computation method.
    Index should be odd and greater then or equal to 3,
    as the number of Kronrod points is equal to 2*N + 1,
    where N is a number of Gauss points. Points and Weights should
    have the size equal to Index. Each even element of Points
    represents a Gauss point value of N-th Gauss quadrature.
    The values from Index equal to 3 to 123 are stored in a
    table (see the file math_Kronrod.cxx). If Index is greater,
    then points and weights will be computed. Returns Standard_True
    if Index is odd, it is equal to the size of Points and Weights
    and the computation of Points and Weights is performed successfully.
    Otherwise this method returns Standard_False.

    :type Index: int
    :type Points: OCC.wrapper.math.math_Vector
    :type Weights: OCC.wrapper.math.math_Vector
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _math.math__KronrodPointsAndWeights(*args)

class math_SVD(object):
    """
    SVD implements the solution of a set of N linear equations
    of M unknowns without condition on N or M. The Singular
    Value Decomposition algorithm is used. For singular or
    nearly singular matrices SVD is a better choice than Gauss
    or GaussLeastSquare.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_SVD self, math_Matrix A) -> math_SVD

        Given as input an n X m matrix A with n < m, n = m or n > m
        this constructor performs the Singular Value Decomposition.

        :type A: OCC.wrapper.math.math_Matrix

        """
        this = _math.new_math_SVD(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(math_SVD self) -> Standard_Boolean

        Returns true if the computations are successful, otherwise returns false.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_SVD_IsDone(self, *args)


    def Solve(self, *args):
        """
        Solve(math_SVD self, math_Vector B, math_Vector X, Standard_Real const Eps=1.0e-6)

        Given the input Vector B this routine solves the set of linear
        equations A . X = B.
        Exception NotDone is raised if the decomposition of A was not done
        successfully.
        Exception DimensionError is raised if the range of B is not
        equal to the rowrange of A.
        Exception DimensionError is raised if the range of X is not
        equal to the colrange of A.

        :type B: OCC.wrapper.math.math_Vector
        :type X: OCC.wrapper.math.math_Vector
        :type Eps: float

        """
        return _math.math_SVD_Solve(self, *args)


    def PseudoInverse(self, *args):
        """
        PseudoInverse(math_SVD self, math_Matrix Inv, Standard_Real const Eps=1.0e-6)

        Computes the inverse Inv of matrix A such as A * Inverse = Identity.
        Exceptions
        StdFail_NotDone if the algorithm fails (and IsDone returns false).
        Standard_DimensionError if the ranges of Inv are
        compatible with the ranges of A.

        :type Inv: OCC.wrapper.math.math_Matrix
        :type Eps: float

        """
        return _math.math_SVD_PseudoInverse(self, *args)


    def Dump(self, *args):
        """
        Dump(math_SVD self, Standard_OStream & o)

        Prints information on the current state of the object.
        Is used to redefine the operator <<.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_SVD_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_SVD
math_SVD_swigregister = _math.math_SVD_swigregister
math_SVD_swigregister(math_SVD)

class math_KronrodSingleIntegration(object):
    """
    This class implements the Gauss-Kronrod method of
    integral computation.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_KronrodSingleIntegration self) -> math_KronrodSingleIntegration
        __init__(math_KronrodSingleIntegration self, math_Function theFunction, Standard_Real const theLower, Standard_Real const theUpper, Standard_Integer const theNbPnts) -> math_KronrodSingleIntegration
        __init__(math_KronrodSingleIntegration self, math_Function theFunction, Standard_Real const theLower, Standard_Real const theUpper, Standard_Integer const theNbPnts, Standard_Real const theTolerance, Standard_Integer const theMaxNbIter) -> math_KronrodSingleIntegration

        Constructor. Takes the function, the lower and upper bound
        values, the initial number of Kronrod points, the
        tolerance value and the maximal number of iterations as
        parameters.

        :type theFunction: OCC.wrapper.math.math_Function
        :type theLower: float
        :type theUpper: float
        :type theNbPnts: int
        :type theTolerance: float
        :type theMaxNbIter: int

        """
        this = _math.new_math_KronrodSingleIntegration(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(math_KronrodSingleIntegration self, math_Function theFunction, Standard_Real const theLower, Standard_Real const theUpper, Standard_Integer const theNbPnts)
        Perform(math_KronrodSingleIntegration self, math_Function theFunction, Standard_Real const theLower, Standard_Real const theUpper, Standard_Integer const theNbPnts, Standard_Real const theTolerance, Standard_Integer const theMaxNbIter)

        Computation of the integral. Takes the function,
        the lower and upper bound values, the initial number
        of Kronrod points, the relative tolerance value and the
        maximal number of iterations as parameters.
        theNbPnts should be odd and greater then or equal to 3.
        Note that theTolerance is relative, i.e. the criterion of
        solution reaching is:
        Abs(Kronrod - Gauss)/Abs(Kronrod) < theTolerance.
        theTolerance should be positive.

        :type theFunction: OCC.wrapper.math.math_Function
        :type theLower: float
        :type theUpper: float
        :type theNbPnts: int
        :type theTolerance: float
        :type theMaxNbIter: int

        """
        return _math.math_KronrodSingleIntegration_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(math_KronrodSingleIntegration self) -> Standard_Boolean

        Returns Standard_True if computation is performed
        successfully.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_KronrodSingleIntegration_IsDone(self, *args)


    def Value(self, *args):
        """
        Value(math_KronrodSingleIntegration self) -> Standard_Real

        Returns the value of the integral.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_KronrodSingleIntegration_Value(self, *args)


    def ErrorReached(self, *args):
        """
        ErrorReached(math_KronrodSingleIntegration self) -> Standard_Real

        Returns the value of the relative error reached.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_KronrodSingleIntegration_ErrorReached(self, *args)


    def AbsolutError(self, *args):
        """
        AbsolutError(math_KronrodSingleIntegration self) -> Standard_Real

        Returns the value of the relative error reached.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_KronrodSingleIntegration_AbsolutError(self, *args)


    def OrderReached(self, *args):
        """
        OrderReached(math_KronrodSingleIntegration self) -> Standard_Integer

        Returns the number of Kronrod points
        for which the result is computed.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_KronrodSingleIntegration_OrderReached(self, *args)


    def NbIterReached(self, *args):
        """
        NbIterReached(math_KronrodSingleIntegration self) -> Standard_Integer

        Returns the number of iterations
        that were made to compute result.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_KronrodSingleIntegration_NbIterReached(self, *args)


    def GKRule(*args):
        """
        GKRule(math_Function theFunction, Standard_Real const theLower, Standard_Real const theUpper, math_Vector theGaussP, math_Vector theGaussW, math_Vector theKronrodP, math_Vector theKronrodW) -> Standard_Boolean

        :type theFunction: OCC.wrapper.math.math_Function
        :type theLower: float
        :type theUpper: float
        :type theGaussP: OCC.wrapper.math.math_Vector
        :type theGaussW: OCC.wrapper.math.math_Vector
        :type theKronrodP: OCC.wrapper.math.math_Vector
        :type theKronrodW: OCC.wrapper.math.math_Vector
        :type theValue: float
        :type theError: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_KronrodSingleIntegration_GKRule(*args)

    GKRule = staticmethod(GKRule)
    __swig_destroy__ = _math.delete_math_KronrodSingleIntegration
math_KronrodSingleIntegration_swigregister = _math.math_KronrodSingleIntegration_swigregister
math_KronrodSingleIntegration_swigregister(math_KronrodSingleIntegration)

def math_KronrodSingleIntegration_GKRule(*args):
    """
    math_KronrodSingleIntegration_GKRule(math_Function theFunction, Standard_Real const theLower, Standard_Real const theUpper, math_Vector theGaussP, math_Vector theGaussW, math_Vector theKronrodP, math_Vector theKronrodW) -> Standard_Boolean

    :type theFunction: OCC.wrapper.math.math_Function
    :type theLower: float
    :type theUpper: float
    :type theGaussP: OCC.wrapper.math.math_Vector
    :type theGaussW: OCC.wrapper.math.math_Vector
    :type theKronrodP: OCC.wrapper.math.math_Vector
    :type theKronrodW: OCC.wrapper.math.math_Vector
    :type theValue: float
    :type theError: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _math.math_KronrodSingleIntegration_GKRule(*args)

class math_FunctionWithDerivative(math_Function):
    """
    This abstract class describes the virtual functions associated with
    a function of a single variable for which the first derivative is
    available.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Value(self, *args):
        """
        Value(math_FunctionWithDerivative self, Standard_Real const X) -> Standard_Boolean

        Computes the value <F>of the function for the variable <X>.
        Returns True if the calculation were successfully done,
        False otherwise.

        :type X: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_FunctionWithDerivative_Value(self, *args)


    def Derivative(self, *args):
        """
        Derivative(math_FunctionWithDerivative self, Standard_Real const X) -> Standard_Boolean

        Computes the derivative <D> of the function
        for the variable <X>.
        Returns True if the calculation were successfully done,
        False otherwise.

        :type X: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_FunctionWithDerivative_Derivative(self, *args)


    def Values(self, *args):
        """
        Values(math_FunctionWithDerivative self, Standard_Real const X) -> Standard_Boolean

        Computes the value <F> and the derivative <D> of the
        function for the variable <X>.
        Returns True if the calculation were successfully done,
        False otherwise.

        :type X: float
        :type F: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_FunctionWithDerivative_Values(self, *args)

    __swig_destroy__ = _math.delete_math_FunctionWithDerivative
math_FunctionWithDerivative_swigregister = _math.math_FunctionWithDerivative_swigregister
math_FunctionWithDerivative_swigregister(math_FunctionWithDerivative)

class math_Powell(object):
    """
    This class implements the Powell method to find the minimum of
    function of multiple variables (the gradient does not have to be known).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_Powell self, math_MultipleVarFunction theFunction, Standard_Real const theTolerance, Standard_Integer const theNbIterations=200, Standard_Real const theZEPS=1.0e-12) -> math_Powell

        Constructor. Initialize new entity.

        :type theFunction: OCC.wrapper.math.math_MultipleVarFunction
        :type theTolerance: float
        :type theNbIterations: int
        :type theZEPS: float

        """
        this = _math.new_math_Powell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(math_Powell self, math_MultipleVarFunction theFunction, math_Vector theStartingPoint, math_Matrix theStartingDirections)

        Computes Powell minimization on the function F given
        theStartingPoint, and an initial matrix theStartingDirection
        whose columns contain the initial set of directions.
        The solution F = Fi is found when:
        2.0 * abs(Fi - Fi-1) =< Tolerance * (abs(Fi) + abs(Fi-1) + ZEPS).

        :type theFunction: OCC.wrapper.math.math_MultipleVarFunction
        :type theStartingPoint: OCC.wrapper.math.math_Vector
        :type theStartingDirections: OCC.wrapper.math.math_Matrix

        """
        return _math.math_Powell_Perform(self, *args)


    def IsSolutionReached(self, *args):
        """
        IsSolutionReached(math_Powell self, math_MultipleVarFunction theFunction) -> Standard_Boolean

        Solution F = Fi is found when:
        2.0 * abs(Fi - Fi-1) <= Tolerance * (abs(Fi) + abs(Fi-1)) + ZEPS.
        The maximum number of iterations allowed is given by NbIterations.

        :type theFunction: OCC.wrapper.math.math_MultipleVarFunction
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_Powell_IsSolutionReached(self, *args)


    def IsDone(self, *args):
        """
        IsDone(math_Powell self) -> Standard_Boolean

        Returns true if the computations are successful, otherwise returns false.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_Powell_IsDone(self, *args)


    def Location(self, *args):
        """
        returns the location vector of the minimum.
        Exception NotDone is raised if the minimum was not found.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _math.math_Powell_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Minimum(self, *args):
        """
        Minimum(math_Powell self) -> Standard_Real

        Returns the value of the minimum.
        Exception NotDone is raised if the minimum was not found.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_Powell_Minimum(self, *args)


    def NbIterations(self, *args):
        """
        NbIterations(math_Powell self) -> Standard_Integer

        Returns the number of iterations really done during the
        computation of the minimum.
        Exception NotDone is raised if the minimum was not found.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_Powell_NbIterations(self, *args)


    def Dump(self, *args):
        """
        Dump(math_Powell self, Standard_OStream & o)

        Prints information on the current state of the object.
        Is used to redefine the operator <<.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_Powell_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_Powell
math_Powell_swigregister = _math.math_Powell_swigregister
math_Powell_swigregister(math_Powell)

class math_TrigonometricEquationFunction(math_FunctionWithDerivative):
    """
    This is function, which corresponds trigonometric equation
    a*Cos(x)*Cos(x) + 2*b*Cos(x)*Sin(x) + c*Cos(x) + d*Sin(x) + e = 0
    See class math_TrigonometricFunctionRoots
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_TrigonometricEquationFunction self, Standard_Real const A, Standard_Real const B, Standard_Real const C, Standard_Real const D, Standard_Real const E) -> math_TrigonometricEquationFunction

        :type A: float
        :type B: float
        :type C: float
        :type D: float
        :type E: float

        """
        this = _math.new_math_TrigonometricEquationFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Value(math_TrigonometricEquationFunction self, Standard_Real const X) -> Standard_Boolean

        :type X: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_TrigonometricEquationFunction_Value(self, *args)


    def Derivative(self, *args):
        """
        Derivative(math_TrigonometricEquationFunction self, Standard_Real const X) -> Standard_Boolean

        :type X: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_TrigonometricEquationFunction_Derivative(self, *args)


    def Values(self, *args):
        """
        Values(math_TrigonometricEquationFunction self, Standard_Real const X) -> Standard_Boolean

        :type X: float
        :type F: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_TrigonometricEquationFunction_Values(self, *args)

    __swig_destroy__ = _math.delete_math_TrigonometricEquationFunction
math_TrigonometricEquationFunction_swigregister = _math.math_TrigonometricEquationFunction_swigregister
math_TrigonometricEquationFunction_swigregister(math_TrigonometricEquationFunction)

class NCollection_Array1_math_ValueAndWeight(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_math_ValueAndWeight self) -> NCollection_Array1< math_ValueAndWeight >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _math.NCollection_Array1_math_ValueAndWeight_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_math_ValueAndWeight self) -> NCollection_Array1< math_ValueAndWeight >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _math.NCollection_Array1_math_ValueAndWeight_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_math_ValueAndWeight self) -> NCollection_Array1< math_ValueAndWeight >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _math.NCollection_Array1_math_ValueAndWeight_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_math_ValueAndWeight self) -> NCollection_Array1< math_ValueAndWeight >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _math.NCollection_Array1_math_ValueAndWeight_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _math.new_NCollection_Array1_math_ValueAndWeight(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_math_ValueAndWeight self, math_ValueAndWeight theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _math.NCollection_Array1_math_ValueAndWeight_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_math_ValueAndWeight self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.NCollection_Array1_math_ValueAndWeight_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_math_ValueAndWeight self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.NCollection_Array1_math_ValueAndWeight_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_math_ValueAndWeight self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.NCollection_Array1_math_ValueAndWeight_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_math_ValueAndWeight self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.NCollection_Array1_math_ValueAndWeight_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_math_ValueAndWeight self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.NCollection_Array1_math_ValueAndWeight_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_math_ValueAndWeight self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.NCollection_Array1_math_ValueAndWeight_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_math_ValueAndWeight self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.NCollection_Array1_math_ValueAndWeight_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_math_ValueAndWeight self, NCollection_Array1_math_ValueAndWeight theOther) -> NCollection_Array1_math_ValueAndWeight

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _math.NCollection_Array1_math_ValueAndWeight_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_math_ValueAndWeight self, NCollection_Array1_math_ValueAndWeight theOther) -> NCollection_Array1_math_ValueAndWeight

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _math.NCollection_Array1_math_ValueAndWeight_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_math_ValueAndWeight self, NCollection_Array1_math_ValueAndWeight theOther) -> NCollection_Array1_math_ValueAndWeight
        assign(NCollection_Array1_math_ValueAndWeight self, NCollection_Array1_math_ValueAndWeight theOther) -> NCollection_Array1_math_ValueAndWeight

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _math.NCollection_Array1_math_ValueAndWeight_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _math.NCollection_Array1_math_ValueAndWeight_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_math_ValueAndWeight self) -> math_ValueAndWeight

        @return first element

        :rtype: TheItemType &

        """
        return _math.NCollection_Array1_math_ValueAndWeight_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _math.NCollection_Array1_math_ValueAndWeight_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_math_ValueAndWeight self) -> math_ValueAndWeight

        @return last element

        :rtype: TheItemType &

        """
        return _math.NCollection_Array1_math_ValueAndWeight_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _math.NCollection_Array1_math_ValueAndWeight_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_math_ValueAndWeight self, Standard_Integer const theIndex) -> math_ValueAndWeight

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _math.NCollection_Array1_math_ValueAndWeight_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _math.NCollection_Array1_math_ValueAndWeight___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _math.NCollection_Array1_math_ValueAndWeight_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_math_ValueAndWeight self, Standard_Integer const theIndex, math_ValueAndWeight theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _math.NCollection_Array1_math_ValueAndWeight_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_math_ValueAndWeight self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _math.NCollection_Array1_math_ValueAndWeight_Resize(self, *args)

    __swig_destroy__ = _math.delete_NCollection_Array1_math_ValueAndWeight
NCollection_Array1_math_ValueAndWeight_swigregister = _math.NCollection_Array1_math_ValueAndWeight_swigregister
NCollection_Array1_math_ValueAndWeight_swigregister(NCollection_Array1_math_ValueAndWeight)


try:
	math_Array1OfValueAndWeight = NCollection_Array1_math_ValueAndWeight
except NameError:
	pass # does not exist, probably ignored

class math_Matrix(object):
    """
    This class implements the real matrix abstract data type.
    Matrixes can have an arbitrary range which must be defined
    at the declaration and cannot be changed after this declaration
    math_Matrix(-3,5,2,4); //a vector with range [-3..5, 2..4]
    Matrix values may be initialized and
    retrieved using indexes which must lie within the range
    of definition of the matrix.
    Matrix objects follow "value semantics", that is, they
    cannot be shared and are copied through assignment
    Matrices are copied through assignement:
    math_Matrix M2(1, 9, 1, 3);
    ...
    M2 = M1;
    M1(1) = 2.0;//the matrix M2 will not be modified.

    The exception RangeError is raised when trying to access
    outside the range of a matrix :
    M1(11, 1)=0.0// --> will raise RangeError.

    The exception DimensionError is raised when the dimensions of
    two matrices or vectors are not compatible.
    math_Matrix M3(1, 2, 1, 2);
    M3 = M1;   // will raise DimensionError
    M1.Add(M3) // --> will raise DimensionError.
    A Matrix can be constructed with a a pointer to "c array".
    It allows to carry the bounds inside the matrix.
    Exemple :
    Standard_Real tab1[10][20];
    Standard_Real tab2[200];

    math_Matrix A (tab1[0][0], 1, 10, 1, 20);
    math_Matrix B (tab2[0],    1, 10, 1, 20);
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_Matrix self, Standard_Integer const LowerRow, Standard_Integer const UpperRow, Standard_Integer const LowerCol, Standard_Integer const UpperCol) -> math_Matrix
        __init__(math_Matrix self, Standard_Integer const LowerRow, Standard_Integer const UpperRow, Standard_Integer const LowerCol, Standard_Integer const UpperCol, Standard_Real const InitialValue) -> math_Matrix
        __init__(math_Matrix self, Standard_Address const Tab, Standard_Integer const LowerRow, Standard_Integer const UpperRow, Standard_Integer const LowerCol, Standard_Integer const UpperCol) -> math_Matrix
        __init__(math_Matrix self, math_Matrix Other) -> math_Matrix

        constructs a matrix for copy in initialization.
        An exception is raised if the matrixes have not the same dimensions.

        :type Other: OCC.wrapper.math.math_Matrix

        """
        this = _math.new_math_Matrix(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(math_Matrix self, Standard_Real const InitialValue)

        Initialize all the elements of a matrix to InitialValue.

        :type InitialValue: float

        """
        return _math.math_Matrix_Init(self, *args)


    def RowNumber(self, *args):
        """
        RowNumber(math_Matrix self) -> Standard_Integer

        Returns the number of rows  of this matrix.
        Note that for a matrix A you always have the following relations:
        - A.RowNumber() = A.UpperRow() -   A.LowerRow() + 1
        - A.ColNumber() = A.UpperCol() -   A.LowerCol() + 1
        - the length of a row of A is equal to the number of columns of A,
        - the length of a column of A is equal to the number of
        rows of A.returns the row range of a matrix.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_Matrix_RowNumber(self, *args)


    def ColNumber(self, *args):
        """
        ColNumber(math_Matrix self) -> Standard_Integer

        Returns the number of rows  of this matrix.
        Note that for a matrix A you always have the following relations:
        - A.RowNumber() = A.UpperRow() -   A.LowerRow() + 1
        - A.ColNumber() = A.UpperCol() -   A.LowerCol() + 1
        - the length of a row of A is equal to the number of columns of A,
        - the length of a column of A is equal to the number of
        rows of A.returns the row range of a matrix.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_Matrix_ColNumber(self, *args)


    def LowerRow(self, *args):
        """
        LowerRow(math_Matrix self) -> Standard_Integer

        Returns the value of the Lower index of the row
        range of a matrix.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_Matrix_LowerRow(self, *args)


    def UpperRow(self, *args):
        """
        UpperRow(math_Matrix self) -> Standard_Integer

        Returns the Upper index of the row range
        of a matrix.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_Matrix_UpperRow(self, *args)


    def LowerCol(self, *args):
        """
        LowerCol(math_Matrix self) -> Standard_Integer

        Returns the value of the Lower index of the
        column range of a matrix.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_Matrix_LowerCol(self, *args)


    def UpperCol(self, *args):
        """
        UpperCol(math_Matrix self) -> Standard_Integer

        Returns the value of the upper index of the
        column range of a matrix.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_Matrix_UpperCol(self, *args)


    def Determinant(self, *args):
        """
        Determinant(math_Matrix self) -> Standard_Real

        Computes the determinant of a matrix.
        An exception is raised if the matrix is not a square matrix.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_Matrix_Determinant(self, *args)


    def Transpose(self, *args):
        """
        Transpose(math_Matrix self)

        Transposes a given matrix.
        An exception is raised if the matrix is not a square matrix.


        """
        return _math.math_Matrix_Transpose(self, *args)


    def Invert(self, *args):
        """
        Invert(math_Matrix self)

        Inverts a matrix using Gauss algorithm.
        Exception NotSquare is raised if the matrix is not square.
        Exception SingularMatrix is raised if the matrix is singular.


        """
        return _math.math_Matrix_Invert(self, *args)


    def TMultiplied(self, *args):
        """
        TMultiplied(math_Matrix self, Standard_Real const Right) -> math_Matrix

        Sets this matrix to the product of the
        transposed matrix TLeft, and the matrix Right.
        Example
        math_Matrix A (1, 3, 1, 3);
        math_Matrix B (1, 3, 1, 3);
        // A = ... , B = ...
        math_Matrix C (1, 3, 1, 3);
        C.Multiply(A, B);
        Exceptions
        Standard_DimensionError if matrices are of incompatible dimensions, i.e. if:
        -   the number of columns of matrix Left, or the number of
        rows of matrix TLeft is not equal to the number of rows
        of matrix Right, or
        -   the number of rows of matrix Left, or the number of
        columns of matrix TLeft is not equal to the number of
        rows of this matrix, or
        -   the number of columns of matrix Right is not equal to
        the number of columns of this matrix.

        :type Right: float
        :rtype: OCC.wrapper.math.math_Matrix

        """
        return _math.math_Matrix_TMultiplied(self, *args)


    def Divide(self, *args):
        """
        Divide(math_Matrix self, Standard_Real const Right)

        divides all the elements of a matrix by the value <Right>.
        An exception is raised if <Right> = 0.

        :type Right: float

        """
        return _math.math_Matrix_Divide(self, *args)


    def __itruediv__(self, *args):
        return _math.math_Matrix___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def Divided(self, *args):
        """
        Divided(math_Matrix self, Standard_Real const Right) -> math_Matrix

        divides all the elements of a matrix by the value <Right>.
        An exception is raised if <Right> = 0.

        :type Right: float
        :rtype: OCC.wrapper.math.math_Matrix

        """
        return _math.math_Matrix_Divided(self, *args)


    def __truediv__(self, *args):
        return _math.math_Matrix___truediv__(self, *args)
    __div__ = __truediv__



    def __iadd__(self, *args):
        """
        __iadd__(math_Matrix self, math_Matrix Right)

        :type Right: OCC.wrapper.math.math_Matrix

        """
        return _math.math_Matrix___iadd__(self, *args)


    def Added(self, *args):
        """
        Added(math_Matrix self, math_Matrix Right) -> math_Matrix

        adds the matrix <Right> to a matrix.
        An exception is raised if the dimensions are different.

        :type Right: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.math.math_Matrix

        """
        return _math.math_Matrix_Added(self, *args)


    def __add__(self, *args):
        """
        __add__(math_Matrix self, math_Matrix Right) -> math_Matrix

        :type Right: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.math.math_Matrix

        """
        return _math.math_Matrix___add__(self, *args)


    def Add(self, *args):
        """
        Add(math_Matrix self, math_Matrix Right)
        Add(math_Matrix self, math_Matrix Left, math_Matrix Right)

        sets a  matrix to the addition of <Left> and <Right>.
        An exception is raised if the dimensions are different.

        :type Left: OCC.wrapper.math.math_Matrix
        :type Right: OCC.wrapper.math.math_Matrix

        """
        return _math.math_Matrix_Add(self, *args)


    def __isub__(self, *args):
        """
        __isub__(math_Matrix self, math_Matrix Right)

        :type Right: OCC.wrapper.math.math_Matrix

        """
        return _math.math_Matrix___isub__(self, *args)


    def Subtracted(self, *args):
        """
        Subtracted(math_Matrix self, math_Matrix Right) -> math_Matrix

        Returns the result of the subtraction of <Right> from <me>.
        An exception is raised if the dimensions are different.

        :type Right: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.math.math_Matrix

        """
        return _math.math_Matrix_Subtracted(self, *args)


    def __sub__(self, *args):
        """
        __sub__(math_Matrix self, math_Matrix Right) -> math_Matrix

        :type Right: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.math.math_Matrix

        """
        return _math.math_Matrix___sub__(self, *args)


    def Set(self, *args):
        """
        Set(math_Matrix self, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const J1, Standard_Integer const J2, math_Matrix M)

        Sets the values of this matrix,
        -   from index I1 to index I2 on the row dimension, and
        -   from index J1 to index J2 on the column dimension,
        to those of matrix M.
        Exceptions
        Standard_DimensionError if:
        -   I1 is less than the index of the lower row bound of this matrix, or
        -   I2 is greater than the index of the upper row bound of this matrix, or
        -   J1 is less than the index of the lower column bound of this matrix, or
        -   J2 is greater than the index of the upper column bound of this matrix, or
        -   I2 - I1 + 1 is not equal to the number of rows of matrix M, or
        -   J2 - J1 + 1 is not equal to the number of columns of matrix M.

        :type I1: int
        :type I2: int
        :type J1: int
        :type J2: int
        :type M: OCC.wrapper.math.math_Matrix

        """
        return _math.math_Matrix_Set(self, *args)


    def SetRow(self, *args):
        """
        SetRow(math_Matrix self, Standard_Integer const Row, math_Vector V)

        Sets the row of index Row of a matrix to the vector <V>.
        An exception is raised if the dimensions are different.
        An exception is raises if <Row> is inferior to the lower
        row of the matrix or <Row> is superior to the upper row.

        :type Row: int
        :type V: OCC.wrapper.math.math_Vector

        """
        return _math.math_Matrix_SetRow(self, *args)


    def SetCol(self, *args):
        """
        SetCol(math_Matrix self, Standard_Integer const Col, math_Vector V)

        Sets the column of index Col of a matrix to the vector <V>.
        An exception is raised if the dimensions are different.
        An exception is raises if <Col> is inferior to the lower
        column of the matrix or <Col> is superior to the upper
        column.

        :type Col: int
        :type V: OCC.wrapper.math.math_Vector

        """
        return _math.math_Matrix_SetCol(self, *args)


    def SetDiag(self, *args):
        """
        SetDiag(math_Matrix self, Standard_Real const Value)

        Sets the diagonal of a matrix to the value <Value>.
        An exception is raised if the matrix is not square.

        :type Value: float

        """
        return _math.math_Matrix_SetDiag(self, *args)


    def Row(self, *args):
        """
        Row(math_Matrix self, Standard_Integer const Row) -> math_Vector

        Returns the row of index Row of a matrix.

        :type Row: int
        :rtype: OCC.wrapper.math.math_Vector

        """
        return _math.math_Matrix_Row(self, *args)


    def Col(self, *args):
        """
        Col(math_Matrix self, Standard_Integer const Col) -> math_Vector

        Returns the column of index <Col> of a matrix.

        :type Col: int
        :rtype: OCC.wrapper.math.math_Vector

        """
        return _math.math_Matrix_Col(self, *args)


    def SwapRow(self, *args):
        """
        SwapRow(math_Matrix self, Standard_Integer const Row1, Standard_Integer const Row2)

        Swaps the rows of index Row1 and Row2.
        An exception is raised if <Row1> or <Row2> is out of range.

        :type Row1: int
        :type Row2: int

        """
        return _math.math_Matrix_SwapRow(self, *args)


    def SwapCol(self, *args):
        """
        SwapCol(math_Matrix self, Standard_Integer const Col1, Standard_Integer const Col2)

        Swaps the columns of index <Col1> and <Col2>.
        An exception is raised if <Col1> or <Col2> is out of range.

        :type Col1: int
        :type Col2: int

        """
        return _math.math_Matrix_SwapCol(self, *args)


    def Transposed(self, *args):
        """
        Transposed(math_Matrix self) -> math_Matrix

        Teturns the transposed of a matrix.
        An exception is raised if the matrix is not a square matrix.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        return _math.math_Matrix_Transposed(self, *args)


    def Inverse(self, *args):
        """
        Inverse(math_Matrix self) -> math_Matrix

        Returns the inverse of a matrix.
        Exception NotSquare is raised if the matrix is not square.
        Exception SingularMatrix is raised if the matrix is singular.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        return _math.math_Matrix_Inverse(self, *args)


    def TMultiply(self, *args):
        """
        TMultiply(math_Matrix self, math_Matrix Right) -> math_Matrix
        TMultiply(math_Matrix self, math_Matrix TLeft, math_Matrix Right)

        Computes a matrix to the product of the transpose of
        the matrix <TLeft> with the matrix <Right>.
        An exception is raised if the dimensions are different.

        :type TLeft: OCC.wrapper.math.math_Matrix
        :type Right: OCC.wrapper.math.math_Matrix

        """
        return _math.math_Matrix_TMultiply(self, *args)


    def Subtract(self, *args):
        """
        Subtract(math_Matrix self, math_Matrix Right)
        Subtract(math_Matrix self, math_Matrix Left, math_Matrix Right)

        Sets a matrix to the Subtraction of the matrix <Right>
        from the matrix <Left>.
        An exception is raised if the dimensions are different.

        :type Left: OCC.wrapper.math.math_Matrix
        :type Right: OCC.wrapper.math.math_Matrix

        """
        return _math.math_Matrix_Subtract(self, *args)


    def Value(self, *args):
        """
        Value(math_Matrix self, Standard_Integer const Row, Standard_Integer const Col) -> Standard_Real &

        Accesses (in read or write mode) the value of index <Row>
        and <Col> of a matrix.
        An exception is raised if <Row> and <Col> are not
        in the correct range.

        :type Row: int
        :type Col: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_Matrix_Value(self, *args)


    def __call__(self, *args):
        """
        __call__(math_Matrix self, Standard_Integer const Row, Standard_Integer const Col) -> Standard_Real &

        :type Row: int
        :type Col: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_Matrix___call__(self, *args)


    def Initialized(self, *args):
        """
        Initialized(math_Matrix self, math_Matrix Other) -> math_Matrix

        Matrixes are copied through assignement.
        An exception is raised if the dimensions are differents.

        :type Other: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.math.math_Matrix

        """
        return _math.math_Matrix_Initialized(self, *args)


    def assign(self, *args):
        """
        assign(math_Matrix self, math_Matrix Other) -> math_Matrix

        :type Other: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.math.math_Matrix

        """
        return _math.math_Matrix_assign(self, *args)


    def Multiply(self, *args):
        """
        Multiply(math_Matrix self, Standard_Real const Right)
        Multiply(math_Matrix self, math_Vector Left, math_Vector Right)
        Multiply(math_Matrix self, math_Matrix Left, math_Matrix Right)
        Multiply(math_Matrix self, math_Matrix Right)

        Returns the product of 2 matrices.
        An exception is raised if the dimensions are different.

        :type Right: OCC.wrapper.math.math_Matrix

        """
        return _math.math_Matrix_Multiply(self, *args)


    def __imul__(self, *args):
        """
        __imul__(math_Matrix self, Standard_Real const Right)
        __imul__(math_Matrix self, math_Matrix Right)

        :type Right: OCC.wrapper.math.math_Matrix

        """
        return _math.math_Matrix___imul__(self, *args)


    def Multiplied(self, *args):
        """
        Multiplied(math_Matrix self, Standard_Real const Right) -> math_Matrix
        Multiplied(math_Matrix self, math_Matrix Right) -> math_Matrix
        Multiplied(math_Matrix self, math_Vector Right) -> math_Vector

        Returns the product of a matrix by a vector.
        An exception is raised if the dimensions are different.

        :type Right: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.math.math_Vector

        """
        return _math.math_Matrix_Multiplied(self, *args)


    def __mul__(self, *args):
        """
        __mul__(math_Matrix self, Standard_Real const Right) -> math_Matrix
        __mul__(math_Matrix self, math_Matrix Right) -> math_Matrix
        __mul__(math_Matrix self, math_Vector Right) -> math_Vector

        :type Right: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.math.math_Vector

        """
        return _math.math_Matrix___mul__(self, *args)


    def Opposite(self, *args):
        """
        Opposite(math_Matrix self) -> math_Matrix

        Returns the opposite of a matrix.
        An exception is raised if the dimensions are different.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        return _math.math_Matrix_Opposite(self, *args)


    def __neg__(self, *args):
        """
        __neg__(math_Matrix self) -> math_Matrix

        :rtype: OCC.wrapper.math.math_Matrix

        """
        return _math.math_Matrix___neg__(self, *args)


    def Dump(self, *args):
        """
        Dump(math_Matrix self, Standard_OStream & o)

        Prints information on the current state of the object.
        Is used to redefine the operator <<.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_Matrix_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_Matrix
math_Matrix_swigregister = _math.math_Matrix_swigregister
math_Matrix_swigregister(math_Matrix)

class Handle_math_NotSquare(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_math_NotSquare self)

        Nullify the handle


        """
        return _math.Handle_math_NotSquare_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_math_NotSquare self) -> bool

        Check for being null

        :rtype: bool

        """
        return _math.Handle_math_NotSquare_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_math_NotSquare self, math_NotSquare thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _math.Handle_math_NotSquare_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_math_NotSquare self, Handle_math_NotSquare theHandle) -> Handle_math_NotSquare
        assign(Handle_math_NotSquare self, math_NotSquare thePtr) -> Handle_math_NotSquare
        assign(Handle_math_NotSquare self, Handle_math_NotSquare theHandle) -> Handle_math_NotSquare

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _math.Handle_math_NotSquare_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_math_NotSquare self) -> math_NotSquare

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _math.Handle_math_NotSquare_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_math_NotSquare self) -> math_NotSquare

        Member access operator (note non-const)

        :rtype: T *

        """
        return _math.Handle_math_NotSquare___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_math_NotSquare self) -> math_NotSquare

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _math.Handle_math_NotSquare___ref__(self, *args)


    def __hash__(self):
        return _math.Handle_math_NotSquare___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _math.Handle_math_NotSquare___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _math.new_Handle_math_NotSquare(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_math.Handle_math_NotSquare_DownCast)
    __swig_destroy__ = _math.delete_Handle_math_NotSquare

    def NewInstance(self, *args):
        """
        NewInstance(Handle_math_NotSquare self, Standard_CString const theMessage) -> Handle_math_NotSquare

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.math.Handle_math_NotSquare

        """
        return _math.Handle_math_NotSquare_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_math_NotSquare self) -> char const *

        :rtype: const char *

        """
        return _math.Handle_math_NotSquare_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _math.Handle_math_NotSquare_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _math.Handle_math_NotSquare_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_math_NotSquare self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.Handle_math_NotSquare_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_math_NotSquare self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _math.Handle_math_NotSquare_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_math_NotSquare self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _math.Handle_math_NotSquare_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_math_NotSquare self)
        Reraise(Handle_math_NotSquare self, Standard_CString const aMessage)
        Reraise(Handle_math_NotSquare self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _math.Handle_math_NotSquare_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_math_NotSquare self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _math.Handle_math_NotSquare_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_math_NotSquare self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _math.Handle_math_NotSquare_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_math_NotSquare self)

        Memory deallocator for transient classes


        """
        return _math.Handle_math_NotSquare_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_math_NotSquare self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_math_NotSquare self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.Handle_math_NotSquare_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_math_NotSquare self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_math_NotSquare self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.Handle_math_NotSquare_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_math_NotSquare self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _math.Handle_math_NotSquare_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_math_NotSquare self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.Handle_math_NotSquare_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_math_NotSquare self)

        Increments the reference counter of this object


        """
        return _math.Handle_math_NotSquare_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_math_NotSquare self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.Handle_math_NotSquare_DecrementRefCounter(self, *args)

Handle_math_NotSquare_swigregister = _math.Handle_math_NotSquare_swigregister
Handle_math_NotSquare_swigregister(Handle_math_NotSquare)

def Handle_math_NotSquare_DownCast(thing):
    return _math.Handle_math_NotSquare_DownCast(thing)
Handle_math_NotSquare_DownCast = _math.Handle_math_NotSquare_DownCast

class math_DoubleTab(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Init(self, *args):
        """
        Init(math_DoubleTab self, Standard_Real const InitValue)

        :type InitValue: float

        """
        return _math.math_DoubleTab_Init(self, *args)


    def __init__(self, *args):
        """
        __init__(math_DoubleTab self, Standard_Integer const LowerRow, Standard_Integer const UpperRow, Standard_Integer const LowerCol, Standard_Integer const UpperCol) -> math_DoubleTab
        __init__(math_DoubleTab self, Standard_Address const Tab, Standard_Integer const LowerRow, Standard_Integer const UpperRow, Standard_Integer const LowerCol, Standard_Integer const UpperCol) -> math_DoubleTab
        __init__(math_DoubleTab self, math_DoubleTab Other) -> math_DoubleTab

        :type Other: OCC.wrapper.math.math_DoubleTab

        """
        this = _math.new_math_DoubleTab(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Copy(self, *args):
        """
        Copy(math_DoubleTab self, math_DoubleTab Other)

        :type Other: OCC.wrapper.math.math_DoubleTab

        """
        return _math.math_DoubleTab_Copy(self, *args)


    def SetLowerRow(self, *args):
        """
        SetLowerRow(math_DoubleTab self, Standard_Integer const LowerRow)

        :type LowerRow: int

        """
        return _math.math_DoubleTab_SetLowerRow(self, *args)


    def SetLowerCol(self, *args):
        """
        SetLowerCol(math_DoubleTab self, Standard_Integer const LowerCol)

        :type LowerCol: int

        """
        return _math.math_DoubleTab_SetLowerCol(self, *args)


    def Value(self, *args):
        """
        Value(math_DoubleTab self, Standard_Integer const RowIndex, Standard_Integer const ColIndex) -> Standard_Real &

        :type RowIndex: int
        :type ColIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_DoubleTab_Value(self, *args)


    def __call__(self, *args):
        """
        __call__(math_DoubleTab self, Standard_Integer const RowIndex, Standard_Integer const ColIndex) -> Standard_Real &

        :type RowIndex: int
        :type ColIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_DoubleTab___call__(self, *args)


    def Free(self, *args):
        """Free(math_DoubleTab self)"""
        return _math.math_DoubleTab_Free(self, *args)

    __swig_destroy__ = _math.delete_math_DoubleTab
math_DoubleTab_swigregister = _math.math_DoubleTab_swigregister
math_DoubleTab_swigregister(math_DoubleTab)

class math_NewtonFunctionSetRoot(object):
    """
    This class computes the root of a set of N functions of N variables,
    knowing an initial guess at the solution and using the
    Newton Raphson algorithm. Knowledge of all the partial
    derivatives (Jacobian) is required.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_NewtonFunctionSetRoot self, math_FunctionSetWithDerivatives theFunction, math_Vector theXTolerance, Standard_Real const theFTolerance, Standard_Integer const tehNbIterations=100) -> math_NewtonFunctionSetRoot
        __init__(math_NewtonFunctionSetRoot self, math_FunctionSetWithDerivatives theFunction, Standard_Real const theFTolerance, Standard_Integer const theNbIterations=100) -> math_NewtonFunctionSetRoot

        This constructor should be used in a sub-class to initialize
        correctly all the fields of this class.
        The range (1, F.NbVariables()) must be especially respected for
        all vectors and matrix declarations.
        The method SetTolerance must be called before performing the algorithm.

        :type theFunction: OCC.wrapper.math.math_FunctionSetWithDerivatives
        :type theFTolerance: float
        :type theNbIterations: int

        """
        this = _math.new_math_NewtonFunctionSetRoot(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetTolerance(self, *args):
        """
        SetTolerance(math_NewtonFunctionSetRoot self, math_Vector XTol)

        Initializes the tolerance values for the unknowns.

        :type XTol: OCC.wrapper.math.math_Vector

        """
        return _math.math_NewtonFunctionSetRoot_SetTolerance(self, *args)


    def Perform(self, *args):
        """
        Perform(math_NewtonFunctionSetRoot self, math_FunctionSetWithDerivatives theFunction, math_Vector theStartingPoint)
        Perform(math_NewtonFunctionSetRoot self, math_FunctionSetWithDerivatives theFunction, math_Vector theStartingPoint, math_Vector theInfBound, math_Vector theSupBound)

        The Newton method is done to improve the root of the function
        from the initial guess point. Bounds may be given, to constrain the solution.
        The solution is found when:
        abs(Xj - Xj-1)(i) <= XTol(i) and abs(Fi) <= FTol for all i;

        :type theFunction: OCC.wrapper.math.math_FunctionSetWithDerivatives
        :type theStartingPoint: OCC.wrapper.math.math_Vector
        :type theInfBound: OCC.wrapper.math.math_Vector
        :type theSupBound: OCC.wrapper.math.math_Vector

        """
        return _math.math_NewtonFunctionSetRoot_Perform(self, *args)


    def IsSolutionReached(self, *args):
        """
        IsSolutionReached(math_NewtonFunctionSetRoot self, math_FunctionSetWithDerivatives F) -> Standard_Boolean

        This method is called at the end of each iteration to check if the
        solution is found.
        Vectors DeltaX, Fvalues and Jacobian Matrix are consistent with the
        possible solution Vector Sol and can be inspected to decide whether
        the solution is reached or not.

        :type F: OCC.wrapper.math.math_FunctionSetWithDerivatives
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_NewtonFunctionSetRoot_IsSolutionReached(self, *args)


    def IsDone(self, *args):
        """
        IsDone(math_NewtonFunctionSetRoot self) -> Standard_Boolean

        Returns true if the computations are successful, otherwise returns false.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_NewtonFunctionSetRoot_IsDone(self, *args)


    def Root(self, *args):
        """
        Returns the value of the root of function F.
        Exceptions
        StdFail_NotDone if the algorithm fails (and IsDone returns false).

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _math.math_NewtonFunctionSetRoot_Root(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Derivative(self, *args):
        """
        Returns the matrix value of the derivative at the root.
        Exception NotDone is raised if the root was not found.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _math.math_NewtonFunctionSetRoot_Derivative(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FunctionSetErrors(self, *args):
        """
        Returns the vector value of the error done on the
        functions at the root.
        Exception NotDone is raised if the root was not found.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _math.math_NewtonFunctionSetRoot_FunctionSetErrors(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbIterations(self, *args):
        """
        NbIterations(math_NewtonFunctionSetRoot self) -> Standard_Integer

        Returns the number of iterations really done
        during the computation of the Root.
        Exception NotDone is raised if the root was not found.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_NewtonFunctionSetRoot_NbIterations(self, *args)


    def Dump(self, *args):
        """
        Dump(math_NewtonFunctionSetRoot self, Standard_OStream & o)

        Prints information on the current state of the object.
        Is used to redefine the operator <<.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_NewtonFunctionSetRoot_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_NewtonFunctionSetRoot
math_NewtonFunctionSetRoot_swigregister = _math.math_NewtonFunctionSetRoot_swigregister
math_NewtonFunctionSetRoot_swigregister(math_NewtonFunctionSetRoot)

class math_GaussSetIntegration(object):
    """
    -- This class implements the integration of a set of N
    functions of M  variables variables between the
    parameter bounds Lower[a..b] and Upper[a..b].
    Warning: - The case M>1 is not implemented.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_GaussSetIntegration self, math_FunctionSet F, math_Vector Lower, math_Vector Upper, math_IntegerVector Order) -> math_GaussSetIntegration

        The Gauss-Legendre integration with Order = points of
        integration for each unknow, is done on the function F
        between the bounds Lower and Upper.

        :type F: OCC.wrapper.math.math_FunctionSet
        :type Lower: OCC.wrapper.math.math_Vector
        :type Upper: OCC.wrapper.math.math_Vector
        :type Order: OCC.wrapper.math.math_IntegerVector

        """
        this = _math.new_math_GaussSetIntegration(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(math_GaussSetIntegration self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_GaussSetIntegration_IsDone(self, *args)


    def Value(self, *args):
        """
        returns the value of the integral.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _math.math_GaussSetIntegration_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Dump(self, *args):
        """
        Dump(math_GaussSetIntegration self, Standard_OStream & o)

        Prints information on the current state of the object.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_GaussSetIntegration_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_GaussSetIntegration
math_GaussSetIntegration_swigregister = _math.math_GaussSetIntegration_swigregister
math_GaussSetIntegration_swigregister(math_GaussSetIntegration)

class math_Vector(object):
    """
    This class implements the real vector abstract data type.
    Vectors can have an arbitrary range which must be defined at
    the declaration and cannot be changed after this declaration.
    @code
    math_Vector V1(-3, 5); // a vector with range [-3..5]
    @endcode

    Vector are copied through assignement :
    @code
    math_Vector V2( 1, 9);
    ....
    V2 = V1;
    V1(1) = 2.0; // the vector V2 will not be modified.
    @endcode

    The Exception RangeError is raised when trying to access outside
    the range of a vector :
    @code
    V1(11) = 0.0 // --> will raise RangeError;
    @endcode

    The Exception DimensionError is raised when the dimensions of two
    vectors are not compatible :
    @code
    math_Vector V3(1, 2);
    V3 = V1;    // --> will raise DimensionError;
    V1.Add(V3)  // --> will raise DimensionError;
    @endcode
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Init(self, *args):
        """
        Init(math_Vector self, Standard_Real const theInitialValue)

        Initialize all the elements of a vector with "theInitialValue".

        :type theInitialValue: float

        """
        return _math.math_Vector_Init(self, *args)


    def __init__(self, *args):
        """
        __init__(math_Vector self, Standard_Integer const theLower, Standard_Integer const theUpper) -> math_Vector
        __init__(math_Vector self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Real const theInitialValue) -> math_Vector
        __init__(math_Vector self, Standard_Address const theTab, Standard_Integer const theLower, Standard_Integer const theUpper) -> math_Vector
        __init__(math_Vector self, gp_XY Other) -> math_Vector
        __init__(math_Vector self, gp_XYZ Other) -> math_Vector
        __init__(math_Vector self, math_Vector theOther) -> math_Vector

        Constructs a copy for initialization.
        An exception is raised if the lengths of the vectors are different.

        :type theOther: OCC.wrapper.math.math_Vector

        """
        this = _math.new_math_Vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(math_Vector self) -> Standard_Integer

        Returns the length of a vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_Vector_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(math_Vector self) -> Standard_Integer

        Returns the value of the theLower index of a vector.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_Vector_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(math_Vector self) -> Standard_Integer

        Returns the value of the theUpper index of a vector.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_Vector_Upper(self, *args)


    def Norm(self, *args):
        """
        Norm(math_Vector self) -> Standard_Real

        Returns the value or the square  of the norm of this vector.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_Vector_Norm(self, *args)


    def Norm2(self, *args):
        """
        Norm2(math_Vector self) -> Standard_Real

        Returns the value of the square of the norm of a vector.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_Vector_Norm2(self, *args)


    def Max(self, *args):
        """
        Max(math_Vector self) -> Standard_Integer

        Returns the value of the "Index" of the maximum element of a vector.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_Vector_Max(self, *args)


    def Min(self, *args):
        """
        Min(math_Vector self) -> Standard_Integer

        Returns the value of the "Index" of the minimum element  of a vector.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_Vector_Min(self, *args)


    def Normalize(self, *args):
        """
        Normalize(math_Vector self)

        Normalizes this vector (the norm of the result
        is equal to 1.0) and assigns the result to this vector
        Exceptions
        Standard_NullValue if this vector is null (i.e. if its norm is
        less than or equal to Standard_Real::RealEpsilon().


        """
        return _math.math_Vector_Normalize(self, *args)


    def Normalized(self, *args):
        """
        Normalized(math_Vector self) -> math_Vector

        Normalizes this vector (the norm of the result
        is equal to 1.0) and creates a new vector
        Exceptions
        Standard_NullValue if this vector is null (i.e. if its norm is
        less than or equal to Standard_Real::RealEpsilon().

        :rtype: OCC.wrapper.math.math_Vector

        """
        return _math.math_Vector_Normalized(self, *args)


    def Invert(self, *args):
        """
        Invert(math_Vector self)

        Inverts this vector and assigns the result to this vector.


        """
        return _math.math_Vector_Invert(self, *args)


    def Inverse(self, *args):
        """
        Inverse(math_Vector self) -> math_Vector

        Inverts this vector and creates a new vector.

        :rtype: OCC.wrapper.math.math_Vector

        """
        return _math.math_Vector_Inverse(self, *args)


    def Set(self, *args):
        """
        Set(math_Vector self, Standard_Integer const theI1, Standard_Integer const theI2, math_Vector theV)

        sets a vector from "theI1" to "theI2" to the vector "theV";
        An exception is raised if "theI1" is less than "LowerIndex" or "theI2" is greater than "UpperIndex" or "theI1" is greater than "theI2".
        An exception is raised if "theI2-theI1+1" is different from the "Length" of "theV".

        :type theI1: int
        :type theI2: int
        :type theV: OCC.wrapper.math.math_Vector

        """
        return _math.math_Vector_Set(self, *args)


    def Slice(self, *args):
        """
        Slice(math_Vector self, Standard_Integer const theI1, Standard_Integer const theI2) -> math_Vector

        Creates a new vector by inverting the values of this vector
        between indexes "theI1" and "theI2".
        If the values of this vector were (1., 2., 3., 4.,5., 6.),
        by slicing it between indexes 2 and 5 the values
        of the resulting vector are (1., 5., 4., 3., 2., 6.)

        :type theI1: int
        :type theI2: int
        :rtype: OCC.wrapper.math.math_Vector

        """
        return _math.math_Vector_Slice(self, *args)


    def __imul__(self, *args):
        """
        __imul__(math_Vector self, Standard_Real const theRight)

        :type theRight: float

        """
        return _math.math_Vector___imul__(self, *args)


    def TMultiplied(self, *args):
        """
        TMultiplied(math_Vector self, Standard_Real const theRight) -> math_Vector

        returns the product of a vector and a real value.

        :type theRight: float
        :rtype: OCC.wrapper.math.math_Vector

        """
        return _math.math_Vector_TMultiplied(self, *args)


    def Divide(self, *args):
        """
        Divide(math_Vector self, Standard_Real const theRight)

        divides a vector by the value "theRight".
        An exception is raised if "theRight" = 0.

        :type theRight: float

        """
        return _math.math_Vector_Divide(self, *args)


    def __itruediv__(self, *args):
        return _math.math_Vector___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def Divided(self, *args):
        """
        Divided(math_Vector self, Standard_Real const theRight) -> math_Vector

        divides a vector by the value "theRight".
        An exception is raised if "theRight" = 0.

        :type theRight: float
        :rtype: OCC.wrapper.math.math_Vector

        """
        return _math.math_Vector_Divided(self, *args)


    def __truediv__(self, *args):
        return _math.math_Vector___truediv__(self, *args)
    __div__ = __truediv__



    def __iadd__(self, *args):
        """
        __iadd__(math_Vector self, math_Vector theRight)

        :type theRight: OCC.wrapper.math.math_Vector

        """
        return _math.math_Vector___iadd__(self, *args)


    def Added(self, *args):
        """
        Added(math_Vector self, math_Vector theRight) -> math_Vector

        adds the vector theRight to a vector.
        An exception is raised if the vectors have not the same length.
        An exception is raised if the lengths are not equal.

        :type theRight: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.math.math_Vector

        """
        return _math.math_Vector_Added(self, *args)


    def __add__(self, *args):
        """
        __add__(math_Vector self, math_Vector theRight) -> math_Vector

        :type theRight: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.math.math_Vector

        """
        return _math.math_Vector___add__(self, *args)


    def TMultiply(self, *args):
        """
        TMultiply(math_Vector self, math_Matrix theTLeft, math_Vector theRight)
        TMultiply(math_Vector self, math_Vector theLeft, math_Matrix theTRight)

        sets a vector to the product of the vector
        "theLeft" by the transpose of the matrix "theTRight".

        :type theLeft: OCC.wrapper.math.math_Vector
        :type theTRight: OCC.wrapper.math.math_Matrix

        """
        return _math.math_Vector_TMultiply(self, *args)


    def Add(self, *args):
        """
        Add(math_Vector self, math_Vector theRight)
        Add(math_Vector self, math_Vector theLeft, math_Vector theRight)

        sets a vector to the sum of the vector "theLeft"
        and the vector "theRight".
        An exception is raised if the lengths are different.

        :type theLeft: OCC.wrapper.math.math_Vector
        :type theRight: OCC.wrapper.math.math_Vector

        """
        return _math.math_Vector_Add(self, *args)


    def Value(self, *args):
        """
        Value(math_Vector self, Standard_Integer const theNum) -> Standard_Real &

        accesses (in read or write mode) the value of index "theNum" of a vector.

        :type theNum: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_Vector_Value(self, *args)


    def __call__(self, *args):
        """
        __call__(math_Vector self, Standard_Integer const theNum) -> Standard_Real &

        :type theNum: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_Vector___call__(self, *args)


    def Initialized(self, *args):
        """
        Initialized(math_Vector self, math_Vector theOther) -> math_Vector

        Initialises a vector by copying "theOther".
        An exception is raised if the Lengths are differents.

        :type theOther: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.math.math_Vector

        """
        return _math.math_Vector_Initialized(self, *args)


    def assign(self, *args):
        """
        assign(math_Vector self, math_Vector theOther) -> math_Vector

        :type theOther: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.math.math_Vector

        """
        return _math.math_Vector_assign(self, *args)


    def Multiplied(self, *args):
        """
        Multiplied(math_Vector self, Standard_Real const theRight) -> math_Vector
        Multiplied(math_Vector self, math_Vector theRight) -> Standard_Real
        Multiplied(math_Vector self, math_Matrix theRight) -> math_Vector

        returns the product of a vector by a matrix.

        :type theRight: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.math.math_Vector

        """
        return _math.math_Vector_Multiplied(self, *args)


    def __mul__(self, *args):
        """
        __mul__(math_Vector self, Standard_Real const theRight) -> math_Vector
        __mul__(math_Vector self, math_Vector theRight) -> Standard_Real
        __mul__(math_Vector self, math_Matrix theRight) -> math_Vector

        :type theRight: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.math.math_Vector

        """
        return _math.math_Vector___mul__(self, *args)


    def Opposite(self, *args):
        """
        Opposite(math_Vector self) -> math_Vector

        returns the opposite of a vector.

        :rtype: OCC.wrapper.math.math_Vector

        """
        return _math.math_Vector_Opposite(self, *args)


    def __neg__(self, *args):
        """
        __neg__(math_Vector self) -> math_Vector

        :rtype: OCC.wrapper.math.math_Vector

        """
        return _math.math_Vector___neg__(self, *args)


    def Subtract(self, *args):
        """
        Subtract(math_Vector self, math_Vector theLeft, math_Vector theRight)
        Subtract(math_Vector self, math_Vector theRight)

        returns the subtraction of "theRight" from "me".
        An exception is raised if the vectors have not the same length.

        :type theRight: OCC.wrapper.math.math_Vector

        """
        return _math.math_Vector_Subtract(self, *args)


    def __isub__(self, *args):
        """
        __isub__(math_Vector self, math_Vector theRight)

        :type theRight: OCC.wrapper.math.math_Vector

        """
        return _math.math_Vector___isub__(self, *args)


    def Subtracted(self, *args):
        """
        Subtracted(math_Vector self, math_Vector theRight) -> math_Vector

        returns the subtraction of "theRight" from "me".
        An exception is raised if the vectors have not the same length.

        :type theRight: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.math.math_Vector

        """
        return _math.math_Vector_Subtracted(self, *args)


    def __sub__(self, *args):
        """
        __sub__(math_Vector self, math_Vector theRight) -> math_Vector

        :type theRight: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.math.math_Vector

        """
        return _math.math_Vector___sub__(self, *args)


    def Multiply(self, *args):
        """
        Multiply(math_Vector self, Standard_Real const theRight)
        Multiply(math_Vector self, math_Vector theLeft, math_Matrix theRight)
        Multiply(math_Vector self, math_Matrix theLeft, math_Vector theRight)
        Multiply(math_Vector self, Standard_Real const theLeft, math_Vector theRight)

        returns the multiplication of a real by a vector.
        "me" = "theLeft" * "theRight"

        :type theLeft: float
        :type theRight: OCC.wrapper.math.math_Vector

        """
        return _math.math_Vector_Multiply(self, *args)


    def Dump(self, *args):
        """
        Dump(math_Vector self, Standard_OStream & theO)

        Prints information on the current state of the object.
        Is used to redefine the operator <<.

        :type theO: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_Vector_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_Vector
math_Vector_swigregister = _math.math_Vector_swigregister
math_Vector_swigregister(math_Vector)

class math_PSO(object):
    """
    In this class implemented variation of Particle Swarm Optimization (PSO) method.
    A. Ismael F. Vaz, L. N. Vicente 
    "A particle swarm pattern search method for bound constrained global optimization"

    Algorithm description:
    Init Section:
    At start of computation a number of "particles" are placed in the search space.
    Each particle is assigned a random velocity.

    Computational loop:
    The particles are moved in cycle, simulating some "social" behavior, so that new position of
    a particle on each step depends not only on its velocity and previous path, but also on the
    position of the best particle in the pool and best obtained position for current particle.
    The velocity of the particles is decreased on each step, so that convergence is guaranteed.

    Algorithm output:
    Best point in param space (position of the best particle) and value of objective function.

    Pros:
    One of the fastest algorithms.
    Work over functions with a lot local extremums.
    Does not require calculation of derivatives of the functional.

    Cons:
    Convergence to global minimum not proved, which is a typical drawback for all stochastic algorithms.
    The result depends on random number generator.

    Warning: PSO is effective to walk into optimum surrounding, not to get strict optimum.
    Run local optimization from pso output point.
    Warning: In PSO used fixed seed in RNG, so results are reproducible.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_PSO self, math_MultipleVarFunction theFunc, math_Vector theLowBorder, math_Vector theUppBorder, math_Vector theSteps, Standard_Integer const theNbParticles=32, Standard_Integer const theNbIter=100) -> math_PSO

        :type theFunc: OCC.wrapper.math.math_MultipleVarFunction
        :type theLowBorder: OCC.wrapper.math.math_Vector
        :type theUppBorder: OCC.wrapper.math.math_Vector
        :type theSteps: OCC.wrapper.math.math_Vector
        :type theNbParticles: int
        :type theNbIter: int

        """
        this = _math.new_math_PSO(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(math_PSO self, math_Vector theSteps, math_Vector theOutPnt, Standard_Integer const theNbIter=100)
        Perform(math_PSO self, math_PSOParticlesPool theParticles, Standard_Integer theNbParticles, math_Vector theOutPnt, Standard_Integer const theNbIter=100)

        Perform computations with given particles array.

        :type theParticles: OCC.wrapper.math.math_PSOParticlesPool
        :type theNbParticles: int
        :type theValue: float
        :type theOutPnt: OCC.wrapper.math.math_Vector
        :type theNbIter: int

        """
        return _math.math_PSO_Perform(self, *args)

    __swig_destroy__ = _math.delete_math_PSO
math_PSO_swigregister = _math.math_PSO_swigregister
math_PSO_swigregister(math_PSO)

class math_MultipleVarFunctionWithHessian(math_MultipleVarFunctionWithGradient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def NbVariables(self, *args):
        """
        NbVariables(math_MultipleVarFunctionWithHessian self) -> Standard_Integer

        returns the number of variables of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_MultipleVarFunctionWithHessian_NbVariables(self, *args)


    def Value(self, *args):
        """
        Value(math_MultipleVarFunctionWithHessian self, math_Vector X) -> Standard_Boolean

        computes the values of the Functions <F> for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_MultipleVarFunctionWithHessian_Value(self, *args)


    def Gradient(self, *args):
        """
        Gradient(math_MultipleVarFunctionWithHessian self, math_Vector X, math_Vector G) -> Standard_Boolean

        computes the gradient <G> of the functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_MultipleVarFunctionWithHessian_Gradient(self, *args)


    def Values(self, *args):
        """
        Values(math_MultipleVarFunctionWithHessian self, math_Vector X, math_Vector G) -> Standard_Boolean
        Values(math_MultipleVarFunctionWithHessian self, math_Vector X, math_Vector G, math_Matrix H) -> Standard_Boolean

        computes the value  <F>, the gradient <G> and  the
        hessian   <H> of  the functions  for the  variable <X>.
        Returns  True  if  the computation  was  done
        successfully, False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :type G: OCC.wrapper.math.math_Vector
        :type H: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_MultipleVarFunctionWithHessian_Values(self, *args)

    __swig_destroy__ = _math.delete_math_MultipleVarFunctionWithHessian
math_MultipleVarFunctionWithHessian_swigregister = _math.math_MultipleVarFunctionWithHessian_swigregister
math_MultipleVarFunctionWithHessian_swigregister(math_MultipleVarFunctionWithHessian)

class math_FRPR(object):
    """
    this class implements the Fletcher-Reeves-Polak_Ribiere minimization
    algorithm of a function of multiple variables.
    Knowledge of the function's gradient is required.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_FRPR self, math_MultipleVarFunctionWithGradient theFunction, Standard_Real const theTolerance, Standard_Integer const theNbIterations=200, Standard_Real const theZEPS=1.0e-12) -> math_FRPR

        Initializes the computation of the minimum of F.
        Warning: constructor does not perform computations.

        :type theFunction: OCC.wrapper.math.math_MultipleVarFunctionWithGradient
        :type theTolerance: float
        :type theNbIterations: int
        :type theZEPS: float

        """
        this = _math.new_math_FRPR(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(math_FRPR self, math_MultipleVarFunctionWithGradient theFunction, math_Vector theStartingPoint)

        The solution F = Fi is found when
        2.0 * abs(Fi - Fi-1) <= Tolerance * (abs(Fi) + abs(Fi-1) + ZEPS).

        :type theFunction: OCC.wrapper.math.math_MultipleVarFunctionWithGradient
        :type theStartingPoint: OCC.wrapper.math.math_Vector

        """
        return _math.math_FRPR_Perform(self, *args)


    def IsSolutionReached(self, *args):
        """
        IsSolutionReached(math_FRPR self, math_MultipleVarFunctionWithGradient theFunction) -> Standard_Boolean

        The solution F = Fi is found when:
        2.0 * abs(Fi - Fi-1) <= Tolerance * (abs(Fi) + abs(Fi-1)) + ZEPS.
        The maximum number of iterations allowed is given by NbIterations.

        :type theFunction: OCC.wrapper.math.math_MultipleVarFunctionWithGradient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_FRPR_IsSolutionReached(self, *args)


    def IsDone(self, *args):
        """
        IsDone(math_FRPR self) -> Standard_Boolean

        Returns true if the computations are successful, otherwise returns false.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_FRPR_IsDone(self, *args)


    def Location(self, *args):
        """
        returns the location vector of the minimum.
        Exception NotDone is raised if the minimum was not found.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _math.math_FRPR_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Minimum(self, *args):
        """
        Minimum(math_FRPR self) -> Standard_Real

        returns the value of the minimum.
        Exception NotDone is raised if the minimum was not found.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_FRPR_Minimum(self, *args)


    def Gradient(self, *args):
        """
        returns the gradient vector at the minimum.
        Exception NotDone is raised if the minimum was not found.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _math.math_FRPR_Gradient(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbIterations(self, *args):
        """
        NbIterations(math_FRPR self) -> Standard_Integer

        returns the number of iterations really done during the
        computation of the minimum.
        Exception NotDone is raised if the minimum was not found.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_FRPR_NbIterations(self, *args)


    def Dump(self, *args):
        """
        Dump(math_FRPR self, Standard_OStream & o)

        Prints on the stream o information on the current state
        of the object.
        Is used to redefine the operator <<.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_FRPR_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_FRPR
math_FRPR_swigregister = _math.math_FRPR_swigregister
math_FRPR_swigregister(math_FRPR)

class math_ComputeKronrodPointsAndWeights(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_ComputeKronrodPointsAndWeights self, Standard_Integer const Number) -> math_ComputeKronrodPointsAndWeights

        :type Number: int

        """
        this = _math.new_math_ComputeKronrodPointsAndWeights(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(math_ComputeKronrodPointsAndWeights self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_ComputeKronrodPointsAndWeights_IsDone(self, *args)


    def Points(self, *args):
        """
        Points(math_ComputeKronrodPointsAndWeights self) -> math_Vector

        :rtype: OCC.wrapper.math.math_Vector

        """
        return _math.math_ComputeKronrodPointsAndWeights_Points(self, *args)


    def Weights(self, *args):
        """
        Weights(math_ComputeKronrodPointsAndWeights self) -> math_Vector

        :rtype: OCC.wrapper.math.math_Vector

        """
        return _math.math_ComputeKronrodPointsAndWeights_Weights(self, *args)

    __swig_destroy__ = _math.delete_math_ComputeKronrodPointsAndWeights
math_ComputeKronrodPointsAndWeights_swigregister = _math.math_ComputeKronrodPointsAndWeights_swigregister
math_ComputeKronrodPointsAndWeights_swigregister(math_ComputeKronrodPointsAndWeights)

class math_GaussMultipleIntegration(object):
    """
    This class implements the integration of a function of multiple
    variables between the parameter bounds Lower[a..b] and Upper[a..b].
    Warning: Each element of Order must be inferior or equal to 61.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_GaussMultipleIntegration self, math_MultipleVarFunction F, math_Vector Lower, math_Vector Upper, math_IntegerVector Order) -> math_GaussMultipleIntegration

        The Gauss-Legendre integration with Order = points of
        integration for each unknow, is done on the function F
        between the bounds Lower and Upper.

        :type F: OCC.wrapper.math.math_MultipleVarFunction
        :type Lower: OCC.wrapper.math.math_Vector
        :type Upper: OCC.wrapper.math.math_Vector
        :type Order: OCC.wrapper.math.math_IntegerVector

        """
        this = _math.new_math_GaussMultipleIntegration(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(math_GaussMultipleIntegration self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_GaussMultipleIntegration_IsDone(self, *args)


    def Value(self, *args):
        """
        Value(math_GaussMultipleIntegration self) -> Standard_Real

        returns the value of the integral.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_GaussMultipleIntegration_Value(self, *args)


    def Dump(self, *args):
        """
        Dump(math_GaussMultipleIntegration self, Standard_OStream & o)

        Prints information on the current state of the object.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_GaussMultipleIntegration_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_GaussMultipleIntegration
math_GaussMultipleIntegration_swigregister = _math.math_GaussMultipleIntegration_swigregister
math_GaussMultipleIntegration_swigregister(math_GaussMultipleIntegration)

class math_FunctionRoot(object):
    """
    This class implements the computation of a root of a function of
    a single variable which is near an initial guess using a minimization
    algorithm.Knowledge of the derivative is required. The
    algorithm used is the same as in
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_FunctionRoot self, math_FunctionWithDerivative F, Standard_Real const Guess, Standard_Real const Tolerance, Standard_Integer const NbIterations=100) -> math_FunctionRoot
        __init__(math_FunctionRoot self, math_FunctionWithDerivative F, Standard_Real const Guess, Standard_Real const Tolerance, Standard_Real const A, Standard_Real const B, Standard_Integer const NbIterations=100) -> math_FunctionRoot

        The Newton-Raphson method is done to find the root of the function F
        from the initial guess Guess.
        The tolerance required on the root is given by Tolerance.
        Iterations are stopped if the expected solution does not stay in the
        range A..B
        The solution is found when abs(Xi - Xi-1) <= Tolerance;
        The maximum number of iterations allowed is given by NbIterations.

        :type F: OCC.wrapper.math.math_FunctionWithDerivative
        :type Guess: float
        :type Tolerance: float
        :type A: float
        :type B: float
        :type NbIterations: int

        """
        this = _math.new_math_FunctionRoot(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(math_FunctionRoot self) -> Standard_Boolean

        Returns true if the computations are successful, otherwise returns false.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_FunctionRoot_IsDone(self, *args)


    def Root(self, *args):
        """
        Root(math_FunctionRoot self) -> Standard_Real

        returns the value of the root.
        Exception NotDone is raised if the root was not found.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_FunctionRoot_Root(self, *args)


    def Derivative(self, *args):
        """
        Derivative(math_FunctionRoot self) -> Standard_Real

        returns the value of the derivative at the root.
        Exception NotDone is raised if the root was not found.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_FunctionRoot_Derivative(self, *args)


    def Value(self, *args):
        """
        Value(math_FunctionRoot self) -> Standard_Real

        returns the value of the function at the root.
        Exception NotDone is raised if the root was not found.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_FunctionRoot_Value(self, *args)


    def NbIterations(self, *args):
        """
        NbIterations(math_FunctionRoot self) -> Standard_Integer

        returns the number of iterations really done on the
        computation of the Root.
        Exception NotDone is raised if the root was not found.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_FunctionRoot_NbIterations(self, *args)


    def Dump(self, *args):
        """
        Dump(math_FunctionRoot self, Standard_OStream & o)

        Prints on the stream o information on the current state
        of the object.
        Is used to redefine the operator <<.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_FunctionRoot_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_FunctionRoot
math_FunctionRoot_swigregister = _math.math_FunctionRoot_swigregister
math_FunctionRoot_swigregister(math_FunctionRoot)

class math_EigenValuesSearcher(object):
    """
    This class finds eigen values and vectors of
    real symmetric tridiagonal matrix
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_EigenValuesSearcher self, NCollection_Array1_Standard_Real Diagonal, NCollection_Array1_Standard_Real Subdiagonal) -> math_EigenValuesSearcher

        :type Diagonal: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Subdiagonal: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        this = _math.new_math_EigenValuesSearcher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(math_EigenValuesSearcher self) -> Standard_Boolean

        Returns Standard_True if computation is performed
        successfully.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_EigenValuesSearcher_IsDone(self, *args)


    def Dimension(self, *args):
        """
        Dimension(math_EigenValuesSearcher self) -> Standard_Integer

        Returns the dimension of matrix

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_EigenValuesSearcher_Dimension(self, *args)


    def EigenValue(self, *args):
        """
        EigenValue(math_EigenValuesSearcher self, Standard_Integer const Index) -> Standard_Real

        Returns the Index_th eigen value of matrix
        Index must be in [1, Dimension()]

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_EigenValuesSearcher_EigenValue(self, *args)


    def EigenVector(self, *args):
        """
        EigenVector(math_EigenValuesSearcher self, Standard_Integer const Index) -> math_Vector

        Returns the Index_th eigen vector of matrix
        Index must be in [1, Dimension()]

        :type Index: int
        :rtype: OCC.wrapper.math.math_Vector

        """
        return _math.math_EigenValuesSearcher_EigenVector(self, *args)

    __swig_destroy__ = _math.delete_math_EigenValuesSearcher
math_EigenValuesSearcher_swigregister = _math.math_EigenValuesSearcher_swigregister
math_EigenValuesSearcher_swigregister(math_EigenValuesSearcher)

class math_GaussLeastSquare(object):
    """
    This class implements the least square solution of a set of
    n linear equations of m unknowns (n >= m) using the gauss LU
    decomposition algorithm.
    This algorithm is more likely subject to numerical instability
    than math_SVD.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_GaussLeastSquare self, math_Matrix A, Standard_Real const MinPivot=1.0e-20) -> math_GaussLeastSquare

        Given an input n X m matrix A with n >= m this constructor
        performs the LU decomposition with partial pivoting
        (interchange of rows) of the matrix AA = A.Transposed() * A;
        This LU decomposition is stored internally and may be used
        to do subsequent calculation.
        If the largest pivot found is less than MinPivot the matrix <A>
        is considered as singular.

        :type A: OCC.wrapper.math.math_Matrix
        :type MinPivot: float

        """
        this = _math.new_math_GaussLeastSquare(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(math_GaussLeastSquare self) -> Standard_Boolean

        Returns true if the computations are successful, otherwise returns false.e

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_GaussLeastSquare_IsDone(self, *args)


    def Solve(self, *args):
        """
        Solve(math_GaussLeastSquare self, math_Vector B, math_Vector X)

        Given the input Vector <B> this routine solves the set
        of linear equations A . X = B.
        Exception NotDone is raised if the decomposition of A was
        not done successfully.
        Exception DimensionError is raised if the range of B Inv is
        not equal to the rowrange of A.
        Exception DimensionError is raised if the range of X Inv is
        not equal to the colrange of A.

        :type B: OCC.wrapper.math.math_Vector
        :type X: OCC.wrapper.math.math_Vector

        """
        return _math.math_GaussLeastSquare_Solve(self, *args)


    def Dump(self, *args):
        """
        Dump(math_GaussLeastSquare self, Standard_OStream & o)

        Prints on the stream o information on the current state
        of the object.
        Is used to redefine the operator <<.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_GaussLeastSquare_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_GaussLeastSquare
math_GaussLeastSquare_swigregister = _math.math_GaussLeastSquare_swigregister
math_GaussLeastSquare_swigregister(math_GaussLeastSquare)

class math_FunctionRoots(object):
    """
    This class implements an algorithm which finds all the real roots of
    a function with derivative within a given range.
    Knowledge of the derivative is required.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(math_FunctionRoots self, math_FunctionWithDerivative F, Standard_Real const A, Standard_Real const B, Standard_Integer const NbSample, Standard_Real const EpsX=0.0, Standard_Real const EpsF=0.0, Standard_Real const EpsNull=0.0, Standard_Real const K=0.0) -> math_FunctionRoots

        Calculates all the real roots of a function F-K within the range
        A..B. whithout conditions on A and B
        A solution X is found when
        abs(Xi - Xi-1) <= Epsx and abs(F(Xi)-K) <= EpsF.
        The function is considered as null between A and B if
        abs(F-K) <= EpsNull within this range.

        :type F: OCC.wrapper.math.math_FunctionWithDerivative
        :type A: float
        :type B: float
        :type NbSample: int
        :type EpsX: float
        :type EpsF: float
        :type EpsNull: float
        :type K: float

        """
        this = _math.new_math_FunctionRoots(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(math_FunctionRoots self) -> Standard_Boolean

        Returns true if the computations are successful, otherwise returns false.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_FunctionRoots_IsDone(self, *args)


    def IsAllNull(self, *args):
        """
        IsAllNull(math_FunctionRoots self) -> Standard_Boolean

        returns true if the function is considered as null between A and B.
        Exceptions
        StdFail_NotDone if the algorithm fails (and IsDone returns false).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _math.math_FunctionRoots_IsAllNull(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(math_FunctionRoots self) -> Standard_Integer

        Returns the number of solutions found.
        Exceptions
        StdFail_NotDone if the algorithm fails (and IsDone returns false).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_FunctionRoots_NbSolutions(self, *args)


    def Value(self, *args):
        """
        Value(math_FunctionRoots self, Standard_Integer const Nieme) -> Standard_Real

        Returns the Nth value of the root of function F.
        Exceptions
        StdFail_NotDone if the algorithm fails (and IsDone returns false).

        :type Nieme: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _math.math_FunctionRoots_Value(self, *args)


    def StateNumber(self, *args):
        """
        StateNumber(math_FunctionRoots self, Standard_Integer const Nieme) -> Standard_Integer

        returns the StateNumber  of the Nieme root.
        Exception RangeError is raised if Nieme is < 1
        or Nieme > NbSolutions.

        :type Nieme: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _math.math_FunctionRoots_StateNumber(self, *args)


    def Dump(self, *args):
        """
        Dump(math_FunctionRoots self, Standard_OStream & o)

        Prints on the stream o information on the current state
        of the object.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _math.math_FunctionRoots_Dump(self, *args)

    __swig_destroy__ = _math.delete_math_FunctionRoots
math_FunctionRoots_swigregister = _math.math_FunctionRoots_swigregister
math_FunctionRoots_swigregister(math_FunctionRoots)




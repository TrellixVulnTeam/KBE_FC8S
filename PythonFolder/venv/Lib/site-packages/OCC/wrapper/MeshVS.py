# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_MeshVS')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_MeshVS')
    _MeshVS = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_MeshVS', [dirname(__file__)])
        except ImportError:
            import _MeshVS
            return _MeshVS
        try:
            _mod = imp.load_module('_MeshVS', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _MeshVS = swig_import_helper()
    del swig_import_helper
else:
    import _MeshVS
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _MeshVS.delete_SwigPyIterator

    def value(self):
        return _MeshVS.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _MeshVS.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _MeshVS.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _MeshVS.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _MeshVS.SwigPyIterator_equal(self, x)

    def copy(self):
        return _MeshVS.SwigPyIterator_copy(self)

    def next(self):
        return _MeshVS.SwigPyIterator_next(self)

    def __next__(self):
        return _MeshVS.SwigPyIterator___next__(self)

    def previous(self):
        return _MeshVS.SwigPyIterator_previous(self)

    def advance(self, n):
        return _MeshVS.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _MeshVS.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _MeshVS.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _MeshVS.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _MeshVS.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _MeshVS.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _MeshVS.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _MeshVS.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _MeshVS.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_MeshVS.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _MeshVS.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _MeshVS.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MeshVS.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _MeshVS.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _MeshVS.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _MeshVS.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _MeshVS.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_MeshVS.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _MeshVS.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _MeshVS.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MeshVS.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _MeshVS.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _MeshVS.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _MeshVS.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _MeshVS.ptr_to_number(item)
ptr_to_number = _MeshVS.ptr_to_number

def HashCode(*args):
    return _MeshVS.HashCode(*args)
HashCode = _MeshVS.HashCode

def ptr_equal(a, b):
    return _MeshVS.ptr_equal(a, b)
ptr_equal = _MeshVS.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import SelectBasics
else:
    import SelectBasics
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Select3D
else:
    import Select3D
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BVH
else:
    import BVH
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Graphic3d
else:
    import Graphic3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Image
else:
    import Image
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Aspect
else:
    import Aspect
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Font
else:
    import Font
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import SelectMgr
else:
    import SelectMgr
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PrsMgr
else:
    import PrsMgr
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import V3d
else:
    import V3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Prs3d
else:
    import Prs3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import HLRAlgo
else:
    import HLRAlgo
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AIS
else:
    import AIS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import DsgPrs
else:
    import DsgPrs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StdSelect
else:
    import StdSelect
del _swig_python_version_info
MeshVS_BP_Mesh = _MeshVS.MeshVS_BP_Mesh
MeshVS_BP_NodalColor = _MeshVS.MeshVS_BP_NodalColor
MeshVS_BP_ElemColor = _MeshVS.MeshVS_BP_ElemColor
MeshVS_BP_Text = _MeshVS.MeshVS_BP_Text
MeshVS_BP_Vector = _MeshVS.MeshVS_BP_Vector
MeshVS_BP_User = _MeshVS.MeshVS_BP_User
MeshVS_BP_Default = _MeshVS.MeshVS_BP_Default
MeshVS_ET_NONE = _MeshVS.MeshVS_ET_NONE
MeshVS_ET_Node = _MeshVS.MeshVS_ET_Node
MeshVS_ET_0D = _MeshVS.MeshVS_ET_0D
MeshVS_ET_Link = _MeshVS.MeshVS_ET_Link
MeshVS_ET_Face = _MeshVS.MeshVS_ET_Face
MeshVS_ET_Volume = _MeshVS.MeshVS_ET_Volume
MeshVS_ET_Element = _MeshVS.MeshVS_ET_Element
MeshVS_ET_All = _MeshVS.MeshVS_ET_All
MeshVS_DMF_WireFrame = _MeshVS.MeshVS_DMF_WireFrame
MeshVS_DMF_Shading = _MeshVS.MeshVS_DMF_Shading
MeshVS_DMF_Shrink = _MeshVS.MeshVS_DMF_Shrink
MeshVS_DMF_OCCMask = _MeshVS.MeshVS_DMF_OCCMask
MeshVS_DMF_VectorDataPrs = _MeshVS.MeshVS_DMF_VectorDataPrs
MeshVS_DMF_NodalColorDataPrs = _MeshVS.MeshVS_DMF_NodalColorDataPrs
MeshVS_DMF_ElementalColorDataPrs = _MeshVS.MeshVS_DMF_ElementalColorDataPrs
MeshVS_DMF_TextDataPrs = _MeshVS.MeshVS_DMF_TextDataPrs
MeshVS_DMF_EntitiesWithData = _MeshVS.MeshVS_DMF_EntitiesWithData
MeshVS_DMF_DeformedPrsWireFrame = _MeshVS.MeshVS_DMF_DeformedPrsWireFrame
MeshVS_DMF_DeformedPrsShading = _MeshVS.MeshVS_DMF_DeformedPrsShading
MeshVS_DMF_DeformedPrsShrink = _MeshVS.MeshVS_DMF_DeformedPrsShrink
MeshVS_DMF_DeformedMask = _MeshVS.MeshVS_DMF_DeformedMask
MeshVS_DMF_SelectionPrs = _MeshVS.MeshVS_DMF_SelectionPrs
MeshVS_DMF_HilightPrs = _MeshVS.MeshVS_DMF_HilightPrs
MeshVS_DMF_User = _MeshVS.MeshVS_DMF_User
MeshVS_MSM_PRECISE = _MeshVS.MeshVS_MSM_PRECISE
MeshVS_MSM_NODES = _MeshVS.MeshVS_MSM_NODES
MeshVS_MSM_BOX = _MeshVS.MeshVS_MSM_BOX
MeshVS_DA_InteriorStyle = _MeshVS.MeshVS_DA_InteriorStyle
MeshVS_DA_InteriorColor = _MeshVS.MeshVS_DA_InteriorColor
MeshVS_DA_BackInteriorColor = _MeshVS.MeshVS_DA_BackInteriorColor
MeshVS_DA_EdgeColor = _MeshVS.MeshVS_DA_EdgeColor
MeshVS_DA_EdgeType = _MeshVS.MeshVS_DA_EdgeType
MeshVS_DA_EdgeWidth = _MeshVS.MeshVS_DA_EdgeWidth
MeshVS_DA_HatchStyle = _MeshVS.MeshVS_DA_HatchStyle
MeshVS_DA_FrontMaterial = _MeshVS.MeshVS_DA_FrontMaterial
MeshVS_DA_BackMaterial = _MeshVS.MeshVS_DA_BackMaterial
MeshVS_DA_BeamType = _MeshVS.MeshVS_DA_BeamType
MeshVS_DA_BeamWidth = _MeshVS.MeshVS_DA_BeamWidth
MeshVS_DA_BeamColor = _MeshVS.MeshVS_DA_BeamColor
MeshVS_DA_MarkerType = _MeshVS.MeshVS_DA_MarkerType
MeshVS_DA_MarkerColor = _MeshVS.MeshVS_DA_MarkerColor
MeshVS_DA_MarkerScale = _MeshVS.MeshVS_DA_MarkerScale
MeshVS_DA_TextColor = _MeshVS.MeshVS_DA_TextColor
MeshVS_DA_TextHeight = _MeshVS.MeshVS_DA_TextHeight
MeshVS_DA_TextFont = _MeshVS.MeshVS_DA_TextFont
MeshVS_DA_TextExpansionFactor = _MeshVS.MeshVS_DA_TextExpansionFactor
MeshVS_DA_TextSpace = _MeshVS.MeshVS_DA_TextSpace
MeshVS_DA_TextStyle = _MeshVS.MeshVS_DA_TextStyle
MeshVS_DA_TextDisplayType = _MeshVS.MeshVS_DA_TextDisplayType
MeshVS_DA_TextTexFont = _MeshVS.MeshVS_DA_TextTexFont
MeshVS_DA_TextFontAspect = _MeshVS.MeshVS_DA_TextFontAspect
MeshVS_DA_VectorColor = _MeshVS.MeshVS_DA_VectorColor
MeshVS_DA_VectorMaxLength = _MeshVS.MeshVS_DA_VectorMaxLength
MeshVS_DA_VectorArrowPart = _MeshVS.MeshVS_DA_VectorArrowPart
MeshVS_DA_IsAllowOverlapped = _MeshVS.MeshVS_DA_IsAllowOverlapped
MeshVS_DA_Reflection = _MeshVS.MeshVS_DA_Reflection
MeshVS_DA_ColorReflection = _MeshVS.MeshVS_DA_ColorReflection
MeshVS_DA_ShrinkCoeff = _MeshVS.MeshVS_DA_ShrinkCoeff
MeshVS_DA_MaxFaceNodes = _MeshVS.MeshVS_DA_MaxFaceNodes
MeshVS_DA_ComputeTime = _MeshVS.MeshVS_DA_ComputeTime
MeshVS_DA_ComputeSelectionTime = _MeshVS.MeshVS_DA_ComputeSelectionTime
MeshVS_DA_DisplayNodes = _MeshVS.MeshVS_DA_DisplayNodes
MeshVS_DA_SelectableAuto = _MeshVS.MeshVS_DA_SelectableAuto
MeshVS_DA_ShowEdges = _MeshVS.MeshVS_DA_ShowEdges
MeshVS_DA_SmoothShading = _MeshVS.MeshVS_DA_SmoothShading
MeshVS_DA_SupressBackFaces = _MeshVS.MeshVS_DA_SupressBackFaces
MeshVS_DA_User = _MeshVS.MeshVS_DA_User
MeshVS_SMF_Mesh = _MeshVS.MeshVS_SMF_Mesh
MeshVS_SMF_Node = _MeshVS.MeshVS_SMF_Node
MeshVS_SMF_0D = _MeshVS.MeshVS_SMF_0D
MeshVS_SMF_Link = _MeshVS.MeshVS_SMF_Link
MeshVS_SMF_Face = _MeshVS.MeshVS_SMF_Face
MeshVS_SMF_Volume = _MeshVS.MeshVS_SMF_Volume
MeshVS_SMF_Element = _MeshVS.MeshVS_SMF_Element
MeshVS_SMF_All = _MeshVS.MeshVS_SMF_All
MeshVS_SMF_Group = _MeshVS.MeshVS_SMF_Group
class MeshVS_PrsBuilder(Standard.Standard_Transient):
    """
    This class is parent for all builders using in MeshVS_Mesh.
    It provides base fields and methods all buildes need.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MeshVS_PrsBuilder
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MeshVS_PrsBuilder(self) 
            return h


    def Build(self, *args):
        """
        Build(MeshVS_PrsBuilder self, Handle_Prs3d_Presentation Prs, TColStd_PackedMapOfInteger IDs, TColStd_PackedMapOfInteger IDsToExclude, Standard_Boolean const IsElement, Standard_Integer const DisplayMode)

        Builds presentation of certain type of data.
        Prs is presentation object which this method constructs.
        IDs is set of numeric identificators forming object appearance.
        IDsToExclude is set of IDs to exclude from processing. If some entity
        has been excluded, it is not processed by other builders.
        IsElement indicates, IDs is identificators of nodes or elements.
        DisplayMode is numeric constant describing display mode (see MeshVS_DisplayModeFlags.hxx)

        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type IDs: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IDsToExclude: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IsElement: bool
        :type DisplayMode: int

        """
        return _MeshVS.MeshVS_PrsBuilder_Build(self, *args)


    def CustomBuild(self, *args):
        """
        CustomBuild(MeshVS_PrsBuilder self, Handle_Prs3d_Presentation Prs, TColStd_PackedMapOfInteger IDs, TColStd_PackedMapOfInteger IDsToExclude, Standard_Integer const DisplayMode)

        This method is called to build presentation of custom elements (they have MeshVS_ET_0D type).
        IDs is set of numeric identificators of elements for custom building.
        IDsToExclude is set of IDs to exclude from processing. If some entity
        has been excluded, it is not processed by other builders.
        DisplayMode is numeric constant describing display mode (see MeshVS_DisplayModeFlags.hxx)

        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type IDs: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IDsToExclude: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type DisplayMode: int

        """
        return _MeshVS.MeshVS_PrsBuilder_CustomBuild(self, *args)


    def CustomSensitiveEntity(self, *args):
        """
        CustomSensitiveEntity(MeshVS_PrsBuilder self, Handle_SelectBasics_EntityOwner Owner, Standard_Integer const SelectMode) -> Handle_SelectBasics_SensitiveEntity

        This method is called to build sensitive of custom elements ( they have MeshVS_ET_0D type )

        :type Owner: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner
        :type SelectMode: int
        :rtype: OCC.wrapper.SelectBasics.Handle_SelectBasics_SensitiveEntity

        """
        return _MeshVS.MeshVS_PrsBuilder_CustomSensitiveEntity(self, *args)


    def GetFlags(self, *args):
        """
        GetFlags(MeshVS_PrsBuilder self) -> Standard_Integer

        Returns flags, assigned with builder during creation

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.MeshVS_PrsBuilder_GetFlags(self, *args)


    def TestFlags(self, *args):
        """
        TestFlags(MeshVS_PrsBuilder self, Standard_Integer const DisplayMode) -> Standard_Boolean

        Test whether display mode has flags assigned with this builder.
        This method has default implementation and can be redefined for advance behavior
        Returns Standard_True only if display mode is appropriate for this builder

        :type DisplayMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_PrsBuilder_TestFlags(self, *args)


    def GetId(self, *args):
        """
        GetId(MeshVS_PrsBuilder self) -> Standard_Integer

        Returns builder ID

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.MeshVS_PrsBuilder_GetId(self, *args)


    def GetPriority(self, *args):
        """
        GetPriority(MeshVS_PrsBuilder self) -> Standard_Integer

        Returns priority; as priority bigger, as soon builder will be called.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.MeshVS_PrsBuilder_GetPriority(self, *args)


    def GetDataSource(self, *args):
        """
        GetDataSource(MeshVS_PrsBuilder self) -> Handle_MeshVS_DataSource

        Returns custom data source or default ( from MeshVS_Mesh ) if custom is NULL

        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource

        """
        return _MeshVS.MeshVS_PrsBuilder_GetDataSource(self, *args)


    def SetDataSource(self, *args):
        """
        SetDataSource(MeshVS_PrsBuilder self, Handle_MeshVS_DataSource newDS)

        Change custom data source

        :type newDS: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource

        """
        return _MeshVS.MeshVS_PrsBuilder_SetDataSource(self, *args)


    def GetDrawer(self, *args):
        """
        GetDrawer(MeshVS_PrsBuilder self) -> Handle_MeshVS_Drawer

        Returns custom drawer or default ( from MeshVS_Mesh ) if custom is NULL

        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer

        """
        return _MeshVS.MeshVS_PrsBuilder_GetDrawer(self, *args)


    def SetDrawer(self, *args):
        """
        SetDrawer(MeshVS_PrsBuilder self, Handle_MeshVS_Drawer newDr)

        Change custom drawer

        :type newDr: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer

        """
        return _MeshVS.MeshVS_PrsBuilder_SetDrawer(self, *args)


    def SetExcluding(self, *args):
        """
        SetExcluding(MeshVS_PrsBuilder self, Standard_Boolean const state)

        Set excluding state. If it is Standard_True, the nodes or elements, processed by current builder
        will be noted and next builder won't process its.

        :type state: bool

        """
        return _MeshVS.MeshVS_PrsBuilder_SetExcluding(self, *args)


    def IsExcludingOn(self, *args):
        """
        IsExcludingOn(MeshVS_PrsBuilder self) -> Standard_Boolean

        Read excluding state

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_PrsBuilder_IsExcludingOn(self, *args)


    def SetPresentationManager(self, *args):
        """
        SetPresentationManager(MeshVS_PrsBuilder self, Handle_PrsMgr_PresentationManager thePrsMgr)

        Set presentation manager for builder

        :type thePrsMgr: OCC.wrapper.MeshVS.Handle_PrsMgr_PresentationManager3d

        """
        return _MeshVS.MeshVS_PrsBuilder_SetPresentationManager(self, *args)


    def GetPresentationManager(self, *args):
        """
        GetPresentationManager(MeshVS_PrsBuilder self) -> Handle_PrsMgr_PresentationManager

        Get presentation manager of builder

        :rtype: OCC.wrapper.MeshVS.Handle_PrsMgr_PresentationManager3d

        """
        return _MeshVS.MeshVS_PrsBuilder_GetPresentationManager(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MeshVS.MeshVS_PrsBuilder_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MeshVS.MeshVS_PrsBuilder_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.MeshVS_PrsBuilder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MeshVS.delete_MeshVS_PrsBuilder
MeshVS_PrsBuilder_swigregister = _MeshVS.MeshVS_PrsBuilder_swigregister
MeshVS_PrsBuilder_swigregister(MeshVS_PrsBuilder)

def MeshVS_PrsBuilder_get_type_name(*args):
    """
    MeshVS_PrsBuilder_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MeshVS.MeshVS_PrsBuilder_get_type_name(*args)

def MeshVS_PrsBuilder_get_type_descriptor(*args):
    """
    MeshVS_PrsBuilder_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MeshVS.MeshVS_PrsBuilder_get_type_descriptor(*args)

class MeshVS_DataSource(Standard.Standard_Transient):
    """
    The deferred class using for the following tasks:
    1) Receiving geometry data about single element of node by its number;
    2) Receiving type of element or node by its number;
    3) Receiving topological information about links between element and nodes it consist of;
    4) Receiving information about what element cover this node;
    5) Receiving information about all nodes and elements the object consist of
    6) Activation of advanced mesh selection. In the advanced mesh selection mode there is created:
    - one owner for the whole mesh and for all selection modes
    - one sensitive entity for the whole mesh and for each selection mode
    Receiving of IDs of detected entities (nodes and elements) in a viewer is achieved by
    implementation of a group of methods GetDetectedEntities.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MeshVS_DataSource
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MeshVS_DataSource(self) 
            return h


    def GetGeom(self, *args):
        """
        GetGeom(MeshVS_DataSource self, Standard_Integer const ID, Standard_Boolean const IsElement, NCollection_Array1_Standard_Real Coords) -> Standard_Boolean

        Returns geometry information about node or element
        ID is the numerical identificator of node or element
        IsElement indicates this ID describe node ( if Standard_False ) or element ( if Standard_True )
        Coords is an array of co-ordinates of node(s).
        For node it is only 3 numbers: X, Y, Z in the strict order
        For element it is 3*n numbers, where n is number of this element vertices
        The order is strict also: X1, Y1, Z1, X2,...., where Xi, Yi, Zi are co-ordinates of vertices
        NbNodes is number of nodes. It is recommended this parameter to be set to 1 for node.
        Type is type of node or element (from enumeration). It is recommended this parameter to be set to
        MeshVS_ET_Node for node.

        :type ID: int
        :type IsElement: bool
        :type Coords: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NbNodes: int
        :type Type: OCC.wrapper.MeshVS.MeshVS_EntityType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_DataSource_GetGeom(self, *args)


    def GetGeomType(self, *args):
        """
        GetGeomType(MeshVS_DataSource self, Standard_Integer const ID, Standard_Boolean const IsElement) -> Standard_Boolean

        This method is similar to GetGeom, but returns only element or node type.

        :type ID: int
        :type IsElement: bool
        :type Type: OCC.wrapper.MeshVS.MeshVS_EntityType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_DataSource_GetGeomType(self, *args)


    def Get3DGeom(self, *args):
        """
        Get3DGeom(MeshVS_DataSource self, Standard_Integer const ID, Handle_MeshVS_HArray1OfSequenceOfInteger Data) -> Standard_Boolean

        This method returns topology information about 3D-element
        Returns false if element with ID isn't 3D or because other troubles

        :type ID: int
        :type NbNodes: int
        :type Data: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_DataSource_Get3DGeom(self, *args)


    def GetAddr(self, *args):
        """
        GetAddr(MeshVS_DataSource self, Standard_Integer const ID, Standard_Boolean const IsElement) -> Standard_Address

        This method returns pointer which represents element or node data structure.
        This address will be saved in MeshVS_MeshEntityOwner, so that you can access to data structure fast
        by the method Owner(). In the redefined method you can return NULL.
        ID is the numerical identificator of node or element
        IsElement indicates this ID describe node ( if Standard_False ) or element ( if Standard_True )

        :type ID: int
        :type IsElement: bool
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _MeshVS.MeshVS_DataSource_GetAddr(self, *args)


    def GetNodesByElement(self, *args):
        """
        GetNodesByElement(MeshVS_DataSource self, Standard_Integer const ID, NCollection_Array1_Standard_Integer NodeIDs) -> Standard_Boolean

        This method returns information about nodes this element consist of.
        ID is the numerical identificator of element.
        NodeIDs is the output array of nodes IDs in correct order,
        the same as coordinates returned by GetGeom().
        NbNodes is number of nodes (number of items set in NodeIDs).
        Returns False if element does not exist

        :type ID: int
        :type NodeIDs: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type NbNodes: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_DataSource_GetNodesByElement(self, *args)


    def GetAllNodes(self, *args):
        """
        This method returns map of all nodes the object consist of.

        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        res = _MeshVS.MeshVS_DataSource_GetAllNodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetAllElements(self, *args):
        """
        This method returns map of all elements the object consist of.

        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        res = _MeshVS.MeshVS_DataSource_GetAllElements(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetNormal(self, *args):
        """
        GetNormal(MeshVS_DataSource self, Standard_Integer const Id, Standard_Integer const Max) -> Standard_Boolean

        This method calculates normal of face, which is using for correct reflection presentation.
        There is default method, for advance reflection this method can be redefined.
        Id is the numerical identificator of only element!
        Max is maximal number of nodes an element can consist of
        nx, ny, nz  are values whose represent co-ordinates of normal (will be returned)
        In the redefined method you can return normal with length more then 1, but in this case
        the appearance of element will be more bright than usual. For ordinary brightness you must return
        normal with length 1

        :type Id: int
        :type Max: int
        :type nx: float
        :type ny: float
        :type nz: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_DataSource_GetNormal(self, *args)


    def GetNodeNormal(self, *args):
        """
        GetNodeNormal(MeshVS_DataSource self, Standard_Integer const ranknode, Standard_Integer const ElementId) -> Standard_Boolean

        This method return normal of node ranknode of face Id,
        which is using for smooth shading presentation.
        Returns false if normal isn't defined.

        :type ranknode: int
        :type ElementId: int
        :type nx: float
        :type ny: float
        :type nz: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_DataSource_GetNodeNormal(self, *args)


    def GetNormalsByElement(self, *args):
        """
        GetNormalsByElement(MeshVS_DataSource self, Standard_Integer const Id, Standard_Boolean const IsNodal, Standard_Integer const MaxNodes, Handle_TColStd_HArray1OfReal Normals) -> Standard_Boolean

        This method puts components of normal vectors at each node of a mesh face (at each face of a mesh volume)
        into the output array.
        Returns false if some problem was detected during calculation of normals.
        Id is an identifier of the mesh element.
        IsNodal, when true, means that normals at mesh element nodes are needed. If nodal normals
        are not available, or IsNodal is false, or the mesh element is a volume, then the output array contents
        depend on the element type:
        face: a normal calculated by GetNormal() is duplicated for each node of the face;
        volume: normals to all faces of the volume are computed (not for each node!).
        MaxNodes is maximal number of nodes an element can consist of.
        Normals contains the result.

        :type Id: int
        :type IsNodal: bool
        :type MaxNodes: int
        :type Normals: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_DataSource_GetNormalsByElement(self, *args)


    def GetAllGroups(self, *args):
        """
        GetAllGroups(MeshVS_DataSource self, TColStd_PackedMapOfInteger Ids)

        This method returns map of all groups the object contains.

        :type Ids: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        return _MeshVS.MeshVS_DataSource_GetAllGroups(self, *args)


    def GetGroup(self, *args):
        """
        GetGroup(MeshVS_DataSource self, Standard_Integer const Id, TColStd_PackedMapOfInteger Ids) -> Standard_Boolean

        This method returns map of all group elements.

        :type Id: int
        :type Type: OCC.wrapper.MeshVS.MeshVS_EntityType
        :type Ids: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_DataSource_GetGroup(self, *args)


    def GetGroupAddr(self, *args):
        """
        GetGroupAddr(MeshVS_DataSource self, Standard_Integer const ID) -> Standard_Address

        This method returns pointer which represents group data structure.
        This address will be saved in MeshVS_MeshOwner, so that you can access to data structure fast
        by the method Owner(). In the redefined method you can return NULL.
        ID is the numerical identificator of group

        :type ID: int
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _MeshVS.MeshVS_DataSource_GetGroupAddr(self, *args)


    def IsAdvancedSelectionEnabled(self, *args):
        """
        IsAdvancedSelectionEnabled(MeshVS_DataSource self) -> Standard_Boolean

        Returns True if advanced mesh selection is enabled.
        Default implementation returns False.
        It should be redefined to return True for advanced
        mesh selection activation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_DataSource_IsAdvancedSelectionEnabled(self, *args)


    def GetBoundingBox(self, *args):
        """
        GetBoundingBox(MeshVS_DataSource self) -> Bnd_Box

        Returns the bounding box of the whole mesh.
        It is used in advanced selection mode to define roughly
        the sensitive area of the mesh.
        It can be redefined to get access to a box computed in advance.

        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _MeshVS.MeshVS_DataSource_GetBoundingBox(self, *args)


    def GetDetectedEntities(self, *args):
        """
        GetDetectedEntities(MeshVS_DataSource self, Handle_MeshVS_Mesh Prs, Standard_Real const X, Standard_Real const Y, Standard_Real const aTol, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elements) -> Standard_Boolean
        GetDetectedEntities(MeshVS_DataSource self, Handle_MeshVS_Mesh Prs, Standard_Real const XMin, Standard_Real const YMin, Standard_Real const XMax, Standard_Real const YMax, Standard_Real const aTol, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elements) -> Standard_Boolean
        GetDetectedEntities(MeshVS_DataSource self, Handle_MeshVS_Mesh Prs, NCollection_Array1_gp_Pnt2d Polyline, Bnd_Box2d aBox, Standard_Real const aTol, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elements) -> Standard_Boolean
        GetDetectedEntities(MeshVS_DataSource self, Handle_MeshVS_Mesh Prs, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elements) -> Standard_Boolean

        Filter out the maps of mesh entities so as to keep
        only the entities that are allowed to be selected
        according to the current context.
        Returns True if any of the maps has been changed.
        It should be redefined if the advanced mesh selection is
        activated. Default implementation returns False.

        :type Prs: OCC.wrapper.MeshVS.Handle_MeshVS_Mesh
        :type Nodes: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger
        :type Elements: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_DataSource_GetDetectedEntities(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MeshVS.MeshVS_DataSource_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MeshVS.MeshVS_DataSource_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.MeshVS_DataSource_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MeshVS.delete_MeshVS_DataSource
MeshVS_DataSource_swigregister = _MeshVS.MeshVS_DataSource_swigregister
MeshVS_DataSource_swigregister(MeshVS_DataSource)

def MeshVS_DataSource_get_type_name(*args):
    """
    MeshVS_DataSource_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MeshVS.MeshVS_DataSource_get_type_name(*args)

def MeshVS_DataSource_get_type_descriptor(*args):
    """
    MeshVS_DataSource_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MeshVS.MeshVS_DataSource_get_type_descriptor(*args)

class MeshVS_MeshPrsBuilder(MeshVS_PrsBuilder):
    """This class provides methods to compute base mesh presentation"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MeshVS_MeshPrsBuilder
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MeshVS_MeshPrsBuilder(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MeshVS_MeshPrsBuilder self, Handle_MeshVS_Mesh Parent, MeshVS_DisplayModeFlags const & Flags=MeshVS_DMF_OCCMask, Handle_MeshVS_DataSource DS=0, Standard_Integer const Id=-1, MeshVS_BuilderPriority const & Priority=MeshVS_BP_Mesh) -> MeshVS_MeshPrsBuilder

        Creates builder with certain display mode flags, data source, ID and priority

        :type Parent: OCC.wrapper.MeshVS.Handle_MeshVS_Mesh
        :type Flags: OCC.wrapper.MeshVS.MeshVS_DisplayModeFlags
        :type DS: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource
        :type Id: int
        :type Priority: OCC.wrapper.MeshVS.MeshVS_BuilderPriority

        """
        this = _MeshVS.new_MeshVS_MeshPrsBuilder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Build(self, *args):
        """
        Build(MeshVS_MeshPrsBuilder self, Handle_Prs3d_Presentation Prs, TColStd_PackedMapOfInteger IDs, TColStd_PackedMapOfInteger IDsToExclude, Standard_Boolean const IsElement, Standard_Integer const DisplayMode)

        Builds base mesh presentation by calling the methods below

        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type IDs: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IDsToExclude: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IsElement: bool
        :type DisplayMode: int

        """
        return _MeshVS.MeshVS_MeshPrsBuilder_Build(self, *args)


    def BuildNodes(self, *args):
        """
        BuildNodes(MeshVS_MeshPrsBuilder self, Handle_Prs3d_Presentation Prs, TColStd_PackedMapOfInteger IDs, TColStd_PackedMapOfInteger IDsToExclude, Standard_Integer const DisplayMode)

        Builds nodes presentation

        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type IDs: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IDsToExclude: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type DisplayMode: int

        """
        return _MeshVS.MeshVS_MeshPrsBuilder_BuildNodes(self, *args)


    def BuildElements(self, *args):
        """
        BuildElements(MeshVS_MeshPrsBuilder self, Handle_Prs3d_Presentation Prs, TColStd_PackedMapOfInteger IDs, TColStd_PackedMapOfInteger IDsToExclude, Standard_Integer const DisplayMode)

        Builds elements presentation

        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type IDs: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IDsToExclude: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type DisplayMode: int

        """
        return _MeshVS.MeshVS_MeshPrsBuilder_BuildElements(self, *args)


    def BuildHilightPrs(self, *args):
        """
        BuildHilightPrs(MeshVS_MeshPrsBuilder self, Handle_Prs3d_Presentation Prs, TColStd_PackedMapOfInteger IDs, Standard_Boolean const IsElement)

        Builds presentation of hilighted entity

        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type IDs: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IsElement: bool

        """
        return _MeshVS.MeshVS_MeshPrsBuilder_BuildHilightPrs(self, *args)


    def AddVolumePrs(*args):
        """
        AddVolumePrs(Handle_MeshVS_HArray1OfSequenceOfInteger Topo, NCollection_Array1_Standard_Real Nodes, Standard_Integer const NbNodes, Handle_Graphic3d_ArrayOfPrimitives Array, Standard_Boolean const IsReflected, Standard_Boolean const IsShrinked, Standard_Boolean const IsSelect, Standard_Real const ShrinkCoef)

        Add to array polygons or polylines representing volume

        :type Topo: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger
        :type Nodes: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NbNodes: int
        :type Array: OCC.wrapper.Graphic3d.Handle_Graphic3d_ArrayOfPrimitives
        :type IsReflected: bool
        :type IsShrinked: bool
        :type IsSelect: bool
        :type ShrinkCoef: float

        """
        return _MeshVS.MeshVS_MeshPrsBuilder_AddVolumePrs(*args)

    AddVolumePrs = staticmethod(AddVolumePrs)

    def HowManyPrimitives(*args):
        """
        HowManyPrimitives(Handle_MeshVS_HArray1OfSequenceOfInteger Topo, Standard_Boolean const AsPolygons, Standard_Boolean const IsSelect, Standard_Integer const NbNodes)

        Calculate how many polygons or polylines are necessary to draw passed topology

        :type Topo: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger
        :type AsPolygons: bool
        :type IsSelect: bool
        :type NbNodes: int
        :type Vertices: int
        :type Bounds: int

        """
        return _MeshVS.MeshVS_MeshPrsBuilder_HowManyPrimitives(*args)

    HowManyPrimitives = staticmethod(HowManyPrimitives)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MeshVS.MeshVS_MeshPrsBuilder_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MeshVS.MeshVS_MeshPrsBuilder_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.MeshVS_MeshPrsBuilder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MeshVS.delete_MeshVS_MeshPrsBuilder
MeshVS_MeshPrsBuilder_swigregister = _MeshVS.MeshVS_MeshPrsBuilder_swigregister
MeshVS_MeshPrsBuilder_swigregister(MeshVS_MeshPrsBuilder)

def MeshVS_MeshPrsBuilder_AddVolumePrs(*args):
    """
    MeshVS_MeshPrsBuilder_AddVolumePrs(Handle_MeshVS_HArray1OfSequenceOfInteger Topo, NCollection_Array1_Standard_Real Nodes, Standard_Integer const NbNodes, Handle_Graphic3d_ArrayOfPrimitives Array, Standard_Boolean const IsReflected, Standard_Boolean const IsShrinked, Standard_Boolean const IsSelect, Standard_Real const ShrinkCoef)

    Add to array polygons or polylines representing volume

    :type Topo: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger
    :type Nodes: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type NbNodes: int
    :type Array: OCC.wrapper.Graphic3d.Handle_Graphic3d_ArrayOfPrimitives
    :type IsReflected: bool
    :type IsShrinked: bool
    :type IsSelect: bool
    :type ShrinkCoef: float

    """
    return _MeshVS.MeshVS_MeshPrsBuilder_AddVolumePrs(*args)

def MeshVS_MeshPrsBuilder_HowManyPrimitives(*args):
    """
    MeshVS_MeshPrsBuilder_HowManyPrimitives(Handle_MeshVS_HArray1OfSequenceOfInteger Topo, Standard_Boolean const AsPolygons, Standard_Boolean const IsSelect, Standard_Integer const NbNodes)

    Calculate how many polygons or polylines are necessary to draw passed topology

    :type Topo: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger
    :type AsPolygons: bool
    :type IsSelect: bool
    :type NbNodes: int
    :type Vertices: int
    :type Bounds: int

    """
    return _MeshVS.MeshVS_MeshPrsBuilder_HowManyPrimitives(*args)

def MeshVS_MeshPrsBuilder_get_type_name(*args):
    """
    MeshVS_MeshPrsBuilder_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MeshVS.MeshVS_MeshPrsBuilder_get_type_name(*args)

def MeshVS_MeshPrsBuilder_get_type_descriptor(*args):
    """
    MeshVS_MeshPrsBuilder_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MeshVS.MeshVS_MeshPrsBuilder_get_type_descriptor(*args)

class MeshVS_SensitiveFace(Select3D.Select3D_SensitiveFace):
    """This class provides custom sensitive face, which will be selected if it center is in rectangle."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MeshVS_SensitiveFace
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MeshVS_SensitiveFace(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MeshVS_SensitiveFace self, Handle_SelectBasics_EntityOwner theOwner, NCollection_Array1_gp_Pnt thePoints, Select3D_TypeOfSensitivity const theSensType=Select3D_TOS_INTERIOR) -> MeshVS_SensitiveFace

        :type theOwner: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner
        :type thePoints: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type theSensType: OCC.wrapper.Select3D.Select3D_TypeOfSensitivity

        """
        this = _MeshVS.new_MeshVS_SensitiveFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MeshVS.MeshVS_SensitiveFace_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MeshVS.MeshVS_SensitiveFace_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.MeshVS_SensitiveFace_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MeshVS.delete_MeshVS_SensitiveFace
MeshVS_SensitiveFace_swigregister = _MeshVS.MeshVS_SensitiveFace_swigregister
MeshVS_SensitiveFace_swigregister(MeshVS_SensitiveFace)

def MeshVS_SensitiveFace_get_type_name(*args):
    """
    MeshVS_SensitiveFace_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MeshVS.MeshVS_SensitiveFace_get_type_name(*args)

def MeshVS_SensitiveFace_get_type_descriptor(*args):
    """
    MeshVS_SensitiveFace_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MeshVS.MeshVS_SensitiveFace_get_type_descriptor(*args)

class MeshVS_SensitivePolyhedron(Select3D.Select3D_SensitiveEntity):
    """
    This class is used to detect selection of a polyhedron. The main
    principle of detection algorithm is to search for overlap with
    each polyhedron's face separately, treating them as planar convex
    polygons.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MeshVS_SensitivePolyhedron
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MeshVS_SensitivePolyhedron(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MeshVS_SensitivePolyhedron self, Handle_SelectBasics_EntityOwner theOwner, NCollection_Array1_gp_Pnt theNodes, Handle_MeshVS_HArray1OfSequenceOfInteger theTopo) -> MeshVS_SensitivePolyhedron

        :type theOwner: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner
        :type theNodes: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type theTopo: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger

        """
        this = _MeshVS.new_MeshVS_SensitivePolyhedron(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetConnected(self, *args):
        """
        GetConnected(MeshVS_SensitivePolyhedron self) -> Handle_Select3D_SensitiveEntity

        :rtype: OCC.wrapper.Select3D.Handle_Select3D_SensitiveEntity

        """
        return _MeshVS.MeshVS_SensitivePolyhedron_GetConnected(self, *args)


    def Matches(self, *args):
        """
        Matches(MeshVS_SensitivePolyhedron self, SelectBasics_SelectingVolumeManager theMgr, SelectBasics_PickResult & thePickResult) -> Standard_Boolean

        :type theMgr: OCC.wrapper.SelectBasics.SelectBasics_SelectingVolumeManager
        :type thePickResult: OCC.wrapper.SelectBasics.SelectBasics_PickResult
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_SensitivePolyhedron_Matches(self, *args)


    def NbSubElements(self, *args):
        """
        NbSubElements(MeshVS_SensitivePolyhedron self) -> Standard_Integer

        Returns the amount of nodes of polyhedron

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.MeshVS_SensitivePolyhedron_NbSubElements(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(MeshVS_SensitivePolyhedron self) -> BVH_Box_Standard_Real_

        :rtype: OCC.wrapper.Select3D.Select3D_BndBox3d

        """
        return _MeshVS.MeshVS_SensitivePolyhedron_BoundingBox(self, *args)


    def CenterOfGeometry(self, *args):
        """
        CenterOfGeometry(MeshVS_SensitivePolyhedron self) -> gp_Pnt

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _MeshVS.MeshVS_SensitivePolyhedron_CenterOfGeometry(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MeshVS.MeshVS_SensitivePolyhedron_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MeshVS.MeshVS_SensitivePolyhedron_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.MeshVS_SensitivePolyhedron_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MeshVS.delete_MeshVS_SensitivePolyhedron
MeshVS_SensitivePolyhedron_swigregister = _MeshVS.MeshVS_SensitivePolyhedron_swigregister
MeshVS_SensitivePolyhedron_swigregister(MeshVS_SensitivePolyhedron)

def MeshVS_SensitivePolyhedron_get_type_name(*args):
    """
    MeshVS_SensitivePolyhedron_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MeshVS.MeshVS_SensitivePolyhedron_get_type_name(*args)

def MeshVS_SensitivePolyhedron_get_type_descriptor(*args):
    """
    MeshVS_SensitivePolyhedron_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MeshVS.MeshVS_SensitivePolyhedron_get_type_descriptor(*args)

class MeshVS_SensitiveSegment(Select3D.Select3D_SensitiveSegment):
    """This class provides custom sensitive face, which will be selected if it center is in rectangle."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MeshVS_SensitiveSegment
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MeshVS_SensitiveSegment(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MeshVS_SensitiveSegment self, Handle_SelectBasics_EntityOwner theOwner, gp_Pnt theFirstPnt, gp_Pnt theLastPnt) -> MeshVS_SensitiveSegment

        :type theOwner: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner
        :type theFirstPnt: OCC.wrapper.gp.gp_Pnt
        :type theLastPnt: OCC.wrapper.gp.gp_Pnt

        """
        this = _MeshVS.new_MeshVS_SensitiveSegment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MeshVS.MeshVS_SensitiveSegment_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MeshVS.MeshVS_SensitiveSegment_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.MeshVS_SensitiveSegment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MeshVS.delete_MeshVS_SensitiveSegment
MeshVS_SensitiveSegment_swigregister = _MeshVS.MeshVS_SensitiveSegment_swigregister
MeshVS_SensitiveSegment_swigregister(MeshVS_SensitiveSegment)

def MeshVS_SensitiveSegment_get_type_name(*args):
    """
    MeshVS_SensitiveSegment_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MeshVS.MeshVS_SensitiveSegment_get_type_name(*args)

def MeshVS_SensitiveSegment_get_type_descriptor(*args):
    """
    MeshVS_SensitiveSegment_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MeshVS.MeshVS_SensitiveSegment_get_type_descriptor(*args)

class MeshVS_MeshOwner(SelectMgr.SelectMgr_EntityOwner):
    """
    The custom mesh owner used for advanced mesh selection. This class provides methods to store information:
    1) IDs of hilighted mesh nodes and elements
    2) IDs of mesh nodes and elements selected on the mesh
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MeshVS_MeshOwner
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MeshVS_MeshOwner(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MeshVS_MeshOwner self, SelectMgr_SelectableObject theSelObj, Handle_MeshVS_DataSource theDS, Standard_Integer const thePriority=0) -> MeshVS_MeshOwner

        :type theSelObj: OCC.wrapper.SelectMgr.SelectMgr_SOPtr
        :type theDS: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource
        :type thePriority: int

        """
        this = _MeshVS.new_MeshVS_MeshOwner(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetDataSource(self, *args):
        """
        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource

        """
        res = _MeshVS.MeshVS_MeshOwner_GetDataSource(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetSelectedNodes(self, *args):
        """
        Returns ids of selected mesh nodes

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        res = _MeshVS.MeshVS_MeshOwner_GetSelectedNodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetSelectedElements(self, *args):
        """
        Returns ids of selected mesh elements

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        res = _MeshVS.MeshVS_MeshOwner_GetSelectedElements(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddSelectedEntities(self, *args):
        """
        AddSelectedEntities(MeshVS_MeshOwner self, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elems)

        Saves ids of selected mesh entities

        :type Nodes: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger
        :type Elems: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        return _MeshVS.MeshVS_MeshOwner_AddSelectedEntities(self, *args)


    def ClearSelectedEntities(self, *args):
        """
        ClearSelectedEntities(MeshVS_MeshOwner self)

        Clears ids of selected mesh entities


        """
        return _MeshVS.MeshVS_MeshOwner_ClearSelectedEntities(self, *args)


    def GetDetectedNodes(self, *args):
        """
        Returns ids of hilighted mesh nodes

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        res = _MeshVS.MeshVS_MeshOwner_GetDetectedNodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetDetectedElements(self, *args):
        """
        Returns ids of hilighted mesh elements

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        res = _MeshVS.MeshVS_MeshOwner_GetDetectedElements(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDetectedEntities(self, *args):
        """
        SetDetectedEntities(MeshVS_MeshOwner self, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elems)

        Saves ids of hilighted mesh entities

        :type Nodes: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger
        :type Elems: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        return _MeshVS.MeshVS_MeshOwner_SetDetectedEntities(self, *args)


    def HilightWithColor(self, *args):
        """
        HilightWithColor(MeshVS_MeshOwner self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theColor, Standard_Integer const theMode=0)

        :type thePM: OCC.wrapper.MeshVS.Handle_PrsMgr_PresentationManager3d
        :type theColor: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theMode: int

        """
        return _MeshVS.MeshVS_MeshOwner_HilightWithColor(self, *args)


    def Unhilight(self, *args):
        """
        Unhilight(MeshVS_MeshOwner self, Handle_PrsMgr_PresentationManager PM, Standard_Integer const Mode=0)

        :type PM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type Mode: int

        """
        return _MeshVS.MeshVS_MeshOwner_Unhilight(self, *args)


    def IsForcedHilight(self, *args):
        """
        IsForcedHilight(MeshVS_MeshOwner self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_MeshOwner_IsForcedHilight(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MeshVS.MeshVS_MeshOwner_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MeshVS.MeshVS_MeshOwner_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.MeshVS_MeshOwner_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MeshVS.delete_MeshVS_MeshOwner
MeshVS_MeshOwner_swigregister = _MeshVS.MeshVS_MeshOwner_swigregister
MeshVS_MeshOwner_swigregister(MeshVS_MeshOwner)

def MeshVS_MeshOwner_get_type_name(*args):
    """
    MeshVS_MeshOwner_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MeshVS.MeshVS_MeshOwner_get_type_name(*args)

def MeshVS_MeshOwner_get_type_descriptor(*args):
    """
    MeshVS_MeshOwner_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MeshVS.MeshVS_MeshOwner_get_type_descriptor(*args)

class MeshVS_DummySensitiveEntity(SelectBasics.SelectBasics_SensitiveEntity):
    """
    This class allows to create owners to all elements or nodes,
    both hidden and shown, but these owners user cannot select "by hands"
    in viewer. They means for internal application tasks, for example, receiving
    all owners, both for hidden and shown entities.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MeshVS_DummySensitiveEntity
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MeshVS_DummySensitiveEntity(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MeshVS_DummySensitiveEntity self, Handle_SelectBasics_EntityOwner theOwnerId) -> MeshVS_DummySensitiveEntity

        :type theOwnerId: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner

        """
        this = _MeshVS.new_MeshVS_DummySensitiveEntity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Matches(self, *args):
        """
        Matches(MeshVS_DummySensitiveEntity self, SelectBasics_SelectingVolumeManager theMgr, SelectBasics_PickResult & thePickResult) -> Standard_Boolean

        :type theMgr: OCC.wrapper.SelectBasics.SelectBasics_SelectingVolumeManager
        :type thePickResult: OCC.wrapper.SelectBasics.SelectBasics_PickResult
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_DummySensitiveEntity_Matches(self, *args)


    def NbSubElements(self, *args):
        """
        NbSubElements(MeshVS_DummySensitiveEntity self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.MeshVS_DummySensitiveEntity_NbSubElements(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(MeshVS_DummySensitiveEntity self) -> BVH_Box_Standard_Real_

        :rtype: OCC.wrapper.Select3D.Select3D_BndBox3d

        """
        return _MeshVS.MeshVS_DummySensitiveEntity_BoundingBox(self, *args)


    def BVH(self, *args):
        """
        BVH(MeshVS_DummySensitiveEntity self)

        Builds BVH tree for sensitive if it is needed


        """
        return _MeshVS.MeshVS_DummySensitiveEntity_BVH(self, *args)


    def Clear(self, *args):
        """
        Clear(MeshVS_DummySensitiveEntity self)

        Clears up all the resources and memory allocated


        """
        return _MeshVS.MeshVS_DummySensitiveEntity_Clear(self, *args)


    def HasInitLocation(self, *args):
        """
        HasInitLocation(MeshVS_DummySensitiveEntity self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_DummySensitiveEntity_HasInitLocation(self, *args)


    def InvInitLocation(self, *args):
        """
        InvInitLocation(MeshVS_DummySensitiveEntity self) -> gp_GTrsf

        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        return _MeshVS.MeshVS_DummySensitiveEntity_InvInitLocation(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MeshVS.MeshVS_DummySensitiveEntity_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MeshVS.MeshVS_DummySensitiveEntity_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.MeshVS_DummySensitiveEntity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MeshVS.delete_MeshVS_DummySensitiveEntity
MeshVS_DummySensitiveEntity_swigregister = _MeshVS.MeshVS_DummySensitiveEntity_swigregister
MeshVS_DummySensitiveEntity_swigregister(MeshVS_DummySensitiveEntity)

def MeshVS_DummySensitiveEntity_get_type_name(*args):
    """
    MeshVS_DummySensitiveEntity_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MeshVS.MeshVS_DummySensitiveEntity_get_type_name(*args)

def MeshVS_DummySensitiveEntity_get_type_descriptor(*args):
    """
    MeshVS_DummySensitiveEntity_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MeshVS.MeshVS_DummySensitiveEntity_get_type_descriptor(*args)

class MeshVS_DeformedDataSource(MeshVS_DataSource):
    """
    The class provides default class which helps to represent node displacements by deformed mesh
    This class has an internal handle to canonical non-deformed mesh data source and
    map of displacement vectors. The displacement can be magnified to useful size.
    All methods is implemented with calling the corresponding methods of non-deformed data source.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MeshVS_DeformedDataSource
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MeshVS_DeformedDataSource(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MeshVS_DeformedDataSource self, Handle_MeshVS_DataSource theNonDeformDS, Standard_Real const theMagnify) -> MeshVS_DeformedDataSource

        Constructor
        theNonDeformDS is canonical non-deformed data source, by which we are able to calculate
        deformed mesh geometry
        theMagnify is coefficient of displacement magnify

        :type theNonDeformDS: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource
        :type theMagnify: float

        """
        this = _MeshVS.new_MeshVS_DeformedDataSource(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetGeom(self, *args):
        """
        GetGeom(MeshVS_DeformedDataSource self, Standard_Integer const ID, Standard_Boolean const IsElement, NCollection_Array1_Standard_Real Coords) -> Standard_Boolean

        :type ID: int
        :type IsElement: bool
        :type Coords: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NbNodes: int
        :type Type: OCC.wrapper.MeshVS.MeshVS_EntityType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_DeformedDataSource_GetGeom(self, *args)


    def GetGeomType(self, *args):
        """
        GetGeomType(MeshVS_DeformedDataSource self, Standard_Integer const ID, Standard_Boolean const IsElement) -> Standard_Boolean

        :type ID: int
        :type IsElement: bool
        :type Type: OCC.wrapper.MeshVS.MeshVS_EntityType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_DeformedDataSource_GetGeomType(self, *args)


    def Get3DGeom(self, *args):
        """
        Get3DGeom(MeshVS_DeformedDataSource self, Standard_Integer const ID, Handle_MeshVS_HArray1OfSequenceOfInteger Data) -> Standard_Boolean

        :type ID: int
        :type NbNodes: int
        :type Data: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_DeformedDataSource_Get3DGeom(self, *args)


    def GetAddr(self, *args):
        """
        GetAddr(MeshVS_DeformedDataSource self, Standard_Integer const ID, Standard_Boolean const IsElement) -> Standard_Address

        :type ID: int
        :type IsElement: bool
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _MeshVS.MeshVS_DeformedDataSource_GetAddr(self, *args)


    def GetNodesByElement(self, *args):
        """
        GetNodesByElement(MeshVS_DeformedDataSource self, Standard_Integer const ID, NCollection_Array1_Standard_Integer NodeIDs) -> Standard_Boolean

        :type ID: int
        :type NodeIDs: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type NbNodes: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_DeformedDataSource_GetNodesByElement(self, *args)


    def GetAllNodes(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        res = _MeshVS.MeshVS_DeformedDataSource_GetAllNodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetAllElements(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        res = _MeshVS.MeshVS_DeformedDataSource_GetAllElements(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetVectors(self, *args):
        """
        This method returns map of nodal displacement vectors

        :rtype: OCC.wrapper.MeshVS.MeshVS_DataMapOfIntegerVector

        """
        res = _MeshVS.MeshVS_DeformedDataSource_GetVectors(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetVectors(self, *args):
        """
        SetVectors(MeshVS_DeformedDataSource self, NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher Map)

        This method sets map of nodal displacement vectors (Map).

        :type Map: OCC.wrapper.MeshVS.MeshVS_DataMapOfIntegerVector

        """
        return _MeshVS.MeshVS_DeformedDataSource_SetVectors(self, *args)


    def GetVector(self, *args):
        """
        GetVector(MeshVS_DeformedDataSource self, Standard_Integer const ID, gp_Vec Vect) -> Standard_Boolean

        This method returns vector ( Vect ) assigned to node number ID.

        :type ID: int
        :type Vect: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_DeformedDataSource_GetVector(self, *args)


    def SetVector(self, *args):
        """
        SetVector(MeshVS_DeformedDataSource self, Standard_Integer const ID, gp_Vec Vect)

        This method sets vector ( Vect ) assigned to node number ID.

        :type ID: int
        :type Vect: OCC.wrapper.gp.gp_Vec

        """
        return _MeshVS.MeshVS_DeformedDataSource_SetVector(self, *args)


    def SetNonDeformedDataSource(self, *args):
        """
        SetNonDeformedDataSource(MeshVS_DeformedDataSource self, Handle_MeshVS_DataSource theDS)

        :type theDS: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource

        """
        return _MeshVS.MeshVS_DeformedDataSource_SetNonDeformedDataSource(self, *args)


    def GetNonDeformedDataSource(self, *args):
        """
        GetNonDeformedDataSource(MeshVS_DeformedDataSource self) -> Handle_MeshVS_DataSource

        With this methods you can read and change internal canonical data source

        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource

        """
        return _MeshVS.MeshVS_DeformedDataSource_GetNonDeformedDataSource(self, *args)


    def SetMagnify(self, *args):
        """
        SetMagnify(MeshVS_DeformedDataSource self, Standard_Real const theMagnify)

        :type theMagnify: float

        """
        return _MeshVS.MeshVS_DeformedDataSource_SetMagnify(self, *args)


    def GetMagnify(self, *args):
        """
        GetMagnify(MeshVS_DeformedDataSource self) -> Standard_Real

        With this methods you can read and change magnify coefficient of nodal displacements

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MeshVS.MeshVS_DeformedDataSource_GetMagnify(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MeshVS.MeshVS_DeformedDataSource_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MeshVS.MeshVS_DeformedDataSource_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.MeshVS_DeformedDataSource_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MeshVS.delete_MeshVS_DeformedDataSource
MeshVS_DeformedDataSource_swigregister = _MeshVS.MeshVS_DeformedDataSource_swigregister
MeshVS_DeformedDataSource_swigregister(MeshVS_DeformedDataSource)

def MeshVS_DeformedDataSource_get_type_name(*args):
    """
    MeshVS_DeformedDataSource_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MeshVS.MeshVS_DeformedDataSource_get_type_name(*args)

def MeshVS_DeformedDataSource_get_type_descriptor(*args):
    """
    MeshVS_DeformedDataSource_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MeshVS.MeshVS_DeformedDataSource_get_type_descriptor(*args)

class MeshVS_HArray1OfSequenceOfInteger(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MeshVS_HArray1OfSequenceOfInteger
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MeshVS_HArray1OfSequenceOfInteger(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MeshVS_HArray1OfSequenceOfInteger self, Standard_Integer const theLower, Standard_Integer const theUpper) -> MeshVS_HArray1OfSequenceOfInteger
        __init__(MeshVS_HArray1OfSequenceOfInteger self, Standard_Integer const theLower, Standard_Integer const theUpper, NCollection_Sequence_Standard_Integer theValue) -> MeshVS_HArray1OfSequenceOfInteger
        __init__(MeshVS_HArray1OfSequenceOfInteger self, NCollection_Array1_TColStd_SequenceOfInteger theOther) -> MeshVS_HArray1OfSequenceOfInteger

        :type theOther: OCC.wrapper.MeshVS.MeshVS_Array1OfSequenceOfInteger

        """
        this = _MeshVS.new_MeshVS_HArray1OfSequenceOfInteger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.MeshVS.MeshVS_Array1OfSequenceOfInteger

        """
        res = _MeshVS.MeshVS_HArray1OfSequenceOfInteger_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(MeshVS_HArray1OfSequenceOfInteger self) -> NCollection_Array1_TColStd_SequenceOfInteger

        :rtype: OCC.wrapper.MeshVS.MeshVS_Array1OfSequenceOfInteger

        """
        return _MeshVS.MeshVS_HArray1OfSequenceOfInteger_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MeshVS.MeshVS_HArray1OfSequenceOfInteger_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MeshVS.MeshVS_HArray1OfSequenceOfInteger_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.MeshVS_HArray1OfSequenceOfInteger_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MeshVS.delete_MeshVS_HArray1OfSequenceOfInteger
MeshVS_HArray1OfSequenceOfInteger_swigregister = _MeshVS.MeshVS_HArray1OfSequenceOfInteger_swigregister
MeshVS_HArray1OfSequenceOfInteger_swigregister(MeshVS_HArray1OfSequenceOfInteger)

def MeshVS_HArray1OfSequenceOfInteger_get_type_name(*args):
    """
    MeshVS_HArray1OfSequenceOfInteger_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MeshVS.MeshVS_HArray1OfSequenceOfInteger_get_type_name(*args)

def MeshVS_HArray1OfSequenceOfInteger_get_type_descriptor(*args):
    """
    MeshVS_HArray1OfSequenceOfInteger_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MeshVS.MeshVS_HArray1OfSequenceOfInteger_get_type_descriptor(*args)

class MeshVS_TextPrsBuilder(MeshVS_PrsBuilder):
    """
    This class provides methods to create text data presentation.
    It store map of texts assigned with nodes or elements.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MeshVS_TextPrsBuilder
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MeshVS_TextPrsBuilder(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MeshVS_TextPrsBuilder self, Handle_MeshVS_Mesh Parent, Standard_Real const Height, Quantity_Color Color, MeshVS_DisplayModeFlags const & Flags=MeshVS_DMF_TextDataPrs, Handle_MeshVS_DataSource DS=0, Standard_Integer const Id=-1, MeshVS_BuilderPriority const & Priority=MeshVS_BP_Text) -> MeshVS_TextPrsBuilder

        :type Parent: OCC.wrapper.MeshVS.Handle_MeshVS_Mesh
        :type Height: float
        :type Color: OCC.wrapper.Quantity.Quantity_Color
        :type Flags: OCC.wrapper.MeshVS.MeshVS_DisplayModeFlags
        :type DS: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource
        :type Id: int
        :type Priority: OCC.wrapper.MeshVS.MeshVS_BuilderPriority

        """
        this = _MeshVS.new_MeshVS_TextPrsBuilder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Build(self, *args):
        """
        Build(MeshVS_TextPrsBuilder self, Handle_Prs3d_Presentation Prs, TColStd_PackedMapOfInteger IDs, TColStd_PackedMapOfInteger IDsToExclude, Standard_Boolean const IsElement, Standard_Integer const theDisplayMode)

        Builds presentation of text data

        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type IDs: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IDsToExclude: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IsElement: bool
        :type theDisplayMode: int

        """
        return _MeshVS.MeshVS_TextPrsBuilder_Build(self, *args)


    def GetTexts(self, *args):
        """
        Returns map of text assigned with nodes ( IsElement = False ) or elements ( IsElement = True )

        :type IsElement: bool
        :rtype: OCC.wrapper.MeshVS.MeshVS_DataMapOfIntegerAsciiString

        """
        res = _MeshVS.MeshVS_TextPrsBuilder_GetTexts(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTexts(self, *args):
        """
        SetTexts(MeshVS_TextPrsBuilder self, Standard_Boolean const IsElement, NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher Map)

        Sets map of text assigned with nodes or elements

        :type IsElement: bool
        :type Map: OCC.wrapper.MeshVS.MeshVS_DataMapOfIntegerAsciiString

        """
        return _MeshVS.MeshVS_TextPrsBuilder_SetTexts(self, *args)


    def HasTexts(self, *args):
        """
        HasTexts(MeshVS_TextPrsBuilder self, Standard_Boolean const IsElement) -> Standard_Boolean

        Returns True if map isn't empty

        :type IsElement: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_TextPrsBuilder_HasTexts(self, *args)


    def GetText(self, *args):
        """
        GetText(MeshVS_TextPrsBuilder self, Standard_Boolean const IsElement, Standard_Integer const ID, TCollection_AsciiString Text) -> Standard_Boolean

        Returns text assigned with single node or element

        :type IsElement: bool
        :type ID: int
        :type Text: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_TextPrsBuilder_GetText(self, *args)


    def SetText(self, *args):
        """
        SetText(MeshVS_TextPrsBuilder self, Standard_Boolean const IsElement, Standard_Integer const ID, TCollection_AsciiString Text)

        Sets text assigned with single node or element

        :type IsElement: bool
        :type ID: int
        :type Text: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _MeshVS.MeshVS_TextPrsBuilder_SetText(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MeshVS.MeshVS_TextPrsBuilder_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MeshVS.MeshVS_TextPrsBuilder_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.MeshVS_TextPrsBuilder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MeshVS.delete_MeshVS_TextPrsBuilder
MeshVS_TextPrsBuilder_swigregister = _MeshVS.MeshVS_TextPrsBuilder_swigregister
MeshVS_TextPrsBuilder_swigregister(MeshVS_TextPrsBuilder)

def MeshVS_TextPrsBuilder_get_type_name(*args):
    """
    MeshVS_TextPrsBuilder_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MeshVS.MeshVS_TextPrsBuilder_get_type_name(*args)

def MeshVS_TextPrsBuilder_get_type_descriptor(*args):
    """
    MeshVS_TextPrsBuilder_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MeshVS.MeshVS_TextPrsBuilder_get_type_descriptor(*args)

class MeshVS_VectorPrsBuilder(MeshVS_PrsBuilder):
    """
    This class provides methods to create vector data presentation.
    It store map of vectors assigned with nodes or elements.
    In simplified mode vectors draws with thickened ends instead of arrows
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MeshVS_VectorPrsBuilder
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MeshVS_VectorPrsBuilder(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MeshVS_VectorPrsBuilder self, Handle_MeshVS_Mesh Parent, Standard_Real const MaxLength, Quantity_Color VectorColor, MeshVS_DisplayModeFlags const & Flags=MeshVS_DMF_VectorDataPrs, Handle_MeshVS_DataSource DS=0, Standard_Integer const Id=-1, MeshVS_BuilderPriority const & Priority=MeshVS_BP_Vector, Standard_Boolean const IsSimplePrs) -> MeshVS_VectorPrsBuilder

        :type Parent: OCC.wrapper.MeshVS.Handle_MeshVS_Mesh
        :type MaxLength: float
        :type VectorColor: OCC.wrapper.Quantity.Quantity_Color
        :type Flags: OCC.wrapper.MeshVS.MeshVS_DisplayModeFlags
        :type DS: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource
        :type Id: int
        :type Priority: OCC.wrapper.MeshVS.MeshVS_BuilderPriority
        :type IsSimplePrs: bool

        """
        this = _MeshVS.new_MeshVS_VectorPrsBuilder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Build(self, *args):
        """
        Build(MeshVS_VectorPrsBuilder self, Handle_Prs3d_Presentation Prs, TColStd_PackedMapOfInteger IDs, TColStd_PackedMapOfInteger IDsToExclude, Standard_Boolean const IsElement, Standard_Integer const theDisplayMode)

        Builds vector data presentation

        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type IDs: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IDsToExclude: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IsElement: bool
        :type theDisplayMode: int

        """
        return _MeshVS.MeshVS_VectorPrsBuilder_Build(self, *args)


    def DrawVector(self, *args):
        """
        DrawVector(MeshVS_VectorPrsBuilder self, gp_Trsf theTrsf, Standard_Real const Length, Standard_Real const MaxLength, NCollection_Array1_gp_Pnt ArrowPoints, Handle_Graphic3d_ArrayOfPrimitives Lines, Handle_Graphic3d_ArrayOfPrimitives ArrowLines, Handle_Graphic3d_ArrayOfPrimitives Triangles)

        Adds to array of polygons and polylines some primitive representing single vector

        :type theTrsf: OCC.wrapper.gp.gp_Trsf
        :type Length: float
        :type MaxLength: float
        :type ArrowPoints: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Lines: OCC.wrapper.Graphic3d.Handle_Graphic3d_ArrayOfPrimitives
        :type ArrowLines: OCC.wrapper.Graphic3d.Handle_Graphic3d_ArrayOfPrimitives
        :type Triangles: OCC.wrapper.Graphic3d.Handle_Graphic3d_ArrayOfPrimitives

        """
        return _MeshVS.MeshVS_VectorPrsBuilder_DrawVector(self, *args)


    def calculateArrow(*args):
        """
        calculateArrow(NCollection_Array1_gp_Pnt Points, Standard_Real const Length, Standard_Real const ArrowPart) -> Standard_Real

        Calculates points of arrow presentation

        :type Points: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Length: float
        :type ArrowPart: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MeshVS.MeshVS_VectorPrsBuilder_calculateArrow(*args)

    calculateArrow = staticmethod(calculateArrow)

    def GetVectors(self, *args):
        """
        Returns map of vectors assigned with nodes or elements

        :type IsElement: bool
        :rtype: OCC.wrapper.MeshVS.MeshVS_DataMapOfIntegerVector

        """
        res = _MeshVS.MeshVS_VectorPrsBuilder_GetVectors(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetVectors(self, *args):
        """
        SetVectors(MeshVS_VectorPrsBuilder self, Standard_Boolean const IsElement, NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher Map)

        Sets map of vectors assigned with nodes or elements

        :type IsElement: bool
        :type Map: OCC.wrapper.MeshVS.MeshVS_DataMapOfIntegerVector

        """
        return _MeshVS.MeshVS_VectorPrsBuilder_SetVectors(self, *args)


    def HasVectors(self, *args):
        """
        HasVectors(MeshVS_VectorPrsBuilder self, Standard_Boolean const IsElement) -> Standard_Boolean

        Returns true, if map isn't empty

        :type IsElement: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_VectorPrsBuilder_HasVectors(self, *args)


    def GetVector(self, *args):
        """
        GetVector(MeshVS_VectorPrsBuilder self, Standard_Boolean const IsElement, Standard_Integer const ID, gp_Vec Vect) -> Standard_Boolean

        Returns vector assigned with certain node or element

        :type IsElement: bool
        :type ID: int
        :type Vect: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_VectorPrsBuilder_GetVector(self, *args)


    def SetVector(self, *args):
        """
        SetVector(MeshVS_VectorPrsBuilder self, Standard_Boolean const IsElement, Standard_Integer const ID, gp_Vec Vect)

        Sets vector assigned with certain node or element

        :type IsElement: bool
        :type ID: int
        :type Vect: OCC.wrapper.gp.gp_Vec

        """
        return _MeshVS.MeshVS_VectorPrsBuilder_SetVector(self, *args)


    def GetMinMaxVectorValue(self, *args):
        """
        GetMinMaxVectorValue(MeshVS_VectorPrsBuilder self, Standard_Boolean const IsElement)

        Calculates minimal and maximal length of vectors in map
        ( nodal, if IsElement = False or elemental, if IsElement = True )

        :type IsElement: bool
        :type MinValue: float
        :type MaxValue: float

        """
        return _MeshVS.MeshVS_VectorPrsBuilder_GetMinMaxVectorValue(self, *args)


    def SetSimplePrsMode(self, *args):
        """
        SetSimplePrsMode(MeshVS_VectorPrsBuilder self, Standard_Boolean const IsSimpleArrow)

        Sets flag that indicates is simple vector arrow mode uses or not
        default value is False

        :type IsSimpleArrow: bool

        """
        return _MeshVS.MeshVS_VectorPrsBuilder_SetSimplePrsMode(self, *args)


    def SetSimplePrsParams(self, *args):
        """
        SetSimplePrsParams(MeshVS_VectorPrsBuilder self, Standard_Real const theLineWidthParam, Standard_Real const theStartParam, Standard_Real const theEndParam)

        Sets parameters of simple vector arrwo presentation
        theLineWidthParam - coefficient of vector line width (to draw line instead of arrow)
        theStartParam and theEndParam parameters of start and end of thickened ends
        position of thickening calculates according to parameters and maximum vector length
        default values are:
        theLineWidthParam = 2.5
        theStartParam     = 0.85
        theEndParam       = 0.95

        :type theLineWidthParam: float
        :type theStartParam: float
        :type theEndParam: float

        """
        return _MeshVS.MeshVS_VectorPrsBuilder_SetSimplePrsParams(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MeshVS.MeshVS_VectorPrsBuilder_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MeshVS.MeshVS_VectorPrsBuilder_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.MeshVS_VectorPrsBuilder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MeshVS.delete_MeshVS_VectorPrsBuilder
MeshVS_VectorPrsBuilder_swigregister = _MeshVS.MeshVS_VectorPrsBuilder_swigregister
MeshVS_VectorPrsBuilder_swigregister(MeshVS_VectorPrsBuilder)

def MeshVS_VectorPrsBuilder_calculateArrow(*args):
    """
    MeshVS_VectorPrsBuilder_calculateArrow(NCollection_Array1_gp_Pnt Points, Standard_Real const Length, Standard_Real const ArrowPart) -> Standard_Real

    Calculates points of arrow presentation

    :type Points: OCC.wrapper.TColgp.TColgp_Array1OfPnt
    :type Length: float
    :type ArrowPart: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _MeshVS.MeshVS_VectorPrsBuilder_calculateArrow(*args)

def MeshVS_VectorPrsBuilder_get_type_name(*args):
    """
    MeshVS_VectorPrsBuilder_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MeshVS.MeshVS_VectorPrsBuilder_get_type_name(*args)

def MeshVS_VectorPrsBuilder_get_type_descriptor(*args):
    """
    MeshVS_VectorPrsBuilder_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MeshVS.MeshVS_VectorPrsBuilder_get_type_descriptor(*args)

class MeshVS_DataSource3D(MeshVS_DataSource):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MeshVS_DataSource3D
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MeshVS_DataSource3D(self) 
            return h


    def GetPrismTopology(self, *args):
        """
        GetPrismTopology(MeshVS_DataSource3D self, Standard_Integer const BasePoints) -> Handle_MeshVS_HArray1OfSequenceOfInteger

        :type BasePoints: int
        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger

        """
        return _MeshVS.MeshVS_DataSource3D_GetPrismTopology(self, *args)


    def GetPyramidTopology(self, *args):
        """
        GetPyramidTopology(MeshVS_DataSource3D self, Standard_Integer const BasePoints) -> Handle_MeshVS_HArray1OfSequenceOfInteger

        :type BasePoints: int
        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger

        """
        return _MeshVS.MeshVS_DataSource3D_GetPyramidTopology(self, *args)


    def CreatePrismTopology(*args):
        """
        CreatePrismTopology(Standard_Integer const BasePoints) -> Handle_MeshVS_HArray1OfSequenceOfInteger

        :type BasePoints: int
        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger

        """
        return _MeshVS.MeshVS_DataSource3D_CreatePrismTopology(*args)

    CreatePrismTopology = staticmethod(CreatePrismTopology)

    def CreatePyramidTopology(*args):
        """
        CreatePyramidTopology(Standard_Integer const BasePoints) -> Handle_MeshVS_HArray1OfSequenceOfInteger

        :type BasePoints: int
        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger

        """
        return _MeshVS.MeshVS_DataSource3D_CreatePyramidTopology(*args)

    CreatePyramidTopology = staticmethod(CreatePyramidTopology)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MeshVS.MeshVS_DataSource3D_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MeshVS.MeshVS_DataSource3D_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.MeshVS_DataSource3D_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MeshVS.delete_MeshVS_DataSource3D
MeshVS_DataSource3D_swigregister = _MeshVS.MeshVS_DataSource3D_swigregister
MeshVS_DataSource3D_swigregister(MeshVS_DataSource3D)

def MeshVS_DataSource3D_CreatePrismTopology(*args):
    """
    MeshVS_DataSource3D_CreatePrismTopology(Standard_Integer const BasePoints) -> Handle_MeshVS_HArray1OfSequenceOfInteger

    :type BasePoints: int
    :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger

    """
    return _MeshVS.MeshVS_DataSource3D_CreatePrismTopology(*args)

def MeshVS_DataSource3D_CreatePyramidTopology(*args):
    """
    MeshVS_DataSource3D_CreatePyramidTopology(Standard_Integer const BasePoints) -> Handle_MeshVS_HArray1OfSequenceOfInteger

    :type BasePoints: int
    :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger

    """
    return _MeshVS.MeshVS_DataSource3D_CreatePyramidTopology(*args)

def MeshVS_DataSource3D_get_type_name(*args):
    """
    MeshVS_DataSource3D_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MeshVS.MeshVS_DataSource3D_get_type_name(*args)

def MeshVS_DataSource3D_get_type_descriptor(*args):
    """
    MeshVS_DataSource3D_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MeshVS.MeshVS_DataSource3D_get_type_descriptor(*args)

class MeshVS_CommonSensitiveEntity(Select3D.Select3D_SensitiveSet):
    """Sensitive entity covering entire mesh for global selection."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MeshVS_CommonSensitiveEntity
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MeshVS_CommonSensitiveEntity(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MeshVS.MeshVS_CommonSensitiveEntity_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MeshVS.MeshVS_CommonSensitiveEntity_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.MeshVS_CommonSensitiveEntity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(MeshVS_CommonSensitiveEntity self, Handle_SelectBasics_EntityOwner theOwner, Handle_MeshVS_Mesh theParentMesh, MeshVS_MeshSelectionMethod const theSelMethod) -> MeshVS_CommonSensitiveEntity

        Default constructor.

        :type theOwner: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner
        :type theParentMesh: OCC.wrapper.MeshVS.Handle_MeshVS_Mesh
        :type theSelMethod: OCC.wrapper.MeshVS.MeshVS_MeshSelectionMethod

        """
        this = _MeshVS.new_MeshVS_CommonSensitiveEntity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NbSubElements(self, *args):
        """
        NbSubElements(MeshVS_CommonSensitiveEntity self) -> Standard_Integer

        Number of elements.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.MeshVS_CommonSensitiveEntity_NbSubElements(self, *args)


    def Size(self, *args):
        """
        Size(MeshVS_CommonSensitiveEntity self) -> Standard_Integer

        Returns the amount of sub-entities of the complex entity

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.MeshVS_CommonSensitiveEntity_Size(self, *args)


    def Box(self, *args):
        """
        Box(MeshVS_CommonSensitiveEntity self, Standard_Integer const theIdx) -> BVH_Box_Standard_Real_

        Returns bounding box of sub-entity with index theIdx in sub-entity list

        :type theIdx: int
        :rtype: OCC.wrapper.Select3D.Select3D_BndBox3d

        """
        return _MeshVS.MeshVS_CommonSensitiveEntity_Box(self, *args)


    def Center(self, *args):
        """
        Center(MeshVS_CommonSensitiveEntity self, Standard_Integer const theIdx, Standard_Integer const theAxis) -> Standard_Real

        Returns geometry center of sensitive entity index theIdx along the given axis theAxis

        :type theIdx: int
        :type theAxis: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MeshVS.MeshVS_CommonSensitiveEntity_Center(self, *args)


    def Swap(self, *args):
        """
        Swap(MeshVS_CommonSensitiveEntity self, Standard_Integer const theIdx1, Standard_Integer const theIdx2)

        Swaps items with indexes theIdx1 and theIdx2

        :type theIdx1: int
        :type theIdx2: int

        """
        return _MeshVS.MeshVS_CommonSensitiveEntity_Swap(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(MeshVS_CommonSensitiveEntity self) -> BVH_Box_Standard_Real_

        Returns bounding box of the triangulation. If location
        transformation is set, it will be applied

        :rtype: OCC.wrapper.Select3D.Select3D_BndBox3d

        """
        return _MeshVS.MeshVS_CommonSensitiveEntity_BoundingBox(self, *args)


    def CenterOfGeometry(self, *args):
        """
        CenterOfGeometry(MeshVS_CommonSensitiveEntity self) -> gp_Pnt

        Returns center of a mesh

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _MeshVS.MeshVS_CommonSensitiveEntity_CenterOfGeometry(self, *args)


    def GetConnected(self, *args):
        """
        GetConnected(MeshVS_CommonSensitiveEntity self) -> Handle_Select3D_SensitiveEntity

        Create a copy.

        :rtype: OCC.wrapper.Select3D.Handle_Select3D_SensitiveEntity

        """
        return _MeshVS.MeshVS_CommonSensitiveEntity_GetConnected(self, *args)

    __swig_destroy__ = _MeshVS.delete_MeshVS_CommonSensitiveEntity
MeshVS_CommonSensitiveEntity_swigregister = _MeshVS.MeshVS_CommonSensitiveEntity_swigregister
MeshVS_CommonSensitiveEntity_swigregister(MeshVS_CommonSensitiveEntity)

def MeshVS_CommonSensitiveEntity_get_type_name(*args):
    """
    MeshVS_CommonSensitiveEntity_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MeshVS.MeshVS_CommonSensitiveEntity_get_type_name(*args)

def MeshVS_CommonSensitiveEntity_get_type_descriptor(*args):
    """
    MeshVS_CommonSensitiveEntity_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MeshVS.MeshVS_CommonSensitiveEntity_get_type_descriptor(*args)

class NCollection_Sequence_Handle_MeshVS_PrsBuilder(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_MeshVS_PrsBuilder self) -> NCollection_Sequence< opencascade::handle< MeshVS_PrsBuilder > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_MeshVS_PrsBuilder self) -> NCollection_Sequence< opencascade::handle< MeshVS_PrsBuilder > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_MeshVS_PrsBuilder self) -> NCollection_Sequence< opencascade::handle< MeshVS_PrsBuilder > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_MeshVS_PrsBuilder self) -> NCollection_Sequence< opencascade::handle< MeshVS_PrsBuilder > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _MeshVS.new_NCollection_Sequence_Handle_MeshVS_PrsBuilder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_MeshVS_PrsBuilder self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_MeshVS_PrsBuilder self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_MeshVS_PrsBuilder self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_MeshVS_PrsBuilder self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_MeshVS_PrsBuilder self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_MeshVS_PrsBuilder self)

        Reverse sequence


        """
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_MeshVS_PrsBuilder self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_MeshVS_PrsBuilder self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_MeshVS_PrsBuilder self, NCollection_Sequence_Handle_MeshVS_PrsBuilder theOther) -> NCollection_Sequence_Handle_MeshVS_PrsBuilder

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_MeshVS_PrsBuilder self, NCollection_Sequence_Handle_MeshVS_PrsBuilder theOther) -> NCollection_Sequence_Handle_MeshVS_PrsBuilder

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_MeshVS_PrsBuilder self, NCollection_Sequence< opencascade::handle< MeshVS_PrsBuilder > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_MeshVS_PrsBuilder self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_MeshVS_PrsBuilder self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_MeshVS_PrsBuilder self, Handle_MeshVS_PrsBuilder theItem)
        Append(NCollection_Sequence_Handle_MeshVS_PrsBuilder self, NCollection_Sequence_Handle_MeshVS_PrsBuilder theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_MeshVS_PrsBuilder self, Handle_MeshVS_PrsBuilder theItem)
        Prepend(NCollection_Sequence_Handle_MeshVS_PrsBuilder self, NCollection_Sequence_Handle_MeshVS_PrsBuilder theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_MeshVS_PrsBuilder self, Standard_Integer const theIndex, Handle_MeshVS_PrsBuilder theItem)
        InsertBefore(NCollection_Sequence_Handle_MeshVS_PrsBuilder self, Standard_Integer const theIndex, NCollection_Sequence_Handle_MeshVS_PrsBuilder theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_MeshVS_PrsBuilder self, NCollection_Sequence< opencascade::handle< MeshVS_PrsBuilder > >::Iterator & thePosition, Handle_MeshVS_PrsBuilder theItem)
        InsertAfter(NCollection_Sequence_Handle_MeshVS_PrsBuilder self, Standard_Integer const theIndex, NCollection_Sequence_Handle_MeshVS_PrsBuilder theSeq)
        InsertAfter(NCollection_Sequence_Handle_MeshVS_PrsBuilder self, Standard_Integer const theIndex, Handle_MeshVS_PrsBuilder theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_MeshVS_PrsBuilder self, Standard_Integer const theIndex, NCollection_Sequence_Handle_MeshVS_PrsBuilder theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_MeshVS_PrsBuilder self) -> Handle_MeshVS_PrsBuilder

        First item access

        :rtype: TheItemType &

        """
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_MeshVS_PrsBuilder self) -> Handle_MeshVS_PrsBuilder

        Last item access

        :rtype: TheItemType &

        """
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_MeshVS_PrsBuilder self, Standard_Integer const theIndex) -> Handle_MeshVS_PrsBuilder

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_MeshVS_PrsBuilder self, Standard_Integer const theIndex, Handle_MeshVS_PrsBuilder theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_SetValue(self, *args)


    def __iter__(self):
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder___iter__(self)
    __swig_destroy__ = _MeshVS.delete_NCollection_Sequence_Handle_MeshVS_PrsBuilder
NCollection_Sequence_Handle_MeshVS_PrsBuilder_swigregister = _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_swigregister
NCollection_Sequence_Handle_MeshVS_PrsBuilder_swigregister(NCollection_Sequence_Handle_MeshVS_PrsBuilder)

def NCollection_Sequence_Handle_MeshVS_PrsBuilder_delNode(*args):
    """
    NCollection_Sequence_Handle_MeshVS_PrsBuilder_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_delNode(*args)

class NCollection_Sequence_Handle_MeshVS_PrsBuilder_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _MeshVS.new_NCollection_Sequence_Handle_MeshVS_PrsBuilder_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MeshVS.delete_NCollection_Sequence_Handle_MeshVS_PrsBuilder_IteratorHelper

    def __next__(self):
        return _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_IteratorHelper___next__(self)
NCollection_Sequence_Handle_MeshVS_PrsBuilder_IteratorHelper_swigregister = _MeshVS.NCollection_Sequence_Handle_MeshVS_PrsBuilder_IteratorHelper_swigregister
NCollection_Sequence_Handle_MeshVS_PrsBuilder_IteratorHelper_swigregister(NCollection_Sequence_Handle_MeshVS_PrsBuilder_IteratorHelper)


try:
	MeshVS_SequenceOfPrsBuilder = NCollection_Sequence_Handle_MeshVS_PrsBuilder
except NameError:
	pass # does not exist, probably ignored

class Handle_MeshVS_SensitiveFace(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MeshVS_SensitiveFace self)

        Nullify the handle


        """
        return _MeshVS.Handle_MeshVS_SensitiveFace_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MeshVS_SensitiveFace self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MeshVS.Handle_MeshVS_SensitiveFace_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MeshVS_SensitiveFace self, MeshVS_SensitiveFace thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MeshVS.Handle_MeshVS_SensitiveFace_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MeshVS_SensitiveFace self, Handle_MeshVS_SensitiveFace theHandle) -> Handle_MeshVS_SensitiveFace
        assign(Handle_MeshVS_SensitiveFace self, MeshVS_SensitiveFace thePtr) -> Handle_MeshVS_SensitiveFace
        assign(Handle_MeshVS_SensitiveFace self, Handle_MeshVS_SensitiveFace theHandle) -> Handle_MeshVS_SensitiveFace

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MeshVS.Handle_MeshVS_SensitiveFace_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MeshVS_SensitiveFace self) -> MeshVS_SensitiveFace

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_SensitiveFace_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MeshVS_SensitiveFace self) -> MeshVS_SensitiveFace

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_SensitiveFace___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MeshVS_SensitiveFace self) -> MeshVS_SensitiveFace

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MeshVS.Handle_MeshVS_SensitiveFace___ref__(self, *args)


    def __hash__(self):
        return _MeshVS.Handle_MeshVS_SensitiveFace___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MeshVS.Handle_MeshVS_SensitiveFace___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MeshVS.new_Handle_MeshVS_SensitiveFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MeshVS.Handle_MeshVS_SensitiveFace_DownCast)
    __swig_destroy__ = _MeshVS.delete_Handle_MeshVS_SensitiveFace

    def get_type_name(self, *args):
        """
        get_type_name(Handle_MeshVS_SensitiveFace self) -> char const *

        :rtype: const char *

        """
        return _MeshVS.Handle_MeshVS_SensitiveFace_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_SensitiveFace_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_SensitiveFace_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetPoints(self, *args):
        """
        GetPoints(Handle_MeshVS_SensitiveFace self, Handle_TColgp_HArray1OfPnt theHArrayOfPnt)

        Initializes the given array theHArrayOfPnt by 3d
        coordinates of vertices of the face

        :type theHArrayOfPnt: OCC.wrapper.TColgp.Handle_TColgp_HArray1OfPnt

        """
        return _MeshVS.Handle_MeshVS_SensitiveFace_GetPoints(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_MeshVS_SensitiveFace self, SelectBasics_SelectingVolumeManager theMgr, SelectBasics_PickResult & thePickResult) -> Standard_Boolean

        Checks whether the face overlaps current selecting volume

        :type theMgr: OCC.wrapper.SelectBasics.SelectBasics_SelectingVolumeManager
        :type thePickResult: OCC.wrapper.SelectBasics.SelectBasics_PickResult
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_SensitiveFace_Matches(self, *args)


    def GetConnected(self, *args):
        """
        GetConnected(Handle_MeshVS_SensitiveFace self) -> Handle_Select3D_SensitiveEntity

        :rtype: OCC.wrapper.Select3D.Handle_Select3D_SensitiveEntity

        """
        return _MeshVS.Handle_MeshVS_SensitiveFace_GetConnected(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_MeshVS_SensitiveFace self) -> BVH_Box_Standard_Real_

        Returns bounding box of the face. If location transformation
        is set, it will be applied

        :rtype: OCC.wrapper.Select3D.Select3D_BndBox3d

        """
        return _MeshVS.Handle_MeshVS_SensitiveFace_BoundingBox(self, *args)


    def CenterOfGeometry(self, *args):
        """
        CenterOfGeometry(Handle_MeshVS_SensitiveFace self) -> gp_Pnt

        Returns center of the face. If location transformation
        is set, it will be applied

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _MeshVS.Handle_MeshVS_SensitiveFace_CenterOfGeometry(self, *args)


    def BVH(self, *args):
        """
        BVH(Handle_MeshVS_SensitiveFace self)

        Builds BVH tree for the face


        """
        return _MeshVS.Handle_MeshVS_SensitiveFace_BVH(self, *args)


    def NbSubElements(self, *args):
        """
        NbSubElements(Handle_MeshVS_SensitiveFace self) -> Standard_Integer

        Returns the amount of sub-entities (points or planar convex polygons)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_SensitiveFace_NbSubElements(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_MeshVS_SensitiveFace self)

        Clears up all resources and memory


        """
        return _MeshVS.Handle_MeshVS_SensitiveFace_Clear(self, *args)


    def HasInitLocation(self, *args):
        """
        HasInitLocation(Handle_MeshVS_SensitiveFace self) -> Standard_Boolean

        Returns true if the shape corresponding to the entity has init location

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_SensitiveFace_HasInitLocation(self, *args)


    def InvInitLocation(self, *args):
        """
        InvInitLocation(Handle_MeshVS_SensitiveFace self) -> gp_GTrsf

        Returns inversed location transformation matrix if the shape corresponding
        to this entity has init location set. Otherwise, returns identity matrix.

        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        return _MeshVS.Handle_MeshVS_SensitiveFace_InvInitLocation(self, *args)


    def Set(self, *args):
        """
        Set(Handle_MeshVS_SensitiveFace self, Handle_SelectBasics_EntityOwner theOwnerId)

        Sets owner of the entity

        :type theOwnerId: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner

        """
        return _MeshVS.Handle_MeshVS_SensitiveFace_Set(self, *args)


    def OwnerId(self, *args):
        """
        Returns pointer to owner of the entity

        :rtype: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner

        """
        res = _MeshVS.Handle_MeshVS_SensitiveFace_OwnerId(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SensitivityFactor(self, *args):
        """
        SensitivityFactor(Handle_MeshVS_SensitiveFace self) -> Standard_Integer

        allows a better sensitivity for
        a specific entity in selection algorithms
        useful for small sized entities.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_SensitiveFace_SensitivityFactor(self, *args)


    def SetSensitivityFactor(self, *args):
        """
        SetSensitivityFactor(Handle_MeshVS_SensitiveFace self, Standard_Integer const theNewSens)

        Allows to manage sensitivity of a particular sensitive entity

        :type theNewSens: int

        """
        return _MeshVS.Handle_MeshVS_SensitiveFace_SetSensitivityFactor(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_MeshVS_SensitiveFace self)

        Memory deallocator for transient classes


        """
        return _MeshVS.Handle_MeshVS_SensitiveFace_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MeshVS_SensitiveFace self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MeshVS_SensitiveFace self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_SensitiveFace_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MeshVS_SensitiveFace self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MeshVS_SensitiveFace self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_SensitiveFace_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MeshVS_SensitiveFace self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MeshVS.Handle_MeshVS_SensitiveFace_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MeshVS_SensitiveFace self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_SensitiveFace_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MeshVS_SensitiveFace self)

        Increments the reference counter of this object


        """
        return _MeshVS.Handle_MeshVS_SensitiveFace_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MeshVS_SensitiveFace self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_SensitiveFace_DecrementRefCounter(self, *args)

Handle_MeshVS_SensitiveFace_swigregister = _MeshVS.Handle_MeshVS_SensitiveFace_swigregister
Handle_MeshVS_SensitiveFace_swigregister(Handle_MeshVS_SensitiveFace)

def Handle_MeshVS_SensitiveFace_DownCast(thing):
    return _MeshVS.Handle_MeshVS_SensitiveFace_DownCast(thing)
Handle_MeshVS_SensitiveFace_DownCast = _MeshVS.Handle_MeshVS_SensitiveFace_DownCast

class NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     Single hashed Map. This  Map is used  to store and
    retrieve keys in linear time.

    The ::Iterator class can be  used to explore  the
    content of the map. It is not  wise to iterate and
    modify a map in parallel.

    To compute  the hashcode of  the key the  function
    ::HashCode must be defined in the global namespace

    To compare two keys the function ::IsEqual must be
    defined in the global namespace.

    The performance of  a Map is conditionned  by  its
    number of buckets that  should be kept greater  to
    the number   of keys.  This  map has  an automatic
    management of the number of buckets. It is resized
    when  the number of Keys  becomes greater than the
    number of buckets.

    If you have a fair  idea of the number of  objects
    you  can save on automatic   resizing by giving  a
    number of buckets  at creation or using the ReSize
    method. This should be  consider only for  crucial
    optimisation issues.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher self) -> NCollection_Map< MeshVS_TwoNodes,MeshVS_TwoNodesHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _MeshVS.NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher self) -> NCollection_Map< MeshVS_TwoNodes,MeshVS_TwoNodesHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _MeshVS.NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Single hashed Map. This  Map is used  to store and
        retrieve keys in linear time.

        The ::Iterator class can be  used to explore  the
        content of the map. It is not  wise to iterate and
        modify a map in parallel.

        To compute  the hashcode of  the key the  function
        ::HashCode must be defined in the global namespace

        To compare two keys the function ::IsEqual must be
        defined in the global namespace.

        The performance of  a Map is conditionned  by  its
        number of buckets that  should be kept greater  to
        the number   of keys.  This  map has  an automatic
        management of the number of buckets. It is resized
        when  the number of Keys  becomes greater than the
        number of buckets.

        If you have a fair  idea of the number of  objects
        you  can save on automatic   resizing by giving  a
        number of buckets  at creation or using the ReSize
        method. This should be  consider only for  crucial
        optimisation issues.
        """
        this = _MeshVS.new_NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher self, NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_Map

        """
        return _MeshVS.NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher self, NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher theOther) -> NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _MeshVS.NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher self, NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher theOther) -> NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher

        Assign operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _MeshVS.NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _MeshVS.NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher self, MeshVS_TwoNodes const & K) -> Standard_Boolean

        Add

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_Add(self, *args)


    def Added(self, *args):
        """
        Added: add a new key if not yet in the map, and return 
        reference to either newly added or previously existing object

        :type K: const TheKeyType &
        :rtype: const TheKeyType &

        """
        res = _MeshVS.NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_Added(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Remove(self, *args):
        """
        Remove(NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher self, MeshVS_TwoNodes const & K) -> Standard_Boolean

        Remove

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_Remove(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _MeshVS.NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_Size(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher self, NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher theOther) -> Standard_Boolean

        @return true if two maps contains exactly the same keys

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_IsEqual(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher self, MeshVS_TwoNodes const & K) -> Standard_Boolean
        Contains(NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher self, NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher theOther) -> Standard_Boolean

        @return true if this map contains ALL keys of another map.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_Contains(self, *args)


    def Union(self, *args):
        """
        Union(NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher self, NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher theLeft, NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher theRight)

        Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps
        The new Map contains the values that are contained either in the first map or in the second map or in both.
        All previous content of this Map is cleared.
        This map (result of the boolean operation) can also be passed as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _MeshVS.NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_Union(self, *args)


    def Unite(self, *args):
        """
        Unite(NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher self, NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher theOther) -> Standard_Boolean

        Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map.
        The result contains the values that were previously contained in this map or contained in the given (operand) map.
        This algorithm is similar to method Union().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_Unite(self, *args)


    def HasIntersection(self, *args):
        """
        HasIntersection(NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher self, NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher theMap) -> Standard_Boolean

        Returns true if this and theMap have common elements.

        :type theMap: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_HasIntersection(self, *args)


    def Intersection(self, *args):
        """
        Intersection(NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher self, NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher theLeft, NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher theRight)

        Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps.
        The new Map contains only the values that are contained in both map operands.
        All previous content of this Map is cleared.
        This same map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _MeshVS.NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_Intersection(self, *args)


    def Intersect(self, *args):
        """
        Intersect(NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher self, NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher theOther) -> Standard_Boolean

        Apply to this Map the intersection operation (aka multiplication, common, boolean AND) with another (given) Map.
        The result contains only the values that are contained in both this and the given maps.
        This algorithm is similar to method Intersection().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_Intersect(self, *args)


    def Subtraction(self, *args):
        """
        Subtraction(NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher self, NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher theLeft, NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher theRight)

        Sets this Map to be the result of subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation between two given Maps.
        The new Map contains only the values that are contained in the first map operands and not contained in the second one.
        All previous content of this Map is cleared.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _MeshVS.NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_Subtraction(self, *args)


    def Subtract(self, *args):
        """
        Subtract(NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher self, NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher theOther) -> Standard_Boolean

        Apply to this Map the subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation with another (given) Map.
        The result contains only the values that were previously contained in this map and not contained in this map.
        This algorithm is similar to method Subtract() with two operands.
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_Subtract(self, *args)


    def Difference(self, *args):
        """
        Difference(NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher self, NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher theLeft, NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher theRight)

        Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps.
        The new Map contains the values that are contained only in the first or the second operand maps but not in both.
        All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _MeshVS.NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_Difference(self, *args)


    def Differ(self, *args):
        """
        Differ(NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher self, NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher theOther) -> Standard_Boolean

        Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map.
        The result contains the values that are contained only in this or the operand map, but not in both.
        This algorithm is similar to method Difference().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_Differ(self, *args)


    def __iter__(self):
        return _MeshVS.NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher___iter__(self)
    __swig_destroy__ = _MeshVS.delete_NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher
NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_swigregister = _MeshVS.NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_swigregister
NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_swigregister(NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher)

class NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _MeshVS.new_NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MeshVS.delete_NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_IteratorHelper

    def __next__(self):
        return _MeshVS.NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_IteratorHelper___next__(self)
NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_IteratorHelper_swigregister = _MeshVS.NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_IteratorHelper_swigregister
NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_IteratorHelper_swigregister(NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher_IteratorHelper)


try:
	MeshVS_MapOfTwoNodes = NCollection_Map_MeshVS_TwoNodes_MeshVS_TwoNodesHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_MeshVS_HArray1OfSequenceOfInteger(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MeshVS_HArray1OfSequenceOfInteger self)

        Nullify the handle


        """
        return _MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MeshVS_HArray1OfSequenceOfInteger self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MeshVS_HArray1OfSequenceOfInteger self, MeshVS_HArray1OfSequenceOfInteger thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MeshVS_HArray1OfSequenceOfInteger self, Handle_MeshVS_HArray1OfSequenceOfInteger theHandle) -> Handle_MeshVS_HArray1OfSequenceOfInteger
        assign(Handle_MeshVS_HArray1OfSequenceOfInteger self, MeshVS_HArray1OfSequenceOfInteger thePtr) -> Handle_MeshVS_HArray1OfSequenceOfInteger
        assign(Handle_MeshVS_HArray1OfSequenceOfInteger self, Handle_MeshVS_HArray1OfSequenceOfInteger theHandle) -> Handle_MeshVS_HArray1OfSequenceOfInteger

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MeshVS_HArray1OfSequenceOfInteger self) -> MeshVS_HArray1OfSequenceOfInteger

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MeshVS_HArray1OfSequenceOfInteger self) -> MeshVS_HArray1OfSequenceOfInteger

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MeshVS_HArray1OfSequenceOfInteger self) -> MeshVS_HArray1OfSequenceOfInteger

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger___ref__(self, *args)


    def __hash__(self):
        return _MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MeshVS.new_Handle_MeshVS_HArray1OfSequenceOfInteger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger_DownCast)
    __swig_destroy__ = _MeshVS.delete_Handle_MeshVS_HArray1OfSequenceOfInteger

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.MeshVS.MeshVS_Array1OfSequenceOfInteger

        """
        res = _MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_MeshVS_HArray1OfSequenceOfInteger self) -> NCollection_Array1_TColStd_SequenceOfInteger

        :rtype: OCC.wrapper.MeshVS.MeshVS_Array1OfSequenceOfInteger

        """
        return _MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MeshVS_HArray1OfSequenceOfInteger self) -> char const *

        :rtype: const char *

        """
        return _MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_MeshVS_HArray1OfSequenceOfInteger self)

        Memory deallocator for transient classes


        """
        return _MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MeshVS_HArray1OfSequenceOfInteger self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MeshVS_HArray1OfSequenceOfInteger self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MeshVS_HArray1OfSequenceOfInteger self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MeshVS_HArray1OfSequenceOfInteger self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MeshVS_HArray1OfSequenceOfInteger self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MeshVS_HArray1OfSequenceOfInteger self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MeshVS_HArray1OfSequenceOfInteger self)

        Increments the reference counter of this object


        """
        return _MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MeshVS_HArray1OfSequenceOfInteger self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger_DecrementRefCounter(self, *args)

Handle_MeshVS_HArray1OfSequenceOfInteger_swigregister = _MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger_swigregister
Handle_MeshVS_HArray1OfSequenceOfInteger_swigregister(Handle_MeshVS_HArray1OfSequenceOfInteger)

def Handle_MeshVS_HArray1OfSequenceOfInteger_DownCast(thing):
    return _MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger_DownCast(thing)
Handle_MeshVS_HArray1OfSequenceOfInteger_DownCast = _MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger_DownCast

class Handle_MeshVS_SensitivePolyhedron(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MeshVS_SensitivePolyhedron self)

        Nullify the handle


        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MeshVS_SensitivePolyhedron self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MeshVS_SensitivePolyhedron self, MeshVS_SensitivePolyhedron thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MeshVS_SensitivePolyhedron self, Handle_MeshVS_SensitivePolyhedron theHandle) -> Handle_MeshVS_SensitivePolyhedron
        assign(Handle_MeshVS_SensitivePolyhedron self, MeshVS_SensitivePolyhedron thePtr) -> Handle_MeshVS_SensitivePolyhedron
        assign(Handle_MeshVS_SensitivePolyhedron self, Handle_MeshVS_SensitivePolyhedron theHandle) -> Handle_MeshVS_SensitivePolyhedron

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MeshVS_SensitivePolyhedron self) -> MeshVS_SensitivePolyhedron

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MeshVS_SensitivePolyhedron self) -> MeshVS_SensitivePolyhedron

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MeshVS_SensitivePolyhedron self) -> MeshVS_SensitivePolyhedron

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron___ref__(self, *args)


    def __hash__(self):
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MeshVS.Handle_MeshVS_SensitivePolyhedron___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MeshVS.new_Handle_MeshVS_SensitivePolyhedron(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MeshVS.Handle_MeshVS_SensitivePolyhedron_DownCast)
    __swig_destroy__ = _MeshVS.delete_Handle_MeshVS_SensitivePolyhedron

    def GetConnected(self, *args):
        """
        GetConnected(Handle_MeshVS_SensitivePolyhedron self) -> Handle_Select3D_SensitiveEntity

        :rtype: OCC.wrapper.Select3D.Handle_Select3D_SensitiveEntity

        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron_GetConnected(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_MeshVS_SensitivePolyhedron self, SelectBasics_SelectingVolumeManager theMgr, SelectBasics_PickResult & thePickResult) -> Standard_Boolean

        :type theMgr: OCC.wrapper.SelectBasics.SelectBasics_SelectingVolumeManager
        :type thePickResult: OCC.wrapper.SelectBasics.SelectBasics_PickResult
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron_Matches(self, *args)


    def NbSubElements(self, *args):
        """
        NbSubElements(Handle_MeshVS_SensitivePolyhedron self) -> Standard_Integer

        Returns the amount of nodes of polyhedron

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron_NbSubElements(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_MeshVS_SensitivePolyhedron self) -> BVH_Box_Standard_Real_

        :rtype: OCC.wrapper.Select3D.Select3D_BndBox3d

        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron_BoundingBox(self, *args)


    def CenterOfGeometry(self, *args):
        """
        CenterOfGeometry(Handle_MeshVS_SensitivePolyhedron self) -> gp_Pnt

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron_CenterOfGeometry(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MeshVS_SensitivePolyhedron self) -> char const *

        :rtype: const char *

        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_SensitivePolyhedron_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_SensitivePolyhedron_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BVH(self, *args):
        """
        BVH(Handle_MeshVS_SensitivePolyhedron self)

        Builds BVH tree for a sensitive if needed


        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron_BVH(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_MeshVS_SensitivePolyhedron self)

        Clears up all resources and memory


        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron_Clear(self, *args)


    def HasInitLocation(self, *args):
        """
        HasInitLocation(Handle_MeshVS_SensitivePolyhedron self) -> Standard_Boolean

        Returns true if the shape corresponding to the entity has init location

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron_HasInitLocation(self, *args)


    def InvInitLocation(self, *args):
        """
        InvInitLocation(Handle_MeshVS_SensitivePolyhedron self) -> gp_GTrsf

        Returns inversed location transformation matrix if the shape corresponding
        to this entity has init location set. Otherwise, returns identity matrix.

        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron_InvInitLocation(self, *args)


    def Set(self, *args):
        """
        Set(Handle_MeshVS_SensitivePolyhedron self, Handle_SelectBasics_EntityOwner theOwnerId)

        Sets owner of the entity

        :type theOwnerId: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner

        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron_Set(self, *args)


    def OwnerId(self, *args):
        """
        Returns pointer to owner of the entity

        :rtype: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner

        """
        res = _MeshVS.Handle_MeshVS_SensitivePolyhedron_OwnerId(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SensitivityFactor(self, *args):
        """
        SensitivityFactor(Handle_MeshVS_SensitivePolyhedron self) -> Standard_Integer

        allows a better sensitivity for
        a specific entity in selection algorithms
        useful for small sized entities.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron_SensitivityFactor(self, *args)


    def SetSensitivityFactor(self, *args):
        """
        SetSensitivityFactor(Handle_MeshVS_SensitivePolyhedron self, Standard_Integer const theNewSens)

        Allows to manage sensitivity of a particular sensitive entity

        :type theNewSens: int

        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron_SetSensitivityFactor(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_MeshVS_SensitivePolyhedron self)

        Memory deallocator for transient classes


        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MeshVS_SensitivePolyhedron self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MeshVS_SensitivePolyhedron self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MeshVS_SensitivePolyhedron self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MeshVS_SensitivePolyhedron self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MeshVS_SensitivePolyhedron self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MeshVS_SensitivePolyhedron self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MeshVS_SensitivePolyhedron self)

        Increments the reference counter of this object


        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MeshVS_SensitivePolyhedron self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_SensitivePolyhedron_DecrementRefCounter(self, *args)

Handle_MeshVS_SensitivePolyhedron_swigregister = _MeshVS.Handle_MeshVS_SensitivePolyhedron_swigregister
Handle_MeshVS_SensitivePolyhedron_swigregister(Handle_MeshVS_SensitivePolyhedron)

def Handle_MeshVS_SensitivePolyhedron_DownCast(thing):
    return _MeshVS.Handle_MeshVS_SensitivePolyhedron_DownCast(thing)
Handle_MeshVS_SensitivePolyhedron_DownCast = _MeshVS.Handle_MeshVS_SensitivePolyhedron_DownCast

class NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Standard_Boolean,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Standard_Boolean,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Standard_Boolean,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Standard_Boolean,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _MeshVS.new_NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher self, int const & theKey, bool const & theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher self, int const & theKey, bool const & theItem) -> bool *

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher self, int const & theKey) -> bool const *

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher self, int const & theKey) -> bool *

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher self, int const & theKey) -> bool &

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _MeshVS.NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _MeshVS.delete_NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_swigregister = _MeshVS.NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _MeshVS.new_NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MeshVS.delete_NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _MeshVS.NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _MeshVS.NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher_IteratorHelper)


try:
	MeshVS_DataMapOfIntegerBoolean = NCollection_DataMap_Standard_Integer_Standard_Boolean_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_MeshVS_VectorPrsBuilder(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MeshVS_VectorPrsBuilder self)

        Nullify the handle


        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MeshVS_VectorPrsBuilder self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MeshVS_VectorPrsBuilder self, MeshVS_VectorPrsBuilder thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MeshVS_VectorPrsBuilder self, Handle_MeshVS_VectorPrsBuilder theHandle) -> Handle_MeshVS_VectorPrsBuilder
        assign(Handle_MeshVS_VectorPrsBuilder self, MeshVS_VectorPrsBuilder thePtr) -> Handle_MeshVS_VectorPrsBuilder
        assign(Handle_MeshVS_VectorPrsBuilder self, Handle_MeshVS_VectorPrsBuilder theHandle) -> Handle_MeshVS_VectorPrsBuilder

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MeshVS_VectorPrsBuilder self) -> MeshVS_VectorPrsBuilder

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MeshVS_VectorPrsBuilder self) -> MeshVS_VectorPrsBuilder

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MeshVS_VectorPrsBuilder self) -> MeshVS_VectorPrsBuilder

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder___ref__(self, *args)


    def __hash__(self):
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MeshVS.Handle_MeshVS_VectorPrsBuilder___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MeshVS.new_Handle_MeshVS_VectorPrsBuilder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MeshVS.Handle_MeshVS_VectorPrsBuilder_DownCast)
    __swig_destroy__ = _MeshVS.delete_Handle_MeshVS_VectorPrsBuilder

    def Build(self, *args):
        """
        Build(Handle_MeshVS_VectorPrsBuilder self, Handle_Prs3d_Presentation Prs, TColStd_PackedMapOfInteger IDs, TColStd_PackedMapOfInteger IDsToExclude, Standard_Boolean const IsElement, Standard_Integer const theDisplayMode)

        Builds vector data presentation

        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type IDs: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IDsToExclude: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IsElement: bool
        :type theDisplayMode: int

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_Build(self, *args)


    def DrawVector(self, *args):
        """
        DrawVector(Handle_MeshVS_VectorPrsBuilder self, gp_Trsf theTrsf, Standard_Real const Length, Standard_Real const MaxLength, NCollection_Array1_gp_Pnt ArrowPoints, Handle_Graphic3d_ArrayOfPrimitives Lines, Handle_Graphic3d_ArrayOfPrimitives ArrowLines, Handle_Graphic3d_ArrayOfPrimitives Triangles)

        Adds to array of polygons and polylines some primitive representing single vector

        :type theTrsf: OCC.wrapper.gp.gp_Trsf
        :type Length: float
        :type MaxLength: float
        :type ArrowPoints: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Lines: OCC.wrapper.Graphic3d.Handle_Graphic3d_ArrayOfPrimitives
        :type ArrowLines: OCC.wrapper.Graphic3d.Handle_Graphic3d_ArrayOfPrimitives
        :type Triangles: OCC.wrapper.Graphic3d.Handle_Graphic3d_ArrayOfPrimitives

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_DrawVector(self, *args)


    def calculateArrow(self, *args):
        """
        calculateArrow(Handle_MeshVS_VectorPrsBuilder self, NCollection_Array1_gp_Pnt Points, Standard_Real const Length, Standard_Real const ArrowPart) -> Standard_Real

        Calculates points of arrow presentation

        :type Points: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Length: float
        :type ArrowPart: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_calculateArrow(self, *args)


    def GetVectors(self, *args):
        """
        Returns map of vectors assigned with nodes or elements

        :type IsElement: bool
        :rtype: OCC.wrapper.MeshVS.MeshVS_DataMapOfIntegerVector

        """
        res = _MeshVS.Handle_MeshVS_VectorPrsBuilder_GetVectors(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetVectors(self, *args):
        """
        SetVectors(Handle_MeshVS_VectorPrsBuilder self, Standard_Boolean const IsElement, NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher Map)

        Sets map of vectors assigned with nodes or elements

        :type IsElement: bool
        :type Map: OCC.wrapper.MeshVS.MeshVS_DataMapOfIntegerVector

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_SetVectors(self, *args)


    def HasVectors(self, *args):
        """
        HasVectors(Handle_MeshVS_VectorPrsBuilder self, Standard_Boolean const IsElement) -> Standard_Boolean

        Returns true, if map isn't empty

        :type IsElement: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_HasVectors(self, *args)


    def GetVector(self, *args):
        """
        GetVector(Handle_MeshVS_VectorPrsBuilder self, Standard_Boolean const IsElement, Standard_Integer const ID, gp_Vec Vect) -> Standard_Boolean

        Returns vector assigned with certain node or element

        :type IsElement: bool
        :type ID: int
        :type Vect: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_GetVector(self, *args)


    def SetVector(self, *args):
        """
        SetVector(Handle_MeshVS_VectorPrsBuilder self, Standard_Boolean const IsElement, Standard_Integer const ID, gp_Vec Vect)

        Sets vector assigned with certain node or element

        :type IsElement: bool
        :type ID: int
        :type Vect: OCC.wrapper.gp.gp_Vec

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_SetVector(self, *args)


    def GetMinMaxVectorValue(self, *args):
        """
        GetMinMaxVectorValue(Handle_MeshVS_VectorPrsBuilder self, Standard_Boolean const IsElement)

        Calculates minimal and maximal length of vectors in map
        ( nodal, if IsElement = False or elemental, if IsElement = True )

        :type IsElement: bool
        :type MinValue: float
        :type MaxValue: float

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_GetMinMaxVectorValue(self, *args)


    def SetSimplePrsMode(self, *args):
        """
        SetSimplePrsMode(Handle_MeshVS_VectorPrsBuilder self, Standard_Boolean const IsSimpleArrow)

        Sets flag that indicates is simple vector arrow mode uses or not
        default value is False

        :type IsSimpleArrow: bool

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_SetSimplePrsMode(self, *args)


    def SetSimplePrsParams(self, *args):
        """
        SetSimplePrsParams(Handle_MeshVS_VectorPrsBuilder self, Standard_Real const theLineWidthParam, Standard_Real const theStartParam, Standard_Real const theEndParam)

        Sets parameters of simple vector arrwo presentation
        theLineWidthParam - coefficient of vector line width (to draw line instead of arrow)
        theStartParam and theEndParam parameters of start and end of thickened ends
        position of thickening calculates according to parameters and maximum vector length
        default values are:
        theLineWidthParam = 2.5
        theStartParam     = 0.85
        theEndParam       = 0.95

        :type theLineWidthParam: float
        :type theStartParam: float
        :type theEndParam: float

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_SetSimplePrsParams(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MeshVS_VectorPrsBuilder self) -> char const *

        :rtype: const char *

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_VectorPrsBuilder_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_VectorPrsBuilder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CustomBuild(self, *args):
        """
        CustomBuild(Handle_MeshVS_VectorPrsBuilder self, Handle_Prs3d_Presentation Prs, TColStd_PackedMapOfInteger IDs, TColStd_PackedMapOfInteger IDsToExclude, Standard_Integer const DisplayMode)

        This method is called to build presentation of custom elements (they have MeshVS_ET_0D type).
        IDs is set of numeric identificators of elements for custom building.
        IDsToExclude is set of IDs to exclude from processing. If some entity
        has been excluded, it is not processed by other builders.
        DisplayMode is numeric constant describing display mode (see MeshVS_DisplayModeFlags.hxx)

        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type IDs: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IDsToExclude: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type DisplayMode: int

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_CustomBuild(self, *args)


    def CustomSensitiveEntity(self, *args):
        """
        CustomSensitiveEntity(Handle_MeshVS_VectorPrsBuilder self, Handle_SelectBasics_EntityOwner Owner, Standard_Integer const SelectMode) -> Handle_SelectBasics_SensitiveEntity

        This method is called to build sensitive of custom elements ( they have MeshVS_ET_0D type )

        :type Owner: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner
        :type SelectMode: int
        :rtype: OCC.wrapper.SelectBasics.Handle_SelectBasics_SensitiveEntity

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_CustomSensitiveEntity(self, *args)


    def GetFlags(self, *args):
        """
        GetFlags(Handle_MeshVS_VectorPrsBuilder self) -> Standard_Integer

        Returns flags, assigned with builder during creation

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_GetFlags(self, *args)


    def TestFlags(self, *args):
        """
        TestFlags(Handle_MeshVS_VectorPrsBuilder self, Standard_Integer const DisplayMode) -> Standard_Boolean

        Test whether display mode has flags assigned with this builder.
        This method has default implementation and can be redefined for advance behavior
        Returns Standard_True only if display mode is appropriate for this builder

        :type DisplayMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_TestFlags(self, *args)


    def GetId(self, *args):
        """
        GetId(Handle_MeshVS_VectorPrsBuilder self) -> Standard_Integer

        Returns builder ID

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_GetId(self, *args)


    def GetPriority(self, *args):
        """
        GetPriority(Handle_MeshVS_VectorPrsBuilder self) -> Standard_Integer

        Returns priority; as priority bigger, as soon builder will be called.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_GetPriority(self, *args)


    def GetDataSource(self, *args):
        """
        GetDataSource(Handle_MeshVS_VectorPrsBuilder self) -> Handle_MeshVS_DataSource

        Returns custom data source or default ( from MeshVS_Mesh ) if custom is NULL

        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_GetDataSource(self, *args)


    def SetDataSource(self, *args):
        """
        SetDataSource(Handle_MeshVS_VectorPrsBuilder self, Handle_MeshVS_DataSource newDS)

        Change custom data source

        :type newDS: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_SetDataSource(self, *args)


    def GetDrawer(self, *args):
        """
        GetDrawer(Handle_MeshVS_VectorPrsBuilder self) -> Handle_MeshVS_Drawer

        Returns custom drawer or default ( from MeshVS_Mesh ) if custom is NULL

        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_GetDrawer(self, *args)


    def SetDrawer(self, *args):
        """
        SetDrawer(Handle_MeshVS_VectorPrsBuilder self, Handle_MeshVS_Drawer newDr)

        Change custom drawer

        :type newDr: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_SetDrawer(self, *args)


    def SetExcluding(self, *args):
        """
        SetExcluding(Handle_MeshVS_VectorPrsBuilder self, Standard_Boolean const state)

        Set excluding state. If it is Standard_True, the nodes or elements, processed by current builder
        will be noted and next builder won't process its.

        :type state: bool

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_SetExcluding(self, *args)


    def IsExcludingOn(self, *args):
        """
        IsExcludingOn(Handle_MeshVS_VectorPrsBuilder self) -> Standard_Boolean

        Read excluding state

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_IsExcludingOn(self, *args)


    def SetPresentationManager(self, *args):
        """
        SetPresentationManager(Handle_MeshVS_VectorPrsBuilder self, Handle_PrsMgr_PresentationManager thePrsMgr)

        Set presentation manager for builder

        :type thePrsMgr: OCC.wrapper.MeshVS.Handle_PrsMgr_PresentationManager3d

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_SetPresentationManager(self, *args)


    def GetPresentationManager(self, *args):
        """
        GetPresentationManager(Handle_MeshVS_VectorPrsBuilder self) -> Handle_PrsMgr_PresentationManager

        Get presentation manager of builder

        :rtype: OCC.wrapper.MeshVS.Handle_PrsMgr_PresentationManager3d

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_GetPresentationManager(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_MeshVS_VectorPrsBuilder self)

        Memory deallocator for transient classes


        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MeshVS_VectorPrsBuilder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MeshVS_VectorPrsBuilder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MeshVS_VectorPrsBuilder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MeshVS_VectorPrsBuilder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MeshVS_VectorPrsBuilder self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MeshVS_VectorPrsBuilder self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MeshVS_VectorPrsBuilder self)

        Increments the reference counter of this object


        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MeshVS_VectorPrsBuilder self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_VectorPrsBuilder_DecrementRefCounter(self, *args)

Handle_MeshVS_VectorPrsBuilder_swigregister = _MeshVS.Handle_MeshVS_VectorPrsBuilder_swigregister
Handle_MeshVS_VectorPrsBuilder_swigregister(Handle_MeshVS_VectorPrsBuilder)

def Handle_MeshVS_VectorPrsBuilder_DownCast(thing):
    return _MeshVS.Handle_MeshVS_VectorPrsBuilder_DownCast(thing)
Handle_MeshVS_VectorPrsBuilder_DownCast = _MeshVS.Handle_MeshVS_VectorPrsBuilder_DownCast

class Handle_MeshVS_DeformedDataSource(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MeshVS_DeformedDataSource self)

        Nullify the handle


        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MeshVS_DeformedDataSource self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MeshVS_DeformedDataSource self, MeshVS_DeformedDataSource thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MeshVS_DeformedDataSource self, Handle_MeshVS_DeformedDataSource theHandle) -> Handle_MeshVS_DeformedDataSource
        assign(Handle_MeshVS_DeformedDataSource self, MeshVS_DeformedDataSource thePtr) -> Handle_MeshVS_DeformedDataSource
        assign(Handle_MeshVS_DeformedDataSource self, Handle_MeshVS_DeformedDataSource theHandle) -> Handle_MeshVS_DeformedDataSource

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MeshVS_DeformedDataSource self) -> MeshVS_DeformedDataSource

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MeshVS_DeformedDataSource self) -> MeshVS_DeformedDataSource

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MeshVS_DeformedDataSource self) -> MeshVS_DeformedDataSource

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource___ref__(self, *args)


    def __hash__(self):
        return _MeshVS.Handle_MeshVS_DeformedDataSource___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MeshVS.Handle_MeshVS_DeformedDataSource___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MeshVS.new_Handle_MeshVS_DeformedDataSource(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MeshVS.Handle_MeshVS_DeformedDataSource_DownCast)
    __swig_destroy__ = _MeshVS.delete_Handle_MeshVS_DeformedDataSource

    def GetGeom(self, *args):
        """
        GetGeom(Handle_MeshVS_DeformedDataSource self, Standard_Integer const ID, Standard_Boolean const IsElement, NCollection_Array1_Standard_Real Coords) -> Standard_Boolean

        :type ID: int
        :type IsElement: bool
        :type Coords: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NbNodes: int
        :type Type: OCC.wrapper.MeshVS.MeshVS_EntityType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_GetGeom(self, *args)


    def GetGeomType(self, *args):
        """
        GetGeomType(Handle_MeshVS_DeformedDataSource self, Standard_Integer const ID, Standard_Boolean const IsElement) -> Standard_Boolean

        :type ID: int
        :type IsElement: bool
        :type Type: OCC.wrapper.MeshVS.MeshVS_EntityType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_GetGeomType(self, *args)


    def Get3DGeom(self, *args):
        """
        Get3DGeom(Handle_MeshVS_DeformedDataSource self, Standard_Integer const ID, Handle_MeshVS_HArray1OfSequenceOfInteger Data) -> Standard_Boolean

        :type ID: int
        :type NbNodes: int
        :type Data: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_Get3DGeom(self, *args)


    def GetAddr(self, *args):
        """
        GetAddr(Handle_MeshVS_DeformedDataSource self, Standard_Integer const ID, Standard_Boolean const IsElement) -> Standard_Address

        :type ID: int
        :type IsElement: bool
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_GetAddr(self, *args)


    def GetNodesByElement(self, *args):
        """
        GetNodesByElement(Handle_MeshVS_DeformedDataSource self, Standard_Integer const ID, NCollection_Array1_Standard_Integer NodeIDs) -> Standard_Boolean

        :type ID: int
        :type NodeIDs: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type NbNodes: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_GetNodesByElement(self, *args)


    def GetAllNodes(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        res = _MeshVS.Handle_MeshVS_DeformedDataSource_GetAllNodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetAllElements(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        res = _MeshVS.Handle_MeshVS_DeformedDataSource_GetAllElements(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetVectors(self, *args):
        """
        This method returns map of nodal displacement vectors

        :rtype: OCC.wrapper.MeshVS.MeshVS_DataMapOfIntegerVector

        """
        res = _MeshVS.Handle_MeshVS_DeformedDataSource_GetVectors(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetVectors(self, *args):
        """
        SetVectors(Handle_MeshVS_DeformedDataSource self, NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher Map)

        This method sets map of nodal displacement vectors (Map).

        :type Map: OCC.wrapper.MeshVS.MeshVS_DataMapOfIntegerVector

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_SetVectors(self, *args)


    def GetVector(self, *args):
        """
        GetVector(Handle_MeshVS_DeformedDataSource self, Standard_Integer const ID, gp_Vec Vect) -> Standard_Boolean

        This method returns vector ( Vect ) assigned to node number ID.

        :type ID: int
        :type Vect: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_GetVector(self, *args)


    def SetVector(self, *args):
        """
        SetVector(Handle_MeshVS_DeformedDataSource self, Standard_Integer const ID, gp_Vec Vect)

        This method sets vector ( Vect ) assigned to node number ID.

        :type ID: int
        :type Vect: OCC.wrapper.gp.gp_Vec

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_SetVector(self, *args)


    def SetNonDeformedDataSource(self, *args):
        """
        SetNonDeformedDataSource(Handle_MeshVS_DeformedDataSource self, Handle_MeshVS_DataSource theDS)

        :type theDS: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_SetNonDeformedDataSource(self, *args)


    def GetNonDeformedDataSource(self, *args):
        """
        GetNonDeformedDataSource(Handle_MeshVS_DeformedDataSource self) -> Handle_MeshVS_DataSource

        With this methods you can read and change internal canonical data source

        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_GetNonDeformedDataSource(self, *args)


    def SetMagnify(self, *args):
        """
        SetMagnify(Handle_MeshVS_DeformedDataSource self, Standard_Real const theMagnify)

        :type theMagnify: float

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_SetMagnify(self, *args)


    def GetMagnify(self, *args):
        """
        GetMagnify(Handle_MeshVS_DeformedDataSource self) -> Standard_Real

        With this methods you can read and change magnify coefficient of nodal displacements

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_GetMagnify(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MeshVS_DeformedDataSource self) -> char const *

        :rtype: const char *

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_DeformedDataSource_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_DeformedDataSource_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetNormal(self, *args):
        """
        GetNormal(Handle_MeshVS_DeformedDataSource self, Standard_Integer const Id, Standard_Integer const Max) -> Standard_Boolean

        This method calculates normal of face, which is using for correct reflection presentation.
        There is default method, for advance reflection this method can be redefined.
        Id is the numerical identificator of only element!
        Max is maximal number of nodes an element can consist of
        nx, ny, nz  are values whose represent co-ordinates of normal (will be returned)
        In the redefined method you can return normal with length more then 1, but in this case
        the appearance of element will be more bright than usual. For ordinary brightness you must return
        normal with length 1

        :type Id: int
        :type Max: int
        :type nx: float
        :type ny: float
        :type nz: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_GetNormal(self, *args)


    def GetNodeNormal(self, *args):
        """
        GetNodeNormal(Handle_MeshVS_DeformedDataSource self, Standard_Integer const ranknode, Standard_Integer const ElementId) -> Standard_Boolean

        This method return normal of node ranknode of face Id,
        which is using for smooth shading presentation.
        Returns false if normal isn't defined.

        :type ranknode: int
        :type ElementId: int
        :type nx: float
        :type ny: float
        :type nz: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_GetNodeNormal(self, *args)


    def GetNormalsByElement(self, *args):
        """
        GetNormalsByElement(Handle_MeshVS_DeformedDataSource self, Standard_Integer const Id, Standard_Boolean const IsNodal, Standard_Integer const MaxNodes, Handle_TColStd_HArray1OfReal Normals) -> Standard_Boolean

        This method puts components of normal vectors at each node of a mesh face (at each face of a mesh volume)
        into the output array.
        Returns false if some problem was detected during calculation of normals.
        Id is an identifier of the mesh element.
        IsNodal, when true, means that normals at mesh element nodes are needed. If nodal normals
        are not available, or IsNodal is false, or the mesh element is a volume, then the output array contents
        depend on the element type:
        face: a normal calculated by GetNormal() is duplicated for each node of the face;
        volume: normals to all faces of the volume are computed (not for each node!).
        MaxNodes is maximal number of nodes an element can consist of.
        Normals contains the result.

        :type Id: int
        :type IsNodal: bool
        :type MaxNodes: int
        :type Normals: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_GetNormalsByElement(self, *args)


    def GetAllGroups(self, *args):
        """
        GetAllGroups(Handle_MeshVS_DeformedDataSource self, TColStd_PackedMapOfInteger Ids)

        This method returns map of all groups the object contains.

        :type Ids: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_GetAllGroups(self, *args)


    def GetGroup(self, *args):
        """
        GetGroup(Handle_MeshVS_DeformedDataSource self, Standard_Integer const Id, TColStd_PackedMapOfInteger Ids) -> Standard_Boolean

        This method returns map of all group elements.

        :type Id: int
        :type Type: OCC.wrapper.MeshVS.MeshVS_EntityType
        :type Ids: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_GetGroup(self, *args)


    def GetGroupAddr(self, *args):
        """
        GetGroupAddr(Handle_MeshVS_DeformedDataSource self, Standard_Integer const ID) -> Standard_Address

        This method returns pointer which represents group data structure.
        This address will be saved in MeshVS_MeshOwner, so that you can access to data structure fast
        by the method Owner(). In the redefined method you can return NULL.
        ID is the numerical identificator of group

        :type ID: int
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_GetGroupAddr(self, *args)


    def IsAdvancedSelectionEnabled(self, *args):
        """
        IsAdvancedSelectionEnabled(Handle_MeshVS_DeformedDataSource self) -> Standard_Boolean

        Returns True if advanced mesh selection is enabled.
        Default implementation returns False.
        It should be redefined to return True for advanced
        mesh selection activation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_IsAdvancedSelectionEnabled(self, *args)


    def GetBoundingBox(self, *args):
        """
        GetBoundingBox(Handle_MeshVS_DeformedDataSource self) -> Bnd_Box

        Returns the bounding box of the whole mesh.
        It is used in advanced selection mode to define roughly
        the sensitive area of the mesh.
        It can be redefined to get access to a box computed in advance.

        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_GetBoundingBox(self, *args)


    def GetDetectedEntities(self, *args):
        """
        GetDetectedEntities(Handle_MeshVS_DeformedDataSource self, Handle_MeshVS_Mesh Prs, Standard_Real const X, Standard_Real const Y, Standard_Real const aTol, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elements) -> Standard_Boolean
        GetDetectedEntities(Handle_MeshVS_DeformedDataSource self, Handle_MeshVS_Mesh Prs, Standard_Real const XMin, Standard_Real const YMin, Standard_Real const XMax, Standard_Real const YMax, Standard_Real const aTol, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elements) -> Standard_Boolean
        GetDetectedEntities(Handle_MeshVS_DeformedDataSource self, Handle_MeshVS_Mesh Prs, NCollection_Array1_gp_Pnt2d Polyline, Bnd_Box2d aBox, Standard_Real const aTol, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elements) -> Standard_Boolean
        GetDetectedEntities(Handle_MeshVS_DeformedDataSource self, Handle_MeshVS_Mesh Prs, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elements) -> Standard_Boolean

        Filter out the maps of mesh entities so as to keep
        only the entities that are allowed to be selected
        according to the current context.
        Returns True if any of the maps has been changed.
        It should be redefined if the advanced mesh selection is
        activated. Default implementation returns False.

        :type Prs: OCC.wrapper.MeshVS.Handle_MeshVS_Mesh
        :type Nodes: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger
        :type Elements: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_GetDetectedEntities(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_MeshVS_DeformedDataSource self)

        Memory deallocator for transient classes


        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MeshVS_DeformedDataSource self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MeshVS_DeformedDataSource self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MeshVS_DeformedDataSource self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MeshVS_DeformedDataSource self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MeshVS_DeformedDataSource self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MeshVS_DeformedDataSource self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MeshVS_DeformedDataSource self)

        Increments the reference counter of this object


        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MeshVS_DeformedDataSource self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_DeformedDataSource_DecrementRefCounter(self, *args)

Handle_MeshVS_DeformedDataSource_swigregister = _MeshVS.Handle_MeshVS_DeformedDataSource_swigregister
Handle_MeshVS_DeformedDataSource_swigregister(Handle_MeshVS_DeformedDataSource)

def Handle_MeshVS_DeformedDataSource_DownCast(thing):
    return _MeshVS.Handle_MeshVS_DeformedDataSource_DownCast(thing)
Handle_MeshVS_DeformedDataSource_DownCast = _MeshVS.Handle_MeshVS_DeformedDataSource_DownCast


try:
	TColStd_MapOfInteger = TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher
except AttributeError:
	pass # does not exist, probably ignored

class NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher self) -> NCollection_DataMap< Quantity_Color,TColStd_MapOfInteger,Quantity_ColorHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _MeshVS.NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher self) -> NCollection_DataMap< Quantity_Color,TColStd_MapOfInteger,Quantity_ColorHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _MeshVS.NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher self) -> NCollection_DataMap< Quantity_Color,TColStd_MapOfInteger,Quantity_ColorHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _MeshVS.NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher self) -> NCollection_DataMap< Quantity_Color,TColStd_MapOfInteger,Quantity_ColorHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _MeshVS.NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _MeshVS.new_NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher self, NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher self, NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher theOther) -> NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher self, NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher theOther) -> NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _MeshVS.NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher self, Quantity_Color theKey, NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher self, Quantity_Color theKey, NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher theItem) -> NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher self, Quantity_Color theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher self, Quantity_Color theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher self, Quantity_Color theKey) -> NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher self, Quantity_Color theKey) -> NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher self, Quantity_Color theKey) -> NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _MeshVS.NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _MeshVS.NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_Size(self, *args)


    def __iter__(self):
        return _MeshVS.NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher___iter__(self)
    __swig_destroy__ = _MeshVS.delete_NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher
NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_swigregister = _MeshVS.NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_swigregister
NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_swigregister(NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher)

class NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _MeshVS.new_NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MeshVS.delete_NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_IteratorHelper

    def __next__(self):
        return _MeshVS.NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_IteratorHelper___next__(self)
NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_IteratorHelper_swigregister = _MeshVS.NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_IteratorHelper_swigregister
NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_IteratorHelper_swigregister(NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher_IteratorHelper)


try:
	MeshVS_DataMapOfColorMapOfInteger = NCollection_DataMap_Quantity_Color_TColStd_MapOfInteger_Quantity_ColorHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_MeshVS_MeshPrsBuilder(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MeshVS_MeshPrsBuilder self)

        Nullify the handle


        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MeshVS_MeshPrsBuilder self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MeshVS_MeshPrsBuilder self, MeshVS_MeshPrsBuilder thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MeshVS_MeshPrsBuilder self, Handle_MeshVS_MeshPrsBuilder theHandle) -> Handle_MeshVS_MeshPrsBuilder
        assign(Handle_MeshVS_MeshPrsBuilder self, MeshVS_MeshPrsBuilder thePtr) -> Handle_MeshVS_MeshPrsBuilder
        assign(Handle_MeshVS_MeshPrsBuilder self, Handle_MeshVS_MeshPrsBuilder theHandle) -> Handle_MeshVS_MeshPrsBuilder

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MeshVS_MeshPrsBuilder self) -> MeshVS_MeshPrsBuilder

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MeshVS_MeshPrsBuilder self) -> MeshVS_MeshPrsBuilder

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MeshVS_MeshPrsBuilder self) -> MeshVS_MeshPrsBuilder

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder___ref__(self, *args)


    def __hash__(self):
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MeshVS.Handle_MeshVS_MeshPrsBuilder___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MeshVS.new_Handle_MeshVS_MeshPrsBuilder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MeshVS.Handle_MeshVS_MeshPrsBuilder_DownCast)
    __swig_destroy__ = _MeshVS.delete_Handle_MeshVS_MeshPrsBuilder

    def Build(self, *args):
        """
        Build(Handle_MeshVS_MeshPrsBuilder self, Handle_Prs3d_Presentation Prs, TColStd_PackedMapOfInteger IDs, TColStd_PackedMapOfInteger IDsToExclude, Standard_Boolean const IsElement, Standard_Integer const DisplayMode)

        Builds base mesh presentation by calling the methods below

        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type IDs: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IDsToExclude: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IsElement: bool
        :type DisplayMode: int

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_Build(self, *args)


    def BuildNodes(self, *args):
        """
        BuildNodes(Handle_MeshVS_MeshPrsBuilder self, Handle_Prs3d_Presentation Prs, TColStd_PackedMapOfInteger IDs, TColStd_PackedMapOfInteger IDsToExclude, Standard_Integer const DisplayMode)

        Builds nodes presentation

        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type IDs: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IDsToExclude: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type DisplayMode: int

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_BuildNodes(self, *args)


    def BuildElements(self, *args):
        """
        BuildElements(Handle_MeshVS_MeshPrsBuilder self, Handle_Prs3d_Presentation Prs, TColStd_PackedMapOfInteger IDs, TColStd_PackedMapOfInteger IDsToExclude, Standard_Integer const DisplayMode)

        Builds elements presentation

        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type IDs: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IDsToExclude: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type DisplayMode: int

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_BuildElements(self, *args)


    def BuildHilightPrs(self, *args):
        """
        BuildHilightPrs(Handle_MeshVS_MeshPrsBuilder self, Handle_Prs3d_Presentation Prs, TColStd_PackedMapOfInteger IDs, Standard_Boolean const IsElement)

        Builds presentation of hilighted entity

        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type IDs: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IsElement: bool

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_BuildHilightPrs(self, *args)


    def AddVolumePrs(self, *args):
        """
        AddVolumePrs(Handle_MeshVS_MeshPrsBuilder self, Handle_MeshVS_HArray1OfSequenceOfInteger Topo, NCollection_Array1_Standard_Real Nodes, Standard_Integer const NbNodes, Handle_Graphic3d_ArrayOfPrimitives Array, Standard_Boolean const IsReflected, Standard_Boolean const IsShrinked, Standard_Boolean const IsSelect, Standard_Real const ShrinkCoef)

        Add to array polygons or polylines representing volume

        :type Topo: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger
        :type Nodes: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NbNodes: int
        :type Array: OCC.wrapper.Graphic3d.Handle_Graphic3d_ArrayOfPrimitives
        :type IsReflected: bool
        :type IsShrinked: bool
        :type IsSelect: bool
        :type ShrinkCoef: float

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_AddVolumePrs(self, *args)


    def HowManyPrimitives(self, *args):
        """
        HowManyPrimitives(Handle_MeshVS_MeshPrsBuilder self, Handle_MeshVS_HArray1OfSequenceOfInteger Topo, Standard_Boolean const AsPolygons, Standard_Boolean const IsSelect, Standard_Integer const NbNodes)

        Calculate how many polygons or polylines are necessary to draw passed topology

        :type Topo: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger
        :type AsPolygons: bool
        :type IsSelect: bool
        :type NbNodes: int
        :type Vertices: int
        :type Bounds: int

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_HowManyPrimitives(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MeshVS_MeshPrsBuilder self) -> char const *

        :rtype: const char *

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_MeshPrsBuilder_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_MeshPrsBuilder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CustomBuild(self, *args):
        """
        CustomBuild(Handle_MeshVS_MeshPrsBuilder self, Handle_Prs3d_Presentation Prs, TColStd_PackedMapOfInteger IDs, TColStd_PackedMapOfInteger IDsToExclude, Standard_Integer const DisplayMode)

        This method is called to build presentation of custom elements (they have MeshVS_ET_0D type).
        IDs is set of numeric identificators of elements for custom building.
        IDsToExclude is set of IDs to exclude from processing. If some entity
        has been excluded, it is not processed by other builders.
        DisplayMode is numeric constant describing display mode (see MeshVS_DisplayModeFlags.hxx)

        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type IDs: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IDsToExclude: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type DisplayMode: int

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_CustomBuild(self, *args)


    def CustomSensitiveEntity(self, *args):
        """
        CustomSensitiveEntity(Handle_MeshVS_MeshPrsBuilder self, Handle_SelectBasics_EntityOwner Owner, Standard_Integer const SelectMode) -> Handle_SelectBasics_SensitiveEntity

        This method is called to build sensitive of custom elements ( they have MeshVS_ET_0D type )

        :type Owner: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner
        :type SelectMode: int
        :rtype: OCC.wrapper.SelectBasics.Handle_SelectBasics_SensitiveEntity

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_CustomSensitiveEntity(self, *args)


    def GetFlags(self, *args):
        """
        GetFlags(Handle_MeshVS_MeshPrsBuilder self) -> Standard_Integer

        Returns flags, assigned with builder during creation

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_GetFlags(self, *args)


    def TestFlags(self, *args):
        """
        TestFlags(Handle_MeshVS_MeshPrsBuilder self, Standard_Integer const DisplayMode) -> Standard_Boolean

        Test whether display mode has flags assigned with this builder.
        This method has default implementation and can be redefined for advance behavior
        Returns Standard_True only if display mode is appropriate for this builder

        :type DisplayMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_TestFlags(self, *args)


    def GetId(self, *args):
        """
        GetId(Handle_MeshVS_MeshPrsBuilder self) -> Standard_Integer

        Returns builder ID

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_GetId(self, *args)


    def GetPriority(self, *args):
        """
        GetPriority(Handle_MeshVS_MeshPrsBuilder self) -> Standard_Integer

        Returns priority; as priority bigger, as soon builder will be called.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_GetPriority(self, *args)


    def GetDataSource(self, *args):
        """
        GetDataSource(Handle_MeshVS_MeshPrsBuilder self) -> Handle_MeshVS_DataSource

        Returns custom data source or default ( from MeshVS_Mesh ) if custom is NULL

        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_GetDataSource(self, *args)


    def SetDataSource(self, *args):
        """
        SetDataSource(Handle_MeshVS_MeshPrsBuilder self, Handle_MeshVS_DataSource newDS)

        Change custom data source

        :type newDS: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_SetDataSource(self, *args)


    def GetDrawer(self, *args):
        """
        GetDrawer(Handle_MeshVS_MeshPrsBuilder self) -> Handle_MeshVS_Drawer

        Returns custom drawer or default ( from MeshVS_Mesh ) if custom is NULL

        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_GetDrawer(self, *args)


    def SetDrawer(self, *args):
        """
        SetDrawer(Handle_MeshVS_MeshPrsBuilder self, Handle_MeshVS_Drawer newDr)

        Change custom drawer

        :type newDr: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_SetDrawer(self, *args)


    def SetExcluding(self, *args):
        """
        SetExcluding(Handle_MeshVS_MeshPrsBuilder self, Standard_Boolean const state)

        Set excluding state. If it is Standard_True, the nodes or elements, processed by current builder
        will be noted and next builder won't process its.

        :type state: bool

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_SetExcluding(self, *args)


    def IsExcludingOn(self, *args):
        """
        IsExcludingOn(Handle_MeshVS_MeshPrsBuilder self) -> Standard_Boolean

        Read excluding state

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_IsExcludingOn(self, *args)


    def SetPresentationManager(self, *args):
        """
        SetPresentationManager(Handle_MeshVS_MeshPrsBuilder self, Handle_PrsMgr_PresentationManager thePrsMgr)

        Set presentation manager for builder

        :type thePrsMgr: OCC.wrapper.MeshVS.Handle_PrsMgr_PresentationManager3d

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_SetPresentationManager(self, *args)


    def GetPresentationManager(self, *args):
        """
        GetPresentationManager(Handle_MeshVS_MeshPrsBuilder self) -> Handle_PrsMgr_PresentationManager

        Get presentation manager of builder

        :rtype: OCC.wrapper.MeshVS.Handle_PrsMgr_PresentationManager3d

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_GetPresentationManager(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_MeshVS_MeshPrsBuilder self)

        Memory deallocator for transient classes


        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MeshVS_MeshPrsBuilder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MeshVS_MeshPrsBuilder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MeshVS_MeshPrsBuilder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MeshVS_MeshPrsBuilder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MeshVS_MeshPrsBuilder self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MeshVS_MeshPrsBuilder self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MeshVS_MeshPrsBuilder self)

        Increments the reference counter of this object


        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MeshVS_MeshPrsBuilder self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_MeshPrsBuilder_DecrementRefCounter(self, *args)

Handle_MeshVS_MeshPrsBuilder_swigregister = _MeshVS.Handle_MeshVS_MeshPrsBuilder_swigregister
Handle_MeshVS_MeshPrsBuilder_swigregister(Handle_MeshVS_MeshPrsBuilder)

def Handle_MeshVS_MeshPrsBuilder_DownCast(thing):
    return _MeshVS.Handle_MeshVS_MeshPrsBuilder_DownCast(thing)
Handle_MeshVS_MeshPrsBuilder_DownCast = _MeshVS.Handle_MeshVS_MeshPrsBuilder_DownCast

class Handle_MeshVS_PrsBuilder(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MeshVS_PrsBuilder self)

        Nullify the handle


        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MeshVS_PrsBuilder self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MeshVS_PrsBuilder self, MeshVS_PrsBuilder thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MeshVS_PrsBuilder self, Handle_MeshVS_PrsBuilder theHandle) -> Handle_MeshVS_PrsBuilder
        assign(Handle_MeshVS_PrsBuilder self, MeshVS_PrsBuilder thePtr) -> Handle_MeshVS_PrsBuilder
        assign(Handle_MeshVS_PrsBuilder self, Handle_MeshVS_PrsBuilder theHandle) -> Handle_MeshVS_PrsBuilder

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MeshVS_PrsBuilder self) -> MeshVS_PrsBuilder

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MeshVS_PrsBuilder self) -> MeshVS_PrsBuilder

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MeshVS_PrsBuilder self) -> MeshVS_PrsBuilder

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder___ref__(self, *args)


    def __hash__(self):
        return _MeshVS.Handle_MeshVS_PrsBuilder___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MeshVS.Handle_MeshVS_PrsBuilder___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MeshVS.new_Handle_MeshVS_PrsBuilder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MeshVS.Handle_MeshVS_PrsBuilder_DownCast)
    __swig_destroy__ = _MeshVS.delete_Handle_MeshVS_PrsBuilder

    def Build(self, *args):
        """
        Build(Handle_MeshVS_PrsBuilder self, Handle_Prs3d_Presentation Prs, TColStd_PackedMapOfInteger IDs, TColStd_PackedMapOfInteger IDsToExclude, Standard_Boolean const IsElement, Standard_Integer const DisplayMode)

        Builds presentation of certain type of data.
        Prs is presentation object which this method constructs.
        IDs is set of numeric identificators forming object appearance.
        IDsToExclude is set of IDs to exclude from processing. If some entity
        has been excluded, it is not processed by other builders.
        IsElement indicates, IDs is identificators of nodes or elements.
        DisplayMode is numeric constant describing display mode (see MeshVS_DisplayModeFlags.hxx)

        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type IDs: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IDsToExclude: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IsElement: bool
        :type DisplayMode: int

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_Build(self, *args)


    def CustomBuild(self, *args):
        """
        CustomBuild(Handle_MeshVS_PrsBuilder self, Handle_Prs3d_Presentation Prs, TColStd_PackedMapOfInteger IDs, TColStd_PackedMapOfInteger IDsToExclude, Standard_Integer const DisplayMode)

        This method is called to build presentation of custom elements (they have MeshVS_ET_0D type).
        IDs is set of numeric identificators of elements for custom building.
        IDsToExclude is set of IDs to exclude from processing. If some entity
        has been excluded, it is not processed by other builders.
        DisplayMode is numeric constant describing display mode (see MeshVS_DisplayModeFlags.hxx)

        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type IDs: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IDsToExclude: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type DisplayMode: int

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_CustomBuild(self, *args)


    def CustomSensitiveEntity(self, *args):
        """
        CustomSensitiveEntity(Handle_MeshVS_PrsBuilder self, Handle_SelectBasics_EntityOwner Owner, Standard_Integer const SelectMode) -> Handle_SelectBasics_SensitiveEntity

        This method is called to build sensitive of custom elements ( they have MeshVS_ET_0D type )

        :type Owner: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner
        :type SelectMode: int
        :rtype: OCC.wrapper.SelectBasics.Handle_SelectBasics_SensitiveEntity

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_CustomSensitiveEntity(self, *args)


    def GetFlags(self, *args):
        """
        GetFlags(Handle_MeshVS_PrsBuilder self) -> Standard_Integer

        Returns flags, assigned with builder during creation

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_GetFlags(self, *args)


    def TestFlags(self, *args):
        """
        TestFlags(Handle_MeshVS_PrsBuilder self, Standard_Integer const DisplayMode) -> Standard_Boolean

        Test whether display mode has flags assigned with this builder.
        This method has default implementation and can be redefined for advance behavior
        Returns Standard_True only if display mode is appropriate for this builder

        :type DisplayMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_TestFlags(self, *args)


    def GetId(self, *args):
        """
        GetId(Handle_MeshVS_PrsBuilder self) -> Standard_Integer

        Returns builder ID

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_GetId(self, *args)


    def GetPriority(self, *args):
        """
        GetPriority(Handle_MeshVS_PrsBuilder self) -> Standard_Integer

        Returns priority; as priority bigger, as soon builder will be called.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_GetPriority(self, *args)


    def GetDataSource(self, *args):
        """
        GetDataSource(Handle_MeshVS_PrsBuilder self) -> Handle_MeshVS_DataSource

        Returns custom data source or default ( from MeshVS_Mesh ) if custom is NULL

        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_GetDataSource(self, *args)


    def SetDataSource(self, *args):
        """
        SetDataSource(Handle_MeshVS_PrsBuilder self, Handle_MeshVS_DataSource newDS)

        Change custom data source

        :type newDS: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_SetDataSource(self, *args)


    def GetDrawer(self, *args):
        """
        GetDrawer(Handle_MeshVS_PrsBuilder self) -> Handle_MeshVS_Drawer

        Returns custom drawer or default ( from MeshVS_Mesh ) if custom is NULL

        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_GetDrawer(self, *args)


    def SetDrawer(self, *args):
        """
        SetDrawer(Handle_MeshVS_PrsBuilder self, Handle_MeshVS_Drawer newDr)

        Change custom drawer

        :type newDr: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_SetDrawer(self, *args)


    def SetExcluding(self, *args):
        """
        SetExcluding(Handle_MeshVS_PrsBuilder self, Standard_Boolean const state)

        Set excluding state. If it is Standard_True, the nodes or elements, processed by current builder
        will be noted and next builder won't process its.

        :type state: bool

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_SetExcluding(self, *args)


    def IsExcludingOn(self, *args):
        """
        IsExcludingOn(Handle_MeshVS_PrsBuilder self) -> Standard_Boolean

        Read excluding state

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_IsExcludingOn(self, *args)


    def SetPresentationManager(self, *args):
        """
        SetPresentationManager(Handle_MeshVS_PrsBuilder self, Handle_PrsMgr_PresentationManager thePrsMgr)

        Set presentation manager for builder

        :type thePrsMgr: OCC.wrapper.MeshVS.Handle_PrsMgr_PresentationManager3d

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_SetPresentationManager(self, *args)


    def GetPresentationManager(self, *args):
        """
        GetPresentationManager(Handle_MeshVS_PrsBuilder self) -> Handle_PrsMgr_PresentationManager

        Get presentation manager of builder

        :rtype: OCC.wrapper.MeshVS.Handle_PrsMgr_PresentationManager3d

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_GetPresentationManager(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MeshVS_PrsBuilder self) -> char const *

        :rtype: const char *

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_PrsBuilder_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_PrsBuilder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_MeshVS_PrsBuilder self)

        Memory deallocator for transient classes


        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MeshVS_PrsBuilder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MeshVS_PrsBuilder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MeshVS_PrsBuilder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MeshVS_PrsBuilder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MeshVS_PrsBuilder self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MeshVS_PrsBuilder self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MeshVS_PrsBuilder self)

        Increments the reference counter of this object


        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MeshVS_PrsBuilder self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_PrsBuilder_DecrementRefCounter(self, *args)

Handle_MeshVS_PrsBuilder_swigregister = _MeshVS.Handle_MeshVS_PrsBuilder_swigregister
Handle_MeshVS_PrsBuilder_swigregister(Handle_MeshVS_PrsBuilder)

def Handle_MeshVS_PrsBuilder_DownCast(thing):
    return _MeshVS.Handle_MeshVS_PrsBuilder_DownCast(thing)
Handle_MeshVS_PrsBuilder_DownCast = _MeshVS.Handle_MeshVS_PrsBuilder_DownCast

class NCollection_List_Handle_TColgp_HArray1OfPnt(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_TColgp_HArray1OfPnt self) -> NCollection_List< opencascade::handle< TColgp_HArray1OfPnt > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _MeshVS.NCollection_List_Handle_TColgp_HArray1OfPnt_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_TColgp_HArray1OfPnt self) -> NCollection_List< opencascade::handle< TColgp_HArray1OfPnt > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _MeshVS.NCollection_List_Handle_TColgp_HArray1OfPnt_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_TColgp_HArray1OfPnt self) -> NCollection_List< opencascade::handle< TColgp_HArray1OfPnt > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _MeshVS.NCollection_List_Handle_TColgp_HArray1OfPnt_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_TColgp_HArray1OfPnt self) -> NCollection_List< opencascade::handle< TColgp_HArray1OfPnt > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _MeshVS.NCollection_List_Handle_TColgp_HArray1OfPnt_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _MeshVS.new_NCollection_List_Handle_TColgp_HArray1OfPnt(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_TColgp_HArray1OfPnt self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.NCollection_List_Handle_TColgp_HArray1OfPnt_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_TColgp_HArray1OfPnt self, NCollection_List_Handle_TColgp_HArray1OfPnt theOther) -> NCollection_List_Handle_TColgp_HArray1OfPnt

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _MeshVS.NCollection_List_Handle_TColgp_HArray1OfPnt_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_TColgp_HArray1OfPnt self, NCollection_List_Handle_TColgp_HArray1OfPnt theOther) -> NCollection_List_Handle_TColgp_HArray1OfPnt

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _MeshVS.NCollection_List_Handle_TColgp_HArray1OfPnt_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_TColgp_HArray1OfPnt self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _MeshVS.NCollection_List_Handle_TColgp_HArray1OfPnt_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_List_Handle_TColgp_HArray1OfPnt_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_List_Handle_TColgp_HArray1OfPnt_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_TColgp_HArray1OfPnt self, Handle_TColgp_HArray1OfPnt theItem) -> Handle_TColgp_HArray1OfPnt
        Append(NCollection_List_Handle_TColgp_HArray1OfPnt self, Handle_TColgp_HArray1OfPnt theItem, NCollection_List< opencascade::handle< TColgp_HArray1OfPnt > >::Iterator & theIter)
        Append(NCollection_List_Handle_TColgp_HArray1OfPnt self, NCollection_List_Handle_TColgp_HArray1OfPnt theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _MeshVS.NCollection_List_Handle_TColgp_HArray1OfPnt_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_TColgp_HArray1OfPnt self, Handle_TColgp_HArray1OfPnt theItem) -> Handle_TColgp_HArray1OfPnt
        Prepend(NCollection_List_Handle_TColgp_HArray1OfPnt self, NCollection_List_Handle_TColgp_HArray1OfPnt theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _MeshVS.NCollection_List_Handle_TColgp_HArray1OfPnt_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_TColgp_HArray1OfPnt self)

        RemoveFirst item


        """
        return _MeshVS.NCollection_List_Handle_TColgp_HArray1OfPnt_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_TColgp_HArray1OfPnt self, NCollection_List< opencascade::handle< TColgp_HArray1OfPnt > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _MeshVS.NCollection_List_Handle_TColgp_HArray1OfPnt_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_TColgp_HArray1OfPnt self, Handle_TColgp_HArray1OfPnt theItem, NCollection_List< opencascade::handle< TColgp_HArray1OfPnt > >::Iterator & theIter) -> Handle_TColgp_HArray1OfPnt
        InsertBefore(NCollection_List_Handle_TColgp_HArray1OfPnt self, NCollection_List_Handle_TColgp_HArray1OfPnt theOther, NCollection_List< opencascade::handle< TColgp_HArray1OfPnt > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _MeshVS.NCollection_List_Handle_TColgp_HArray1OfPnt_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_TColgp_HArray1OfPnt self, Handle_TColgp_HArray1OfPnt theItem, NCollection_List< opencascade::handle< TColgp_HArray1OfPnt > >::Iterator & theIter) -> Handle_TColgp_HArray1OfPnt
        InsertAfter(NCollection_List_Handle_TColgp_HArray1OfPnt self, NCollection_List_Handle_TColgp_HArray1OfPnt theOther, NCollection_List< opencascade::handle< TColgp_HArray1OfPnt > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _MeshVS.NCollection_List_Handle_TColgp_HArray1OfPnt_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_TColgp_HArray1OfPnt self)

        Reverse the list


        """
        return _MeshVS.NCollection_List_Handle_TColgp_HArray1OfPnt_Reverse(self, *args)


    def __iter__(self):
        return _MeshVS.NCollection_List_Handle_TColgp_HArray1OfPnt___iter__(self)
    __swig_destroy__ = _MeshVS.delete_NCollection_List_Handle_TColgp_HArray1OfPnt
NCollection_List_Handle_TColgp_HArray1OfPnt_swigregister = _MeshVS.NCollection_List_Handle_TColgp_HArray1OfPnt_swigregister
NCollection_List_Handle_TColgp_HArray1OfPnt_swigregister(NCollection_List_Handle_TColgp_HArray1OfPnt)

class NCollection_List_Handle_TColgp_HArray1OfPnt_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _MeshVS.new_NCollection_List_Handle_TColgp_HArray1OfPnt_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MeshVS.delete_NCollection_List_Handle_TColgp_HArray1OfPnt_IteratorHelper

    def __next__(self):
        return _MeshVS.NCollection_List_Handle_TColgp_HArray1OfPnt_IteratorHelper___next__(self)
NCollection_List_Handle_TColgp_HArray1OfPnt_IteratorHelper_swigregister = _MeshVS.NCollection_List_Handle_TColgp_HArray1OfPnt_IteratorHelper_swigregister
NCollection_List_Handle_TColgp_HArray1OfPnt_IteratorHelper_swigregister(NCollection_List_Handle_TColgp_HArray1OfPnt_IteratorHelper)


try:
	MeshVS_PolyhedronVerts = NCollection_List_Handle_TColgp_HArray1OfPnt
except NameError:
	pass # does not exist, probably ignored

class MeshVS_MeshEntityOwner(SelectMgr.SelectMgr_EntityOwner):
    """
    The custom owner. This class provides methods to store owner information:
    1) An address of element or node data structure
    2) Type of node or element owner assigned
    3) ID of node or element owner assigned
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MeshVS_MeshEntityOwner
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MeshVS_MeshEntityOwner(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MeshVS_MeshEntityOwner self, SelectMgr_SelectableObject SelObj, Standard_Integer const ID, Standard_Address const MeshEntity, MeshVS_EntityType const & Type, Standard_Integer const Priority=0, Standard_Boolean const IsGroup) -> MeshVS_MeshEntityOwner

        :type SelObj: OCC.wrapper.SelectMgr.SelectMgr_SOPtr
        :type ID: int
        :type MeshEntity: OCC.wrapper.Standard.Standard_Address
        :type Type: OCC.wrapper.MeshVS.MeshVS_EntityType
        :type Priority: int
        :type IsGroup: bool

        """
        this = _MeshVS.new_MeshVS_MeshEntityOwner(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Owner(self, *args):
        """
        Owner(MeshVS_MeshEntityOwner self) -> Standard_Address

        Returns an address of element or node data structure

        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _MeshVS.MeshVS_MeshEntityOwner_Owner(self, *args)


    def Type(self, *args):
        """
        Type(MeshVS_MeshEntityOwner self) -> MeshVS_EntityType

        Returns type of element or node data structure

        :rtype: OCC.wrapper.MeshVS.MeshVS_EntityType

        """
        return _MeshVS.MeshVS_MeshEntityOwner_Type(self, *args)


    def ID(self, *args):
        """
        ID(MeshVS_MeshEntityOwner self) -> Standard_Integer

        Returns ID of element or node data structure

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.MeshVS_MeshEntityOwner_ID(self, *args)


    def IsGroup(self, *args):
        """
        IsGroup(MeshVS_MeshEntityOwner self) -> Standard_Boolean

        Returns true if owner represents group of nodes or elements

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_MeshEntityOwner_IsGroup(self, *args)


    def IsHilighted(self, *args):
        """
        IsHilighted(MeshVS_MeshEntityOwner self, Handle_PrsMgr_PresentationManager PM, Standard_Integer const Mode=0) -> Standard_Boolean

        Returns true if owner is hilighted

        :type PM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type Mode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_MeshEntityOwner_IsHilighted(self, *args)


    def HilightWithColor(self, *args):
        """
        HilightWithColor(MeshVS_MeshEntityOwner self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Standard_Integer const theMode=0)

        Hilights owner with the certain color

        :type thePM: OCC.wrapper.MeshVS.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theMode: int

        """
        return _MeshVS.MeshVS_MeshEntityOwner_HilightWithColor(self, *args)


    def Unhilight(self, *args):
        """
        Unhilight(MeshVS_MeshEntityOwner self, Handle_PrsMgr_PresentationManager PM, Standard_Integer const Mode=0)

        Strip hilight of owner

        :type PM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type Mode: int

        """
        return _MeshVS.MeshVS_MeshEntityOwner_Unhilight(self, *args)


    def Clear(self, *args):
        """
        Clear(MeshVS_MeshEntityOwner self, Handle_PrsMgr_PresentationManager PM, Standard_Integer const Mode=0)

        :type PM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type Mode: int

        """
        return _MeshVS.MeshVS_MeshEntityOwner_Clear(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MeshVS.MeshVS_MeshEntityOwner_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MeshVS.MeshVS_MeshEntityOwner_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.MeshVS_MeshEntityOwner_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MeshVS.delete_MeshVS_MeshEntityOwner
MeshVS_MeshEntityOwner_swigregister = _MeshVS.MeshVS_MeshEntityOwner_swigregister
MeshVS_MeshEntityOwner_swigregister(MeshVS_MeshEntityOwner)

def MeshVS_MeshEntityOwner_get_type_name(*args):
    """
    MeshVS_MeshEntityOwner_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MeshVS.MeshVS_MeshEntityOwner_get_type_name(*args)

def MeshVS_MeshEntityOwner_get_type_descriptor(*args):
    """
    MeshVS_MeshEntityOwner_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MeshVS.MeshVS_MeshEntityOwner_get_type_descriptor(*args)

class NCollection_Array1_TColStd_SequenceOfInteger(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_TColStd_SequenceOfInteger self) -> NCollection_Array1< TColStd_SequenceOfInteger >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _MeshVS.NCollection_Array1_TColStd_SequenceOfInteger_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_TColStd_SequenceOfInteger self) -> NCollection_Array1< TColStd_SequenceOfInteger >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _MeshVS.NCollection_Array1_TColStd_SequenceOfInteger_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_TColStd_SequenceOfInteger self) -> NCollection_Array1< TColStd_SequenceOfInteger >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _MeshVS.NCollection_Array1_TColStd_SequenceOfInteger_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_TColStd_SequenceOfInteger self) -> NCollection_Array1< TColStd_SequenceOfInteger >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _MeshVS.NCollection_Array1_TColStd_SequenceOfInteger_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _MeshVS.new_NCollection_Array1_TColStd_SequenceOfInteger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_TColStd_SequenceOfInteger self, NCollection_Sequence_Standard_Integer theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _MeshVS.NCollection_Array1_TColStd_SequenceOfInteger_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_TColStd_SequenceOfInteger self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.NCollection_Array1_TColStd_SequenceOfInteger_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_TColStd_SequenceOfInteger self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.NCollection_Array1_TColStd_SequenceOfInteger_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_TColStd_SequenceOfInteger self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_Array1_TColStd_SequenceOfInteger_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_TColStd_SequenceOfInteger self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.NCollection_Array1_TColStd_SequenceOfInteger_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_TColStd_SequenceOfInteger self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.NCollection_Array1_TColStd_SequenceOfInteger_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_TColStd_SequenceOfInteger self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_Array1_TColStd_SequenceOfInteger_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_TColStd_SequenceOfInteger self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_Array1_TColStd_SequenceOfInteger_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_TColStd_SequenceOfInteger self, NCollection_Array1_TColStd_SequenceOfInteger theOther) -> NCollection_Array1_TColStd_SequenceOfInteger

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _MeshVS.NCollection_Array1_TColStd_SequenceOfInteger_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_TColStd_SequenceOfInteger self, NCollection_Array1_TColStd_SequenceOfInteger theOther) -> NCollection_Array1_TColStd_SequenceOfInteger

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _MeshVS.NCollection_Array1_TColStd_SequenceOfInteger_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_TColStd_SequenceOfInteger self, NCollection_Array1_TColStd_SequenceOfInteger theOther) -> NCollection_Array1_TColStd_SequenceOfInteger
        assign(NCollection_Array1_TColStd_SequenceOfInteger self, NCollection_Array1_TColStd_SequenceOfInteger theOther) -> NCollection_Array1_TColStd_SequenceOfInteger

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _MeshVS.NCollection_Array1_TColStd_SequenceOfInteger_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_Array1_TColStd_SequenceOfInteger_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_TColStd_SequenceOfInteger self) -> NCollection_Sequence_Standard_Integer

        @return first element

        :rtype: TheItemType &

        """
        return _MeshVS.NCollection_Array1_TColStd_SequenceOfInteger_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_Array1_TColStd_SequenceOfInteger_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_TColStd_SequenceOfInteger self) -> NCollection_Sequence_Standard_Integer

        @return last element

        :rtype: TheItemType &

        """
        return _MeshVS.NCollection_Array1_TColStd_SequenceOfInteger_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_Array1_TColStd_SequenceOfInteger_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_TColStd_SequenceOfInteger self, Standard_Integer const theIndex) -> NCollection_Sequence_Standard_Integer

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _MeshVS.NCollection_Array1_TColStd_SequenceOfInteger_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_Array1_TColStd_SequenceOfInteger___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_Array1_TColStd_SequenceOfInteger_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_TColStd_SequenceOfInteger self, Standard_Integer const theIndex, NCollection_Sequence_Standard_Integer theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _MeshVS.NCollection_Array1_TColStd_SequenceOfInteger_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_TColStd_SequenceOfInteger self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _MeshVS.NCollection_Array1_TColStd_SequenceOfInteger_Resize(self, *args)

    __swig_destroy__ = _MeshVS.delete_NCollection_Array1_TColStd_SequenceOfInteger
NCollection_Array1_TColStd_SequenceOfInteger_swigregister = _MeshVS.NCollection_Array1_TColStd_SequenceOfInteger_swigregister
NCollection_Array1_TColStd_SequenceOfInteger_swigregister(NCollection_Array1_TColStd_SequenceOfInteger)


try:
	MeshVS_Array1OfSequenceOfInteger = NCollection_Array1_TColStd_SequenceOfInteger
except NameError:
	pass # does not exist, probably ignored

class Handle_MeshVS_DummySensitiveEntity(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MeshVS_DummySensitiveEntity self)

        Nullify the handle


        """
        return _MeshVS.Handle_MeshVS_DummySensitiveEntity_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MeshVS_DummySensitiveEntity self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MeshVS.Handle_MeshVS_DummySensitiveEntity_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MeshVS_DummySensitiveEntity self, MeshVS_DummySensitiveEntity thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MeshVS.Handle_MeshVS_DummySensitiveEntity_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MeshVS_DummySensitiveEntity self, Handle_MeshVS_DummySensitiveEntity theHandle) -> Handle_MeshVS_DummySensitiveEntity
        assign(Handle_MeshVS_DummySensitiveEntity self, MeshVS_DummySensitiveEntity thePtr) -> Handle_MeshVS_DummySensitiveEntity
        assign(Handle_MeshVS_DummySensitiveEntity self, Handle_MeshVS_DummySensitiveEntity theHandle) -> Handle_MeshVS_DummySensitiveEntity

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MeshVS.Handle_MeshVS_DummySensitiveEntity_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MeshVS_DummySensitiveEntity self) -> MeshVS_DummySensitiveEntity

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_DummySensitiveEntity_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MeshVS_DummySensitiveEntity self) -> MeshVS_DummySensitiveEntity

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_DummySensitiveEntity___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MeshVS_DummySensitiveEntity self) -> MeshVS_DummySensitiveEntity

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MeshVS.Handle_MeshVS_DummySensitiveEntity___ref__(self, *args)


    def __hash__(self):
        return _MeshVS.Handle_MeshVS_DummySensitiveEntity___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MeshVS.Handle_MeshVS_DummySensitiveEntity___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MeshVS.new_Handle_MeshVS_DummySensitiveEntity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MeshVS.Handle_MeshVS_DummySensitiveEntity_DownCast)
    __swig_destroy__ = _MeshVS.delete_Handle_MeshVS_DummySensitiveEntity

    def Matches(self, *args):
        """
        Matches(Handle_MeshVS_DummySensitiveEntity self, SelectBasics_SelectingVolumeManager theMgr, SelectBasics_PickResult & thePickResult) -> Standard_Boolean

        :type theMgr: OCC.wrapper.SelectBasics.SelectBasics_SelectingVolumeManager
        :type thePickResult: OCC.wrapper.SelectBasics.SelectBasics_PickResult
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DummySensitiveEntity_Matches(self, *args)


    def NbSubElements(self, *args):
        """
        NbSubElements(Handle_MeshVS_DummySensitiveEntity self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_DummySensitiveEntity_NbSubElements(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_MeshVS_DummySensitiveEntity self) -> BVH_Box_Standard_Real_

        :rtype: OCC.wrapper.Select3D.Select3D_BndBox3d

        """
        return _MeshVS.Handle_MeshVS_DummySensitiveEntity_BoundingBox(self, *args)


    def BVH(self, *args):
        """
        BVH(Handle_MeshVS_DummySensitiveEntity self)

        Builds BVH tree for sensitive if it is needed


        """
        return _MeshVS.Handle_MeshVS_DummySensitiveEntity_BVH(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_MeshVS_DummySensitiveEntity self)

        Clears up all the resources and memory allocated


        """
        return _MeshVS.Handle_MeshVS_DummySensitiveEntity_Clear(self, *args)


    def HasInitLocation(self, *args):
        """
        HasInitLocation(Handle_MeshVS_DummySensitiveEntity self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DummySensitiveEntity_HasInitLocation(self, *args)


    def InvInitLocation(self, *args):
        """
        InvInitLocation(Handle_MeshVS_DummySensitiveEntity self) -> gp_GTrsf

        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        return _MeshVS.Handle_MeshVS_DummySensitiveEntity_InvInitLocation(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MeshVS_DummySensitiveEntity self) -> char const *

        :rtype: const char *

        """
        return _MeshVS.Handle_MeshVS_DummySensitiveEntity_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_DummySensitiveEntity_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_DummySensitiveEntity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_MeshVS_DummySensitiveEntity self, Handle_SelectBasics_EntityOwner theOwnerId)

        Sets owner of the entity

        :type theOwnerId: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner

        """
        return _MeshVS.Handle_MeshVS_DummySensitiveEntity_Set(self, *args)


    def OwnerId(self, *args):
        """
        Returns pointer to owner of the entity

        :rtype: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner

        """
        res = _MeshVS.Handle_MeshVS_DummySensitiveEntity_OwnerId(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SensitivityFactor(self, *args):
        """
        SensitivityFactor(Handle_MeshVS_DummySensitiveEntity self) -> Standard_Integer

        allows a better sensitivity for
        a specific entity in selection algorithms
        useful for small sized entities.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_DummySensitiveEntity_SensitivityFactor(self, *args)


    def SetSensitivityFactor(self, *args):
        """
        SetSensitivityFactor(Handle_MeshVS_DummySensitiveEntity self, Standard_Integer const theNewSens)

        Allows to manage sensitivity of a particular sensitive entity

        :type theNewSens: int

        """
        return _MeshVS.Handle_MeshVS_DummySensitiveEntity_SetSensitivityFactor(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_MeshVS_DummySensitiveEntity self)

        Memory deallocator for transient classes


        """
        return _MeshVS.Handle_MeshVS_DummySensitiveEntity_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MeshVS_DummySensitiveEntity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MeshVS_DummySensitiveEntity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DummySensitiveEntity_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MeshVS_DummySensitiveEntity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MeshVS_DummySensitiveEntity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DummySensitiveEntity_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MeshVS_DummySensitiveEntity self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MeshVS.Handle_MeshVS_DummySensitiveEntity_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MeshVS_DummySensitiveEntity self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_DummySensitiveEntity_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MeshVS_DummySensitiveEntity self)

        Increments the reference counter of this object


        """
        return _MeshVS.Handle_MeshVS_DummySensitiveEntity_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MeshVS_DummySensitiveEntity self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_DummySensitiveEntity_DecrementRefCounter(self, *args)

Handle_MeshVS_DummySensitiveEntity_swigregister = _MeshVS.Handle_MeshVS_DummySensitiveEntity_swigregister
Handle_MeshVS_DummySensitiveEntity_swigregister(Handle_MeshVS_DummySensitiveEntity)

def Handle_MeshVS_DummySensitiveEntity_DownCast(thing):
    return _MeshVS.Handle_MeshVS_DummySensitiveEntity_DownCast(thing)
Handle_MeshVS_DummySensitiveEntity_DownCast = _MeshVS.Handle_MeshVS_DummySensitiveEntity_DownCast

class Handle_MeshVS_SensitiveSegment(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MeshVS_SensitiveSegment self)

        Nullify the handle


        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MeshVS_SensitiveSegment self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MeshVS_SensitiveSegment self, MeshVS_SensitiveSegment thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MeshVS_SensitiveSegment self, Handle_MeshVS_SensitiveSegment theHandle) -> Handle_MeshVS_SensitiveSegment
        assign(Handle_MeshVS_SensitiveSegment self, MeshVS_SensitiveSegment thePtr) -> Handle_MeshVS_SensitiveSegment
        assign(Handle_MeshVS_SensitiveSegment self, Handle_MeshVS_SensitiveSegment theHandle) -> Handle_MeshVS_SensitiveSegment

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MeshVS_SensitiveSegment self) -> MeshVS_SensitiveSegment

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MeshVS_SensitiveSegment self) -> MeshVS_SensitiveSegment

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MeshVS_SensitiveSegment self) -> MeshVS_SensitiveSegment

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment___ref__(self, *args)


    def __hash__(self):
        return _MeshVS.Handle_MeshVS_SensitiveSegment___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MeshVS.Handle_MeshVS_SensitiveSegment___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MeshVS.new_Handle_MeshVS_SensitiveSegment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MeshVS.Handle_MeshVS_SensitiveSegment_DownCast)
    __swig_destroy__ = _MeshVS.delete_Handle_MeshVS_SensitiveSegment

    def get_type_name(self, *args):
        """
        get_type_name(Handle_MeshVS_SensitiveSegment self) -> char const *

        :rtype: const char *

        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_SensitiveSegment_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_SensitiveSegment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetStartPoint(self, *args):
        """
        SetStartPoint(Handle_MeshVS_SensitiveSegment self, gp_Pnt thePnt)

        changes the start Point of the Segment;

        :type thePnt: OCC.wrapper.gp.gp_Pnt

        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_SetStartPoint(self, *args)


    def SetEndPoint(self, *args):
        """
        SetEndPoint(Handle_MeshVS_SensitiveSegment self, gp_Pnt thePnt)

        changes the end point of the segment

        :type thePnt: OCC.wrapper.gp.gp_Pnt

        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_SetEndPoint(self, *args)


    def StartPoint(self, *args):
        """
        gives the 3D start Point of the Segment

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _MeshVS.Handle_MeshVS_SensitiveSegment_StartPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def EndPoint(self, *args):
        """
        gives the 3D End Point of the Segment

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _MeshVS.Handle_MeshVS_SensitiveSegment_EndPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbSubElements(self, *args):
        """
        NbSubElements(Handle_MeshVS_SensitiveSegment self) -> Standard_Integer

        Returns the amount of points

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_NbSubElements(self, *args)


    def GetConnected(self, *args):
        """
        GetConnected(Handle_MeshVS_SensitiveSegment self) -> Handle_Select3D_SensitiveEntity

        :rtype: OCC.wrapper.Select3D.Handle_Select3D_SensitiveEntity

        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_GetConnected(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_MeshVS_SensitiveSegment self, SelectBasics_SelectingVolumeManager theMgr, SelectBasics_PickResult & thePickResult) -> Standard_Boolean

        Checks whether the segment overlaps current selecting volume

        :type theMgr: OCC.wrapper.SelectBasics.SelectBasics_SelectingVolumeManager
        :type thePickResult: OCC.wrapper.SelectBasics.SelectBasics_PickResult
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_Matches(self, *args)


    def CenterOfGeometry(self, *args):
        """
        CenterOfGeometry(Handle_MeshVS_SensitiveSegment self) -> gp_Pnt

        Returns center of the segment. If location transformation
        is set, it will be applied

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_CenterOfGeometry(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_MeshVS_SensitiveSegment self) -> BVH_Box_Standard_Real_

        Returns bounding box of the segment. If location
        transformation is set, it will be applied

        :rtype: OCC.wrapper.Select3D.Select3D_BndBox3d

        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_BoundingBox(self, *args)


    def BVH(self, *args):
        """
        BVH(Handle_MeshVS_SensitiveSegment self)

        Builds BVH tree for a sensitive if needed


        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_BVH(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_MeshVS_SensitiveSegment self)

        Clears up all resources and memory


        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_Clear(self, *args)


    def HasInitLocation(self, *args):
        """
        HasInitLocation(Handle_MeshVS_SensitiveSegment self) -> Standard_Boolean

        Returns true if the shape corresponding to the entity has init location

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_HasInitLocation(self, *args)


    def InvInitLocation(self, *args):
        """
        InvInitLocation(Handle_MeshVS_SensitiveSegment self) -> gp_GTrsf

        Returns inversed location transformation matrix if the shape corresponding
        to this entity has init location set. Otherwise, returns identity matrix.

        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_InvInitLocation(self, *args)


    def Set(self, *args):
        """
        Set(Handle_MeshVS_SensitiveSegment self, Handle_SelectBasics_EntityOwner theOwnerId)

        Sets owner of the entity

        :type theOwnerId: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner

        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_Set(self, *args)


    def OwnerId(self, *args):
        """
        Returns pointer to owner of the entity

        :rtype: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner

        """
        res = _MeshVS.Handle_MeshVS_SensitiveSegment_OwnerId(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SensitivityFactor(self, *args):
        """
        SensitivityFactor(Handle_MeshVS_SensitiveSegment self) -> Standard_Integer

        allows a better sensitivity for
        a specific entity in selection algorithms
        useful for small sized entities.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_SensitivityFactor(self, *args)


    def SetSensitivityFactor(self, *args):
        """
        SetSensitivityFactor(Handle_MeshVS_SensitiveSegment self, Standard_Integer const theNewSens)

        Allows to manage sensitivity of a particular sensitive entity

        :type theNewSens: int

        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_SetSensitivityFactor(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_MeshVS_SensitiveSegment self)

        Memory deallocator for transient classes


        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MeshVS_SensitiveSegment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MeshVS_SensitiveSegment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MeshVS_SensitiveSegment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MeshVS_SensitiveSegment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MeshVS_SensitiveSegment self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MeshVS_SensitiveSegment self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MeshVS_SensitiveSegment self)

        Increments the reference counter of this object


        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MeshVS_SensitiveSegment self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_SensitiveSegment_DecrementRefCounter(self, *args)

Handle_MeshVS_SensitiveSegment_swigregister = _MeshVS.Handle_MeshVS_SensitiveSegment_swigregister
Handle_MeshVS_SensitiveSegment_swigregister(Handle_MeshVS_SensitiveSegment)

def Handle_MeshVS_SensitiveSegment_DownCast(thing):
    return _MeshVS.Handle_MeshVS_SensitiveSegment_DownCast(thing)
Handle_MeshVS_SensitiveSegment_DownCast = _MeshVS.Handle_MeshVS_SensitiveSegment_DownCast

class MeshVS_NodalColorPrsBuilder(MeshVS_PrsBuilder):
    """
    This class provides methods to create presentation of nodes with assigned color.
    There are two ways of presentation building
    1. Without using texture.
    In this case colors of nodes are specified with DataMapOfIntegerColor and presentation
    is built with gradient fill between these nodes (default behaviour)
    2. Using texture.
    In this case presentation is built with spectrum filling between nodes. For example, if
    one node has blue color and second one has violet color, parameters of this class may be
    set to fill presentation between nodes with solar spectrum.
    Methods:
    UseTexture - activates/deactivates this way
    SetColorMap - sets colors used for generation of texture
    SetColorindices - specifies correspondence between node IDs and indices of colors from color map
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MeshVS_NodalColorPrsBuilder
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MeshVS_NodalColorPrsBuilder(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MeshVS_NodalColorPrsBuilder self, Handle_MeshVS_Mesh Parent, MeshVS_DisplayModeFlags const & Flags=MeshVS_DMF_NodalColorDataPrs, Handle_MeshVS_DataSource DS=0, Standard_Integer const Id=-1, MeshVS_BuilderPriority const & Priority=MeshVS_BP_NodalColor) -> MeshVS_NodalColorPrsBuilder

        :type Parent: OCC.wrapper.MeshVS.Handle_MeshVS_Mesh
        :type Flags: OCC.wrapper.MeshVS.MeshVS_DisplayModeFlags
        :type DS: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource
        :type Id: int
        :type Priority: OCC.wrapper.MeshVS.MeshVS_BuilderPriority

        """
        this = _MeshVS.new_MeshVS_NodalColorPrsBuilder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Build(self, *args):
        """
        Build(MeshVS_NodalColorPrsBuilder self, Handle_Prs3d_Presentation Prs, TColStd_PackedMapOfInteger IDs, TColStd_PackedMapOfInteger IDsToExclude, Standard_Boolean const IsElement, Standard_Integer const DisplayMode)

        Builds presentation of nodes with assigned color.

        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type IDs: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IDsToExclude: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IsElement: bool
        :type DisplayMode: int

        """
        return _MeshVS.MeshVS_NodalColorPrsBuilder_Build(self, *args)


    def GetColors(self, *args):
        """
        Returns map of colors assigned to nodes.

        :rtype: OCC.wrapper.MeshVS.MeshVS_DataMapOfIntegerColor

        """
        res = _MeshVS.MeshVS_NodalColorPrsBuilder_GetColors(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColors(self, *args):
        """
        SetColors(MeshVS_NodalColorPrsBuilder self, NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher Map)

        Sets map of colors assigned to nodes.

        :type Map: OCC.wrapper.MeshVS.MeshVS_DataMapOfIntegerColor

        """
        return _MeshVS.MeshVS_NodalColorPrsBuilder_SetColors(self, *args)


    def HasColors(self, *args):
        """
        HasColors(MeshVS_NodalColorPrsBuilder self) -> Standard_Boolean

        Returns true, if map isn't empty

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_NodalColorPrsBuilder_HasColors(self, *args)


    def GetColor(self, *args):
        """
        GetColor(MeshVS_NodalColorPrsBuilder self, Standard_Integer const ID, Quantity_Color theColor) -> Standard_Boolean

        Returns color assigned to single node

        :type ID: int
        :type theColor: OCC.wrapper.Quantity.Quantity_Color
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_NodalColorPrsBuilder_GetColor(self, *args)


    def SetColor(self, *args):
        """
        SetColor(MeshVS_NodalColorPrsBuilder self, Standard_Integer const ID, Quantity_Color theColor)

        Sets color assigned to single node

        :type ID: int
        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _MeshVS.MeshVS_NodalColorPrsBuilder_SetColor(self, *args)


    def UseTexture(self, *args):
        """
        UseTexture(MeshVS_NodalColorPrsBuilder self, Standard_Boolean const theToUse)

        Specify whether texture must be used to build presentation

        :type theToUse: bool

        """
        return _MeshVS.MeshVS_NodalColorPrsBuilder_UseTexture(self, *args)


    def IsUseTexture(self, *args):
        """
        IsUseTexture(MeshVS_NodalColorPrsBuilder self) -> Standard_Boolean

        Verify whether texture is used to build presentation

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_NodalColorPrsBuilder_IsUseTexture(self, *args)


    def SetColorMap(self, *args):
        """
        SetColorMap(MeshVS_NodalColorPrsBuilder self, NCollection_Sequence_Quantity_Color theColors)

        Set colors to be used for texrture presentation
        theColors - colors for valid coordinates (laying in range [0, 1])

        :type theColors: OCC.wrapper.Aspect.Aspect_SequenceOfColor

        """
        return _MeshVS.MeshVS_NodalColorPrsBuilder_SetColorMap(self, *args)


    def GetColorMap(self, *args):
        """
        Return colors used for texrture presentation

        :rtype: OCC.wrapper.Aspect.Aspect_SequenceOfColor

        """
        res = _MeshVS.MeshVS_NodalColorPrsBuilder_GetColorMap(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetInvalidColor(self, *args):
        """
        SetInvalidColor(MeshVS_NodalColorPrsBuilder self, Quantity_Color theInvalidColor)

        Set color representing invalid texture coordinate
        (laying outside range [0, 1])

        :type theInvalidColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _MeshVS.MeshVS_NodalColorPrsBuilder_SetInvalidColor(self, *args)


    def GetInvalidColor(self, *args):
        """
        GetInvalidColor(MeshVS_NodalColorPrsBuilder self) -> Quantity_Color

        Return color representing invalid texture coordinate
        (laying outside range [0, 1])

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        return _MeshVS.MeshVS_NodalColorPrsBuilder_GetInvalidColor(self, *args)


    def SetTextureCoords(self, *args):
        """
        SetTextureCoords(MeshVS_NodalColorPrsBuilder self, NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher theMap)

        Specify correspondence between node IDs and texture coordinates (range [0, 1])

        :type theMap: OCC.wrapper.TColStd.TColStd_DataMapOfIntegerReal

        """
        return _MeshVS.MeshVS_NodalColorPrsBuilder_SetTextureCoords(self, *args)


    def GetTextureCoords(self, *args):
        """
        Get correspondence between node IDs and texture coordinates (range [0, 1])

        :rtype: OCC.wrapper.TColStd.TColStd_DataMapOfIntegerReal

        """
        res = _MeshVS.MeshVS_NodalColorPrsBuilder_GetTextureCoords(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTextureCoord(self, *args):
        """
        SetTextureCoord(MeshVS_NodalColorPrsBuilder self, Standard_Integer const theID, Standard_Real const theCoord)

        Specify correspondence between node ID and texture coordinate (range [0, 1])

        :type theID: int
        :type theCoord: float

        """
        return _MeshVS.MeshVS_NodalColorPrsBuilder_SetTextureCoord(self, *args)


    def GetTextureCoord(self, *args):
        """
        GetTextureCoord(MeshVS_NodalColorPrsBuilder self, Standard_Integer const theID) -> Standard_Real

        Return correspondence between node IDs and texture coordinate (range [0, 1])

        :type theID: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MeshVS.MeshVS_NodalColorPrsBuilder_GetTextureCoord(self, *args)


    def AddVolumePrs(self, *args):
        """
        AddVolumePrs(MeshVS_NodalColorPrsBuilder self, Handle_MeshVS_HArray1OfSequenceOfInteger theTopo, NCollection_Array1_Standard_Integer theNodes, NCollection_Array1_Standard_Real theCoords, Handle_Graphic3d_ArrayOfPrimitives theArray, Standard_Boolean const theIsShaded, Standard_Integer const theNbColors, Standard_Integer const theNbTexColors, Standard_Real const theColorRatio)

        Add to array polygons or polylines representing volume

        :type theTopo: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger
        :type theNodes: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type theCoords: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type theArray: OCC.wrapper.Graphic3d.Handle_Graphic3d_ArrayOfPrimitives
        :type theIsShaded: bool
        :type theNbColors: int
        :type theNbTexColors: int
        :type theColorRatio: float

        """
        return _MeshVS.MeshVS_NodalColorPrsBuilder_AddVolumePrs(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MeshVS.MeshVS_NodalColorPrsBuilder_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MeshVS.MeshVS_NodalColorPrsBuilder_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.MeshVS_NodalColorPrsBuilder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MeshVS.delete_MeshVS_NodalColorPrsBuilder
MeshVS_NodalColorPrsBuilder_swigregister = _MeshVS.MeshVS_NodalColorPrsBuilder_swigregister
MeshVS_NodalColorPrsBuilder_swigregister(MeshVS_NodalColorPrsBuilder)

def MeshVS_NodalColorPrsBuilder_get_type_name(*args):
    """
    MeshVS_NodalColorPrsBuilder_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MeshVS.MeshVS_NodalColorPrsBuilder_get_type_name(*args)

def MeshVS_NodalColorPrsBuilder_get_type_descriptor(*args):
    """
    MeshVS_NodalColorPrsBuilder_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MeshVS.MeshVS_NodalColorPrsBuilder_get_type_descriptor(*args)

class MeshVS_Drawer(Standard.Standard_Transient):
    """
    This class provided the common interface to share between classes
    big set of constants affecting to object appearance. By default, this class
    can store integers, doubles, OCC colors, OCC materials. Each of OCC enum members
    can be stored as integers.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MeshVS_Drawer
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MeshVS_Drawer(self) 
            return h


    def Assign(self, *args):
        """
        Assign(MeshVS_Drawer self, Handle_MeshVS_Drawer aDrawer)

        This method copies other drawer contents to this.

        :type aDrawer: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer

        """
        return _MeshVS.MeshVS_Drawer_Assign(self, *args)


    def SetInteger(self, *args):
        """
        SetInteger(MeshVS_Drawer self, Standard_Integer const Key, Standard_Integer const Value)

        :type Key: int
        :type Value: int

        """
        return _MeshVS.MeshVS_Drawer_SetInteger(self, *args)


    def SetDouble(self, *args):
        """
        SetDouble(MeshVS_Drawer self, Standard_Integer const Key, Standard_Real const Value)

        :type Key: int
        :type Value: float

        """
        return _MeshVS.MeshVS_Drawer_SetDouble(self, *args)


    def SetBoolean(self, *args):
        """
        SetBoolean(MeshVS_Drawer self, Standard_Integer const Key, Standard_Boolean const Value)

        :type Key: int
        :type Value: bool

        """
        return _MeshVS.MeshVS_Drawer_SetBoolean(self, *args)


    def SetColor(self, *args):
        """
        SetColor(MeshVS_Drawer self, Standard_Integer const Key, Quantity_Color Value)

        :type Key: int
        :type Value: OCC.wrapper.Quantity.Quantity_Color

        """
        return _MeshVS.MeshVS_Drawer_SetColor(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(MeshVS_Drawer self, Standard_Integer const Key, Graphic3d_MaterialAspect Value)

        :type Key: int
        :type Value: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _MeshVS.MeshVS_Drawer_SetMaterial(self, *args)


    def SetAsciiString(self, *args):
        """
        SetAsciiString(MeshVS_Drawer self, Standard_Integer const Key, TCollection_AsciiString Value)

        :type Key: int
        :type Value: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _MeshVS.MeshVS_Drawer_SetAsciiString(self, *args)


    def GetInteger(self, *args):
        """
        GetInteger(MeshVS_Drawer self, Standard_Integer const Key) -> Standard_Boolean

        :type Key: int
        :type Value: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_Drawer_GetInteger(self, *args)


    def GetDouble(self, *args):
        """
        GetDouble(MeshVS_Drawer self, Standard_Integer const Key) -> Standard_Boolean

        :type Key: int
        :type Value: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_Drawer_GetDouble(self, *args)


    def GetBoolean(self, *args):
        """
        GetBoolean(MeshVS_Drawer self, Standard_Integer const Key) -> Standard_Boolean

        :type Key: int
        :type Value: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_Drawer_GetBoolean(self, *args)


    def GetColor(self, *args):
        """
        GetColor(MeshVS_Drawer self, Standard_Integer const Key, Quantity_Color Value) -> Standard_Boolean

        :type Key: int
        :type Value: OCC.wrapper.Quantity.Quantity_Color
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_Drawer_GetColor(self, *args)


    def GetMaterial(self, *args):
        """
        GetMaterial(MeshVS_Drawer self, Standard_Integer const Key, Graphic3d_MaterialAspect Value) -> Standard_Boolean

        :type Key: int
        :type Value: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_Drawer_GetMaterial(self, *args)


    def GetAsciiString(self, *args):
        """
        GetAsciiString(MeshVS_Drawer self, Standard_Integer const Key, TCollection_AsciiString Value) -> Standard_Boolean

        :type Key: int
        :type Value: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_Drawer_GetAsciiString(self, *args)


    def RemoveInteger(self, *args):
        """
        RemoveInteger(MeshVS_Drawer self, Standard_Integer const Key) -> Standard_Boolean

        :type Key: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_Drawer_RemoveInteger(self, *args)


    def RemoveDouble(self, *args):
        """
        RemoveDouble(MeshVS_Drawer self, Standard_Integer const Key) -> Standard_Boolean

        :type Key: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_Drawer_RemoveDouble(self, *args)


    def RemoveBoolean(self, *args):
        """
        RemoveBoolean(MeshVS_Drawer self, Standard_Integer const Key) -> Standard_Boolean

        :type Key: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_Drawer_RemoveBoolean(self, *args)


    def RemoveColor(self, *args):
        """
        RemoveColor(MeshVS_Drawer self, Standard_Integer const Key) -> Standard_Boolean

        :type Key: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_Drawer_RemoveColor(self, *args)


    def RemoveMaterial(self, *args):
        """
        RemoveMaterial(MeshVS_Drawer self, Standard_Integer const Key) -> Standard_Boolean

        :type Key: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_Drawer_RemoveMaterial(self, *args)


    def RemoveAsciiString(self, *args):
        """
        RemoveAsciiString(MeshVS_Drawer self, Standard_Integer const Key) -> Standard_Boolean

        :type Key: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_Drawer_RemoveAsciiString(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MeshVS.MeshVS_Drawer_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MeshVS.MeshVS_Drawer_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.MeshVS_Drawer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self):
        """
        This class provided the common interface to share between classes
        big set of constants affecting to object appearance. By default, this class
        can store integers, doubles, OCC colors, OCC materials. Each of OCC enum members
        can be stored as integers.
        """
        this = _MeshVS.new_MeshVS_Drawer()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _MeshVS.delete_MeshVS_Drawer
MeshVS_Drawer_swigregister = _MeshVS.MeshVS_Drawer_swigregister
MeshVS_Drawer_swigregister(MeshVS_Drawer)

def MeshVS_Drawer_get_type_name(*args):
    """
    MeshVS_Drawer_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MeshVS.MeshVS_Drawer_get_type_name(*args)

def MeshVS_Drawer_get_type_descriptor(*args):
    """
    MeshVS_Drawer_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MeshVS.MeshVS_Drawer_get_type_descriptor(*args)

class MeshVS_SensitiveMesh(Select3D.Select3D_SensitiveEntity):
    """This class provides custom mesh sensitive entity used in advanced mesh selection."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MeshVS_SensitiveMesh
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MeshVS_SensitiveMesh(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MeshVS_SensitiveMesh self, Handle_SelectBasics_EntityOwner theOwner, Standard_Integer const theMode=0) -> MeshVS_SensitiveMesh

        :type theOwner: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner
        :type theMode: int

        """
        this = _MeshVS.new_MeshVS_SensitiveMesh(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetMode(self, *args):
        """
        GetMode(MeshVS_SensitiveMesh self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.MeshVS_SensitiveMesh_GetMode(self, *args)


    def GetConnected(self, *args):
        """
        GetConnected(MeshVS_SensitiveMesh self) -> Handle_Select3D_SensitiveEntity

        :rtype: OCC.wrapper.Select3D.Handle_Select3D_SensitiveEntity

        """
        return _MeshVS.MeshVS_SensitiveMesh_GetConnected(self, *args)


    def NbSubElements(self, *args):
        """
        NbSubElements(MeshVS_SensitiveMesh self) -> Standard_Integer

        Returns the amount of mesh nodes

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.MeshVS_SensitiveMesh_NbSubElements(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(MeshVS_SensitiveMesh self) -> BVH_Box_Standard_Real_

        Returns bounding box of mesh

        :rtype: OCC.wrapper.Select3D.Select3D_BndBox3d

        """
        return _MeshVS.MeshVS_SensitiveMesh_BoundingBox(self, *args)


    def CenterOfGeometry(self, *args):
        """
        CenterOfGeometry(MeshVS_SensitiveMesh self) -> gp_Pnt

        Returns center of mesh

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _MeshVS.MeshVS_SensitiveMesh_CenterOfGeometry(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MeshVS.MeshVS_SensitiveMesh_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MeshVS.MeshVS_SensitiveMesh_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.MeshVS_SensitiveMesh_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MeshVS.delete_MeshVS_SensitiveMesh
MeshVS_SensitiveMesh_swigregister = _MeshVS.MeshVS_SensitiveMesh_swigregister
MeshVS_SensitiveMesh_swigregister(MeshVS_SensitiveMesh)

def MeshVS_SensitiveMesh_get_type_name(*args):
    """
    MeshVS_SensitiveMesh_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MeshVS.MeshVS_SensitiveMesh_get_type_name(*args)

def MeshVS_SensitiveMesh_get_type_descriptor(*args):
    """
    MeshVS_SensitiveMesh_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MeshVS.MeshVS_SensitiveMesh_get_type_descriptor(*args)

class Handle_MeshVS_MeshOwner(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MeshVS_MeshOwner self)

        Nullify the handle


        """
        return _MeshVS.Handle_MeshVS_MeshOwner_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MeshVS_MeshOwner self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MeshVS_MeshOwner self, MeshVS_MeshOwner thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MeshVS_MeshOwner self, Handle_MeshVS_MeshOwner theHandle) -> Handle_MeshVS_MeshOwner
        assign(Handle_MeshVS_MeshOwner self, MeshVS_MeshOwner thePtr) -> Handle_MeshVS_MeshOwner
        assign(Handle_MeshVS_MeshOwner self, Handle_MeshVS_MeshOwner theHandle) -> Handle_MeshVS_MeshOwner

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MeshVS_MeshOwner self) -> MeshVS_MeshOwner

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MeshVS_MeshOwner self) -> MeshVS_MeshOwner

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_MeshOwner___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MeshVS_MeshOwner self) -> MeshVS_MeshOwner

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MeshVS.Handle_MeshVS_MeshOwner___ref__(self, *args)


    def __hash__(self):
        return _MeshVS.Handle_MeshVS_MeshOwner___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MeshVS.Handle_MeshVS_MeshOwner___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MeshVS.new_Handle_MeshVS_MeshOwner(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MeshVS.Handle_MeshVS_MeshOwner_DownCast)
    __swig_destroy__ = _MeshVS.delete_Handle_MeshVS_MeshOwner

    def GetDataSource(self, *args):
        """
        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource

        """
        res = _MeshVS.Handle_MeshVS_MeshOwner_GetDataSource(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetSelectedNodes(self, *args):
        """
        Returns ids of selected mesh nodes

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        res = _MeshVS.Handle_MeshVS_MeshOwner_GetSelectedNodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetSelectedElements(self, *args):
        """
        Returns ids of selected mesh elements

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        res = _MeshVS.Handle_MeshVS_MeshOwner_GetSelectedElements(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddSelectedEntities(self, *args):
        """
        AddSelectedEntities(Handle_MeshVS_MeshOwner self, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elems)

        Saves ids of selected mesh entities

        :type Nodes: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger
        :type Elems: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_AddSelectedEntities(self, *args)


    def ClearSelectedEntities(self, *args):
        """
        ClearSelectedEntities(Handle_MeshVS_MeshOwner self)

        Clears ids of selected mesh entities


        """
        return _MeshVS.Handle_MeshVS_MeshOwner_ClearSelectedEntities(self, *args)


    def GetDetectedNodes(self, *args):
        """
        Returns ids of hilighted mesh nodes

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        res = _MeshVS.Handle_MeshVS_MeshOwner_GetDetectedNodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetDetectedElements(self, *args):
        """
        Returns ids of hilighted mesh elements

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        res = _MeshVS.Handle_MeshVS_MeshOwner_GetDetectedElements(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDetectedEntities(self, *args):
        """
        SetDetectedEntities(Handle_MeshVS_MeshOwner self, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elems)

        Saves ids of hilighted mesh entities

        :type Nodes: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger
        :type Elems: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_SetDetectedEntities(self, *args)


    def HilightWithColor(self, *args):
        """
        HilightWithColor(Handle_MeshVS_MeshOwner self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theColor, Standard_Integer const theMode=0)

        :type thePM: OCC.wrapper.MeshVS.Handle_PrsMgr_PresentationManager3d
        :type theColor: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theMode: int

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_HilightWithColor(self, *args)


    def Unhilight(self, *args):
        """
        Unhilight(Handle_MeshVS_MeshOwner self, Handle_PrsMgr_PresentationManager PM, Standard_Integer const Mode=0)

        :type PM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type Mode: int

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_Unhilight(self, *args)


    def IsForcedHilight(self, *args):
        """
        IsForcedHilight(Handle_MeshVS_MeshOwner self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_IsForcedHilight(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MeshVS_MeshOwner self) -> char const *

        :rtype: const char *

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_MeshOwner_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_MeshOwner_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelectable(self, *args):
        """
        HasSelectable(Handle_MeshVS_MeshOwner self) -> Standard_Boolean

        Returns true if there is a selectable object to serve as an owner.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_HasSelectable(self, *args)


    def Selectable(self, *args):
        """
        Selectable(Handle_MeshVS_MeshOwner self) -> Handle_SelectMgr_SelectableObject

        Returns a selectable object detected in the working context.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_Selectable(self, *args)


    def SetSelectable(self, *args):
        """
        SetSelectable(Handle_MeshVS_MeshOwner self, Handle_SelectMgr_SelectableObject theSelObj)

        Sets the selectable object.

        :type theSelObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_SetSelectable(self, *args)


    def IsHilighted(self, *args):
        """
        IsHilighted(Handle_MeshVS_MeshOwner self, Handle_PrsMgr_PresentationManager aPM, Standard_Integer const aMode=0) -> Standard_Boolean

        Returns true if the presentation manager aPM
        highlights selections corresponding to the selection mode aMode.

        :type aPM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type aMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_IsHilighted(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_MeshVS_MeshOwner self, Handle_PrsMgr_PresentationManager aPM, Standard_Integer const aMode=0)

        Clears the owners matching the value of the selection
        mode aMode from the presentation manager object aPM.

        :type aPM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type aMode: int

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_Clear(self, *args)


    def HasLocation(self, *args):
        """
        HasLocation(Handle_MeshVS_MeshOwner self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_HasLocation(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_MeshVS_MeshOwner self, TopLoc_Location aLoc)

        :type aLoc: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_SetLocation(self, *args)


    def ResetLocation(self, *args):
        """ResetLocation(Handle_MeshVS_MeshOwner self)"""
        return _MeshVS.Handle_MeshVS_MeshOwner_ResetLocation(self, *args)


    def Location(self, *args):
        """
        Location(Handle_MeshVS_MeshOwner self) -> TopLoc_Location

        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_Location(self, *args)


    def SetSelected(self, *args):
        """
        SetSelected(Handle_MeshVS_MeshOwner self, Standard_Boolean const theIsSelected)

        Set the state of the owner.
        @param theIsSelected [in] shows if owner is selected.

        :type theIsSelected: bool

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_SetSelected(self, *args)


    def IsSelected(self, *args):
        """
        IsSelected(Handle_MeshVS_MeshOwner self) -> Standard_Boolean

        @return Standard_True if the owner is selected.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_IsSelected(self, *args)


    def State(self, *args):
        """
        State(Handle_MeshVS_MeshOwner self, Standard_Integer const theStatus)
        State(Handle_MeshVS_MeshOwner self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_State(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_MeshVS_MeshOwner self) -> Standard_Boolean

        if owner is not auto hilighted, for group contains many such owners
        will be called one method HilightSelected of SelectableObject

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_IsAutoHilight(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_MeshVS_MeshOwner self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_SetZLayer(self, *args)


    def UpdateHighlightTrsf(self, *args):
        """
        UpdateHighlightTrsf(Handle_MeshVS_MeshOwner self, Handle_V3d_Viewer theViewer, Handle_PrsMgr_PresentationManager theManager, Standard_Integer const theDispMode)

        Implements immediate application of location transformation of parent object to dynamic highlight structure

        :type theViewer: OCC.wrapper.V3d.Handle_V3d_Viewer
        :type theManager: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theDispMode: int

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_UpdateHighlightTrsf(self, *args)


    def IsSameSelectable(self, *args):
        """
        IsSameSelectable(Handle_MeshVS_MeshOwner self, Handle_SelectMgr_SelectableObject theOther) -> Standard_Boolean

        Returns true if pointer to selectable object of this owner is equal to the given one

        :type theOther: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_IsSameSelectable(self, *args)


    def ComesFromDecomposition(self, *args):
        """
        ComesFromDecomposition(Handle_MeshVS_MeshOwner self) -> Standard_Boolean

        Returns TRUE if this owner points to a part of object and FALSE for entire object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_ComesFromDecomposition(self, *args)


    def SetComesFromDecomposition(self, *args):
        """
        SetComesFromDecomposition(Handle_MeshVS_MeshOwner self, Standard_Boolean const theIsFromDecomposition)

        Sets flag indicating this owner points to a part of object (TRUE) or to entire object (FALSE).

        :type theIsFromDecomposition: bool

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_SetComesFromDecomposition(self, *args)


    def Set(self, *args):
        """
        Set(Handle_MeshVS_MeshOwner self, Handle_SelectMgr_SelectableObject theSelObj)

        Sets the selectable object.

        :type theSelObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_Set(self, *args)


    def SetPriority(self, *args):
        """
        SetPriority(Handle_MeshVS_MeshOwner self, Standard_Integer const thePriority)

        sets the selectable priority of the owner

        :type thePriority: int

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_SetPriority(self, *args)


    def Priority(self, *args):
        """
        Priority(Handle_MeshVS_MeshOwner self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_Priority(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_MeshVS_MeshOwner self)

        Memory deallocator for transient classes


        """
        return _MeshVS.Handle_MeshVS_MeshOwner_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MeshVS_MeshOwner self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MeshVS_MeshOwner self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MeshVS_MeshOwner self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MeshVS_MeshOwner self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MeshVS_MeshOwner self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MeshVS_MeshOwner self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MeshVS_MeshOwner self)

        Increments the reference counter of this object


        """
        return _MeshVS.Handle_MeshVS_MeshOwner_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MeshVS_MeshOwner self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_MeshOwner_DecrementRefCounter(self, *args)

Handle_MeshVS_MeshOwner_swigregister = _MeshVS.Handle_MeshVS_MeshOwner_swigregister
Handle_MeshVS_MeshOwner_swigregister(Handle_MeshVS_MeshOwner)

def Handle_MeshVS_MeshOwner_DownCast(thing):
    return _MeshVS.Handle_MeshVS_MeshOwner_DownCast(thing)
Handle_MeshVS_MeshOwner_DownCast = _MeshVS.Handle_MeshVS_MeshOwner_DownCast

class MeshVS_ElementalColorPrsBuilder(MeshVS_PrsBuilder):
    """
    This class provides methods to create presentation of elements with
    assigned colors. The class contains two color maps: map of same colors for front
    and back side of face and map of different ones,
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MeshVS_ElementalColorPrsBuilder
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MeshVS_ElementalColorPrsBuilder(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MeshVS_ElementalColorPrsBuilder self, Handle_MeshVS_Mesh Parent, MeshVS_DisplayModeFlags const & Flags=MeshVS_DMF_ElementalColorDataPrs, Handle_MeshVS_DataSource DS=0, Standard_Integer const Id=-1, MeshVS_BuilderPriority const & Priority=MeshVS_BP_ElemColor) -> MeshVS_ElementalColorPrsBuilder

        Constructor

        :type Parent: OCC.wrapper.MeshVS.Handle_MeshVS_Mesh
        :type Flags: OCC.wrapper.MeshVS.MeshVS_DisplayModeFlags
        :type DS: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource
        :type Id: int
        :type Priority: OCC.wrapper.MeshVS.MeshVS_BuilderPriority

        """
        this = _MeshVS.new_MeshVS_ElementalColorPrsBuilder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Build(self, *args):
        """
        Build(MeshVS_ElementalColorPrsBuilder self, Handle_Prs3d_Presentation Prs, TColStd_PackedMapOfInteger IDs, TColStd_PackedMapOfInteger IDsToExclude, Standard_Boolean const IsElement, Standard_Integer const DisplayMode)

        Builds presentation of elements with assigned colors.

        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type IDs: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IDsToExclude: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IsElement: bool
        :type DisplayMode: int

        """
        return _MeshVS.MeshVS_ElementalColorPrsBuilder_Build(self, *args)


    def GetColors1(self, *args):
        """
        Returns map of colors same for front and back side of face.

        :rtype: OCC.wrapper.MeshVS.MeshVS_DataMapOfIntegerColor

        """
        res = _MeshVS.MeshVS_ElementalColorPrsBuilder_GetColors1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColors1(self, *args):
        """
        SetColors1(MeshVS_ElementalColorPrsBuilder self, NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher Map)

        Sets map of colors same for front and back side of face.

        :type Map: OCC.wrapper.MeshVS.MeshVS_DataMapOfIntegerColor

        """
        return _MeshVS.MeshVS_ElementalColorPrsBuilder_SetColors1(self, *args)


    def HasColors1(self, *args):
        """
        HasColors1(MeshVS_ElementalColorPrsBuilder self) -> Standard_Boolean

        Returns true, if map of colors isn't empty

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_ElementalColorPrsBuilder_HasColors1(self, *args)


    def GetColor1(self, *args):
        """
        GetColor1(MeshVS_ElementalColorPrsBuilder self, Standard_Integer const ID, Quantity_Color theColor) -> Standard_Boolean

        Returns color assigned with element number ID

        :type ID: int
        :type theColor: OCC.wrapper.Quantity.Quantity_Color
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_ElementalColorPrsBuilder_GetColor1(self, *args)


    def SetColor1(self, *args):
        """
        SetColor1(MeshVS_ElementalColorPrsBuilder self, Standard_Integer const ID, Quantity_Color theColor)

        Sets color assigned with element number ID

        :type ID: int
        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _MeshVS.MeshVS_ElementalColorPrsBuilder_SetColor1(self, *args)


    def GetColors2(self, *args):
        """
        Returns map of different colors for front and back side of face

        :rtype: OCC.wrapper.MeshVS.MeshVS_DataMapOfIntegerTwoColors

        """
        res = _MeshVS.MeshVS_ElementalColorPrsBuilder_GetColors2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColors2(self, *args):
        """
        SetColors2(MeshVS_ElementalColorPrsBuilder self, MeshVS_DataMapOfIntegerTwoColors const & Map)

        Sets map of different colors for front and back side of face

        :type Map: OCC.wrapper.MeshVS.MeshVS_DataMapOfIntegerTwoColors

        """
        return _MeshVS.MeshVS_ElementalColorPrsBuilder_SetColors2(self, *args)


    def HasColors2(self, *args):
        """
        HasColors2(MeshVS_ElementalColorPrsBuilder self) -> Standard_Boolean

        Returns true, if map isn't empty

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_ElementalColorPrsBuilder_HasColors2(self, *args)


    def GetColor2(self, *args):
        """
        GetColor2(MeshVS_ElementalColorPrsBuilder self, Standard_Integer const ID, MeshVS_TwoColors & theColor) -> Standard_Boolean
        GetColor2(MeshVS_ElementalColorPrsBuilder self, Standard_Integer const ID, Quantity_Color theColor1, Quantity_Color theColor2) -> Standard_Boolean

        Returns colors assigned with element number ID
        theColor1 is the front element color
        theColor2 is the back element color

        :type ID: int
        :type theColor1: OCC.wrapper.Quantity.Quantity_Color
        :type theColor2: OCC.wrapper.Quantity.Quantity_Color
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_ElementalColorPrsBuilder_GetColor2(self, *args)


    def SetColor2(self, *args):
        """
        SetColor2(MeshVS_ElementalColorPrsBuilder self, Standard_Integer const ID, MeshVS_TwoColors const & theTwoColors)
        SetColor2(MeshVS_ElementalColorPrsBuilder self, Standard_Integer const ID, Quantity_Color theColor1, Quantity_Color theColor2)

        Sets color assigned with element number ID
        theColor1 is the front element color
        theColor2 is the back element color

        :type ID: int
        :type theColor1: OCC.wrapper.Quantity.Quantity_Color
        :type theColor2: OCC.wrapper.Quantity.Quantity_Color

        """
        return _MeshVS.MeshVS_ElementalColorPrsBuilder_SetColor2(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MeshVS.MeshVS_ElementalColorPrsBuilder_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MeshVS.MeshVS_ElementalColorPrsBuilder_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.MeshVS_ElementalColorPrsBuilder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MeshVS.delete_MeshVS_ElementalColorPrsBuilder
MeshVS_ElementalColorPrsBuilder_swigregister = _MeshVS.MeshVS_ElementalColorPrsBuilder_swigregister
MeshVS_ElementalColorPrsBuilder_swigregister(MeshVS_ElementalColorPrsBuilder)

def MeshVS_ElementalColorPrsBuilder_get_type_name(*args):
    """
    MeshVS_ElementalColorPrsBuilder_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MeshVS.MeshVS_ElementalColorPrsBuilder_get_type_name(*args)

def MeshVS_ElementalColorPrsBuilder_get_type_descriptor(*args):
    """
    MeshVS_ElementalColorPrsBuilder_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MeshVS.MeshVS_ElementalColorPrsBuilder_get_type_descriptor(*args)

class NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Graphic3d_MaterialAspect,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Graphic3d_MaterialAspect,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Graphic3d_MaterialAspect,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Graphic3d_MaterialAspect,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _MeshVS.new_NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher self, int const & theKey, Graphic3d_MaterialAspect theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher self, int const & theKey, Graphic3d_MaterialAspect theItem) -> Graphic3d_MaterialAspect

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher self, int const & theKey) -> Graphic3d_MaterialAspect

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher self, int const & theKey) -> Graphic3d_MaterialAspect

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher self, int const & theKey) -> Graphic3d_MaterialAspect

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _MeshVS.NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _MeshVS.delete_NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_swigregister = _MeshVS.NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _MeshVS.new_NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MeshVS.delete_NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _MeshVS.NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _MeshVS.NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher_IteratorHelper)


try:
	MeshVS_DataMapOfIntegerMaterial = NCollection_DataMap_Standard_Integer_Graphic3d_MaterialAspect_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_MeshVS_Drawer(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MeshVS_Drawer self)

        Nullify the handle


        """
        return _MeshVS.Handle_MeshVS_Drawer_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MeshVS_Drawer self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MeshVS.Handle_MeshVS_Drawer_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MeshVS_Drawer self, MeshVS_Drawer thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MeshVS.Handle_MeshVS_Drawer_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MeshVS_Drawer self, Handle_MeshVS_Drawer theHandle) -> Handle_MeshVS_Drawer
        assign(Handle_MeshVS_Drawer self, MeshVS_Drawer thePtr) -> Handle_MeshVS_Drawer
        assign(Handle_MeshVS_Drawer self, Handle_MeshVS_Drawer theHandle) -> Handle_MeshVS_Drawer

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MeshVS.Handle_MeshVS_Drawer_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MeshVS_Drawer self) -> MeshVS_Drawer

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_Drawer_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MeshVS_Drawer self) -> MeshVS_Drawer

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_Drawer___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MeshVS_Drawer self) -> MeshVS_Drawer

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MeshVS.Handle_MeshVS_Drawer___ref__(self, *args)


    def __hash__(self):
        return _MeshVS.Handle_MeshVS_Drawer___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MeshVS.Handle_MeshVS_Drawer___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MeshVS.new_Handle_MeshVS_Drawer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MeshVS.Handle_MeshVS_Drawer_DownCast)
    __swig_destroy__ = _MeshVS.delete_Handle_MeshVS_Drawer

    def Assign(self, *args):
        """
        Assign(Handle_MeshVS_Drawer self, Handle_MeshVS_Drawer aDrawer)

        This method copies other drawer contents to this.

        :type aDrawer: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer

        """
        return _MeshVS.Handle_MeshVS_Drawer_Assign(self, *args)


    def SetInteger(self, *args):
        """
        SetInteger(Handle_MeshVS_Drawer self, Standard_Integer const Key, Standard_Integer const Value)

        :type Key: int
        :type Value: int

        """
        return _MeshVS.Handle_MeshVS_Drawer_SetInteger(self, *args)


    def SetDouble(self, *args):
        """
        SetDouble(Handle_MeshVS_Drawer self, Standard_Integer const Key, Standard_Real const Value)

        :type Key: int
        :type Value: float

        """
        return _MeshVS.Handle_MeshVS_Drawer_SetDouble(self, *args)


    def SetBoolean(self, *args):
        """
        SetBoolean(Handle_MeshVS_Drawer self, Standard_Integer const Key, Standard_Boolean const Value)

        :type Key: int
        :type Value: bool

        """
        return _MeshVS.Handle_MeshVS_Drawer_SetBoolean(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_MeshVS_Drawer self, Standard_Integer const Key, Quantity_Color Value)

        :type Key: int
        :type Value: OCC.wrapper.Quantity.Quantity_Color

        """
        return _MeshVS.Handle_MeshVS_Drawer_SetColor(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_MeshVS_Drawer self, Standard_Integer const Key, Graphic3d_MaterialAspect Value)

        :type Key: int
        :type Value: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _MeshVS.Handle_MeshVS_Drawer_SetMaterial(self, *args)


    def SetAsciiString(self, *args):
        """
        SetAsciiString(Handle_MeshVS_Drawer self, Standard_Integer const Key, TCollection_AsciiString Value)

        :type Key: int
        :type Value: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _MeshVS.Handle_MeshVS_Drawer_SetAsciiString(self, *args)


    def GetInteger(self, *args):
        """
        GetInteger(Handle_MeshVS_Drawer self, Standard_Integer const Key) -> Standard_Boolean

        :type Key: int
        :type Value: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Drawer_GetInteger(self, *args)


    def GetDouble(self, *args):
        """
        GetDouble(Handle_MeshVS_Drawer self, Standard_Integer const Key) -> Standard_Boolean

        :type Key: int
        :type Value: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Drawer_GetDouble(self, *args)


    def GetBoolean(self, *args):
        """
        GetBoolean(Handle_MeshVS_Drawer self, Standard_Integer const Key) -> Standard_Boolean

        :type Key: int
        :type Value: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Drawer_GetBoolean(self, *args)


    def GetColor(self, *args):
        """
        GetColor(Handle_MeshVS_Drawer self, Standard_Integer const Key, Quantity_Color Value) -> Standard_Boolean

        :type Key: int
        :type Value: OCC.wrapper.Quantity.Quantity_Color
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Drawer_GetColor(self, *args)


    def GetMaterial(self, *args):
        """
        GetMaterial(Handle_MeshVS_Drawer self, Standard_Integer const Key, Graphic3d_MaterialAspect Value) -> Standard_Boolean

        :type Key: int
        :type Value: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Drawer_GetMaterial(self, *args)


    def GetAsciiString(self, *args):
        """
        GetAsciiString(Handle_MeshVS_Drawer self, Standard_Integer const Key, TCollection_AsciiString Value) -> Standard_Boolean

        :type Key: int
        :type Value: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Drawer_GetAsciiString(self, *args)


    def RemoveInteger(self, *args):
        """
        RemoveInteger(Handle_MeshVS_Drawer self, Standard_Integer const Key) -> Standard_Boolean

        :type Key: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Drawer_RemoveInteger(self, *args)


    def RemoveDouble(self, *args):
        """
        RemoveDouble(Handle_MeshVS_Drawer self, Standard_Integer const Key) -> Standard_Boolean

        :type Key: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Drawer_RemoveDouble(self, *args)


    def RemoveBoolean(self, *args):
        """
        RemoveBoolean(Handle_MeshVS_Drawer self, Standard_Integer const Key) -> Standard_Boolean

        :type Key: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Drawer_RemoveBoolean(self, *args)


    def RemoveColor(self, *args):
        """
        RemoveColor(Handle_MeshVS_Drawer self, Standard_Integer const Key) -> Standard_Boolean

        :type Key: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Drawer_RemoveColor(self, *args)


    def RemoveMaterial(self, *args):
        """
        RemoveMaterial(Handle_MeshVS_Drawer self, Standard_Integer const Key) -> Standard_Boolean

        :type Key: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Drawer_RemoveMaterial(self, *args)


    def RemoveAsciiString(self, *args):
        """
        RemoveAsciiString(Handle_MeshVS_Drawer self, Standard_Integer const Key) -> Standard_Boolean

        :type Key: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Drawer_RemoveAsciiString(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MeshVS_Drawer self) -> char const *

        :rtype: const char *

        """
        return _MeshVS.Handle_MeshVS_Drawer_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_Drawer_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_Drawer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_MeshVS_Drawer self)

        Memory deallocator for transient classes


        """
        return _MeshVS.Handle_MeshVS_Drawer_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MeshVS_Drawer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MeshVS_Drawer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Drawer_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MeshVS_Drawer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MeshVS_Drawer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Drawer_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MeshVS_Drawer self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MeshVS.Handle_MeshVS_Drawer_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MeshVS_Drawer self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_Drawer_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MeshVS_Drawer self)

        Increments the reference counter of this object


        """
        return _MeshVS.Handle_MeshVS_Drawer_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MeshVS_Drawer self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_Drawer_DecrementRefCounter(self, *args)

Handle_MeshVS_Drawer_swigregister = _MeshVS.Handle_MeshVS_Drawer_swigregister
Handle_MeshVS_Drawer_swigregister(Handle_MeshVS_Drawer)

def Handle_MeshVS_Drawer_DownCast(thing):
    return _MeshVS.Handle_MeshVS_Drawer_DownCast(thing)
Handle_MeshVS_Drawer_DownCast = _MeshVS.Handle_MeshVS_Drawer_DownCast

class NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Quantity_Color,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Quantity_Color,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Quantity_Color,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Quantity_Color,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _MeshVS.new_NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher self, int const & theKey, Quantity_Color theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher self, int const & theKey, Quantity_Color theItem) -> Quantity_Color

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher self, int const & theKey) -> Quantity_Color

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher self, int const & theKey) -> Quantity_Color

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher self, int const & theKey) -> Quantity_Color

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _MeshVS.NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _MeshVS.delete_NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_swigregister = _MeshVS.NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _MeshVS.new_NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MeshVS.delete_NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _MeshVS.NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _MeshVS.NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher_IteratorHelper)


try:
	MeshVS_DataMapOfIntegerColor = NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_MeshVS_DataSource(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MeshVS_DataSource self)

        Nullify the handle


        """
        return _MeshVS.Handle_MeshVS_DataSource_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MeshVS_DataSource self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MeshVS.Handle_MeshVS_DataSource_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MeshVS_DataSource self, MeshVS_DataSource thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MeshVS.Handle_MeshVS_DataSource_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MeshVS_DataSource self, Handle_MeshVS_DataSource theHandle) -> Handle_MeshVS_DataSource
        assign(Handle_MeshVS_DataSource self, MeshVS_DataSource thePtr) -> Handle_MeshVS_DataSource
        assign(Handle_MeshVS_DataSource self, Handle_MeshVS_DataSource theHandle) -> Handle_MeshVS_DataSource

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MeshVS.Handle_MeshVS_DataSource_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MeshVS_DataSource self) -> MeshVS_DataSource

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_DataSource_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MeshVS_DataSource self) -> MeshVS_DataSource

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_DataSource___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MeshVS_DataSource self) -> MeshVS_DataSource

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MeshVS.Handle_MeshVS_DataSource___ref__(self, *args)


    def __hash__(self):
        return _MeshVS.Handle_MeshVS_DataSource___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MeshVS.Handle_MeshVS_DataSource___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MeshVS.new_Handle_MeshVS_DataSource(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MeshVS.Handle_MeshVS_DataSource_DownCast)
    __swig_destroy__ = _MeshVS.delete_Handle_MeshVS_DataSource

    def GetGeom(self, *args):
        """
        GetGeom(Handle_MeshVS_DataSource self, Standard_Integer const ID, Standard_Boolean const IsElement, NCollection_Array1_Standard_Real Coords) -> Standard_Boolean

        Returns geometry information about node or element
        ID is the numerical identificator of node or element
        IsElement indicates this ID describe node ( if Standard_False ) or element ( if Standard_True )
        Coords is an array of co-ordinates of node(s).
        For node it is only 3 numbers: X, Y, Z in the strict order
        For element it is 3*n numbers, where n is number of this element vertices
        The order is strict also: X1, Y1, Z1, X2,...., where Xi, Yi, Zi are co-ordinates of vertices
        NbNodes is number of nodes. It is recommended this parameter to be set to 1 for node.
        Type is type of node or element (from enumeration). It is recommended this parameter to be set to
        MeshVS_ET_Node for node.

        :type ID: int
        :type IsElement: bool
        :type Coords: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NbNodes: int
        :type Type: OCC.wrapper.MeshVS.MeshVS_EntityType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DataSource_GetGeom(self, *args)


    def GetGeomType(self, *args):
        """
        GetGeomType(Handle_MeshVS_DataSource self, Standard_Integer const ID, Standard_Boolean const IsElement) -> Standard_Boolean

        This method is similar to GetGeom, but returns only element or node type.

        :type ID: int
        :type IsElement: bool
        :type Type: OCC.wrapper.MeshVS.MeshVS_EntityType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DataSource_GetGeomType(self, *args)


    def Get3DGeom(self, *args):
        """
        Get3DGeom(Handle_MeshVS_DataSource self, Standard_Integer const ID, Handle_MeshVS_HArray1OfSequenceOfInteger Data) -> Standard_Boolean

        This method returns topology information about 3D-element
        Returns false if element with ID isn't 3D or because other troubles

        :type ID: int
        :type NbNodes: int
        :type Data: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DataSource_Get3DGeom(self, *args)


    def GetAddr(self, *args):
        """
        GetAddr(Handle_MeshVS_DataSource self, Standard_Integer const ID, Standard_Boolean const IsElement) -> Standard_Address

        This method returns pointer which represents element or node data structure.
        This address will be saved in MeshVS_MeshEntityOwner, so that you can access to data structure fast
        by the method Owner(). In the redefined method you can return NULL.
        ID is the numerical identificator of node or element
        IsElement indicates this ID describe node ( if Standard_False ) or element ( if Standard_True )

        :type ID: int
        :type IsElement: bool
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _MeshVS.Handle_MeshVS_DataSource_GetAddr(self, *args)


    def GetNodesByElement(self, *args):
        """
        GetNodesByElement(Handle_MeshVS_DataSource self, Standard_Integer const ID, NCollection_Array1_Standard_Integer NodeIDs) -> Standard_Boolean

        This method returns information about nodes this element consist of.
        ID is the numerical identificator of element.
        NodeIDs is the output array of nodes IDs in correct order,
        the same as coordinates returned by GetGeom().
        NbNodes is number of nodes (number of items set in NodeIDs).
        Returns False if element does not exist

        :type ID: int
        :type NodeIDs: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type NbNodes: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DataSource_GetNodesByElement(self, *args)


    def GetAllNodes(self, *args):
        """
        This method returns map of all nodes the object consist of.

        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        res = _MeshVS.Handle_MeshVS_DataSource_GetAllNodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetAllElements(self, *args):
        """
        This method returns map of all elements the object consist of.

        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        res = _MeshVS.Handle_MeshVS_DataSource_GetAllElements(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetNormal(self, *args):
        """
        GetNormal(Handle_MeshVS_DataSource self, Standard_Integer const Id, Standard_Integer const Max) -> Standard_Boolean

        This method calculates normal of face, which is using for correct reflection presentation.
        There is default method, for advance reflection this method can be redefined.
        Id is the numerical identificator of only element!
        Max is maximal number of nodes an element can consist of
        nx, ny, nz  are values whose represent co-ordinates of normal (will be returned)
        In the redefined method you can return normal with length more then 1, but in this case
        the appearance of element will be more bright than usual. For ordinary brightness you must return
        normal with length 1

        :type Id: int
        :type Max: int
        :type nx: float
        :type ny: float
        :type nz: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DataSource_GetNormal(self, *args)


    def GetNodeNormal(self, *args):
        """
        GetNodeNormal(Handle_MeshVS_DataSource self, Standard_Integer const ranknode, Standard_Integer const ElementId) -> Standard_Boolean

        This method return normal of node ranknode of face Id,
        which is using for smooth shading presentation.
        Returns false if normal isn't defined.

        :type ranknode: int
        :type ElementId: int
        :type nx: float
        :type ny: float
        :type nz: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DataSource_GetNodeNormal(self, *args)


    def GetNormalsByElement(self, *args):
        """
        GetNormalsByElement(Handle_MeshVS_DataSource self, Standard_Integer const Id, Standard_Boolean const IsNodal, Standard_Integer const MaxNodes, Handle_TColStd_HArray1OfReal Normals) -> Standard_Boolean

        This method puts components of normal vectors at each node of a mesh face (at each face of a mesh volume)
        into the output array.
        Returns false if some problem was detected during calculation of normals.
        Id is an identifier of the mesh element.
        IsNodal, when true, means that normals at mesh element nodes are needed. If nodal normals
        are not available, or IsNodal is false, or the mesh element is a volume, then the output array contents
        depend on the element type:
        face: a normal calculated by GetNormal() is duplicated for each node of the face;
        volume: normals to all faces of the volume are computed (not for each node!).
        MaxNodes is maximal number of nodes an element can consist of.
        Normals contains the result.

        :type Id: int
        :type IsNodal: bool
        :type MaxNodes: int
        :type Normals: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DataSource_GetNormalsByElement(self, *args)


    def GetAllGroups(self, *args):
        """
        GetAllGroups(Handle_MeshVS_DataSource self, TColStd_PackedMapOfInteger Ids)

        This method returns map of all groups the object contains.

        :type Ids: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        return _MeshVS.Handle_MeshVS_DataSource_GetAllGroups(self, *args)


    def GetGroup(self, *args):
        """
        GetGroup(Handle_MeshVS_DataSource self, Standard_Integer const Id, TColStd_PackedMapOfInteger Ids) -> Standard_Boolean

        This method returns map of all group elements.

        :type Id: int
        :type Type: OCC.wrapper.MeshVS.MeshVS_EntityType
        :type Ids: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DataSource_GetGroup(self, *args)


    def GetGroupAddr(self, *args):
        """
        GetGroupAddr(Handle_MeshVS_DataSource self, Standard_Integer const ID) -> Standard_Address

        This method returns pointer which represents group data structure.
        This address will be saved in MeshVS_MeshOwner, so that you can access to data structure fast
        by the method Owner(). In the redefined method you can return NULL.
        ID is the numerical identificator of group

        :type ID: int
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _MeshVS.Handle_MeshVS_DataSource_GetGroupAddr(self, *args)


    def IsAdvancedSelectionEnabled(self, *args):
        """
        IsAdvancedSelectionEnabled(Handle_MeshVS_DataSource self) -> Standard_Boolean

        Returns True if advanced mesh selection is enabled.
        Default implementation returns False.
        It should be redefined to return True for advanced
        mesh selection activation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DataSource_IsAdvancedSelectionEnabled(self, *args)


    def GetBoundingBox(self, *args):
        """
        GetBoundingBox(Handle_MeshVS_DataSource self) -> Bnd_Box

        Returns the bounding box of the whole mesh.
        It is used in advanced selection mode to define roughly
        the sensitive area of the mesh.
        It can be redefined to get access to a box computed in advance.

        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _MeshVS.Handle_MeshVS_DataSource_GetBoundingBox(self, *args)


    def GetDetectedEntities(self, *args):
        """
        GetDetectedEntities(Handle_MeshVS_DataSource self, Handle_MeshVS_Mesh Prs, Standard_Real const X, Standard_Real const Y, Standard_Real const aTol, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elements) -> Standard_Boolean
        GetDetectedEntities(Handle_MeshVS_DataSource self, Handle_MeshVS_Mesh Prs, Standard_Real const XMin, Standard_Real const YMin, Standard_Real const XMax, Standard_Real const YMax, Standard_Real const aTol, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elements) -> Standard_Boolean
        GetDetectedEntities(Handle_MeshVS_DataSource self, Handle_MeshVS_Mesh Prs, NCollection_Array1_gp_Pnt2d Polyline, Bnd_Box2d aBox, Standard_Real const aTol, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elements) -> Standard_Boolean
        GetDetectedEntities(Handle_MeshVS_DataSource self, Handle_MeshVS_Mesh Prs, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elements) -> Standard_Boolean

        Filter out the maps of mesh entities so as to keep
        only the entities that are allowed to be selected
        according to the current context.
        Returns True if any of the maps has been changed.
        It should be redefined if the advanced mesh selection is
        activated. Default implementation returns False.

        :type Prs: OCC.wrapper.MeshVS.Handle_MeshVS_Mesh
        :type Nodes: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger
        :type Elements: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DataSource_GetDetectedEntities(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MeshVS_DataSource self) -> char const *

        :rtype: const char *

        """
        return _MeshVS.Handle_MeshVS_DataSource_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_DataSource_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_DataSource_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_MeshVS_DataSource self)

        Memory deallocator for transient classes


        """
        return _MeshVS.Handle_MeshVS_DataSource_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MeshVS_DataSource self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MeshVS_DataSource self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DataSource_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MeshVS_DataSource self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MeshVS_DataSource self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DataSource_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MeshVS_DataSource self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MeshVS.Handle_MeshVS_DataSource_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MeshVS_DataSource self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_DataSource_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MeshVS_DataSource self)

        Increments the reference counter of this object


        """
        return _MeshVS.Handle_MeshVS_DataSource_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MeshVS_DataSource self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_DataSource_DecrementRefCounter(self, *args)

Handle_MeshVS_DataSource_swigregister = _MeshVS.Handle_MeshVS_DataSource_swigregister
Handle_MeshVS_DataSource_swigregister(Handle_MeshVS_DataSource)

def Handle_MeshVS_DataSource_DownCast(thing):
    return _MeshVS.Handle_MeshVS_DataSource_DownCast(thing)
Handle_MeshVS_DataSource_DownCast = _MeshVS.Handle_MeshVS_DataSource_DownCast

class MeshVS_SensitiveQuad(Select3D.Select3D_SensitiveEntity):
    """
    This class contains description of planar quadrangle and defines methods
    for its detection by OCCT BVH selection mechanism
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MeshVS_SensitiveQuad
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MeshVS_SensitiveQuad(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MeshVS_SensitiveQuad self, Handle_SelectMgr_EntityOwner theOwner, NCollection_Array1_gp_Pnt theQuadVerts) -> MeshVS_SensitiveQuad
        __init__(MeshVS_SensitiveQuad self, Handle_SelectMgr_EntityOwner theOwner, gp_Pnt thePnt1, gp_Pnt thePnt2, gp_Pnt thePnt3, gp_Pnt thePnt4) -> MeshVS_SensitiveQuad

        Creates a new instance and initializes quadrangle vertices with the given points

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type thePnt1: OCC.wrapper.gp.gp_Pnt
        :type thePnt2: OCC.wrapper.gp.gp_Pnt
        :type thePnt3: OCC.wrapper.gp.gp_Pnt
        :type thePnt4: OCC.wrapper.gp.gp_Pnt

        """
        this = _MeshVS.new_MeshVS_SensitiveQuad(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NbSubElements(self, *args):
        """
        NbSubElements(MeshVS_SensitiveQuad self) -> Standard_Integer

        Returns the amount of sub-entities in sensitive

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.MeshVS_SensitiveQuad_NbSubElements(self, *args)


    def GetConnected(self, *args):
        """
        GetConnected(MeshVS_SensitiveQuad self) -> Handle_Select3D_SensitiveEntity

        Returns a copy of this sensitive quadrangle

        :rtype: OCC.wrapper.Select3D.Handle_Select3D_SensitiveEntity

        """
        return _MeshVS.MeshVS_SensitiveQuad_GetConnected(self, *args)


    def Matches(self, *args):
        """
        Matches(MeshVS_SensitiveQuad self, SelectBasics_SelectingVolumeManager theMgr, SelectBasics_PickResult & thePickResult) -> Standard_Boolean

        Checks whether the box overlaps current selecting volume

        :type theMgr: OCC.wrapper.SelectBasics.SelectBasics_SelectingVolumeManager
        :type thePickResult: OCC.wrapper.SelectBasics.SelectBasics_PickResult
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_SensitiveQuad_Matches(self, *args)


    def CenterOfGeometry(self, *args):
        """
        CenterOfGeometry(MeshVS_SensitiveQuad self) -> gp_Pnt

        Returns center of the box

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _MeshVS.MeshVS_SensitiveQuad_CenterOfGeometry(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(MeshVS_SensitiveQuad self) -> BVH_Box_Standard_Real_

        Returns coordinates of the box

        :rtype: OCC.wrapper.Select3D.Select3D_BndBox3d

        """
        return _MeshVS.MeshVS_SensitiveQuad_BoundingBox(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MeshVS.MeshVS_SensitiveQuad_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MeshVS.MeshVS_SensitiveQuad_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.MeshVS_SensitiveQuad_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MeshVS.delete_MeshVS_SensitiveQuad
MeshVS_SensitiveQuad_swigregister = _MeshVS.MeshVS_SensitiveQuad_swigregister
MeshVS_SensitiveQuad_swigregister(MeshVS_SensitiveQuad)

def MeshVS_SensitiveQuad_get_type_name(*args):
    """
    MeshVS_SensitiveQuad_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MeshVS.MeshVS_SensitiveQuad_get_type_name(*args)

def MeshVS_SensitiveQuad_get_type_descriptor(*args):
    """
    MeshVS_SensitiveQuad_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MeshVS.MeshVS_SensitiveQuad_get_type_descriptor(*args)

class Handle_MeshVS_NodalColorPrsBuilder(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MeshVS_NodalColorPrsBuilder self)

        Nullify the handle


        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MeshVS_NodalColorPrsBuilder self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MeshVS_NodalColorPrsBuilder self, MeshVS_NodalColorPrsBuilder thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MeshVS_NodalColorPrsBuilder self, Handle_MeshVS_NodalColorPrsBuilder theHandle) -> Handle_MeshVS_NodalColorPrsBuilder
        assign(Handle_MeshVS_NodalColorPrsBuilder self, MeshVS_NodalColorPrsBuilder thePtr) -> Handle_MeshVS_NodalColorPrsBuilder
        assign(Handle_MeshVS_NodalColorPrsBuilder self, Handle_MeshVS_NodalColorPrsBuilder theHandle) -> Handle_MeshVS_NodalColorPrsBuilder

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MeshVS_NodalColorPrsBuilder self) -> MeshVS_NodalColorPrsBuilder

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MeshVS_NodalColorPrsBuilder self) -> MeshVS_NodalColorPrsBuilder

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MeshVS_NodalColorPrsBuilder self) -> MeshVS_NodalColorPrsBuilder

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder___ref__(self, *args)


    def __hash__(self):
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MeshVS.new_Handle_MeshVS_NodalColorPrsBuilder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MeshVS.Handle_MeshVS_NodalColorPrsBuilder_DownCast)
    __swig_destroy__ = _MeshVS.delete_Handle_MeshVS_NodalColorPrsBuilder

    def Build(self, *args):
        """
        Build(Handle_MeshVS_NodalColorPrsBuilder self, Handle_Prs3d_Presentation Prs, TColStd_PackedMapOfInteger IDs, TColStd_PackedMapOfInteger IDsToExclude, Standard_Boolean const IsElement, Standard_Integer const DisplayMode)

        Builds presentation of nodes with assigned color.

        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type IDs: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IDsToExclude: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IsElement: bool
        :type DisplayMode: int

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_Build(self, *args)


    def GetColors(self, *args):
        """
        Returns map of colors assigned to nodes.

        :rtype: OCC.wrapper.MeshVS.MeshVS_DataMapOfIntegerColor

        """
        res = _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_GetColors(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColors(self, *args):
        """
        SetColors(Handle_MeshVS_NodalColorPrsBuilder self, NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher Map)

        Sets map of colors assigned to nodes.

        :type Map: OCC.wrapper.MeshVS.MeshVS_DataMapOfIntegerColor

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_SetColors(self, *args)


    def HasColors(self, *args):
        """
        HasColors(Handle_MeshVS_NodalColorPrsBuilder self) -> Standard_Boolean

        Returns true, if map isn't empty

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_HasColors(self, *args)


    def GetColor(self, *args):
        """
        GetColor(Handle_MeshVS_NodalColorPrsBuilder self, Standard_Integer const ID, Quantity_Color theColor) -> Standard_Boolean

        Returns color assigned to single node

        :type ID: int
        :type theColor: OCC.wrapper.Quantity.Quantity_Color
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_GetColor(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_MeshVS_NodalColorPrsBuilder self, Standard_Integer const ID, Quantity_Color theColor)

        Sets color assigned to single node

        :type ID: int
        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_SetColor(self, *args)


    def UseTexture(self, *args):
        """
        UseTexture(Handle_MeshVS_NodalColorPrsBuilder self, Standard_Boolean const theToUse)

        Specify whether texture must be used to build presentation

        :type theToUse: bool

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_UseTexture(self, *args)


    def IsUseTexture(self, *args):
        """
        IsUseTexture(Handle_MeshVS_NodalColorPrsBuilder self) -> Standard_Boolean

        Verify whether texture is used to build presentation

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_IsUseTexture(self, *args)


    def SetColorMap(self, *args):
        """
        SetColorMap(Handle_MeshVS_NodalColorPrsBuilder self, NCollection_Sequence_Quantity_Color theColors)

        Set colors to be used for texrture presentation
        theColors - colors for valid coordinates (laying in range [0, 1])

        :type theColors: OCC.wrapper.Aspect.Aspect_SequenceOfColor

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_SetColorMap(self, *args)


    def GetColorMap(self, *args):
        """
        Return colors used for texrture presentation

        :rtype: OCC.wrapper.Aspect.Aspect_SequenceOfColor

        """
        res = _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_GetColorMap(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetInvalidColor(self, *args):
        """
        SetInvalidColor(Handle_MeshVS_NodalColorPrsBuilder self, Quantity_Color theInvalidColor)

        Set color representing invalid texture coordinate
        (laying outside range [0, 1])

        :type theInvalidColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_SetInvalidColor(self, *args)


    def GetInvalidColor(self, *args):
        """
        GetInvalidColor(Handle_MeshVS_NodalColorPrsBuilder self) -> Quantity_Color

        Return color representing invalid texture coordinate
        (laying outside range [0, 1])

        :rtype: OCC.wrapper.Quantity.Quantity_Color

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_GetInvalidColor(self, *args)


    def SetTextureCoords(self, *args):
        """
        SetTextureCoords(Handle_MeshVS_NodalColorPrsBuilder self, NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher theMap)

        Specify correspondence between node IDs and texture coordinates (range [0, 1])

        :type theMap: OCC.wrapper.TColStd.TColStd_DataMapOfIntegerReal

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_SetTextureCoords(self, *args)


    def GetTextureCoords(self, *args):
        """
        Get correspondence between node IDs and texture coordinates (range [0, 1])

        :rtype: OCC.wrapper.TColStd.TColStd_DataMapOfIntegerReal

        """
        res = _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_GetTextureCoords(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTextureCoord(self, *args):
        """
        SetTextureCoord(Handle_MeshVS_NodalColorPrsBuilder self, Standard_Integer const theID, Standard_Real const theCoord)

        Specify correspondence between node ID and texture coordinate (range [0, 1])

        :type theID: int
        :type theCoord: float

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_SetTextureCoord(self, *args)


    def GetTextureCoord(self, *args):
        """
        GetTextureCoord(Handle_MeshVS_NodalColorPrsBuilder self, Standard_Integer const theID) -> Standard_Real

        Return correspondence between node IDs and texture coordinate (range [0, 1])

        :type theID: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_GetTextureCoord(self, *args)


    def AddVolumePrs(self, *args):
        """
        AddVolumePrs(Handle_MeshVS_NodalColorPrsBuilder self, Handle_MeshVS_HArray1OfSequenceOfInteger theTopo, NCollection_Array1_Standard_Integer theNodes, NCollection_Array1_Standard_Real theCoords, Handle_Graphic3d_ArrayOfPrimitives theArray, Standard_Boolean const theIsShaded, Standard_Integer const theNbColors, Standard_Integer const theNbTexColors, Standard_Real const theColorRatio)

        Add to array polygons or polylines representing volume

        :type theTopo: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger
        :type theNodes: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type theCoords: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type theArray: OCC.wrapper.Graphic3d.Handle_Graphic3d_ArrayOfPrimitives
        :type theIsShaded: bool
        :type theNbColors: int
        :type theNbTexColors: int
        :type theColorRatio: float

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_AddVolumePrs(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MeshVS_NodalColorPrsBuilder self) -> char const *

        :rtype: const char *

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CustomBuild(self, *args):
        """
        CustomBuild(Handle_MeshVS_NodalColorPrsBuilder self, Handle_Prs3d_Presentation Prs, TColStd_PackedMapOfInteger IDs, TColStd_PackedMapOfInteger IDsToExclude, Standard_Integer const DisplayMode)

        This method is called to build presentation of custom elements (they have MeshVS_ET_0D type).
        IDs is set of numeric identificators of elements for custom building.
        IDsToExclude is set of IDs to exclude from processing. If some entity
        has been excluded, it is not processed by other builders.
        DisplayMode is numeric constant describing display mode (see MeshVS_DisplayModeFlags.hxx)

        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type IDs: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IDsToExclude: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type DisplayMode: int

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_CustomBuild(self, *args)


    def CustomSensitiveEntity(self, *args):
        """
        CustomSensitiveEntity(Handle_MeshVS_NodalColorPrsBuilder self, Handle_SelectBasics_EntityOwner Owner, Standard_Integer const SelectMode) -> Handle_SelectBasics_SensitiveEntity

        This method is called to build sensitive of custom elements ( they have MeshVS_ET_0D type )

        :type Owner: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner
        :type SelectMode: int
        :rtype: OCC.wrapper.SelectBasics.Handle_SelectBasics_SensitiveEntity

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_CustomSensitiveEntity(self, *args)


    def GetFlags(self, *args):
        """
        GetFlags(Handle_MeshVS_NodalColorPrsBuilder self) -> Standard_Integer

        Returns flags, assigned with builder during creation

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_GetFlags(self, *args)


    def TestFlags(self, *args):
        """
        TestFlags(Handle_MeshVS_NodalColorPrsBuilder self, Standard_Integer const DisplayMode) -> Standard_Boolean

        Test whether display mode has flags assigned with this builder.
        This method has default implementation and can be redefined for advance behavior
        Returns Standard_True only if display mode is appropriate for this builder

        :type DisplayMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_TestFlags(self, *args)


    def GetId(self, *args):
        """
        GetId(Handle_MeshVS_NodalColorPrsBuilder self) -> Standard_Integer

        Returns builder ID

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_GetId(self, *args)


    def GetPriority(self, *args):
        """
        GetPriority(Handle_MeshVS_NodalColorPrsBuilder self) -> Standard_Integer

        Returns priority; as priority bigger, as soon builder will be called.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_GetPriority(self, *args)


    def GetDataSource(self, *args):
        """
        GetDataSource(Handle_MeshVS_NodalColorPrsBuilder self) -> Handle_MeshVS_DataSource

        Returns custom data source or default ( from MeshVS_Mesh ) if custom is NULL

        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_GetDataSource(self, *args)


    def SetDataSource(self, *args):
        """
        SetDataSource(Handle_MeshVS_NodalColorPrsBuilder self, Handle_MeshVS_DataSource newDS)

        Change custom data source

        :type newDS: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_SetDataSource(self, *args)


    def GetDrawer(self, *args):
        """
        GetDrawer(Handle_MeshVS_NodalColorPrsBuilder self) -> Handle_MeshVS_Drawer

        Returns custom drawer or default ( from MeshVS_Mesh ) if custom is NULL

        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_GetDrawer(self, *args)


    def SetDrawer(self, *args):
        """
        SetDrawer(Handle_MeshVS_NodalColorPrsBuilder self, Handle_MeshVS_Drawer newDr)

        Change custom drawer

        :type newDr: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_SetDrawer(self, *args)


    def SetExcluding(self, *args):
        """
        SetExcluding(Handle_MeshVS_NodalColorPrsBuilder self, Standard_Boolean const state)

        Set excluding state. If it is Standard_True, the nodes or elements, processed by current builder
        will be noted and next builder won't process its.

        :type state: bool

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_SetExcluding(self, *args)


    def IsExcludingOn(self, *args):
        """
        IsExcludingOn(Handle_MeshVS_NodalColorPrsBuilder self) -> Standard_Boolean

        Read excluding state

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_IsExcludingOn(self, *args)


    def SetPresentationManager(self, *args):
        """
        SetPresentationManager(Handle_MeshVS_NodalColorPrsBuilder self, Handle_PrsMgr_PresentationManager thePrsMgr)

        Set presentation manager for builder

        :type thePrsMgr: OCC.wrapper.MeshVS.Handle_PrsMgr_PresentationManager3d

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_SetPresentationManager(self, *args)


    def GetPresentationManager(self, *args):
        """
        GetPresentationManager(Handle_MeshVS_NodalColorPrsBuilder self) -> Handle_PrsMgr_PresentationManager

        Get presentation manager of builder

        :rtype: OCC.wrapper.MeshVS.Handle_PrsMgr_PresentationManager3d

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_GetPresentationManager(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_MeshVS_NodalColorPrsBuilder self)

        Memory deallocator for transient classes


        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MeshVS_NodalColorPrsBuilder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MeshVS_NodalColorPrsBuilder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MeshVS_NodalColorPrsBuilder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MeshVS_NodalColorPrsBuilder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MeshVS_NodalColorPrsBuilder self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MeshVS_NodalColorPrsBuilder self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MeshVS_NodalColorPrsBuilder self)

        Increments the reference counter of this object


        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MeshVS_NodalColorPrsBuilder self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_DecrementRefCounter(self, *args)

Handle_MeshVS_NodalColorPrsBuilder_swigregister = _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_swigregister
Handle_MeshVS_NodalColorPrsBuilder_swigregister(Handle_MeshVS_NodalColorPrsBuilder)

def Handle_MeshVS_NodalColorPrsBuilder_DownCast(thing):
    return _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_DownCast(thing)
Handle_MeshVS_NodalColorPrsBuilder_DownCast = _MeshVS.Handle_MeshVS_NodalColorPrsBuilder_DownCast

class Handle_MeshVS_TextPrsBuilder(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MeshVS_TextPrsBuilder self)

        Nullify the handle


        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MeshVS_TextPrsBuilder self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MeshVS_TextPrsBuilder self, MeshVS_TextPrsBuilder thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MeshVS_TextPrsBuilder self, Handle_MeshVS_TextPrsBuilder theHandle) -> Handle_MeshVS_TextPrsBuilder
        assign(Handle_MeshVS_TextPrsBuilder self, MeshVS_TextPrsBuilder thePtr) -> Handle_MeshVS_TextPrsBuilder
        assign(Handle_MeshVS_TextPrsBuilder self, Handle_MeshVS_TextPrsBuilder theHandle) -> Handle_MeshVS_TextPrsBuilder

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MeshVS_TextPrsBuilder self) -> MeshVS_TextPrsBuilder

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MeshVS_TextPrsBuilder self) -> MeshVS_TextPrsBuilder

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MeshVS_TextPrsBuilder self) -> MeshVS_TextPrsBuilder

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder___ref__(self, *args)


    def __hash__(self):
        return _MeshVS.Handle_MeshVS_TextPrsBuilder___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MeshVS.Handle_MeshVS_TextPrsBuilder___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MeshVS.new_Handle_MeshVS_TextPrsBuilder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MeshVS.Handle_MeshVS_TextPrsBuilder_DownCast)
    __swig_destroy__ = _MeshVS.delete_Handle_MeshVS_TextPrsBuilder

    def Build(self, *args):
        """
        Build(Handle_MeshVS_TextPrsBuilder self, Handle_Prs3d_Presentation Prs, TColStd_PackedMapOfInteger IDs, TColStd_PackedMapOfInteger IDsToExclude, Standard_Boolean const IsElement, Standard_Integer const theDisplayMode)

        Builds presentation of text data

        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type IDs: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IDsToExclude: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IsElement: bool
        :type theDisplayMode: int

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_Build(self, *args)


    def GetTexts(self, *args):
        """
        Returns map of text assigned with nodes ( IsElement = False ) or elements ( IsElement = True )

        :type IsElement: bool
        :rtype: OCC.wrapper.MeshVS.MeshVS_DataMapOfIntegerAsciiString

        """
        res = _MeshVS.Handle_MeshVS_TextPrsBuilder_GetTexts(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTexts(self, *args):
        """
        SetTexts(Handle_MeshVS_TextPrsBuilder self, Standard_Boolean const IsElement, NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher Map)

        Sets map of text assigned with nodes or elements

        :type IsElement: bool
        :type Map: OCC.wrapper.MeshVS.MeshVS_DataMapOfIntegerAsciiString

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_SetTexts(self, *args)


    def HasTexts(self, *args):
        """
        HasTexts(Handle_MeshVS_TextPrsBuilder self, Standard_Boolean const IsElement) -> Standard_Boolean

        Returns True if map isn't empty

        :type IsElement: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_HasTexts(self, *args)


    def GetText(self, *args):
        """
        GetText(Handle_MeshVS_TextPrsBuilder self, Standard_Boolean const IsElement, Standard_Integer const ID, TCollection_AsciiString Text) -> Standard_Boolean

        Returns text assigned with single node or element

        :type IsElement: bool
        :type ID: int
        :type Text: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_GetText(self, *args)


    def SetText(self, *args):
        """
        SetText(Handle_MeshVS_TextPrsBuilder self, Standard_Boolean const IsElement, Standard_Integer const ID, TCollection_AsciiString Text)

        Sets text assigned with single node or element

        :type IsElement: bool
        :type ID: int
        :type Text: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_SetText(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MeshVS_TextPrsBuilder self) -> char const *

        :rtype: const char *

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_TextPrsBuilder_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_TextPrsBuilder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CustomBuild(self, *args):
        """
        CustomBuild(Handle_MeshVS_TextPrsBuilder self, Handle_Prs3d_Presentation Prs, TColStd_PackedMapOfInteger IDs, TColStd_PackedMapOfInteger IDsToExclude, Standard_Integer const DisplayMode)

        This method is called to build presentation of custom elements (they have MeshVS_ET_0D type).
        IDs is set of numeric identificators of elements for custom building.
        IDsToExclude is set of IDs to exclude from processing. If some entity
        has been excluded, it is not processed by other builders.
        DisplayMode is numeric constant describing display mode (see MeshVS_DisplayModeFlags.hxx)

        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type IDs: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IDsToExclude: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type DisplayMode: int

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_CustomBuild(self, *args)


    def CustomSensitiveEntity(self, *args):
        """
        CustomSensitiveEntity(Handle_MeshVS_TextPrsBuilder self, Handle_SelectBasics_EntityOwner Owner, Standard_Integer const SelectMode) -> Handle_SelectBasics_SensitiveEntity

        This method is called to build sensitive of custom elements ( they have MeshVS_ET_0D type )

        :type Owner: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner
        :type SelectMode: int
        :rtype: OCC.wrapper.SelectBasics.Handle_SelectBasics_SensitiveEntity

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_CustomSensitiveEntity(self, *args)


    def GetFlags(self, *args):
        """
        GetFlags(Handle_MeshVS_TextPrsBuilder self) -> Standard_Integer

        Returns flags, assigned with builder during creation

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_GetFlags(self, *args)


    def TestFlags(self, *args):
        """
        TestFlags(Handle_MeshVS_TextPrsBuilder self, Standard_Integer const DisplayMode) -> Standard_Boolean

        Test whether display mode has flags assigned with this builder.
        This method has default implementation and can be redefined for advance behavior
        Returns Standard_True only if display mode is appropriate for this builder

        :type DisplayMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_TestFlags(self, *args)


    def GetId(self, *args):
        """
        GetId(Handle_MeshVS_TextPrsBuilder self) -> Standard_Integer

        Returns builder ID

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_GetId(self, *args)


    def GetPriority(self, *args):
        """
        GetPriority(Handle_MeshVS_TextPrsBuilder self) -> Standard_Integer

        Returns priority; as priority bigger, as soon builder will be called.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_GetPriority(self, *args)


    def GetDataSource(self, *args):
        """
        GetDataSource(Handle_MeshVS_TextPrsBuilder self) -> Handle_MeshVS_DataSource

        Returns custom data source or default ( from MeshVS_Mesh ) if custom is NULL

        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_GetDataSource(self, *args)


    def SetDataSource(self, *args):
        """
        SetDataSource(Handle_MeshVS_TextPrsBuilder self, Handle_MeshVS_DataSource newDS)

        Change custom data source

        :type newDS: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_SetDataSource(self, *args)


    def GetDrawer(self, *args):
        """
        GetDrawer(Handle_MeshVS_TextPrsBuilder self) -> Handle_MeshVS_Drawer

        Returns custom drawer or default ( from MeshVS_Mesh ) if custom is NULL

        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_GetDrawer(self, *args)


    def SetDrawer(self, *args):
        """
        SetDrawer(Handle_MeshVS_TextPrsBuilder self, Handle_MeshVS_Drawer newDr)

        Change custom drawer

        :type newDr: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_SetDrawer(self, *args)


    def SetExcluding(self, *args):
        """
        SetExcluding(Handle_MeshVS_TextPrsBuilder self, Standard_Boolean const state)

        Set excluding state. If it is Standard_True, the nodes or elements, processed by current builder
        will be noted and next builder won't process its.

        :type state: bool

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_SetExcluding(self, *args)


    def IsExcludingOn(self, *args):
        """
        IsExcludingOn(Handle_MeshVS_TextPrsBuilder self) -> Standard_Boolean

        Read excluding state

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_IsExcludingOn(self, *args)


    def SetPresentationManager(self, *args):
        """
        SetPresentationManager(Handle_MeshVS_TextPrsBuilder self, Handle_PrsMgr_PresentationManager thePrsMgr)

        Set presentation manager for builder

        :type thePrsMgr: OCC.wrapper.MeshVS.Handle_PrsMgr_PresentationManager3d

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_SetPresentationManager(self, *args)


    def GetPresentationManager(self, *args):
        """
        GetPresentationManager(Handle_MeshVS_TextPrsBuilder self) -> Handle_PrsMgr_PresentationManager

        Get presentation manager of builder

        :rtype: OCC.wrapper.MeshVS.Handle_PrsMgr_PresentationManager3d

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_GetPresentationManager(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_MeshVS_TextPrsBuilder self)

        Memory deallocator for transient classes


        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MeshVS_TextPrsBuilder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MeshVS_TextPrsBuilder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MeshVS_TextPrsBuilder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MeshVS_TextPrsBuilder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MeshVS_TextPrsBuilder self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MeshVS_TextPrsBuilder self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MeshVS_TextPrsBuilder self)

        Increments the reference counter of this object


        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MeshVS_TextPrsBuilder self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_TextPrsBuilder_DecrementRefCounter(self, *args)

Handle_MeshVS_TextPrsBuilder_swigregister = _MeshVS.Handle_MeshVS_TextPrsBuilder_swigregister
Handle_MeshVS_TextPrsBuilder_swigregister(Handle_MeshVS_TextPrsBuilder)

def Handle_MeshVS_TextPrsBuilder_DownCast(thing):
    return _MeshVS.Handle_MeshVS_TextPrsBuilder_DownCast(thing)
Handle_MeshVS_TextPrsBuilder_DownCast = _MeshVS.Handle_MeshVS_TextPrsBuilder_DownCast

class Handle_MeshVS_CommonSensitiveEntity(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MeshVS_CommonSensitiveEntity self)

        Nullify the handle


        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MeshVS_CommonSensitiveEntity self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MeshVS_CommonSensitiveEntity self, MeshVS_CommonSensitiveEntity thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MeshVS_CommonSensitiveEntity self, Handle_MeshVS_CommonSensitiveEntity theHandle) -> Handle_MeshVS_CommonSensitiveEntity
        assign(Handle_MeshVS_CommonSensitiveEntity self, MeshVS_CommonSensitiveEntity thePtr) -> Handle_MeshVS_CommonSensitiveEntity
        assign(Handle_MeshVS_CommonSensitiveEntity self, Handle_MeshVS_CommonSensitiveEntity theHandle) -> Handle_MeshVS_CommonSensitiveEntity

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MeshVS_CommonSensitiveEntity self) -> MeshVS_CommonSensitiveEntity

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MeshVS_CommonSensitiveEntity self) -> MeshVS_CommonSensitiveEntity

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MeshVS_CommonSensitiveEntity self) -> MeshVS_CommonSensitiveEntity

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity___ref__(self, *args)


    def __hash__(self):
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MeshVS.Handle_MeshVS_CommonSensitiveEntity___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MeshVS.new_Handle_MeshVS_CommonSensitiveEntity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MeshVS.Handle_MeshVS_CommonSensitiveEntity_DownCast)
    __swig_destroy__ = _MeshVS.delete_Handle_MeshVS_CommonSensitiveEntity

    def get_type_name(self, *args):
        """
        get_type_name(Handle_MeshVS_CommonSensitiveEntity self) -> char const *

        :rtype: const char *

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_CommonSensitiveEntity_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_CommonSensitiveEntity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbSubElements(self, *args):
        """
        NbSubElements(Handle_MeshVS_CommonSensitiveEntity self) -> Standard_Integer

        Number of elements.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_NbSubElements(self, *args)


    def Size(self, *args):
        """
        Size(Handle_MeshVS_CommonSensitiveEntity self) -> Standard_Integer

        Returns the amount of sub-entities of the complex entity

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_Size(self, *args)


    def Box(self, *args):
        """
        Box(Handle_MeshVS_CommonSensitiveEntity self, Standard_Integer const theIdx) -> BVH_Box_Standard_Real_

        Returns bounding box of sub-entity with index theIdx in sub-entity list

        :type theIdx: int
        :rtype: OCC.wrapper.Select3D.Select3D_BndBox3d

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_Box(self, *args)


    def Center(self, *args):
        """
        Center(Handle_MeshVS_CommonSensitiveEntity self, Standard_Integer const theIdx, Standard_Integer const theAxis) -> Standard_Real

        Returns geometry center of sensitive entity index theIdx along the given axis theAxis

        :type theIdx: int
        :type theAxis: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_Center(self, *args)


    def Swap(self, *args):
        """
        Swap(Handle_MeshVS_CommonSensitiveEntity self, Standard_Integer const theIdx1, Standard_Integer const theIdx2)

        Swaps items with indexes theIdx1 and theIdx2

        :type theIdx1: int
        :type theIdx2: int

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_Swap(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_MeshVS_CommonSensitiveEntity self) -> BVH_Box_Standard_Real_

        Returns bounding box of the triangulation. If location
        transformation is set, it will be applied

        :rtype: OCC.wrapper.Select3D.Select3D_BndBox3d

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_BoundingBox(self, *args)


    def CenterOfGeometry(self, *args):
        """
        CenterOfGeometry(Handle_MeshVS_CommonSensitiveEntity self) -> gp_Pnt

        Returns center of a mesh

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_CenterOfGeometry(self, *args)


    def GetConnected(self, *args):
        """
        GetConnected(Handle_MeshVS_CommonSensitiveEntity self) -> Handle_Select3D_SensitiveEntity

        Create a copy.

        :rtype: OCC.wrapper.Select3D.Handle_Select3D_SensitiveEntity

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_GetConnected(self, *args)


    def DefaultBVHBuilder(self, *args):
        """
        Return global instance to default BVH builder.

        :rtype: OCC.wrapper.Select3D.Handle_Select3D_BVHBuilder3d

        """
        res = _MeshVS.Handle_MeshVS_CommonSensitiveEntity_DefaultBVHBuilder(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDefaultBVHBuilder(self, *args):
        """
        SetDefaultBVHBuilder(Handle_MeshVS_CommonSensitiveEntity self, Handle_Select3D_BVHBuilder3d theBuilder)

        Assign new BVH builder to be used by default for new sensitive sets (assigning is NOT thread-safe!).

        :type theBuilder: OCC.wrapper.Select3D.Handle_Select3D_BVHBuilder3d

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_SetDefaultBVHBuilder(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_MeshVS_CommonSensitiveEntity self, SelectBasics_SelectingVolumeManager theMgr, SelectBasics_PickResult & thePickResult) -> Standard_Boolean

        Checks whether one or more entities of the set overlap current selecting volume.
        Implements the traverse of BVH tree built for the set

        :type theMgr: OCC.wrapper.SelectBasics.SelectBasics_SelectingVolumeManager
        :type thePickResult: OCC.wrapper.SelectBasics.SelectBasics_PickResult
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_Matches(self, *args)


    def BVH(self, *args):
        """
        BVH(Handle_MeshVS_CommonSensitiveEntity self)

        Builds BVH tree for sensitive set.
        Must be called manually to build BVH tree for any sensitive set
        in case if its content was initialized not in a constructor,
        but element by element


        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_BVH(self, *args)


    def SetBuilder(self, *args):
        """
        SetBuilder(Handle_MeshVS_CommonSensitiveEntity self, Handle_Select3D_BVHBuilder3d theBuilder)

        Sets the method (builder) used to construct BVH.

        :type theBuilder: OCC.wrapper.Select3D.Handle_Select3D_BVHBuilder3d

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_SetBuilder(self, *args)


    def MarkDirty(self, *args):
        """
        MarkDirty(Handle_MeshVS_CommonSensitiveEntity self)

        Marks BVH tree of the set as outdated. It will be rebuild
        at the next call of BVH()


        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_MarkDirty(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_MeshVS_CommonSensitiveEntity self)

        Destroys cross-reference to avoid memory leak


        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_Clear(self, *args)


    def GetLeafNodeSize(self, *args):
        """
        GetLeafNodeSize(Handle_MeshVS_CommonSensitiveEntity self) -> Standard_Integer

        Returns a number of nodes in 1 BVH leaf

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_GetLeafNodeSize(self, *args)


    def HasInitLocation(self, *args):
        """
        HasInitLocation(Handle_MeshVS_CommonSensitiveEntity self) -> Standard_Boolean

        Returns true if the shape corresponding to the entity has init location

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_HasInitLocation(self, *args)


    def InvInitLocation(self, *args):
        """
        InvInitLocation(Handle_MeshVS_CommonSensitiveEntity self) -> gp_GTrsf

        Returns inversed location transformation matrix if the shape corresponding
        to this entity has init location set. Otherwise, returns identity matrix.

        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_InvInitLocation(self, *args)


    def Set(self, *args):
        """
        Set(Handle_MeshVS_CommonSensitiveEntity self, Handle_SelectBasics_EntityOwner theOwnerId)

        Sets owner of the entity

        :type theOwnerId: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_Set(self, *args)


    def OwnerId(self, *args):
        """
        Returns pointer to owner of the entity

        :rtype: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner

        """
        res = _MeshVS.Handle_MeshVS_CommonSensitiveEntity_OwnerId(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SensitivityFactor(self, *args):
        """
        SensitivityFactor(Handle_MeshVS_CommonSensitiveEntity self) -> Standard_Integer

        allows a better sensitivity for
        a specific entity in selection algorithms
        useful for small sized entities.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_SensitivityFactor(self, *args)


    def SetSensitivityFactor(self, *args):
        """
        SetSensitivityFactor(Handle_MeshVS_CommonSensitiveEntity self, Standard_Integer const theNewSens)

        Allows to manage sensitivity of a particular sensitive entity

        :type theNewSens: int

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_SetSensitivityFactor(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_MeshVS_CommonSensitiveEntity self)

        Memory deallocator for transient classes


        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MeshVS_CommonSensitiveEntity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MeshVS_CommonSensitiveEntity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MeshVS_CommonSensitiveEntity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MeshVS_CommonSensitiveEntity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MeshVS_CommonSensitiveEntity self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MeshVS_CommonSensitiveEntity self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MeshVS_CommonSensitiveEntity self)

        Increments the reference counter of this object


        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MeshVS_CommonSensitiveEntity self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_DecrementRefCounter(self, *args)

Handle_MeshVS_CommonSensitiveEntity_swigregister = _MeshVS.Handle_MeshVS_CommonSensitiveEntity_swigregister
Handle_MeshVS_CommonSensitiveEntity_swigregister(Handle_MeshVS_CommonSensitiveEntity)

def Handle_MeshVS_CommonSensitiveEntity_DownCast(thing):
    return _MeshVS.Handle_MeshVS_CommonSensitiveEntity_DownCast(thing)
Handle_MeshVS_CommonSensitiveEntity_DownCast = _MeshVS.Handle_MeshVS_CommonSensitiveEntity_DownCast

class NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,gp_Vec,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,gp_Vec,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,gp_Vec,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,gp_Vec,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _MeshVS.new_NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher self, int const & theKey, gp_Vec theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher self, int const & theKey, gp_Vec theItem) -> gp_Vec

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher self, int const & theKey) -> gp_Vec

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher self, int const & theKey) -> gp_Vec

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher self, int const & theKey) -> gp_Vec

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _MeshVS.NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _MeshVS.delete_NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_swigregister = _MeshVS.NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _MeshVS.new_NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MeshVS.delete_NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _MeshVS.NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _MeshVS.NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher_IteratorHelper)


try:
	MeshVS_DataMapOfIntegerVector = NCollection_DataMap_Standard_Integer_gp_Vec_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored


try:
	TColStd_MapIntegerHasher = TColStd.NCollection_DefaultHasher_Standard_Integer
except AttributeError:
	pass # does not exist, probably ignored

class MeshVS_Buffer(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(MeshVS_Buffer self, Standard_Size const theSize) -> MeshVS_Buffer

        Constructor of the buffer of the requested size

        :type theSize: int

        """
        this = _MeshVS.new_MeshVS_Buffer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MeshVS.delete_MeshVS_Buffer
MeshVS_Buffer_swigregister = _MeshVS.MeshVS_Buffer_swigregister
MeshVS_Buffer_swigregister(MeshVS_Buffer)

class Handle_MeshVS_MeshEntityOwner(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MeshVS_MeshEntityOwner self)

        Nullify the handle


        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MeshVS_MeshEntityOwner self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MeshVS_MeshEntityOwner self, MeshVS_MeshEntityOwner thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MeshVS_MeshEntityOwner self, Handle_MeshVS_MeshEntityOwner theHandle) -> Handle_MeshVS_MeshEntityOwner
        assign(Handle_MeshVS_MeshEntityOwner self, MeshVS_MeshEntityOwner thePtr) -> Handle_MeshVS_MeshEntityOwner
        assign(Handle_MeshVS_MeshEntityOwner self, Handle_MeshVS_MeshEntityOwner theHandle) -> Handle_MeshVS_MeshEntityOwner

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MeshVS_MeshEntityOwner self) -> MeshVS_MeshEntityOwner

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MeshVS_MeshEntityOwner self) -> MeshVS_MeshEntityOwner

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MeshVS_MeshEntityOwner self) -> MeshVS_MeshEntityOwner

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner___ref__(self, *args)


    def __hash__(self):
        return _MeshVS.Handle_MeshVS_MeshEntityOwner___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MeshVS.Handle_MeshVS_MeshEntityOwner___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MeshVS.new_Handle_MeshVS_MeshEntityOwner(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MeshVS.Handle_MeshVS_MeshEntityOwner_DownCast)
    __swig_destroy__ = _MeshVS.delete_Handle_MeshVS_MeshEntityOwner

    def Owner(self, *args):
        """
        Owner(Handle_MeshVS_MeshEntityOwner self) -> Standard_Address

        Returns an address of element or node data structure

        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_Owner(self, *args)


    def Type(self, *args):
        """
        Type(Handle_MeshVS_MeshEntityOwner self) -> MeshVS_EntityType

        Returns type of element or node data structure

        :rtype: OCC.wrapper.MeshVS.MeshVS_EntityType

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_Type(self, *args)


    def ID(self, *args):
        """
        ID(Handle_MeshVS_MeshEntityOwner self) -> Standard_Integer

        Returns ID of element or node data structure

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_ID(self, *args)


    def IsGroup(self, *args):
        """
        IsGroup(Handle_MeshVS_MeshEntityOwner self) -> Standard_Boolean

        Returns true if owner represents group of nodes or elements

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_IsGroup(self, *args)


    def IsHilighted(self, *args):
        """
        IsHilighted(Handle_MeshVS_MeshEntityOwner self, Handle_PrsMgr_PresentationManager PM, Standard_Integer const Mode=0) -> Standard_Boolean

        Returns true if owner is hilighted

        :type PM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type Mode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_IsHilighted(self, *args)


    def HilightWithColor(self, *args):
        """
        HilightWithColor(Handle_MeshVS_MeshEntityOwner self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theStyle, Standard_Integer const theMode=0)

        Hilights owner with the certain color

        :type thePM: OCC.wrapper.MeshVS.Handle_PrsMgr_PresentationManager3d
        :type theStyle: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theMode: int

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_HilightWithColor(self, *args)


    def Unhilight(self, *args):
        """
        Unhilight(Handle_MeshVS_MeshEntityOwner self, Handle_PrsMgr_PresentationManager PM, Standard_Integer const Mode=0)

        Strip hilight of owner

        :type PM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type Mode: int

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_Unhilight(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_MeshVS_MeshEntityOwner self, Handle_PrsMgr_PresentationManager PM, Standard_Integer const Mode=0)

        :type PM: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentationManager
        :type Mode: int

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_Clear(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MeshVS_MeshEntityOwner self) -> char const *

        :rtype: const char *

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_MeshEntityOwner_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_MeshEntityOwner_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelectable(self, *args):
        """
        HasSelectable(Handle_MeshVS_MeshEntityOwner self) -> Standard_Boolean

        Returns true if there is a selectable object to serve as an owner.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_HasSelectable(self, *args)


    def Selectable(self, *args):
        """
        Selectable(Handle_MeshVS_MeshEntityOwner self) -> Handle_SelectMgr_SelectableObject

        Returns a selectable object detected in the working context.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_Selectable(self, *args)


    def SetSelectable(self, *args):
        """
        SetSelectable(Handle_MeshVS_MeshEntityOwner self, Handle_SelectMgr_SelectableObject theSelObj)

        Sets the selectable object.

        :type theSelObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_SetSelectable(self, *args)


    def HasLocation(self, *args):
        """
        HasLocation(Handle_MeshVS_MeshEntityOwner self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_HasLocation(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_MeshVS_MeshEntityOwner self, TopLoc_Location aLoc)

        :type aLoc: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_SetLocation(self, *args)


    def ResetLocation(self, *args):
        """ResetLocation(Handle_MeshVS_MeshEntityOwner self)"""
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_ResetLocation(self, *args)


    def Location(self, *args):
        """
        Location(Handle_MeshVS_MeshEntityOwner self) -> TopLoc_Location

        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_Location(self, *args)


    def SetSelected(self, *args):
        """
        SetSelected(Handle_MeshVS_MeshEntityOwner self, Standard_Boolean const theIsSelected)

        Set the state of the owner.
        @param theIsSelected [in] shows if owner is selected.

        :type theIsSelected: bool

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_SetSelected(self, *args)


    def IsSelected(self, *args):
        """
        IsSelected(Handle_MeshVS_MeshEntityOwner self) -> Standard_Boolean

        @return Standard_True if the owner is selected.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_IsSelected(self, *args)


    def State(self, *args):
        """
        State(Handle_MeshVS_MeshEntityOwner self, Standard_Integer const theStatus)
        State(Handle_MeshVS_MeshEntityOwner self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_State(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_MeshVS_MeshEntityOwner self) -> Standard_Boolean

        if owner is not auto hilighted, for group contains many such owners
        will be called one method HilightSelected of SelectableObject

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_IsAutoHilight(self, *args)


    def IsForcedHilight(self, *args):
        """
        IsForcedHilight(Handle_MeshVS_MeshEntityOwner self) -> Standard_Boolean

        if this method returns TRUE the owner will allways call method
        Hilight for SelectableObject when the owner is detected. By default
        it always return FALSE.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_IsForcedHilight(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_MeshVS_MeshEntityOwner self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_SetZLayer(self, *args)


    def UpdateHighlightTrsf(self, *args):
        """
        UpdateHighlightTrsf(Handle_MeshVS_MeshEntityOwner self, Handle_V3d_Viewer theViewer, Handle_PrsMgr_PresentationManager theManager, Standard_Integer const theDispMode)

        Implements immediate application of location transformation of parent object to dynamic highlight structure

        :type theViewer: OCC.wrapper.V3d.Handle_V3d_Viewer
        :type theManager: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :type theDispMode: int

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_UpdateHighlightTrsf(self, *args)


    def IsSameSelectable(self, *args):
        """
        IsSameSelectable(Handle_MeshVS_MeshEntityOwner self, Handle_SelectMgr_SelectableObject theOther) -> Standard_Boolean

        Returns true if pointer to selectable object of this owner is equal to the given one

        :type theOther: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_IsSameSelectable(self, *args)


    def ComesFromDecomposition(self, *args):
        """
        ComesFromDecomposition(Handle_MeshVS_MeshEntityOwner self) -> Standard_Boolean

        Returns TRUE if this owner points to a part of object and FALSE for entire object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_ComesFromDecomposition(self, *args)


    def SetComesFromDecomposition(self, *args):
        """
        SetComesFromDecomposition(Handle_MeshVS_MeshEntityOwner self, Standard_Boolean const theIsFromDecomposition)

        Sets flag indicating this owner points to a part of object (TRUE) or to entire object (FALSE).

        :type theIsFromDecomposition: bool

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_SetComesFromDecomposition(self, *args)


    def Set(self, *args):
        """
        Set(Handle_MeshVS_MeshEntityOwner self, Handle_SelectMgr_SelectableObject theSelObj)

        Sets the selectable object.

        :type theSelObj: OCC.wrapper.SelectMgr.Handle_SelectMgr_SelectableObject

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_Set(self, *args)


    def SetPriority(self, *args):
        """
        SetPriority(Handle_MeshVS_MeshEntityOwner self, Standard_Integer const thePriority)

        sets the selectable priority of the owner

        :type thePriority: int

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_SetPriority(self, *args)


    def Priority(self, *args):
        """
        Priority(Handle_MeshVS_MeshEntityOwner self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_Priority(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_MeshVS_MeshEntityOwner self)

        Memory deallocator for transient classes


        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MeshVS_MeshEntityOwner self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MeshVS_MeshEntityOwner self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MeshVS_MeshEntityOwner self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MeshVS_MeshEntityOwner self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MeshVS_MeshEntityOwner self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MeshVS_MeshEntityOwner self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MeshVS_MeshEntityOwner self)

        Increments the reference counter of this object


        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MeshVS_MeshEntityOwner self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_MeshEntityOwner_DecrementRefCounter(self, *args)

Handle_MeshVS_MeshEntityOwner_swigregister = _MeshVS.Handle_MeshVS_MeshEntityOwner_swigregister
Handle_MeshVS_MeshEntityOwner_swigregister(Handle_MeshVS_MeshEntityOwner)

def Handle_MeshVS_MeshEntityOwner_DownCast(thing):
    return _MeshVS.Handle_MeshVS_MeshEntityOwner_DownCast(thing)
Handle_MeshVS_MeshEntityOwner_DownCast = _MeshVS.Handle_MeshVS_MeshEntityOwner_DownCast

class NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< MeshVS_MeshEntityOwner >,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< MeshVS_MeshEntityOwner >,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< MeshVS_MeshEntityOwner >,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< MeshVS_MeshEntityOwner >,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _MeshVS.new_NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher self, int const & theKey, Handle_MeshVS_MeshEntityOwner theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher self, int const & theKey, Handle_MeshVS_MeshEntityOwner theItem) -> Handle_MeshVS_MeshEntityOwner

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_MeshVS_MeshEntityOwner

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_MeshVS_MeshEntityOwner

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_MeshVS_MeshEntityOwner

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _MeshVS.delete_NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_swigregister = _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _MeshVS.new_NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MeshVS.delete_NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher_IteratorHelper)


try:
	MeshVS_DataMapOfIntegerMeshEntityOwner = NCollection_DataMap_Standard_Integer_Handle_MeshVS_MeshEntityOwner_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< SelectMgr_EntityOwner >,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< SelectMgr_EntityOwner >,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< SelectMgr_EntityOwner >,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< SelectMgr_EntityOwner >,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _MeshVS.new_NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher self, int const & theKey, Handle_SelectMgr_EntityOwner theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher self, int const & theKey, Handle_SelectMgr_EntityOwner theItem) -> Handle_SelectMgr_EntityOwner

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_SelectMgr_EntityOwner

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_SelectMgr_EntityOwner

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_SelectMgr_EntityOwner

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _MeshVS.delete_NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_swigregister = _MeshVS.NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _MeshVS.new_NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MeshVS.delete_NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _MeshVS.NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher_IteratorHelper)


try:
	MeshVS_DataMapOfIntegerOwner = NCollection_DataMap_Standard_Integer_Handle_SelectMgr_EntityOwner_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< MeshVS_HArray1OfSequenceOfInteger >,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< MeshVS_HArray1OfSequenceOfInteger >,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< MeshVS_HArray1OfSequenceOfInteger >,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< MeshVS_HArray1OfSequenceOfInteger >,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _MeshVS.new_NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher self, int const & theKey, Handle_MeshVS_HArray1OfSequenceOfInteger theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher self, int const & theKey, Handle_MeshVS_HArray1OfSequenceOfInteger theItem) -> Handle_MeshVS_HArray1OfSequenceOfInteger

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_MeshVS_HArray1OfSequenceOfInteger

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_MeshVS_HArray1OfSequenceOfInteger

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_MeshVS_HArray1OfSequenceOfInteger

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _MeshVS.delete_NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_swigregister = _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _MeshVS.new_NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MeshVS.delete_NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _MeshVS.NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher_IteratorHelper)


try:
	MeshVS_DataMapOfHArray1OfSequenceOfInteger = NCollection_DataMap_Standard_Integer_Handle_MeshVS_HArray1OfSequenceOfInteger_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class MeshVS_Tool(object):
    """This class provides auxiliary methods to create differents aspects"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def CreateAspectFillArea3d(*args):
        """
        CreateAspectFillArea3d(Handle_MeshVS_Drawer theDr, Standard_Boolean const UseDefaults) -> Handle_Graphic3d_AspectFillArea3d
        CreateAspectFillArea3d(Handle_MeshVS_Drawer theDr, Graphic3d_MaterialAspect Mat, Standard_Boolean const UseDefaults) -> Handle_Graphic3d_AspectFillArea3d

        Creates fill aspect with values from Drawer according to keys from DrawerAttribute
        and specific material aspect

        :type theDr: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer
        :type Mat: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect
        :type UseDefaults: bool
        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectFillArea3d

        """
        return _MeshVS.MeshVS_Tool_CreateAspectFillArea3d(*args)

    CreateAspectFillArea3d = staticmethod(CreateAspectFillArea3d)

    def CreateAspectLine3d(*args):
        """
        CreateAspectLine3d(Handle_MeshVS_Drawer theDr, Standard_Boolean const UseDefaults) -> Handle_Graphic3d_AspectLine3d

        Creates line aspect with values from Drawer according to keys from DrawerAttribute

        :type theDr: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer
        :type UseDefaults: bool
        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectLine3d

        """
        return _MeshVS.MeshVS_Tool_CreateAspectLine3d(*args)

    CreateAspectLine3d = staticmethod(CreateAspectLine3d)

    def CreateAspectMarker3d(*args):
        """
        CreateAspectMarker3d(Handle_MeshVS_Drawer theDr, Standard_Boolean const UseDefaults) -> Handle_Graphic3d_AspectMarker3d

        Creates marker aspect with values from Drawer according to keys from DrawerAttribute

        :type theDr: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer
        :type UseDefaults: bool
        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectMarker3d

        """
        return _MeshVS.MeshVS_Tool_CreateAspectMarker3d(*args)

    CreateAspectMarker3d = staticmethod(CreateAspectMarker3d)

    def CreateAspectText3d(*args):
        """
        CreateAspectText3d(Handle_MeshVS_Drawer theDr, Standard_Boolean const UseDefaults) -> Handle_Graphic3d_AspectText3d

        Creates text aspect with values from Drawer according to keys from DrawerAttribute

        :type theDr: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer
        :type UseDefaults: bool
        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectText3d

        """
        return _MeshVS.MeshVS_Tool_CreateAspectText3d(*args)

    CreateAspectText3d = staticmethod(CreateAspectText3d)

    def GetNormal(*args):
        """
        GetNormal(NCollection_Array1_Standard_Real Nodes, gp_Vec Norm) -> Standard_Boolean

        Get one of normals to polygon described by these points.
        If the polygon isn't planar, function returns false

        :type Nodes: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Norm: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_Tool_GetNormal(*args)

    GetNormal = staticmethod(GetNormal)

    def GetAverageNormal(*args):
        """
        GetAverageNormal(NCollection_Array1_Standard_Real Nodes, gp_Vec Norm) -> Standard_Boolean

        Get an average of normals to non-planar polygon described by these points or compute
        normal of planar polygon. If the polygon isn't planar, function returns false

        :type Nodes: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Norm: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_Tool_GetAverageNormal(*args)

    GetAverageNormal = staticmethod(GetAverageNormal)

    def __init__(self):
        """This class provides auxiliary methods to create differents aspects"""
        this = _MeshVS.new_MeshVS_Tool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MeshVS.delete_MeshVS_Tool
MeshVS_Tool_swigregister = _MeshVS.MeshVS_Tool_swigregister
MeshVS_Tool_swigregister(MeshVS_Tool)

def MeshVS_Tool_CreateAspectFillArea3d(*args):
    """
    CreateAspectFillArea3d(Handle_MeshVS_Drawer theDr, Standard_Boolean const UseDefaults) -> Handle_Graphic3d_AspectFillArea3d
    MeshVS_Tool_CreateAspectFillArea3d(Handle_MeshVS_Drawer theDr, Graphic3d_MaterialAspect Mat, Standard_Boolean const UseDefaults) -> Handle_Graphic3d_AspectFillArea3d

    Creates fill aspect with values from Drawer according to keys from DrawerAttribute
    and specific material aspect

    :type theDr: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer
    :type Mat: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect
    :type UseDefaults: bool
    :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectFillArea3d

    """
    return _MeshVS.MeshVS_Tool_CreateAspectFillArea3d(*args)

def MeshVS_Tool_CreateAspectLine3d(*args):
    """
    MeshVS_Tool_CreateAspectLine3d(Handle_MeshVS_Drawer theDr, Standard_Boolean const UseDefaults) -> Handle_Graphic3d_AspectLine3d

    Creates line aspect with values from Drawer according to keys from DrawerAttribute

    :type theDr: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer
    :type UseDefaults: bool
    :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectLine3d

    """
    return _MeshVS.MeshVS_Tool_CreateAspectLine3d(*args)

def MeshVS_Tool_CreateAspectMarker3d(*args):
    """
    MeshVS_Tool_CreateAspectMarker3d(Handle_MeshVS_Drawer theDr, Standard_Boolean const UseDefaults) -> Handle_Graphic3d_AspectMarker3d

    Creates marker aspect with values from Drawer according to keys from DrawerAttribute

    :type theDr: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer
    :type UseDefaults: bool
    :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectMarker3d

    """
    return _MeshVS.MeshVS_Tool_CreateAspectMarker3d(*args)

def MeshVS_Tool_CreateAspectText3d(*args):
    """
    MeshVS_Tool_CreateAspectText3d(Handle_MeshVS_Drawer theDr, Standard_Boolean const UseDefaults) -> Handle_Graphic3d_AspectText3d

    Creates text aspect with values from Drawer according to keys from DrawerAttribute

    :type theDr: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer
    :type UseDefaults: bool
    :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_AspectText3d

    """
    return _MeshVS.MeshVS_Tool_CreateAspectText3d(*args)

def MeshVS_Tool_GetNormal(*args):
    """
    MeshVS_Tool_GetNormal(NCollection_Array1_Standard_Real Nodes, gp_Vec Norm) -> Standard_Boolean

    Get one of normals to polygon described by these points.
    If the polygon isn't planar, function returns false

    :type Nodes: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Norm: OCC.wrapper.gp.gp_Vec
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _MeshVS.MeshVS_Tool_GetNormal(*args)

def MeshVS_Tool_GetAverageNormal(*args):
    """
    MeshVS_Tool_GetAverageNormal(NCollection_Array1_Standard_Real Nodes, gp_Vec Norm) -> Standard_Boolean

    Get an average of normals to non-planar polygon described by these points or compute
    normal of planar polygon. If the polygon isn't planar, function returns false

    :type Nodes: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Norm: OCC.wrapper.gp.gp_Vec
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _MeshVS.MeshVS_Tool_GetAverageNormal(*args)

class Handle_MeshVS_SensitiveMesh(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MeshVS_SensitiveMesh self)

        Nullify the handle


        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MeshVS_SensitiveMesh self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MeshVS_SensitiveMesh self, MeshVS_SensitiveMesh thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MeshVS_SensitiveMesh self, Handle_MeshVS_SensitiveMesh theHandle) -> Handle_MeshVS_SensitiveMesh
        assign(Handle_MeshVS_SensitiveMesh self, MeshVS_SensitiveMesh thePtr) -> Handle_MeshVS_SensitiveMesh
        assign(Handle_MeshVS_SensitiveMesh self, Handle_MeshVS_SensitiveMesh theHandle) -> Handle_MeshVS_SensitiveMesh

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MeshVS_SensitiveMesh self) -> MeshVS_SensitiveMesh

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MeshVS_SensitiveMesh self) -> MeshVS_SensitiveMesh

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MeshVS_SensitiveMesh self) -> MeshVS_SensitiveMesh

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh___ref__(self, *args)


    def __hash__(self):
        return _MeshVS.Handle_MeshVS_SensitiveMesh___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MeshVS.Handle_MeshVS_SensitiveMesh___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MeshVS.new_Handle_MeshVS_SensitiveMesh(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MeshVS.Handle_MeshVS_SensitiveMesh_DownCast)
    __swig_destroy__ = _MeshVS.delete_Handle_MeshVS_SensitiveMesh

    def GetMode(self, *args):
        """
        GetMode(Handle_MeshVS_SensitiveMesh self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh_GetMode(self, *args)


    def GetConnected(self, *args):
        """
        GetConnected(Handle_MeshVS_SensitiveMesh self) -> Handle_Select3D_SensitiveEntity

        :rtype: OCC.wrapper.Select3D.Handle_Select3D_SensitiveEntity

        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh_GetConnected(self, *args)


    def NbSubElements(self, *args):
        """
        NbSubElements(Handle_MeshVS_SensitiveMesh self) -> Standard_Integer

        Returns the amount of mesh nodes

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh_NbSubElements(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_MeshVS_SensitiveMesh self) -> BVH_Box_Standard_Real_

        Returns bounding box of mesh

        :rtype: OCC.wrapper.Select3D.Select3D_BndBox3d

        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh_BoundingBox(self, *args)


    def CenterOfGeometry(self, *args):
        """
        CenterOfGeometry(Handle_MeshVS_SensitiveMesh self) -> gp_Pnt

        Returns center of mesh

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh_CenterOfGeometry(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MeshVS_SensitiveMesh self) -> char const *

        :rtype: const char *

        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_SensitiveMesh_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_SensitiveMesh_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Matches(self, *args):
        """
        Matches(Handle_MeshVS_SensitiveMesh self, SelectBasics_SelectingVolumeManager theMgr, SelectBasics_PickResult & thePickResult) -> Standard_Boolean

        Checks whether sensitive overlaps current selecting volume.
        Stores minimum depth, distance to center of geometry and
        closest point detected into thePickResult

        :type theMgr: OCC.wrapper.SelectBasics.SelectBasics_SelectingVolumeManager
        :type thePickResult: OCC.wrapper.SelectBasics.SelectBasics_PickResult
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh_Matches(self, *args)


    def BVH(self, *args):
        """
        BVH(Handle_MeshVS_SensitiveMesh self)

        Builds BVH tree for a sensitive if needed


        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh_BVH(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_MeshVS_SensitiveMesh self)

        Clears up all resources and memory


        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh_Clear(self, *args)


    def HasInitLocation(self, *args):
        """
        HasInitLocation(Handle_MeshVS_SensitiveMesh self) -> Standard_Boolean

        Returns true if the shape corresponding to the entity has init location

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh_HasInitLocation(self, *args)


    def InvInitLocation(self, *args):
        """
        InvInitLocation(Handle_MeshVS_SensitiveMesh self) -> gp_GTrsf

        Returns inversed location transformation matrix if the shape corresponding
        to this entity has init location set. Otherwise, returns identity matrix.

        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh_InvInitLocation(self, *args)


    def Set(self, *args):
        """
        Set(Handle_MeshVS_SensitiveMesh self, Handle_SelectBasics_EntityOwner theOwnerId)

        Sets owner of the entity

        :type theOwnerId: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner

        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh_Set(self, *args)


    def OwnerId(self, *args):
        """
        Returns pointer to owner of the entity

        :rtype: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner

        """
        res = _MeshVS.Handle_MeshVS_SensitiveMesh_OwnerId(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SensitivityFactor(self, *args):
        """
        SensitivityFactor(Handle_MeshVS_SensitiveMesh self) -> Standard_Integer

        allows a better sensitivity for
        a specific entity in selection algorithms
        useful for small sized entities.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh_SensitivityFactor(self, *args)


    def SetSensitivityFactor(self, *args):
        """
        SetSensitivityFactor(Handle_MeshVS_SensitiveMesh self, Standard_Integer const theNewSens)

        Allows to manage sensitivity of a particular sensitive entity

        :type theNewSens: int

        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh_SetSensitivityFactor(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_MeshVS_SensitiveMesh self)

        Memory deallocator for transient classes


        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MeshVS_SensitiveMesh self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MeshVS_SensitiveMesh self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MeshVS_SensitiveMesh self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MeshVS_SensitiveMesh self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MeshVS_SensitiveMesh self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MeshVS_SensitiveMesh self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MeshVS_SensitiveMesh self)

        Increments the reference counter of this object


        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MeshVS_SensitiveMesh self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_SensitiveMesh_DecrementRefCounter(self, *args)

Handle_MeshVS_SensitiveMesh_swigregister = _MeshVS.Handle_MeshVS_SensitiveMesh_swigregister
Handle_MeshVS_SensitiveMesh_swigregister(Handle_MeshVS_SensitiveMesh)

def Handle_MeshVS_SensitiveMesh_DownCast(thing):
    return _MeshVS.Handle_MeshVS_SensitiveMesh_DownCast(thing)
Handle_MeshVS_SensitiveMesh_DownCast = _MeshVS.Handle_MeshVS_SensitiveMesh_DownCast

class MeshVS_Mesh(AIS.AIS_InteractiveObject):
    """the main class provides interface to create mesh presentation as a whole"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MeshVS_Mesh
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MeshVS_Mesh(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MeshVS_Mesh self, Standard_Boolean const theIsAllowOverlapped) -> MeshVS_Mesh

        Constructor.
        theIsAllowOverlapped is Standard_True, if it is allowed to draw edges overlapped with beams
        Its value is stored in drawer

        :type theIsAllowOverlapped: bool

        """
        this = _MeshVS.new_MeshVS_Mesh(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(MeshVS_Mesh self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true for supported display modes basing on a list of defined builders.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_Mesh_AcceptDisplayMode(self, *args)


    def Compute(self, *args):
        """
        Compute(MeshVS_Mesh self, Handle_PrsMgr_PresentationManager PM, Handle_Prs3d_Presentation Prs, Standard_Integer const DisplayMode)

        Computes presentation using builders added to sequence. Each builder computes
        own part of mesh presentation according to its type.

        :type PM: OCC.wrapper.MeshVS.Handle_PrsMgr_PresentationManager3d
        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type DisplayMode: int

        """
        return _MeshVS.MeshVS_Mesh_Compute(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(MeshVS_Mesh self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Owners)

        Draw selected owners presentation

        :type PM: OCC.wrapper.MeshVS.Handle_PrsMgr_PresentationManager3d
        :type Owners: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _MeshVS.MeshVS_Mesh_HilightSelected(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(MeshVS_Mesh self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theColor, Handle_SelectMgr_EntityOwner theOwner)

        Draw hilighted owner presentation

        :type thePM: OCC.wrapper.MeshVS.Handle_PrsMgr_PresentationManager3d
        :type theColor: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _MeshVS.MeshVS_Mesh_HilightOwnerWithColor(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(MeshVS_Mesh self)

        Clears internal selection presentation


        """
        return _MeshVS.MeshVS_Mesh_ClearSelected(self, *args)


    def GetBuildersCount(self, *args):
        """
        GetBuildersCount(MeshVS_Mesh self) -> Standard_Integer

        How many builders there are in sequence

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.MeshVS_Mesh_GetBuildersCount(self, *args)


    def GetBuilder(self, *args):
        """
        GetBuilder(MeshVS_Mesh self, Standard_Integer const Index) -> Handle_MeshVS_PrsBuilder

        Returns builder by its index in sequence

        :type Index: int
        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_PrsBuilder

        """
        return _MeshVS.MeshVS_Mesh_GetBuilder(self, *args)


    def GetBuilderById(self, *args):
        """
        GetBuilderById(MeshVS_Mesh self, Standard_Integer const Id) -> Handle_MeshVS_PrsBuilder

        Returns builder by its ID

        :type Id: int
        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_PrsBuilder

        """
        return _MeshVS.MeshVS_Mesh_GetBuilderById(self, *args)


    def GetFreeId(self, *args):
        """
        GetFreeId(MeshVS_Mesh self) -> Standard_Integer

        Returns the smallest positive ID, not occupied by any builder.
        This method using when builder is created with ID = -1

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.MeshVS_Mesh_GetFreeId(self, *args)


    def AddBuilder(self, *args):
        """
        AddBuilder(MeshVS_Mesh self, Handle_MeshVS_PrsBuilder Builder, Standard_Boolean const TreatAsHilighter)

        Adds builder to tale of sequence.
        PrsBuilder is builder to be added
        If TreatAsHilighter is true, MeshVS_Mesh will use this builder to create
        presentation of hilighted and selected owners.
        Only one builder can be hilighter, so that if you call this method with
        TreatAsHilighter = Standard_True some times, only last builder will be hilighter
        WARNING: As minimum one builder must be added as hilighter, otherwise selection cannot be computed

        :type Builder: OCC.wrapper.MeshVS.Handle_MeshVS_PrsBuilder
        :type TreatAsHilighter: bool

        """
        return _MeshVS.MeshVS_Mesh_AddBuilder(self, *args)


    def SetHilighter(self, *args):
        """
        SetHilighter(MeshVS_Mesh self, Handle_MeshVS_PrsBuilder Builder)
        SetHilighter(MeshVS_Mesh self, Standard_Integer const Index) -> Standard_Boolean

        Sets builder with sequence index "Index" as hilighter

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_Mesh_SetHilighter(self, *args)


    def SetHilighterById(self, *args):
        """
        SetHilighterById(MeshVS_Mesh self, Standard_Integer const Id) -> Standard_Boolean

        Sets builder with identificator "Id" as hilighter

        :type Id: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_Mesh_SetHilighterById(self, *args)


    def GetHilighter(self, *args):
        """
        GetHilighter(MeshVS_Mesh self) -> Handle_MeshVS_PrsBuilder

        Returns hilighter

        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_PrsBuilder

        """
        return _MeshVS.MeshVS_Mesh_GetHilighter(self, *args)


    def RemoveBuilder(self, *args):
        """
        RemoveBuilder(MeshVS_Mesh self, Standard_Integer const Index)

        Removes builder from sequence. If it is hilighter, hilighter will be NULL
        ( Don't remember to set it to other after!!! )

        :type Index: int

        """
        return _MeshVS.MeshVS_Mesh_RemoveBuilder(self, *args)


    def RemoveBuilderById(self, *args):
        """
        RemoveBuilderById(MeshVS_Mesh self, Standard_Integer const Id)

        Removes builder with identificator Id

        :type Id: int

        """
        return _MeshVS.MeshVS_Mesh_RemoveBuilderById(self, *args)


    def FindBuilder(self, *args):
        """
        FindBuilder(MeshVS_Mesh self, Standard_CString const TypeString) -> Handle_MeshVS_PrsBuilder

        Finds builder by its type the string represents

        :type TypeString: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_PrsBuilder

        """
        return _MeshVS.MeshVS_Mesh_FindBuilder(self, *args)


    def GetOwnerMaps(self, *args):
        """
        Returns map of owners.

        :type IsElement: bool
        :rtype: OCC.wrapper.MeshVS.MeshVS_DataMapOfIntegerOwner

        """
        res = _MeshVS.MeshVS_Mesh_GetOwnerMaps(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetDataSource(self, *args):
        """
        GetDataSource(MeshVS_Mesh self) -> Handle_MeshVS_DataSource

        Returns default builders' data source

        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource

        """
        return _MeshVS.MeshVS_Mesh_GetDataSource(self, *args)


    def SetDataSource(self, *args):
        """
        SetDataSource(MeshVS_Mesh self, Handle_MeshVS_DataSource aDataSource)

        Sets default builders' data source

        :type aDataSource: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource

        """
        return _MeshVS.MeshVS_Mesh_SetDataSource(self, *args)


    def GetDrawer(self, *args):
        """
        GetDrawer(MeshVS_Mesh self) -> Handle_MeshVS_Drawer

        Returns default builders' drawer

        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer

        """
        return _MeshVS.MeshVS_Mesh_GetDrawer(self, *args)


    def SetDrawer(self, *args):
        """
        SetDrawer(MeshVS_Mesh self, Handle_MeshVS_Drawer aDrawer)

        Sets default builders' drawer

        :type aDrawer: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer

        """
        return _MeshVS.MeshVS_Mesh_SetDrawer(self, *args)


    def IsHiddenElem(self, *args):
        """
        IsHiddenElem(MeshVS_Mesh self, Standard_Integer const ID) -> Standard_Boolean

        Returns True if specified element is hidden
        By default no elements are hidden

        :type ID: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_Mesh_IsHiddenElem(self, *args)


    def IsHiddenNode(self, *args):
        """
        IsHiddenNode(MeshVS_Mesh self, Standard_Integer const ID) -> Standard_Boolean

        Returns True if specified node is hidden.
        By default all nodes are hidden

        :type ID: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_Mesh_IsHiddenNode(self, *args)


    def IsSelectableElem(self, *args):
        """
        IsSelectableElem(MeshVS_Mesh self, Standard_Integer const ID) -> Standard_Boolean

        Returns True if specified element is not hidden

        :type ID: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_Mesh_IsSelectableElem(self, *args)


    def IsSelectableNode(self, *args):
        """
        IsSelectableNode(MeshVS_Mesh self, Standard_Integer const ID) -> Standard_Boolean

        Returns True if specified node is specified as selectable.

        :type ID: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_Mesh_IsSelectableNode(self, *args)


    def GetHiddenNodes(self, *args):
        """
        Returns map of hidden nodes (may be null handle)

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        res = _MeshVS.MeshVS_Mesh_GetHiddenNodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHiddenNodes(self, *args):
        """
        SetHiddenNodes(MeshVS_Mesh self, Handle_TColStd_HPackedMapOfInteger Ids)

        Sets map of hidden nodes, which shall not be displayed individually.
        If nodes shared by some elements shall not be drawn,
        they should be included into that map

        :type Ids: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        return _MeshVS.MeshVS_Mesh_SetHiddenNodes(self, *args)


    def GetHiddenElems(self, *args):
        """
        Returns map of hidden elements (may be null handle)

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        res = _MeshVS.MeshVS_Mesh_GetHiddenElems(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHiddenElems(self, *args):
        """
        SetHiddenElems(MeshVS_Mesh self, Handle_TColStd_HPackedMapOfInteger Ids)

        Sets map of hidden elements

        :type Ids: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        return _MeshVS.MeshVS_Mesh_SetHiddenElems(self, *args)


    def GetSelectableNodes(self, *args):
        """
        Returns map of selectable elements (may be null handle)

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        res = _MeshVS.MeshVS_Mesh_GetSelectableNodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSelectableNodes(self, *args):
        """
        SetSelectableNodes(MeshVS_Mesh self, Handle_TColStd_HPackedMapOfInteger Ids)

        Sets map of selectable nodes.

        :type Ids: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        return _MeshVS.MeshVS_Mesh_SetSelectableNodes(self, *args)


    def UpdateSelectableNodes(self, *args):
        """
        UpdateSelectableNodes(MeshVS_Mesh self)

        Automatically computes selectable nodes; the node is considered
        as being selectable if it is either not hidden, or is hidden
        but referred by at least one non-hidden element.
        Thus all nodes that are visible (either individually, or as ends or
        corners of elements) are selectable by default.


        """
        return _MeshVS.MeshVS_Mesh_UpdateSelectableNodes(self, *args)


    def GetMeshSelMethod(self, *args):
        """
        GetMeshSelMethod(MeshVS_Mesh self) -> MeshVS_MeshSelectionMethod

        Returns set mesh selection method (see MeshVS.cdl)

        :rtype: OCC.wrapper.MeshVS.MeshVS_MeshSelectionMethod

        """
        return _MeshVS.MeshVS_Mesh_GetMeshSelMethod(self, *args)


    def SetMeshSelMethod(self, *args):
        """
        SetMeshSelMethod(MeshVS_Mesh self, MeshVS_MeshSelectionMethod const M)

        Sets mesh selection method (see MeshVS.cdl)

        :type M: OCC.wrapper.MeshVS.MeshVS_MeshSelectionMethod

        """
        return _MeshVS.MeshVS_Mesh_SetMeshSelMethod(self, *args)


    def IsWholeMeshOwner(self, *args):
        """
        IsWholeMeshOwner(MeshVS_Mesh self, Handle_SelectMgr_EntityOwner theOwner) -> Standard_Boolean

        Returns True if the given owner represents a whole mesh.

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.MeshVS_Mesh_IsWholeMeshOwner(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MeshVS.MeshVS_Mesh_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MeshVS.MeshVS_Mesh_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.MeshVS_Mesh_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MeshVS.delete_MeshVS_Mesh
MeshVS_Mesh_swigregister = _MeshVS.MeshVS_Mesh_swigregister
MeshVS_Mesh_swigregister(MeshVS_Mesh)

def MeshVS_Mesh_get_type_name(*args):
    """
    MeshVS_Mesh_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MeshVS.MeshVS_Mesh_get_type_name(*args)

def MeshVS_Mesh_get_type_descriptor(*args):
    """
    MeshVS_Mesh_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MeshVS.MeshVS_Mesh_get_type_descriptor(*args)

class NCollection_DefaultHasher_MeshVS_TwoNodes(object):
    """
    Purpose:     The  DefaultHasher  is a  Hasher  that is used by
    default in NCollection maps. 
    To compute the  hash code of the key  is used the
    global function HashCode.
    To compare two keys is used  the  global function 
    IsEqual.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args):
        """
        HashCode(MeshVS_TwoNodes const & theKey, Standard_Integer const Upper) -> Standard_Integer

        :type theKey: const TheKeyType &
        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.NCollection_DefaultHasher_MeshVS_TwoNodes_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(MeshVS_TwoNodes const & theKey1, MeshVS_TwoNodes const & theKey2) -> Standard_Boolean

        :type theKey1: const TheKeyType &
        :type theKey2: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DefaultHasher_MeshVS_TwoNodes_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def __init__(self):
        """
        Purpose:     The  DefaultHasher  is a  Hasher  that is used by
        default in NCollection maps. 
        To compute the  hash code of the key  is used the
        global function HashCode.
        To compare two keys is used  the  global function 
        IsEqual.
        """
        this = _MeshVS.new_NCollection_DefaultHasher_MeshVS_TwoNodes()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MeshVS.delete_NCollection_DefaultHasher_MeshVS_TwoNodes
NCollection_DefaultHasher_MeshVS_TwoNodes_swigregister = _MeshVS.NCollection_DefaultHasher_MeshVS_TwoNodes_swigregister
NCollection_DefaultHasher_MeshVS_TwoNodes_swigregister(NCollection_DefaultHasher_MeshVS_TwoNodes)

def NCollection_DefaultHasher_MeshVS_TwoNodes_HashCode(*args):
    """
    NCollection_DefaultHasher_MeshVS_TwoNodes_HashCode(MeshVS_TwoNodes const & theKey, Standard_Integer const Upper) -> Standard_Integer

    :type theKey: const TheKeyType &
    :type Upper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _MeshVS.NCollection_DefaultHasher_MeshVS_TwoNodes_HashCode(*args)

def NCollection_DefaultHasher_MeshVS_TwoNodes_IsEqual(*args):
    """
    NCollection_DefaultHasher_MeshVS_TwoNodes_IsEqual(MeshVS_TwoNodes const & theKey1, MeshVS_TwoNodes const & theKey2) -> Standard_Boolean

    :type theKey1: const TheKeyType &
    :type theKey2: const TheKeyType &
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _MeshVS.NCollection_DefaultHasher_MeshVS_TwoNodes_IsEqual(*args)


try:
	MeshVS_TwoNodesHasher = NCollection_DefaultHasher_MeshVS_TwoNodes
except NameError:
	pass # does not exist, probably ignored


try:
	TColStd_SequenceOfInteger = TColStd.NCollection_Sequence_Standard_Integer
except AttributeError:
	pass # does not exist, probably ignored

class Handle_MeshVS_SensitiveQuad(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MeshVS_SensitiveQuad self)

        Nullify the handle


        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MeshVS_SensitiveQuad self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MeshVS_SensitiveQuad self, MeshVS_SensitiveQuad thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MeshVS_SensitiveQuad self, Handle_MeshVS_SensitiveQuad theHandle) -> Handle_MeshVS_SensitiveQuad
        assign(Handle_MeshVS_SensitiveQuad self, MeshVS_SensitiveQuad thePtr) -> Handle_MeshVS_SensitiveQuad
        assign(Handle_MeshVS_SensitiveQuad self, Handle_MeshVS_SensitiveQuad theHandle) -> Handle_MeshVS_SensitiveQuad

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MeshVS_SensitiveQuad self) -> MeshVS_SensitiveQuad

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MeshVS_SensitiveQuad self) -> MeshVS_SensitiveQuad

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MeshVS_SensitiveQuad self) -> MeshVS_SensitiveQuad

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad___ref__(self, *args)


    def __hash__(self):
        return _MeshVS.Handle_MeshVS_SensitiveQuad___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MeshVS.Handle_MeshVS_SensitiveQuad___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MeshVS.new_Handle_MeshVS_SensitiveQuad(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MeshVS.Handle_MeshVS_SensitiveQuad_DownCast)
    __swig_destroy__ = _MeshVS.delete_Handle_MeshVS_SensitiveQuad

    def NbSubElements(self, *args):
        """
        NbSubElements(Handle_MeshVS_SensitiveQuad self) -> Standard_Integer

        Returns the amount of sub-entities in sensitive

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad_NbSubElements(self, *args)


    def GetConnected(self, *args):
        """
        GetConnected(Handle_MeshVS_SensitiveQuad self) -> Handle_Select3D_SensitiveEntity

        Returns a copy of this sensitive quadrangle

        :rtype: OCC.wrapper.Select3D.Handle_Select3D_SensitiveEntity

        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad_GetConnected(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_MeshVS_SensitiveQuad self, SelectBasics_SelectingVolumeManager theMgr, SelectBasics_PickResult & thePickResult) -> Standard_Boolean

        Checks whether the box overlaps current selecting volume

        :type theMgr: OCC.wrapper.SelectBasics.SelectBasics_SelectingVolumeManager
        :type thePickResult: OCC.wrapper.SelectBasics.SelectBasics_PickResult
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad_Matches(self, *args)


    def CenterOfGeometry(self, *args):
        """
        CenterOfGeometry(Handle_MeshVS_SensitiveQuad self) -> gp_Pnt

        Returns center of the box

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad_CenterOfGeometry(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_MeshVS_SensitiveQuad self) -> BVH_Box_Standard_Real_

        Returns coordinates of the box

        :rtype: OCC.wrapper.Select3D.Select3D_BndBox3d

        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad_BoundingBox(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MeshVS_SensitiveQuad self) -> char const *

        :rtype: const char *

        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_SensitiveQuad_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_SensitiveQuad_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BVH(self, *args):
        """
        BVH(Handle_MeshVS_SensitiveQuad self)

        Builds BVH tree for a sensitive if needed


        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad_BVH(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_MeshVS_SensitiveQuad self)

        Clears up all resources and memory


        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad_Clear(self, *args)


    def HasInitLocation(self, *args):
        """
        HasInitLocation(Handle_MeshVS_SensitiveQuad self) -> Standard_Boolean

        Returns true if the shape corresponding to the entity has init location

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad_HasInitLocation(self, *args)


    def InvInitLocation(self, *args):
        """
        InvInitLocation(Handle_MeshVS_SensitiveQuad self) -> gp_GTrsf

        Returns inversed location transformation matrix if the shape corresponding
        to this entity has init location set. Otherwise, returns identity matrix.

        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad_InvInitLocation(self, *args)


    def Set(self, *args):
        """
        Set(Handle_MeshVS_SensitiveQuad self, Handle_SelectBasics_EntityOwner theOwnerId)

        Sets owner of the entity

        :type theOwnerId: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner

        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad_Set(self, *args)


    def OwnerId(self, *args):
        """
        Returns pointer to owner of the entity

        :rtype: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner

        """
        res = _MeshVS.Handle_MeshVS_SensitiveQuad_OwnerId(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SensitivityFactor(self, *args):
        """
        SensitivityFactor(Handle_MeshVS_SensitiveQuad self) -> Standard_Integer

        allows a better sensitivity for
        a specific entity in selection algorithms
        useful for small sized entities.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad_SensitivityFactor(self, *args)


    def SetSensitivityFactor(self, *args):
        """
        SetSensitivityFactor(Handle_MeshVS_SensitiveQuad self, Standard_Integer const theNewSens)

        Allows to manage sensitivity of a particular sensitive entity

        :type theNewSens: int

        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad_SetSensitivityFactor(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_MeshVS_SensitiveQuad self)

        Memory deallocator for transient classes


        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MeshVS_SensitiveQuad self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MeshVS_SensitiveQuad self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MeshVS_SensitiveQuad self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MeshVS_SensitiveQuad self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MeshVS_SensitiveQuad self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MeshVS_SensitiveQuad self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MeshVS_SensitiveQuad self)

        Increments the reference counter of this object


        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MeshVS_SensitiveQuad self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_SensitiveQuad_DecrementRefCounter(self, *args)

Handle_MeshVS_SensitiveQuad_swigregister = _MeshVS.Handle_MeshVS_SensitiveQuad_swigregister
Handle_MeshVS_SensitiveQuad_swigregister(Handle_MeshVS_SensitiveQuad)

def Handle_MeshVS_SensitiveQuad_DownCast(thing):
    return _MeshVS.Handle_MeshVS_SensitiveQuad_DownCast(thing)
Handle_MeshVS_SensitiveQuad_DownCast = _MeshVS.Handle_MeshVS_SensitiveQuad_DownCast

class Handle_MeshVS_DataSource3D(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MeshVS_DataSource3D self)

        Nullify the handle


        """
        return _MeshVS.Handle_MeshVS_DataSource3D_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MeshVS_DataSource3D self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MeshVS_DataSource3D self, MeshVS_DataSource3D thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MeshVS_DataSource3D self, Handle_MeshVS_DataSource3D theHandle) -> Handle_MeshVS_DataSource3D
        assign(Handle_MeshVS_DataSource3D self, MeshVS_DataSource3D thePtr) -> Handle_MeshVS_DataSource3D
        assign(Handle_MeshVS_DataSource3D self, Handle_MeshVS_DataSource3D theHandle) -> Handle_MeshVS_DataSource3D

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MeshVS_DataSource3D self) -> MeshVS_DataSource3D

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MeshVS_DataSource3D self) -> MeshVS_DataSource3D

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_DataSource3D___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MeshVS_DataSource3D self) -> MeshVS_DataSource3D

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MeshVS.Handle_MeshVS_DataSource3D___ref__(self, *args)


    def __hash__(self):
        return _MeshVS.Handle_MeshVS_DataSource3D___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MeshVS.Handle_MeshVS_DataSource3D___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MeshVS.new_Handle_MeshVS_DataSource3D(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MeshVS.Handle_MeshVS_DataSource3D_DownCast)
    __swig_destroy__ = _MeshVS.delete_Handle_MeshVS_DataSource3D

    def GetPrismTopology(self, *args):
        """
        GetPrismTopology(Handle_MeshVS_DataSource3D self, Standard_Integer const BasePoints) -> Handle_MeshVS_HArray1OfSequenceOfInteger

        :type BasePoints: int
        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_GetPrismTopology(self, *args)


    def GetPyramidTopology(self, *args):
        """
        GetPyramidTopology(Handle_MeshVS_DataSource3D self, Standard_Integer const BasePoints) -> Handle_MeshVS_HArray1OfSequenceOfInteger

        :type BasePoints: int
        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_GetPyramidTopology(self, *args)


    def CreatePrismTopology(self, *args):
        """
        CreatePrismTopology(Handle_MeshVS_DataSource3D self, Standard_Integer const BasePoints) -> Handle_MeshVS_HArray1OfSequenceOfInteger

        :type BasePoints: int
        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_CreatePrismTopology(self, *args)


    def CreatePyramidTopology(self, *args):
        """
        CreatePyramidTopology(Handle_MeshVS_DataSource3D self, Standard_Integer const BasePoints) -> Handle_MeshVS_HArray1OfSequenceOfInteger

        :type BasePoints: int
        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_CreatePyramidTopology(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MeshVS_DataSource3D self) -> char const *

        :rtype: const char *

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_DataSource3D_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_DataSource3D_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetGeom(self, *args):
        """
        GetGeom(Handle_MeshVS_DataSource3D self, Standard_Integer const ID, Standard_Boolean const IsElement, NCollection_Array1_Standard_Real Coords) -> Standard_Boolean

        Returns geometry information about node or element
        ID is the numerical identificator of node or element
        IsElement indicates this ID describe node ( if Standard_False ) or element ( if Standard_True )
        Coords is an array of co-ordinates of node(s).
        For node it is only 3 numbers: X, Y, Z in the strict order
        For element it is 3*n numbers, where n is number of this element vertices
        The order is strict also: X1, Y1, Z1, X2,...., where Xi, Yi, Zi are co-ordinates of vertices
        NbNodes is number of nodes. It is recommended this parameter to be set to 1 for node.
        Type is type of node or element (from enumeration). It is recommended this parameter to be set to
        MeshVS_ET_Node for node.

        :type ID: int
        :type IsElement: bool
        :type Coords: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NbNodes: int
        :type Type: OCC.wrapper.MeshVS.MeshVS_EntityType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_GetGeom(self, *args)


    def GetGeomType(self, *args):
        """
        GetGeomType(Handle_MeshVS_DataSource3D self, Standard_Integer const ID, Standard_Boolean const IsElement) -> Standard_Boolean

        This method is similar to GetGeom, but returns only element or node type.

        :type ID: int
        :type IsElement: bool
        :type Type: OCC.wrapper.MeshVS.MeshVS_EntityType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_GetGeomType(self, *args)


    def Get3DGeom(self, *args):
        """
        Get3DGeom(Handle_MeshVS_DataSource3D self, Standard_Integer const ID, Handle_MeshVS_HArray1OfSequenceOfInteger Data) -> Standard_Boolean

        This method returns topology information about 3D-element
        Returns false if element with ID isn't 3D or because other troubles

        :type ID: int
        :type NbNodes: int
        :type Data: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_Get3DGeom(self, *args)


    def GetAddr(self, *args):
        """
        GetAddr(Handle_MeshVS_DataSource3D self, Standard_Integer const ID, Standard_Boolean const IsElement) -> Standard_Address

        This method returns pointer which represents element or node data structure.
        This address will be saved in MeshVS_MeshEntityOwner, so that you can access to data structure fast
        by the method Owner(). In the redefined method you can return NULL.
        ID is the numerical identificator of node or element
        IsElement indicates this ID describe node ( if Standard_False ) or element ( if Standard_True )

        :type ID: int
        :type IsElement: bool
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_GetAddr(self, *args)


    def GetNodesByElement(self, *args):
        """
        GetNodesByElement(Handle_MeshVS_DataSource3D self, Standard_Integer const ID, NCollection_Array1_Standard_Integer NodeIDs) -> Standard_Boolean

        This method returns information about nodes this element consist of.
        ID is the numerical identificator of element.
        NodeIDs is the output array of nodes IDs in correct order,
        the same as coordinates returned by GetGeom().
        NbNodes is number of nodes (number of items set in NodeIDs).
        Returns False if element does not exist

        :type ID: int
        :type NodeIDs: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type NbNodes: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_GetNodesByElement(self, *args)


    def GetAllNodes(self, *args):
        """
        This method returns map of all nodes the object consist of.

        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        res = _MeshVS.Handle_MeshVS_DataSource3D_GetAllNodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetAllElements(self, *args):
        """
        This method returns map of all elements the object consist of.

        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        res = _MeshVS.Handle_MeshVS_DataSource3D_GetAllElements(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetNormal(self, *args):
        """
        GetNormal(Handle_MeshVS_DataSource3D self, Standard_Integer const Id, Standard_Integer const Max) -> Standard_Boolean

        This method calculates normal of face, which is using for correct reflection presentation.
        There is default method, for advance reflection this method can be redefined.
        Id is the numerical identificator of only element!
        Max is maximal number of nodes an element can consist of
        nx, ny, nz  are values whose represent co-ordinates of normal (will be returned)
        In the redefined method you can return normal with length more then 1, but in this case
        the appearance of element will be more bright than usual. For ordinary brightness you must return
        normal with length 1

        :type Id: int
        :type Max: int
        :type nx: float
        :type ny: float
        :type nz: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_GetNormal(self, *args)


    def GetNodeNormal(self, *args):
        """
        GetNodeNormal(Handle_MeshVS_DataSource3D self, Standard_Integer const ranknode, Standard_Integer const ElementId) -> Standard_Boolean

        This method return normal of node ranknode of face Id,
        which is using for smooth shading presentation.
        Returns false if normal isn't defined.

        :type ranknode: int
        :type ElementId: int
        :type nx: float
        :type ny: float
        :type nz: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_GetNodeNormal(self, *args)


    def GetNormalsByElement(self, *args):
        """
        GetNormalsByElement(Handle_MeshVS_DataSource3D self, Standard_Integer const Id, Standard_Boolean const IsNodal, Standard_Integer const MaxNodes, Handle_TColStd_HArray1OfReal Normals) -> Standard_Boolean

        This method puts components of normal vectors at each node of a mesh face (at each face of a mesh volume)
        into the output array.
        Returns false if some problem was detected during calculation of normals.
        Id is an identifier of the mesh element.
        IsNodal, when true, means that normals at mesh element nodes are needed. If nodal normals
        are not available, or IsNodal is false, or the mesh element is a volume, then the output array contents
        depend on the element type:
        face: a normal calculated by GetNormal() is duplicated for each node of the face;
        volume: normals to all faces of the volume are computed (not for each node!).
        MaxNodes is maximal number of nodes an element can consist of.
        Normals contains the result.

        :type Id: int
        :type IsNodal: bool
        :type MaxNodes: int
        :type Normals: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_GetNormalsByElement(self, *args)


    def GetAllGroups(self, *args):
        """
        GetAllGroups(Handle_MeshVS_DataSource3D self, TColStd_PackedMapOfInteger Ids)

        This method returns map of all groups the object contains.

        :type Ids: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_GetAllGroups(self, *args)


    def GetGroup(self, *args):
        """
        GetGroup(Handle_MeshVS_DataSource3D self, Standard_Integer const Id, TColStd_PackedMapOfInteger Ids) -> Standard_Boolean

        This method returns map of all group elements.

        :type Id: int
        :type Type: OCC.wrapper.MeshVS.MeshVS_EntityType
        :type Ids: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_GetGroup(self, *args)


    def GetGroupAddr(self, *args):
        """
        GetGroupAddr(Handle_MeshVS_DataSource3D self, Standard_Integer const ID) -> Standard_Address

        This method returns pointer which represents group data structure.
        This address will be saved in MeshVS_MeshOwner, so that you can access to data structure fast
        by the method Owner(). In the redefined method you can return NULL.
        ID is the numerical identificator of group

        :type ID: int
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_GetGroupAddr(self, *args)


    def IsAdvancedSelectionEnabled(self, *args):
        """
        IsAdvancedSelectionEnabled(Handle_MeshVS_DataSource3D self) -> Standard_Boolean

        Returns True if advanced mesh selection is enabled.
        Default implementation returns False.
        It should be redefined to return True for advanced
        mesh selection activation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_IsAdvancedSelectionEnabled(self, *args)


    def GetBoundingBox(self, *args):
        """
        GetBoundingBox(Handle_MeshVS_DataSource3D self) -> Bnd_Box

        Returns the bounding box of the whole mesh.
        It is used in advanced selection mode to define roughly
        the sensitive area of the mesh.
        It can be redefined to get access to a box computed in advance.

        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_GetBoundingBox(self, *args)


    def GetDetectedEntities(self, *args):
        """
        GetDetectedEntities(Handle_MeshVS_DataSource3D self, Handle_MeshVS_Mesh Prs, Standard_Real const X, Standard_Real const Y, Standard_Real const aTol, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elements) -> Standard_Boolean
        GetDetectedEntities(Handle_MeshVS_DataSource3D self, Handle_MeshVS_Mesh Prs, Standard_Real const XMin, Standard_Real const YMin, Standard_Real const XMax, Standard_Real const YMax, Standard_Real const aTol, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elements) -> Standard_Boolean
        GetDetectedEntities(Handle_MeshVS_DataSource3D self, Handle_MeshVS_Mesh Prs, NCollection_Array1_gp_Pnt2d Polyline, Bnd_Box2d aBox, Standard_Real const aTol, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elements) -> Standard_Boolean
        GetDetectedEntities(Handle_MeshVS_DataSource3D self, Handle_MeshVS_Mesh Prs, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elements) -> Standard_Boolean

        Filter out the maps of mesh entities so as to keep
        only the entities that are allowed to be selected
        according to the current context.
        Returns True if any of the maps has been changed.
        It should be redefined if the advanced mesh selection is
        activated. Default implementation returns False.

        :type Prs: OCC.wrapper.MeshVS.Handle_MeshVS_Mesh
        :type Nodes: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger
        :type Elements: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_GetDetectedEntities(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_MeshVS_DataSource3D self)

        Memory deallocator for transient classes


        """
        return _MeshVS.Handle_MeshVS_DataSource3D_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MeshVS_DataSource3D self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MeshVS_DataSource3D self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MeshVS_DataSource3D self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MeshVS_DataSource3D self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MeshVS_DataSource3D self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MeshVS_DataSource3D self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MeshVS_DataSource3D self)

        Increments the reference counter of this object


        """
        return _MeshVS.Handle_MeshVS_DataSource3D_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MeshVS_DataSource3D self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_DataSource3D_DecrementRefCounter(self, *args)

Handle_MeshVS_DataSource3D_swigregister = _MeshVS.Handle_MeshVS_DataSource3D_swigregister
Handle_MeshVS_DataSource3D_swigregister(Handle_MeshVS_DataSource3D)

def Handle_MeshVS_DataSource3D_DownCast(thing):
    return _MeshVS.Handle_MeshVS_DataSource3D_DownCast(thing)
Handle_MeshVS_DataSource3D_DownCast = _MeshVS.Handle_MeshVS_DataSource3D_DownCast

class NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TCollection_AsciiString,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TCollection_AsciiString,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TCollection_AsciiString,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TCollection_AsciiString,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _MeshVS.new_NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher self, int const & theKey, TCollection_AsciiString theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher self, int const & theKey, TCollection_AsciiString theItem) -> TCollection_AsciiString

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher self, int const & theKey) -> TCollection_AsciiString

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher self, int const & theKey) -> TCollection_AsciiString

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher self, int const & theKey) -> TCollection_AsciiString

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MeshVS.NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _MeshVS.NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _MeshVS.delete_NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_swigregister = _MeshVS.NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _MeshVS.new_NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MeshVS.delete_NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _MeshVS.NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _MeshVS.NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher_IteratorHelper)


try:
	MeshVS_DataMapOfIntegerAsciiString = NCollection_DataMap_Standard_Integer_TCollection_AsciiString_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_MeshVS_ElementalColorPrsBuilder(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MeshVS_ElementalColorPrsBuilder self)

        Nullify the handle


        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MeshVS_ElementalColorPrsBuilder self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MeshVS_ElementalColorPrsBuilder self, MeshVS_ElementalColorPrsBuilder thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MeshVS_ElementalColorPrsBuilder self, Handle_MeshVS_ElementalColorPrsBuilder theHandle) -> Handle_MeshVS_ElementalColorPrsBuilder
        assign(Handle_MeshVS_ElementalColorPrsBuilder self, MeshVS_ElementalColorPrsBuilder thePtr) -> Handle_MeshVS_ElementalColorPrsBuilder
        assign(Handle_MeshVS_ElementalColorPrsBuilder self, Handle_MeshVS_ElementalColorPrsBuilder theHandle) -> Handle_MeshVS_ElementalColorPrsBuilder

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MeshVS_ElementalColorPrsBuilder self) -> MeshVS_ElementalColorPrsBuilder

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MeshVS_ElementalColorPrsBuilder self) -> MeshVS_ElementalColorPrsBuilder

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MeshVS_ElementalColorPrsBuilder self) -> MeshVS_ElementalColorPrsBuilder

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder___ref__(self, *args)


    def __hash__(self):
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MeshVS.new_Handle_MeshVS_ElementalColorPrsBuilder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_DownCast)
    __swig_destroy__ = _MeshVS.delete_Handle_MeshVS_ElementalColorPrsBuilder

    def Build(self, *args):
        """
        Build(Handle_MeshVS_ElementalColorPrsBuilder self, Handle_Prs3d_Presentation Prs, TColStd_PackedMapOfInteger IDs, TColStd_PackedMapOfInteger IDsToExclude, Standard_Boolean const IsElement, Standard_Integer const DisplayMode)

        Builds presentation of elements with assigned colors.

        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type IDs: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IDsToExclude: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IsElement: bool
        :type DisplayMode: int

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_Build(self, *args)


    def GetColors1(self, *args):
        """
        Returns map of colors same for front and back side of face.

        :rtype: OCC.wrapper.MeshVS.MeshVS_DataMapOfIntegerColor

        """
        res = _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_GetColors1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColors1(self, *args):
        """
        SetColors1(Handle_MeshVS_ElementalColorPrsBuilder self, NCollection_DataMap_Standard_Integer_Quantity_Color_TColStd_MapIntegerHasher Map)

        Sets map of colors same for front and back side of face.

        :type Map: OCC.wrapper.MeshVS.MeshVS_DataMapOfIntegerColor

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_SetColors1(self, *args)


    def HasColors1(self, *args):
        """
        HasColors1(Handle_MeshVS_ElementalColorPrsBuilder self) -> Standard_Boolean

        Returns true, if map of colors isn't empty

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_HasColors1(self, *args)


    def GetColor1(self, *args):
        """
        GetColor1(Handle_MeshVS_ElementalColorPrsBuilder self, Standard_Integer const ID, Quantity_Color theColor) -> Standard_Boolean

        Returns color assigned with element number ID

        :type ID: int
        :type theColor: OCC.wrapper.Quantity.Quantity_Color
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_GetColor1(self, *args)


    def SetColor1(self, *args):
        """
        SetColor1(Handle_MeshVS_ElementalColorPrsBuilder self, Standard_Integer const ID, Quantity_Color theColor)

        Sets color assigned with element number ID

        :type ID: int
        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_SetColor1(self, *args)


    def GetColors2(self, *args):
        """
        Returns map of different colors for front and back side of face

        :rtype: OCC.wrapper.MeshVS.MeshVS_DataMapOfIntegerTwoColors

        """
        res = _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_GetColors2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetColors2(self, *args):
        """
        SetColors2(Handle_MeshVS_ElementalColorPrsBuilder self, MeshVS_DataMapOfIntegerTwoColors const & Map)

        Sets map of different colors for front and back side of face

        :type Map: OCC.wrapper.MeshVS.MeshVS_DataMapOfIntegerTwoColors

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_SetColors2(self, *args)


    def HasColors2(self, *args):
        """
        HasColors2(Handle_MeshVS_ElementalColorPrsBuilder self) -> Standard_Boolean

        Returns true, if map isn't empty

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_HasColors2(self, *args)


    def GetColor2(self, *args):
        """
        GetColor2(Handle_MeshVS_ElementalColorPrsBuilder self, Standard_Integer const ID, MeshVS_TwoColors & theColor) -> Standard_Boolean
        GetColor2(Handle_MeshVS_ElementalColorPrsBuilder self, Standard_Integer const ID, Quantity_Color theColor1, Quantity_Color theColor2) -> Standard_Boolean

        Returns colors assigned with element number ID
        theColor1 is the front element color
        theColor2 is the back element color

        :type ID: int
        :type theColor1: OCC.wrapper.Quantity.Quantity_Color
        :type theColor2: OCC.wrapper.Quantity.Quantity_Color
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_GetColor2(self, *args)


    def SetColor2(self, *args):
        """
        SetColor2(Handle_MeshVS_ElementalColorPrsBuilder self, Standard_Integer const ID, MeshVS_TwoColors const & theTwoColors)
        SetColor2(Handle_MeshVS_ElementalColorPrsBuilder self, Standard_Integer const ID, Quantity_Color theColor1, Quantity_Color theColor2)

        Sets color assigned with element number ID
        theColor1 is the front element color
        theColor2 is the back element color

        :type ID: int
        :type theColor1: OCC.wrapper.Quantity.Quantity_Color
        :type theColor2: OCC.wrapper.Quantity.Quantity_Color

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_SetColor2(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MeshVS_ElementalColorPrsBuilder self) -> char const *

        :rtype: const char *

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CustomBuild(self, *args):
        """
        CustomBuild(Handle_MeshVS_ElementalColorPrsBuilder self, Handle_Prs3d_Presentation Prs, TColStd_PackedMapOfInteger IDs, TColStd_PackedMapOfInteger IDsToExclude, Standard_Integer const DisplayMode)

        This method is called to build presentation of custom elements (they have MeshVS_ET_0D type).
        IDs is set of numeric identificators of elements for custom building.
        IDsToExclude is set of IDs to exclude from processing. If some entity
        has been excluded, it is not processed by other builders.
        DisplayMode is numeric constant describing display mode (see MeshVS_DisplayModeFlags.hxx)

        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type IDs: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type IDsToExclude: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type DisplayMode: int

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_CustomBuild(self, *args)


    def CustomSensitiveEntity(self, *args):
        """
        CustomSensitiveEntity(Handle_MeshVS_ElementalColorPrsBuilder self, Handle_SelectBasics_EntityOwner Owner, Standard_Integer const SelectMode) -> Handle_SelectBasics_SensitiveEntity

        This method is called to build sensitive of custom elements ( they have MeshVS_ET_0D type )

        :type Owner: OCC.wrapper.SelectBasics.Handle_SelectBasics_EntityOwner
        :type SelectMode: int
        :rtype: OCC.wrapper.SelectBasics.Handle_SelectBasics_SensitiveEntity

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_CustomSensitiveEntity(self, *args)


    def GetFlags(self, *args):
        """
        GetFlags(Handle_MeshVS_ElementalColorPrsBuilder self) -> Standard_Integer

        Returns flags, assigned with builder during creation

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_GetFlags(self, *args)


    def TestFlags(self, *args):
        """
        TestFlags(Handle_MeshVS_ElementalColorPrsBuilder self, Standard_Integer const DisplayMode) -> Standard_Boolean

        Test whether display mode has flags assigned with this builder.
        This method has default implementation and can be redefined for advance behavior
        Returns Standard_True only if display mode is appropriate for this builder

        :type DisplayMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_TestFlags(self, *args)


    def GetId(self, *args):
        """
        GetId(Handle_MeshVS_ElementalColorPrsBuilder self) -> Standard_Integer

        Returns builder ID

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_GetId(self, *args)


    def GetPriority(self, *args):
        """
        GetPriority(Handle_MeshVS_ElementalColorPrsBuilder self) -> Standard_Integer

        Returns priority; as priority bigger, as soon builder will be called.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_GetPriority(self, *args)


    def GetDataSource(self, *args):
        """
        GetDataSource(Handle_MeshVS_ElementalColorPrsBuilder self) -> Handle_MeshVS_DataSource

        Returns custom data source or default ( from MeshVS_Mesh ) if custom is NULL

        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_GetDataSource(self, *args)


    def SetDataSource(self, *args):
        """
        SetDataSource(Handle_MeshVS_ElementalColorPrsBuilder self, Handle_MeshVS_DataSource newDS)

        Change custom data source

        :type newDS: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_SetDataSource(self, *args)


    def GetDrawer(self, *args):
        """
        GetDrawer(Handle_MeshVS_ElementalColorPrsBuilder self) -> Handle_MeshVS_Drawer

        Returns custom drawer or default ( from MeshVS_Mesh ) if custom is NULL

        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_GetDrawer(self, *args)


    def SetDrawer(self, *args):
        """
        SetDrawer(Handle_MeshVS_ElementalColorPrsBuilder self, Handle_MeshVS_Drawer newDr)

        Change custom drawer

        :type newDr: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_SetDrawer(self, *args)


    def SetExcluding(self, *args):
        """
        SetExcluding(Handle_MeshVS_ElementalColorPrsBuilder self, Standard_Boolean const state)

        Set excluding state. If it is Standard_True, the nodes or elements, processed by current builder
        will be noted and next builder won't process its.

        :type state: bool

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_SetExcluding(self, *args)


    def IsExcludingOn(self, *args):
        """
        IsExcludingOn(Handle_MeshVS_ElementalColorPrsBuilder self) -> Standard_Boolean

        Read excluding state

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_IsExcludingOn(self, *args)


    def SetPresentationManager(self, *args):
        """
        SetPresentationManager(Handle_MeshVS_ElementalColorPrsBuilder self, Handle_PrsMgr_PresentationManager thePrsMgr)

        Set presentation manager for builder

        :type thePrsMgr: OCC.wrapper.MeshVS.Handle_PrsMgr_PresentationManager3d

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_SetPresentationManager(self, *args)


    def GetPresentationManager(self, *args):
        """
        GetPresentationManager(Handle_MeshVS_ElementalColorPrsBuilder self) -> Handle_PrsMgr_PresentationManager

        Get presentation manager of builder

        :rtype: OCC.wrapper.MeshVS.Handle_PrsMgr_PresentationManager3d

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_GetPresentationManager(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_MeshVS_ElementalColorPrsBuilder self)

        Memory deallocator for transient classes


        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MeshVS_ElementalColorPrsBuilder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MeshVS_ElementalColorPrsBuilder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MeshVS_ElementalColorPrsBuilder self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MeshVS_ElementalColorPrsBuilder self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MeshVS_ElementalColorPrsBuilder self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MeshVS_ElementalColorPrsBuilder self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MeshVS_ElementalColorPrsBuilder self)

        Increments the reference counter of this object


        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MeshVS_ElementalColorPrsBuilder self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_DecrementRefCounter(self, *args)

Handle_MeshVS_ElementalColorPrsBuilder_swigregister = _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_swigregister
Handle_MeshVS_ElementalColorPrsBuilder_swigregister(Handle_MeshVS_ElementalColorPrsBuilder)

def Handle_MeshVS_ElementalColorPrsBuilder_DownCast(thing):
    return _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_DownCast(thing)
Handle_MeshVS_ElementalColorPrsBuilder_DownCast = _MeshVS.Handle_MeshVS_ElementalColorPrsBuilder_DownCast

class Handle_MeshVS_Mesh(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MeshVS_Mesh self)

        Nullify the handle


        """
        return _MeshVS.Handle_MeshVS_Mesh_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MeshVS_Mesh self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MeshVS.Handle_MeshVS_Mesh_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MeshVS_Mesh self, MeshVS_Mesh thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MeshVS.Handle_MeshVS_Mesh_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MeshVS_Mesh self, Handle_MeshVS_Mesh theHandle) -> Handle_MeshVS_Mesh
        assign(Handle_MeshVS_Mesh self, MeshVS_Mesh thePtr) -> Handle_MeshVS_Mesh
        assign(Handle_MeshVS_Mesh self, Handle_MeshVS_Mesh theHandle) -> Handle_MeshVS_Mesh

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MeshVS.Handle_MeshVS_Mesh_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MeshVS_Mesh self) -> MeshVS_Mesh

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_Mesh_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MeshVS_Mesh self) -> MeshVS_Mesh

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MeshVS.Handle_MeshVS_Mesh___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MeshVS_Mesh self) -> MeshVS_Mesh

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MeshVS.Handle_MeshVS_Mesh___ref__(self, *args)


    def __hash__(self):
        return _MeshVS.Handle_MeshVS_Mesh___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MeshVS.Handle_MeshVS_Mesh___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MeshVS.new_Handle_MeshVS_Mesh(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MeshVS.Handle_MeshVS_Mesh_DownCast)
    __swig_destroy__ = _MeshVS.delete_Handle_MeshVS_Mesh

    def AcceptDisplayMode(self, *args):
        """
        AcceptDisplayMode(Handle_MeshVS_Mesh self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true for supported display modes basing on a list of defined builders.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_AcceptDisplayMode(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_MeshVS_Mesh self, Handle_PrsMgr_PresentationManager PM, Handle_Prs3d_Presentation Prs, Standard_Integer const DisplayMode)

        Computes presentation using builders added to sequence. Each builder computes
        own part of mesh presentation according to its type.

        :type PM: OCC.wrapper.MeshVS.Handle_PrsMgr_PresentationManager3d
        :type Prs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type DisplayMode: int

        """
        return _MeshVS.Handle_MeshVS_Mesh_Compute(self, *args)


    def HilightSelected(self, *args):
        """
        HilightSelected(Handle_MeshVS_Mesh self, Handle_PrsMgr_PresentationManager PM, NCollection_Sequence_Handle_SelectMgr_EntityOwner Owners)

        Draw selected owners presentation

        :type PM: OCC.wrapper.MeshVS.Handle_PrsMgr_PresentationManager3d
        :type Owners: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfOwner

        """
        return _MeshVS.Handle_MeshVS_Mesh_HilightSelected(self, *args)


    def HilightOwnerWithColor(self, *args):
        """
        HilightOwnerWithColor(Handle_MeshVS_Mesh self, Handle_PrsMgr_PresentationManager thePM, Handle_Prs3d_Drawer theColor, Handle_SelectMgr_EntityOwner theOwner)

        Draw hilighted owner presentation

        :type thePM: OCC.wrapper.MeshVS.Handle_PrsMgr_PresentationManager3d
        :type theColor: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _MeshVS.Handle_MeshVS_Mesh_HilightOwnerWithColor(self, *args)


    def ClearSelected(self, *args):
        """
        ClearSelected(Handle_MeshVS_Mesh self)

        Clears internal selection presentation


        """
        return _MeshVS.Handle_MeshVS_Mesh_ClearSelected(self, *args)


    def GetBuildersCount(self, *args):
        """
        GetBuildersCount(Handle_MeshVS_Mesh self) -> Standard_Integer

        How many builders there are in sequence

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_Mesh_GetBuildersCount(self, *args)


    def GetBuilder(self, *args):
        """
        GetBuilder(Handle_MeshVS_Mesh self, Standard_Integer const Index) -> Handle_MeshVS_PrsBuilder

        Returns builder by its index in sequence

        :type Index: int
        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_PrsBuilder

        """
        return _MeshVS.Handle_MeshVS_Mesh_GetBuilder(self, *args)


    def GetBuilderById(self, *args):
        """
        GetBuilderById(Handle_MeshVS_Mesh self, Standard_Integer const Id) -> Handle_MeshVS_PrsBuilder

        Returns builder by its ID

        :type Id: int
        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_PrsBuilder

        """
        return _MeshVS.Handle_MeshVS_Mesh_GetBuilderById(self, *args)


    def GetFreeId(self, *args):
        """
        GetFreeId(Handle_MeshVS_Mesh self) -> Standard_Integer

        Returns the smallest positive ID, not occupied by any builder.
        This method using when builder is created with ID = -1

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_Mesh_GetFreeId(self, *args)


    def AddBuilder(self, *args):
        """
        AddBuilder(Handle_MeshVS_Mesh self, Handle_MeshVS_PrsBuilder Builder, Standard_Boolean const TreatAsHilighter)

        Adds builder to tale of sequence.
        PrsBuilder is builder to be added
        If TreatAsHilighter is true, MeshVS_Mesh will use this builder to create
        presentation of hilighted and selected owners.
        Only one builder can be hilighter, so that if you call this method with
        TreatAsHilighter = Standard_True some times, only last builder will be hilighter
        WARNING: As minimum one builder must be added as hilighter, otherwise selection cannot be computed

        :type Builder: OCC.wrapper.MeshVS.Handle_MeshVS_PrsBuilder
        :type TreatAsHilighter: bool

        """
        return _MeshVS.Handle_MeshVS_Mesh_AddBuilder(self, *args)


    def SetHilighter(self, *args):
        """
        SetHilighter(Handle_MeshVS_Mesh self, Handle_MeshVS_PrsBuilder Builder)
        SetHilighter(Handle_MeshVS_Mesh self, Standard_Integer const Index) -> Standard_Boolean

        Sets builder with sequence index "Index" as hilighter

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetHilighter(self, *args)


    def SetHilighterById(self, *args):
        """
        SetHilighterById(Handle_MeshVS_Mesh self, Standard_Integer const Id) -> Standard_Boolean

        Sets builder with identificator "Id" as hilighter

        :type Id: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetHilighterById(self, *args)


    def GetHilighter(self, *args):
        """
        GetHilighter(Handle_MeshVS_Mesh self) -> Handle_MeshVS_PrsBuilder

        Returns hilighter

        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_PrsBuilder

        """
        return _MeshVS.Handle_MeshVS_Mesh_GetHilighter(self, *args)


    def RemoveBuilder(self, *args):
        """
        RemoveBuilder(Handle_MeshVS_Mesh self, Standard_Integer const Index)

        Removes builder from sequence. If it is hilighter, hilighter will be NULL
        ( Don't remember to set it to other after!!! )

        :type Index: int

        """
        return _MeshVS.Handle_MeshVS_Mesh_RemoveBuilder(self, *args)


    def RemoveBuilderById(self, *args):
        """
        RemoveBuilderById(Handle_MeshVS_Mesh self, Standard_Integer const Id)

        Removes builder with identificator Id

        :type Id: int

        """
        return _MeshVS.Handle_MeshVS_Mesh_RemoveBuilderById(self, *args)


    def FindBuilder(self, *args):
        """
        FindBuilder(Handle_MeshVS_Mesh self, Standard_CString const TypeString) -> Handle_MeshVS_PrsBuilder

        Finds builder by its type the string represents

        :type TypeString: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_PrsBuilder

        """
        return _MeshVS.Handle_MeshVS_Mesh_FindBuilder(self, *args)


    def GetOwnerMaps(self, *args):
        """
        Returns map of owners.

        :type IsElement: bool
        :rtype: OCC.wrapper.MeshVS.MeshVS_DataMapOfIntegerOwner

        """
        res = _MeshVS.Handle_MeshVS_Mesh_GetOwnerMaps(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetDataSource(self, *args):
        """
        GetDataSource(Handle_MeshVS_Mesh self) -> Handle_MeshVS_DataSource

        Returns default builders' data source

        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource

        """
        return _MeshVS.Handle_MeshVS_Mesh_GetDataSource(self, *args)


    def SetDataSource(self, *args):
        """
        SetDataSource(Handle_MeshVS_Mesh self, Handle_MeshVS_DataSource aDataSource)

        Sets default builders' data source

        :type aDataSource: OCC.wrapper.MeshVS.Handle_MeshVS_DataSource

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetDataSource(self, *args)


    def GetDrawer(self, *args):
        """
        GetDrawer(Handle_MeshVS_Mesh self) -> Handle_MeshVS_Drawer

        Returns default builders' drawer

        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer

        """
        return _MeshVS.Handle_MeshVS_Mesh_GetDrawer(self, *args)


    def SetDrawer(self, *args):
        """
        SetDrawer(Handle_MeshVS_Mesh self, Handle_MeshVS_Drawer aDrawer)

        Sets default builders' drawer

        :type aDrawer: OCC.wrapper.MeshVS.Handle_MeshVS_Drawer

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetDrawer(self, *args)


    def IsHiddenElem(self, *args):
        """
        IsHiddenElem(Handle_MeshVS_Mesh self, Standard_Integer const ID) -> Standard_Boolean

        Returns True if specified element is hidden
        By default no elements are hidden

        :type ID: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_IsHiddenElem(self, *args)


    def IsHiddenNode(self, *args):
        """
        IsHiddenNode(Handle_MeshVS_Mesh self, Standard_Integer const ID) -> Standard_Boolean

        Returns True if specified node is hidden.
        By default all nodes are hidden

        :type ID: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_IsHiddenNode(self, *args)


    def IsSelectableElem(self, *args):
        """
        IsSelectableElem(Handle_MeshVS_Mesh self, Standard_Integer const ID) -> Standard_Boolean

        Returns True if specified element is not hidden

        :type ID: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_IsSelectableElem(self, *args)


    def IsSelectableNode(self, *args):
        """
        IsSelectableNode(Handle_MeshVS_Mesh self, Standard_Integer const ID) -> Standard_Boolean

        Returns True if specified node is specified as selectable.

        :type ID: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_IsSelectableNode(self, *args)


    def GetHiddenNodes(self, *args):
        """
        Returns map of hidden nodes (may be null handle)

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        res = _MeshVS.Handle_MeshVS_Mesh_GetHiddenNodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHiddenNodes(self, *args):
        """
        SetHiddenNodes(Handle_MeshVS_Mesh self, Handle_TColStd_HPackedMapOfInteger Ids)

        Sets map of hidden nodes, which shall not be displayed individually.
        If nodes shared by some elements shall not be drawn,
        they should be included into that map

        :type Ids: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetHiddenNodes(self, *args)


    def GetHiddenElems(self, *args):
        """
        Returns map of hidden elements (may be null handle)

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        res = _MeshVS.Handle_MeshVS_Mesh_GetHiddenElems(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHiddenElems(self, *args):
        """
        SetHiddenElems(Handle_MeshVS_Mesh self, Handle_TColStd_HPackedMapOfInteger Ids)

        Sets map of hidden elements

        :type Ids: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetHiddenElems(self, *args)


    def GetSelectableNodes(self, *args):
        """
        Returns map of selectable elements (may be null handle)

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        res = _MeshVS.Handle_MeshVS_Mesh_GetSelectableNodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSelectableNodes(self, *args):
        """
        SetSelectableNodes(Handle_MeshVS_Mesh self, Handle_TColStd_HPackedMapOfInteger Ids)

        Sets map of selectable nodes.

        :type Ids: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetSelectableNodes(self, *args)


    def UpdateSelectableNodes(self, *args):
        """
        UpdateSelectableNodes(Handle_MeshVS_Mesh self)

        Automatically computes selectable nodes; the node is considered
        as being selectable if it is either not hidden, or is hidden
        but referred by at least one non-hidden element.
        Thus all nodes that are visible (either individually, or as ends or
        corners of elements) are selectable by default.


        """
        return _MeshVS.Handle_MeshVS_Mesh_UpdateSelectableNodes(self, *args)


    def GetMeshSelMethod(self, *args):
        """
        GetMeshSelMethod(Handle_MeshVS_Mesh self) -> MeshVS_MeshSelectionMethod

        Returns set mesh selection method (see MeshVS.cdl)

        :rtype: OCC.wrapper.MeshVS.MeshVS_MeshSelectionMethod

        """
        return _MeshVS.Handle_MeshVS_Mesh_GetMeshSelMethod(self, *args)


    def SetMeshSelMethod(self, *args):
        """
        SetMeshSelMethod(Handle_MeshVS_Mesh self, MeshVS_MeshSelectionMethod const M)

        Sets mesh selection method (see MeshVS.cdl)

        :type M: OCC.wrapper.MeshVS.MeshVS_MeshSelectionMethod

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetMeshSelMethod(self, *args)


    def IsWholeMeshOwner(self, *args):
        """
        IsWholeMeshOwner(Handle_MeshVS_Mesh self, Handle_SelectMgr_EntityOwner theOwner) -> Standard_Boolean

        Returns True if the given owner represents a whole mesh.

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_IsWholeMeshOwner(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MeshVS_Mesh self) -> char const *

        :rtype: const char *

        """
        return _MeshVS.Handle_MeshVS_Mesh_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_Mesh_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MeshVS.Handle_MeshVS_Mesh_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Type(self, *args):
        """
        Type(Handle_MeshVS_Mesh self) -> AIS_KindOfInteractive

        Returns the kind of Interactive Object:
        -   None
        -   Datum
        -   Relation
        -   Object
        By default, the   interactive object has a None type.
        Because specific shapes entail different behavior
        according to their sub-shapes, you may need to
        create a Local Context. This will allow you to
        specify the additional characteristics which you
        need to handle these shapes.

        :rtype: OCC.wrapper.AIS.AIS_KindOfInteractive

        """
        return _MeshVS.Handle_MeshVS_Mesh_Type(self, *args)


    def Signature(self, *args):
        """
        Signature(Handle_MeshVS_Mesh self) -> Standard_Integer

        Specifies additional characteristics of Interactive
        Objects. A signature is, in fact, an index with integer
        values assigned different properties.
        This method is frequently used in conjuction with
        Type to give a particular type and signature to an
        Interactive Object. By default, the Interactive Object
        has a None type and a signature of 0. Among the
        datums, this signature is attributed to the shape
        The remaining datums have the following default signatures:
        -   Point                   signature 1
        -   Axis                     signature 2
        -   Trihedron                signature 3
        -   PlaneTrihedron            signature 4
        -   Line                     signature 5
        -   Circle                  signature 6
        -   Plane                   signature 7.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_Mesh_Signature(self, *args)


    def AcceptShapeDecomposition(self, *args):
        """
        AcceptShapeDecomposition(Handle_MeshVS_Mesh self) -> Standard_Boolean

        Informs the graphic context that the interactive Object
        may be decomposed into sub-shapes for dynamic selection.
        The most used Interactive Object is AIS_Shape.
        Activation methods for standard selection modes are
        proposed in the Interactive Context. These include
        selection by vertex or by edges. For datums with the
        same behavior as AIS_Shape, such as vetices and
        edges, we must redefine the virtual method so that
        AcceptShapeDecomposition returns false.
        Rule for selection :
        Mode 0 :  Selection of  the interactive Object itself
        Mode 1 :  Selection of vertices
        Mode 2 :  Selection Of Edges
        Mode 3 :  Selection Of Wires
        Mode 4 :  Selection Of Faces ...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_AcceptShapeDecomposition(self, *args)


    def SetCurrentFacingModel(self, *args):
        """
        SetCurrentFacingModel(Handle_MeshVS_Mesh self, Aspect_TypeOfFacingModel const aModel=Aspect_TOFM_BOTH_SIDE)

        change the current facing model apply on polygons for
        SetColor(), SetTransparency(), SetMaterial() methods
        default facing model is Aspect_TOFM_TWO_SIDE. This mean that attributes is
        applying both on the front and back face.

        :type aModel: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetCurrentFacingModel(self, *args)


    def CurrentFacingModel(self, *args):
        """
        CurrentFacingModel(Handle_MeshVS_Mesh self) -> Aspect_TypeOfFacingModel

        Returns the current facing model which is in effect.

        :rtype: OCC.wrapper.Aspect.Aspect_TypeOfFacingModel

        """
        return _MeshVS.Handle_MeshVS_Mesh_CurrentFacingModel(self, *args)


    def SetColor(self, *args):
        """
        SetColor(Handle_MeshVS_Mesh self, Quantity_Color theColor)

        Only the interactive object knowns which Drawer attribute is affected by the color, if any
        (ex: for a wire,it's the wireaspect field of the drawer, but for a vertex, only the point aspect field is affected by the color).
        WARNING : Do not forget to set the corresponding fields here (hasOwnColor and myDrawer->SetColor())

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetColor(self, *args)


    def UnsetColor(self, *args):
        """
        UnsetColor(Handle_MeshVS_Mesh self)

        Removes color settings. Only the Interactive Object
        knows which Drawer attribute is   affected by the color
        setting. For a wire, for example, wire aspect is the
        attribute affected. For a vertex, however, only point
        aspect is affected by the color setting.


        """
        return _MeshVS.Handle_MeshVS_Mesh_UnsetColor(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_MeshVS_Mesh self, Standard_Real const aValue)

        Allows you to provide the setting aValue for width.
        Only the Interactive Object knows which Drawer
        attribute is affected by the width setting.

        :type aValue: float

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetWidth(self, *args)


    def UnsetWidth(self, *args):
        """UnsetWidth(Handle_MeshVS_Mesh self)"""
        return _MeshVS.Handle_MeshVS_Mesh_UnsetWidth(self, *args)


    def DefaultDisplayMode(self, *args):
        """
        DefaultDisplayMode(Handle_MeshVS_Mesh self) -> Standard_Integer

        Returns the default display mode. This method is to
        be implemented when the main mode is not mode 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_Mesh_DefaultDisplayMode(self, *args)


    def Redisplay(self, *args):
        """
        Redisplay(Handle_MeshVS_Mesh self, Standard_Boolean const AllModes)

        Updates the active presentation; if <AllModes> = Standard_True
        all the presentations inside are recomputed.
        IMPORTANT: It is preferable to call Redisplay method of
        corresponding AIS_InteractiveContext instance for cases when it
        is accessible. This method just redirects call to myCTXPtr,
        so this class field must be up to date for proper result.

        :type AllModes: bool

        """
        return _MeshVS.Handle_MeshVS_Mesh_Redisplay(self, *args)


    def SetInfiniteState(self, *args):
        """
        SetInfiniteState(Handle_MeshVS_Mesh self, Standard_Boolean const aFlag)

        Sets the infinite state flag aFlage.
        if   <aFlag>   = True  ,  the   interactiveObject  is
        considered as infinite, i.e. its graphic presentations
        are not taken in account for View FitAll...

        :type aFlag: bool

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetInfiniteState(self, *args)


    def IsInfinite(self, *args):
        """
        IsInfinite(Handle_MeshVS_Mesh self) -> Standard_Boolean

        Returns true if the interactive object is infinite. In this
        case, its graphic presentations are not taken into
        account in the fit-all view.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_IsInfinite(self, *args)


    def HasInteractiveContext(self, *args):
        """
        HasInteractiveContext(Handle_MeshVS_Mesh self) -> Standard_Boolean

        Indicates whether the Interactive Object has a pointer to an interactive context.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_HasInteractiveContext(self, *args)


    def GetContext(self, *args):
        """
        GetContext(Handle_MeshVS_Mesh self) -> Handle_AIS_InteractiveContext

        Returns the context pointer to the interactive context.

        :rtype: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _MeshVS.Handle_MeshVS_Mesh_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_MeshVS_Mesh self, Handle_AIS_InteractiveContext aCtx)

        Sets the interactive context aCtx and provides a link
        to the default drawing tool or "Drawer" if there is none.

        :type aCtx: OCC.wrapper.AIS.Handle_AIS_InteractiveContext

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetContext(self, *args)


    def HasOwner(self, *args):
        """
        HasOwner(Handle_MeshVS_Mesh self) -> Standard_Boolean

        Returns true if the object has an owner attributed to it.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_HasOwner(self, *args)


    def GetOwner(self, *args):
        """
        Returns the owner of the Interactive Object.
        The owner can be a shape for a set of sub-shapes or
        a sub-shape for sub-shapes which it is composed of,
        and takes the form of a transient.
        There are two types of owners:
        -   Direct owners, decomposition shapes such as
        edges, wires, and faces.
        -   Users, presentable objects connecting to sensitive
        primitives, or a shape which has been decomposed.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _MeshVS.Handle_MeshVS_Mesh_GetOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOwner(self, *args):
        """
        SetOwner(Handle_MeshVS_Mesh self, Handle_Standard_Transient theApplicativeEntity)

        Allows you to attribute the owner theApplicativeEntity to
        an Interactive Object. This can be a shape for a set of
        sub-shapes or a sub-shape for sub-shapes which it
        is composed of. The owner takes the form of a transient.

        :type theApplicativeEntity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetOwner(self, *args)


    def ClearOwner(self, *args):
        """
        ClearOwner(Handle_MeshVS_Mesh self)

        Each Interactive Object has methods which allow us
        to attribute an Owner to it in the form of a Transient.
        This method removes the owner from the graphic entity.


        """
        return _MeshVS.Handle_MeshVS_Mesh_ClearOwner(self, *args)


    def HasDisplayMode(self, *args):
        """
        HasDisplayMode(Handle_MeshVS_Mesh self) -> Standard_Boolean

        Returns true if the Interactive Object has a display
        mode setting. Otherwise, it is displayed in Neutral Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_HasDisplayMode(self, *args)


    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_MeshVS_Mesh self, Standard_Integer const aMode)

        Sets the display mode aMode for the interactive object.
        An object can have its own temporary display mode,
        which is different from that proposed by the interactive context.
        The range of possibilities currently proposed is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the creation of new display modes.

        :type aMode: int

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetDisplayMode(self, *args)


    def UnsetDisplayMode(self, *args):
        """
        UnsetDisplayMode(Handle_MeshVS_Mesh self)

        Removes display mode settings from the interactive object.


        """
        return _MeshVS.Handle_MeshVS_Mesh_UnsetDisplayMode(self, *args)


    def DisplayMode(self, *args):
        """
        DisplayMode(Handle_MeshVS_Mesh self) -> Standard_Integer

        Returns the display mode setting of the Interactive Object.
        The range of possibilities is the following:
        -   AIS_WireFrame
        -   AIS_Shaded
        This range can, however, be extended through the
        creation of new display modes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_Mesh_DisplayMode(self, *args)


    def HasHilightMode(self, *args):
        """
        HasHilightMode(Handle_MeshVS_Mesh self) -> Standard_Boolean

        Returns true if the Interactive Object is in highlight mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_HasHilightMode(self, *args)


    def HilightMode(self, *args):
        """
        HilightMode(Handle_MeshVS_Mesh self) -> Standard_Integer

        Returns highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_Mesh_HilightMode(self, *args)


    def SetHilightMode(self, *args):
        """
        SetHilightMode(Handle_MeshVS_Mesh self, Standard_Integer const theMode)

        Sets highlight display mode.
        This is obsolete method for backward compatibility - use ::HilightAttributes() and ::DynamicHilightAttributes() instead.

        :type theMode: int

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetHilightMode(self, *args)


    def UnsetHilightMode(self, *args):
        """
        UnsetHilightMode(Handle_MeshVS_Mesh self)

        Unsets highlight display mode.


        """
        return _MeshVS.Handle_MeshVS_Mesh_UnsetHilightMode(self, *args)


    def HasColor(self, *args):
        """
        HasColor(Handle_MeshVS_Mesh self) -> Standard_Boolean

        Returns true if the Interactive Object has color.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_HasColor(self, *args)


    def Color(self, *args):
        """
        Color(Handle_MeshVS_Mesh self, Quantity_Color theColor)

        Returns the color setting of the Interactive Object.

        :type theColor: OCC.wrapper.Quantity.Quantity_Color

        """
        return _MeshVS.Handle_MeshVS_Mesh_Color(self, *args)


    def HasWidth(self, *args):
        """
        HasWidth(Handle_MeshVS_Mesh self) -> Standard_Boolean

        Returns true if the Interactive Object has width.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_HasWidth(self, *args)


    def Width(self, *args):
        """
        Width(Handle_MeshVS_Mesh self) -> Standard_Real

        Returns the width setting of the Interactive Object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MeshVS.Handle_MeshVS_Mesh_Width(self, *args)


    def HasMaterial(self, *args):
        """
        HasMaterial(Handle_MeshVS_Mesh self) -> Standard_Boolean

        Returns true if the Interactive Object has a setting for material.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_HasMaterial(self, *args)


    def Material(self, *args):
        """
        Material(Handle_MeshVS_Mesh self) -> Graphic3d_NameOfMaterial

        Returns the current material setting.
        This will be on of the following materials:
        -   Brass
        -   Bronze
        -   Gold
        -   Pewter
        -   Silver
        -   Stone.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_NameOfMaterial

        """
        return _MeshVS.Handle_MeshVS_Mesh_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_MeshVS_Mesh self, Graphic3d_MaterialAspect aName)

        Sets the material aMat defining this display attribute
        for the interactive object.
        Material aspect determines shading aspect, color and
        transparency of visible entities.

        :type aName: OCC.wrapper.Graphic3d.Graphic3d_MaterialAspect

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetMaterial(self, *args)


    def UnsetMaterial(self, *args):
        """
        UnsetMaterial(Handle_MeshVS_Mesh self)

        Removes the setting for material.


        """
        return _MeshVS.Handle_MeshVS_Mesh_UnsetMaterial(self, *args)


    def SetTransparency(self, *args):
        """
        SetTransparency(Handle_MeshVS_Mesh self, Standard_Real const aValue=0.6)

        Attributes a setting aValue for transparency.
        The transparency value should be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.
        Warning At a value of 1.0, there may be nothing visible.

        :type aValue: float

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetTransparency(self, *args)


    def IsTransparent(self, *args):
        """
        IsTransparent(Handle_MeshVS_Mesh self) -> Standard_Boolean

        Returns true if there is a transparency setting.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_IsTransparent(self, *args)


    def Transparency(self, *args):
        """
        Transparency(Handle_MeshVS_Mesh self) -> Standard_Real

        Returns the transparency setting.
        This will be between 0.0 and 1.0.
        At 0.0 an object will be totally opaque, and at 1.0, fully transparent.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MeshVS.Handle_MeshVS_Mesh_Transparency(self, *args)


    def UnsetTransparency(self, *args):
        """
        UnsetTransparency(Handle_MeshVS_Mesh self)

        Removes the transparency setting. The object is opaque by default.


        """
        return _MeshVS.Handle_MeshVS_Mesh_UnsetTransparency(self, *args)


    def UnsetAttributes(self, *args):
        """
        UnsetAttributes(Handle_MeshVS_Mesh self)

        Clears settings provided by the drawing tool aDrawer.


        """
        return _MeshVS.Handle_MeshVS_Mesh_UnsetAttributes(self, *args)


    def HasPresentation(self, *args):
        """
        HasPresentation(Handle_MeshVS_Mesh self) -> Standard_Boolean

        Returns TRUE when this object has a presentation
        in the current DisplayMode()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_HasPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_MeshVS_Mesh self) -> Handle_Prs3d_Presentation

        Returns the current presentation of this object
        according to the current DisplayMode()

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _MeshVS.Handle_MeshVS_Mesh_Presentation(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_MeshVS_Mesh self, Handle_Prs3d_BasicAspect anAspect)

        Sets the graphic basic aspect to the current presentation.

        :type anAspect: OCC.wrapper.Prs3d.Handle_Prs3d_BasicAspect

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetAspect(self, *args)


    def SetPolygonOffsets(self, *args):
        """
        SetPolygonOffsets(Handle_MeshVS_Mesh self, Standard_Integer const aMode, Standard_ShortReal const aFactor=1.0, Standard_ShortReal const aUnits=0.0)

        Sets up polygon offsets for this object.
        It modifies all existing presentations of <anObj> (if any),
        so it is reasonable to call this method after <anObj> has been displayed.
        Otherwise, Compute() method should pass Graphic3d_AspectFillArea3d
        aspect from <myDrawer> to Graphic3d_Group to make polygon offsets work.

        <aMode> parameter can contain various combinations of
        Aspect_PolygonOffsetMode enumeration elements (Aspect_POM_None means
        that polygon offsets are not changed).
        If <aMode> is different from Aspect_POM_Off and Aspect_POM_None, then <aFactor> and <aUnits>
        arguments are used by graphic renderer to calculate a depth offset value:

        offset = <aFactor> * m + <aUnits> * r, where
        m - maximum depth slope for the polygon currently being displayed,
        r - minimum window coordinates depth resolution (implementation-specific).

        Deafult settings for OCC 3D viewer: mode = Aspect_POM_Fill, factor = 1., units = 0.

        Negative offset values move polygons closer to the viewport,
        while positive values shift polygons away.
        Consult OpenGL reference for details (glPolygonOffset function description).

        NOTE: This method has a side effect - it creates own shading aspect
        if not yet created, so it is better to set up object material,
        color, etc. first.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetPolygonOffsets(self, *args)


    def HasPolygonOffsets(self, *args):
        """
        HasPolygonOffsets(Handle_MeshVS_Mesh self) -> Standard_Boolean

        Returns Standard_True if <myDrawer> has non-null shading aspect

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_HasPolygonOffsets(self, *args)


    def PolygonOffsets(self, *args):
        """
        PolygonOffsets(Handle_MeshVS_Mesh self)

        Retrieves current polygon offsets settings from <myDrawer>.

        :type aMode: int
        :type aFactor: float
        :type aUnits: float

        """
        return _MeshVS.Handle_MeshVS_Mesh_PolygonOffsets(self, *args)


    def BoundingBox(self, *args):
        """
        BoundingBox(Handle_MeshVS_Mesh self, Bnd_Box theBndBox)

        Returns bounding box of object correspondingly to its current display mode.

        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box

        """
        return _MeshVS.Handle_MeshVS_Mesh_BoundingBox(self, *args)


    def SetIsoOnTriangulation(self, *args):
        """
        SetIsoOnTriangulation(Handle_MeshVS_Mesh self, Standard_Boolean const theIsEnabled)

        Enables or disables on-triangulation build of isolines according to the flag given.

        :type theIsEnabled: bool

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetIsoOnTriangulation(self, *args)


    def SynchronizeAspects(self, *args):
        """
        SynchronizeAspects(Handle_MeshVS_Mesh self)

        Synchronize presentation aspects after their modification.

        This method should be called after modifying primitive aspect properties (material, texture, shader)
        so that modifications will take effect on already computed presentation groups (thus avoiding re-displaying the object).


        """
        return _MeshVS.Handle_MeshVS_Mesh_SynchronizeAspects(self, *args)


    def RecomputePrimitives(self, *args):
        """
        RecomputePrimitives(Handle_MeshVS_Mesh self)
        RecomputePrimitives(Handle_MeshVS_Mesh self, Standard_Integer const theMode)

        Re-computes the sensitive primitives which correspond to the <theMode>th selection mode.
        IMPORTANT: Do not use this method to update selection primitives except implementing custom selection manager!
        selection manager! This method does not take into account necessary BVH updates, but may invalidate
        the pointers it refers to. TO UPDATE SELECTION properly from outside classes, use method UpdateSelection.

        :type theMode: int

        """
        return _MeshVS.Handle_MeshVS_Mesh_RecomputePrimitives(self, *args)


    def AddSelection(self, *args):
        """
        AddSelection(Handle_MeshVS_Mesh self, Handle_SelectMgr_Selection aSelection, Standard_Integer const aMode)

        Adds the selection aSelection with the selection mode
        index aMode to this framework.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection
        :type aMode: int

        """
        return _MeshVS.Handle_MeshVS_Mesh_AddSelection(self, *args)


    def ClearSelections(self, *args):
        """
        ClearSelections(Handle_MeshVS_Mesh self, Standard_Boolean const update)

        Empties all the selections in the SelectableObject
        <update> parameter defines whether all object's
        selections should be flagged for further update or not.
        This improved method can be used to recompute an
        object's selection (without redisplaying the object
        completely) when some selection mode is activated not for the first time.

        :type update: bool

        """
        return _MeshVS.Handle_MeshVS_Mesh_ClearSelections(self, *args)


    def Selection(self, *args):
        """
        Returns the selection having specified selection mode or NULL.

        :type theMode: int
        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _MeshVS.Handle_MeshVS_Mesh_Selection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSelection(self, *args):
        """
        HasSelection(Handle_MeshVS_Mesh self, Standard_Integer const theMode) -> Standard_Boolean

        Returns true if a selection corresponding to the selection mode theMode was computed for this object.

        :type theMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_HasSelection(self, *args)


    def Selections(self, *args):
        """
        Return the sequence of selections.

        :rtype: OCC.wrapper.SelectMgr.SelectMgr_SequenceOfSelection

        """
        res = _MeshVS.Handle_MeshVS_Mesh_Selections(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_MeshVS_Mesh self)

        Begins the iteration scanning for sensitive primitives.


        """
        return _MeshVS.Handle_MeshVS_Mesh_Init(self, *args)


    def More(self, *args):
        """
        More(Handle_MeshVS_Mesh self) -> Standard_Boolean

        Continues the iteration scanning for sensitive primitives.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_More(self, *args)


    def Next(self, *args):
        """
        Next(Handle_MeshVS_Mesh self)

        Continues the iteration scanning for sensitive primitives.


        """
        return _MeshVS.Handle_MeshVS_Mesh_Next(self, *args)


    def CurrentSelection(self, *args):
        """
        Returns the current selection in this framework.

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        res = _MeshVS.Handle_MeshVS_Mesh_CurrentSelection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetTransformation(self, *args):
        """
        ResetTransformation(Handle_MeshVS_Mesh self)

        resets local transformation to identity.


        """
        return _MeshVS.Handle_MeshVS_Mesh_ResetTransformation(self, *args)


    def UpdateTransformation(self, *args):
        """
        UpdateTransformation(Handle_MeshVS_Mesh self)

        Recomputes the location of the selection aSelection.


        """
        return _MeshVS.Handle_MeshVS_Mesh_UpdateTransformation(self, *args)


    def UpdateTransformations(self, *args):
        """
        UpdateTransformations(Handle_MeshVS_Mesh self, Handle_SelectMgr_Selection aSelection)

        Updates locations in all sensitive entities from <aSelection>
        and in corresponding entity owners.

        :type aSelection: OCC.wrapper.SelectMgr.Handle_SelectMgr_Selection

        """
        return _MeshVS.Handle_MeshVS_Mesh_UpdateTransformations(self, *args)


    def ClearDynamicHighlight(self, *args):
        """
        ClearDynamicHighlight(Handle_MeshVS_Mesh self, Handle_PrsMgr_PresentationManager theMgr)

        Method that needs to be implemented when the object
        manages selection and dynamic highlighting on its own.
        Clears or invalidates dynamic highlight presentation.
        By default it clears immediate draw of given presentation
        manager.

        :type theMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d

        """
        return _MeshVS.Handle_MeshVS_Mesh_ClearDynamicHighlight(self, *args)


    def IsAutoHilight(self, *args):
        """
        IsAutoHilight(Handle_MeshVS_Mesh self) -> Standard_Boolean

        If returns True, the old mechanism for highlighting
        selected objects is used (HilightSelected Method may be empty).
        If returns False, the HilightSelected method will be
        fully responsible for highlighting selected entity
        owners belonging to this selectable object.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_IsAutoHilight(self, *args)


    def SetAutoHilight(self, *args):
        """
        SetAutoHilight(Handle_MeshVS_Mesh self, Standard_Boolean const newAutoHilight)

        Set AutoHilight property to true or false
        Sets  up  Transform  Persistence Mode  for  this  object

        :type newAutoHilight: bool

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetAutoHilight(self, *args)


    def GetHilightPresentation(self, *args):
        """
        GetHilightPresentation(Handle_MeshVS_Mesh self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _MeshVS.Handle_MeshVS_Mesh_GetHilightPresentation(self, *args)


    def GetSelectPresentation(self, *args):
        """
        GetSelectPresentation(Handle_MeshVS_Mesh self, Handle_PrsMgr_PresentationManager TheMgr) -> Handle_Prs3d_Presentation

        :type TheMgr: OCC.wrapper.SelectMgr.Handle_PrsMgr_PresentationManager3d
        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation

        """
        return _MeshVS.Handle_MeshVS_Mesh_GetSelectPresentation(self, *args)


    def ErasePresentations(self, *args):
        """
        ErasePresentations(Handle_MeshVS_Mesh self, Standard_Boolean theToRemove)

        Removes presentations returned by GetHilightPresentation() and GetSelectPresentation().

        :type theToRemove: bool

        """
        return _MeshVS.Handle_MeshVS_Mesh_ErasePresentations(self, *args)


    def SetZLayer(self, *args):
        """
        SetZLayer(Handle_MeshVS_Mesh self, Graphic3d_ZLayerId const theLayerId)

        Set Z layer ID and update all presentations of the selectable object.
        The layers mechanism allows drawing objects in higher layers in overlay of objects in lower layers.

        :type theLayerId: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetZLayer(self, *args)


    def UpdateSelection(self, *args):
        """
        UpdateSelection(Handle_MeshVS_Mesh self, Standard_Integer const theMode=-1)

        Sets update status FULL to selections of the object. Must be used as the only method of UpdateSelection
        from outer classes to prevent BVH structures from being outdated.

        :type theMode: int

        """
        return _MeshVS.Handle_MeshVS_Mesh_UpdateSelection(self, *args)


    def SetAssemblyOwner(self, *args):
        """
        SetAssemblyOwner(Handle_MeshVS_Mesh self, Handle_SelectMgr_EntityOwner theOwner, Standard_Integer const theMode=-1)

        Sets common entity owner for assembly sensitive object entities

        :type theOwner: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner
        :type theMode: int

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetAssemblyOwner(self, *args)


    def BndBoxOfSelected(self, *args):
        """
        BndBoxOfSelected(Handle_MeshVS_Mesh self, opencascade::handle< SelectMgr_IndexedMapOfOwner > const & theOwners) -> Bnd_Box

        Returns a bounding box of sensitive entities with the owners given
        if they are a part of activated selection

        :type theOwners: OCC.wrapper.SelectMgr.Handle_SelectMgr_IndexedMapOfOwner
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _MeshVS.Handle_MeshVS_Mesh_BndBoxOfSelected(self, *args)


    def GlobalSelectionMode(self, *args):
        """
        GlobalSelectionMode(Handle_MeshVS_Mesh self) -> Standard_Integer

        Returns the mode for selection of object as a whole

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_Mesh_GlobalSelectionMode(self, *args)


    def GlobalSelOwner(self, *args):
        """
        GlobalSelOwner(Handle_MeshVS_Mesh self) -> Handle_SelectMgr_EntityOwner

        Returns the owner of mode for selection of object as a whole

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        return _MeshVS.Handle_MeshVS_Mesh_GlobalSelOwner(self, *args)


    def GetAssemblyOwner(self, *args):
        """
        Returns common entity owner if the object is an assembly

        :rtype: OCC.wrapper.SelectMgr.Handle_SelectMgr_EntityOwner

        """
        res = _MeshVS.Handle_MeshVS_Mesh_GetAssemblyOwner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Presentations(self, *args):
        """
        Presentations(Handle_MeshVS_Mesh self) -> NCollection_Sequence_PrsMgr_ModedPresentation

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_Presentations

        """
        return _MeshVS.Handle_MeshVS_Mesh_Presentations(self, *args)


    def TypeOfPresentation3d(self, *args):
        """
        TypeOfPresentation3d(Handle_MeshVS_Mesh self) -> PrsMgr_TypeOfPresentation3d

        Returns information on whether the object accepts display in HLR mode or not.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _MeshVS.Handle_MeshVS_Mesh_TypeOfPresentation3d(self, *args)


    def TransformPersistence(self, *args):
        """
        Returns Transformation Persistence defining a special Local Coordinate system where this presentable object is located or NULL handle if not defined.
        Position of the object having Transformation Persistence is mutable and depends on camera position.
        The same applies to a bounding box of the object.
        @sa Graphic3d_TransformPers class description

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_TransformPers

        """
        res = _MeshVS.Handle_MeshVS_Mesh_TransformPersistence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransformPersistence(self, *args):
        """
        SetTransformPersistence(Handle_MeshVS_Mesh self, Handle_Graphic3d_TransformPers theTrsfPers)
        SetTransformPersistence(Handle_MeshVS_Mesh self, Graphic3d_TransModeFlags const theMode, gp_Pnt thePoint)

        Sets up Transform Persistence Mode for this object.
        This function used to lock in object position, rotation and / or zooming relative to camera position.
        Object will be drawn in the origin setted by thePoint parameter (except Graphic3d_TMF_TriedronPers flag
        - see description later). theMode should be:
        -   Graphic3d_TMF_None - no persistence attributes (reset);
        -   Graphic3d_TMF_ZoomPers - object doesn't resize;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_ZoomRotatePers - object doesn't resize and rotate;
        -   Graphic3d_TMF_RotatePers - object doesn't rotate;
        -   Graphic3d_TMF_TriedronPers - object behaves like trihedron.
        If Graphic3d_TMF_TriedronPers or Graphic3d_TMF_2d persistence mode selected thePoint coordinates X and Y means:
        -   X = 0.0, Y = 0.0 - center of view window;
        -   X > 0.0, Y > 0.0 - right upper corner of view window;
        -   X > 0.0, Y < 0.0 - right lower corner of view window;
        -   X < 0.0, Y > 0.0 - left  upper corner of view window;
        -   X < 0.0, Y < 0.0 - left  lower corner of view window.
        And Z coordinate defines the gap from border of view window (except center position).

        :type theMode: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetTransformPersistence(self, *args)


    def GetTransformPersistenceMode(self, *args):
        """
        GetTransformPersistenceMode(Handle_MeshVS_Mesh self) -> Graphic3d_TransModeFlags

        Gets  Transform  Persistence Mode  for  this  object

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_TransModeFlags

        """
        return _MeshVS.Handle_MeshVS_Mesh_GetTransformPersistenceMode(self, *args)


    def GetTransformPersistencePoint(self, *args):
        """
        GetTransformPersistencePoint(Handle_MeshVS_Mesh self) -> gp_Pnt

        Gets  point  of  transform  persistence for  this  object

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _MeshVS.Handle_MeshVS_Mesh_GetTransformPersistencePoint(self, *args)


    def SetTypeOfPresentation(self, *args):
        """
        SetTypeOfPresentation(Handle_MeshVS_Mesh self, PrsMgr_TypeOfPresentation3d const aType)

        :type aType: OCC.wrapper.PrsMgr.PrsMgr_TypeOfPresentation3d

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetTypeOfPresentation(self, *args)


    def SetToUpdate(self, *args):
        """
        SetToUpdate(Handle_MeshVS_Mesh self, Standard_Integer const aMode)
        SetToUpdate(Handle_MeshVS_Mesh self)

        flags all the Presentations to be Updated.


        """
        return _MeshVS.Handle_MeshVS_Mesh_SetToUpdate(self, *args)


    def ToBeUpdated(self, *args):
        """
        ToBeUpdated(Handle_MeshVS_Mesh self, NCollection_List_Standard_Integer ListOfMode)

        gives the list of modes which are flagged "to be updated".

        :type ListOfMode: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _MeshVS.Handle_MeshVS_Mesh_ToBeUpdated(self, *args)


    def LocalTransformationGeom(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _MeshVS.Handle_MeshVS_Mesh_LocalTransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLocalTransformation(self, *args):
        """
        SetLocalTransformation(Handle_MeshVS_Mesh self, gp_Trsf theTrsf)
        SetLocalTransformation(Handle_MeshVS_Mesh self, Handle_Geom_Transformation theTrsf)

        Sets local transformation to theTransformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :type theTrsf: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetLocalTransformation(self, *args)


    def HasTransformation(self, *args):
        """
        HasTransformation(Handle_MeshVS_Mesh self) -> Standard_Boolean

        Returns true if object has a transformation that is different from the identity.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_HasTransformation(self, *args)


    def TransformationGeom(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Transformation

        """
        res = _MeshVS.Handle_MeshVS_Mesh_TransformationGeom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LocalTransformation(self, *args):
        """
        Return the local transformation.
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _MeshVS.Handle_MeshVS_Mesh_LocalTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Return the transformation taking into account transformation of parent object(s).
        Note that the local transformation of the object having Transformation Persistence
        is applied within Local Coordinate system defined by this Persistence.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _MeshVS.Handle_MeshVS_Mesh_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InversedTransformation(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        res = _MeshVS.Handle_MeshVS_Mesh_InversedTransformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ZLayer(self, *args):
        """
        ZLayer(Handle_MeshVS_Mesh self) -> Graphic3d_ZLayerId

        Get ID of Z layer.

        :rtype: OCC.wrapper.Graphic3d.Graphic3d_ZLayerId

        """
        return _MeshVS.Handle_MeshVS_Mesh_ZLayer(self, *args)


    def AddClipPlane(self, *args):
        """
        AddClipPlane(Handle_MeshVS_Mesh self, Handle_Graphic3d_ClipPlane thePlane)

        Adds clip plane for graphical clipping for all display mode
        presentations. The composition of clip planes truncates the rendering
        space to convex volume. Please be aware that number of supported
        clip plane is limited. The planes which exceed the limit are ignored.
        Besides of this, some planes can be already set in view where the object
        is shown: the number of these planes should be substracted from limit
        to predict the maximum possible number of object clipping planes.
        @param thePlane [in] the clip plane to be appended to map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _MeshVS.Handle_MeshVS_Mesh_AddClipPlane(self, *args)


    def RemoveClipPlane(self, *args):
        """
        RemoveClipPlane(Handle_MeshVS_Mesh self, Handle_Graphic3d_ClipPlane thePlane)

        Removes previously added clip plane.
        @param thePlane [in] the clip plane to be removed from map of clip planes.

        :type thePlane: OCC.wrapper.Graphic3d.Handle_Graphic3d_ClipPlane

        """
        return _MeshVS.Handle_MeshVS_Mesh_RemoveClipPlane(self, *args)


    def SetClipPlanes(self, *args):
        """
        SetClipPlanes(Handle_MeshVS_Mesh self, Handle_Graphic3d_SequenceOfHClipPlane thePlanes)
        SetClipPlanes(Handle_MeshVS_Mesh self, Graphic3d_SequenceOfHClipPlane thePlanes)

        :type thePlanes: OCC.wrapper.Graphic3d.Graphic3d_SequenceOfHClipPlane

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetClipPlanes(self, *args)


    def ClipPlanes(self, *args):
        """
        Get clip planes.
        @return set of previously added clip planes for all display mode presentations.

        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_SequenceOfHClipPlane

        """
        res = _MeshVS.Handle_MeshVS_Mesh_ClipPlanes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMutable(self, *args):
        """
        SetMutable(Handle_MeshVS_Mesh self, Standard_Boolean const theIsMutable)

        Sets if the object has mutable nature (content or location will be changed regularly).
        This method should be called before object displaying to take effect.

        :type theIsMutable: bool

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetMutable(self, *args)


    def IsMutable(self, *args):
        """
        IsMutable(Handle_MeshVS_Mesh self) -> Standard_Boolean

        Returns true if object has mutable nature (content or location are be changed regularly).
        Mutable object will be managed in different way than static onces (another optimizations).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_IsMutable(self, *args)


    def AddChild(self, *args):
        """
        AddChild(Handle_MeshVS_Mesh self, Handle_PrsMgr_PresentableObject theObject)

        Makes theObject child of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _MeshVS.Handle_MeshVS_Mesh_AddChild(self, *args)


    def RemoveChild(self, *args):
        """
        RemoveChild(Handle_MeshVS_Mesh self, Handle_PrsMgr_PresentableObject theObject)

        Removes theObject from children of current object in scene hierarchy.

        :type theObject: OCC.wrapper.PrsMgr.Handle_PrsMgr_PresentableObject

        """
        return _MeshVS.Handle_MeshVS_Mesh_RemoveChild(self, *args)


    def Children(self, *args):
        """
        Returns children of the current object.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_ListOfPresentableObjects

        """
        res = _MeshVS.Handle_MeshVS_Mesh_Children(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasOwnPresentations(self, *args):
        """
        HasOwnPresentations(Handle_MeshVS_Mesh self) -> Standard_Boolean

        Returns true if object should have own presentations.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_HasOwnPresentations(self, *args)


    def Parent(self, *args):
        """
        Parent(Handle_MeshVS_Mesh self) -> PrsMgr_PresentableObject

        Returns parent of current object in scene hierarchy.

        :rtype: OCC.wrapper.PrsMgr.PrsMgr_PresentableObjectPointer

        """
        return _MeshVS.Handle_MeshVS_Mesh_Parent(self, *args)


    def SetAttributes(self, *args):
        """
        SetAttributes(Handle_MeshVS_Mesh self, Handle_Prs3d_Drawer theDrawer)

        Initializes the drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetAttributes(self, *args)


    def Attributes(self, *args):
        """
        Returns the attributes settings.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _MeshVS.Handle_MeshVS_Mesh_Attributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalSelected and Prs3d_TypeOfHighlight_Selected defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _MeshVS.Handle_MeshVS_Mesh_HilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetHilightAttributes(self, *args):
        """
        SetHilightAttributes(Handle_MeshVS_Mesh self, Handle_Prs3d_Drawer theDrawer)

        Initializes the hilight drawing tool theDrawer.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetHilightAttributes(self, *args)


    def DynamicHilightAttributes(self, *args):
        """
        Returns the hilight attributes settings.
        When not NULL, overrides both Prs3d_TypeOfHighlight_LocalDynamic and Prs3d_TypeOfHighlight_Dynamic defined within AIS_InteractiveContext.

        :rtype: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        res = _MeshVS.Handle_MeshVS_Mesh_DynamicHilightAttributes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDynamicHilightAttributes(self, *args):
        """
        SetDynamicHilightAttributes(Handle_MeshVS_Mesh self, Handle_Prs3d_Drawer theDrawer)

        Initializes the dynamic hilight drawing tool.

        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _MeshVS.Handle_MeshVS_Mesh_SetDynamicHilightAttributes(self, *args)


    def UnsetHilightAttributes(self, *args):
        """
        UnsetHilightAttributes(Handle_MeshVS_Mesh self)

        Clears settings provided by the hilight drawing tool theDrawer.


        """
        return _MeshVS.Handle_MeshVS_Mesh_UnsetHilightAttributes(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_MeshVS_Mesh self)

        Memory deallocator for transient classes


        """
        return _MeshVS.Handle_MeshVS_Mesh_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MeshVS_Mesh self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MeshVS_Mesh self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MeshVS_Mesh self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MeshVS_Mesh self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MeshVS.Handle_MeshVS_Mesh_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MeshVS_Mesh self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MeshVS.Handle_MeshVS_Mesh_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MeshVS_Mesh self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_Mesh_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MeshVS_Mesh self)

        Increments the reference counter of this object


        """
        return _MeshVS.Handle_MeshVS_Mesh_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MeshVS_Mesh self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MeshVS.Handle_MeshVS_Mesh_DecrementRefCounter(self, *args)

Handle_MeshVS_Mesh_swigregister = _MeshVS.Handle_MeshVS_Mesh_swigregister
Handle_MeshVS_Mesh_swigregister(Handle_MeshVS_Mesh)

def Handle_MeshVS_Mesh_DownCast(thing):
    return _MeshVS.Handle_MeshVS_Mesh_DownCast(thing)
Handle_MeshVS_Mesh_DownCast = _MeshVS.Handle_MeshVS_Mesh_DownCast




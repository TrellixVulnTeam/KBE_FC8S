# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Hatch')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Hatch')
    _Hatch = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Hatch', [dirname(__file__)])
        except ImportError:
            import _Hatch
            return _Hatch
        try:
            _mod = imp.load_module('_Hatch', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Hatch = swig_import_helper()
    del swig_import_helper
else:
    import _Hatch
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Hatch.delete_SwigPyIterator

    def value(self):
        return _Hatch.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Hatch.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Hatch.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Hatch.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Hatch.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Hatch.SwigPyIterator_copy(self)

    def next(self):
        return _Hatch.SwigPyIterator_next(self)

    def __next__(self):
        return _Hatch.SwigPyIterator___next__(self)

    def previous(self):
        return _Hatch.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Hatch.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Hatch.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Hatch.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Hatch.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Hatch.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Hatch.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Hatch.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Hatch.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Hatch.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Hatch.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Hatch.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Hatch.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Hatch.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Hatch.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Hatch.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Hatch.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Hatch.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Hatch.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Hatch.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Hatch.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Hatch.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Hatch.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Hatch.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Hatch.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Hatch.ptr_to_number(item)
ptr_to_number = _Hatch.ptr_to_number

def HashCode(*args):
    return _Hatch.HashCode(*args)
HashCode = _Hatch.HashCode

def ptr_equal(a, b):
    return _Hatch.ptr_equal(a, b)
ptr_equal = _Hatch.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
Hatch_XLINE = _Hatch.Hatch_XLINE
Hatch_YLINE = _Hatch.Hatch_YLINE
Hatch_ANYLINE = _Hatch.Hatch_ANYLINE
class Hatch_Parameter(object):
    """
    Stores an intersection on a line represented by :

    * A Real parameter.

    * A flag True when the parameter starts an interval.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Hatch_Parameter self) -> Hatch_Parameter
        __init__(Hatch_Parameter self, Standard_Real const Par1, Standard_Boolean const Start, Standard_Integer const Index=0, Standard_Real const Par2=0) -> Hatch_Parameter

        :type Par1: float
        :type Start: bool
        :type Index: int
        :type Par2: float

        """
        this = _Hatch.new_Hatch_Parameter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Hatch.delete_Hatch_Parameter
Hatch_Parameter_swigregister = _Hatch.Hatch_Parameter_swigregister
Hatch_Parameter_swigregister(Hatch_Parameter)

class Hatch_Line(object):
    """
    Stores a Line in the Hatcher. Represented by :

    * A Lin2d from gp, the geometry of the line.

    * Bounding parameters for the line.

    * A sorted List  of Parameters, the  intersections
    on the line.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Hatch_Line self) -> Hatch_Line
        __init__(Hatch_Line self, gp_Lin2d L, Hatch_LineForm const T) -> Hatch_Line

        :type L: OCC.wrapper.gp.gp_Lin2d
        :type T: OCC.wrapper.Hatch.Hatch_LineForm

        """
        this = _Hatch.new_Hatch_Line(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddIntersection(self, *args):
        """
        AddIntersection(Hatch_Line self, Standard_Real const Par1, Standard_Boolean const Start, Standard_Integer const Index, Standard_Real const Par2, Standard_Real const theToler)

        Insert a new intersection in the sorted list.

        :type Par1: float
        :type Start: bool
        :type Index: int
        :type Par2: float
        :type theToler: float

        """
        return _Hatch.Hatch_Line_AddIntersection(self, *args)

    __swig_destroy__ = _Hatch.delete_Hatch_Line
Hatch_Line_swigregister = _Hatch.Hatch_Line_swigregister
Hatch_Line_swigregister(Hatch_Line)

class Hatch_Hatcher(object):
    """
    The Hatcher   is  an algorithm  to   compute cross
    hatchings in a 2d plane. It is mainly dedicated to
    display purpose.

    Computing cross hatchings is a 3 steps process :

    1.  The users stores in the   Hatcher a set  of 2d
    lines to   be  trimmed. Methods   in  the  "Lines"
    category.

    2.  The user trims the lines with a boundary.  The
    inside of a boundary is on the left side.  Methods
    in the "Trimming" category.

    3. The user reads  back the trimmed lines. Methods
    in the "Results" category.

    The result is a set of parameter intervals  on the
    line. The first  parameter of an  Interval may  be
    RealFirst() and the last may be RealLast().

    A line can be a line parallel to the axis (X  or Y
    line or a 2D line.

    The Hatcher has two modes :

    *  The "Oriented" mode,  where the  orientation of
    the trimming curves is  considered. The  hatch are
    kept on  the left of  the  trimming curve. In this
    mode infinite hatch can be computed.

    *   The "UnOriented"  mode,  where  the  hatch are
    always finite.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Hatch_Hatcher self, Standard_Real const Tol, Standard_Boolean const Oriented) -> Hatch_Hatcher

        Returns a empty  hatcher.  <Tol> is the  tolerance
        for intersections.

        :type Tol: float
        :type Oriented: bool

        """
        this = _Hatch.new_Hatch_Hatcher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Tolerance(self, *args):
        """
        Tolerance(Hatch_Hatcher self, Standard_Real const Tol)
        Tolerance(Hatch_Hatcher self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Hatch.Hatch_Hatcher_Tolerance(self, *args)


    def AddLine(self, *args):
        """
        AddLine(Hatch_Hatcher self, gp_Lin2d L, Hatch_LineForm const T=Hatch_ANYLINE)
        AddLine(Hatch_Hatcher self, gp_Dir2d D, Standard_Real const Dist)

        Add an infinite line on  direction <D> at distance
        <Dist> from the origin  to be  trimmed. <Dist> may
        be negative.

        If O  is the origin  of the  2D plane, and   V the
        vector perpendicular to D (in the direct direction).

        A point P is on the line if :
        OP dot V = Dist
        The parameter of P on the line is
        OP dot D

        :type D: OCC.wrapper.gp.gp_Dir2d
        :type Dist: float

        """
        return _Hatch.Hatch_Hatcher_AddLine(self, *args)


    def AddXLine(self, *args):
        """
        AddXLine(Hatch_Hatcher self, Standard_Real const X)

        Add an infinite line   parallel to the Y-axis   at
        abciss <X>.

        :type X: float

        """
        return _Hatch.Hatch_Hatcher_AddXLine(self, *args)


    def AddYLine(self, *args):
        """
        AddYLine(Hatch_Hatcher self, Standard_Real const Y)

        Add an infinite line   parallel to the X-axis   at
        ordinate <Y>.

        :type Y: float

        """
        return _Hatch.Hatch_Hatcher_AddYLine(self, *args)


    def Trim(self, *args):
        """
        Trim(Hatch_Hatcher self, gp_Lin2d L, Standard_Integer const Index=0)
        Trim(Hatch_Hatcher self, gp_Lin2d L, Standard_Real const Start, Standard_Real const End, Standard_Integer const Index=0)
        Trim(Hatch_Hatcher self, gp_Pnt2d P1, gp_Pnt2d P2, Standard_Integer const Index=0)

        Trims the line at  intersection with  the oriented
        segment P1,P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :type Index: int

        """
        return _Hatch.Hatch_Hatcher_Trim(self, *args)


    def NbLines(self, *args):
        """
        NbLines(Hatch_Hatcher self) -> Standard_Integer

        Returns the number of lines.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Hatch.Hatch_Hatcher_NbLines(self, *args)


    def Line(self, *args):
        """
        Returns the line of index <I>.

        :type I: int
        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        res = _Hatch.Hatch_Hatcher_Line(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LineForm(self, *args):
        """
        LineForm(Hatch_Hatcher self, Standard_Integer const I) -> Hatch_LineForm

        Returns  the type of the  line   of  index <I>.

        :type I: int
        :rtype: OCC.wrapper.Hatch.Hatch_LineForm

        """
        return _Hatch.Hatch_Hatcher_LineForm(self, *args)


    def IsXLine(self, *args):
        """
        IsXLine(Hatch_Hatcher self, Standard_Integer const I) -> Standard_Boolean

        Returns  True if the  line   of  index <I>  has  a
        constant X value.

        :type I: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Hatch.Hatch_Hatcher_IsXLine(self, *args)


    def IsYLine(self, *args):
        """
        IsYLine(Hatch_Hatcher self, Standard_Integer const I) -> Standard_Boolean

        Returns  True if the  line   of  index <I>  has  a
        constant Y value.

        :type I: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Hatch.Hatch_Hatcher_IsYLine(self, *args)


    def Coordinate(self, *args):
        """
        Coordinate(Hatch_Hatcher self, Standard_Integer const I) -> Standard_Real

        Returns the X or Y coordinate of the line of index
        <I> if it is a X or a Y line.

        :type I: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Hatch.Hatch_Hatcher_Coordinate(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Hatch_Hatcher self) -> Standard_Integer
        NbIntervals(Hatch_Hatcher self, Standard_Integer const I) -> Standard_Integer

        Returns the number of intervals on line of index <I>.

        :type I: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Hatch.Hatch_Hatcher_NbIntervals(self, *args)


    def Start(self, *args):
        """
        Start(Hatch_Hatcher self, Standard_Integer const I, Standard_Integer const J) -> Standard_Real

        Returns the first   parameter of  interval <J>  on
        line  <I>.

        :type I: int
        :type J: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Hatch.Hatch_Hatcher_Start(self, *args)


    def StartIndex(self, *args):
        """
        StartIndex(Hatch_Hatcher self, Standard_Integer const I, Standard_Integer const J)

        Returns the first Index and Par2 of  interval <J>  on
        line  <I>.

        :type I: int
        :type J: int
        :type Index: int
        :type Par2: float

        """
        return _Hatch.Hatch_Hatcher_StartIndex(self, *args)


    def End(self, *args):
        """
        End(Hatch_Hatcher self, Standard_Integer const I, Standard_Integer const J) -> Standard_Real

        Returns the last   parameter of  interval <J>  on
        line  <I>.

        :type I: int
        :type J: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Hatch.Hatch_Hatcher_End(self, *args)


    def EndIndex(self, *args):
        """
        EndIndex(Hatch_Hatcher self, Standard_Integer const I, Standard_Integer const J)

        Returns the last Index and Par2 of  interval <J>  on
        line  <I>.

        :type I: int
        :type J: int
        :type Index: int
        :type Par2: float

        """
        return _Hatch.Hatch_Hatcher_EndIndex(self, *args)

    __swig_destroy__ = _Hatch.delete_Hatch_Hatcher
Hatch_Hatcher_swigregister = _Hatch.Hatch_Hatcher_swigregister
Hatch_Hatcher_swigregister(Hatch_Hatcher)

class NCollection_Sequence_Hatch_Parameter(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Hatch_Parameter self) -> NCollection_Sequence< Hatch_Parameter >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Hatch.NCollection_Sequence_Hatch_Parameter_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Hatch_Parameter self) -> NCollection_Sequence< Hatch_Parameter >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Hatch.NCollection_Sequence_Hatch_Parameter_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Hatch_Parameter self) -> NCollection_Sequence< Hatch_Parameter >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Hatch.NCollection_Sequence_Hatch_Parameter_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Hatch_Parameter self) -> NCollection_Sequence< Hatch_Parameter >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Hatch.NCollection_Sequence_Hatch_Parameter_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Hatch.new_NCollection_Sequence_Hatch_Parameter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Hatch_Parameter self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Hatch.NCollection_Sequence_Hatch_Parameter_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Hatch_Parameter self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Hatch.NCollection_Sequence_Hatch_Parameter_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Hatch_Parameter self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Hatch.NCollection_Sequence_Hatch_Parameter_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Hatch_Parameter self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Hatch.NCollection_Sequence_Hatch_Parameter_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Hatch_Parameter self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Hatch.NCollection_Sequence_Hatch_Parameter_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Hatch_Parameter self)

        Reverse sequence


        """
        return _Hatch.NCollection_Sequence_Hatch_Parameter_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Hatch_Parameter self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Hatch.NCollection_Sequence_Hatch_Parameter_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Hatch.NCollection_Sequence_Hatch_Parameter_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Hatch_Parameter self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Hatch.NCollection_Sequence_Hatch_Parameter_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Hatch_Parameter self, NCollection_Sequence_Hatch_Parameter theOther) -> NCollection_Sequence_Hatch_Parameter

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Hatch.NCollection_Sequence_Hatch_Parameter_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Hatch_Parameter self, NCollection_Sequence_Hatch_Parameter theOther) -> NCollection_Sequence_Hatch_Parameter

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Hatch.NCollection_Sequence_Hatch_Parameter_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Hatch_Parameter self, NCollection_Sequence< Hatch_Parameter >::Iterator & thePosition)
        Remove(NCollection_Sequence_Hatch_Parameter self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Hatch_Parameter self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Hatch.NCollection_Sequence_Hatch_Parameter_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Hatch_Parameter self, Hatch_Parameter theItem)
        Append(NCollection_Sequence_Hatch_Parameter self, NCollection_Sequence_Hatch_Parameter theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Hatch.NCollection_Sequence_Hatch_Parameter_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Hatch_Parameter self, Hatch_Parameter theItem)
        Prepend(NCollection_Sequence_Hatch_Parameter self, NCollection_Sequence_Hatch_Parameter theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Hatch.NCollection_Sequence_Hatch_Parameter_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Hatch_Parameter self, Standard_Integer const theIndex, Hatch_Parameter theItem)
        InsertBefore(NCollection_Sequence_Hatch_Parameter self, Standard_Integer const theIndex, NCollection_Sequence_Hatch_Parameter theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Hatch.NCollection_Sequence_Hatch_Parameter_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Hatch_Parameter self, NCollection_Sequence< Hatch_Parameter >::Iterator & thePosition, Hatch_Parameter theItem)
        InsertAfter(NCollection_Sequence_Hatch_Parameter self, Standard_Integer const theIndex, NCollection_Sequence_Hatch_Parameter theSeq)
        InsertAfter(NCollection_Sequence_Hatch_Parameter self, Standard_Integer const theIndex, Hatch_Parameter theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Hatch.NCollection_Sequence_Hatch_Parameter_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Hatch_Parameter self, Standard_Integer const theIndex, NCollection_Sequence_Hatch_Parameter theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Hatch.NCollection_Sequence_Hatch_Parameter_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Hatch.NCollection_Sequence_Hatch_Parameter_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Hatch_Parameter self) -> Hatch_Parameter

        First item access

        :rtype: TheItemType &

        """
        return _Hatch.NCollection_Sequence_Hatch_Parameter_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Hatch.NCollection_Sequence_Hatch_Parameter_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Hatch_Parameter self) -> Hatch_Parameter

        Last item access

        :rtype: TheItemType &

        """
        return _Hatch.NCollection_Sequence_Hatch_Parameter_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Hatch.NCollection_Sequence_Hatch_Parameter_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Hatch_Parameter self, Standard_Integer const theIndex) -> Hatch_Parameter

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Hatch.NCollection_Sequence_Hatch_Parameter_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Hatch.NCollection_Sequence_Hatch_Parameter___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Hatch_Parameter self, Standard_Integer const theIndex, Hatch_Parameter theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Hatch.NCollection_Sequence_Hatch_Parameter_SetValue(self, *args)


    def __iter__(self):
        return _Hatch.NCollection_Sequence_Hatch_Parameter___iter__(self)
    __swig_destroy__ = _Hatch.delete_NCollection_Sequence_Hatch_Parameter
NCollection_Sequence_Hatch_Parameter_swigregister = _Hatch.NCollection_Sequence_Hatch_Parameter_swigregister
NCollection_Sequence_Hatch_Parameter_swigregister(NCollection_Sequence_Hatch_Parameter)

def NCollection_Sequence_Hatch_Parameter_delNode(*args):
    """
    NCollection_Sequence_Hatch_Parameter_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Hatch.NCollection_Sequence_Hatch_Parameter_delNode(*args)

class NCollection_Sequence_Hatch_Parameter_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Hatch.new_NCollection_Sequence_Hatch_Parameter_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Hatch.delete_NCollection_Sequence_Hatch_Parameter_IteratorHelper

    def __next__(self):
        return _Hatch.NCollection_Sequence_Hatch_Parameter_IteratorHelper___next__(self)
NCollection_Sequence_Hatch_Parameter_IteratorHelper_swigregister = _Hatch.NCollection_Sequence_Hatch_Parameter_IteratorHelper_swigregister
NCollection_Sequence_Hatch_Parameter_IteratorHelper_swigregister(NCollection_Sequence_Hatch_Parameter_IteratorHelper)


try:
	Hatch_SequenceOfParameter = NCollection_Sequence_Hatch_Parameter
except NameError:
	pass # does not exist, probably ignored

class NCollection_Sequence_Hatch_Line(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Hatch_Line self) -> NCollection_Sequence< Hatch_Line >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Hatch.NCollection_Sequence_Hatch_Line_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Hatch_Line self) -> NCollection_Sequence< Hatch_Line >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Hatch.NCollection_Sequence_Hatch_Line_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Hatch_Line self) -> NCollection_Sequence< Hatch_Line >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Hatch.NCollection_Sequence_Hatch_Line_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Hatch_Line self) -> NCollection_Sequence< Hatch_Line >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Hatch.NCollection_Sequence_Hatch_Line_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Hatch.new_NCollection_Sequence_Hatch_Line(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Hatch_Line self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Hatch.NCollection_Sequence_Hatch_Line_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Hatch_Line self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Hatch.NCollection_Sequence_Hatch_Line_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Hatch_Line self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Hatch.NCollection_Sequence_Hatch_Line_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Hatch_Line self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Hatch.NCollection_Sequence_Hatch_Line_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Hatch_Line self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Hatch.NCollection_Sequence_Hatch_Line_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Hatch_Line self)

        Reverse sequence


        """
        return _Hatch.NCollection_Sequence_Hatch_Line_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Hatch_Line self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Hatch.NCollection_Sequence_Hatch_Line_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Hatch.NCollection_Sequence_Hatch_Line_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Hatch_Line self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Hatch.NCollection_Sequence_Hatch_Line_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Hatch_Line self, NCollection_Sequence_Hatch_Line theOther) -> NCollection_Sequence_Hatch_Line

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Hatch.NCollection_Sequence_Hatch_Line_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Hatch_Line self, NCollection_Sequence_Hatch_Line theOther) -> NCollection_Sequence_Hatch_Line

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Hatch.NCollection_Sequence_Hatch_Line_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Hatch_Line self, NCollection_Sequence< Hatch_Line >::Iterator & thePosition)
        Remove(NCollection_Sequence_Hatch_Line self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Hatch_Line self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Hatch.NCollection_Sequence_Hatch_Line_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Hatch_Line self, Hatch_Line theItem)
        Append(NCollection_Sequence_Hatch_Line self, NCollection_Sequence_Hatch_Line theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Hatch.NCollection_Sequence_Hatch_Line_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Hatch_Line self, Hatch_Line theItem)
        Prepend(NCollection_Sequence_Hatch_Line self, NCollection_Sequence_Hatch_Line theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Hatch.NCollection_Sequence_Hatch_Line_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Hatch_Line self, Standard_Integer const theIndex, Hatch_Line theItem)
        InsertBefore(NCollection_Sequence_Hatch_Line self, Standard_Integer const theIndex, NCollection_Sequence_Hatch_Line theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Hatch.NCollection_Sequence_Hatch_Line_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Hatch_Line self, NCollection_Sequence< Hatch_Line >::Iterator & thePosition, Hatch_Line theItem)
        InsertAfter(NCollection_Sequence_Hatch_Line self, Standard_Integer const theIndex, NCollection_Sequence_Hatch_Line theSeq)
        InsertAfter(NCollection_Sequence_Hatch_Line self, Standard_Integer const theIndex, Hatch_Line theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Hatch.NCollection_Sequence_Hatch_Line_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Hatch_Line self, Standard_Integer const theIndex, NCollection_Sequence_Hatch_Line theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Hatch.NCollection_Sequence_Hatch_Line_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Hatch.NCollection_Sequence_Hatch_Line_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Hatch_Line self) -> Hatch_Line

        First item access

        :rtype: TheItemType &

        """
        return _Hatch.NCollection_Sequence_Hatch_Line_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Hatch.NCollection_Sequence_Hatch_Line_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Hatch_Line self) -> Hatch_Line

        Last item access

        :rtype: TheItemType &

        """
        return _Hatch.NCollection_Sequence_Hatch_Line_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Hatch.NCollection_Sequence_Hatch_Line_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Hatch_Line self, Standard_Integer const theIndex) -> Hatch_Line

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Hatch.NCollection_Sequence_Hatch_Line_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Hatch.NCollection_Sequence_Hatch_Line___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Hatch_Line self, Standard_Integer const theIndex, Hatch_Line theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Hatch.NCollection_Sequence_Hatch_Line_SetValue(self, *args)


    def __iter__(self):
        return _Hatch.NCollection_Sequence_Hatch_Line___iter__(self)
    __swig_destroy__ = _Hatch.delete_NCollection_Sequence_Hatch_Line
NCollection_Sequence_Hatch_Line_swigregister = _Hatch.NCollection_Sequence_Hatch_Line_swigregister
NCollection_Sequence_Hatch_Line_swigregister(NCollection_Sequence_Hatch_Line)

def NCollection_Sequence_Hatch_Line_delNode(*args):
    """
    NCollection_Sequence_Hatch_Line_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Hatch.NCollection_Sequence_Hatch_Line_delNode(*args)

class NCollection_Sequence_Hatch_Line_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Hatch.new_NCollection_Sequence_Hatch_Line_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Hatch.delete_NCollection_Sequence_Hatch_Line_IteratorHelper

    def __next__(self):
        return _Hatch.NCollection_Sequence_Hatch_Line_IteratorHelper___next__(self)
NCollection_Sequence_Hatch_Line_IteratorHelper_swigregister = _Hatch.NCollection_Sequence_Hatch_Line_IteratorHelper_swigregister
NCollection_Sequence_Hatch_Line_IteratorHelper_swigregister(NCollection_Sequence_Hatch_Line_IteratorHelper)


try:
	Hatch_SequenceOfLine = NCollection_Sequence_Hatch_Line
except NameError:
	pass # does not exist, probably ignored




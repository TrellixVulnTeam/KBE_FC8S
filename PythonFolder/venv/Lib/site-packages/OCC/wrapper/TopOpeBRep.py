# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_TopOpeBRep')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_TopOpeBRep')
    _TopOpeBRep = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_TopOpeBRep', [dirname(__file__)])
        except ImportError:
            import _TopOpeBRep
            return _TopOpeBRep
        try:
            _mod = imp.load_module('_TopOpeBRep', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _TopOpeBRep = swig_import_helper()
    del swig_import_helper
else:
    import _TopOpeBRep
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _TopOpeBRep.delete_SwigPyIterator

    def value(self):
        return _TopOpeBRep.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _TopOpeBRep.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _TopOpeBRep.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _TopOpeBRep.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _TopOpeBRep.SwigPyIterator_equal(self, x)

    def copy(self):
        return _TopOpeBRep.SwigPyIterator_copy(self)

    def next(self):
        return _TopOpeBRep.SwigPyIterator_next(self)

    def __next__(self):
        return _TopOpeBRep.SwigPyIterator___next__(self)

    def previous(self):
        return _TopOpeBRep.SwigPyIterator_previous(self)

    def advance(self, n):
        return _TopOpeBRep.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _TopOpeBRep.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _TopOpeBRep.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _TopOpeBRep.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _TopOpeBRep.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _TopOpeBRep.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _TopOpeBRep.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _TopOpeBRep.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TopOpeBRep.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_TopOpeBRep.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _TopOpeBRep.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TopOpeBRep.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRep.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _TopOpeBRep.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _TopOpeBRep.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _TopOpeBRep.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TopOpeBRep.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_TopOpeBRep.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _TopOpeBRep.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TopOpeBRep.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRep.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _TopOpeBRep.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _TopOpeBRep.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _TopOpeBRep.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _TopOpeBRep.ptr_to_number(item)
ptr_to_number = _TopOpeBRep.ptr_to_number

def HashCode(*args):
    return _TopOpeBRep.HashCode(*args)
HashCode = _TopOpeBRep.HashCode

def ptr_equal(a, b):
    return _TopOpeBRep.ptr_equal(a, b)
ptr_equal = _TopOpeBRep.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopOpeBRepDS
else:
    import TopOpeBRepDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopOpeBRepTool
else:
    import TopOpeBRepTool
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopExp
else:
    import TopExp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepClass3d
else:
    import BRepClass3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurveSurface
else:
    import IntCurveSurface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Intf
else:
    import Intf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntAna
else:
    import IntAna
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntSurf
else:
    import IntSurf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurvesFace
else:
    import IntCurvesFace
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntPatch
else:
    import IntPatch
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntWalk
else:
    import IntWalk
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntImp
else:
    import IntImp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepTopAdaptor
else:
    import BRepTopAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntRes2d
else:
    import IntRes2d
del _swig_python_version_info
TopOpeBRep_ANALYTIC = _TopOpeBRep.TopOpeBRep_ANALYTIC
TopOpeBRep_RESTRICTION = _TopOpeBRep.TopOpeBRep_RESTRICTION
TopOpeBRep_WALKING = _TopOpeBRep.TopOpeBRep_WALKING
TopOpeBRep_LINE = _TopOpeBRep.TopOpeBRep_LINE
TopOpeBRep_CIRCLE = _TopOpeBRep.TopOpeBRep_CIRCLE
TopOpeBRep_ELLIPSE = _TopOpeBRep.TopOpeBRep_ELLIPSE
TopOpeBRep_PARABOLA = _TopOpeBRep.TopOpeBRep_PARABOLA
TopOpeBRep_HYPERBOLA = _TopOpeBRep.TopOpeBRep_HYPERBOLA
TopOpeBRep_OTHERTYPE = _TopOpeBRep.TopOpeBRep_OTHERTYPE
TopOpeBRep_P2DUNK = _TopOpeBRep.TopOpeBRep_P2DUNK
TopOpeBRep_P2DINT = _TopOpeBRep.TopOpeBRep_P2DINT
TopOpeBRep_P2DSGF = _TopOpeBRep.TopOpeBRep_P2DSGF
TopOpeBRep_P2DSGL = _TopOpeBRep.TopOpeBRep_P2DSGL
TopOpeBRep_P2DNEW = _TopOpeBRep.TopOpeBRep_P2DNEW
class TopOpeBRep_VPointInter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(TopOpeBRep_VPointInter self) -> TopOpeBRep_VPointInter"""
        this = _TopOpeBRep.new_TopOpeBRep_VPointInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetPoint(self, *args):
        """
        SetPoint(TopOpeBRep_VPointInter self, IntPatch_Point P)

        :type P: OCC.wrapper.IntPatch.IntPatch_Point

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_SetPoint(self, *args)


    def SetShapes(self, *args):
        """
        SetShapes(TopOpeBRep_VPointInter self, Standard_Integer const I1, Standard_Integer const I2)

        :type I1: int
        :type I2: int

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_SetShapes(self, *args)


    def GetShapes(self, *args):
        """
        GetShapes(TopOpeBRep_VPointInter self)

        :type I1: int
        :type I2: int

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_GetShapes(self, *args)


    def TransitionOnS1(self, *args):
        """
        TransitionOnS1(TopOpeBRep_VPointInter self) -> IntSurf_Transition

        :rtype: OCC.wrapper.IntSurf.IntSurf_Transition

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_TransitionOnS1(self, *args)


    def TransitionOnS2(self, *args):
        """
        TransitionOnS2(TopOpeBRep_VPointInter self) -> IntSurf_Transition

        :rtype: OCC.wrapper.IntSurf.IntSurf_Transition

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_TransitionOnS2(self, *args)


    def TransitionLineArc1(self, *args):
        """
        TransitionLineArc1(TopOpeBRep_VPointInter self) -> IntSurf_Transition

        :rtype: OCC.wrapper.IntSurf.IntSurf_Transition

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_TransitionLineArc1(self, *args)


    def TransitionLineArc2(self, *args):
        """
        TransitionLineArc2(TopOpeBRep_VPointInter self) -> IntSurf_Transition

        :rtype: OCC.wrapper.IntSurf.IntSurf_Transition

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_TransitionLineArc2(self, *args)


    def IsOnDomS1(self, *args):
        """
        IsOnDomS1(TopOpeBRep_VPointInter self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_IsOnDomS1(self, *args)


    def IsOnDomS2(self, *args):
        """
        IsOnDomS2(TopOpeBRep_VPointInter self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_IsOnDomS2(self, *args)


    def ParametersOnS1(self, *args):
        """
        ParametersOnS1(TopOpeBRep_VPointInter self)

        :type u: float
        :type v: float

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_ParametersOnS1(self, *args)


    def ParametersOnS2(self, *args):
        """
        ParametersOnS2(TopOpeBRep_VPointInter self)

        :type u: float
        :type v: float

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_ParametersOnS2(self, *args)


    def Value(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _TopOpeBRep.TopOpeBRep_VPointInter_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tolerance(self, *args):
        """
        Tolerance(TopOpeBRep_VPointInter self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_Tolerance(self, *args)


    def ArcOnS1(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRep.TopOpeBRep_VPointInter_ArcOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ArcOnS2(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRep.TopOpeBRep_VPointInter_ArcOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParameterOnLine(self, *args):
        """
        ParameterOnLine(TopOpeBRep_VPointInter self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_ParameterOnLine(self, *args)


    def ParameterOnArc1(self, *args):
        """
        ParameterOnArc1(TopOpeBRep_VPointInter self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_ParameterOnArc1(self, *args)


    def IsVertexOnS1(self, *args):
        """
        IsVertexOnS1(TopOpeBRep_VPointInter self) -> Standard_Boolean

        Returns TRUE if the point is a vertex on the initial
        restriction facet of the first surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_IsVertexOnS1(self, *args)


    def VertexOnS1(self, *args):
        """
        Returns the information about the point when it is
        on the domain of the first patch, i-e when the function
        IsVertexOnS1 returns True.
        Otherwise, an exception is raised.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRep.TopOpeBRep_VPointInter_VertexOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParameterOnArc2(self, *args):
        """
        ParameterOnArc2(TopOpeBRep_VPointInter self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_ParameterOnArc2(self, *args)


    def IsVertexOnS2(self, *args):
        """
        IsVertexOnS2(TopOpeBRep_VPointInter self) -> Standard_Boolean

        Returns TRUE if the point is a vertex on the initial
        restriction facet of the second surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_IsVertexOnS2(self, *args)


    def VertexOnS2(self, *args):
        """
        Returns the information about the point when it is
        on the domain of the second patch, i-e when the function
        IsVertexOnS2 returns True.
        Otherwise, an exception is raised.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRep.TopOpeBRep_VPointInter_VertexOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsInternal(self, *args):
        """
        IsInternal(TopOpeBRep_VPointInter self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_IsInternal(self, *args)


    def IsMultiple(self, *args):
        """
        IsMultiple(TopOpeBRep_VPointInter self) -> Standard_Boolean

        Returns True if the point belongs to several intersection
        lines.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_IsMultiple(self, *args)


    def State(self, *args):
        """
        State(TopOpeBRep_VPointInter self, Standard_Integer const I) -> TopAbs_State
        State(TopOpeBRep_VPointInter self, TopAbs_State const S, Standard_Integer const I)

        Set the state of VPoint within the  domain of
        the geometric shape <I> (= 1 or 2).

        :type S: OCC.wrapper.TopAbs.TopAbs_State
        :type I: int

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_State(self, *args)


    def EdgeON(self, *args):
        """
        get the edge of shape I (1,2) containing the point.

        :type I: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRep.TopOpeBRep_VPointInter_EdgeON(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def EdgeONParameter(self, *args):
        """
        EdgeONParameter(TopOpeBRep_VPointInter self, Standard_Integer const I) -> Standard_Real

        get the parameter on edge of shape I (1,2) containing the point.

        :type I: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_EdgeONParameter(self, *args)


    def ShapeIndex(self, *args):
        """
        ShapeIndex(TopOpeBRep_VPointInter self) -> Standard_Integer
        ShapeIndex(TopOpeBRep_VPointInter self, Standard_Integer const I)

        set value of shape supporting me (0,1,2,3).

        :type I: int

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_ShapeIndex(self, *args)


    def Edge(self, *args):
        """
        get the edge of shape I (1,2) containing the point.
        Returned shape is null if the VPoint is not on an edge
        of shape I (1,2).

        :type I: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRep.TopOpeBRep_VPointInter_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def EdgeParameter(self, *args):
        """
        EdgeParameter(TopOpeBRep_VPointInter self, Standard_Integer const I) -> Standard_Real

        get the parameter on edge of shape I (1,2) containing the point

        :type I: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_EdgeParameter(self, *args)


    def SurfaceParameters(self, *args):
        """
        SurfaceParameters(TopOpeBRep_VPointInter self, Standard_Integer const I) -> gp_Pnt2d

        get the parameter on surface of shape I (1,2) containing the point

        :type I: int
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_SurfaceParameters(self, *args)


    def IsVertex(self, *args):
        """
        IsVertex(TopOpeBRep_VPointInter self, Standard_Integer const I) -> Standard_Boolean

        :type I: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_IsVertex(self, *args)


    def Vertex(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRep.TopOpeBRep_VPointInter_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UpdateKeep(self, *args):
        """
        UpdateKeep(TopOpeBRep_VPointInter self)

        set myKeep value according to current states.


        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_UpdateKeep(self, *args)


    def Keep(self, *args):
        """
        Keep(TopOpeBRep_VPointInter self) -> Standard_Boolean

        Returns value of myKeep (does not evaluate states)
        False at creation of VPoint.
        Updated by State(State from TopAbs,Integer from Standard)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_Keep(self, *args)


    def ChangeKeep(self, *args):
        """
        ChangeKeep(TopOpeBRep_VPointInter self, Standard_Boolean const keep)

        updates VPointInter flag "keep" with <keep>.

        :type keep: bool

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_ChangeKeep(self, *args)


    def EqualpP(self, *args):
        """
        EqualpP(TopOpeBRep_VPointInter self, TopOpeBRep_VPointInter VP) -> Standard_Boolean

        returns <True> if the 3d points and the parameters of the
        VPoints are same

        :type VP: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_EqualpP(self, *args)


    def ParonE(self, *args):
        """
        ParonE(TopOpeBRep_VPointInter self, TopoDS_Edge E) -> Standard_Boolean

        returns <false> if the vpoint is not given on arc <E>,
        else returns <par> parameter on <E>

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type par: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_ParonE(self, *args)


    def Index(self, *args):
        """
        Index(TopOpeBRep_VPointInter self, Standard_Integer const I)
        Index(TopOpeBRep_VPointInter self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_Index(self, *args)


    def Dump(self, *args):
        """
        Dump(TopOpeBRep_VPointInter self, Standard_Integer const I, TopoDS_Face F, Standard_OStream & OS) -> Standard_OStream
        Dump(TopOpeBRep_VPointInter self, TopoDS_Face F1, TopoDS_Face F2, Standard_OStream & OS) -> Standard_OStream &

        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_Dump(self, *args)


    def PThePointOfIntersectionDummy(self, *args):
        """
        PThePointOfIntersectionDummy(TopOpeBRep_VPointInter self) -> IntPatch_Point

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_PThePointOfIntersection

        """
        return _TopOpeBRep.TopOpeBRep_VPointInter_PThePointOfIntersectionDummy(self, *args)

    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_VPointInter
TopOpeBRep_VPointInter_swigregister = _TopOpeBRep.TopOpeBRep_VPointInter_swigregister
TopOpeBRep_VPointInter_swigregister(TopOpeBRep_VPointInter)

class TopOpeBRep_Hctxff2d(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopOpeBRep_Hctxff2d
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopOpeBRep_Hctxff2d(self) 
            return h


    def __init__(self, *args):
        """__init__(TopOpeBRep_Hctxff2d self) -> TopOpeBRep_Hctxff2d"""
        this = _TopOpeBRep.new_TopOpeBRep_Hctxff2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetFaces(self, *args):
        """
        SetFaces(TopOpeBRep_Hctxff2d self, TopoDS_Face F1, TopoDS_Face F2)

        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _TopOpeBRep.TopOpeBRep_Hctxff2d_SetFaces(self, *args)


    def SetHSurfaces(self, *args):
        """
        SetHSurfaces(TopOpeBRep_Hctxff2d self, Handle_BRepAdaptor_HSurface S1, Handle_BRepAdaptor_HSurface S2)

        :type S1: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
        :type S2: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface

        """
        return _TopOpeBRep.TopOpeBRep_Hctxff2d_SetHSurfaces(self, *args)


    def SetTolerances(self, *args):
        """
        SetTolerances(TopOpeBRep_Hctxff2d self, Standard_Real const Tol1, Standard_Real const Tol2)

        :type Tol1: float
        :type Tol2: float

        """
        return _TopOpeBRep.TopOpeBRep_Hctxff2d_SetTolerances(self, *args)


    def GetTolerances(self, *args):
        """
        GetTolerances(TopOpeBRep_Hctxff2d self)

        :type Tol1: float
        :type Tol2: float

        """
        return _TopOpeBRep.TopOpeBRep_Hctxff2d_GetTolerances(self, *args)


    def GetMaxTolerance(self, *args):
        """
        GetMaxTolerance(TopOpeBRep_Hctxff2d self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRep.TopOpeBRep_Hctxff2d_GetMaxTolerance(self, *args)


    def Face(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _TopOpeBRep.TopOpeBRep_Hctxff2d_Face(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HSurface(self, *args):
        """
        HSurface(TopOpeBRep_Hctxff2d self, Standard_Integer const I) -> Handle_BRepAdaptor_HSurface

        :type I: int
        :rtype: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface

        """
        return _TopOpeBRep.TopOpeBRep_Hctxff2d_HSurface(self, *args)


    def SurfacesSameOriented(self, *args):
        """
        SurfacesSameOriented(TopOpeBRep_Hctxff2d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_Hctxff2d_SurfacesSameOriented(self, *args)


    def FacesSameOriented(self, *args):
        """
        FacesSameOriented(TopOpeBRep_Hctxff2d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_Hctxff2d_FacesSameOriented(self, *args)


    def FaceSameOrientedWithRef(self, *args):
        """
        FaceSameOrientedWithRef(TopOpeBRep_Hctxff2d self, Standard_Integer const I) -> Standard_Boolean

        :type I: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_Hctxff2d_FaceSameOrientedWithRef(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopOpeBRep.TopOpeBRep_Hctxff2d_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopOpeBRep.TopOpeBRep_Hctxff2d_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRep.TopOpeBRep_Hctxff2d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_Hctxff2d
TopOpeBRep_Hctxff2d_swigregister = _TopOpeBRep.TopOpeBRep_Hctxff2d_swigregister
TopOpeBRep_Hctxff2d_swigregister(TopOpeBRep_Hctxff2d)

def TopOpeBRep_Hctxff2d_get_type_name(*args):
    """
    TopOpeBRep_Hctxff2d_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopOpeBRep.TopOpeBRep_Hctxff2d_get_type_name(*args)

def TopOpeBRep_Hctxff2d_get_type_descriptor(*args):
    """
    TopOpeBRep_Hctxff2d_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopOpeBRep.TopOpeBRep_Hctxff2d_get_type_descriptor(*args)

class TopOpeBRep_Bipoint(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRep_Bipoint self) -> TopOpeBRep_Bipoint
        __init__(TopOpeBRep_Bipoint self, Standard_Integer const I1, Standard_Integer const I2) -> TopOpeBRep_Bipoint

        :type I1: int
        :type I2: int

        """
        this = _TopOpeBRep.new_TopOpeBRep_Bipoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def I1(self, *args):
        """
        I1(TopOpeBRep_Bipoint self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.TopOpeBRep_Bipoint_I1(self, *args)


    def I2(self, *args):
        """
        I2(TopOpeBRep_Bipoint self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.TopOpeBRep_Bipoint_I2(self, *args)

    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_Bipoint
TopOpeBRep_Bipoint_swigregister = _TopOpeBRep.TopOpeBRep_Bipoint_swigregister
TopOpeBRep_Bipoint_swigregister(TopOpeBRep_Bipoint)

class TopOpeBRep_HArray1OfVPointInter(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopOpeBRep_HArray1OfVPointInter
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopOpeBRep_HArray1OfVPointInter(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopOpeBRep_HArray1OfVPointInter self, Standard_Integer const theLower, Standard_Integer const theUpper) -> TopOpeBRep_HArray1OfVPointInter
        __init__(TopOpeBRep_HArray1OfVPointInter self, Standard_Integer const theLower, Standard_Integer const theUpper, TopOpeBRep_VPointInter theValue) -> TopOpeBRep_HArray1OfVPointInter
        __init__(TopOpeBRep_HArray1OfVPointInter self, NCollection_Array1_TopOpeBRep_VPointInter theOther) -> TopOpeBRep_HArray1OfVPointInter

        :type theOther: OCC.wrapper.TopOpeBRep.TopOpeBRep_Array1OfVPointInter

        """
        this = _TopOpeBRep.new_TopOpeBRep_HArray1OfVPointInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_Array1OfVPointInter

        """
        res = _TopOpeBRep.TopOpeBRep_HArray1OfVPointInter_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(TopOpeBRep_HArray1OfVPointInter self) -> NCollection_Array1_TopOpeBRep_VPointInter

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_Array1OfVPointInter

        """
        return _TopOpeBRep.TopOpeBRep_HArray1OfVPointInter_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopOpeBRep.TopOpeBRep_HArray1OfVPointInter_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopOpeBRep.TopOpeBRep_HArray1OfVPointInter_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRep.TopOpeBRep_HArray1OfVPointInter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_HArray1OfVPointInter
TopOpeBRep_HArray1OfVPointInter_swigregister = _TopOpeBRep.TopOpeBRep_HArray1OfVPointInter_swigregister
TopOpeBRep_HArray1OfVPointInter_swigregister(TopOpeBRep_HArray1OfVPointInter)

def TopOpeBRep_HArray1OfVPointInter_get_type_name(*args):
    """
    TopOpeBRep_HArray1OfVPointInter_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopOpeBRep.TopOpeBRep_HArray1OfVPointInter_get_type_name(*args)

def TopOpeBRep_HArray1OfVPointInter_get_type_descriptor(*args):
    """
    TopOpeBRep_HArray1OfVPointInter_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopOpeBRep.TopOpeBRep_HArray1OfVPointInter_get_type_descriptor(*args)

class TopOpeBRep_ShapeIntersector(object):
    """
    Intersect two shapes.

    A GeomShape is a  shape with a geometric domain, i.e.
    a Face or an Edge.

    The purpose   of  the  ShapeIntersector is   to  find
    couples  of  intersecting   GeomShape  in  two Shapes
    (which can   be  any kind of  topologies  : Compound,
    Solid, Shell, etc... )

    It  is in charge  of  exploration  of the shapes  and
    rejection. For this it is provided with two tools :

    - ShapeExplorer from TopOpeBRepTool.
    - ShapeScanner from TopOpeBRep which implements bounding boxes.

    Let S1,S2 the shapes sent to InitIntersection(S1,S2) method :
    - S1 is always SCANNED by a ShapeScanner from TopOpeBRep.
    - S2 is always EXPLORED by a ShapeExplorer from TopOpeBRepTool.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRep_ShapeIntersector self) -> TopOpeBRep_ShapeIntersector

        Intersect two shapes.

        A GeomShape is a  shape with a geometric domain, i.e.
        a Face or an Edge.

        The purpose   of  the  ShapeIntersector is   to  find
        couples  of  intersecting   GeomShape  in  two Shapes
        (which can   be  any kind of  topologies  : Compound,
        Solid, Shell, etc... )

        It  is in charge  of  exploration  of the shapes  and
        rejection. For this it is provided with two tools :

        - ShapeExplorer from TopOpeBRepTool.
        - ShapeScanner from TopOpeBRep which implements bounding boxes.

        Let S1,S2 the shapes sent to InitIntersection(S1,S2) method :
        - S1 is always SCANNED by a ShapeScanner from TopOpeBRep.
        - S2 is always EXPLORED by a ShapeExplorer from TopOpeBRepTool.
        """
        this = _TopOpeBRep.new_TopOpeBRep_ShapeIntersector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def InitIntersection(self, *args):
        """
        InitIntersection(TopOpeBRep_ShapeIntersector self, TopoDS_Shape S1, TopoDS_Shape S2)
        InitIntersection(TopOpeBRep_ShapeIntersector self, TopoDS_Shape S1, TopoDS_Shape S2, TopoDS_Face F1, TopoDS_Face F2)

        Initialize the intersection of shapes S1,S2.

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _TopOpeBRep.TopOpeBRep_ShapeIntersector_InitIntersection(self, *args)


    def Shape(self, *args):
        """
        return  the shape  <Index> ( = 1 or 2) given to
        InitIntersection().
        Index = 1 will return S1, Index = 2 will return S2.

        :type Index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRep.TopOpeBRep_ShapeIntersector_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MoreIntersection(self, *args):
        """
        MoreIntersection(TopOpeBRep_ShapeIntersector self) -> Standard_Boolean

        returns True if there are more intersection
        between two the shapes.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_ShapeIntersector_MoreIntersection(self, *args)


    def NextIntersection(self, *args):
        """
        NextIntersection(TopOpeBRep_ShapeIntersector self)

        search for the next intersection between the two shapes.


        """
        return _TopOpeBRep.TopOpeBRep_ShapeIntersector_NextIntersection(self, *args)


    def ChangeFacesIntersector(self, *args):
        """
        ChangeFacesIntersector(TopOpeBRep_ShapeIntersector self) -> TopOpeBRep_FacesIntersector

        return the current intersection of two Faces.

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_FacesIntersector

        """
        return _TopOpeBRep.TopOpeBRep_ShapeIntersector_ChangeFacesIntersector(self, *args)


    def ChangeEdgesIntersector(self, *args):
        """
        ChangeEdgesIntersector(TopOpeBRep_ShapeIntersector self) -> TopOpeBRep_EdgesIntersector

        return the current intersection of two Edges.

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_EdgesIntersector

        """
        return _TopOpeBRep.TopOpeBRep_ShapeIntersector_ChangeEdgesIntersector(self, *args)


    def ChangeFaceEdgeIntersector(self, *args):
        """
        ChangeFaceEdgeIntersector(TopOpeBRep_ShapeIntersector self) -> TopOpeBRep_FaceEdgeIntersector

        return the current intersection of a Face and an Edge.

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_FaceEdgeIntersector

        """
        return _TopOpeBRep.TopOpeBRep_ShapeIntersector_ChangeFaceEdgeIntersector(self, *args)


    def CurrentGeomShape(self, *args):
        """
        return  geometric  shape <Index> ( = 1 or 2 )  of
        current intersection.

        :type Index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRep.TopOpeBRep_ShapeIntersector_CurrentGeomShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetTolerances(self, *args):
        """
        GetTolerances(TopOpeBRep_ShapeIntersector self)

        return  MAX of intersection tolerances with
        which FacesIntersector from TopOpeBRep was working.

        :type tol1: float
        :type tol2: float

        """
        return _TopOpeBRep.TopOpeBRep_ShapeIntersector_GetTolerances(self, *args)


    def DumpCurrent(self, *args):
        """
        DumpCurrent(TopOpeBRep_ShapeIntersector self, Standard_Integer const K)

        :type K: int

        """
        return _TopOpeBRep.TopOpeBRep_ShapeIntersector_DumpCurrent(self, *args)


    def Index(self, *args):
        """
        Index(TopOpeBRep_ShapeIntersector self, Standard_Integer const K) -> Standard_Integer

        :type K: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.TopOpeBRep_ShapeIntersector_Index(self, *args)


    def RejectedFaces(self, *args):
        """
        RejectedFaces(TopOpeBRep_ShapeIntersector self, TopoDS_Shape anObj, TopoDS_Shape aReference, NCollection_List_TopoDS_Shape aListOfShape)

        :type anObj: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aReference: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aListOfShape: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _TopOpeBRep.TopOpeBRep_ShapeIntersector_RejectedFaces(self, *args)

    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_ShapeIntersector
TopOpeBRep_ShapeIntersector_swigregister = _TopOpeBRep.TopOpeBRep_ShapeIntersector_swigregister
TopOpeBRep_ShapeIntersector_swigregister(TopOpeBRep_ShapeIntersector)

class TopOpeBRep_ShapeIntersector2d(object):
    """
    Intersect two shapes.

    A GeomShape is a  shape with a geometric domain, i.e.
    a Face or an Edge.

    The purpose   of  the  ShapeIntersector2d is   to  find
    couples  of  intersecting   GeomShape  in  two Shapes
    (which can   be  any kind of  topologies  : Compound,
    Solid, Shell, etc... )

    It  is in charge  of  exploration  of the shapes  and
    rejection. For this it is provided with two tools :

    - ShapeExplorer from TopOpeBRepTool.
    - ShapeScanner from TopOpeBRep which implements bounding boxes.

    Let S1,S2 the shapes sent to InitIntersection(S1,S2) method :
    - S1 is always SCANNED by a ShapeScanner from TopOpeBRep.
    - S2 is always EXPLORED by a ShapeExplorer from TopOpeBRepTool.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRep_ShapeIntersector2d self) -> TopOpeBRep_ShapeIntersector2d

        Intersect two shapes.

        A GeomShape is a  shape with a geometric domain, i.e.
        a Face or an Edge.

        The purpose   of  the  ShapeIntersector2d is   to  find
        couples  of  intersecting   GeomShape  in  two Shapes
        (which can   be  any kind of  topologies  : Compound,
        Solid, Shell, etc... )

        It  is in charge  of  exploration  of the shapes  and
        rejection. For this it is provided with two tools :

        - ShapeExplorer from TopOpeBRepTool.
        - ShapeScanner from TopOpeBRep which implements bounding boxes.

        Let S1,S2 the shapes sent to InitIntersection(S1,S2) method :
        - S1 is always SCANNED by a ShapeScanner from TopOpeBRep.
        - S2 is always EXPLORED by a ShapeExplorer from TopOpeBRepTool.
        """
        this = _TopOpeBRep.new_TopOpeBRep_ShapeIntersector2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def InitIntersection(self, *args):
        """
        InitIntersection(TopOpeBRep_ShapeIntersector2d self, TopoDS_Shape S1, TopoDS_Shape S2)

        Initialize the intersection of shapes S1,S2.

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRep.TopOpeBRep_ShapeIntersector2d_InitIntersection(self, *args)


    def Shape(self, *args):
        """
        return  the shape  <Index> ( = 1 or 2) given to
        InitIntersection().
        Index = 1 will return S1, Index = 2 will return S2.

        :type Index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRep.TopOpeBRep_ShapeIntersector2d_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MoreIntersection(self, *args):
        """
        MoreIntersection(TopOpeBRep_ShapeIntersector2d self) -> Standard_Boolean

        returns True if there are more intersection
        between two the shapes.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_ShapeIntersector2d_MoreIntersection(self, *args)


    def NextIntersection(self, *args):
        """
        NextIntersection(TopOpeBRep_ShapeIntersector2d self)

        search for the next intersection between the two shapes.


        """
        return _TopOpeBRep.TopOpeBRep_ShapeIntersector2d_NextIntersection(self, *args)


    def ChangeEdgesIntersector(self, *args):
        """
        ChangeEdgesIntersector(TopOpeBRep_ShapeIntersector2d self) -> TopOpeBRep_EdgesIntersector

        return the current intersection of two Edges.

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_EdgesIntersector

        """
        return _TopOpeBRep.TopOpeBRep_ShapeIntersector2d_ChangeEdgesIntersector(self, *args)


    def CurrentGeomShape(self, *args):
        """
        return  geometric  shape <Index> ( = 1 or 2 )  of
        current intersection.

        :type Index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRep.TopOpeBRep_ShapeIntersector2d_CurrentGeomShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DumpCurrent(self, *args):
        """
        DumpCurrent(TopOpeBRep_ShapeIntersector2d self, Standard_Integer const K)

        :type K: int

        """
        return _TopOpeBRep.TopOpeBRep_ShapeIntersector2d_DumpCurrent(self, *args)


    def Index(self, *args):
        """
        Index(TopOpeBRep_ShapeIntersector2d self, Standard_Integer const K) -> Standard_Integer

        :type K: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.TopOpeBRep_ShapeIntersector2d_Index(self, *args)

    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_ShapeIntersector2d
TopOpeBRep_ShapeIntersector2d_swigregister = _TopOpeBRep.TopOpeBRep_ShapeIntersector2d_swigregister
TopOpeBRep_ShapeIntersector2d_swigregister(TopOpeBRep_ShapeIntersector2d)

class TopOpeBRep_PointGeomTool(object):
    """Provide services needed by the Fillers"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def MakePoint(*args):
        """
        MakePoint(TopOpeBRep_VPointInter IP) -> TopOpeBRepDS_Point
        MakePoint(TopOpeBRep_Point2d P2D) -> TopOpeBRepDS_Point
        MakePoint(TopOpeBRep_FaceEdgeIntersector FEI) -> TopOpeBRepDS_Point
        MakePoint(TopoDS_Shape S) -> TopOpeBRepDS_Point

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Point

        """
        return _TopOpeBRep.TopOpeBRep_PointGeomTool_MakePoint(*args)

    MakePoint = staticmethod(MakePoint)

    def IsEqual(*args):
        """
        IsEqual(TopOpeBRepDS_Point DSP1, TopOpeBRepDS_Point DSP2) -> Standard_Boolean

        :type DSP1: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Point
        :type DSP2: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Point
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_PointGeomTool_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def __init__(self):
        """Provide services needed by the Fillers"""
        this = _TopOpeBRep.new_TopOpeBRep_PointGeomTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_PointGeomTool
TopOpeBRep_PointGeomTool_swigregister = _TopOpeBRep.TopOpeBRep_PointGeomTool_swigregister
TopOpeBRep_PointGeomTool_swigregister(TopOpeBRep_PointGeomTool)

def TopOpeBRep_PointGeomTool_MakePoint(*args):
    """
    MakePoint(TopOpeBRep_VPointInter IP) -> TopOpeBRepDS_Point
    MakePoint(TopOpeBRep_Point2d P2D) -> TopOpeBRepDS_Point
    MakePoint(TopOpeBRep_FaceEdgeIntersector FEI) -> TopOpeBRepDS_Point
    TopOpeBRep_PointGeomTool_MakePoint(TopoDS_Shape S) -> TopOpeBRepDS_Point

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Point

    """
    return _TopOpeBRep.TopOpeBRep_PointGeomTool_MakePoint(*args)

def TopOpeBRep_PointGeomTool_IsEqual(*args):
    """
    TopOpeBRep_PointGeomTool_IsEqual(TopOpeBRepDS_Point DSP1, TopOpeBRepDS_Point DSP2) -> Standard_Boolean

    :type DSP1: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Point
    :type DSP2: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Point
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRep.TopOpeBRep_PointGeomTool_IsEqual(*args)

class TopOpeBRep_WPointInter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(TopOpeBRep_WPointInter self) -> TopOpeBRep_WPointInter"""
        this = _TopOpeBRep.new_TopOpeBRep_WPointInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Set(self, *args):
        """
        Set(TopOpeBRep_WPointInter self, IntSurf_PntOn2S P)

        :type P: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        return _TopOpeBRep.TopOpeBRep_WPointInter_Set(self, *args)


    def ParametersOnS1(self, *args):
        """
        ParametersOnS1(TopOpeBRep_WPointInter self)

        :type U: float
        :type V: float

        """
        return _TopOpeBRep.TopOpeBRep_WPointInter_ParametersOnS1(self, *args)


    def ParametersOnS2(self, *args):
        """
        ParametersOnS2(TopOpeBRep_WPointInter self)

        :type U: float
        :type V: float

        """
        return _TopOpeBRep.TopOpeBRep_WPointInter_ParametersOnS2(self, *args)


    def Parameters(self, *args):
        """
        Parameters(TopOpeBRep_WPointInter self)

        :type U1: float
        :type V1: float
        :type U2: float
        :type V2: float

        """
        return _TopOpeBRep.TopOpeBRep_WPointInter_Parameters(self, *args)


    def ValueOnS1(self, *args):
        """
        ValueOnS1(TopOpeBRep_WPointInter self) -> gp_Pnt2d

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _TopOpeBRep.TopOpeBRep_WPointInter_ValueOnS1(self, *args)


    def ValueOnS2(self, *args):
        """
        ValueOnS2(TopOpeBRep_WPointInter self) -> gp_Pnt2d

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _TopOpeBRep.TopOpeBRep_WPointInter_ValueOnS2(self, *args)


    def Value(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _TopOpeBRep.TopOpeBRep_WPointInter_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PPntOn2SDummy(self, *args):
        """
        PPntOn2SDummy(TopOpeBRep_WPointInter self) -> IntSurf_PntOn2S

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_PPntOn2S

        """
        return _TopOpeBRep.TopOpeBRep_WPointInter_PPntOn2SDummy(self, *args)

    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_WPointInter
TopOpeBRep_WPointInter_swigregister = _TopOpeBRep.TopOpeBRep_WPointInter_swigregister
TopOpeBRep_WPointInter_swigregister(TopOpeBRep_WPointInter)

class Handle_TopOpeBRep_Hctxff2d(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopOpeBRep_Hctxff2d self)

        Nullify the handle


        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopOpeBRep_Hctxff2d self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopOpeBRep_Hctxff2d self, TopOpeBRep_Hctxff2d thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopOpeBRep_Hctxff2d self, Handle_TopOpeBRep_Hctxff2d theHandle) -> Handle_TopOpeBRep_Hctxff2d
        assign(Handle_TopOpeBRep_Hctxff2d self, TopOpeBRep_Hctxff2d thePtr) -> Handle_TopOpeBRep_Hctxff2d
        assign(Handle_TopOpeBRep_Hctxff2d self, Handle_TopOpeBRep_Hctxff2d theHandle) -> Handle_TopOpeBRep_Hctxff2d

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopOpeBRep_Hctxff2d self) -> TopOpeBRep_Hctxff2d

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopOpeBRep_Hctxff2d self) -> TopOpeBRep_Hctxff2d

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopOpeBRep_Hctxff2d self) -> TopOpeBRep_Hctxff2d

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d___ref__(self, *args)


    def __hash__(self):
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopOpeBRep.new_Handle_TopOpeBRep_Hctxff2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_DownCast)
    __swig_destroy__ = _TopOpeBRep.delete_Handle_TopOpeBRep_Hctxff2d

    def SetFaces(self, *args):
        """
        SetFaces(Handle_TopOpeBRep_Hctxff2d self, TopoDS_Face F1, TopoDS_Face F2)

        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_SetFaces(self, *args)


    def SetHSurfaces(self, *args):
        """
        SetHSurfaces(Handle_TopOpeBRep_Hctxff2d self, Handle_BRepAdaptor_HSurface S1, Handle_BRepAdaptor_HSurface S2)

        :type S1: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
        :type S2: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_SetHSurfaces(self, *args)


    def SetTolerances(self, *args):
        """
        SetTolerances(Handle_TopOpeBRep_Hctxff2d self, Standard_Real const Tol1, Standard_Real const Tol2)

        :type Tol1: float
        :type Tol2: float

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_SetTolerances(self, *args)


    def GetTolerances(self, *args):
        """
        GetTolerances(Handle_TopOpeBRep_Hctxff2d self)

        :type Tol1: float
        :type Tol2: float

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_GetTolerances(self, *args)


    def GetMaxTolerance(self, *args):
        """
        GetMaxTolerance(Handle_TopOpeBRep_Hctxff2d self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_GetMaxTolerance(self, *args)


    def Face(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_Face(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HSurface(self, *args):
        """
        HSurface(Handle_TopOpeBRep_Hctxff2d self, Standard_Integer const I) -> Handle_BRepAdaptor_HSurface

        :type I: int
        :rtype: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_HSurface(self, *args)


    def SurfacesSameOriented(self, *args):
        """
        SurfacesSameOriented(Handle_TopOpeBRep_Hctxff2d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_SurfacesSameOriented(self, *args)


    def FacesSameOriented(self, *args):
        """
        FacesSameOriented(Handle_TopOpeBRep_Hctxff2d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_FacesSameOriented(self, *args)


    def FaceSameOrientedWithRef(self, *args):
        """
        FaceSameOrientedWithRef(Handle_TopOpeBRep_Hctxff2d self, Standard_Integer const I) -> Standard_Boolean

        :type I: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_FaceSameOrientedWithRef(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopOpeBRep_Hctxff2d self) -> char const *

        :rtype: const char *

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TopOpeBRep_Hctxff2d self)

        Memory deallocator for transient classes


        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopOpeBRep_Hctxff2d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopOpeBRep_Hctxff2d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopOpeBRep_Hctxff2d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopOpeBRep_Hctxff2d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopOpeBRep_Hctxff2d self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopOpeBRep_Hctxff2d self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopOpeBRep_Hctxff2d self)

        Increments the reference counter of this object


        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopOpeBRep_Hctxff2d self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_DecrementRefCounter(self, *args)

Handle_TopOpeBRep_Hctxff2d_swigregister = _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_swigregister
Handle_TopOpeBRep_Hctxff2d_swigregister(Handle_TopOpeBRep_Hctxff2d)

def Handle_TopOpeBRep_Hctxff2d_DownCast(thing):
    return _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_DownCast(thing)
Handle_TopOpeBRep_Hctxff2d_DownCast = _TopOpeBRep.Handle_TopOpeBRep_Hctxff2d_DownCast

class NCollection_Array1_TopOpeBRep_VPointInter(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_TopOpeBRep_VPointInter self) -> NCollection_Array1< TopOpeBRep_VPointInter >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_VPointInter_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_TopOpeBRep_VPointInter self) -> NCollection_Array1< TopOpeBRep_VPointInter >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_VPointInter_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_TopOpeBRep_VPointInter self) -> NCollection_Array1< TopOpeBRep_VPointInter >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_VPointInter_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_TopOpeBRep_VPointInter self) -> NCollection_Array1< TopOpeBRep_VPointInter >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_VPointInter_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _TopOpeBRep.new_NCollection_Array1_TopOpeBRep_VPointInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_TopOpeBRep_VPointInter self, TopOpeBRep_VPointInter theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_VPointInter_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_TopOpeBRep_VPointInter self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_VPointInter_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_TopOpeBRep_VPointInter self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_VPointInter_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_TopOpeBRep_VPointInter self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_VPointInter_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_TopOpeBRep_VPointInter self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_VPointInter_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_TopOpeBRep_VPointInter self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_VPointInter_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_TopOpeBRep_VPointInter self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_VPointInter_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_TopOpeBRep_VPointInter self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_VPointInter_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_TopOpeBRep_VPointInter self, NCollection_Array1_TopOpeBRep_VPointInter theOther) -> NCollection_Array1_TopOpeBRep_VPointInter

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_VPointInter_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_TopOpeBRep_VPointInter self, NCollection_Array1_TopOpeBRep_VPointInter theOther) -> NCollection_Array1_TopOpeBRep_VPointInter

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_VPointInter_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_TopOpeBRep_VPointInter self, NCollection_Array1_TopOpeBRep_VPointInter theOther) -> NCollection_Array1_TopOpeBRep_VPointInter
        assign(NCollection_Array1_TopOpeBRep_VPointInter self, NCollection_Array1_TopOpeBRep_VPointInter theOther) -> NCollection_Array1_TopOpeBRep_VPointInter

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_VPointInter_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _TopOpeBRep.NCollection_Array1_TopOpeBRep_VPointInter_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_TopOpeBRep_VPointInter self) -> TopOpeBRep_VPointInter

        @return first element

        :rtype: TheItemType &

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_VPointInter_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _TopOpeBRep.NCollection_Array1_TopOpeBRep_VPointInter_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_TopOpeBRep_VPointInter self) -> TopOpeBRep_VPointInter

        @return last element

        :rtype: TheItemType &

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_VPointInter_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopOpeBRep.NCollection_Array1_TopOpeBRep_VPointInter_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_TopOpeBRep_VPointInter self, Standard_Integer const theIndex) -> TopOpeBRep_VPointInter

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_VPointInter_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopOpeBRep.NCollection_Array1_TopOpeBRep_VPointInter___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopOpeBRep.NCollection_Array1_TopOpeBRep_VPointInter_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_TopOpeBRep_VPointInter self, Standard_Integer const theIndex, TopOpeBRep_VPointInter theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_VPointInter_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_TopOpeBRep_VPointInter self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_VPointInter_Resize(self, *args)

    __swig_destroy__ = _TopOpeBRep.delete_NCollection_Array1_TopOpeBRep_VPointInter
NCollection_Array1_TopOpeBRep_VPointInter_swigregister = _TopOpeBRep.NCollection_Array1_TopOpeBRep_VPointInter_swigregister
NCollection_Array1_TopOpeBRep_VPointInter_swigregister(NCollection_Array1_TopOpeBRep_VPointInter)


try:
	TopOpeBRep_Array1OfVPointInter = NCollection_Array1_TopOpeBRep_VPointInter
except NameError:
	pass # does not exist, probably ignored

class TopOpeBRep_GeomTool(object):
    """Provide services needed by the DSFiller"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def MakeCurves(*args):
        """
        MakeCurves(Standard_Real const min, Standard_Real const max, TopOpeBRep_LineInter L, TopoDS_Shape S1, TopoDS_Shape S2, TopOpeBRepDS_Curve C, Handle_Geom2d_Curve PC1, Handle_Geom2d_Curve PC2)

        Make the  DS curve <C> and the pcurves <PC1,PC2> from
        intersection line <L> lying on shapes <S1,S2>. <min,max> = <L> bounds

        :type min: float
        :type max: float
        :type L: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter
        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type C: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve
        :type PC1: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type PC2: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _TopOpeBRep.TopOpeBRep_GeomTool_MakeCurves(*args)

    MakeCurves = staticmethod(MakeCurves)

    def MakeCurve(*args):
        """
        MakeCurve(Standard_Real const min, Standard_Real const max, TopOpeBRep_LineInter L, Handle_Geom_Curve C)

        :type min: float
        :type max: float
        :type L: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _TopOpeBRep.TopOpeBRep_GeomTool_MakeCurve(*args)

    MakeCurve = staticmethod(MakeCurve)

    def MakeBSpline1fromWALKING3d(*args):
        """
        MakeBSpline1fromWALKING3d(TopOpeBRep_LineInter L) -> Handle_Geom_Curve

        :type L: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _TopOpeBRep.TopOpeBRep_GeomTool_MakeBSpline1fromWALKING3d(*args)

    MakeBSpline1fromWALKING3d = staticmethod(MakeBSpline1fromWALKING3d)

    def MakeBSpline1fromWALKING2d(*args):
        """
        MakeBSpline1fromWALKING2d(TopOpeBRep_LineInter L, Standard_Integer const SI) -> Handle_Geom2d_Curve

        :type L: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter
        :type SI: int
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _TopOpeBRep.TopOpeBRep_GeomTool_MakeBSpline1fromWALKING2d(*args)

    MakeBSpline1fromWALKING2d = staticmethod(MakeBSpline1fromWALKING2d)

    def __init__(self):
        """Provide services needed by the DSFiller"""
        this = _TopOpeBRep.new_TopOpeBRep_GeomTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_GeomTool
TopOpeBRep_GeomTool_swigregister = _TopOpeBRep.TopOpeBRep_GeomTool_swigregister
TopOpeBRep_GeomTool_swigregister(TopOpeBRep_GeomTool)

def TopOpeBRep_GeomTool_MakeCurves(*args):
    """
    TopOpeBRep_GeomTool_MakeCurves(Standard_Real const min, Standard_Real const max, TopOpeBRep_LineInter L, TopoDS_Shape S1, TopoDS_Shape S2, TopOpeBRepDS_Curve C, Handle_Geom2d_Curve PC1, Handle_Geom2d_Curve PC2)

    Make the  DS curve <C> and the pcurves <PC1,PC2> from
    intersection line <L> lying on shapes <S1,S2>. <min,max> = <L> bounds

    :type min: float
    :type max: float
    :type L: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter
    :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
    :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
    :type C: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve
    :type PC1: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type PC2: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

    """
    return _TopOpeBRep.TopOpeBRep_GeomTool_MakeCurves(*args)

def TopOpeBRep_GeomTool_MakeCurve(*args):
    """
    TopOpeBRep_GeomTool_MakeCurve(Standard_Real const min, Standard_Real const max, TopOpeBRep_LineInter L, Handle_Geom_Curve C)

    :type min: float
    :type max: float
    :type L: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter
    :type C: OCC.wrapper.Geom.Handle_Geom_Curve

    """
    return _TopOpeBRep.TopOpeBRep_GeomTool_MakeCurve(*args)

def TopOpeBRep_GeomTool_MakeBSpline1fromWALKING3d(*args):
    """
    TopOpeBRep_GeomTool_MakeBSpline1fromWALKING3d(TopOpeBRep_LineInter L) -> Handle_Geom_Curve

    :type L: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter
    :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

    """
    return _TopOpeBRep.TopOpeBRep_GeomTool_MakeBSpline1fromWALKING3d(*args)

def TopOpeBRep_GeomTool_MakeBSpline1fromWALKING2d(*args):
    """
    TopOpeBRep_GeomTool_MakeBSpline1fromWALKING2d(TopOpeBRep_LineInter L, Standard_Integer const SI) -> Handle_Geom2d_Curve

    :type L: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter
    :type SI: int
    :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

    """
    return _TopOpeBRep.TopOpeBRep_GeomTool_MakeBSpline1fromWALKING2d(*args)

class TopOpeBRep_LineInter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(TopOpeBRep_LineInter self) -> TopOpeBRep_LineInter"""
        this = _TopOpeBRep.new_TopOpeBRep_LineInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetLine(self, *args):
        """
        SetLine(TopOpeBRep_LineInter self, Handle_IntPatch_Line L, BRepAdaptor_Surface S1, BRepAdaptor_Surface S2)

        :type L: OCC.wrapper.IntPatch.Handle_IntPatch_Line
        :type S1: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type S2: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_SetLine(self, *args)


    def SetFaces(self, *args):
        """
        SetFaces(TopOpeBRep_LineInter self, TopoDS_Face F1, TopoDS_Face F2)

        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_SetFaces(self, *args)


    def TypeLineCurve(self, *args):
        """
        TypeLineCurve(TopOpeBRep_LineInter self) -> TopOpeBRep_TypeLineCurve

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_TypeLineCurve

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_TypeLineCurve(self, *args)


    def NbVPoint(self, *args):
        """
        NbVPoint(TopOpeBRep_LineInter self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_NbVPoint(self, *args)


    def VPoint(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter

        """
        res = _TopOpeBRep.TopOpeBRep_LineInter_VPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeVPoint(self, *args):
        """
        ChangeVPoint(TopOpeBRep_LineInter self, Standard_Integer const I) -> TopOpeBRep_VPointInter

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_ChangeVPoint(self, *args)


    def SetINL(self, *args):
        """SetINL(TopOpeBRep_LineInter self)"""
        return _TopOpeBRep.TopOpeBRep_LineInter_SetINL(self, *args)


    def INL(self, *args):
        """
        INL(TopOpeBRep_LineInter self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_INL(self, *args)


    def SetIsVClosed(self, *args):
        """SetIsVClosed(TopOpeBRep_LineInter self)"""
        return _TopOpeBRep.TopOpeBRep_LineInter_SetIsVClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(TopOpeBRep_LineInter self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_IsVClosed(self, *args)


    def SetOK(self, *args):
        """
        SetOK(TopOpeBRep_LineInter self, Standard_Boolean const B)

        :type B: bool

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_SetOK(self, *args)


    def OK(self, *args):
        """
        OK(TopOpeBRep_LineInter self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_OK(self, *args)


    def SetHasVPonR(self, *args):
        """SetHasVPonR(TopOpeBRep_LineInter self)"""
        return _TopOpeBRep.TopOpeBRep_LineInter_SetHasVPonR(self, *args)


    def HasVPonR(self, *args):
        """
        HasVPonR(TopOpeBRep_LineInter self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_HasVPonR(self, *args)


    def SetVPBounds(self, *args):
        """SetVPBounds(TopOpeBRep_LineInter self)"""
        return _TopOpeBRep.TopOpeBRep_LineInter_SetVPBounds(self, *args)


    def VPBounds(self, *args):
        """
        VPBounds(TopOpeBRep_LineInter self)

        :type f: int
        :type l: int
        :type n: int

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_VPBounds(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(TopOpeBRep_LineInter self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(TopOpeBRep_LineInter self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_Period(self, *args)


    def Bounds(self, *args):
        """
        Bounds(TopOpeBRep_LineInter self)

        :type f: float
        :type l: float

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_Bounds(self, *args)


    def HasVInternal(self, *args):
        """
        HasVInternal(TopOpeBRep_LineInter self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_HasVInternal(self, *args)


    def NbWPoint(self, *args):
        """
        NbWPoint(TopOpeBRep_LineInter self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_NbWPoint(self, *args)


    def WPoint(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_WPointInter

        """
        res = _TopOpeBRep.TopOpeBRep_LineInter_WPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransitionOnS1(self, *args):
        """
        TransitionOnS1(TopOpeBRep_LineInter self) -> IntSurf_TypeTrans

        :rtype: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_TransitionOnS1(self, *args)


    def TransitionOnS2(self, *args):
        """
        TransitionOnS2(TopOpeBRep_LineInter self) -> IntSurf_TypeTrans

        :rtype: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_TransitionOnS2(self, *args)


    def SituationS1(self, *args):
        """
        SituationS1(TopOpeBRep_LineInter self) -> IntSurf_Situation

        :rtype: OCC.wrapper.IntSurf.IntSurf_Situation

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_SituationS1(self, *args)


    def SituationS2(self, *args):
        """
        SituationS2(TopOpeBRep_LineInter self) -> IntSurf_Situation

        :rtype: OCC.wrapper.IntSurf.IntSurf_Situation

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_SituationS2(self, *args)


    def Curve(self, *args):
        """
        Curve(TopOpeBRep_LineInter self) -> Handle_Geom_Curve
        Curve(TopOpeBRep_LineInter self, Standard_Real const parmin, Standard_Real const parmax) -> Handle_Geom_Curve

        :type parmin: float
        :type parmax: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_Curve(self, *args)


    def Arc(self, *args):
        """
        returns the edge of a RESTRICTION line (or a null edge).

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRep.TopOpeBRep_LineInter_Arc(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ArcIsEdge(self, *args):
        """
        ArcIsEdge(TopOpeBRep_LineInter self, Standard_Integer const I) -> Standard_Boolean

        returns true if Arc() edge (of a RESTRICTION line) is
        an edge of the original face <Index> (1 or 2).

        :type I: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_ArcIsEdge(self, *args)


    def LineW(self, *args):
        """
        :rtype: OCC.wrapper.IntPatch.Handle_IntPatch_WLine

        """
        res = _TopOpeBRep.TopOpeBRep_LineInter_LineW(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LineG(self, *args):
        """
        :rtype: OCC.wrapper.IntPatch.Handle_IntPatch_GLine

        """
        res = _TopOpeBRep.TopOpeBRep_LineInter_LineG(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LineR(self, *args):
        """
        :rtype: OCC.wrapper.IntPatch.Handle_IntPatch_RLine

        """
        res = _TopOpeBRep.TopOpeBRep_LineInter_LineR(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasFirstPoint(self, *args):
        """
        HasFirstPoint(TopOpeBRep_LineInter self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args):
        """
        HasLastPoint(TopOpeBRep_LineInter self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_HasLastPoint(self, *args)


    def ComputeFaceFaceTransition(self, *args):
        """ComputeFaceFaceTransition(TopOpeBRep_LineInter self)"""
        return _TopOpeBRep.TopOpeBRep_LineInter_ComputeFaceFaceTransition(self, *args)


    def FaceFaceTransition(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        res = _TopOpeBRep.TopOpeBRep_LineInter_FaceFaceTransition(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Index(self, *args):
        """
        Index(TopOpeBRep_LineInter self, Standard_Integer const I)
        Index(TopOpeBRep_LineInter self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_Index(self, *args)


    def DumpType(self, *args):
        """DumpType(TopOpeBRep_LineInter self)"""
        return _TopOpeBRep.TopOpeBRep_LineInter_DumpType(self, *args)


    def DumpVPoint(self, *args):
        """
        DumpVPoint(TopOpeBRep_LineInter self, Standard_Integer const I, TCollection_AsciiString s1, TCollection_AsciiString s2)

        :type I: int
        :type s1: OCC.wrapper.TCollection.TCollection_AsciiString
        :type s2: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_DumpVPoint(self, *args)


    def DumpBipoint(self, *args):
        """
        DumpBipoint(TopOpeBRep_LineInter self, TopOpeBRep_Bipoint B, TCollection_AsciiString s1, TCollection_AsciiString s2)

        :type B: OCC.wrapper.TopOpeBRep.TopOpeBRep_Bipoint
        :type s1: OCC.wrapper.TCollection.TCollection_AsciiString
        :type s2: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_DumpBipoint(self, *args)


    def SetTraceIndex(self, *args):
        """
        SetTraceIndex(TopOpeBRep_LineInter self, Standard_Integer const exF1, Standard_Integer const exF2)

        :type exF1: int
        :type exF2: int

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_SetTraceIndex(self, *args)


    def GetTraceIndex(self, *args):
        """
        GetTraceIndex(TopOpeBRep_LineInter self)

        :type exF1: int
        :type exF2: int

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_GetTraceIndex(self, *args)


    def DumpLineTransitions(self, *args):
        """
        DumpLineTransitions(TopOpeBRep_LineInter self, Standard_OStream & OS) -> Standard_OStream &

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TopOpeBRep.TopOpeBRep_LineInter_DumpLineTransitions(self, *args)

    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_LineInter
TopOpeBRep_LineInter_swigregister = _TopOpeBRep.TopOpeBRep_LineInter_swigregister
TopOpeBRep_LineInter_swigregister(TopOpeBRep_LineInter)

class TopOpeBRep_FacesIntersector(object):
    """Describes the intersection of two faces."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRep_FacesIntersector self) -> TopOpeBRep_FacesIntersector

        Describes the intersection of two faces.
        """
        this = _TopOpeBRep.new_TopOpeBRep_FacesIntersector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(TopOpeBRep_FacesIntersector self, TopoDS_Shape S1, TopoDS_Shape S2)
        Perform(TopOpeBRep_FacesIntersector self, TopoDS_Shape S1, TopoDS_Shape S2, Bnd_Box B1, Bnd_Box B2)

        Computes the intersection of faces S1 and S2.

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type B1: OCC.wrapper.Bnd.Bnd_Box
        :type B2: OCC.wrapper.Bnd.Bnd_Box

        """
        return _TopOpeBRep.TopOpeBRep_FacesIntersector_Perform(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(TopOpeBRep_FacesIntersector self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_FacesIntersector_IsEmpty(self, *args)


    def IsDone(self, *args):
        """
        IsDone(TopOpeBRep_FacesIntersector self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_FacesIntersector_IsDone(self, *args)


    def SameDomain(self, *args):
        """
        SameDomain(TopOpeBRep_FacesIntersector self) -> Standard_Boolean

        Returns True if Perform() arguments are two faces with the
        same surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_FacesIntersector_SameDomain(self, *args)


    def Face(self, *args):
        """
        returns first or second intersected face.

        :type Index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRep.TopOpeBRep_FacesIntersector_Face(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfacesSameOriented(self, *args):
        """
        SurfacesSameOriented(TopOpeBRep_FacesIntersector self) -> Standard_Boolean

        Returns True if Perform() arguments are two faces
        SameDomain() and normals on both side.
        Raise if SameDomain is False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_FacesIntersector_SurfacesSameOriented(self, *args)


    def IsRestriction(self, *args):
        """
        IsRestriction(TopOpeBRep_FacesIntersector self, TopoDS_Shape E) -> Standard_Boolean

        returns true if edge <E> is found as same as the edge
        associated with a RESTRICTION line.

        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_FacesIntersector_IsRestriction(self, *args)


    def Restrictions(self, *args):
        """
        returns the map of edges found as TopeBRepBRep_RESTRICTION

        :rtype: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape

        """
        res = _TopOpeBRep.TopOpeBRep_FacesIntersector_Restrictions(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PrepareLines(self, *args):
        """PrepareLines(TopOpeBRep_FacesIntersector self)"""
        return _TopOpeBRep.TopOpeBRep_FacesIntersector_PrepareLines(self, *args)


    def Lines(self, *args):
        """
        Lines(TopOpeBRep_FacesIntersector self) -> Handle_TopOpeBRep_HArray1OfLineInter

        :rtype: OCC.wrapper.TopOpeBRep.Handle_TopOpeBRep_HArray1OfLineInter

        """
        return _TopOpeBRep.TopOpeBRep_FacesIntersector_Lines(self, *args)


    def NbLines(self, *args):
        """
        NbLines(TopOpeBRep_FacesIntersector self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.TopOpeBRep_FacesIntersector_NbLines(self, *args)


    def InitLine(self, *args):
        """InitLine(TopOpeBRep_FacesIntersector self)"""
        return _TopOpeBRep.TopOpeBRep_FacesIntersector_InitLine(self, *args)


    def MoreLine(self, *args):
        """
        MoreLine(TopOpeBRep_FacesIntersector self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_FacesIntersector_MoreLine(self, *args)


    def NextLine(self, *args):
        """NextLine(TopOpeBRep_FacesIntersector self)"""
        return _TopOpeBRep.TopOpeBRep_FacesIntersector_NextLine(self, *args)


    def CurrentLine(self, *args):
        """
        CurrentLine(TopOpeBRep_FacesIntersector self) -> TopOpeBRep_LineInter

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter

        """
        return _TopOpeBRep.TopOpeBRep_FacesIntersector_CurrentLine(self, *args)


    def CurrentLineIndex(self, *args):
        """
        CurrentLineIndex(TopOpeBRep_FacesIntersector self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.TopOpeBRep_FacesIntersector_CurrentLineIndex(self, *args)


    def ChangeLine(self, *args):
        """
        ChangeLine(TopOpeBRep_FacesIntersector self, Standard_Integer const IL) -> TopOpeBRep_LineInter

        :type IL: int
        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter

        """
        return _TopOpeBRep.TopOpeBRep_FacesIntersector_ChangeLine(self, *args)


    def ForceTolerances(self, *args):
        """
        ForceTolerances(TopOpeBRep_FacesIntersector self, Standard_Real const tolarc, Standard_Real const toltang)

        Force the tolerance values used by the next Perform(S1,S2) call.

        :type tolarc: float
        :type toltang: float

        """
        return _TopOpeBRep.TopOpeBRep_FacesIntersector_ForceTolerances(self, *args)


    def GetTolerances(self, *args):
        """
        GetTolerances(TopOpeBRep_FacesIntersector self)

        Return the tolerance values used in the last Perform() call
        If ForceTolerances() has been called, return the given values.
        If not, return values extracted from shapes.

        :type tolarc: float
        :type toltang: float

        """
        return _TopOpeBRep.TopOpeBRep_FacesIntersector_GetTolerances(self, *args)

    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_FacesIntersector
TopOpeBRep_FacesIntersector_swigregister = _TopOpeBRep.TopOpeBRep_FacesIntersector_swigregister
TopOpeBRep_FacesIntersector_swigregister(TopOpeBRep_FacesIntersector)

class TopOpeBRep_FacesFiller(object):
    """
    Fills a DataStructure from TopOpeBRepDS with the result
    of Face/Face instersection described by FacesIntersector from TopOpeBRep.
    if the faces have same Domain, record it in the DS.
    else record lines and  points and attach list of interferences
    to the faces, the lines and the edges.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRep_FacesFiller self) -> TopOpeBRep_FacesFiller

        Fills a DataStructure from TopOpeBRepDS with the result
        of Face/Face instersection described by FacesIntersector from TopOpeBRep.
        if the faces have same Domain, record it in the DS.
        else record lines and  points and attach list of interferences
        to the faces, the lines and the edges.
        """
        this = _TopOpeBRep.new_TopOpeBRep_FacesFiller(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Insert(self, *args):
        """
        Insert(TopOpeBRep_FacesFiller self, TopoDS_Shape F1, TopoDS_Shape F2, TopOpeBRep_FacesIntersector FACINT, Handle_TopOpeBRepDS_HDataStructure HDS)

        Stores in <DS> the intersections of <S1> and <S2>.

        :type F1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type F2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type FACINT: OCC.wrapper.TopOpeBRep.TopOpeBRep_FacesIntersector
        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_Insert(self, *args)


    def ProcessSectionEdges(self, *args):
        """ProcessSectionEdges(TopOpeBRep_FacesFiller self)"""
        return _TopOpeBRep.TopOpeBRep_FacesFiller_ProcessSectionEdges(self, *args)


    def ChangePointClassifier(self, *args):
        """
        ChangePointClassifier(TopOpeBRep_FacesFiller self) -> TopOpeBRep_PointClassifier

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_PointClassifier

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_ChangePointClassifier(self, *args)


    def PShapeClassifier(self, *args):
        """
        PShapeClassifier(TopOpeBRep_FacesFiller self) -> TopOpeBRepTool_ShapeClassifier

        return field myPShapeClassifier.

        :rtype: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_PShapeClassifier

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_PShapeClassifier(self, *args)


    def SetPShapeClassifier(self, *args):
        """
        SetPShapeClassifier(TopOpeBRep_FacesFiller self, TopOpeBRepTool_ShapeClassifier PSC)

        set field myPShapeClassifier.

        :type PSC: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_PShapeClassifier

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_SetPShapeClassifier(self, *args)


    def LoadLine(self, *args):
        """
        LoadLine(TopOpeBRep_FacesFiller self, TopOpeBRep_LineInter L)

        :type L: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_LoadLine(self, *args)


    def CheckLine(self, *args):
        """
        CheckLine(TopOpeBRep_FacesFiller self, TopOpeBRep_LineInter L) -> Standard_Boolean

        :type L: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_CheckLine(self, *args)


    def VP_PositionOnL(self, *args):
        """
        VP_PositionOnL(TopOpeBRep_FacesFiller self, TopOpeBRep_LineInter L)

        compute position of VPoints of non-restriction line L.

        :type L: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_VP_PositionOnL(self, *args)


    def VP_PositionOnR(self, *args):
        """
        VP_PositionOnR(TopOpeBRep_FacesFiller self, TopOpeBRep_LineInter L)

        compute position of VPoints of restriction line L.

        :type L: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_VP_PositionOnR(self, *args)


    def VP_Position(self, *args):
        """
        VP_Position(TopOpeBRep_FacesFiller self, TopOpeBRep_FacesIntersector FACINT)
        VP_Position(TopOpeBRep_FacesFiller self, TopOpeBRep_LineInter L)
        VP_Position(TopOpeBRep_FacesFiller self, TopOpeBRep_VPointInter VP, TopOpeBRep_VPointInterClassifier VPC)

        compute position of VP with current faces,
        according to VP.ShapeIndex() .

        :type VP: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter
        :type VPC: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInterClassifier

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_VP_Position(self, *args)


    def ProcessLine(self, *args):
        """
        ProcessLine(TopOpeBRep_FacesFiller self)

        Process current intersection line (set by LoadLine)


        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_ProcessLine(self, *args)


    def ResetDSC(self, *args):
        """ResetDSC(TopOpeBRep_FacesFiller self)"""
        return _TopOpeBRep.TopOpeBRep_FacesFiller_ResetDSC(self, *args)


    def ProcessRLine(self, *args):
        """
        ProcessRLine(TopOpeBRep_FacesFiller self)

        Process current restriction line, adding restriction edge
        and computing face/edge interference.


        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_ProcessRLine(self, *args)


    def FillLineVPonR(self, *args):
        """
        FillLineVPonR(TopOpeBRep_FacesFiller self)

        VP processing for restriction  line  and line sharing
        same domain with  section edges :
        - if restriction :
        Adds restriction edges as  section edges and compute
        face/edge  interference.
        - if  same domain :
        If line share same domain  with section edges, compute
        parts of line IN/IN the two faces, and compute curve/point
        interference for VP boundaries.


        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_FillLineVPonR(self, *args)


    def FillLine(self, *args):
        """FillLine(TopOpeBRep_FacesFiller self)"""
        return _TopOpeBRep.TopOpeBRep_FacesFiller_FillLine(self, *args)


    def AddShapesLine(self, *args):
        """
        AddShapesLine(TopOpeBRep_FacesFiller self)

        compute 3d curve, pcurves and face/curve interferences
        for current NDSC. Add them to the DS.


        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_AddShapesLine(self, *args)


    def GetESL(self, *args):
        """
        GetESL(TopOpeBRep_FacesFiller self, NCollection_List_TopoDS_Shape LES)

        Get map <mapES > of restriction edges having parts IN one
        of the 2 faces.

        :type LES: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_GetESL(self, *args)


    def ProcessVPR(self, *args):
        """
        ProcessVPR(TopOpeBRep_FacesFiller self, TopOpeBRep_FacesFiller FF, TopOpeBRep_VPointInter VP)

        calling the followings ProcessVPIonR and ProcessVPonR.

        :type FF: OCC.wrapper.TopOpeBRep.TopOpeBRep_FacesFiller
        :type VP: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_ProcessVPR(self, *args)


    def ProcessVPIonR(self, *args):
        """
        ProcessVPIonR(TopOpeBRep_FacesFiller self, TopOpeBRep_VPointInterIterator VPI, TopOpeBRepDS_Transition trans1, TopoDS_Shape F1, Standard_Integer const ShapeIndex)

        processing ProcessVPonR for VPI.

        :type VPI: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInterIterator
        :type trans1: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition
        :type F1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type ShapeIndex: int

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_ProcessVPIonR(self, *args)


    def ProcessVPonR(self, *args):
        """
        ProcessVPonR(TopOpeBRep_FacesFiller self, TopOpeBRep_VPointInter VP, TopOpeBRepDS_Transition trans1, TopoDS_Shape F1, Standard_Integer const ShapeIndex)

        adds <VP>'s   geometric   point (if not   stored)  and
        computes (curve or edge)/(point or vertex) interference.

        :type VP: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter
        :type trans1: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition
        :type F1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type ShapeIndex: int

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_ProcessVPonR(self, *args)


    def ProcessVPonclosingR(self, *args):
        """
        ProcessVPonclosingR(TopOpeBRep_FacesFiller self, TopOpeBRep_VPointInter VP, TopoDS_Shape F1, Standard_Integer const ShapeIndex, TopOpeBRepDS_Transition transEdge, TopOpeBRepDS_Kind const PVKind, Standard_Integer const PVIndex, Standard_Boolean const EPIfound, Handle_TopOpeBRepDS_Interference IEPI)

        VP processing on closing arc.

        :type VP: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter
        :type F1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type ShapeIndex: int
        :type transEdge: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition
        :type PVKind: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type PVIndex: int
        :type EPIfound: bool
        :type IEPI: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_ProcessVPonclosingR(self, *args)


    def ProcessVPondgE(self, *args):
        """
        ProcessVPondgE(TopOpeBRep_FacesFiller self, TopOpeBRep_VPointInter VP, Standard_Integer const ShapeIndex, Handle_TopOpeBRepDS_Interference IEPI, Handle_TopOpeBRepDS_Interference ICPI) -> Standard_Boolean

        VP processing on degenerated arc.

        :type VP: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter
        :type ShapeIndex: int
        :type PVKind: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type PVIndex: int
        :type EPIfound: bool
        :type IEPI: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type CPIfound: bool
        :type ICPI: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_ProcessVPondgE(self, *args)


    def ProcessVPInotonR(self, *args):
        """
        ProcessVPInotonR(TopOpeBRep_FacesFiller self, TopOpeBRep_VPointInterIterator VPI)

        processing ProcessVPnotonR for VPI.

        :type VPI: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInterIterator

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_ProcessVPInotonR(self, *args)


    def ProcessVPnotonR(self, *args):
        """
        ProcessVPnotonR(TopOpeBRep_FacesFiller self, TopOpeBRep_VPointInter VP)

        adds <VP>'s  geometrical point to the DS (if not stored)
        and computes curve point interference.

        :type VP: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_ProcessVPnotonR(self, *args)


    def GetGeometry(self, *args):
        """
        GetGeometry(TopOpeBRep_FacesFiller self, TopOpeBRepDS_ListIteratorOfListOfInterference & IT, TopOpeBRep_VPointInter VP) -> Standard_Boolean

        Get the geometry of a DS point <DSP>.
        Search for it with ScanInterfList (previous method).
        if found, set <G> to the geometry of the interference found.
        else, add the point <DSP> in the <DS> and set <G> to the
        value of the new geometry such created.
        returns the value of ScanInterfList().

        :type IT: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListIteratorOfListOfInterference
        :type VP: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter
        :type G: int
        :type K: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_GetGeometry(self, *args)


    def MakeGeometry(self, *args):
        """
        MakeGeometry(TopOpeBRep_FacesFiller self, TopOpeBRep_VPointInter VP, Standard_Integer const ShapeIndex) -> Standard_Integer

        :type VP: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter
        :type ShapeIndex: int
        :type K: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_MakeGeometry(self, *args)


    def StoreCurveInterference(self, *args):
        """
        StoreCurveInterference(TopOpeBRep_FacesFiller self, Handle_TopOpeBRepDS_Interference I)

        Add interference <I> to list myDSCIL.
        on a given line, at first call, add a new DS curve.

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_StoreCurveInterference(self, *args)


    def GetFFGeometry(self, *args):
        """
        GetFFGeometry(TopOpeBRep_FacesFiller self, TopOpeBRepDS_Point DSP) -> Standard_Boolean
        GetFFGeometry(TopOpeBRep_FacesFiller self, TopOpeBRep_VPointInter VP) -> Standard_Boolean

        search for G = geometry of Point which is identical to <VP>
        among the DS Points created in the CURRENT face/face
        intersection ( current Insert() call).

        :type VP: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter
        :type K: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type G: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_GetFFGeometry(self, *args)


    def ChangeFacesIntersector(self, *args):
        """
        ChangeFacesIntersector(TopOpeBRep_FacesFiller self) -> TopOpeBRep_FacesIntersector

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_FacesIntersector

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_ChangeFacesIntersector(self, *args)


    def HDataStructure(self, *args):
        """
        HDataStructure(TopOpeBRep_FacesFiller self) -> Handle_TopOpeBRepDS_HDataStructure

        :rtype: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_HDataStructure(self, *args)


    def ChangeDataStructure(self, *args):
        """
        ChangeDataStructure(TopOpeBRep_FacesFiller self) -> TopOpeBRepDS_DataStructure

        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_DataStructure

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_ChangeDataStructure(self, *args)


    def Face(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _TopOpeBRep.TopOpeBRep_FacesFiller_Face(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FaceFaceTransition(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        res = _TopOpeBRep.TopOpeBRep_FacesFiller_FaceFaceTransition(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PFacesIntersectorDummy(self, *args):
        """
        PFacesIntersectorDummy(TopOpeBRep_FacesFiller self) -> TopOpeBRep_FacesIntersector

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_PFacesIntersector

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_PFacesIntersectorDummy(self, *args)


    def PDataStructureDummy(self, *args):
        """
        PDataStructureDummy(TopOpeBRep_FacesFiller self) -> TopOpeBRepDS_DataStructure

        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_PDataStructure

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_PDataStructureDummy(self, *args)


    def PLineInterDummy(self, *args):
        """
        PLineInterDummy(TopOpeBRep_FacesFiller self) -> TopOpeBRep_LineInter

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_PLineInter

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_PLineInterDummy(self, *args)


    def SetTraceIndex(self, *args):
        """
        SetTraceIndex(TopOpeBRep_FacesFiller self, Standard_Integer const exF1, Standard_Integer const exF2)

        :type exF1: int
        :type exF2: int

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_SetTraceIndex(self, *args)


    def GetTraceIndex(self, *args):
        """
        GetTraceIndex(TopOpeBRep_FacesFiller self)

        :type exF1: int
        :type exF2: int

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_GetTraceIndex(self, *args)


    def Lminmax(*args):
        """
        Lminmax(TopOpeBRep_LineInter L)

        Computes <pmin> and <pmax> the upper and lower bounds of <L>
        enclosing all vpoints.

        :type L: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter
        :type pmin: float
        :type pmax: float

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_Lminmax(*args)

    Lminmax = staticmethod(Lminmax)

    def LSameDomainERL(*args):
        """
        LSameDomainERL(TopOpeBRep_LineInter L, NCollection_List_TopoDS_Shape ERL) -> Standard_Boolean

        Returns <True> if <L> shares a same geometric domain with
        at least one of the section edges of <ERL>.

        :type L: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter
        :type ERL: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_LSameDomainERL(*args)

    LSameDomainERL = staticmethod(LSameDomainERL)

    def IsVPtransLok(*args):
        """
        IsVPtransLok(TopOpeBRep_LineInter L, Standard_Integer const iVP, Standard_Integer const SI12, TopOpeBRepDS_Transition T) -> Standard_Boolean

        Computes the transition <T> of the VPoint <iVP> on the edge
        of <SI12>. Returns <False> if the status is unknown.

        :type L: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter
        :type iVP: int
        :type SI12: int
        :type T: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_IsVPtransLok(*args)

    IsVPtransLok = staticmethod(IsVPtransLok)

    def TransvpOK(*args):
        """
        TransvpOK(TopOpeBRep_LineInter L, Standard_Integer const iVP, Standard_Integer const SI, Standard_Boolean const isINOUT) -> Standard_Boolean

        Computes   transition   on line for  VP<iVP>   on edge
        restriction of <SI>.  If <isINOUT>  :  returns <true> if
        transition computed is IN/OUT else : returns <true> if
        transition computed is OUT/IN.

        :type L: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter
        :type iVP: int
        :type SI: int
        :type isINOUT: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_TransvpOK(*args)

    TransvpOK = staticmethod(TransvpOK)

    def VPParamOnER(*args):
        """
        VPParamOnER(TopOpeBRep_VPointInter vp, TopOpeBRep_LineInter Lrest) -> Standard_Real

        Returns parameter u of vp on the restriction edge.

        :type vp: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter
        :type Lrest: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_VPParamOnER(*args)

    VPParamOnER = staticmethod(VPParamOnER)

    def EqualpPonR(*args):
        """
        EqualpPonR(TopOpeBRep_LineInter Lrest, TopOpeBRep_VPointInter VP1, TopOpeBRep_VPointInter VP2) -> Standard_Boolean

        :type Lrest: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter
        :type VP1: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter
        :type VP2: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_FacesFiller_EqualpPonR(*args)

    EqualpPonR = staticmethod(EqualpPonR)
    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_FacesFiller
TopOpeBRep_FacesFiller_swigregister = _TopOpeBRep.TopOpeBRep_FacesFiller_swigregister
TopOpeBRep_FacesFiller_swigregister(TopOpeBRep_FacesFiller)

def TopOpeBRep_FacesFiller_Lminmax(*args):
    """
    TopOpeBRep_FacesFiller_Lminmax(TopOpeBRep_LineInter L)

    Computes <pmin> and <pmax> the upper and lower bounds of <L>
    enclosing all vpoints.

    :type L: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter
    :type pmin: float
    :type pmax: float

    """
    return _TopOpeBRep.TopOpeBRep_FacesFiller_Lminmax(*args)

def TopOpeBRep_FacesFiller_LSameDomainERL(*args):
    """
    TopOpeBRep_FacesFiller_LSameDomainERL(TopOpeBRep_LineInter L, NCollection_List_TopoDS_Shape ERL) -> Standard_Boolean

    Returns <True> if <L> shares a same geometric domain with
    at least one of the section edges of <ERL>.

    :type L: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter
    :type ERL: OCC.wrapper.TopTools.TopTools_ListOfShape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRep.TopOpeBRep_FacesFiller_LSameDomainERL(*args)

def TopOpeBRep_FacesFiller_IsVPtransLok(*args):
    """
    TopOpeBRep_FacesFiller_IsVPtransLok(TopOpeBRep_LineInter L, Standard_Integer const iVP, Standard_Integer const SI12, TopOpeBRepDS_Transition T) -> Standard_Boolean

    Computes the transition <T> of the VPoint <iVP> on the edge
    of <SI12>. Returns <False> if the status is unknown.

    :type L: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter
    :type iVP: int
    :type SI12: int
    :type T: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRep.TopOpeBRep_FacesFiller_IsVPtransLok(*args)

def TopOpeBRep_FacesFiller_TransvpOK(*args):
    """
    TopOpeBRep_FacesFiller_TransvpOK(TopOpeBRep_LineInter L, Standard_Integer const iVP, Standard_Integer const SI, Standard_Boolean const isINOUT) -> Standard_Boolean

    Computes   transition   on line for  VP<iVP>   on edge
    restriction of <SI>.  If <isINOUT>  :  returns <true> if
    transition computed is IN/OUT else : returns <true> if
    transition computed is OUT/IN.

    :type L: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter
    :type iVP: int
    :type SI: int
    :type isINOUT: bool
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRep.TopOpeBRep_FacesFiller_TransvpOK(*args)

def TopOpeBRep_FacesFiller_VPParamOnER(*args):
    """
    TopOpeBRep_FacesFiller_VPParamOnER(TopOpeBRep_VPointInter vp, TopOpeBRep_LineInter Lrest) -> Standard_Real

    Returns parameter u of vp on the restriction edge.

    :type vp: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter
    :type Lrest: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _TopOpeBRep.TopOpeBRep_FacesFiller_VPParamOnER(*args)

def TopOpeBRep_FacesFiller_EqualpPonR(*args):
    """
    TopOpeBRep_FacesFiller_EqualpPonR(TopOpeBRep_LineInter Lrest, TopOpeBRep_VPointInter VP1, TopOpeBRep_VPointInter VP2) -> Standard_Boolean

    :type Lrest: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter
    :type VP1: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter
    :type VP2: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRep.TopOpeBRep_FacesFiller_EqualpPonR(*args)

class TopOpeBRep_FFTransitionTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ProcessLineTransition(*args):
        """
        ProcessLineTransition(TopOpeBRep_VPointInter P, Standard_Integer const Index, TopAbs_Orientation const EdgeOrientation) -> TopOpeBRepDS_Transition
        ProcessLineTransition(TopOpeBRep_VPointInter P, TopOpeBRep_LineInter L) -> TopOpeBRepDS_Transition

        :type P: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter
        :type L: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        return _TopOpeBRep.TopOpeBRep_FFTransitionTool_ProcessLineTransition(*args)

    ProcessLineTransition = staticmethod(ProcessLineTransition)

    def ProcessEdgeTransition(*args):
        """
        ProcessEdgeTransition(TopOpeBRep_VPointInter P, Standard_Integer const Index, TopAbs_Orientation const LineOrientation) -> TopOpeBRepDS_Transition

        :type P: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter
        :type Index: int
        :type LineOrientation: OCC.wrapper.TopAbs.TopAbs_Orientation
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        return _TopOpeBRep.TopOpeBRep_FFTransitionTool_ProcessEdgeTransition(*args)

    ProcessEdgeTransition = staticmethod(ProcessEdgeTransition)

    def ProcessFaceTransition(*args):
        """
        ProcessFaceTransition(TopOpeBRep_LineInter L, Standard_Integer const Index, TopAbs_Orientation const FaceOrientation) -> TopOpeBRepDS_Transition

        :type L: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter
        :type Index: int
        :type FaceOrientation: OCC.wrapper.TopAbs.TopAbs_Orientation
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        return _TopOpeBRep.TopOpeBRep_FFTransitionTool_ProcessFaceTransition(*args)

    ProcessFaceTransition = staticmethod(ProcessFaceTransition)

    def ProcessEdgeONTransition(*args):
        """
        ProcessEdgeONTransition(TopOpeBRep_VPointInter VP, Standard_Integer const Index, TopoDS_Shape R, TopoDS_Shape E, TopoDS_Shape F) -> TopOpeBRepDS_Transition

        compute transition on "IntPatch_Restriction line" edge <R>
        when crossing edge <E> of face <F> at point <VP>.
        VP is given on edge <E> of face <F> of index <Index> (1 or 2).
        <VP> has been classified by FacesFiller as TopAbs_ON an edge <R>
        of the other face than <F> of current (face/face) intersection.
        Transition depends on the orientation of E in F.
        This method should be provided by IntPatch_Line (NYI)

        :type VP: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter
        :type Index: int
        :type R: OCC.wrapper.TopoDS.TopoDS_Shape
        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :type F: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        return _TopOpeBRep.TopOpeBRep_FFTransitionTool_ProcessEdgeONTransition(*args)

    ProcessEdgeONTransition = staticmethod(ProcessEdgeONTransition)

    def __init__(self):
        this = _TopOpeBRep.new_TopOpeBRep_FFTransitionTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_FFTransitionTool
TopOpeBRep_FFTransitionTool_swigregister = _TopOpeBRep.TopOpeBRep_FFTransitionTool_swigregister
TopOpeBRep_FFTransitionTool_swigregister(TopOpeBRep_FFTransitionTool)

def TopOpeBRep_FFTransitionTool_ProcessLineTransition(*args):
    """
    ProcessLineTransition(TopOpeBRep_VPointInter P, Standard_Integer const Index, TopAbs_Orientation const EdgeOrientation) -> TopOpeBRepDS_Transition
    TopOpeBRep_FFTransitionTool_ProcessLineTransition(TopOpeBRep_VPointInter P, TopOpeBRep_LineInter L) -> TopOpeBRepDS_Transition

    :type P: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter
    :type L: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter
    :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

    """
    return _TopOpeBRep.TopOpeBRep_FFTransitionTool_ProcessLineTransition(*args)

def TopOpeBRep_FFTransitionTool_ProcessEdgeTransition(*args):
    """
    TopOpeBRep_FFTransitionTool_ProcessEdgeTransition(TopOpeBRep_VPointInter P, Standard_Integer const Index, TopAbs_Orientation const LineOrientation) -> TopOpeBRepDS_Transition

    :type P: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter
    :type Index: int
    :type LineOrientation: OCC.wrapper.TopAbs.TopAbs_Orientation
    :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

    """
    return _TopOpeBRep.TopOpeBRep_FFTransitionTool_ProcessEdgeTransition(*args)

def TopOpeBRep_FFTransitionTool_ProcessFaceTransition(*args):
    """
    TopOpeBRep_FFTransitionTool_ProcessFaceTransition(TopOpeBRep_LineInter L, Standard_Integer const Index, TopAbs_Orientation const FaceOrientation) -> TopOpeBRepDS_Transition

    :type L: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter
    :type Index: int
    :type FaceOrientation: OCC.wrapper.TopAbs.TopAbs_Orientation
    :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

    """
    return _TopOpeBRep.TopOpeBRep_FFTransitionTool_ProcessFaceTransition(*args)

def TopOpeBRep_FFTransitionTool_ProcessEdgeONTransition(*args):
    """
    TopOpeBRep_FFTransitionTool_ProcessEdgeONTransition(TopOpeBRep_VPointInter VP, Standard_Integer const Index, TopoDS_Shape R, TopoDS_Shape E, TopoDS_Shape F) -> TopOpeBRepDS_Transition

    compute transition on "IntPatch_Restriction line" edge <R>
    when crossing edge <E> of face <F> at point <VP>.
    VP is given on edge <E> of face <F> of index <Index> (1 or 2).
    <VP> has been classified by FacesFiller as TopAbs_ON an edge <R>
    of the other face than <F> of current (face/face) intersection.
    Transition depends on the orientation of E in F.
    This method should be provided by IntPatch_Line (NYI)

    :type VP: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter
    :type Index: int
    :type R: OCC.wrapper.TopoDS.TopoDS_Shape
    :type E: OCC.wrapper.TopoDS.TopoDS_Shape
    :type F: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

    """
    return _TopOpeBRep.TopOpeBRep_FFTransitionTool_ProcessEdgeONTransition(*args)

class TopOpeBRep_VPointInterClassifier(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(TopOpeBRep_VPointInterClassifier self) -> TopOpeBRep_VPointInterClassifier"""
        this = _TopOpeBRep.new_TopOpeBRep_VPointInterClassifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def VPointPosition(self, *args):
        """
        VPointPosition(TopOpeBRep_VPointInterClassifier self, TopoDS_Shape F, TopOpeBRep_VPointInter VP, Standard_Integer const ShapeIndex, TopOpeBRep_PointClassifier PC, Standard_Boolean const AssumeINON, Standard_Real const Tol) -> TopAbs_State

        compute position of VPoint <VP> regarding with face <F>.
        <ShapeIndex> (= 1,2) indicates which (u,v) point of <VP> is used.
        when state is ON, set VP.EdgeON() with the edge containing <VP>
        and associated parameter.
        returns state of VP on ShapeIndex.

        :type F: OCC.wrapper.TopoDS.TopoDS_Shape
        :type VP: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter
        :type ShapeIndex: int
        :type PC: OCC.wrapper.TopOpeBRep.TopOpeBRep_PointClassifier
        :type AssumeINON: bool
        :type Tol: float
        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _TopOpeBRep.TopOpeBRep_VPointInterClassifier_VPointPosition(self, *args)


    def Edge(self, *args):
        """
        returns the edge containing the VPoint <VP> used in the
        last VPointPosition() call. Edge is defined if the state previously
        computed is ON, else Edge is a null shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRep.TopOpeBRep_VPointInterClassifier_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def EdgeParameter(self, *args):
        """
        EdgeParameter(TopOpeBRep_VPointInterClassifier self) -> Standard_Real

        returns the parameter of the VPoint <VP> on Edge()

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRep.TopOpeBRep_VPointInterClassifier_EdgeParameter(self, *args)

    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_VPointInterClassifier
TopOpeBRep_VPointInterClassifier_swigregister = _TopOpeBRep.TopOpeBRep_VPointInterClassifier_swigregister
TopOpeBRep_VPointInterClassifier_swigregister(TopOpeBRep_VPointInterClassifier)

class TopOpeBRep_HArray1OfLineInter(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopOpeBRep_HArray1OfLineInter
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopOpeBRep_HArray1OfLineInter(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopOpeBRep_HArray1OfLineInter self, Standard_Integer const theLower, Standard_Integer const theUpper) -> TopOpeBRep_HArray1OfLineInter
        __init__(TopOpeBRep_HArray1OfLineInter self, Standard_Integer const theLower, Standard_Integer const theUpper, TopOpeBRep_LineInter theValue) -> TopOpeBRep_HArray1OfLineInter
        __init__(TopOpeBRep_HArray1OfLineInter self, NCollection_Array1_TopOpeBRep_LineInter theOther) -> TopOpeBRep_HArray1OfLineInter

        :type theOther: OCC.wrapper.TopOpeBRep.TopOpeBRep_Array1OfLineInter

        """
        this = _TopOpeBRep.new_TopOpeBRep_HArray1OfLineInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_Array1OfLineInter

        """
        res = _TopOpeBRep.TopOpeBRep_HArray1OfLineInter_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(TopOpeBRep_HArray1OfLineInter self) -> NCollection_Array1_TopOpeBRep_LineInter

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_Array1OfLineInter

        """
        return _TopOpeBRep.TopOpeBRep_HArray1OfLineInter_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopOpeBRep.TopOpeBRep_HArray1OfLineInter_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopOpeBRep.TopOpeBRep_HArray1OfLineInter_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRep.TopOpeBRep_HArray1OfLineInter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_HArray1OfLineInter
TopOpeBRep_HArray1OfLineInter_swigregister = _TopOpeBRep.TopOpeBRep_HArray1OfLineInter_swigregister
TopOpeBRep_HArray1OfLineInter_swigregister(TopOpeBRep_HArray1OfLineInter)

def TopOpeBRep_HArray1OfLineInter_get_type_name(*args):
    """
    TopOpeBRep_HArray1OfLineInter_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopOpeBRep.TopOpeBRep_HArray1OfLineInter_get_type_name(*args)

def TopOpeBRep_HArray1OfLineInter_get_type_descriptor(*args):
    """
    TopOpeBRep_HArray1OfLineInter_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopOpeBRep.TopOpeBRep_HArray1OfLineInter_get_type_descriptor(*args)

class NCollection_Array1_TopOpeBRep_LineInter(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_TopOpeBRep_LineInter self) -> NCollection_Array1< TopOpeBRep_LineInter >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_LineInter_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_TopOpeBRep_LineInter self) -> NCollection_Array1< TopOpeBRep_LineInter >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_LineInter_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_TopOpeBRep_LineInter self) -> NCollection_Array1< TopOpeBRep_LineInter >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_LineInter_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_TopOpeBRep_LineInter self) -> NCollection_Array1< TopOpeBRep_LineInter >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_LineInter_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _TopOpeBRep.new_NCollection_Array1_TopOpeBRep_LineInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_TopOpeBRep_LineInter self, TopOpeBRep_LineInter theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_LineInter_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_TopOpeBRep_LineInter self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_LineInter_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_TopOpeBRep_LineInter self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_LineInter_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_TopOpeBRep_LineInter self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_LineInter_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_TopOpeBRep_LineInter self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_LineInter_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_TopOpeBRep_LineInter self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_LineInter_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_TopOpeBRep_LineInter self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_LineInter_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_TopOpeBRep_LineInter self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_LineInter_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_TopOpeBRep_LineInter self, NCollection_Array1_TopOpeBRep_LineInter theOther) -> NCollection_Array1_TopOpeBRep_LineInter

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_LineInter_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_TopOpeBRep_LineInter self, NCollection_Array1_TopOpeBRep_LineInter theOther) -> NCollection_Array1_TopOpeBRep_LineInter

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_LineInter_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_TopOpeBRep_LineInter self, NCollection_Array1_TopOpeBRep_LineInter theOther) -> NCollection_Array1_TopOpeBRep_LineInter
        assign(NCollection_Array1_TopOpeBRep_LineInter self, NCollection_Array1_TopOpeBRep_LineInter theOther) -> NCollection_Array1_TopOpeBRep_LineInter

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_LineInter_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _TopOpeBRep.NCollection_Array1_TopOpeBRep_LineInter_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_TopOpeBRep_LineInter self) -> TopOpeBRep_LineInter

        @return first element

        :rtype: TheItemType &

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_LineInter_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _TopOpeBRep.NCollection_Array1_TopOpeBRep_LineInter_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_TopOpeBRep_LineInter self) -> TopOpeBRep_LineInter

        @return last element

        :rtype: TheItemType &

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_LineInter_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopOpeBRep.NCollection_Array1_TopOpeBRep_LineInter_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_TopOpeBRep_LineInter self, Standard_Integer const theIndex) -> TopOpeBRep_LineInter

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_LineInter_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopOpeBRep.NCollection_Array1_TopOpeBRep_LineInter___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopOpeBRep.NCollection_Array1_TopOpeBRep_LineInter_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_TopOpeBRep_LineInter self, Standard_Integer const theIndex, TopOpeBRep_LineInter theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_LineInter_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_TopOpeBRep_LineInter self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _TopOpeBRep.NCollection_Array1_TopOpeBRep_LineInter_Resize(self, *args)

    __swig_destroy__ = _TopOpeBRep.delete_NCollection_Array1_TopOpeBRep_LineInter
NCollection_Array1_TopOpeBRep_LineInter_swigregister = _TopOpeBRep.NCollection_Array1_TopOpeBRep_LineInter_swigregister
NCollection_Array1_TopOpeBRep_LineInter_swigregister(NCollection_Array1_TopOpeBRep_LineInter)


try:
	TopOpeBRep_Array1OfLineInter = NCollection_Array1_TopOpeBRep_LineInter
except NameError:
	pass # does not exist, probably ignored

class Handle_TopOpeBRep_HArray1OfVPointInter(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopOpeBRep_HArray1OfVPointInter self)

        Nullify the handle


        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfVPointInter_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopOpeBRep_HArray1OfVPointInter self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfVPointInter_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopOpeBRep_HArray1OfVPointInter self, TopOpeBRep_HArray1OfVPointInter thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfVPointInter_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopOpeBRep_HArray1OfVPointInter self, Handle_TopOpeBRep_HArray1OfVPointInter theHandle) -> Handle_TopOpeBRep_HArray1OfVPointInter
        assign(Handle_TopOpeBRep_HArray1OfVPointInter self, TopOpeBRep_HArray1OfVPointInter thePtr) -> Handle_TopOpeBRep_HArray1OfVPointInter
        assign(Handle_TopOpeBRep_HArray1OfVPointInter self, Handle_TopOpeBRep_HArray1OfVPointInter theHandle) -> Handle_TopOpeBRep_HArray1OfVPointInter

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfVPointInter_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopOpeBRep_HArray1OfVPointInter self) -> TopOpeBRep_HArray1OfVPointInter

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfVPointInter_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopOpeBRep_HArray1OfVPointInter self) -> TopOpeBRep_HArray1OfVPointInter

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfVPointInter___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopOpeBRep_HArray1OfVPointInter self) -> TopOpeBRep_HArray1OfVPointInter

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfVPointInter___ref__(self, *args)


    def __hash__(self):
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfVPointInter___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfVPointInter___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopOpeBRep.new_Handle_TopOpeBRep_HArray1OfVPointInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopOpeBRep.Handle_TopOpeBRep_HArray1OfVPointInter_DownCast)
    __swig_destroy__ = _TopOpeBRep.delete_Handle_TopOpeBRep_HArray1OfVPointInter

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_Array1OfVPointInter

        """
        res = _TopOpeBRep.Handle_TopOpeBRep_HArray1OfVPointInter_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_TopOpeBRep_HArray1OfVPointInter self) -> NCollection_Array1_TopOpeBRep_VPointInter

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_Array1OfVPointInter

        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfVPointInter_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopOpeBRep_HArray1OfVPointInter self) -> char const *

        :rtype: const char *

        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfVPointInter_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRep.Handle_TopOpeBRep_HArray1OfVPointInter_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRep.Handle_TopOpeBRep_HArray1OfVPointInter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TopOpeBRep_HArray1OfVPointInter self)

        Memory deallocator for transient classes


        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfVPointInter_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopOpeBRep_HArray1OfVPointInter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopOpeBRep_HArray1OfVPointInter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfVPointInter_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopOpeBRep_HArray1OfVPointInter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopOpeBRep_HArray1OfVPointInter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfVPointInter_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopOpeBRep_HArray1OfVPointInter self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfVPointInter_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopOpeBRep_HArray1OfVPointInter self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfVPointInter_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopOpeBRep_HArray1OfVPointInter self)

        Increments the reference counter of this object


        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfVPointInter_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopOpeBRep_HArray1OfVPointInter self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfVPointInter_DecrementRefCounter(self, *args)

Handle_TopOpeBRep_HArray1OfVPointInter_swigregister = _TopOpeBRep.Handle_TopOpeBRep_HArray1OfVPointInter_swigregister
Handle_TopOpeBRep_HArray1OfVPointInter_swigregister(Handle_TopOpeBRep_HArray1OfVPointInter)

def Handle_TopOpeBRep_HArray1OfVPointInter_DownCast(thing):
    return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfVPointInter_DownCast(thing)
Handle_TopOpeBRep_HArray1OfVPointInter_DownCast = _TopOpeBRep.Handle_TopOpeBRep_HArray1OfVPointInter_DownCast

class TopOpeBRep_ShapeScanner(object):
    """
    Find, among the  subshapes SS of a reference shape
    RS, the ones which 3D box interfers with the box of
    a shape S (SS and S are of the same type).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRep_ShapeScanner self) -> TopOpeBRep_ShapeScanner

        Find, among the  subshapes SS of a reference shape
        RS, the ones which 3D box interfers with the box of
        a shape S (SS and S are of the same type).
        """
        this = _TopOpeBRep.new_TopOpeBRep_ShapeScanner(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self, *args):
        """Clear(TopOpeBRep_ShapeScanner self)"""
        return _TopOpeBRep.TopOpeBRep_ShapeScanner_Clear(self, *args)


    def AddBoxesMakeCOB(self, *args):
        """
        AddBoxesMakeCOB(TopOpeBRep_ShapeScanner self, TopoDS_Shape S, TopAbs_ShapeEnum const TS, TopAbs_ShapeEnum const TA=TopAbs_SHAPE)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type TS: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type TA: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopOpeBRep.TopOpeBRep_ShapeScanner_AddBoxesMakeCOB(self, *args)


    def Init(self, *args):
        """
        Init(TopOpeBRep_ShapeScanner self, TopoDS_Shape E)
        Init(TopOpeBRep_ShapeScanner self, TopOpeBRepTool_ShapeExplorer X)

        :type X: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_ShapeExplorer

        """
        return _TopOpeBRep.TopOpeBRep_ShapeScanner_Init(self, *args)


    def More(self, *args):
        """
        More(TopOpeBRep_ShapeScanner self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_ShapeScanner_More(self, *args)


    def Next(self, *args):
        """Next(TopOpeBRep_ShapeScanner self)"""
        return _TopOpeBRep.TopOpeBRep_ShapeScanner_Next(self, *args)


    def Current(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRep.TopOpeBRep_ShapeScanner_Current(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BoxSort(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_BoxSort

        """
        res = _TopOpeBRep.TopOpeBRep_ShapeScanner_BoxSort(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeBoxSort(self, *args):
        """
        ChangeBoxSort(TopOpeBRep_ShapeScanner self) -> TopOpeBRepTool_BoxSort

        :rtype: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_BoxSort

        """
        return _TopOpeBRep.TopOpeBRep_ShapeScanner_ChangeBoxSort(self, *args)


    def Index(self, *args):
        """
        Index(TopOpeBRep_ShapeScanner self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.TopOpeBRep_ShapeScanner_Index(self, *args)


    def DumpCurrent(self, *args):
        """
        DumpCurrent(TopOpeBRep_ShapeScanner self, Standard_OStream & OS) -> Standard_OStream &

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TopOpeBRep.TopOpeBRep_ShapeScanner_DumpCurrent(self, *args)

    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_ShapeScanner
TopOpeBRep_ShapeScanner_swigregister = _TopOpeBRep.TopOpeBRep_ShapeScanner_swigregister
TopOpeBRep_ShapeScanner_swigregister(TopOpeBRep_ShapeScanner)

class TopOpeBRep_DSFiller(object):
    """
    Provides class  methods  to  fill  a datastructure
    with  results  of intersections.

    1.  Use  an    Intersector  to   find    pairs  of
    intersecting GeomShapes

    2. For each  pair fill the DataStructure using the
    appropriate Filler.

    3. Complete the  DataStructure to record shapes to
    rebuild (shells, wires )
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRep_DSFiller self) -> TopOpeBRep_DSFiller

        Provides class  methods  to  fill  a datastructure
        with  results  of intersections.

        1.  Use  an    Intersector  to   find    pairs  of
        intersecting GeomShapes

        2. For each  pair fill the DataStructure using the
        appropriate Filler.

        3. Complete the  DataStructure to record shapes to
        rebuild (shells, wires )
        """
        this = _TopOpeBRep.new_TopOpeBRep_DSFiller(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def PShapeClassifier(self, *args):
        """
        PShapeClassifier(TopOpeBRep_DSFiller self) -> TopOpeBRepTool_ShapeClassifier

        return field myPShapeClassifier.
        set field myPShapeClassifier.

        :rtype: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_PShapeClassifier

        """
        return _TopOpeBRep.TopOpeBRep_DSFiller_PShapeClassifier(self, *args)


    def Insert(self, *args):
        """
        Insert(TopOpeBRep_DSFiller self, TopoDS_Shape S1, TopoDS_Shape S2, Handle_TopOpeBRepDS_HDataStructure HDS, Standard_Boolean const orientFORWARD)

        Stores in <DS> the intersections of <S1> and <S2>.
        if orientFORWARD = True
        S FORWARD,REVERSED   --> FORWARD
        S EXTERNAL,INTERNAL --> EXTERNAL,INTERNAL

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure
        :type orientFORWARD: bool

        """
        return _TopOpeBRep.TopOpeBRep_DSFiller_Insert(self, *args)


    def InsertIntersection(self, *args):
        """
        InsertIntersection(TopOpeBRep_DSFiller self, TopoDS_Shape S1, TopoDS_Shape S2, Handle_TopOpeBRepDS_HDataStructure HDS, Standard_Boolean const orientFORWARD)

        Stores in <DS> the intersections of <S1> and <S2>.
        if orientFORWARD = True
        S FORWAR,REVERSED   --> FORWARD
        S EXTERNAL,INTERNAL --> EXTERNAL,INTERNAL

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure
        :type orientFORWARD: bool

        """
        return _TopOpeBRep.TopOpeBRep_DSFiller_InsertIntersection(self, *args)


    def Complete(self, *args):
        """
        Complete(TopOpeBRep_DSFiller self, Handle_TopOpeBRepDS_HDataStructure HDS)

        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        return _TopOpeBRep.TopOpeBRep_DSFiller_Complete(self, *args)


    def Insert2d(self, *args):
        """
        Insert2d(TopOpeBRep_DSFiller self, TopoDS_Shape S1, TopoDS_Shape S2, Handle_TopOpeBRepDS_HDataStructure HDS)

        Stores in <DS> the intersections of <S1> and <S2>.
        S1 et S2 contain only SameDomain Face

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        return _TopOpeBRep.TopOpeBRep_DSFiller_Insert2d(self, *args)


    def InsertIntersection2d(self, *args):
        """
        InsertIntersection2d(TopOpeBRep_DSFiller self, TopoDS_Shape S1, TopoDS_Shape S2, Handle_TopOpeBRepDS_HDataStructure HDS)

        S1, S2 set of tangent face
        lance les intersections 2d pour coder correctement
        les faces SameDomain.

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        return _TopOpeBRep.TopOpeBRep_DSFiller_InsertIntersection2d(self, *args)


    def IsMadeOf1d(self, *args):
        """
        IsMadeOf1d(TopOpeBRep_DSFiller self, TopoDS_Shape S) -> Standard_Boolean

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_DSFiller_IsMadeOf1d(self, *args)


    def IsContext1d(self, *args):
        """
        IsContext1d(TopOpeBRep_DSFiller self, TopoDS_Shape S) -> Standard_Boolean

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_DSFiller_IsContext1d(self, *args)


    def Insert1d(self, *args):
        """
        Insert1d(TopOpeBRep_DSFiller self, TopoDS_Shape S1, TopoDS_Shape S2, TopoDS_Face F1, TopoDS_Face F2, Handle_TopOpeBRepDS_HDataStructure HDS, Standard_Boolean const orientFORWARD)

        Stores in <DS> the intersections of <S1> and <S2>.
        S1 and S2 are edges or wires.
        S1 edges have a 2d representation in face F1
        S2 edges have a 2d representation in face F2
        F1 is the face which surface is taken as reference
        for 2d description of S1 and S2 edges.
        if orientFORWARD = True
        S FORWARD,REVERSED  --> FORWARD
        S EXTERNAL,INTERNAL --> EXTERNAL,INTERNAL

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure
        :type orientFORWARD: bool

        """
        return _TopOpeBRep.TopOpeBRep_DSFiller_Insert1d(self, *args)


    def ChangeShapeIntersector(self, *args):
        """
        ChangeShapeIntersector(TopOpeBRep_DSFiller self) -> TopOpeBRep_ShapeIntersector

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_ShapeIntersector

        """
        return _TopOpeBRep.TopOpeBRep_DSFiller_ChangeShapeIntersector(self, *args)


    def ChangeShapeIntersector2d(self, *args):
        """
        ChangeShapeIntersector2d(TopOpeBRep_DSFiller self) -> TopOpeBRep_ShapeIntersector2d

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_ShapeIntersector2d

        """
        return _TopOpeBRep.TopOpeBRep_DSFiller_ChangeShapeIntersector2d(self, *args)


    def ChangeFacesFiller(self, *args):
        """
        ChangeFacesFiller(TopOpeBRep_DSFiller self) -> TopOpeBRep_FacesFiller

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_FacesFiller

        """
        return _TopOpeBRep.TopOpeBRep_DSFiller_ChangeFacesFiller(self, *args)


    def ChangeEdgesFiller(self, *args):
        """
        ChangeEdgesFiller(TopOpeBRep_DSFiller self) -> TopOpeBRep_EdgesFiller

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_EdgesFiller

        """
        return _TopOpeBRep.TopOpeBRep_DSFiller_ChangeEdgesFiller(self, *args)


    def ChangeFaceEdgeFiller(self, *args):
        """
        ChangeFaceEdgeFiller(TopOpeBRep_DSFiller self) -> TopOpeBRep_FaceEdgeFiller

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_FaceEdgeFiller

        """
        return _TopOpeBRep.TopOpeBRep_DSFiller_ChangeFaceEdgeFiller(self, *args)


    def GapFiller(self, *args):
        """
        GapFiller(TopOpeBRep_DSFiller self, Handle_TopOpeBRepDS_HDataStructure HDS)

        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        return _TopOpeBRep.TopOpeBRep_DSFiller_GapFiller(self, *args)


    def CompleteDS(self, *args):
        """
        CompleteDS(TopOpeBRep_DSFiller self, Handle_TopOpeBRepDS_HDataStructure HDS)

        Update   the  data      structure  with   relevant
        informations deduced from the intersections.

        Shells containing an intersected face.
        Wires  containing an intersected edge.

        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        return _TopOpeBRep.TopOpeBRep_DSFiller_CompleteDS(self, *args)


    def Filter(self, *args):
        """
        Filter(TopOpeBRep_DSFiller self, Handle_TopOpeBRepDS_HDataStructure HDS)

        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        return _TopOpeBRep.TopOpeBRep_DSFiller_Filter(self, *args)


    def Reducer(self, *args):
        """
        Reducer(TopOpeBRep_DSFiller self, Handle_TopOpeBRepDS_HDataStructure HDS)

        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        return _TopOpeBRep.TopOpeBRep_DSFiller_Reducer(self, *args)


    def RemoveUnsharedGeometry(self, *args):
        """
        RemoveUnsharedGeometry(TopOpeBRep_DSFiller self, Handle_TopOpeBRepDS_HDataStructure HDS)

        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        return _TopOpeBRep.TopOpeBRep_DSFiller_RemoveUnsharedGeometry(self, *args)


    def Checker(self, *args):
        """
        Checker(TopOpeBRep_DSFiller self, Handle_TopOpeBRepDS_HDataStructure HDS)

        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        return _TopOpeBRep.TopOpeBRep_DSFiller_Checker(self, *args)


    def CompleteDS2d(self, *args):
        """
        CompleteDS2d(TopOpeBRep_DSFiller self, Handle_TopOpeBRepDS_HDataStructure HDS)

        Update   the  data      structure  with   relevant
        informations deduced from the intersections 2d.

        Shells containing an intersected face.
        Wires  containing an intersected edge.

        search for interference identity using edge connexity //NYI

        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        return _TopOpeBRep.TopOpeBRep_DSFiller_CompleteDS2d(self, *args)

    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_DSFiller
TopOpeBRep_DSFiller_swigregister = _TopOpeBRep.TopOpeBRep_DSFiller_swigregister
TopOpeBRep_DSFiller_swigregister(TopOpeBRep_DSFiller)

class TopOpeBRep_Hctxee2d(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopOpeBRep_Hctxee2d
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopOpeBRep_Hctxee2d(self) 
            return h


    def __init__(self, *args):
        """__init__(TopOpeBRep_Hctxee2d self) -> TopOpeBRep_Hctxee2d"""
        this = _TopOpeBRep.new_TopOpeBRep_Hctxee2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetEdges(self, *args):
        """
        SetEdges(TopOpeBRep_Hctxee2d self, TopoDS_Edge E1, TopoDS_Edge E2, BRepAdaptor_Surface BAS1, BRepAdaptor_Surface BAS2)

        :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
        :type BAS1: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type BAS2: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface

        """
        return _TopOpeBRep.TopOpeBRep_Hctxee2d_SetEdges(self, *args)


    def Edge(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRep.TopOpeBRep_Hctxee2d_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curve(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve

        """
        res = _TopOpeBRep.TopOpeBRep_Hctxee2d_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Domain(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.IntRes2d.IntRes2d_Domain

        """
        res = _TopOpeBRep.TopOpeBRep_Hctxee2d_Domain(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopOpeBRep.TopOpeBRep_Hctxee2d_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopOpeBRep.TopOpeBRep_Hctxee2d_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRep.TopOpeBRep_Hctxee2d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_Hctxee2d
TopOpeBRep_Hctxee2d_swigregister = _TopOpeBRep.TopOpeBRep_Hctxee2d_swigregister
TopOpeBRep_Hctxee2d_swigregister(TopOpeBRep_Hctxee2d)

def TopOpeBRep_Hctxee2d_get_type_name(*args):
    """
    TopOpeBRep_Hctxee2d_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopOpeBRep.TopOpeBRep_Hctxee2d_get_type_name(*args)

def TopOpeBRep_Hctxee2d_get_type_descriptor(*args):
    """
    TopOpeBRep_Hctxee2d_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopOpeBRep.TopOpeBRep_Hctxee2d_get_type_descriptor(*args)

class NCollection_List_TopOpeBRep_Bipoint_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopOpeBRep.new_NCollection_List_TopOpeBRep_Bipoint_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRep.delete_NCollection_List_TopOpeBRep_Bipoint_IteratorHelper

    def __next__(self):
        return _TopOpeBRep.NCollection_List_TopOpeBRep_Bipoint_IteratorHelper___next__(self)
NCollection_List_TopOpeBRep_Bipoint_IteratorHelper_swigregister = _TopOpeBRep.NCollection_List_TopOpeBRep_Bipoint_IteratorHelper_swigregister
NCollection_List_TopOpeBRep_Bipoint_IteratorHelper_swigregister(NCollection_List_TopOpeBRep_Bipoint_IteratorHelper)


try:
	TopOpeBRep_ListOfBipoint = NCollection_List_TopOpeBRep_Bipoint
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< BRepTopAdaptor_TopolTool >,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopOpeBRep.NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< BRepTopAdaptor_TopolTool >,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopOpeBRep.NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< BRepTopAdaptor_TopolTool >,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRep.NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< BRepTopAdaptor_TopolTool >,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRep.NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TopOpeBRep.new_NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRep.NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRep.NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRep.NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopOpeBRep.NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, Handle_BRepTopAdaptor_TopolTool theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, Handle_BRepTopAdaptor_TopolTool theItem) -> Handle_BRepTopAdaptor_TopolTool

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TopOpeBRep.NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Handle_BRepTopAdaptor_TopolTool

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopOpeBRep.NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRep.NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Handle_BRepTopAdaptor_TopolTool

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopOpeBRep.NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Handle_BRepTopAdaptor_TopolTool

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopOpeBRep.NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRep.NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopOpeBRep.NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopOpeBRep.NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopOpeBRep.delete_NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_swigregister = _TopOpeBRep.NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopOpeBRep.new_NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRep.delete_NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopOpeBRep.NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _TopOpeBRep.NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher_IteratorHelper)


try:
	TopOpeBRep_DataMapOfTopolTool = NCollection_DataMap_TopoDS_Shape_Handle_BRepTopAdaptor_TopolTool_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class TopOpeBRep_FaceEdgeIntersector(object):
    """Describes the intersection of a face and an edge."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRep_FaceEdgeIntersector self) -> TopOpeBRep_FaceEdgeIntersector

        Describes the intersection of a face and an edge.
        """
        this = _TopOpeBRep.new_TopOpeBRep_FaceEdgeIntersector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(TopOpeBRep_FaceEdgeIntersector self, TopoDS_Shape F, TopoDS_Shape E)

        :type F: OCC.wrapper.TopoDS.TopoDS_Shape
        :type E: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRep.TopOpeBRep_FaceEdgeIntersector_Perform(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(TopOpeBRep_FaceEdgeIntersector self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_FaceEdgeIntersector_IsEmpty(self, *args)


    def Shape(self, *args):
        """
        returns intersected face or edge according to
        value of <Index> = 1 or 2

        :type Index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRep.TopOpeBRep_FaceEdgeIntersector_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ForceTolerance(self, *args):
        """
        ForceTolerance(TopOpeBRep_FaceEdgeIntersector self, Standard_Real const tol)

        Force the tolerance values used by the next Perform(S1,S2) call.

        :type tol: float

        """
        return _TopOpeBRep.TopOpeBRep_FaceEdgeIntersector_ForceTolerance(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(TopOpeBRep_FaceEdgeIntersector self) -> Standard_Real

        Return the tolerance value used in the last Perform() call
        If ForceTolerance() has been called, return the given value.
        If not, return value extracted from shapes.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRep.TopOpeBRep_FaceEdgeIntersector_Tolerance(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(TopOpeBRep_FaceEdgeIntersector self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.TopOpeBRep_FaceEdgeIntersector_NbPoints(self, *args)


    def InitPoint(self, *args):
        """InitPoint(TopOpeBRep_FaceEdgeIntersector self)"""
        return _TopOpeBRep.TopOpeBRep_FaceEdgeIntersector_InitPoint(self, *args)


    def MorePoint(self, *args):
        """
        MorePoint(TopOpeBRep_FaceEdgeIntersector self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_FaceEdgeIntersector_MorePoint(self, *args)


    def NextPoint(self, *args):
        """NextPoint(TopOpeBRep_FaceEdgeIntersector self)"""
        return _TopOpeBRep.TopOpeBRep_FaceEdgeIntersector_NextPoint(self, *args)


    def Value(self, *args):
        """
        Value(TopOpeBRep_FaceEdgeIntersector self) -> gp_Pnt

        return the 3D point of the current intersection point.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _TopOpeBRep.TopOpeBRep_FaceEdgeIntersector_Value(self, *args)


    def Parameter(self, *args):
        """
        Parameter(TopOpeBRep_FaceEdgeIntersector self) -> Standard_Real

        parametre de Value() sur l'arete

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRep.TopOpeBRep_FaceEdgeIntersector_Parameter(self, *args)


    def UVPoint(self, *args):
        """
        UVPoint(TopOpeBRep_FaceEdgeIntersector self, gp_Pnt2d P)

        parametre de Value() sur la face

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _TopOpeBRep.TopOpeBRep_FaceEdgeIntersector_UVPoint(self, *args)


    def State(self, *args):
        """
        State(TopOpeBRep_FaceEdgeIntersector self) -> TopAbs_State

        IN ou ON / a la face. Les points OUT ne sont pas retournes.

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _TopOpeBRep.TopOpeBRep_FaceEdgeIntersector_State(self, *args)


    def Transition(self, *args):
        """
        Transition(TopOpeBRep_FaceEdgeIntersector self, Standard_Integer const Index, TopAbs_Orientation const FaceOrientation) -> TopOpeBRepDS_Transition

        Index = 1 transition par rapport a la face, en cheminant sur l'arete

        :type Index: int
        :type FaceOrientation: OCC.wrapper.TopAbs.TopAbs_Orientation
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        return _TopOpeBRep.TopOpeBRep_FaceEdgeIntersector_Transition(self, *args)


    def IsVertex(self, *args):
        """
        IsVertex(TopOpeBRep_FaceEdgeIntersector self, TopoDS_Shape S, gp_Pnt P, Standard_Real const Tol, TopoDS_Vertex V) -> Standard_Boolean
        IsVertex(TopOpeBRep_FaceEdgeIntersector self, Standard_Integer const I, TopoDS_Vertex V) -> Standard_Boolean

        :type I: int
        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_FaceEdgeIntersector_IsVertex(self, *args)


    def Index(self, *args):
        """
        Index(TopOpeBRep_FaceEdgeIntersector self) -> Standard_Integer

        trace only

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.TopOpeBRep_FaceEdgeIntersector_Index(self, *args)

    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_FaceEdgeIntersector
TopOpeBRep_FaceEdgeIntersector_swigregister = _TopOpeBRep.TopOpeBRep_FaceEdgeIntersector_swigregister
TopOpeBRep_FaceEdgeIntersector_swigregister(TopOpeBRep_FaceEdgeIntersector)

class Handle_TopOpeBRep_HArray1OfLineInter(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopOpeBRep_HArray1OfLineInter self)

        Nullify the handle


        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfLineInter_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopOpeBRep_HArray1OfLineInter self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfLineInter_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopOpeBRep_HArray1OfLineInter self, TopOpeBRep_HArray1OfLineInter thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfLineInter_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopOpeBRep_HArray1OfLineInter self, Handle_TopOpeBRep_HArray1OfLineInter theHandle) -> Handle_TopOpeBRep_HArray1OfLineInter
        assign(Handle_TopOpeBRep_HArray1OfLineInter self, TopOpeBRep_HArray1OfLineInter thePtr) -> Handle_TopOpeBRep_HArray1OfLineInter
        assign(Handle_TopOpeBRep_HArray1OfLineInter self, Handle_TopOpeBRep_HArray1OfLineInter theHandle) -> Handle_TopOpeBRep_HArray1OfLineInter

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfLineInter_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopOpeBRep_HArray1OfLineInter self) -> TopOpeBRep_HArray1OfLineInter

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfLineInter_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopOpeBRep_HArray1OfLineInter self) -> TopOpeBRep_HArray1OfLineInter

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfLineInter___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopOpeBRep_HArray1OfLineInter self) -> TopOpeBRep_HArray1OfLineInter

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfLineInter___ref__(self, *args)


    def __hash__(self):
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfLineInter___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfLineInter___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopOpeBRep.new_Handle_TopOpeBRep_HArray1OfLineInter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopOpeBRep.Handle_TopOpeBRep_HArray1OfLineInter_DownCast)
    __swig_destroy__ = _TopOpeBRep.delete_Handle_TopOpeBRep_HArray1OfLineInter

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_Array1OfLineInter

        """
        res = _TopOpeBRep.Handle_TopOpeBRep_HArray1OfLineInter_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_TopOpeBRep_HArray1OfLineInter self) -> NCollection_Array1_TopOpeBRep_LineInter

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_Array1OfLineInter

        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfLineInter_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopOpeBRep_HArray1OfLineInter self) -> char const *

        :rtype: const char *

        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfLineInter_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRep.Handle_TopOpeBRep_HArray1OfLineInter_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRep.Handle_TopOpeBRep_HArray1OfLineInter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TopOpeBRep_HArray1OfLineInter self)

        Memory deallocator for transient classes


        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfLineInter_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopOpeBRep_HArray1OfLineInter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopOpeBRep_HArray1OfLineInter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfLineInter_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopOpeBRep_HArray1OfLineInter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopOpeBRep_HArray1OfLineInter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfLineInter_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopOpeBRep_HArray1OfLineInter self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfLineInter_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopOpeBRep_HArray1OfLineInter self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfLineInter_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopOpeBRep_HArray1OfLineInter self)

        Increments the reference counter of this object


        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfLineInter_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopOpeBRep_HArray1OfLineInter self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfLineInter_DecrementRefCounter(self, *args)

Handle_TopOpeBRep_HArray1OfLineInter_swigregister = _TopOpeBRep.Handle_TopOpeBRep_HArray1OfLineInter_swigregister
Handle_TopOpeBRep_HArray1OfLineInter_swigregister(Handle_TopOpeBRep_HArray1OfLineInter)

def Handle_TopOpeBRep_HArray1OfLineInter_DownCast(thing):
    return _TopOpeBRep.Handle_TopOpeBRep_HArray1OfLineInter_DownCast(thing)
Handle_TopOpeBRep_HArray1OfLineInter_DownCast = _TopOpeBRep.Handle_TopOpeBRep_HArray1OfLineInter_DownCast

class TopOpeBRep_Point2d(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(TopOpeBRep_Point2d self) -> TopOpeBRep_Point2d"""
        this = _TopOpeBRep.new_TopOpeBRep_Point2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Dump(self, *args):
        """
        Dump(TopOpeBRep_Point2d self, Standard_Integer const ie1=0, Standard_Integer const ie2=0)

        :type ie1: int
        :type ie2: int

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_Dump(self, *args)


    def SetPint(self, *args):
        """
        SetPint(TopOpeBRep_Point2d self, IntRes2d_IntersectionPoint P)

        :type P: OCC.wrapper.IntRes2d.IntRes2d_IntersectionPoint

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_SetPint(self, *args)


    def HasPint(self, *args):
        """
        HasPint(TopOpeBRep_Point2d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_HasPint(self, *args)


    def Pint(self, *args):
        """
        :rtype: OCC.wrapper.IntRes2d.IntRes2d_IntersectionPoint

        """
        res = _TopOpeBRep.TopOpeBRep_Point2d_Pint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetIsVertex(self, *args):
        """
        SetIsVertex(TopOpeBRep_Point2d self, Standard_Integer const I, Standard_Boolean const B)

        :type I: int
        :type B: bool

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_SetIsVertex(self, *args)


    def IsVertex(self, *args):
        """
        IsVertex(TopOpeBRep_Point2d self, Standard_Integer const I) -> Standard_Boolean

        :type I: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_IsVertex(self, *args)


    def SetVertex(self, *args):
        """
        SetVertex(TopOpeBRep_Point2d self, Standard_Integer const I, TopoDS_Vertex V)

        :type I: int
        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_SetVertex(self, *args)


    def Vertex(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _TopOpeBRep.TopOpeBRep_Point2d_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransition(self, *args):
        """
        SetTransition(TopOpeBRep_Point2d self, Standard_Integer const I, TopOpeBRepDS_Transition T)

        :type I: int
        :type T: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_SetTransition(self, *args)


    def Transition(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        res = _TopOpeBRep.TopOpeBRep_Point2d_Transition(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeTransition(self, *args):
        """
        ChangeTransition(TopOpeBRep_Point2d self, Standard_Integer const I) -> TopOpeBRepDS_Transition

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_ChangeTransition(self, *args)


    def SetParameter(self, *args):
        """
        SetParameter(TopOpeBRep_Point2d self, Standard_Integer const I, Standard_Real const P)

        :type I: int
        :type P: float

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_SetParameter(self, *args)


    def Parameter(self, *args):
        """
        Parameter(TopOpeBRep_Point2d self, Standard_Integer const I) -> Standard_Real

        :type I: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_Parameter(self, *args)


    def SetIsPointOfSegment(self, *args):
        """
        SetIsPointOfSegment(TopOpeBRep_Point2d self, Standard_Boolean const B)

        :type B: bool

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_SetIsPointOfSegment(self, *args)


    def IsPointOfSegment(self, *args):
        """
        IsPointOfSegment(TopOpeBRep_Point2d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_IsPointOfSegment(self, *args)


    def SetSegmentAncestors(self, *args):
        """
        SetSegmentAncestors(TopOpeBRep_Point2d self, Standard_Integer const IP1, Standard_Integer const IP2)

        :type IP1: int
        :type IP2: int

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_SetSegmentAncestors(self, *args)


    def SegmentAncestors(self, *args):
        """
        SegmentAncestors(TopOpeBRep_Point2d self) -> Standard_Boolean

        :type IP1: int
        :type IP2: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_SegmentAncestors(self, *args)


    def SetStatus(self, *args):
        """
        SetStatus(TopOpeBRep_Point2d self, TopOpeBRep_P2Dstatus const S)

        :type S: OCC.wrapper.TopOpeBRep.TopOpeBRep_P2Dstatus

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_SetStatus(self, *args)


    def Status(self, *args):
        """
        Status(TopOpeBRep_Point2d self) -> TopOpeBRep_P2Dstatus

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_P2Dstatus

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_Status(self, *args)


    def SetIndex(self, *args):
        """
        SetIndex(TopOpeBRep_Point2d self, Standard_Integer const X)

        :type X: int

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_SetIndex(self, *args)


    def Index(self, *args):
        """
        Index(TopOpeBRep_Point2d self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_Index(self, *args)


    def SetValue(self, *args):
        """
        SetValue(TopOpeBRep_Point2d self, gp_Pnt P)

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_SetValue(self, *args)


    def Value(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _TopOpeBRep.TopOpeBRep_Point2d_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue2d(self, *args):
        """
        SetValue2d(TopOpeBRep_Point2d self, gp_Pnt2d P)

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_SetValue2d(self, *args)


    def Value2d(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _TopOpeBRep.TopOpeBRep_Point2d_Value2d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetKeep(self, *args):
        """
        SetKeep(TopOpeBRep_Point2d self, Standard_Boolean const B)

        :type B: bool

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_SetKeep(self, *args)


    def Keep(self, *args):
        """
        Keep(TopOpeBRep_Point2d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_Keep(self, *args)


    def SetEdgesConfig(self, *args):
        """
        SetEdgesConfig(TopOpeBRep_Point2d self, TopOpeBRepDS_Config const C)

        :type C: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Config

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_SetEdgesConfig(self, *args)


    def EdgesConfig(self, *args):
        """
        EdgesConfig(TopOpeBRep_Point2d self) -> TopOpeBRepDS_Config

        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Config

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_EdgesConfig(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(TopOpeBRep_Point2d self, Standard_Real const T)

        :type T: float

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_SetTolerance(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(TopOpeBRep_Point2d self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_Tolerance(self, *args)


    def SetHctxff2d(self, *args):
        """
        SetHctxff2d(TopOpeBRep_Point2d self, Handle_TopOpeBRep_Hctxff2d ff2d)

        :type ff2d: OCC.wrapper.TopOpeBRep.Handle_TopOpeBRep_Hctxff2d

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_SetHctxff2d(self, *args)


    def Hctxff2d(self, *args):
        """
        Hctxff2d(TopOpeBRep_Point2d self) -> Handle_TopOpeBRep_Hctxff2d

        :rtype: OCC.wrapper.TopOpeBRep.Handle_TopOpeBRep_Hctxff2d

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_Hctxff2d(self, *args)


    def SetHctxee2d(self, *args):
        """
        SetHctxee2d(TopOpeBRep_Point2d self, Handle_TopOpeBRep_Hctxee2d ee2d)

        :type ee2d: OCC.wrapper.TopOpeBRep.Handle_TopOpeBRep_Hctxee2d

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_SetHctxee2d(self, *args)


    def Hctxee2d(self, *args):
        """
        Hctxee2d(TopOpeBRep_Point2d self) -> Handle_TopOpeBRep_Hctxee2d

        :rtype: OCC.wrapper.TopOpeBRep.Handle_TopOpeBRep_Hctxee2d

        """
        return _TopOpeBRep.TopOpeBRep_Point2d_Hctxee2d(self, *args)

    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_Point2d
TopOpeBRep_Point2d_swigregister = _TopOpeBRep.TopOpeBRep_Point2d_swigregister
TopOpeBRep_Point2d_swigregister(TopOpeBRep_Point2d)

class TopOpeBRep_WPointInterIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRep_WPointInterIterator self) -> TopOpeBRep_WPointInterIterator
        __init__(TopOpeBRep_WPointInterIterator self, TopOpeBRep_LineInter LI) -> TopOpeBRep_WPointInterIterator

        :type LI: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter

        """
        this = _TopOpeBRep.new_TopOpeBRep_WPointInterIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(TopOpeBRep_WPointInterIterator self, TopOpeBRep_LineInter LI)
        Init(TopOpeBRep_WPointInterIterator self)

        :type LI: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter

        """
        return _TopOpeBRep.TopOpeBRep_WPointInterIterator_Init(self, *args)


    def More(self, *args):
        """
        More(TopOpeBRep_WPointInterIterator self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_WPointInterIterator_More(self, *args)


    def Next(self, *args):
        """Next(TopOpeBRep_WPointInterIterator self)"""
        return _TopOpeBRep.TopOpeBRep_WPointInterIterator_Next(self, *args)


    def CurrentWP(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_WPointInter

        """
        res = _TopOpeBRep.TopOpeBRep_WPointInterIterator_CurrentWP(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PLineInterDummy(self, *args):
        """
        PLineInterDummy(TopOpeBRep_WPointInterIterator self) -> TopOpeBRep_LineInter

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_PLineInter

        """
        return _TopOpeBRep.TopOpeBRep_WPointInterIterator_PLineInterDummy(self, *args)

    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_WPointInterIterator
TopOpeBRep_WPointInterIterator_swigregister = _TopOpeBRep.TopOpeBRep_WPointInterIterator_swigregister
TopOpeBRep_WPointInterIterator_swigregister(TopOpeBRep_WPointInterIterator)

class TopOpeBRep_PointClassifier(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(TopOpeBRep_PointClassifier self) -> TopOpeBRep_PointClassifier"""
        this = _TopOpeBRep.new_TopOpeBRep_PointClassifier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """Init(TopOpeBRep_PointClassifier self)"""
        return _TopOpeBRep.TopOpeBRep_PointClassifier_Init(self, *args)


    def Load(self, *args):
        """
        Load(TopOpeBRep_PointClassifier self, TopoDS_Face F)

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _TopOpeBRep.TopOpeBRep_PointClassifier_Load(self, *args)


    def Classify(self, *args):
        """
        Classify(TopOpeBRep_PointClassifier self, TopoDS_Face F, gp_Pnt2d P, Standard_Real const Tol) -> TopAbs_State

        compute position of point <P> regarding with the face <F>.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Tol: float
        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _TopOpeBRep.TopOpeBRep_PointClassifier_Classify(self, *args)


    def State(self, *args):
        """
        State(TopOpeBRep_PointClassifier self) -> TopAbs_State

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _TopOpeBRep.TopOpeBRep_PointClassifier_State(self, *args)

    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_PointClassifier
TopOpeBRep_PointClassifier_swigregister = _TopOpeBRep.TopOpeBRep_PointClassifier_swigregister
TopOpeBRep_PointClassifier_swigregister(TopOpeBRep_PointClassifier)

class NCollection_Sequence_TopOpeBRep_Point2d(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_TopOpeBRep_Point2d self) -> NCollection_Sequence< TopOpeBRep_Point2d >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_TopOpeBRep_Point2d self) -> NCollection_Sequence< TopOpeBRep_Point2d >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_TopOpeBRep_Point2d self) -> NCollection_Sequence< TopOpeBRep_Point2d >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_TopOpeBRep_Point2d self) -> NCollection_Sequence< TopOpeBRep_Point2d >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _TopOpeBRep.new_NCollection_Sequence_TopOpeBRep_Point2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_TopOpeBRep_Point2d self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_TopOpeBRep_Point2d self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_TopOpeBRep_Point2d self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_TopOpeBRep_Point2d self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_TopOpeBRep_Point2d self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_TopOpeBRep_Point2d self)

        Reverse sequence


        """
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_TopOpeBRep_Point2d self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_TopOpeBRep_Point2d self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_TopOpeBRep_Point2d self, NCollection_Sequence_TopOpeBRep_Point2d theOther) -> NCollection_Sequence_TopOpeBRep_Point2d

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_TopOpeBRep_Point2d self, NCollection_Sequence_TopOpeBRep_Point2d theOther) -> NCollection_Sequence_TopOpeBRep_Point2d

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_TopOpeBRep_Point2d self, NCollection_Sequence< TopOpeBRep_Point2d >::Iterator & thePosition)
        Remove(NCollection_Sequence_TopOpeBRep_Point2d self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_TopOpeBRep_Point2d self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_TopOpeBRep_Point2d self, TopOpeBRep_Point2d theItem)
        Append(NCollection_Sequence_TopOpeBRep_Point2d self, NCollection_Sequence_TopOpeBRep_Point2d theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_TopOpeBRep_Point2d self, TopOpeBRep_Point2d theItem)
        Prepend(NCollection_Sequence_TopOpeBRep_Point2d self, NCollection_Sequence_TopOpeBRep_Point2d theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_TopOpeBRep_Point2d self, Standard_Integer const theIndex, TopOpeBRep_Point2d theItem)
        InsertBefore(NCollection_Sequence_TopOpeBRep_Point2d self, Standard_Integer const theIndex, NCollection_Sequence_TopOpeBRep_Point2d theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_TopOpeBRep_Point2d self, NCollection_Sequence< TopOpeBRep_Point2d >::Iterator & thePosition, TopOpeBRep_Point2d theItem)
        InsertAfter(NCollection_Sequence_TopOpeBRep_Point2d self, Standard_Integer const theIndex, NCollection_Sequence_TopOpeBRep_Point2d theSeq)
        InsertAfter(NCollection_Sequence_TopOpeBRep_Point2d self, Standard_Integer const theIndex, TopOpeBRep_Point2d theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_TopOpeBRep_Point2d self, Standard_Integer const theIndex, NCollection_Sequence_TopOpeBRep_Point2d theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_TopOpeBRep_Point2d self) -> TopOpeBRep_Point2d

        First item access

        :rtype: TheItemType &

        """
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_TopOpeBRep_Point2d self) -> TopOpeBRep_Point2d

        Last item access

        :rtype: TheItemType &

        """
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_TopOpeBRep_Point2d self, Standard_Integer const theIndex) -> TopOpeBRep_Point2d

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_TopOpeBRep_Point2d self, Standard_Integer const theIndex, TopOpeBRep_Point2d theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_SetValue(self, *args)


    def __iter__(self):
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d___iter__(self)
    __swig_destroy__ = _TopOpeBRep.delete_NCollection_Sequence_TopOpeBRep_Point2d
NCollection_Sequence_TopOpeBRep_Point2d_swigregister = _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_swigregister
NCollection_Sequence_TopOpeBRep_Point2d_swigregister(NCollection_Sequence_TopOpeBRep_Point2d)

def NCollection_Sequence_TopOpeBRep_Point2d_delNode(*args):
    """
    NCollection_Sequence_TopOpeBRep_Point2d_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_delNode(*args)

class NCollection_Sequence_TopOpeBRep_Point2d_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopOpeBRep.new_NCollection_Sequence_TopOpeBRep_Point2d_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRep.delete_NCollection_Sequence_TopOpeBRep_Point2d_IteratorHelper

    def __next__(self):
        return _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_IteratorHelper___next__(self)
NCollection_Sequence_TopOpeBRep_Point2d_IteratorHelper_swigregister = _TopOpeBRep.NCollection_Sequence_TopOpeBRep_Point2d_IteratorHelper_swigregister
NCollection_Sequence_TopOpeBRep_Point2d_IteratorHelper_swigregister(NCollection_Sequence_TopOpeBRep_Point2d_IteratorHelper)


try:
	TopOpeBRep_SequenceOfPoint2d = NCollection_Sequence_TopOpeBRep_Point2d
except NameError:
	pass # does not exist, probably ignored

class TopOpeBRep_FaceEdgeFiller(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(TopOpeBRep_FaceEdgeFiller self) -> TopOpeBRep_FaceEdgeFiller"""
        this = _TopOpeBRep.new_TopOpeBRep_FaceEdgeFiller(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Insert(self, *args):
        """
        Insert(TopOpeBRep_FaceEdgeFiller self, TopoDS_Shape F, TopoDS_Shape E, TopOpeBRep_FaceEdgeIntersector FEINT, Handle_TopOpeBRepDS_HDataStructure HDS)

        :type F: OCC.wrapper.TopoDS.TopoDS_Shape
        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :type FEINT: OCC.wrapper.TopOpeBRep.TopOpeBRep_FaceEdgeIntersector
        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        return _TopOpeBRep.TopOpeBRep_FaceEdgeFiller_Insert(self, *args)

    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_FaceEdgeFiller
TopOpeBRep_FaceEdgeFiller_swigregister = _TopOpeBRep.TopOpeBRep_FaceEdgeFiller_swigregister
TopOpeBRep_FaceEdgeFiller_swigregister(TopOpeBRep_FaceEdgeFiller)

class TopOpeBRep_(object):
    """
    This package provides  the topological  operations
    on the BRep data structure.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Print(*args):
        """
        Print(TopOpeBRep_TypeLineCurve const TLC, Standard_OStream & OS) -> Standard_OStream &

        Prints the name  of  <TLC>  as  a String  on the
        Stream <S> and returns <S>.

        :type TLC: OCC.wrapper.TopOpeBRep.TopOpeBRep_TypeLineCurve
        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TopOpeBRep.TopOpeBRep__Print(*args)

    Print = staticmethod(Print)

    def __init__(self):
        """
        This package provides  the topological  operations
        on the BRep data structure.
        """
        this = _TopOpeBRep.new_TopOpeBRep_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_
TopOpeBRep__swigregister = _TopOpeBRep.TopOpeBRep__swigregister
TopOpeBRep__swigregister(TopOpeBRep_)

def TopOpeBRep__Print(*args):
    """
    TopOpeBRep__Print(TopOpeBRep_TypeLineCurve const TLC, Standard_OStream & OS) -> Standard_OStream &

    Prints the name  of  <TLC>  as  a String  on the
    Stream <S> and returns <S>.

    :type TLC: OCC.wrapper.TopOpeBRep.TopOpeBRep_TypeLineCurve
    :type OS: OCC.wrapper.Standard.Standard_OStream
    :rtype: OCC.wrapper.Standard.Standard_OStream

    """
    return _TopOpeBRep.TopOpeBRep__Print(*args)

class TopOpeBRep_FFDumper(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopOpeBRep_FFDumper
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopOpeBRep_FFDumper(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopOpeBRep_FFDumper self, TopOpeBRep_FacesFiller PFF) -> TopOpeBRep_FFDumper

        :type PFF: OCC.wrapper.TopOpeBRep.TopOpeBRep_PFacesFiller

        """
        this = _TopOpeBRep.new_TopOpeBRep_FFDumper(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(TopOpeBRep_FFDumper self, TopOpeBRep_FacesFiller PFF)

        :type PFF: OCC.wrapper.TopOpeBRep.TopOpeBRep_PFacesFiller

        """
        return _TopOpeBRep.TopOpeBRep_FFDumper_Init(self, *args)


    def DumpLine(self, *args):
        """
        DumpLine(TopOpeBRep_FFDumper self, Standard_Integer const I)
        DumpLine(TopOpeBRep_FFDumper self, TopOpeBRep_LineInter L)

        :type L: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter

        """
        return _TopOpeBRep.TopOpeBRep_FFDumper_DumpLine(self, *args)


    def DumpVP(self, *args):
        """
        DumpVP(TopOpeBRep_FFDumper self, TopOpeBRep_VPointInter VP)
        DumpVP(TopOpeBRep_FFDumper self, TopOpeBRep_VPointInter VP, Standard_Integer const ISI)

        :type VP: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter
        :type ISI: int

        """
        return _TopOpeBRep.TopOpeBRep_FFDumper_DumpVP(self, *args)


    def ExploreIndex(self, *args):
        """
        ExploreIndex(TopOpeBRep_FFDumper self, TopoDS_Shape S, Standard_Integer const ISI) -> Standard_Integer

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type ISI: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.TopOpeBRep_FFDumper_ExploreIndex(self, *args)


    def DumpDSP(self, *args):
        """
        DumpDSP(TopOpeBRep_FFDumper self, TopOpeBRep_VPointInter VP, TopOpeBRepDS_Kind const GK, Standard_Integer const G, Standard_Boolean const newinDS)

        :type VP: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter
        :type GK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type G: int
        :type newinDS: bool

        """
        return _TopOpeBRep.TopOpeBRep_FFDumper_DumpDSP(self, *args)


    def PFacesFillerDummy(self, *args):
        """
        PFacesFillerDummy(TopOpeBRep_FFDumper self) -> TopOpeBRep_FacesFiller

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_PFacesFiller

        """
        return _TopOpeBRep.TopOpeBRep_FFDumper_PFacesFillerDummy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopOpeBRep.TopOpeBRep_FFDumper_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopOpeBRep.TopOpeBRep_FFDumper_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRep.TopOpeBRep_FFDumper_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_FFDumper
TopOpeBRep_FFDumper_swigregister = _TopOpeBRep.TopOpeBRep_FFDumper_swigregister
TopOpeBRep_FFDumper_swigregister(TopOpeBRep_FFDumper)

def TopOpeBRep_FFDumper_get_type_name(*args):
    """
    TopOpeBRep_FFDumper_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopOpeBRep.TopOpeBRep_FFDumper_get_type_name(*args)

def TopOpeBRep_FFDumper_get_type_descriptor(*args):
    """
    TopOpeBRep_FFDumper_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopOpeBRep.TopOpeBRep_FFDumper_get_type_descriptor(*args)

class Handle_TopOpeBRep_Hctxee2d(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopOpeBRep_Hctxee2d self)

        Nullify the handle


        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxee2d_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopOpeBRep_Hctxee2d self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxee2d_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopOpeBRep_Hctxee2d self, TopOpeBRep_Hctxee2d thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxee2d_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopOpeBRep_Hctxee2d self, Handle_TopOpeBRep_Hctxee2d theHandle) -> Handle_TopOpeBRep_Hctxee2d
        assign(Handle_TopOpeBRep_Hctxee2d self, TopOpeBRep_Hctxee2d thePtr) -> Handle_TopOpeBRep_Hctxee2d
        assign(Handle_TopOpeBRep_Hctxee2d self, Handle_TopOpeBRep_Hctxee2d theHandle) -> Handle_TopOpeBRep_Hctxee2d

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxee2d_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopOpeBRep_Hctxee2d self) -> TopOpeBRep_Hctxee2d

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxee2d_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopOpeBRep_Hctxee2d self) -> TopOpeBRep_Hctxee2d

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxee2d___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopOpeBRep_Hctxee2d self) -> TopOpeBRep_Hctxee2d

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxee2d___ref__(self, *args)


    def __hash__(self):
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxee2d___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopOpeBRep.Handle_TopOpeBRep_Hctxee2d___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopOpeBRep.new_Handle_TopOpeBRep_Hctxee2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopOpeBRep.Handle_TopOpeBRep_Hctxee2d_DownCast)
    __swig_destroy__ = _TopOpeBRep.delete_Handle_TopOpeBRep_Hctxee2d

    def SetEdges(self, *args):
        """
        SetEdges(Handle_TopOpeBRep_Hctxee2d self, TopoDS_Edge E1, TopoDS_Edge E2, BRepAdaptor_Surface BAS1, BRepAdaptor_Surface BAS2)

        :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
        :type BAS1: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface
        :type BAS2: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxee2d_SetEdges(self, *args)


    def Edge(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRep.Handle_TopOpeBRep_Hctxee2d_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curve(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve

        """
        res = _TopOpeBRep.Handle_TopOpeBRep_Hctxee2d_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Domain(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.IntRes2d.IntRes2d_Domain

        """
        res = _TopOpeBRep.Handle_TopOpeBRep_Hctxee2d_Domain(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopOpeBRep_Hctxee2d self) -> char const *

        :rtype: const char *

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxee2d_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRep.Handle_TopOpeBRep_Hctxee2d_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRep.Handle_TopOpeBRep_Hctxee2d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TopOpeBRep_Hctxee2d self)

        Memory deallocator for transient classes


        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxee2d_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopOpeBRep_Hctxee2d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopOpeBRep_Hctxee2d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxee2d_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopOpeBRep_Hctxee2d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopOpeBRep_Hctxee2d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxee2d_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopOpeBRep_Hctxee2d self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxee2d_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopOpeBRep_Hctxee2d self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxee2d_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopOpeBRep_Hctxee2d self)

        Increments the reference counter of this object


        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxee2d_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopOpeBRep_Hctxee2d self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.Handle_TopOpeBRep_Hctxee2d_DecrementRefCounter(self, *args)

Handle_TopOpeBRep_Hctxee2d_swigregister = _TopOpeBRep.Handle_TopOpeBRep_Hctxee2d_swigregister
Handle_TopOpeBRep_Hctxee2d_swigregister(Handle_TopOpeBRep_Hctxee2d)

def Handle_TopOpeBRep_Hctxee2d_DownCast(thing):
    return _TopOpeBRep.Handle_TopOpeBRep_Hctxee2d_DownCast(thing)
Handle_TopOpeBRep_Hctxee2d_DownCast = _TopOpeBRep.Handle_TopOpeBRep_Hctxee2d_DownCast

class TopOpeBRep_EdgesFiller(object):
    """
    Fills a TopOpeBRepDS_DataStructure with Edge/Edge
    instersection data described by TopOpeBRep_EdgesIntersector.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRep_EdgesFiller self) -> TopOpeBRep_EdgesFiller

        Fills a TopOpeBRepDS_DataStructure with Edge/Edge
        instersection data described by TopOpeBRep_EdgesIntersector.
        """
        this = _TopOpeBRep.new_TopOpeBRep_EdgesFiller(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Insert(self, *args):
        """
        Insert(TopOpeBRep_EdgesFiller self, TopoDS_Shape E1, TopoDS_Shape E2, TopOpeBRep_EdgesIntersector EI, Handle_TopOpeBRepDS_HDataStructure HDS)

        :type E1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type E2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type EI: OCC.wrapper.TopOpeBRep.TopOpeBRep_EdgesIntersector
        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        return _TopOpeBRep.TopOpeBRep_EdgesFiller_Insert(self, *args)


    def Face(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRep.TopOpeBRep_EdgesFiller_Face(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_EdgesFiller
TopOpeBRep_EdgesFiller_swigregister = _TopOpeBRep.TopOpeBRep_EdgesFiller_swigregister
TopOpeBRep_EdgesFiller_swigregister(TopOpeBRep_EdgesFiller)

class Handle_TopOpeBRep_FFDumper(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopOpeBRep_FFDumper self)

        Nullify the handle


        """
        return _TopOpeBRep.Handle_TopOpeBRep_FFDumper_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopOpeBRep_FFDumper self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopOpeBRep.Handle_TopOpeBRep_FFDumper_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopOpeBRep_FFDumper self, TopOpeBRep_FFDumper thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopOpeBRep.Handle_TopOpeBRep_FFDumper_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopOpeBRep_FFDumper self, Handle_TopOpeBRep_FFDumper theHandle) -> Handle_TopOpeBRep_FFDumper
        assign(Handle_TopOpeBRep_FFDumper self, TopOpeBRep_FFDumper thePtr) -> Handle_TopOpeBRep_FFDumper
        assign(Handle_TopOpeBRep_FFDumper self, Handle_TopOpeBRep_FFDumper theHandle) -> Handle_TopOpeBRep_FFDumper

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopOpeBRep.Handle_TopOpeBRep_FFDumper_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopOpeBRep_FFDumper self) -> TopOpeBRep_FFDumper

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopOpeBRep.Handle_TopOpeBRep_FFDumper_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopOpeBRep_FFDumper self) -> TopOpeBRep_FFDumper

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopOpeBRep.Handle_TopOpeBRep_FFDumper___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopOpeBRep_FFDumper self) -> TopOpeBRep_FFDumper

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopOpeBRep.Handle_TopOpeBRep_FFDumper___ref__(self, *args)


    def __hash__(self):
        return _TopOpeBRep.Handle_TopOpeBRep_FFDumper___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopOpeBRep.Handle_TopOpeBRep_FFDumper___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopOpeBRep.new_Handle_TopOpeBRep_FFDumper(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopOpeBRep.Handle_TopOpeBRep_FFDumper_DownCast)
    __swig_destroy__ = _TopOpeBRep.delete_Handle_TopOpeBRep_FFDumper

    def Init(self, *args):
        """
        Init(Handle_TopOpeBRep_FFDumper self, TopOpeBRep_FacesFiller PFF)

        :type PFF: OCC.wrapper.TopOpeBRep.TopOpeBRep_PFacesFiller

        """
        return _TopOpeBRep.Handle_TopOpeBRep_FFDumper_Init(self, *args)


    def DumpLine(self, *args):
        """
        DumpLine(Handle_TopOpeBRep_FFDumper self, Standard_Integer const I)
        DumpLine(Handle_TopOpeBRep_FFDumper self, TopOpeBRep_LineInter L)

        :type L: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter

        """
        return _TopOpeBRep.Handle_TopOpeBRep_FFDumper_DumpLine(self, *args)


    def DumpVP(self, *args):
        """
        DumpVP(Handle_TopOpeBRep_FFDumper self, TopOpeBRep_VPointInter VP)
        DumpVP(Handle_TopOpeBRep_FFDumper self, TopOpeBRep_VPointInter VP, Standard_Integer const ISI)

        :type VP: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter
        :type ISI: int

        """
        return _TopOpeBRep.Handle_TopOpeBRep_FFDumper_DumpVP(self, *args)


    def ExploreIndex(self, *args):
        """
        ExploreIndex(Handle_TopOpeBRep_FFDumper self, TopoDS_Shape S, Standard_Integer const ISI) -> Standard_Integer

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type ISI: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.Handle_TopOpeBRep_FFDumper_ExploreIndex(self, *args)


    def DumpDSP(self, *args):
        """
        DumpDSP(Handle_TopOpeBRep_FFDumper self, TopOpeBRep_VPointInter VP, TopOpeBRepDS_Kind const GK, Standard_Integer const G, Standard_Boolean const newinDS)

        :type VP: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter
        :type GK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type G: int
        :type newinDS: bool

        """
        return _TopOpeBRep.Handle_TopOpeBRep_FFDumper_DumpDSP(self, *args)


    def PFacesFillerDummy(self, *args):
        """
        PFacesFillerDummy(Handle_TopOpeBRep_FFDumper self) -> TopOpeBRep_FacesFiller

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_PFacesFiller

        """
        return _TopOpeBRep.Handle_TopOpeBRep_FFDumper_PFacesFillerDummy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopOpeBRep_FFDumper self) -> char const *

        :rtype: const char *

        """
        return _TopOpeBRep.Handle_TopOpeBRep_FFDumper_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRep.Handle_TopOpeBRep_FFDumper_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRep.Handle_TopOpeBRep_FFDumper_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TopOpeBRep_FFDumper self)

        Memory deallocator for transient classes


        """
        return _TopOpeBRep.Handle_TopOpeBRep_FFDumper_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopOpeBRep_FFDumper self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopOpeBRep_FFDumper self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.Handle_TopOpeBRep_FFDumper_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopOpeBRep_FFDumper self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopOpeBRep_FFDumper self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.Handle_TopOpeBRep_FFDumper_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopOpeBRep_FFDumper self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopOpeBRep.Handle_TopOpeBRep_FFDumper_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopOpeBRep_FFDumper self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.Handle_TopOpeBRep_FFDumper_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopOpeBRep_FFDumper self)

        Increments the reference counter of this object


        """
        return _TopOpeBRep.Handle_TopOpeBRep_FFDumper_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopOpeBRep_FFDumper self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.Handle_TopOpeBRep_FFDumper_DecrementRefCounter(self, *args)

Handle_TopOpeBRep_FFDumper_swigregister = _TopOpeBRep.Handle_TopOpeBRep_FFDumper_swigregister
Handle_TopOpeBRep_FFDumper_swigregister(Handle_TopOpeBRep_FFDumper)

def Handle_TopOpeBRep_FFDumper_DownCast(thing):
    return _TopOpeBRep.Handle_TopOpeBRep_FFDumper_DownCast(thing)
Handle_TopOpeBRep_FFDumper_DownCast = _TopOpeBRep.Handle_TopOpeBRep_FFDumper_DownCast

class TopOpeBRep_EdgesIntersector(object):
    """Describes the intersection of two edges on the same surface"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRep_EdgesIntersector self) -> TopOpeBRep_EdgesIntersector

        Describes the intersection of two edges on the same surface
        """
        this = _TopOpeBRep.new_TopOpeBRep_EdgesIntersector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetFaces(self, *args):
        """
        SetFaces(TopOpeBRep_EdgesIntersector self, TopoDS_Shape F1, TopoDS_Shape F2)
        SetFaces(TopOpeBRep_EdgesIntersector self, TopoDS_Shape F1, TopoDS_Shape F2, Bnd_Box B1, Bnd_Box B2)

        :type F1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type F2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type B1: OCC.wrapper.Bnd.Bnd_Box
        :type B2: OCC.wrapper.Bnd.Bnd_Box

        """
        return _TopOpeBRep.TopOpeBRep_EdgesIntersector_SetFaces(self, *args)


    def ForceTolerances(self, *args):
        """
        ForceTolerances(TopOpeBRep_EdgesIntersector self, Standard_Real const Tol1, Standard_Real const Tol2)

        :type Tol1: float
        :type Tol2: float

        """
        return _TopOpeBRep.TopOpeBRep_EdgesIntersector_ForceTolerances(self, *args)


    def Dimension(self, *args):
        """
        Dimension(TopOpeBRep_EdgesIntersector self, Standard_Integer const D)
        Dimension(TopOpeBRep_EdgesIntersector self) -> Standard_Integer

        set working space dimension D = 1 for E &|| W, 2 for E in F

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.TopOpeBRep_EdgesIntersector_Dimension(self, *args)


    def Perform(self, *args):
        """
        Perform(TopOpeBRep_EdgesIntersector self, TopoDS_Shape E1, TopoDS_Shape E2, Standard_Boolean const ReduceSegments)

        :type E1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type E2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type ReduceSegments: bool

        """
        return _TopOpeBRep.TopOpeBRep_EdgesIntersector_Perform(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(TopOpeBRep_EdgesIntersector self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_EdgesIntersector_IsEmpty(self, *args)


    def HasSegment(self, *args):
        """
        HasSegment(TopOpeBRep_EdgesIntersector self) -> Standard_Boolean

        true if at least one intersection segment.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_EdgesIntersector_HasSegment(self, *args)


    def SameDomain(self, *args):
        """
        SameDomain(TopOpeBRep_EdgesIntersector self) -> Standard_Boolean

        = mySameDomain.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_EdgesIntersector_SameDomain(self, *args)


    def Edge(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRep.TopOpeBRep_EdgesIntersector_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curve(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.Geom2dAdaptor.Geom2dAdaptor_Curve

        """
        res = _TopOpeBRep.TopOpeBRep_EdgesIntersector_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Face(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRep.TopOpeBRep_EdgesIntersector_Face(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface(self, *args):
        """
        Surface(TopOpeBRep_EdgesIntersector self, Standard_Integer const Index) -> BRepAdaptor_Surface

        :type Index: int
        :rtype: OCC.wrapper.BRepAdaptor.BRepAdaptor_Surface

        """
        return _TopOpeBRep.TopOpeBRep_EdgesIntersector_Surface(self, *args)


    def SurfacesSameOriented(self, *args):
        """
        SurfacesSameOriented(TopOpeBRep_EdgesIntersector self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_EdgesIntersector_SurfacesSameOriented(self, *args)


    def FacesSameOriented(self, *args):
        """
        FacesSameOriented(TopOpeBRep_EdgesIntersector self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_EdgesIntersector_FacesSameOriented(self, *args)


    def ToleranceMax(self, *args):
        """
        ToleranceMax(TopOpeBRep_EdgesIntersector self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRep.TopOpeBRep_EdgesIntersector_ToleranceMax(self, *args)


    def Tolerances(self, *args):
        """
        Tolerances(TopOpeBRep_EdgesIntersector self)

        :type tol1: float
        :type tol2: float

        """
        return _TopOpeBRep.TopOpeBRep_EdgesIntersector_Tolerances(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(TopOpeBRep_EdgesIntersector self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.TopOpeBRep_EdgesIntersector_NbPoints(self, *args)


    def NbSegments(self, *args):
        """
        NbSegments(TopOpeBRep_EdgesIntersector self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.TopOpeBRep_EdgesIntersector_NbSegments(self, *args)


    def Dump(self, *args):
        """
        Dump(TopOpeBRep_EdgesIntersector self, TCollection_AsciiString str, Standard_Integer const ie1=0, Standard_Integer const ie2=0)

        :type str: OCC.wrapper.TCollection.TCollection_AsciiString
        :type ie1: int
        :type ie2: int

        """
        return _TopOpeBRep.TopOpeBRep_EdgesIntersector_Dump(self, *args)


    def InitPoint(self, *args):
        """
        InitPoint(TopOpeBRep_EdgesIntersector self, Standard_Boolean const selectkeep)

        :type selectkeep: bool

        """
        return _TopOpeBRep.TopOpeBRep_EdgesIntersector_InitPoint(self, *args)


    def MorePoint(self, *args):
        """
        MorePoint(TopOpeBRep_EdgesIntersector self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_EdgesIntersector_MorePoint(self, *args)


    def NextPoint(self, *args):
        """NextPoint(TopOpeBRep_EdgesIntersector self)"""
        return _TopOpeBRep.TopOpeBRep_EdgesIntersector_NextPoint(self, *args)


    def Points(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_SequenceOfPoint2d

        """
        res = _TopOpeBRep.TopOpeBRep_EdgesIntersector_Points(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Point(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_Point2d

        """
        res = _TopOpeBRep.TopOpeBRep_EdgesIntersector_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ReduceSegment(self, *args):
        """
        ReduceSegment(TopOpeBRep_EdgesIntersector self, TopOpeBRep_Point2d P1, TopOpeBRep_Point2d P2, TopOpeBRep_Point2d Pn) -> Standard_Boolean

        :type P1: OCC.wrapper.TopOpeBRep.TopOpeBRep_Point2d
        :type P2: OCC.wrapper.TopOpeBRep.TopOpeBRep_Point2d
        :type Pn: OCC.wrapper.TopOpeBRep.TopOpeBRep_Point2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_EdgesIntersector_ReduceSegment(self, *args)


    def Status1(self, *args):
        """
        Status1(TopOpeBRep_EdgesIntersector self) -> TopOpeBRep_P2Dstatus

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_P2Dstatus

        """
        return _TopOpeBRep.TopOpeBRep_EdgesIntersector_Status1(self, *args)

    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_EdgesIntersector
TopOpeBRep_EdgesIntersector_swigregister = _TopOpeBRep.TopOpeBRep_EdgesIntersector_swigregister
TopOpeBRep_EdgesIntersector_swigregister(TopOpeBRep_EdgesIntersector)

class TopOpeBRep_VPointInterIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRep_VPointInterIterator self) -> TopOpeBRep_VPointInterIterator
        __init__(TopOpeBRep_VPointInterIterator self, TopOpeBRep_LineInter LI) -> TopOpeBRep_VPointInterIterator

        :type LI: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter

        """
        this = _TopOpeBRep.new_TopOpeBRep_VPointInterIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(TopOpeBRep_VPointInterIterator self, TopOpeBRep_LineInter LI, Standard_Boolean const checkkeep)
        Init(TopOpeBRep_VPointInterIterator self)

        :type LI: OCC.wrapper.TopOpeBRep.TopOpeBRep_LineInter
        :type checkkeep: bool

        """
        return _TopOpeBRep.TopOpeBRep_VPointInterIterator_Init(self, *args)


    def More(self, *args):
        """
        More(TopOpeBRep_VPointInterIterator self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRep.TopOpeBRep_VPointInterIterator_More(self, *args)


    def Next(self, *args):
        """Next(TopOpeBRep_VPointInterIterator self)"""
        return _TopOpeBRep.TopOpeBRep_VPointInterIterator_Next(self, *args)


    def CurrentVP(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter

        """
        res = _TopOpeBRep.TopOpeBRep_VPointInterIterator_CurrentVP(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CurrentVPIndex(self, *args):
        """
        CurrentVPIndex(TopOpeBRep_VPointInterIterator self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRep.TopOpeBRep_VPointInterIterator_CurrentVPIndex(self, *args)


    def ChangeCurrentVP(self, *args):
        """
        ChangeCurrentVP(TopOpeBRep_VPointInterIterator self) -> TopOpeBRep_VPointInter

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_VPointInter

        """
        return _TopOpeBRep.TopOpeBRep_VPointInterIterator_ChangeCurrentVP(self, *args)


    def PLineInterDummy(self, *args):
        """
        PLineInterDummy(TopOpeBRep_VPointInterIterator self) -> TopOpeBRep_LineInter

        :rtype: OCC.wrapper.TopOpeBRep.TopOpeBRep_PLineInter

        """
        return _TopOpeBRep.TopOpeBRep_VPointInterIterator_PLineInterDummy(self, *args)

    __swig_destroy__ = _TopOpeBRep.delete_TopOpeBRep_VPointInterIterator
TopOpeBRep_VPointInterIterator_swigregister = _TopOpeBRep.TopOpeBRep_VPointInterIterator_swigregister
TopOpeBRep_VPointInterIterator_swigregister(TopOpeBRep_VPointInterIterator)




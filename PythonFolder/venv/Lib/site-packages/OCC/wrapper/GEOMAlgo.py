# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_GEOMAlgo')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_GEOMAlgo')
    _GEOMAlgo = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_GEOMAlgo', [dirname(__file__)])
        except ImportError:
            import _GEOMAlgo
            return _GEOMAlgo
        try:
            _mod = imp.load_module('_GEOMAlgo', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _GEOMAlgo = swig_import_helper()
    del swig_import_helper
else:
    import _GEOMAlgo
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _GEOMAlgo.delete_SwigPyIterator

    def value(self):
        return _GEOMAlgo.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _GEOMAlgo.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _GEOMAlgo.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _GEOMAlgo.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _GEOMAlgo.SwigPyIterator_equal(self, x)

    def copy(self):
        return _GEOMAlgo.SwigPyIterator_copy(self)

    def next(self):
        return _GEOMAlgo.SwigPyIterator_next(self)

    def __next__(self):
        return _GEOMAlgo.SwigPyIterator___next__(self)

    def previous(self):
        return _GEOMAlgo.SwigPyIterator_previous(self)

    def advance(self, n):
        return _GEOMAlgo.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _GEOMAlgo.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _GEOMAlgo.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _GEOMAlgo.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _GEOMAlgo.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _GEOMAlgo.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _GEOMAlgo.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _GEOMAlgo.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _GEOMAlgo.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_GEOMAlgo.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _GEOMAlgo.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _GEOMAlgo.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GEOMAlgo.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _GEOMAlgo.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _GEOMAlgo.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _GEOMAlgo.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _GEOMAlgo.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_GEOMAlgo.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _GEOMAlgo.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _GEOMAlgo.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GEOMAlgo.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _GEOMAlgo.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _GEOMAlgo.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _GEOMAlgo.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _GEOMAlgo.ptr_to_number(item)
ptr_to_number = _GEOMAlgo.ptr_to_number

def HashCode(*args):
    return _GEOMAlgo.HashCode(*args)
HashCode = _GEOMAlgo.HashCode

def ptr_equal(a, b):
    return _GEOMAlgo.ptr_equal(a, b)
ptr_equal = _GEOMAlgo.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BOPAlgo
else:
    import BOPAlgo
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BOPTools
else:
    import BOPTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntTools
else:
    import IntTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAPI
else:
    import GeomAPI
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Approx
else:
    import Approx
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppCont
else:
    import AppCont
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppParCurves
else:
    import AppParCurves
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AdvApprox
else:
    import AdvApprox
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PLib
else:
    import PLib
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Extrema
else:
    import Extrema
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dHatch
else:
    import Geom2dHatch
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import HatchGen
else:
    import HatchGen
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntRes2d
else:
    import IntRes2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dInt
else:
    import Geom2dInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Intf
else:
    import Intf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurve
else:
    import IntCurve
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntPatch
else:
    import IntPatch
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntSurf
else:
    import IntSurf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntAna
else:
    import IntAna
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntWalk
else:
    import IntWalk
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntImp
else:
    import IntImp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepClass3d
else:
    import BRepClass3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurveSurface
else:
    import IntCurveSurface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurvesFace
else:
    import IntCurvesFace
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomInt
else:
    import GeomInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ApproxInt
else:
    import ApproxInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BOPDS
else:
    import BOPDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepTools
else:
    import BRepTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRep
else:
    import BRep
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepExtrema
else:
    import BRepExtrema
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BVH
else:
    import BVH
del _swig_python_version_info
GEOMAlgo_ST_UNKNOWN = _GEOMAlgo.GEOMAlgo_ST_UNKNOWN
GEOMAlgo_ST_IN = _GEOMAlgo.GEOMAlgo_ST_IN
GEOMAlgo_ST_OUT = _GEOMAlgo.GEOMAlgo_ST_OUT
GEOMAlgo_ST_ON = _GEOMAlgo.GEOMAlgo_ST_ON
GEOMAlgo_ST_ONIN = _GEOMAlgo.GEOMAlgo_ST_ONIN
GEOMAlgo_ST_ONOUT = _GEOMAlgo.GEOMAlgo_ST_ONOUT
GEOMAlgo_ST_INOUT = _GEOMAlgo.GEOMAlgo_ST_INOUT
GEOMAlgo_KD_UNKNOWN = _GEOMAlgo.GEOMAlgo_KD_UNKNOWN
GEOMAlgo_KD_SPECIFIED = _GEOMAlgo.GEOMAlgo_KD_SPECIFIED
GEOMAlgo_KD_ARBITRARY = _GEOMAlgo.GEOMAlgo_KD_ARBITRARY
GEOMAlgo_KS_UNKNOWN = _GEOMAlgo.GEOMAlgo_KS_UNKNOWN
GEOMAlgo_KS_SPHERE = _GEOMAlgo.GEOMAlgo_KS_SPHERE
GEOMAlgo_KS_CYLINDER = _GEOMAlgo.GEOMAlgo_KS_CYLINDER
GEOMAlgo_KS_BOX = _GEOMAlgo.GEOMAlgo_KS_BOX
GEOMAlgo_KS_TORUS = _GEOMAlgo.GEOMAlgo_KS_TORUS
GEOMAlgo_KS_CONE = _GEOMAlgo.GEOMAlgo_KS_CONE
GEOMAlgo_KS_ELLIPSE = _GEOMAlgo.GEOMAlgo_KS_ELLIPSE
GEOMAlgo_KS_PLANE = _GEOMAlgo.GEOMAlgo_KS_PLANE
GEOMAlgo_KS_CIRCLE = _GEOMAlgo.GEOMAlgo_KS_CIRCLE
GEOMAlgo_KS_LINE = _GEOMAlgo.GEOMAlgo_KS_LINE
GEOMAlgo_KS_DEGENERATED = _GEOMAlgo.GEOMAlgo_KS_DEGENERATED
GEOMAlgo_KS_BSPLINE = _GEOMAlgo.GEOMAlgo_KS_BSPLINE
GEOMAlgo_KN_UNKNOWN = _GEOMAlgo.GEOMAlgo_KN_UNKNOWN
GEOMAlgo_KN_SPHERE = _GEOMAlgo.GEOMAlgo_KN_SPHERE
GEOMAlgo_KN_CYLINDER = _GEOMAlgo.GEOMAlgo_KN_CYLINDER
GEOMAlgo_KN_TORUS = _GEOMAlgo.GEOMAlgo_KN_TORUS
GEOMAlgo_KN_CONE = _GEOMAlgo.GEOMAlgo_KN_CONE
GEOMAlgo_KN_ELLIPSE = _GEOMAlgo.GEOMAlgo_KN_ELLIPSE
GEOMAlgo_KN_CIRCLE = _GEOMAlgo.GEOMAlgo_KN_CIRCLE
GEOMAlgo_KN_PLANE = _GEOMAlgo.GEOMAlgo_KN_PLANE
GEOMAlgo_KN_LINE = _GEOMAlgo.GEOMAlgo_KN_LINE
GEOMAlgo_KN_BOX = _GEOMAlgo.GEOMAlgo_KN_BOX
GEOMAlgo_KN_SEGMENT = _GEOMAlgo.GEOMAlgo_KN_SEGMENT
GEOMAlgo_KN_ARCCIRCLE = _GEOMAlgo.GEOMAlgo_KN_ARCCIRCLE
GEOMAlgo_KN_POLYGON = _GEOMAlgo.GEOMAlgo_KN_POLYGON
GEOMAlgo_KN_POLYHEDRON = _GEOMAlgo.GEOMAlgo_KN_POLYHEDRON
GEOMAlgo_KN_DISKCIRCLE = _GEOMAlgo.GEOMAlgo_KN_DISKCIRCLE
GEOMAlgo_KN_DISKELLIPSE = _GEOMAlgo.GEOMAlgo_KN_DISKELLIPSE
GEOMAlgo_KN_RECTANGLE = _GEOMAlgo.GEOMAlgo_KN_RECTANGLE
GEOMAlgo_KN_TRIANGLE = _GEOMAlgo.GEOMAlgo_KN_TRIANGLE
GEOMAlgo_KN_QUADRANGLE = _GEOMAlgo.GEOMAlgo_KN_QUADRANGLE
GEOMAlgo_KN_ARCELLIPSE = _GEOMAlgo.GEOMAlgo_KN_ARCELLIPSE
GEOMAlgo_KN_SOLID = _GEOMAlgo.GEOMAlgo_KN_SOLID
GEOMAlgo_KB_UNKNOWN = _GEOMAlgo.GEOMAlgo_KB_UNKNOWN
GEOMAlgo_KB_TRIMMED = _GEOMAlgo.GEOMAlgo_KB_TRIMMED
GEOMAlgo_KB_INFINITE = _GEOMAlgo.GEOMAlgo_KB_INFINITE
GEOMAlgo_KC_UNKNOWN = _GEOMAlgo.GEOMAlgo_KC_UNKNOWN
GEOMAlgo_KC_CLOSED = _GEOMAlgo.GEOMAlgo_KC_CLOSED
GEOMAlgo_KC_NOTCLOSED = _GEOMAlgo.GEOMAlgo_KC_NOTCLOSED
class GEOMAlgo_Algo(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Perform(self, *args):
        """Perform(GEOMAlgo_Algo self)"""
        return _GEOMAlgo.GEOMAlgo_Algo_Perform(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(GEOMAlgo_Algo self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.GEOMAlgo_Algo_ErrorStatus(self, *args)


    def WarningStatus(self, *args):
        """
        WarningStatus(GEOMAlgo_Algo self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.GEOMAlgo_Algo_WarningStatus(self, *args)


    def ComputeInternalShapes(self, *args):
        """
        ComputeInternalShapes(GEOMAlgo_Algo self, Standard_Boolean const theFlag)

        Allows to omit of creation of internal shapes (manifold topology). <br>
        Needed for the SALOME/TRIPOLI module. <br>

        :type theFlag: bool

        """
        return _GEOMAlgo.GEOMAlgo_Algo_ComputeInternalShapes(self, *args)

GEOMAlgo_Algo_swigregister = _GEOMAlgo.GEOMAlgo_Algo_swigregister
GEOMAlgo_Algo_swigregister(GEOMAlgo_Algo)

class GEOMAlgo_ShapeAlgo(GEOMAlgo_Algo):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def SetContext(self, *args):
        """
        SetContext(GEOMAlgo_ShapeAlgo self, Handle_IntTools_Context theContext)

        Sets cashed geometrical tools <br>

        :type theContext: OCC.wrapper.IntTools.Handle_IntTools_Context

        """
        return _GEOMAlgo.GEOMAlgo_ShapeAlgo_SetContext(self, *args)


    def Context(self, *args):
        """
        Returns cashed geometrical tools <br>

        :rtype: OCC.wrapper.IntTools.Handle_IntTools_Context

        """
        res = _GEOMAlgo.GEOMAlgo_ShapeAlgo_Context(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetShape(self, *args):
        """
        SetShape(GEOMAlgo_ShapeAlgo self, TopoDS_Shape aS)

        :type aS: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _GEOMAlgo.GEOMAlgo_ShapeAlgo_SetShape(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(GEOMAlgo_ShapeAlgo self, Standard_Real const aT)

        :type aT: float

        """
        return _GEOMAlgo.GEOMAlgo_ShapeAlgo_SetTolerance(self, *args)


    def Shape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _GEOMAlgo.GEOMAlgo_ShapeAlgo_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tolerance(self, *args):
        """
        Tolerance(GEOMAlgo_ShapeAlgo self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GEOMAlgo.GEOMAlgo_ShapeAlgo_Tolerance(self, *args)


    def Result(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _GEOMAlgo.GEOMAlgo_ShapeAlgo_Result(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Perform(self, *args):
        """Perform(GEOMAlgo_ShapeAlgo self)"""
        return _GEOMAlgo.GEOMAlgo_ShapeAlgo_Perform(self, *args)

GEOMAlgo_ShapeAlgo_swigregister = _GEOMAlgo.GEOMAlgo_ShapeAlgo_swigregister
GEOMAlgo_ShapeAlgo_swigregister(GEOMAlgo_ShapeAlgo)

class GEOMAlgo_HAlgo(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GEOMAlgo_HAlgo
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GEOMAlgo_HAlgo(self) 
            return h


    def Perform(self, *args):
        """Perform(GEOMAlgo_HAlgo self)"""
        return _GEOMAlgo.GEOMAlgo_HAlgo_Perform(self, *args)


    def CheckData(self, *args):
        """CheckData(GEOMAlgo_HAlgo self)"""
        return _GEOMAlgo.GEOMAlgo_HAlgo_CheckData(self, *args)


    def CheckResult(self, *args):
        """CheckResult(GEOMAlgo_HAlgo self)"""
        return _GEOMAlgo.GEOMAlgo_HAlgo_CheckResult(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(GEOMAlgo_HAlgo self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.GEOMAlgo_HAlgo_ErrorStatus(self, *args)


    def WarningStatus(self, *args):
        """
        WarningStatus(GEOMAlgo_HAlgo self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.GEOMAlgo_HAlgo_WarningStatus(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GEOMAlgo.GEOMAlgo_HAlgo_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GEOMAlgo.GEOMAlgo_HAlgo_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GEOMAlgo.GEOMAlgo_HAlgo_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


GEOMAlgo_HAlgo_swigregister = _GEOMAlgo.GEOMAlgo_HAlgo_swigregister
GEOMAlgo_HAlgo_swigregister(GEOMAlgo_HAlgo)

def GEOMAlgo_HAlgo_get_type_name(*args):
    """
    GEOMAlgo_HAlgo_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GEOMAlgo.GEOMAlgo_HAlgo_get_type_name(*args)

def GEOMAlgo_HAlgo_get_type_descriptor(*args):
    """
    GEOMAlgo_HAlgo_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GEOMAlgo.GEOMAlgo_HAlgo_get_type_descriptor(*args)

class GEOMAlgo_Clsf(GEOMAlgo_HAlgo):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GEOMAlgo_Clsf
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GEOMAlgo_Clsf(self) 
            return h


    def SetPnt(self, *args):
        """
        SetPnt(GEOMAlgo_Clsf self, gp_Pnt aP)

        :type aP: OCC.wrapper.gp.gp_Pnt

        """
        return _GEOMAlgo.GEOMAlgo_Clsf_SetPnt(self, *args)


    def Pnt(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _GEOMAlgo.GEOMAlgo_Clsf_Pnt(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTolerance(self, *args):
        """
        SetTolerance(GEOMAlgo_Clsf self, Standard_Real const aT)

        :type aT: float

        """
        return _GEOMAlgo.GEOMAlgo_Clsf_SetTolerance(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(GEOMAlgo_Clsf self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GEOMAlgo.GEOMAlgo_Clsf_Tolerance(self, *args)


    def State(self, *args):
        """
        State(GEOMAlgo_Clsf self) -> TopAbs_State

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _GEOMAlgo.GEOMAlgo_Clsf_State(self, *args)


    def CanBeON(self, *args):
        """
        CanBeON(GEOMAlgo_Clsf self, Handle_Geom_Curve aCT) -> Standard_Boolean
        CanBeON(GEOMAlgo_Clsf self, Handle_Geom_Surface aST) -> Standard_Boolean

        :type aST: OCC.wrapper.Geom.Handle_Geom_Surface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_Clsf_CanBeON(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GEOMAlgo.GEOMAlgo_Clsf_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GEOMAlgo.GEOMAlgo_Clsf_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GEOMAlgo.GEOMAlgo_Clsf_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


GEOMAlgo_Clsf_swigregister = _GEOMAlgo.GEOMAlgo_Clsf_swigregister
GEOMAlgo_Clsf_swigregister(GEOMAlgo_Clsf)

def GEOMAlgo_Clsf_get_type_name(*args):
    """
    GEOMAlgo_Clsf_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GEOMAlgo.GEOMAlgo_Clsf_get_type_name(*args)

def GEOMAlgo_Clsf_get_type_descriptor(*args):
    """
    GEOMAlgo_Clsf_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GEOMAlgo.GEOMAlgo_Clsf_get_type_descriptor(*args)

class GEOMAlgo_BndSphere(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(GEOMAlgo_BndSphere self) -> GEOMAlgo_BndSphere"""
        this = _GEOMAlgo.new_GEOMAlgo_BndSphere(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsOut(self, *args):
        """
        IsOut(GEOMAlgo_BndSphere self, GEOMAlgo_BndSphere theOther) -> Standard_Boolean

        :type theOther: OCC.wrapper.GEOMAlgo.GEOMAlgo_BndSphere
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_BndSphere_IsOut(self, *args)

    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_BndSphere
GEOMAlgo_BndSphere_swigregister = _GEOMAlgo.GEOMAlgo_BndSphere_swigregister
GEOMAlgo_BndSphere_swigregister(GEOMAlgo_BndSphere)

class GEOMAlgo_PassKeyMapHasher(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args):
        """
        HashCode(GEOMAlgo_PassKey aPKey, Standard_Integer const Upper) -> Standard_Integer

        :type aPKey: OCC.wrapper.GEOMAlgo.GEOMAlgo_PassKey
        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.GEOMAlgo_PassKeyMapHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(GEOMAlgo_PassKey aPKey1, GEOMAlgo_PassKey aPKey2) -> Standard_Boolean

        :type aPKey1: OCC.wrapper.GEOMAlgo.GEOMAlgo_PassKey
        :type aPKey2: OCC.wrapper.GEOMAlgo.GEOMAlgo_PassKey
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_PassKeyMapHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def __init__(self):
        this = _GEOMAlgo.new_GEOMAlgo_PassKeyMapHasher()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_PassKeyMapHasher
GEOMAlgo_PassKeyMapHasher_swigregister = _GEOMAlgo.GEOMAlgo_PassKeyMapHasher_swigregister
GEOMAlgo_PassKeyMapHasher_swigregister(GEOMAlgo_PassKeyMapHasher)

def GEOMAlgo_PassKeyMapHasher_HashCode(*args):
    """
    GEOMAlgo_PassKeyMapHasher_HashCode(GEOMAlgo_PassKey aPKey, Standard_Integer const Upper) -> Standard_Integer

    :type aPKey: OCC.wrapper.GEOMAlgo.GEOMAlgo_PassKey
    :type Upper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _GEOMAlgo.GEOMAlgo_PassKeyMapHasher_HashCode(*args)

def GEOMAlgo_PassKeyMapHasher_IsEqual(*args):
    """
    GEOMAlgo_PassKeyMapHasher_IsEqual(GEOMAlgo_PassKey aPKey1, GEOMAlgo_PassKey aPKey2) -> Standard_Boolean

    :type aPKey1: OCC.wrapper.GEOMAlgo.GEOMAlgo_PassKey
    :type aPKey2: OCC.wrapper.GEOMAlgo.GEOMAlgo_PassKey
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _GEOMAlgo.GEOMAlgo_PassKeyMapHasher_IsEqual(*args)

class GEOMAlgo_CoupleOfShapes(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(GEOMAlgo_CoupleOfShapes self) -> GEOMAlgo_CoupleOfShapes"""
        this = _GEOMAlgo.new_GEOMAlgo_CoupleOfShapes(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetShapes(self, *args):
        """
        SetShapes(GEOMAlgo_CoupleOfShapes self, TopoDS_Shape aS1, TopoDS_Shape aS2)

        :type aS1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aS2: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _GEOMAlgo.GEOMAlgo_CoupleOfShapes_SetShapes(self, *args)


    def SetShape1(self, *args):
        """
        SetShape1(GEOMAlgo_CoupleOfShapes self, TopoDS_Shape aS1)

        :type aS1: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _GEOMAlgo.GEOMAlgo_CoupleOfShapes_SetShape1(self, *args)


    def SetShape2(self, *args):
        """
        SetShape2(GEOMAlgo_CoupleOfShapes self, TopoDS_Shape aS2)

        :type aS2: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _GEOMAlgo.GEOMAlgo_CoupleOfShapes_SetShape2(self, *args)


    def Shapes(self, *args):
        """
        Shapes(GEOMAlgo_CoupleOfShapes self, TopoDS_Shape aS1, TopoDS_Shape aS2)

        :type aS1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aS2: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _GEOMAlgo.GEOMAlgo_CoupleOfShapes_Shapes(self, *args)


    def Shape1(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _GEOMAlgo.GEOMAlgo_CoupleOfShapes_Shape1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shape2(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _GEOMAlgo.GEOMAlgo_CoupleOfShapes_Shape2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_CoupleOfShapes
GEOMAlgo_CoupleOfShapes_swigregister = _GEOMAlgo.GEOMAlgo_CoupleOfShapes_swigregister
GEOMAlgo_CoupleOfShapes_swigregister(GEOMAlgo_CoupleOfShapes)

class GEOMAlgo_PassKeyShape(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GEOMAlgo_PassKeyShape self) -> GEOMAlgo_PassKeyShape
        __init__(GEOMAlgo_PassKeyShape self, GEOMAlgo_PassKeyShape Other) -> GEOMAlgo_PassKeyShape

        :type Other: OCC.wrapper.GEOMAlgo.GEOMAlgo_PassKeyShape

        """
        this = _GEOMAlgo.new_GEOMAlgo_PassKeyShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Assign(self, *args):
        """
        Assign(GEOMAlgo_PassKeyShape self, GEOMAlgo_PassKeyShape Other) -> GEOMAlgo_PassKeyShape

        :type Other: OCC.wrapper.GEOMAlgo.GEOMAlgo_PassKeyShape
        :rtype: OCC.wrapper.GEOMAlgo.GEOMAlgo_PassKeyShape

        """
        return _GEOMAlgo.GEOMAlgo_PassKeyShape_Assign(self, *args)


    def assign(self, *args):
        """
        assign(GEOMAlgo_PassKeyShape self, GEOMAlgo_PassKeyShape Other) -> GEOMAlgo_PassKeyShape

        :type Other: OCC.wrapper.GEOMAlgo.GEOMAlgo_PassKeyShape
        :rtype: OCC.wrapper.GEOMAlgo.GEOMAlgo_PassKeyShape

        """
        return _GEOMAlgo.GEOMAlgo_PassKeyShape_assign(self, *args)


    def SetShapes(self, *args):
        """
        SetShapes(GEOMAlgo_PassKeyShape self, TopoDS_Shape aS)
        SetShapes(GEOMAlgo_PassKeyShape self, TopoDS_Shape aS1, TopoDS_Shape aS2)
        SetShapes(GEOMAlgo_PassKeyShape self, TopoDS_Shape aS1, TopoDS_Shape aS2, TopoDS_Shape aS3)
        SetShapes(GEOMAlgo_PassKeyShape self, TopoDS_Shape aS1, TopoDS_Shape aS2, TopoDS_Shape aS3, TopoDS_Shape aS4)
        SetShapes(GEOMAlgo_PassKeyShape self, NCollection_List_TopoDS_Shape aLS)

        :type aLS: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _GEOMAlgo.GEOMAlgo_PassKeyShape_SetShapes(self, *args)


    def Clear(self, *args):
        """Clear(GEOMAlgo_PassKeyShape self)"""
        return _GEOMAlgo.GEOMAlgo_PassKeyShape_Clear(self, *args)


    def NbIds(self, *args):
        """
        NbIds(GEOMAlgo_PassKeyShape self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.GEOMAlgo_PassKeyShape_NbIds(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(GEOMAlgo_PassKeyShape self, GEOMAlgo_PassKeyShape aOther) -> Standard_Boolean

        :type aOther: OCC.wrapper.GEOMAlgo.GEOMAlgo_PassKeyShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_PassKeyShape_IsEqual(self, *args)


    def HashCode(self, *args):
        """
        HashCode(GEOMAlgo_PassKeyShape self, Standard_Integer const Upper) -> Standard_Integer

        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.GEOMAlgo_PassKeyShape_HashCode(self, *args)


    def __hash__(self, *args):
        """
        __hash__(GEOMAlgo_PassKeyShape self) -> Standard_Integer

        Returns the a hashcode based on the HashCode method, suitable for a python __hash__

        :rtype: int
        """
        return _GEOMAlgo.GEOMAlgo_PassKeyShape___hash__(self, *args)


    def Dump(self, *args):
        """
        Dump(GEOMAlgo_PassKeyShape self, Standard_Integer const aHex=0)

        :type aHex: int

        """
        return _GEOMAlgo.GEOMAlgo_PassKeyShape_Dump(self, *args)

    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_PassKeyShape
GEOMAlgo_PassKeyShape_swigregister = _GEOMAlgo.GEOMAlgo_PassKeyShape_swigregister
GEOMAlgo_PassKeyShape_swigregister(GEOMAlgo_PassKeyShape)

class GEOMAlgo_GluerAlgo(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(GEOMAlgo_GluerAlgo self) -> GEOMAlgo_GluerAlgo"""
        this = _GEOMAlgo.new_GEOMAlgo_GluerAlgo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetArgument(self, *args):
        """
        SetArgument(GEOMAlgo_GluerAlgo self, TopoDS_Shape theShape)

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _GEOMAlgo.GEOMAlgo_GluerAlgo_SetArgument(self, *args)


    def Argument(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _GEOMAlgo.GEOMAlgo_GluerAlgo_Argument(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTolerance(self, *args):
        """
        SetTolerance(GEOMAlgo_GluerAlgo self, Standard_Real const aT)

        :type aT: float

        """
        return _GEOMAlgo.GEOMAlgo_GluerAlgo_SetTolerance(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(GEOMAlgo_GluerAlgo self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GEOMAlgo.GEOMAlgo_GluerAlgo_Tolerance(self, *args)


    def SetCheckGeometry(self, *args):
        """
        SetCheckGeometry(GEOMAlgo_GluerAlgo self, Standard_Boolean const aFlag)

        :type aFlag: bool

        """
        return _GEOMAlgo.GEOMAlgo_GluerAlgo_SetCheckGeometry(self, *args)


    def CheckGeometry(self, *args):
        """
        CheckGeometry(GEOMAlgo_GluerAlgo self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_GluerAlgo_CheckGeometry(self, *args)


    def Perform(self, *args):
        """Perform(GEOMAlgo_GluerAlgo self)"""
        return _GEOMAlgo.GEOMAlgo_GluerAlgo_Perform(self, *args)


    def Clear(self, *args):
        """Clear(GEOMAlgo_GluerAlgo self)"""
        return _GEOMAlgo.GEOMAlgo_GluerAlgo_Clear(self, *args)


    def SetContext(self, *args):
        """
        SetContext(GEOMAlgo_GluerAlgo self, Handle_IntTools_Context arg2)

        :type : OCC.wrapper.IntTools.Handle_IntTools_Context

        """
        return _GEOMAlgo.GEOMAlgo_GluerAlgo_SetContext(self, *args)


    def Context(self, *args):
        """
        :rtype: OCC.wrapper.IntTools.Handle_IntTools_Context

        """
        res = _GEOMAlgo.GEOMAlgo_GluerAlgo_Context(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Images(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape

        """
        res = _GEOMAlgo.GEOMAlgo_GluerAlgo_Images(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Origins(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape

        """
        res = _GEOMAlgo.GEOMAlgo_GluerAlgo_Origins(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_GluerAlgo
GEOMAlgo_GluerAlgo_swigregister = _GEOMAlgo.GEOMAlgo_GluerAlgo_swigregister
GEOMAlgo_GluerAlgo_swigregister(GEOMAlgo_GluerAlgo)

class GEOMAlgo_ClsfQuad(GEOMAlgo_Clsf):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GEOMAlgo_ClsfQuad
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GEOMAlgo_ClsfQuad(self) 
            return h


    def __init__(self, *args):
        """__init__(GEOMAlgo_ClsfQuad self) -> GEOMAlgo_ClsfQuad"""
        this = _GEOMAlgo.new_GEOMAlgo_ClsfQuad(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetCorners(self, *args):
        """
        SetCorners(GEOMAlgo_ClsfQuad self, gp_Pnt theTopLeftPoint, gp_Pnt theTopRightPoint, gp_Pnt theBottomLeftPoint, gp_Pnt theBottomRightPoint)

        :type theTopLeftPoint: OCC.wrapper.gp.gp_Pnt
        :type theTopRightPoint: OCC.wrapper.gp.gp_Pnt
        :type theBottomLeftPoint: OCC.wrapper.gp.gp_Pnt
        :type theBottomRightPoint: OCC.wrapper.gp.gp_Pnt

        """
        return _GEOMAlgo.GEOMAlgo_ClsfQuad_SetCorners(self, *args)


    def GetCorners(self, *args):
        """
        GetCorners(GEOMAlgo_ClsfQuad self, gp_Pnt theTopLeftPoint, gp_Pnt theTopRightPoint, gp_Pnt theBottomLeftPoint, gp_Pnt theBottomRightPoint)

        :type theTopLeftPoint: OCC.wrapper.gp.gp_Pnt
        :type theTopRightPoint: OCC.wrapper.gp.gp_Pnt
        :type theBottomLeftPoint: OCC.wrapper.gp.gp_Pnt
        :type theBottomRightPoint: OCC.wrapper.gp.gp_Pnt

        """
        return _GEOMAlgo.GEOMAlgo_ClsfQuad_GetCorners(self, *args)


    def Perform(self, *args):
        """Perform(GEOMAlgo_ClsfQuad self)"""
        return _GEOMAlgo.GEOMAlgo_ClsfQuad_Perform(self, *args)


    def CheckData(self, *args):
        """CheckData(GEOMAlgo_ClsfQuad self)"""
        return _GEOMAlgo.GEOMAlgo_ClsfQuad_CheckData(self, *args)


    def CanBeON(self, *args):
        """
        CanBeON(GEOMAlgo_ClsfQuad self, Handle_Geom_Curve aC) -> Standard_Boolean
        CanBeON(GEOMAlgo_ClsfQuad self, Handle_Geom_Surface aST) -> Standard_Boolean

        :type aST: OCC.wrapper.Geom.Handle_Geom_Surface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_ClsfQuad_CanBeON(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GEOMAlgo.GEOMAlgo_ClsfQuad_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GEOMAlgo.GEOMAlgo_ClsfQuad_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GEOMAlgo.GEOMAlgo_ClsfQuad_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_ClsfQuad
GEOMAlgo_ClsfQuad_swigregister = _GEOMAlgo.GEOMAlgo_ClsfQuad_swigregister
GEOMAlgo_ClsfQuad_swigregister(GEOMAlgo_ClsfQuad)

def GEOMAlgo_ClsfQuad_get_type_name(*args):
    """
    GEOMAlgo_ClsfQuad_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GEOMAlgo.GEOMAlgo_ClsfQuad_get_type_name(*args)

def GEOMAlgo_ClsfQuad_get_type_descriptor(*args):
    """
    GEOMAlgo_ClsfQuad_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GEOMAlgo.GEOMAlgo_ClsfQuad_get_type_descriptor(*args)

class GEOMAlgo_ClsfSurf(GEOMAlgo_Clsf):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GEOMAlgo_ClsfSurf
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GEOMAlgo_ClsfSurf(self) 
            return h


    def __init__(self, *args):
        """__init__(GEOMAlgo_ClsfSurf self) -> GEOMAlgo_ClsfSurf"""
        this = _GEOMAlgo.new_GEOMAlgo_ClsfSurf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetSurface(self, *args):
        """
        SetSurface(GEOMAlgo_ClsfSurf self, Handle_Geom_Surface aS)

        :type aS: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _GEOMAlgo.GEOMAlgo_ClsfSurf_SetSurface(self, *args)


    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _GEOMAlgo.GEOMAlgo_ClsfSurf_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Perform(self, *args):
        """Perform(GEOMAlgo_ClsfSurf self)"""
        return _GEOMAlgo.GEOMAlgo_ClsfSurf_Perform(self, *args)


    def CheckData(self, *args):
        """CheckData(GEOMAlgo_ClsfSurf self)"""
        return _GEOMAlgo.GEOMAlgo_ClsfSurf_CheckData(self, *args)


    def CanBeON(self, *args):
        """
        CanBeON(GEOMAlgo_ClsfSurf self, Handle_Geom_Curve aC) -> Standard_Boolean
        CanBeON(GEOMAlgo_ClsfSurf self, Handle_Geom_Surface aST) -> Standard_Boolean

        :type aST: OCC.wrapper.Geom.Handle_Geom_Surface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_ClsfSurf_CanBeON(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GEOMAlgo.GEOMAlgo_ClsfSurf_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GEOMAlgo.GEOMAlgo_ClsfSurf_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GEOMAlgo.GEOMAlgo_ClsfSurf_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_ClsfSurf
GEOMAlgo_ClsfSurf_swigregister = _GEOMAlgo.GEOMAlgo_ClsfSurf_swigregister
GEOMAlgo_ClsfSurf_swigregister(GEOMAlgo_ClsfSurf)

def GEOMAlgo_ClsfSurf_get_type_name(*args):
    """
    GEOMAlgo_ClsfSurf_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GEOMAlgo.GEOMAlgo_ClsfSurf_get_type_name(*args)

def GEOMAlgo_ClsfSurf_get_type_descriptor(*args):
    """
    GEOMAlgo_ClsfSurf_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GEOMAlgo.GEOMAlgo_ClsfSurf_get_type_descriptor(*args)

class GEOMAlgo_PassKeyShapeMapHasher(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args):
        """
        HashCode(GEOMAlgo_PassKeyShape aPKey, Standard_Integer const Upper) -> Standard_Integer

        :type aPKey: OCC.wrapper.GEOMAlgo.GEOMAlgo_PassKeyShape
        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.GEOMAlgo_PassKeyShapeMapHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(GEOMAlgo_PassKeyShape aPKey1, GEOMAlgo_PassKeyShape aPKey2) -> Standard_Boolean

        :type aPKey1: OCC.wrapper.GEOMAlgo.GEOMAlgo_PassKeyShape
        :type aPKey2: OCC.wrapper.GEOMAlgo.GEOMAlgo_PassKeyShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_PassKeyShapeMapHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def __init__(self):
        this = _GEOMAlgo.new_GEOMAlgo_PassKeyShapeMapHasher()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_PassKeyShapeMapHasher
GEOMAlgo_PassKeyShapeMapHasher_swigregister = _GEOMAlgo.GEOMAlgo_PassKeyShapeMapHasher_swigregister
GEOMAlgo_PassKeyShapeMapHasher_swigregister(GEOMAlgo_PassKeyShapeMapHasher)

def GEOMAlgo_PassKeyShapeMapHasher_HashCode(*args):
    """
    GEOMAlgo_PassKeyShapeMapHasher_HashCode(GEOMAlgo_PassKeyShape aPKey, Standard_Integer const Upper) -> Standard_Integer

    :type aPKey: OCC.wrapper.GEOMAlgo.GEOMAlgo_PassKeyShape
    :type Upper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _GEOMAlgo.GEOMAlgo_PassKeyShapeMapHasher_HashCode(*args)

def GEOMAlgo_PassKeyShapeMapHasher_IsEqual(*args):
    """
    GEOMAlgo_PassKeyShapeMapHasher_IsEqual(GEOMAlgo_PassKeyShape aPKey1, GEOMAlgo_PassKeyShape aPKey2) -> Standard_Boolean

    :type aPKey1: OCC.wrapper.GEOMAlgo.GEOMAlgo_PassKeyShape
    :type aPKey2: OCC.wrapper.GEOMAlgo.GEOMAlgo_PassKeyShape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _GEOMAlgo.GEOMAlgo_PassKeyShapeMapHasher_IsEqual(*args)

class GEOMAlgo_PassKey(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GEOMAlgo_PassKey self) -> GEOMAlgo_PassKey
        __init__(GEOMAlgo_PassKey self, GEOMAlgo_PassKey Other) -> GEOMAlgo_PassKey

        :type Other: OCC.wrapper.GEOMAlgo.GEOMAlgo_PassKey

        """
        this = _GEOMAlgo.new_GEOMAlgo_PassKey(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Assign(self, *args):
        """
        Assign(GEOMAlgo_PassKey self, GEOMAlgo_PassKey Other) -> GEOMAlgo_PassKey

        :type Other: OCC.wrapper.GEOMAlgo.GEOMAlgo_PassKey
        :rtype: OCC.wrapper.GEOMAlgo.GEOMAlgo_PassKey

        """
        return _GEOMAlgo.GEOMAlgo_PassKey_Assign(self, *args)


    def assign(self, *args):
        """
        assign(GEOMAlgo_PassKey self, GEOMAlgo_PassKey Other) -> GEOMAlgo_PassKey

        :type Other: OCC.wrapper.GEOMAlgo.GEOMAlgo_PassKey
        :rtype: OCC.wrapper.GEOMAlgo.GEOMAlgo_PassKey

        """
        return _GEOMAlgo.GEOMAlgo_PassKey_assign(self, *args)


    def Clear(self, *args):
        """Clear(GEOMAlgo_PassKey self)"""
        return _GEOMAlgo.GEOMAlgo_PassKey_Clear(self, *args)


    def SetIds(self, *args):
        """
        SetIds(GEOMAlgo_PassKey self, Standard_Integer const aI1)
        SetIds(GEOMAlgo_PassKey self, Standard_Integer const aI1, Standard_Integer const aI2)
        SetIds(GEOMAlgo_PassKey self, Standard_Integer const aI1, Standard_Integer const aI2, Standard_Integer const aI3)
        SetIds(GEOMAlgo_PassKey self, Standard_Integer const aI1, Standard_Integer const aI2, Standard_Integer const aI3, Standard_Integer const aI4)
        SetIds(GEOMAlgo_PassKey self, NCollection_List_Standard_Integer aLS)

        :type aLS: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        return _GEOMAlgo.GEOMAlgo_PassKey_SetIds(self, *args)


    def NbIds(self, *args):
        """
        NbIds(GEOMAlgo_PassKey self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.GEOMAlgo_PassKey_NbIds(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(GEOMAlgo_PassKey self, GEOMAlgo_PassKey aOther) -> Standard_Boolean

        :type aOther: OCC.wrapper.GEOMAlgo.GEOMAlgo_PassKey
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_PassKey_IsEqual(self, *args)


    def HashCode(self, *args):
        """
        HashCode(GEOMAlgo_PassKey self, Standard_Integer const Upper) -> Standard_Integer

        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.GEOMAlgo_PassKey_HashCode(self, *args)


    def __hash__(self, *args):
        """
        __hash__(GEOMAlgo_PassKey self) -> Standard_Integer

        Returns the a hashcode based on the HashCode method, suitable for a python __hash__

        :rtype: int
        """
        return _GEOMAlgo.GEOMAlgo_PassKey___hash__(self, *args)


    def Id(self, *args):
        """
        Id(GEOMAlgo_PassKey self, Standard_Integer const aIndex) -> Standard_Integer

        :type aIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.GEOMAlgo_PassKey_Id(self, *args)


    def Dump(self, *args):
        """
        Dump(GEOMAlgo_PassKey self, Standard_Integer const aHex=0)

        :type aHex: int

        """
        return _GEOMAlgo.GEOMAlgo_PassKey_Dump(self, *args)

    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_PassKey
GEOMAlgo_PassKey_swigregister = _GEOMAlgo.GEOMAlgo_PassKey_swigregister
GEOMAlgo_PassKey_swigregister(GEOMAlgo_PassKey)

class GEOMAlgo_ShapeSolid(GEOMAlgo_Algo):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def SetFiller(self, *args):
        """
        SetFiller(GEOMAlgo_ShapeSolid self, BOPAlgo_PaveFiller aDSF)

        :type aDSF: OCC.wrapper.BOPAlgo.BOPAlgo_PaveFiller

        """
        return _GEOMAlgo.GEOMAlgo_ShapeSolid_SetFiller(self, *args)


    def Shapes(self, *args):
        """
        :type aState: OCC.wrapper.TopAbs.TopAbs_State
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _GEOMAlgo.GEOMAlgo_ShapeSolid_Shapes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_ShapeSolid
GEOMAlgo_ShapeSolid_swigregister = _GEOMAlgo.GEOMAlgo_ShapeSolid_swigregister
GEOMAlgo_ShapeSolid_swigregister(GEOMAlgo_ShapeSolid)

class GEOMAlgo_ClsfBox(GEOMAlgo_Clsf):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GEOMAlgo_ClsfBox
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GEOMAlgo_ClsfBox(self) 
            return h


    def __init__(self, *args):
        """__init__(GEOMAlgo_ClsfBox self) -> GEOMAlgo_ClsfBox"""
        this = _GEOMAlgo.new_GEOMAlgo_ClsfBox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetBox(self, *args):
        """
        SetBox(GEOMAlgo_ClsfBox self, TopoDS_Shape aS)

        :type aS: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _GEOMAlgo.GEOMAlgo_ClsfBox_SetBox(self, *args)


    def Box(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _GEOMAlgo.GEOMAlgo_ClsfBox_Box(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Perform(self, *args):
        """Perform(GEOMAlgo_ClsfBox self)"""
        return _GEOMAlgo.GEOMAlgo_ClsfBox_Perform(self, *args)


    def CheckData(self, *args):
        """CheckData(GEOMAlgo_ClsfBox self)"""
        return _GEOMAlgo.GEOMAlgo_ClsfBox_CheckData(self, *args)


    def CanBeON(self, *args):
        """
        CanBeON(GEOMAlgo_ClsfBox self, Handle_Geom_Curve aC) -> Standard_Boolean
        CanBeON(GEOMAlgo_ClsfBox self, Handle_Geom_Surface aST) -> Standard_Boolean

        :type aST: OCC.wrapper.Geom.Handle_Geom_Surface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_ClsfBox_CanBeON(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GEOMAlgo.GEOMAlgo_ClsfBox_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GEOMAlgo.GEOMAlgo_ClsfBox_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GEOMAlgo.GEOMAlgo_ClsfBox_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_ClsfBox
GEOMAlgo_ClsfBox_swigregister = _GEOMAlgo.GEOMAlgo_ClsfBox_swigregister
GEOMAlgo_ClsfBox_swigregister(GEOMAlgo_ClsfBox)

def GEOMAlgo_ClsfBox_get_type_name(*args):
    """
    GEOMAlgo_ClsfBox_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GEOMAlgo.GEOMAlgo_ClsfBox_get_type_name(*args)

def GEOMAlgo_ClsfBox_get_type_descriptor(*args):
    """
    GEOMAlgo_ClsfBox_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GEOMAlgo.GEOMAlgo_ClsfBox_get_type_descriptor(*args)

class GEOMAlgo_ShapeInfoFiller(GEOMAlgo_Algo):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(GEOMAlgo_ShapeInfoFiller self) -> GEOMAlgo_ShapeInfoFiller"""
        this = _GEOMAlgo.new_GEOMAlgo_ShapeInfoFiller(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetShape(self, *args):
        """
        SetShape(GEOMAlgo_ShapeInfoFiller self, TopoDS_Shape aS)

        :type aS: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfoFiller_SetShape(self, *args)


    def Shape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _GEOMAlgo.GEOMAlgo_ShapeInfoFiller_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTolerance(self, *args):
        """
        SetTolerance(GEOMAlgo_ShapeInfoFiller self, Standard_Real const aT)

        :type aT: float

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfoFiller_SetTolerance(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(GEOMAlgo_ShapeInfoFiller self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfoFiller_Tolerance(self, *args)


    def Info(self, *args):
        """
        :type aS: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.GEOMAlgo.GEOMAlgo_ShapeInfo

        """
        res = _GEOMAlgo.GEOMAlgo_ShapeInfoFiller_Info(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Perform(self, *args):
        """Perform(GEOMAlgo_ShapeInfoFiller self)"""
        return _GEOMAlgo.GEOMAlgo_ShapeInfoFiller_Perform(self, *args)

    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_ShapeInfoFiller
GEOMAlgo_ShapeInfoFiller_swigregister = _GEOMAlgo.GEOMAlgo_ShapeInfoFiller_swigregister
GEOMAlgo_ShapeInfoFiller_swigregister(GEOMAlgo_ShapeInfoFiller)

class GEOMAlgo_StateCollector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(GEOMAlgo_StateCollector self) -> GEOMAlgo_StateCollector"""
        this = _GEOMAlgo.new_GEOMAlgo_StateCollector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AppendState(self, *args):
        """
        AppendState(GEOMAlgo_StateCollector self, TopAbs_State const aSt) -> Standard_Boolean

        :type aSt: OCC.wrapper.TopAbs.TopAbs_State
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_StateCollector_AppendState(self, *args)


    def State(self, *args):
        """
        State(GEOMAlgo_StateCollector self) -> TopAbs_State

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _GEOMAlgo.GEOMAlgo_StateCollector_State(self, *args)

    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_StateCollector
GEOMAlgo_StateCollector_swigregister = _GEOMAlgo.GEOMAlgo_StateCollector_swigregister
GEOMAlgo_StateCollector_swigregister(GEOMAlgo_StateCollector)

class NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,GEOMAlgo_BndSphere,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,GEOMAlgo_BndSphere,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,GEOMAlgo_BndSphere,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,GEOMAlgo_BndSphere,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _GEOMAlgo.new_NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1, GEOMAlgo_BndSphere theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher self, Standard_Integer const theIndex, TopoDS_Shape theKey1, GEOMAlgo_BndSphere theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher self)

        RemoveLast


        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher self, Standard_Integer const theIndex) -> GEOMAlgo_BndSphere

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> GEOMAlgo_BndSphere

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> GEOMAlgo_BndSphere

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> GEOMAlgo_BndSphere

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _GEOMAlgo.delete_NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher
NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_swigregister = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher)

class NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _GEOMAlgo.new_NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GEOMAlgo.delete_NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher_IteratorHelper)


try:
	GEOMAlgo_IndexedDataMapOfShapeBndSphere = NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_BndSphere_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher self) -> NCollection_DataMap< GEOMAlgo_PassKey,Standard_Integer,GEOMAlgo_PassKeyMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _GEOMAlgo.NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher self) -> NCollection_DataMap< GEOMAlgo_PassKey,Standard_Integer,GEOMAlgo_PassKeyMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _GEOMAlgo.NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher self) -> NCollection_DataMap< GEOMAlgo_PassKey,Standard_Integer,GEOMAlgo_PassKeyMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _GEOMAlgo.NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher self) -> NCollection_DataMap< GEOMAlgo_PassKey,Standard_Integer,GEOMAlgo_PassKeyMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _GEOMAlgo.NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _GEOMAlgo.new_NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher self, NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _GEOMAlgo.NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher self, NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher theOther) -> NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _GEOMAlgo.NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher self, NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher theOther) -> NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _GEOMAlgo.NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _GEOMAlgo.NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher self, GEOMAlgo_PassKey theKey, int const & theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher self, GEOMAlgo_PassKey theKey, int const & theItem) -> int *

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _GEOMAlgo.NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher self, GEOMAlgo_PassKey theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher self, GEOMAlgo_PassKey theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher self, GEOMAlgo_PassKey theKey) -> int const *

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _GEOMAlgo.NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher self, GEOMAlgo_PassKey theKey) -> int *

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _GEOMAlgo.NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher self, GEOMAlgo_PassKey theKey) -> int &

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _GEOMAlgo.NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _GEOMAlgo.NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_Size(self, *args)


    def __iter__(self):
        return _GEOMAlgo.NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher___iter__(self)
    __swig_destroy__ = _GEOMAlgo.delete_NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher
NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_swigregister = _GEOMAlgo.NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_swigregister
NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_swigregister(NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher)

class NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _GEOMAlgo.new_NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GEOMAlgo.delete_NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_IteratorHelper

    def __next__(self):
        return _GEOMAlgo.NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_IteratorHelper_swigregister = _GEOMAlgo.NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_IteratorHelper_swigregister
NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_IteratorHelper_swigregister(NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher_IteratorHelper)


try:
	GEOMAlgo_DataMapOfPassKeyInteger = NCollection_DataMap_GEOMAlgo_PassKey_Standard_Integer_GEOMAlgo_PassKeyMapHasher
except NameError:
	pass # does not exist, probably ignored

class GEOMAlgo_Extractor(GEOMAlgo_Algo):
    """
    rief This class encapsulates an algorithm of extraction of sub-shapes
    from the main shape.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GEOMAlgo_Extractor self) -> GEOMAlgo_Extractor

        rief Empty constructor.


        """
        this = _GEOMAlgo.new_GEOMAlgo_Extractor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetShape(self, *args):
        """
        SetShape(GEOMAlgo_Extractor self, TopoDS_Shape theShape)

        rief This method sets the main shape.

        \param theShape the main shape.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _GEOMAlgo.GEOMAlgo_Extractor_SetShape(self, *args)


    def GetShape(self, *args):
        """
        \brief This method returns the main shape.

        \return the main shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _GEOMAlgo.GEOMAlgo_Extractor_GetShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetShapesToRemove(self, *args):
        """
        SetShapesToRemove(GEOMAlgo_Extractor self, NCollection_List_TopoDS_Shape theSubShapes)

        rief This method sets the list of sub-shapes to be removed
        from the main shape.

        \param theSubShapes the sub-shapes to be removed.

        :type theSubShapes: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _GEOMAlgo.GEOMAlgo_Extractor_SetShapesToRemove(self, *args)


    def GetShapesToRemove(self, *args):
        """
        \brief This method returns the list of sub-shapes to be removed
        from the main shape.

        \return the list of sub-shapes to be removed.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _GEOMAlgo.GEOMAlgo_Extractor_GetShapesToRemove(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Perform(self, *args):
        """
        Perform(GEOMAlgo_Extractor self)

        This method performs computation of the extracted shape.


        """
        return _GEOMAlgo.GEOMAlgo_Extractor_Perform(self, *args)


    def GetResult(self, *args):
        """
        This method returns the result of the algorithm.

        \return the result of the operation.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _GEOMAlgo.GEOMAlgo_Extractor_GetResult(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetRemoved(self, *args):
        """
        \brief This method returns the sub-shapes removed from the main shape.

        \return the list of removed sub-shapes.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _GEOMAlgo.GEOMAlgo_Extractor_GetRemoved(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetModified(self, *args):
        """
        \brief This method returns the sub-shapes modified in the main shape.

        \return the list of modified sub-shapes.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _GEOMAlgo.GEOMAlgo_Extractor_GetModified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetNew(self, *args):
        """
        \brief This method returns the newly created sub-shapes in the result
        shape.

        \return the list of new sub-shapes in result.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _GEOMAlgo.GEOMAlgo_Extractor_GetNew(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_Extractor
GEOMAlgo_Extractor_swigregister = _GEOMAlgo.GEOMAlgo_Extractor_swigregister
GEOMAlgo_Extractor_swigregister(GEOMAlgo_Extractor)

class GEOMAlgo_GetInPlaceIterator(object):
    """
    The implementation of iterator of intersected  shapes
    for Get In Place Algorithm.
    The intersection is in terms of 3D bounding boxes.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_GetInPlaceIterator
GEOMAlgo_GetInPlaceIterator_swigregister = _GEOMAlgo.GEOMAlgo_GetInPlaceIterator_swigregister
GEOMAlgo_GetInPlaceIterator_swigregister(GEOMAlgo_GetInPlaceIterator)

class NCollection_List_GEOMAlgo_CoupleOfShapes_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _GEOMAlgo.new_NCollection_List_GEOMAlgo_CoupleOfShapes_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GEOMAlgo.delete_NCollection_List_GEOMAlgo_CoupleOfShapes_IteratorHelper

    def __next__(self):
        return _GEOMAlgo.NCollection_List_GEOMAlgo_CoupleOfShapes_IteratorHelper___next__(self)
NCollection_List_GEOMAlgo_CoupleOfShapes_IteratorHelper_swigregister = _GEOMAlgo.NCollection_List_GEOMAlgo_CoupleOfShapes_IteratorHelper_swigregister
NCollection_List_GEOMAlgo_CoupleOfShapes_IteratorHelper_swigregister(NCollection_List_GEOMAlgo_CoupleOfShapes_IteratorHelper)


try:
	GEOMAlgo_ListOfCoupleOfShapes = NCollection_List_GEOMAlgo_CoupleOfShapes
except NameError:
	pass # does not exist, probably ignored

class GEOMAlgo_Gluer2(GEOMAlgo_GluerAlgo):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(GEOMAlgo_Gluer2 self) -> GEOMAlgo_Gluer2"""
        this = _GEOMAlgo.new_GEOMAlgo_Gluer2(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetShapesToGlue(self, *args):
        """
        SetShapesToGlue(GEOMAlgo_Gluer2 self, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher aM)

        :type aM: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape

        """
        return _GEOMAlgo.GEOMAlgo_Gluer2_SetShapesToGlue(self, *args)


    def ShapesToGlue(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape

        """
        res = _GEOMAlgo.GEOMAlgo_Gluer2_ShapesToGlue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetKeepNonSolids(self, *args):
        """
        SetKeepNonSolids(GEOMAlgo_Gluer2 self, Standard_Boolean const theFlag)

        :type theFlag: bool

        """
        return _GEOMAlgo.GEOMAlgo_Gluer2_SetKeepNonSolids(self, *args)


    def KeepNonSolids(self, *args):
        """
        KeepNonSolids(GEOMAlgo_Gluer2 self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_Gluer2_KeepNonSolids(self, *args)


    def Clear(self, *args):
        """Clear(GEOMAlgo_Gluer2 self)"""
        return _GEOMAlgo.GEOMAlgo_Gluer2_Clear(self, *args)


    def Perform(self, *args):
        """Perform(GEOMAlgo_Gluer2 self)"""
        return _GEOMAlgo.GEOMAlgo_Gluer2_Perform(self, *args)


    def CheckData(self, *args):
        """CheckData(GEOMAlgo_Gluer2 self)"""
        return _GEOMAlgo.GEOMAlgo_Gluer2_CheckData(self, *args)


    def Detect(self, *args):
        """Detect(GEOMAlgo_Gluer2 self)"""
        return _GEOMAlgo.GEOMAlgo_Gluer2_Detect(self, *args)


    def ShapesDetected(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape

        """
        res = _GEOMAlgo.GEOMAlgo_Gluer2_ShapesDetected(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ImagesToWork(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape

        """
        res = _GEOMAlgo.GEOMAlgo_Gluer2_ImagesToWork(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Generated(self, *args):
        """
        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _GEOMAlgo.GEOMAlgo_Gluer2_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Modified(self, *args):
        """
        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _GEOMAlgo.GEOMAlgo_Gluer2_Modified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDeleted(self, *args):
        """
        IsDeleted(GEOMAlgo_Gluer2 self, TopoDS_Shape theS) -> Standard_Boolean

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_Gluer2_IsDeleted(self, *args)


    def MakeVertex(*args):
        """
        MakeVertex(NCollection_List_TopoDS_Shape theLV, TopoDS_Vertex theV)

        :type theLV: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type theV: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _GEOMAlgo.GEOMAlgo_Gluer2_MakeVertex(*args)

    MakeVertex = staticmethod(MakeVertex)

    def MapBRepShapes(*args):
        """
        MapBRepShapes(TopoDS_Shape theS, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theM)

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theM: int &

        """
        return _GEOMAlgo.GEOMAlgo_Gluer2_MapBRepShapes(*args)

    MapBRepShapes = staticmethod(MapBRepShapes)

    def MapShapes(*args):
        """
        MapShapes(TopoDS_Shape theS, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theM)

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theM: int &

        """
        return _GEOMAlgo.GEOMAlgo_Gluer2_MapShapes(*args)

    MapShapes = staticmethod(MapShapes)

    def StickedShapes(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeListOfShape

        """
        res = _GEOMAlgo.GEOMAlgo_Gluer2_StickedShapes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_Gluer2
GEOMAlgo_Gluer2_swigregister = _GEOMAlgo.GEOMAlgo_Gluer2_swigregister
GEOMAlgo_Gluer2_swigregister(GEOMAlgo_Gluer2)

def GEOMAlgo_Gluer2_MakeVertex(*args):
    """
    GEOMAlgo_Gluer2_MakeVertex(NCollection_List_TopoDS_Shape theLV, TopoDS_Vertex theV)

    :type theLV: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type theV: OCC.wrapper.TopoDS.TopoDS_Vertex

    """
    return _GEOMAlgo.GEOMAlgo_Gluer2_MakeVertex(*args)

def GEOMAlgo_Gluer2_MapBRepShapes(*args):
    """
    GEOMAlgo_Gluer2_MapBRepShapes(TopoDS_Shape theS, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theM)

    :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theM: int &

    """
    return _GEOMAlgo.GEOMAlgo_Gluer2_MapBRepShapes(*args)

def GEOMAlgo_Gluer2_MapShapes(*args):
    """
    GEOMAlgo_Gluer2_MapShapes(TopoDS_Shape theS, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theM)

    :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theM: int &

    """
    return _GEOMAlgo.GEOMAlgo_Gluer2_MapShapes(*args)

class NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self) -> NCollection_IndexedDataMap< Standard_Integer,TopoDS_Shape,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self) -> NCollection_IndexedDataMap< Standard_Integer,TopoDS_Shape,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self) -> NCollection_IndexedDataMap< Standard_Integer,TopoDS_Shape,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self) -> NCollection_IndexedDataMap< Standard_Integer,TopoDS_Shape,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _GEOMAlgo.new_NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher theOther) -> NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher theOther) -> NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, int const & theKey1, TopoDS_Shape theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, int const & theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, Standard_Integer const theIndex, int const & theKey1, TopoDS_Shape theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self)

        RemoveLast


        """
        return _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, int const & theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, Standard_Integer const theIndex) -> TopoDS_Shape

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, int const & theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, int const & theKey1) -> TopoDS_Shape

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, int const & theKey1) -> TopoDS_Shape

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, int const & theKey1) -> TopoDS_Shape

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _GEOMAlgo.delete_NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher
NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_swigregister = _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_swigregister
NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_swigregister(NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher)

class NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _GEOMAlgo.new_NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GEOMAlgo.delete_NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _GEOMAlgo.NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_IteratorHelper)


try:
	GEOMAlgo_IndexedDataMapOfIntegerShape = NCollection_IndexedDataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored


try:
	TopTools_MapOfShape = TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher
except AttributeError:
	pass # does not exist, probably ignored

class GEOMAlgo_BoxBndTreeSelector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(GEOMAlgo_BoxBndTreeSelector self) -> GEOMAlgo_BoxBndTreeSelector"""
        this = _GEOMAlgo.new_GEOMAlgo_BoxBndTreeSelector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Reject(self, *args):
        """
        Reject(GEOMAlgo_BoxBndTreeSelector self, Bnd_Box arg2) -> Standard_Boolean

        :type : OCC.wrapper.Bnd.Bnd_Box
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_BoxBndTreeSelector_Reject(self, *args)


    def Accept(self, *args):
        """
        Accept(GEOMAlgo_BoxBndTreeSelector self, Standard_Integer const & arg2) -> Standard_Boolean

        :type : int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_BoxBndTreeSelector_Accept(self, *args)


    def Clear(self, *args):
        """Clear(GEOMAlgo_BoxBndTreeSelector self)"""
        return _GEOMAlgo.GEOMAlgo_BoxBndTreeSelector_Clear(self, *args)


    def SetBox(self, *args):
        """
        SetBox(GEOMAlgo_BoxBndTreeSelector self, Bnd_Box arg2)

        :type : OCC.wrapper.Bnd.Bnd_Box

        """
        return _GEOMAlgo.GEOMAlgo_BoxBndTreeSelector_SetBox(self, *args)


    def Indices(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        res = _GEOMAlgo.GEOMAlgo_BoxBndTreeSelector_Indices(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_BoxBndTreeSelector
GEOMAlgo_BoxBndTreeSelector_swigregister = _GEOMAlgo.GEOMAlgo_BoxBndTreeSelector_swigregister
GEOMAlgo_BoxBndTreeSelector_swigregister(GEOMAlgo_BoxBndTreeSelector)

class GEOMAlgo_GetInPlaceAPI(object):
    """
    This is an API class for all GetInPlace algorithm.
    It facilitates using different GetInPlace algorithms:
    a new one(GEOMAlgo_GetInPlace), an old one and
    GetInPlaceByHistory.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def GetInPlace(*args):
        """
        GetInPlace(TopoDS_Shape theWhere, TopoDS_Shape theWhat, GEOMAlgo_GetInPlace theGIP) -> Standard_Boolean

        rief New GetInPlace method implementation.
        Initializes the GEOMAlgo_GetInPlace object with correct parameters and
        performs computation (calls theGIP's method Perform. Returns
        Standard_True in face of success; Standard_False otherwise.

        :type theWhere: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theWhat: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theGIP: OCC.wrapper.GEOMAlgo.GEOMAlgo_GetInPlace
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_GetInPlaceAPI_GetInPlace(*args)

    GetInPlace = staticmethod(GetInPlace)

    def GetInPlaceOld(*args):
        """
        GetInPlaceOld(TopoDS_Shape theWhere, TopoDS_Shape theWhat, NCollection_List_TopoDS_Shape theShapesInPlace) -> Standard_Integer

        rief Old implementation of GetInPlace algorithm.
        This method searches among sub shapes of the shape theWhere parts that are
        coincident with the shape theWhat. The result list of shape is returned as
        an output parameter. It returns the error code with the following possible
        values:
        0 - Success;
        1 - theWhere and/or theWhat TopoDS_Shape are Null;
        2 - An attempt to extract a shape of not supported type;
        3 - Not found any Results.

        :type theWhere: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theWhat: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theShapesInPlace: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.GEOMAlgo_GetInPlaceAPI_GetInPlaceOld(*args)

    GetInPlaceOld = staticmethod(GetInPlaceOld)

    def GetInPlaceByHistory(*args):
        """
        GetInPlaceByHistory(opencascade::handle< GEOM_Function > const & theWhereFunction, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher theWhereIndices, TopoDS_Shape theWhat, NCollection_List_TopoDS_Shape theShapesInPlace) -> Standard_Boolean

        rief GetInPlaceByHistory method implementation.
        Returns Standard_True if something is found. Warning: theShapesInPlace
        list is not cleared at first.

        :type theWhereFunction: OCC.wrapper.GEOMAlgo.Handle_GEOM_Function
        :type theWhereIndices: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape
        :type theWhat: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theShapesInPlace: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_GetInPlaceAPI_GetInPlaceByHistory(*args)

    GetInPlaceByHistory = staticmethod(GetInPlaceByHistory)

    def GetInPlaceMap(*args):
        """
        GetInPlaceMap(opencascade::handle< GEOM_Function > const & theWhereFunction, TopoDS_Shape theWhat, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > & theResVec) -> Standard_Boolean

        rief GetInPlaceMap method implementation.
        For each sub-shape ID in theWhat fills an array of corresponding
        sub-shape IDs in theWhere

        :type theWhereFunction: OCC.wrapper.GEOMAlgo.Handle_GEOM_Function
        :type theWhat: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theResVec: int &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_GetInPlaceAPI_GetInPlaceMap(*args)

    GetInPlaceMap = staticmethod(GetInPlaceMap)

    def __init__(self):
        """
        This is an API class for all GetInPlace algorithm.
        It facilitates using different GetInPlace algorithms:
        a new one(GEOMAlgo_GetInPlace), an old one and
        GetInPlaceByHistory.
        """
        this = _GEOMAlgo.new_GEOMAlgo_GetInPlaceAPI()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_GetInPlaceAPI
GEOMAlgo_GetInPlaceAPI_swigregister = _GEOMAlgo.GEOMAlgo_GetInPlaceAPI_swigregister
GEOMAlgo_GetInPlaceAPI_swigregister(GEOMAlgo_GetInPlaceAPI)

def GEOMAlgo_GetInPlaceAPI_GetInPlace(*args):
    """
    GEOMAlgo_GetInPlaceAPI_GetInPlace(TopoDS_Shape theWhere, TopoDS_Shape theWhat, GEOMAlgo_GetInPlace theGIP) -> Standard_Boolean

    rief New GetInPlace method implementation.
    Initializes the GEOMAlgo_GetInPlace object with correct parameters and
    performs computation (calls theGIP's method Perform. Returns
    Standard_True in face of success; Standard_False otherwise.

    :type theWhere: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theWhat: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theGIP: OCC.wrapper.GEOMAlgo.GEOMAlgo_GetInPlace
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _GEOMAlgo.GEOMAlgo_GetInPlaceAPI_GetInPlace(*args)

def GEOMAlgo_GetInPlaceAPI_GetInPlaceOld(*args):
    """
    GEOMAlgo_GetInPlaceAPI_GetInPlaceOld(TopoDS_Shape theWhere, TopoDS_Shape theWhat, NCollection_List_TopoDS_Shape theShapesInPlace) -> Standard_Integer

    rief Old implementation of GetInPlace algorithm.
    This method searches among sub shapes of the shape theWhere parts that are
    coincident with the shape theWhat. The result list of shape is returned as
    an output parameter. It returns the error code with the following possible
    values:
    0 - Success;
    1 - theWhere and/or theWhat TopoDS_Shape are Null;
    2 - An attempt to extract a shape of not supported type;
    3 - Not found any Results.

    :type theWhere: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theWhat: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theShapesInPlace: OCC.wrapper.TopTools.TopTools_ListOfShape
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _GEOMAlgo.GEOMAlgo_GetInPlaceAPI_GetInPlaceOld(*args)

def GEOMAlgo_GetInPlaceAPI_GetInPlaceByHistory(*args):
    """
    GEOMAlgo_GetInPlaceAPI_GetInPlaceByHistory(opencascade::handle< GEOM_Function > const & theWhereFunction, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher theWhereIndices, TopoDS_Shape theWhat, NCollection_List_TopoDS_Shape theShapesInPlace) -> Standard_Boolean

    rief GetInPlaceByHistory method implementation.
    Returns Standard_True if something is found. Warning: theShapesInPlace
    list is not cleared at first.

    :type theWhereFunction: OCC.wrapper.GEOMAlgo.Handle_GEOM_Function
    :type theWhereIndices: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape
    :type theWhat: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theShapesInPlace: OCC.wrapper.TopTools.TopTools_ListOfShape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _GEOMAlgo.GEOMAlgo_GetInPlaceAPI_GetInPlaceByHistory(*args)

def GEOMAlgo_GetInPlaceAPI_GetInPlaceMap(*args):
    """
    GEOMAlgo_GetInPlaceAPI_GetInPlaceMap(opencascade::handle< GEOM_Function > const & theWhereFunction, TopoDS_Shape theWhat, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > & theResVec) -> Standard_Boolean

    rief GetInPlaceMap method implementation.
    For each sub-shape ID in theWhat fills an array of corresponding
    sub-shape IDs in theWhere

    :type theWhereFunction: OCC.wrapper.GEOMAlgo.Handle_GEOM_Function
    :type theWhat: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theResVec: int &
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _GEOMAlgo.GEOMAlgo_GetInPlaceAPI_GetInPlaceMap(*args)

class GEOMAlgo_FinderShapeOn2(GEOMAlgo_ShapeAlgo):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(GEOMAlgo_FinderShapeOn2 self) -> GEOMAlgo_FinderShapeOn2"""
        this = _GEOMAlgo.new_GEOMAlgo_FinderShapeOn2(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetClsf(self, *args):
        """
        SetClsf(GEOMAlgo_FinderShapeOn2 self, Handle_GEOMAlgo_Clsf aClsf)

        :type aClsf: OCC.wrapper.GEOMAlgo.Handle_GEOMAlgo_Clsf

        """
        return _GEOMAlgo.GEOMAlgo_FinderShapeOn2_SetClsf(self, *args)


    def Clsf(self, *args):
        """
        :rtype: OCC.wrapper.GEOMAlgo.Handle_GEOMAlgo_Clsf

        """
        res = _GEOMAlgo.GEOMAlgo_FinderShapeOn2_Clsf(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetShapeType(self, *args):
        """
        SetShapeType(GEOMAlgo_FinderShapeOn2 self, TopAbs_ShapeEnum const aST)

        :type aST: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _GEOMAlgo.GEOMAlgo_FinderShapeOn2_SetShapeType(self, *args)


    def ShapeType(self, *args):
        """
        ShapeType(GEOMAlgo_FinderShapeOn2 self) -> TopAbs_ShapeEnum

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _GEOMAlgo.GEOMAlgo_FinderShapeOn2_ShapeType(self, *args)


    def SetState(self, *args):
        """
        SetState(GEOMAlgo_FinderShapeOn2 self, GEOMAlgo_State const aSF)

        :type aSF: OCC.wrapper.GEOMAlgo.GEOMAlgo_State

        """
        return _GEOMAlgo.GEOMAlgo_FinderShapeOn2_SetState(self, *args)


    def State(self, *args):
        """
        State(GEOMAlgo_FinderShapeOn2 self) -> GEOMAlgo_State

        :rtype: OCC.wrapper.GEOMAlgo.GEOMAlgo_State

        """
        return _GEOMAlgo.GEOMAlgo_FinderShapeOn2_State(self, *args)


    def SetNbPntsMin(self, *args):
        """
        SetNbPntsMin(GEOMAlgo_FinderShapeOn2 self, Standard_Integer const aNb)

        :type aNb: int

        """
        return _GEOMAlgo.GEOMAlgo_FinderShapeOn2_SetNbPntsMin(self, *args)


    def NbPntsMin(self, *args):
        """
        NbPntsMin(GEOMAlgo_FinderShapeOn2 self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.GEOMAlgo_FinderShapeOn2_NbPntsMin(self, *args)


    def SetNbPntsMax(self, *args):
        """
        SetNbPntsMax(GEOMAlgo_FinderShapeOn2 self, Standard_Integer const aNb)

        :type aNb: int

        """
        return _GEOMAlgo.GEOMAlgo_FinderShapeOn2_SetNbPntsMax(self, *args)


    def NbPntsMax(self, *args):
        """
        NbPntsMax(GEOMAlgo_FinderShapeOn2 self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.GEOMAlgo_FinderShapeOn2_NbPntsMax(self, *args)


    def Perform(self, *args):
        """Perform(GEOMAlgo_FinderShapeOn2 self)"""
        return _GEOMAlgo.GEOMAlgo_FinderShapeOn2_Perform(self, *args)


    def Shapes(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _GEOMAlgo.GEOMAlgo_FinderShapeOn2_Shapes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MSS(self, *args):
        """
        :rtype: OCC.wrapper.GEOMAlgo.GEOMAlgo_IndexedDataMapOfShapeState

        """
        res = _GEOMAlgo.GEOMAlgo_FinderShapeOn2_MSS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_FinderShapeOn2
GEOMAlgo_FinderShapeOn2_swigregister = _GEOMAlgo.GEOMAlgo_FinderShapeOn2_swigregister
GEOMAlgo_FinderShapeOn2_swigregister(GEOMAlgo_FinderShapeOn2)

class GEOMAlgo_WireSolid(GEOMAlgo_ShapeSolid):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(GEOMAlgo_WireSolid self) -> GEOMAlgo_WireSolid"""
        this = _GEOMAlgo.new_GEOMAlgo_WireSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """Perform(GEOMAlgo_WireSolid self)"""
        return _GEOMAlgo.GEOMAlgo_WireSolid_Perform(self, *args)

    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_WireSolid
GEOMAlgo_WireSolid_swigregister = _GEOMAlgo.GEOMAlgo_WireSolid_swigregister
GEOMAlgo_WireSolid_swigregister(GEOMAlgo_WireSolid)

class GEOMAlgo_ShellSolid(GEOMAlgo_ShapeSolid):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(GEOMAlgo_ShellSolid self) -> GEOMAlgo_ShellSolid"""
        this = _GEOMAlgo.new_GEOMAlgo_ShellSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """Perform(GEOMAlgo_ShellSolid self)"""
        return _GEOMAlgo.GEOMAlgo_ShellSolid_Perform(self, *args)

    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_ShellSolid
GEOMAlgo_ShellSolid_swigregister = _GEOMAlgo.GEOMAlgo_ShellSolid_swigregister
GEOMAlgo_ShellSolid_swigregister(GEOMAlgo_ShellSolid)

class GEOMAlgo_Gluer(GEOMAlgo_ShapeAlgo):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(GEOMAlgo_Gluer self) -> GEOMAlgo_Gluer"""
        this = _GEOMAlgo.new_GEOMAlgo_Gluer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetCheckGeometry(self, *args):
        """
        SetCheckGeometry(GEOMAlgo_Gluer self, Standard_Boolean const aFlag)

        :type aFlag: bool

        """
        return _GEOMAlgo.GEOMAlgo_Gluer_SetCheckGeometry(self, *args)


    def CheckGeometry(self, *args):
        """
        CheckGeometry(GEOMAlgo_Gluer self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_Gluer_CheckGeometry(self, *args)


    def SetKeepNonSolids(self, *args):
        """
        SetKeepNonSolids(GEOMAlgo_Gluer self, Standard_Boolean const aFlag)

        :type aFlag: bool

        """
        return _GEOMAlgo.GEOMAlgo_Gluer_SetKeepNonSolids(self, *args)


    def KeepNonSolids(self, *args):
        """
        KeepNonSolids(GEOMAlgo_Gluer self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_Gluer_KeepNonSolids(self, *args)


    def Perform(self, *args):
        """Perform(GEOMAlgo_Gluer self)"""
        return _GEOMAlgo.GEOMAlgo_Gluer_Perform(self, *args)


    def AloneShapes(self, *args):
        """
        AloneShapes(GEOMAlgo_Gluer self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.GEOMAlgo_Gluer_AloneShapes(self, *args)


    def Modified(self, *args):
        """
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _GEOMAlgo.GEOMAlgo_Gluer_Modified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Generated(self, *args):
        """
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _GEOMAlgo.GEOMAlgo_Gluer_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDeleted(self, *args):
        """
        IsDeleted(GEOMAlgo_Gluer self, TopoDS_Shape S) -> Standard_Boolean

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_Gluer_IsDeleted(self, *args)


    def Images(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape

        """
        res = _GEOMAlgo.GEOMAlgo_Gluer_Images(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Origins(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape

        """
        res = _GEOMAlgo.GEOMAlgo_Gluer_Origins(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_Gluer
GEOMAlgo_Gluer_swigregister = _GEOMAlgo.GEOMAlgo_Gluer_swigregister
GEOMAlgo_Gluer_swigregister(GEOMAlgo_Gluer)


try:
	TopTools_ListOfShape = TopoDS.NCollection_List_TopoDS_Shape
except AttributeError:
	pass # does not exist, probably ignored

class Handle_GEOMAlgo_ClsfQuad(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GEOMAlgo_ClsfQuad self)

        Nullify the handle


        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GEOMAlgo_ClsfQuad self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GEOMAlgo_ClsfQuad self, GEOMAlgo_ClsfQuad thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GEOMAlgo_ClsfQuad self, Handle_GEOMAlgo_ClsfQuad theHandle) -> Handle_GEOMAlgo_ClsfQuad
        assign(Handle_GEOMAlgo_ClsfQuad self, GEOMAlgo_ClsfQuad thePtr) -> Handle_GEOMAlgo_ClsfQuad
        assign(Handle_GEOMAlgo_ClsfQuad self, Handle_GEOMAlgo_ClsfQuad theHandle) -> Handle_GEOMAlgo_ClsfQuad

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GEOMAlgo_ClsfQuad self) -> GEOMAlgo_ClsfQuad

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GEOMAlgo_ClsfQuad self) -> GEOMAlgo_ClsfQuad

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GEOMAlgo_ClsfQuad self) -> GEOMAlgo_ClsfQuad

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad___ref__(self, *args)


    def __hash__(self):
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GEOMAlgo.new_Handle_GEOMAlgo_ClsfQuad(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_DownCast)
    __swig_destroy__ = _GEOMAlgo.delete_Handle_GEOMAlgo_ClsfQuad

    def SetCorners(self, *args):
        """
        SetCorners(Handle_GEOMAlgo_ClsfQuad self, gp_Pnt theTopLeftPoint, gp_Pnt theTopRightPoint, gp_Pnt theBottomLeftPoint, gp_Pnt theBottomRightPoint)

        :type theTopLeftPoint: OCC.wrapper.gp.gp_Pnt
        :type theTopRightPoint: OCC.wrapper.gp.gp_Pnt
        :type theBottomLeftPoint: OCC.wrapper.gp.gp_Pnt
        :type theBottomRightPoint: OCC.wrapper.gp.gp_Pnt

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_SetCorners(self, *args)


    def GetCorners(self, *args):
        """
        GetCorners(Handle_GEOMAlgo_ClsfQuad self, gp_Pnt theTopLeftPoint, gp_Pnt theTopRightPoint, gp_Pnt theBottomLeftPoint, gp_Pnt theBottomRightPoint)

        :type theTopLeftPoint: OCC.wrapper.gp.gp_Pnt
        :type theTopRightPoint: OCC.wrapper.gp.gp_Pnt
        :type theBottomLeftPoint: OCC.wrapper.gp.gp_Pnt
        :type theBottomRightPoint: OCC.wrapper.gp.gp_Pnt

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_GetCorners(self, *args)


    def Perform(self, *args):
        """Perform(Handle_GEOMAlgo_ClsfQuad self)"""
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_Perform(self, *args)


    def CheckData(self, *args):
        """CheckData(Handle_GEOMAlgo_ClsfQuad self)"""
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_CheckData(self, *args)


    def CanBeON(self, *args):
        """
        CanBeON(Handle_GEOMAlgo_ClsfQuad self, Handle_Geom_Curve aC) -> Standard_Boolean
        CanBeON(Handle_GEOMAlgo_ClsfQuad self, Handle_Geom_Surface aST) -> Standard_Boolean

        :type aST: OCC.wrapper.Geom.Handle_Geom_Surface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_CanBeON(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GEOMAlgo_ClsfQuad self) -> char const *

        :rtype: const char *

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPnt(self, *args):
        """
        SetPnt(Handle_GEOMAlgo_ClsfQuad self, gp_Pnt aP)

        :type aP: OCC.wrapper.gp.gp_Pnt

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_SetPnt(self, *args)


    def Pnt(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_Pnt(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_GEOMAlgo_ClsfQuad self, Standard_Real const aT)

        :type aT: float

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_SetTolerance(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(Handle_GEOMAlgo_ClsfQuad self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_Tolerance(self, *args)


    def State(self, *args):
        """
        State(Handle_GEOMAlgo_ClsfQuad self) -> TopAbs_State

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_State(self, *args)


    def CheckResult(self, *args):
        """CheckResult(Handle_GEOMAlgo_ClsfQuad self)"""
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_CheckResult(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_GEOMAlgo_ClsfQuad self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_ErrorStatus(self, *args)


    def WarningStatus(self, *args):
        """
        WarningStatus(Handle_GEOMAlgo_ClsfQuad self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_WarningStatus(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GEOMAlgo_ClsfQuad self)

        Memory deallocator for transient classes


        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GEOMAlgo_ClsfQuad self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GEOMAlgo_ClsfQuad self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GEOMAlgo_ClsfQuad self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GEOMAlgo_ClsfQuad self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GEOMAlgo_ClsfQuad self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GEOMAlgo_ClsfQuad self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GEOMAlgo_ClsfQuad self)

        Increments the reference counter of this object


        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GEOMAlgo_ClsfQuad self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_DecrementRefCounter(self, *args)

Handle_GEOMAlgo_ClsfQuad_swigregister = _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_swigregister
Handle_GEOMAlgo_ClsfQuad_swigregister(Handle_GEOMAlgo_ClsfQuad)

def Handle_GEOMAlgo_ClsfQuad_DownCast(thing):
    return _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_DownCast(thing)
Handle_GEOMAlgo_ClsfQuad_DownCast = _GEOMAlgo.Handle_GEOMAlgo_ClsfQuad_DownCast

class Handle_GEOMAlgo_Clsf(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GEOMAlgo_Clsf self)

        Nullify the handle


        """
        return _GEOMAlgo.Handle_GEOMAlgo_Clsf_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GEOMAlgo_Clsf self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GEOMAlgo.Handle_GEOMAlgo_Clsf_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GEOMAlgo_Clsf self, GEOMAlgo_Clsf thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GEOMAlgo.Handle_GEOMAlgo_Clsf_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GEOMAlgo_Clsf self, Handle_GEOMAlgo_Clsf theHandle) -> Handle_GEOMAlgo_Clsf
        assign(Handle_GEOMAlgo_Clsf self, GEOMAlgo_Clsf thePtr) -> Handle_GEOMAlgo_Clsf
        assign(Handle_GEOMAlgo_Clsf self, Handle_GEOMAlgo_Clsf theHandle) -> Handle_GEOMAlgo_Clsf

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GEOMAlgo.Handle_GEOMAlgo_Clsf_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GEOMAlgo_Clsf self) -> GEOMAlgo_Clsf

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GEOMAlgo.Handle_GEOMAlgo_Clsf_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GEOMAlgo_Clsf self) -> GEOMAlgo_Clsf

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GEOMAlgo.Handle_GEOMAlgo_Clsf___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GEOMAlgo_Clsf self) -> GEOMAlgo_Clsf

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GEOMAlgo.Handle_GEOMAlgo_Clsf___ref__(self, *args)


    def __hash__(self):
        return _GEOMAlgo.Handle_GEOMAlgo_Clsf___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GEOMAlgo.Handle_GEOMAlgo_Clsf___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GEOMAlgo.new_Handle_GEOMAlgo_Clsf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GEOMAlgo.Handle_GEOMAlgo_Clsf_DownCast)
    __swig_destroy__ = _GEOMAlgo.delete_Handle_GEOMAlgo_Clsf

    def SetPnt(self, *args):
        """
        SetPnt(Handle_GEOMAlgo_Clsf self, gp_Pnt aP)

        :type aP: OCC.wrapper.gp.gp_Pnt

        """
        return _GEOMAlgo.Handle_GEOMAlgo_Clsf_SetPnt(self, *args)


    def Pnt(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _GEOMAlgo.Handle_GEOMAlgo_Clsf_Pnt(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_GEOMAlgo_Clsf self, Standard_Real const aT)

        :type aT: float

        """
        return _GEOMAlgo.Handle_GEOMAlgo_Clsf_SetTolerance(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(Handle_GEOMAlgo_Clsf self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GEOMAlgo.Handle_GEOMAlgo_Clsf_Tolerance(self, *args)


    def State(self, *args):
        """
        State(Handle_GEOMAlgo_Clsf self) -> TopAbs_State

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _GEOMAlgo.Handle_GEOMAlgo_Clsf_State(self, *args)


    def CanBeON(self, *args):
        """
        CanBeON(Handle_GEOMAlgo_Clsf self, Handle_Geom_Curve aCT) -> Standard_Boolean
        CanBeON(Handle_GEOMAlgo_Clsf self, Handle_Geom_Surface aST) -> Standard_Boolean

        :type aST: OCC.wrapper.Geom.Handle_Geom_Surface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.Handle_GEOMAlgo_Clsf_CanBeON(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GEOMAlgo_Clsf self) -> char const *

        :rtype: const char *

        """
        return _GEOMAlgo.Handle_GEOMAlgo_Clsf_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GEOMAlgo.Handle_GEOMAlgo_Clsf_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GEOMAlgo.Handle_GEOMAlgo_Clsf_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Perform(self, *args):
        """Perform(Handle_GEOMAlgo_Clsf self)"""
        return _GEOMAlgo.Handle_GEOMAlgo_Clsf_Perform(self, *args)


    def CheckData(self, *args):
        """CheckData(Handle_GEOMAlgo_Clsf self)"""
        return _GEOMAlgo.Handle_GEOMAlgo_Clsf_CheckData(self, *args)


    def CheckResult(self, *args):
        """CheckResult(Handle_GEOMAlgo_Clsf self)"""
        return _GEOMAlgo.Handle_GEOMAlgo_Clsf_CheckResult(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_GEOMAlgo_Clsf self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.Handle_GEOMAlgo_Clsf_ErrorStatus(self, *args)


    def WarningStatus(self, *args):
        """
        WarningStatus(Handle_GEOMAlgo_Clsf self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.Handle_GEOMAlgo_Clsf_WarningStatus(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GEOMAlgo_Clsf self)

        Memory deallocator for transient classes


        """
        return _GEOMAlgo.Handle_GEOMAlgo_Clsf_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GEOMAlgo_Clsf self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GEOMAlgo_Clsf self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.Handle_GEOMAlgo_Clsf_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GEOMAlgo_Clsf self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GEOMAlgo_Clsf self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.Handle_GEOMAlgo_Clsf_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GEOMAlgo_Clsf self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GEOMAlgo.Handle_GEOMAlgo_Clsf_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GEOMAlgo_Clsf self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.Handle_GEOMAlgo_Clsf_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GEOMAlgo_Clsf self)

        Increments the reference counter of this object


        """
        return _GEOMAlgo.Handle_GEOMAlgo_Clsf_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GEOMAlgo_Clsf self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.Handle_GEOMAlgo_Clsf_DecrementRefCounter(self, *args)

Handle_GEOMAlgo_Clsf_swigregister = _GEOMAlgo.Handle_GEOMAlgo_Clsf_swigregister
Handle_GEOMAlgo_Clsf_swigregister(Handle_GEOMAlgo_Clsf)

def Handle_GEOMAlgo_Clsf_DownCast(thing):
    return _GEOMAlgo.Handle_GEOMAlgo_Clsf_DownCast(thing)
Handle_GEOMAlgo_Clsf_DownCast = _GEOMAlgo.Handle_GEOMAlgo_Clsf_DownCast

class Handle_GEOMAlgo_ClsfBox(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GEOMAlgo_ClsfBox self)

        Nullify the handle


        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GEOMAlgo_ClsfBox self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GEOMAlgo_ClsfBox self, GEOMAlgo_ClsfBox thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GEOMAlgo_ClsfBox self, Handle_GEOMAlgo_ClsfBox theHandle) -> Handle_GEOMAlgo_ClsfBox
        assign(Handle_GEOMAlgo_ClsfBox self, GEOMAlgo_ClsfBox thePtr) -> Handle_GEOMAlgo_ClsfBox
        assign(Handle_GEOMAlgo_ClsfBox self, Handle_GEOMAlgo_ClsfBox theHandle) -> Handle_GEOMAlgo_ClsfBox

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GEOMAlgo_ClsfBox self) -> GEOMAlgo_ClsfBox

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GEOMAlgo_ClsfBox self) -> GEOMAlgo_ClsfBox

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GEOMAlgo_ClsfBox self) -> GEOMAlgo_ClsfBox

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox___ref__(self, *args)


    def __hash__(self):
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GEOMAlgo.new_Handle_GEOMAlgo_ClsfBox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GEOMAlgo.Handle_GEOMAlgo_ClsfBox_DownCast)
    __swig_destroy__ = _GEOMAlgo.delete_Handle_GEOMAlgo_ClsfBox

    def SetBox(self, *args):
        """
        SetBox(Handle_GEOMAlgo_ClsfBox self, TopoDS_Shape aS)

        :type aS: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_SetBox(self, *args)


    def Box(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_Box(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Perform(self, *args):
        """Perform(Handle_GEOMAlgo_ClsfBox self)"""
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_Perform(self, *args)


    def CheckData(self, *args):
        """CheckData(Handle_GEOMAlgo_ClsfBox self)"""
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_CheckData(self, *args)


    def CanBeON(self, *args):
        """
        CanBeON(Handle_GEOMAlgo_ClsfBox self, Handle_Geom_Curve aC) -> Standard_Boolean
        CanBeON(Handle_GEOMAlgo_ClsfBox self, Handle_Geom_Surface aST) -> Standard_Boolean

        :type aST: OCC.wrapper.Geom.Handle_Geom_Surface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_CanBeON(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GEOMAlgo_ClsfBox self) -> char const *

        :rtype: const char *

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPnt(self, *args):
        """
        SetPnt(Handle_GEOMAlgo_ClsfBox self, gp_Pnt aP)

        :type aP: OCC.wrapper.gp.gp_Pnt

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_SetPnt(self, *args)


    def Pnt(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_Pnt(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_GEOMAlgo_ClsfBox self, Standard_Real const aT)

        :type aT: float

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_SetTolerance(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(Handle_GEOMAlgo_ClsfBox self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_Tolerance(self, *args)


    def State(self, *args):
        """
        State(Handle_GEOMAlgo_ClsfBox self) -> TopAbs_State

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_State(self, *args)


    def CheckResult(self, *args):
        """CheckResult(Handle_GEOMAlgo_ClsfBox self)"""
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_CheckResult(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_GEOMAlgo_ClsfBox self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_ErrorStatus(self, *args)


    def WarningStatus(self, *args):
        """
        WarningStatus(Handle_GEOMAlgo_ClsfBox self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_WarningStatus(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GEOMAlgo_ClsfBox self)

        Memory deallocator for transient classes


        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GEOMAlgo_ClsfBox self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GEOMAlgo_ClsfBox self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GEOMAlgo_ClsfBox self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GEOMAlgo_ClsfBox self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GEOMAlgo_ClsfBox self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GEOMAlgo_ClsfBox self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GEOMAlgo_ClsfBox self)

        Increments the reference counter of this object


        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GEOMAlgo_ClsfBox self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_DecrementRefCounter(self, *args)

Handle_GEOMAlgo_ClsfBox_swigregister = _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_swigregister
Handle_GEOMAlgo_ClsfBox_swigregister(Handle_GEOMAlgo_ClsfBox)

def Handle_GEOMAlgo_ClsfBox_DownCast(thing):
    return _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_DownCast(thing)
Handle_GEOMAlgo_ClsfBox_DownCast = _GEOMAlgo.Handle_GEOMAlgo_ClsfBox_DownCast

class NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher self) -> NCollection_IndexedDataMap< GEOMAlgo_PassKeyShape,TopTools_ListOfShape,GEOMAlgo_PassKeyShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher self) -> NCollection_IndexedDataMap< GEOMAlgo_PassKeyShape,TopTools_ListOfShape,GEOMAlgo_PassKeyShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher self) -> NCollection_IndexedDataMap< GEOMAlgo_PassKeyShape,TopTools_ListOfShape,GEOMAlgo_PassKeyShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher self) -> NCollection_IndexedDataMap< GEOMAlgo_PassKeyShape,TopTools_ListOfShape,GEOMAlgo_PassKeyShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _GEOMAlgo.new_NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher self, NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher self, NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher theOther) -> NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher self, NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher theOther) -> NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher self, GEOMAlgo_PassKeyShape theKey1, NCollection_List_TopoDS_Shape theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher self, GEOMAlgo_PassKeyShape theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher self, Standard_Integer const theIndex, GEOMAlgo_PassKeyShape theKey1, NCollection_List_TopoDS_Shape theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher self)

        RemoveLast


        """
        return _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher self, GEOMAlgo_PassKeyShape theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher self, Standard_Integer const theIndex) -> NCollection_List_TopoDS_Shape

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher self, GEOMAlgo_PassKeyShape theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher self, GEOMAlgo_PassKeyShape theKey1) -> NCollection_List_TopoDS_Shape

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher self, GEOMAlgo_PassKeyShape theKey1) -> NCollection_List_TopoDS_Shape

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher self, GEOMAlgo_PassKeyShape theKey1) -> NCollection_List_TopoDS_Shape

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher___iter__(self)
    __swig_destroy__ = _GEOMAlgo.delete_NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher
NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_swigregister = _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_swigregister
NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_swigregister(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher)

class NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _GEOMAlgo.new_NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GEOMAlgo.delete_NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_IteratorHelper

    def __next__(self):
        return _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_IteratorHelper_swigregister = _GEOMAlgo.NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher_IteratorHelper)


try:
	GEOMAlgo_IndexedDataMapOfPassKeyShapeListOfShape = NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopAbs_State,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopAbs_State,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopAbs_State,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopAbs_State,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _GEOMAlgo.new_NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1, TopAbs_State const & theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, Standard_Integer const theIndex, TopoDS_Shape theKey1, TopAbs_State const & theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self)

        RemoveLast


        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, Standard_Integer const theIndex) -> TopAbs_State &

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> TopAbs_State &

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> TopAbs_State const *

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> TopAbs_State *

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _GEOMAlgo.delete_NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher
NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_swigregister = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher)

class NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _GEOMAlgo.new_NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GEOMAlgo.delete_NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_IteratorHelper)


try:
	GEOMAlgo_IndexedDataMapOfShapeState = NCollection_IndexedDataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class GEOMAlgo_VertexSolid(GEOMAlgo_ShapeSolid):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(GEOMAlgo_VertexSolid self) -> GEOMAlgo_VertexSolid"""
        this = _GEOMAlgo.new_GEOMAlgo_VertexSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """Perform(GEOMAlgo_VertexSolid self)"""
        return _GEOMAlgo.GEOMAlgo_VertexSolid_Perform(self, *args)

    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_VertexSolid
GEOMAlgo_VertexSolid_swigregister = _GEOMAlgo.GEOMAlgo_VertexSolid_swigregister
GEOMAlgo_VertexSolid_swigregister(GEOMAlgo_VertexSolid)

class GEOMAlgo_Splitter(BOPAlgo.BOPAlgo_Builder):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GEOMAlgo_Splitter self) -> GEOMAlgo_Splitter
        __init__(GEOMAlgo_Splitter self, Handle_NCollection_BaseAllocator theAllocator) -> GEOMAlgo_Splitter

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _GEOMAlgo.new_GEOMAlgo_Splitter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddTool(self, *args):
        """
        AddTool(GEOMAlgo_Splitter self, TopoDS_Shape theShape)

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _GEOMAlgo.GEOMAlgo_Splitter_AddTool(self, *args)


    def Tools(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _GEOMAlgo.GEOMAlgo_Splitter_Tools(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetLimit(self, *args):
        """
        SetLimit(GEOMAlgo_Splitter self, TopAbs_ShapeEnum const aLimit)

        :type aLimit: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _GEOMAlgo.GEOMAlgo_Splitter_SetLimit(self, *args)


    def Limit(self, *args):
        """
        Limit(GEOMAlgo_Splitter self) -> TopAbs_ShapeEnum

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _GEOMAlgo.GEOMAlgo_Splitter_Limit(self, *args)


    def SetLimitMode(self, *args):
        """
        SetLimitMode(GEOMAlgo_Splitter self, Standard_Integer const aMode)

        :type aMode: int

        """
        return _GEOMAlgo.GEOMAlgo_Splitter_SetLimitMode(self, *args)


    def LimitMode(self, *args):
        """
        LimitMode(GEOMAlgo_Splitter self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.GEOMAlgo_Splitter_LimitMode(self, *args)


    def Clear(self, *args):
        """
        Clear(GEOMAlgo_Splitter self)

        Clears the content of the algorithm.


        """
        return _GEOMAlgo.GEOMAlgo_Splitter_Clear(self, *args)

    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_Splitter
GEOMAlgo_Splitter_swigregister = _GEOMAlgo.GEOMAlgo_Splitter_swigregister
GEOMAlgo_Splitter_swigregister(GEOMAlgo_Splitter)

class GEOMAlgo_FinderShapeOnQuad(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_FinderShapeOnQuad
GEOMAlgo_FinderShapeOnQuad_swigregister = _GEOMAlgo.GEOMAlgo_FinderShapeOnQuad_swigregister
GEOMAlgo_FinderShapeOnQuad_swigregister(GEOMAlgo_FinderShapeOnQuad)

class GEOMAlgo_RemoverWebs(GEOMAlgo_ShapeAlgo):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(GEOMAlgo_RemoverWebs self) -> GEOMAlgo_RemoverWebs"""
        this = _GEOMAlgo.new_GEOMAlgo_RemoverWebs(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """Perform(GEOMAlgo_RemoverWebs self)"""
        return _GEOMAlgo.GEOMAlgo_RemoverWebs_Perform(self, *args)

    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_RemoverWebs
GEOMAlgo_RemoverWebs_swigregister = _GEOMAlgo.GEOMAlgo_RemoverWebs_swigregister
GEOMAlgo_RemoverWebs_swigregister(GEOMAlgo_RemoverWebs)

class NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopTools_MapOfShape,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopTools_MapOfShape,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopTools_MapOfShape,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopTools_MapOfShape,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _GEOMAlgo.new_NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theItem) -> NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _GEOMAlgo.delete_NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_swigregister = _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _GEOMAlgo.new_NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GEOMAlgo.delete_NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_IteratorHelper)


try:
	GEOMAlgo_DataMapOfShapeMapOfShape = NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class GEOMAlgo_ShapeInfo(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(GEOMAlgo_ShapeInfo self) -> GEOMAlgo_ShapeInfo"""
        this = _GEOMAlgo.new_GEOMAlgo_ShapeInfo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Reset(self, *args):
        """Reset(GEOMAlgo_ShapeInfo self)"""
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_Reset(self, *args)


    def SetType(self, *args):
        """
        SetType(GEOMAlgo_ShapeInfo self, TopAbs_ShapeEnum const aType)

        :type aType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_SetType(self, *args)


    def Type(self, *args):
        """
        Type(GEOMAlgo_ShapeInfo self) -> TopAbs_ShapeEnum

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_Type(self, *args)


    def SetNbSubShapes(self, *args):
        """
        SetNbSubShapes(GEOMAlgo_ShapeInfo self, TopAbs_ShapeEnum const aType, Standard_Integer const aNb)

        :type aType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type aNb: int

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_SetNbSubShapes(self, *args)


    def NbSubShapes(self, *args):
        """
        NbSubShapes(GEOMAlgo_ShapeInfo self, TopAbs_ShapeEnum const aType) -> Standard_Integer

        :type aType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_NbSubShapes(self, *args)


    def SetKindOfShape(self, *args):
        """
        SetKindOfShape(GEOMAlgo_ShapeInfo self, GEOMAlgo_KindOfShape const aT)

        :type aT: OCC.wrapper.GEOMAlgo.GEOMAlgo_KindOfShape

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_SetKindOfShape(self, *args)


    def KindOfShape(self, *args):
        """
        KindOfShape(GEOMAlgo_ShapeInfo self) -> GEOMAlgo_KindOfShape

        :rtype: OCC.wrapper.GEOMAlgo.GEOMAlgo_KindOfShape

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_KindOfShape(self, *args)


    def SetKindOfName(self, *args):
        """
        SetKindOfName(GEOMAlgo_ShapeInfo self, GEOMAlgo_KindOfName const aT)

        :type aT: OCC.wrapper.GEOMAlgo.GEOMAlgo_KindOfName

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_SetKindOfName(self, *args)


    def KindOfName(self, *args):
        """
        KindOfName(GEOMAlgo_ShapeInfo self) -> GEOMAlgo_KindOfName

        :rtype: OCC.wrapper.GEOMAlgo.GEOMAlgo_KindOfName

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_KindOfName(self, *args)


    def SetKindOfBounds(self, *args):
        """
        SetKindOfBounds(GEOMAlgo_ShapeInfo self, GEOMAlgo_KindOfBounds const aT)

        :type aT: OCC.wrapper.GEOMAlgo.GEOMAlgo_KindOfBounds

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_SetKindOfBounds(self, *args)


    def KindOfBounds(self, *args):
        """
        KindOfBounds(GEOMAlgo_ShapeInfo self) -> GEOMAlgo_KindOfBounds

        :rtype: OCC.wrapper.GEOMAlgo.GEOMAlgo_KindOfBounds

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_KindOfBounds(self, *args)


    def SetKindOfClosed(self, *args):
        """
        SetKindOfClosed(GEOMAlgo_ShapeInfo self, GEOMAlgo_KindOfClosed const aT)

        :type aT: OCC.wrapper.GEOMAlgo.GEOMAlgo_KindOfClosed

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_SetKindOfClosed(self, *args)


    def KindOfClosed(self, *args):
        """
        KindOfClosed(GEOMAlgo_ShapeInfo self) -> GEOMAlgo_KindOfClosed

        :rtype: OCC.wrapper.GEOMAlgo.GEOMAlgo_KindOfClosed

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_KindOfClosed(self, *args)


    def SetKindOfDef(self, *args):
        """
        SetKindOfDef(GEOMAlgo_ShapeInfo self, GEOMAlgo_KindOfDef const aT)

        :type aT: OCC.wrapper.GEOMAlgo.GEOMAlgo_KindOfDef

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_SetKindOfDef(self, *args)


    def KindOfDef(self, *args):
        """
        KindOfDef(GEOMAlgo_ShapeInfo self) -> GEOMAlgo_KindOfDef

        :rtype: OCC.wrapper.GEOMAlgo.GEOMAlgo_KindOfDef

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_KindOfDef(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(GEOMAlgo_ShapeInfo self, gp_Pnt aP)

        :type aP: OCC.wrapper.gp.gp_Pnt

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_SetLocation(self, *args)


    def Location(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _GEOMAlgo.GEOMAlgo_ShapeInfo_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDirection(self, *args):
        """
        SetDirection(GEOMAlgo_ShapeInfo self, gp_Dir aD)

        :type aD: OCC.wrapper.gp.gp_Dir

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_SetDirection(self, *args)


    def Direction(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _GEOMAlgo.GEOMAlgo_ShapeInfo_Direction(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPosition(self, *args):
        """
        SetPosition(GEOMAlgo_ShapeInfo self, gp_Ax2 aAx2)
        SetPosition(GEOMAlgo_ShapeInfo self, gp_Ax3 aAx3)

        :type aAx3: OCC.wrapper.gp.gp_Ax3

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_SetPosition(self, *args)


    def Position(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Ax3

        """
        res = _GEOMAlgo.GEOMAlgo_ShapeInfo_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPnt1(self, *args):
        """
        SetPnt1(GEOMAlgo_ShapeInfo self, gp_Pnt aP)

        :type aP: OCC.wrapper.gp.gp_Pnt

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_SetPnt1(self, *args)


    def Pnt1(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _GEOMAlgo.GEOMAlgo_ShapeInfo_Pnt1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPnt2(self, *args):
        """
        SetPnt2(GEOMAlgo_ShapeInfo self, gp_Pnt aP)

        :type aP: OCC.wrapper.gp.gp_Pnt

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_SetPnt2(self, *args)


    def Pnt2(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _GEOMAlgo.GEOMAlgo_ShapeInfo_Pnt2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetRadius1(self, *args):
        """
        SetRadius1(GEOMAlgo_ShapeInfo self, Standard_Real const aR)

        :type aR: float

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_SetRadius1(self, *args)


    def Radius1(self, *args):
        """
        Radius1(GEOMAlgo_ShapeInfo self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_Radius1(self, *args)


    def SetRadius2(self, *args):
        """
        SetRadius2(GEOMAlgo_ShapeInfo self, Standard_Real const aR)

        :type aR: float

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_SetRadius2(self, *args)


    def Radius2(self, *args):
        """
        Radius2(GEOMAlgo_ShapeInfo self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_Radius2(self, *args)


    def SetLength(self, *args):
        """
        SetLength(GEOMAlgo_ShapeInfo self, Standard_Real const aL)

        :type aL: float

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_SetLength(self, *args)


    def Length(self, *args):
        """
        Length(GEOMAlgo_ShapeInfo self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_Length(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(GEOMAlgo_ShapeInfo self, Standard_Real const aW)

        :type aW: float

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_SetWidth(self, *args)


    def Width(self, *args):
        """
        Width(GEOMAlgo_ShapeInfo self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_Width(self, *args)


    def SetHeight(self, *args):
        """
        SetHeight(GEOMAlgo_ShapeInfo self, Standard_Real const aH)

        :type aH: float

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_SetHeight(self, *args)


    def Height(self, *args):
        """
        Height(GEOMAlgo_ShapeInfo self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_Height(self, *args)


    def Dump(self, *args):
        """Dump(GEOMAlgo_ShapeInfo self)"""
        return _GEOMAlgo.GEOMAlgo_ShapeInfo_Dump(self, *args)

    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_ShapeInfo
GEOMAlgo_ShapeInfo_swigregister = _GEOMAlgo.GEOMAlgo_ShapeInfo_swigregister
GEOMAlgo_ShapeInfo_swigregister(GEOMAlgo_ShapeInfo)

class GEOMAlgo_GlueAnalyser(GEOMAlgo_Gluer):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(GEOMAlgo_GlueAnalyser self) -> GEOMAlgo_GlueAnalyser"""
        this = _GEOMAlgo.new_GEOMAlgo_GlueAnalyser(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """Perform(GEOMAlgo_GlueAnalyser self)"""
        return _GEOMAlgo.GEOMAlgo_GlueAnalyser_Perform(self, *args)


    def HasSolidsToGlue(self, *args):
        """
        HasSolidsToGlue(GEOMAlgo_GlueAnalyser self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_GlueAnalyser_HasSolidsToGlue(self, *args)


    def SolidsToGlue(self, *args):
        """
        :rtype: OCC.wrapper.GEOMAlgo.GEOMAlgo_ListOfCoupleOfShapes

        """
        res = _GEOMAlgo.GEOMAlgo_GlueAnalyser_SolidsToGlue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasSolidsAlone(self, *args):
        """
        HasSolidsAlone(GEOMAlgo_GlueAnalyser self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_GlueAnalyser_HasSolidsAlone(self, *args)


    def SolidsAlone(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _GEOMAlgo.GEOMAlgo_GlueAnalyser_SolidsAlone(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_GlueAnalyser
GEOMAlgo_GlueAnalyser_swigregister = _GEOMAlgo.GEOMAlgo_GlueAnalyser_swigregister
GEOMAlgo_GlueAnalyser_swigregister(GEOMAlgo_GlueAnalyser)


try:
	TopTools_IndexedMapOfShape = TopTools.NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher
except AttributeError:
	pass # does not exist, probably ignored

class GEOMAlgo_BndSphereTreeSelector(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(GEOMAlgo_BndSphereTreeSelector self) -> GEOMAlgo_BndSphereTreeSelector"""
        this = _GEOMAlgo.new_GEOMAlgo_BndSphereTreeSelector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Reject(self, *args):
        """
        Reject(GEOMAlgo_BndSphereTreeSelector self, GEOMAlgo_BndSphere arg2) -> Standard_Boolean

        :type : OCC.wrapper.GEOMAlgo.GEOMAlgo_BndSphere
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_BndSphereTreeSelector_Reject(self, *args)


    def Accept(self, *args):
        """
        Accept(GEOMAlgo_BndSphereTreeSelector self, Standard_Integer const & arg2) -> Standard_Boolean

        :type : int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_BndSphereTreeSelector_Accept(self, *args)


    def Clear(self, *args):
        """Clear(GEOMAlgo_BndSphereTreeSelector self)"""
        return _GEOMAlgo.GEOMAlgo_BndSphereTreeSelector_Clear(self, *args)


    def SetBox(self, *args):
        """
        SetBox(GEOMAlgo_BndSphereTreeSelector self, GEOMAlgo_BndSphere arg2)

        :type : OCC.wrapper.GEOMAlgo.GEOMAlgo_BndSphere

        """
        return _GEOMAlgo.GEOMAlgo_BndSphereTreeSelector_SetBox(self, *args)


    def Indices(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        res = _GEOMAlgo.GEOMAlgo_BndSphereTreeSelector_Indices(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_BndSphereTreeSelector
GEOMAlgo_BndSphereTreeSelector_swigregister = _GEOMAlgo.GEOMAlgo_BndSphereTreeSelector_swigregister
GEOMAlgo_BndSphereTreeSelector_swigregister(GEOMAlgo_BndSphereTreeSelector)

class GEOMAlgo_ClsfSolid(GEOMAlgo_Clsf):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GEOMAlgo_ClsfSolid
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GEOMAlgo_ClsfSolid(self) 
            return h


    def __init__(self, *args):
        """__init__(GEOMAlgo_ClsfSolid self) -> GEOMAlgo_ClsfSolid"""
        this = _GEOMAlgo.new_GEOMAlgo_ClsfSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetShape(self, *args):
        """
        SetShape(GEOMAlgo_ClsfSolid self, TopoDS_Shape aS)

        :type aS: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _GEOMAlgo.GEOMAlgo_ClsfSolid_SetShape(self, *args)


    def Shape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _GEOMAlgo.GEOMAlgo_ClsfSolid_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Perform(self, *args):
        """Perform(GEOMAlgo_ClsfSolid self)"""
        return _GEOMAlgo.GEOMAlgo_ClsfSolid_Perform(self, *args)


    def CheckData(self, *args):
        """CheckData(GEOMAlgo_ClsfSolid self)"""
        return _GEOMAlgo.GEOMAlgo_ClsfSolid_CheckData(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GEOMAlgo.GEOMAlgo_ClsfSolid_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GEOMAlgo.GEOMAlgo_ClsfSolid_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GEOMAlgo.GEOMAlgo_ClsfSolid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_ClsfSolid
GEOMAlgo_ClsfSolid_swigregister = _GEOMAlgo.GEOMAlgo_ClsfSolid_swigregister
GEOMAlgo_ClsfSolid_swigregister(GEOMAlgo_ClsfSolid)

def GEOMAlgo_ClsfSolid_get_type_name(*args):
    """
    GEOMAlgo_ClsfSolid_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GEOMAlgo.GEOMAlgo_ClsfSolid_get_type_name(*args)

def GEOMAlgo_ClsfSolid_get_type_descriptor(*args):
    """
    GEOMAlgo_ClsfSolid_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GEOMAlgo.GEOMAlgo_ClsfSolid_get_type_descriptor(*args)

class GEOMAlgo_SurfaceTools(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def IsAnalytic(*args):
        """
        IsAnalytic(Handle_Geom_Surface aS) -> Standard_Boolean

        :type aS: OCC.wrapper.Geom.Handle_Geom_Surface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_SurfaceTools_IsAnalytic(*args)

    IsAnalytic = staticmethod(IsAnalytic)

    def IsCoaxial(*args):
        """
        IsCoaxial(gp_Pnt aP1, gp_Pnt aP2, gp_Cylinder aCyl, Standard_Real const aTol) -> Standard_Boolean

        :type aP1: OCC.wrapper.gp.gp_Pnt
        :type aP2: OCC.wrapper.gp.gp_Pnt
        :type aCyl: OCC.wrapper.gp.gp_Cylinder
        :type aTol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_SurfaceTools_IsCoaxial(*args)

    IsCoaxial = staticmethod(IsCoaxial)

    def IsConformState(*args):
        """
        IsConformState(TopAbs_State const aST1, GEOMAlgo_State const aST2) -> Standard_Boolean

        :type aST1: OCC.wrapper.TopAbs.TopAbs_State
        :type aST2: OCC.wrapper.GEOMAlgo.GEOMAlgo_State
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_SurfaceTools_IsConformState(*args)

    IsConformState = staticmethod(IsConformState)

    def GetState(*args):
        """
        GetState(gp_Pnt aP, GeomAdaptor_Surface aS, Standard_Real const aTol) -> Standard_Integer
        GetState(gp_Pnt aP, Handle_Geom_Surface aS, Standard_Real const aTol) -> Standard_Integer

        :type aP: OCC.wrapper.gp.gp_Pnt
        :type aS: OCC.wrapper.Geom.Handle_Geom_Surface
        :type aTol: float
        :type aSt: OCC.wrapper.TopAbs.TopAbs_State
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.GEOMAlgo_SurfaceTools_GetState(*args)

    GetState = staticmethod(GetState)

    def ReverseState(*args):
        """
        ReverseState(TopAbs_State const aSt) -> TopAbs_State

        :type aSt: OCC.wrapper.TopAbs.TopAbs_State
        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _GEOMAlgo.GEOMAlgo_SurfaceTools_ReverseState(*args)

    ReverseState = staticmethod(ReverseState)

    def __init__(self):
        this = _GEOMAlgo.new_GEOMAlgo_SurfaceTools()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_SurfaceTools
GEOMAlgo_SurfaceTools_swigregister = _GEOMAlgo.GEOMAlgo_SurfaceTools_swigregister
GEOMAlgo_SurfaceTools_swigregister(GEOMAlgo_SurfaceTools)

def GEOMAlgo_SurfaceTools_IsAnalytic(*args):
    """
    GEOMAlgo_SurfaceTools_IsAnalytic(Handle_Geom_Surface aS) -> Standard_Boolean

    :type aS: OCC.wrapper.Geom.Handle_Geom_Surface
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _GEOMAlgo.GEOMAlgo_SurfaceTools_IsAnalytic(*args)

def GEOMAlgo_SurfaceTools_IsCoaxial(*args):
    """
    GEOMAlgo_SurfaceTools_IsCoaxial(gp_Pnt aP1, gp_Pnt aP2, gp_Cylinder aCyl, Standard_Real const aTol) -> Standard_Boolean

    :type aP1: OCC.wrapper.gp.gp_Pnt
    :type aP2: OCC.wrapper.gp.gp_Pnt
    :type aCyl: OCC.wrapper.gp.gp_Cylinder
    :type aTol: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _GEOMAlgo.GEOMAlgo_SurfaceTools_IsCoaxial(*args)

def GEOMAlgo_SurfaceTools_IsConformState(*args):
    """
    GEOMAlgo_SurfaceTools_IsConformState(TopAbs_State const aST1, GEOMAlgo_State const aST2) -> Standard_Boolean

    :type aST1: OCC.wrapper.TopAbs.TopAbs_State
    :type aST2: OCC.wrapper.GEOMAlgo.GEOMAlgo_State
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _GEOMAlgo.GEOMAlgo_SurfaceTools_IsConformState(*args)

def GEOMAlgo_SurfaceTools_GetState(*args):
    """
    GetState(gp_Pnt aP, GeomAdaptor_Surface aS, Standard_Real const aTol) -> Standard_Integer
    GEOMAlgo_SurfaceTools_GetState(gp_Pnt aP, Handle_Geom_Surface aS, Standard_Real const aTol) -> Standard_Integer

    :type aP: OCC.wrapper.gp.gp_Pnt
    :type aS: OCC.wrapper.Geom.Handle_Geom_Surface
    :type aTol: float
    :type aSt: OCC.wrapper.TopAbs.TopAbs_State
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _GEOMAlgo.GEOMAlgo_SurfaceTools_GetState(*args)

def GEOMAlgo_SurfaceTools_ReverseState(*args):
    """
    GEOMAlgo_SurfaceTools_ReverseState(TopAbs_State const aSt) -> TopAbs_State

    :type aSt: OCC.wrapper.TopAbs.TopAbs_State
    :rtype: OCC.wrapper.TopAbs.TopAbs_State

    """
    return _GEOMAlgo.GEOMAlgo_SurfaceTools_ReverseState(*args)


try:
	GEOMAlgo_BoxBndTree = NCollection_UBTree_Standard_Integer_Bnd_Box
except NameError:
	pass # does not exist, probably ignored

class GEOMAlgo_GetInPlace(GEOMAlgo_GluerAlgo, GEOMAlgo_Algo):
    """
    The implementation of Get In Place Algorithm.
    The algorithm provides the search the argument [What]
    in the shape [Where].
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GEOMAlgo_GetInPlace self) -> GEOMAlgo_GetInPlace

        Constructor.


        """
        this = _GEOMAlgo.new_GEOMAlgo_GetInPlace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetShapeWhere(self, *args):
        """
        SetShapeWhere(GEOMAlgo_GetInPlace self, TopoDS_Shape theShape)

        Modifier. Sets the shape where the search is intended.
        @param theShape
        The shape where the search is intended.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _GEOMAlgo.GEOMAlgo_GetInPlace_SetShapeWhere(self, *args)


    def ShapeWhere(self, *args):
        """
        Selector. Returns the shape where the search is intended.
        @return
        The shape where the search is intended.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _GEOMAlgo.GEOMAlgo_GetInPlace_ShapeWhere(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTolMass(self, *args):
        """
        SetTolMass(GEOMAlgo_GetInPlace self, Standard_Real const theTol)

        Modifier. Sets the tolerance of mass.
        @param theTol
        The value tolerance of mass.

        :type theTol: float

        """
        return _GEOMAlgo.GEOMAlgo_GetInPlace_SetTolMass(self, *args)


    def TolMass(self, *args):
        """
        TolMass(GEOMAlgo_GetInPlace self) -> Standard_Real

        Selector. Returns the value tolerance of mass.
        @return
        The value tolerance of mass.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GEOMAlgo.GEOMAlgo_GetInPlace_TolMass(self, *args)


    def SetTolCG(self, *args):
        """
        SetTolCG(GEOMAlgo_GetInPlace self, Standard_Real const theTol)

        Modifier. Sets the tolerance of center of gravily.
        @param theTol
        The value tolerance of center of gravily.

        :type theTol: float

        """
        return _GEOMAlgo.GEOMAlgo_GetInPlace_SetTolCG(self, *args)


    def TolCG(self, *args):
        """
        TolCG(GEOMAlgo_GetInPlace self) -> Standard_Real

        Selector. Returns the tolerance of center of gravily.
        @return
        The value tolerance of center of gravily.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GEOMAlgo.GEOMAlgo_GetInPlace_TolCG(self, *args)


    def Perform(self, *args):
        """
        Perform(GEOMAlgo_GetInPlace self)

        Perform the algorithm.


        """
        return _GEOMAlgo.GEOMAlgo_GetInPlace_Perform(self, *args)


    def IsFound(self, *args):
        """
        IsFound(GEOMAlgo_GetInPlace self) -> Standard_Boolean

        Returns state of the search.
        @return
        Standard_True if the whole argument is found.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_GetInPlace_IsFound(self, *args)


    def CheckData(self, *args):
        """
        CheckData(GEOMAlgo_GetInPlace self)

        Checks data


        """
        return _GEOMAlgo.GEOMAlgo_GetInPlace_CheckData(self, *args)


    def Clear(self, *args):
        """
        Clear(GEOMAlgo_GetInPlace self)

        Clear the internal content.


        """
        return _GEOMAlgo.GEOMAlgo_GetInPlace_Clear(self, *args)


    def ShapesIn(self, *args):
        """
        Returns the map of shapes IN.
        @return
        * Returns the map of shapes IN.
        The Key - the (sub)shape of the argument [What].
        The Item- the (sub)shapes of the shape [Where] that have
        the state IN in respect of [What].

        :rtype: OCC.wrapper.GEOMAlgo.GEOMAlgo_DataMapOfShapeMapOfShape

        """
        res = _GEOMAlgo.GEOMAlgo_GetInPlace_ShapesIn(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ShapesOn(self, *args):
        """
        Returns the map of shapes ON.
        @return
        Returns the map of shapes ON.
        The Key - the (sub)shape of the argument [What].
        The Item- the (sub)shapes of the shape [Where] that have
        the state ON in respect of [What].

        :rtype: OCC.wrapper.GEOMAlgo.GEOMAlgo_DataMapOfShapeMapOfShape

        """
        res = _GEOMAlgo.GEOMAlgo_GetInPlace_ShapesOn(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Result(self, *args):
        """
        Returns the result that includes parts of the whole and whole from parts.

        The Result is the parts (taken from myShapeWhere) that correspond to
        myArgument (the whole one or its part). To check if the whole myArgument
        is found in myShapeWhere it is possible to use the method IsFound.

        The Result is a compound.

        @return
        - the compound of the parts from myShapeWhere 
        that correspond to the myArgument if success.
        - NULL shape otherwise

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _GEOMAlgo.GEOMAlgo_GetInPlace_Result(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_GetInPlace
GEOMAlgo_GetInPlace_swigregister = _GEOMAlgo.GEOMAlgo_GetInPlace_swigregister
GEOMAlgo_GetInPlace_swigregister(GEOMAlgo_GetInPlace)

class GEOMAlgo_GlueDetector(GEOMAlgo_GluerAlgo, GEOMAlgo_Algo):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(GEOMAlgo_GlueDetector self) -> GEOMAlgo_GlueDetector"""
        this = _GEOMAlgo.new_GEOMAlgo_GlueDetector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """Perform(GEOMAlgo_GlueDetector self)"""
        return _GEOMAlgo.GEOMAlgo_GlueDetector_Perform(self, *args)


    def StickedShapes(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeListOfShape

        """
        res = _GEOMAlgo.GEOMAlgo_GlueDetector_StickedShapes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_GlueDetector
GEOMAlgo_GlueDetector_swigregister = _GEOMAlgo.GEOMAlgo_GlueDetector_swigregister
GEOMAlgo_GlueDetector_swigregister(GEOMAlgo_GlueDetector)

class Handle_GEOMAlgo_ClsfSurf(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GEOMAlgo_ClsfSurf self)

        Nullify the handle


        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GEOMAlgo_ClsfSurf self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GEOMAlgo_ClsfSurf self, GEOMAlgo_ClsfSurf thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GEOMAlgo_ClsfSurf self, Handle_GEOMAlgo_ClsfSurf theHandle) -> Handle_GEOMAlgo_ClsfSurf
        assign(Handle_GEOMAlgo_ClsfSurf self, GEOMAlgo_ClsfSurf thePtr) -> Handle_GEOMAlgo_ClsfSurf
        assign(Handle_GEOMAlgo_ClsfSurf self, Handle_GEOMAlgo_ClsfSurf theHandle) -> Handle_GEOMAlgo_ClsfSurf

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GEOMAlgo_ClsfSurf self) -> GEOMAlgo_ClsfSurf

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GEOMAlgo_ClsfSurf self) -> GEOMAlgo_ClsfSurf

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GEOMAlgo_ClsfSurf self) -> GEOMAlgo_ClsfSurf

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf___ref__(self, *args)


    def __hash__(self):
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GEOMAlgo.new_Handle_GEOMAlgo_ClsfSurf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_DownCast)
    __swig_destroy__ = _GEOMAlgo.delete_Handle_GEOMAlgo_ClsfSurf

    def SetSurface(self, *args):
        """
        SetSurface(Handle_GEOMAlgo_ClsfSurf self, Handle_Geom_Surface aS)

        :type aS: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_SetSurface(self, *args)


    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Perform(self, *args):
        """Perform(Handle_GEOMAlgo_ClsfSurf self)"""
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_Perform(self, *args)


    def CheckData(self, *args):
        """CheckData(Handle_GEOMAlgo_ClsfSurf self)"""
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_CheckData(self, *args)


    def CanBeON(self, *args):
        """
        CanBeON(Handle_GEOMAlgo_ClsfSurf self, Handle_Geom_Curve aC) -> Standard_Boolean
        CanBeON(Handle_GEOMAlgo_ClsfSurf self, Handle_Geom_Surface aST) -> Standard_Boolean

        :type aST: OCC.wrapper.Geom.Handle_Geom_Surface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_CanBeON(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GEOMAlgo_ClsfSurf self) -> char const *

        :rtype: const char *

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPnt(self, *args):
        """
        SetPnt(Handle_GEOMAlgo_ClsfSurf self, gp_Pnt aP)

        :type aP: OCC.wrapper.gp.gp_Pnt

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_SetPnt(self, *args)


    def Pnt(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_Pnt(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_GEOMAlgo_ClsfSurf self, Standard_Real const aT)

        :type aT: float

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_SetTolerance(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(Handle_GEOMAlgo_ClsfSurf self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_Tolerance(self, *args)


    def State(self, *args):
        """
        State(Handle_GEOMAlgo_ClsfSurf self) -> TopAbs_State

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_State(self, *args)


    def CheckResult(self, *args):
        """CheckResult(Handle_GEOMAlgo_ClsfSurf self)"""
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_CheckResult(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_GEOMAlgo_ClsfSurf self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_ErrorStatus(self, *args)


    def WarningStatus(self, *args):
        """
        WarningStatus(Handle_GEOMAlgo_ClsfSurf self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_WarningStatus(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GEOMAlgo_ClsfSurf self)

        Memory deallocator for transient classes


        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GEOMAlgo_ClsfSurf self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GEOMAlgo_ClsfSurf self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GEOMAlgo_ClsfSurf self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GEOMAlgo_ClsfSurf self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GEOMAlgo_ClsfSurf self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GEOMAlgo_ClsfSurf self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GEOMAlgo_ClsfSurf self)

        Increments the reference counter of this object


        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GEOMAlgo_ClsfSurf self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_DecrementRefCounter(self, *args)

Handle_GEOMAlgo_ClsfSurf_swigregister = _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_swigregister
Handle_GEOMAlgo_ClsfSurf_swigregister(Handle_GEOMAlgo_ClsfSurf)

def Handle_GEOMAlgo_ClsfSurf_DownCast(thing):
    return _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_DownCast(thing)
Handle_GEOMAlgo_ClsfSurf_DownCast = _GEOMAlgo.Handle_GEOMAlgo_ClsfSurf_DownCast

class Handle_GEOMAlgo_ClsfSolid(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GEOMAlgo_ClsfSolid self)

        Nullify the handle


        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GEOMAlgo_ClsfSolid self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GEOMAlgo_ClsfSolid self, GEOMAlgo_ClsfSolid thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GEOMAlgo_ClsfSolid self, Handle_GEOMAlgo_ClsfSolid theHandle) -> Handle_GEOMAlgo_ClsfSolid
        assign(Handle_GEOMAlgo_ClsfSolid self, GEOMAlgo_ClsfSolid thePtr) -> Handle_GEOMAlgo_ClsfSolid
        assign(Handle_GEOMAlgo_ClsfSolid self, Handle_GEOMAlgo_ClsfSolid theHandle) -> Handle_GEOMAlgo_ClsfSolid

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GEOMAlgo_ClsfSolid self) -> GEOMAlgo_ClsfSolid

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GEOMAlgo_ClsfSolid self) -> GEOMAlgo_ClsfSolid

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GEOMAlgo_ClsfSolid self) -> GEOMAlgo_ClsfSolid

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid___ref__(self, *args)


    def __hash__(self):
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GEOMAlgo.new_Handle_GEOMAlgo_ClsfSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_DownCast)
    __swig_destroy__ = _GEOMAlgo.delete_Handle_GEOMAlgo_ClsfSolid

    def SetShape(self, *args):
        """
        SetShape(Handle_GEOMAlgo_ClsfSolid self, TopoDS_Shape aS)

        :type aS: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_SetShape(self, *args)


    def Shape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Perform(self, *args):
        """Perform(Handle_GEOMAlgo_ClsfSolid self)"""
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_Perform(self, *args)


    def CheckData(self, *args):
        """CheckData(Handle_GEOMAlgo_ClsfSolid self)"""
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_CheckData(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GEOMAlgo_ClsfSolid self) -> char const *

        :rtype: const char *

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPnt(self, *args):
        """
        SetPnt(Handle_GEOMAlgo_ClsfSolid self, gp_Pnt aP)

        :type aP: OCC.wrapper.gp.gp_Pnt

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_SetPnt(self, *args)


    def Pnt(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_Pnt(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_GEOMAlgo_ClsfSolid self, Standard_Real const aT)

        :type aT: float

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_SetTolerance(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(Handle_GEOMAlgo_ClsfSolid self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_Tolerance(self, *args)


    def State(self, *args):
        """
        State(Handle_GEOMAlgo_ClsfSolid self) -> TopAbs_State

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_State(self, *args)


    def CanBeON(self, *args):
        """
        CanBeON(Handle_GEOMAlgo_ClsfSolid self, Handle_Geom_Curve aCT) -> Standard_Boolean
        CanBeON(Handle_GEOMAlgo_ClsfSolid self, Handle_Geom_Surface aST) -> Standard_Boolean

        :type aST: OCC.wrapper.Geom.Handle_Geom_Surface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_CanBeON(self, *args)


    def CheckResult(self, *args):
        """CheckResult(Handle_GEOMAlgo_ClsfSolid self)"""
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_CheckResult(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_GEOMAlgo_ClsfSolid self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_ErrorStatus(self, *args)


    def WarningStatus(self, *args):
        """
        WarningStatus(Handle_GEOMAlgo_ClsfSolid self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_WarningStatus(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GEOMAlgo_ClsfSolid self)

        Memory deallocator for transient classes


        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GEOMAlgo_ClsfSolid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GEOMAlgo_ClsfSolid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GEOMAlgo_ClsfSolid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GEOMAlgo_ClsfSolid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GEOMAlgo_ClsfSolid self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GEOMAlgo_ClsfSolid self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GEOMAlgo_ClsfSolid self)

        Increments the reference counter of this object


        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GEOMAlgo_ClsfSolid self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_DecrementRefCounter(self, *args)

Handle_GEOMAlgo_ClsfSolid_swigregister = _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_swigregister
Handle_GEOMAlgo_ClsfSolid_swigregister(Handle_GEOMAlgo_ClsfSolid)

def Handle_GEOMAlgo_ClsfSolid_DownCast(thing):
    return _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_DownCast(thing)
Handle_GEOMAlgo_ClsfSolid_DownCast = _GEOMAlgo.Handle_GEOMAlgo_ClsfSolid_DownCast

class NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,Bnd_Box,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,Bnd_Box,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,Bnd_Box,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,Bnd_Box,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _GEOMAlgo.new_NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1, Bnd_Box theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, Standard_Integer const theIndex, TopoDS_Shape theKey1, Bnd_Box theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self)

        RemoveLast


        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, Standard_Integer const theIndex) -> Bnd_Box

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Bnd_Box

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Bnd_Box

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Bnd_Box

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _GEOMAlgo.delete_NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher
NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_swigregister = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher)

class NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _GEOMAlgo.new_NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GEOMAlgo.delete_NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher_IteratorHelper)


try:
	GEOMAlgo_IndexedDataMapOfShapeBox = NCollection_IndexedDataMap_TopoDS_Shape_Bnd_Box_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopTools_IndexedMapOfShape,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopTools_IndexedMapOfShape,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopTools_IndexedMapOfShape,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopTools_IndexedMapOfShape,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _GEOMAlgo.new_NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher self, Standard_Integer const theIndex, TopoDS_Shape theKey1, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher self)

        RemoveLast


        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher self, Standard_Integer const theIndex) -> NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _GEOMAlgo.delete_NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher
NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_swigregister = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher)

class NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _GEOMAlgo.new_NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GEOMAlgo.delete_NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher_IteratorHelper)


try:
	GEOMAlgo_IndexedDataMapOfShapeIndexedMapOfShape = NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,GEOMAlgo_ShapeInfo,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,GEOMAlgo_ShapeInfo,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,GEOMAlgo_ShapeInfo,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,GEOMAlgo_ShapeInfo,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _GEOMAlgo.new_NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1, GEOMAlgo_ShapeInfo theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher self, Standard_Integer const theIndex, TopoDS_Shape theKey1, GEOMAlgo_ShapeInfo theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher self)

        RemoveLast


        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher self, Standard_Integer const theIndex) -> GEOMAlgo_ShapeInfo

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> GEOMAlgo_ShapeInfo

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> GEOMAlgo_ShapeInfo

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> GEOMAlgo_ShapeInfo

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _GEOMAlgo.delete_NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher
NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_swigregister = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher)

class NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _GEOMAlgo.new_NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GEOMAlgo.delete_NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _GEOMAlgo.NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher_IteratorHelper)


try:
	GEOMAlgo_IndexedDataMapOfShapeShapeInfo = NCollection_IndexedDataMap_TopoDS_Shape_GEOMAlgo_ShapeInfo_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_UBTree_Standard_Integer_GEOMAlgo_BndSphere(object):
    """
    The algorithm of unbalanced binary tree of overlapped bounding boxes.

    Once the tree of boxes  of geometric objects is constructed, the algorithm
    is capable of fast geometric selection of objects.  The tree can be easily
    updated by adding to it a new object with bounding box.

    The time of adding to the tree  of one object is O(log(N)), where N is the
    total number of  objects, so the time  of building a tree of  N objects is
    O(N(log(N)). The search time of one object is O(log(N)).

    Defining  various classes  inheriting NCollection_UBTree::Selector  we can
    perform various kinds of selection over the same b-tree object

    The object  may be of any  type allowing copying. Among  the best suitable
    solutions there can  be a pointer to an object,  handled object or integer
    index of object inside some  collection.  The bounding object may have any
    dimension  and  geometry. The  minimal  interface  of TheBndType  (besides
    public empty and copy constructor and operator =) used in UBTree algorithm
    is as the following:
    @code
    class MyBndType
    {
    public:
    inline void                   Add (const MyBndType& other);
    // Updates me with other bounding

    inline Standard_Boolean       IsOut (const MyBndType& other) const;
    // Classifies other bounding relatively me

    inline Standard_Real          SquareExtent() const;
    // Computes the squared maximal linear extent of me.
    // (For box it is the squared diagonal of box)
    };
    @endcode
    To select objects you need to define a class derived from UBTree::Selector
    that  should  redefine  the  necessary  virtual methods  to  maintain  the
    selection condition.  The object  of this class  is also used  to retrieve
    selected objects after search.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        The algorithm of unbalanced binary tree of overlapped bounding boxes.

        Once the tree of boxes  of geometric objects is constructed, the algorithm
        is capable of fast geometric selection of objects.  The tree can be easily
        updated by adding to it a new object with bounding box.

        The time of adding to the tree  of one object is O(log(N)), where N is the
        total number of  objects, so the time  of building a tree of  N objects is
        O(N(log(N)). The search time of one object is O(log(N)).

        Defining  various classes  inheriting NCollection_UBTree::Selector  we can
        perform various kinds of selection over the same b-tree object

        The object  may be of any  type allowing copying. Among  the best suitable
        solutions there can  be a pointer to an object,  handled object or integer
        index of object inside some  collection.  The bounding object may have any
        dimension  and  geometry. The  minimal  interface  of TheBndType  (besides
        public empty and copy constructor and operator =) used in UBTree algorithm
        is as the following:
        @code
        class MyBndType
        {
        public:
        inline void                   Add (const MyBndType& other);
        // Updates me with other bounding

        inline Standard_Boolean       IsOut (const MyBndType& other) const;
        // Classifies other bounding relatively me

        inline Standard_Real          SquareExtent() const;
        // Computes the squared maximal linear extent of me.
        // (For box it is the squared diagonal of box)
        };
        @endcode
        To select objects you need to define a class derived from UBTree::Selector
        that  should  redefine  the  necessary  virtual methods  to  maintain  the
        selection condition.  The object  of this class  is also used  to retrieve
        selected objects after search.
        """
        this = _GEOMAlgo.new_NCollection_UBTree_Standard_Integer_GEOMAlgo_BndSphere(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args):
        """
        Add(NCollection_UBTree_Standard_Integer_GEOMAlgo_BndSphere self, int const & theObj, GEOMAlgo_BndSphere theBnd) -> Standard_Boolean

        Update the tree with a new object and its bounding box.
        @param theObj
        added object
        @param theBnd
        bounding box of the object.
        @return
        always True

        :type theObj: const TheObjType &
        :type theBnd: const TheBndType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.NCollection_UBTree_Standard_Integer_GEOMAlgo_BndSphere_Add(self, *args)


    def Select(self, *args):
        """
        Select(NCollection_UBTree_Standard_Integer_GEOMAlgo_BndSphere self, NCollection_UBTree< Standard_Integer,GEOMAlgo_BndSphere >::Selector & theSelector) -> Standard_Integer

        Searches in the branch all objects conforming to the given selector.
        @return
        the number of objects accepted

        :type theBranch: OCC.wrapper.NCollection.TreeNode
        :type theSelector: OCC.wrapper.NCollection.Selector
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.NCollection_UBTree_Standard_Integer_GEOMAlgo_BndSphere_Select(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_UBTree_Standard_Integer_GEOMAlgo_BndSphere self, Handle_NCollection_BaseAllocator aNewAlloc=0)

        Clears the contents of the tree.
        @param aNewAlloc
        Optional:   a new allocator that will be used when the tree is rebuilt
        anew. This makes sense if the memory allocator needs re-initialisation
        (like NCollection_IncAllocator).  By default the previous allocator is
        kept.

        :type aNewAlloc: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _GEOMAlgo.NCollection_UBTree_Standard_Integer_GEOMAlgo_BndSphere_Clear(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_UBTree_Standard_Integer_GEOMAlgo_BndSphere self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.NCollection_UBTree_Standard_Integer_GEOMAlgo_BndSphere_IsEmpty(self, *args)


    def Root(self, *args):
        """
        @return
        the root node of the tree

        :rtype: OCC.wrapper.NCollection.TreeNode

        """
        res = _GEOMAlgo.NCollection_UBTree_Standard_Integer_GEOMAlgo_BndSphere_Root(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Allocator(self, *args):
        """
        Recommended to be used only in sub-classes.
        @return
        Allocator object used in this instance of UBTree.

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        res = _GEOMAlgo.NCollection_UBTree_Standard_Integer_GEOMAlgo_BndSphere_Allocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GEOMAlgo.delete_NCollection_UBTree_Standard_Integer_GEOMAlgo_BndSphere
NCollection_UBTree_Standard_Integer_GEOMAlgo_BndSphere_swigregister = _GEOMAlgo.NCollection_UBTree_Standard_Integer_GEOMAlgo_BndSphere_swigregister
NCollection_UBTree_Standard_Integer_GEOMAlgo_BndSphere_swigregister(NCollection_UBTree_Standard_Integer_GEOMAlgo_BndSphere)


try:
	GEOMAlgo_BndSphereTree = NCollection_UBTree_Standard_Integer_GEOMAlgo_BndSphere
except NameError:
	pass # does not exist, probably ignored

class Handle_GEOMAlgo_HAlgo(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GEOMAlgo_HAlgo self)

        Nullify the handle


        """
        return _GEOMAlgo.Handle_GEOMAlgo_HAlgo_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GEOMAlgo_HAlgo self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GEOMAlgo.Handle_GEOMAlgo_HAlgo_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GEOMAlgo_HAlgo self, GEOMAlgo_HAlgo thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GEOMAlgo.Handle_GEOMAlgo_HAlgo_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GEOMAlgo_HAlgo self, Handle_GEOMAlgo_HAlgo theHandle) -> Handle_GEOMAlgo_HAlgo
        assign(Handle_GEOMAlgo_HAlgo self, GEOMAlgo_HAlgo thePtr) -> Handle_GEOMAlgo_HAlgo
        assign(Handle_GEOMAlgo_HAlgo self, Handle_GEOMAlgo_HAlgo theHandle) -> Handle_GEOMAlgo_HAlgo

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GEOMAlgo.Handle_GEOMAlgo_HAlgo_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GEOMAlgo_HAlgo self) -> GEOMAlgo_HAlgo

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GEOMAlgo.Handle_GEOMAlgo_HAlgo_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GEOMAlgo_HAlgo self) -> GEOMAlgo_HAlgo

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GEOMAlgo.Handle_GEOMAlgo_HAlgo___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GEOMAlgo_HAlgo self) -> GEOMAlgo_HAlgo

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GEOMAlgo.Handle_GEOMAlgo_HAlgo___ref__(self, *args)


    def __hash__(self):
        return _GEOMAlgo.Handle_GEOMAlgo_HAlgo___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GEOMAlgo.Handle_GEOMAlgo_HAlgo___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GEOMAlgo.new_Handle_GEOMAlgo_HAlgo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GEOMAlgo.Handle_GEOMAlgo_HAlgo_DownCast)
    __swig_destroy__ = _GEOMAlgo.delete_Handle_GEOMAlgo_HAlgo

    def Perform(self, *args):
        """Perform(Handle_GEOMAlgo_HAlgo self)"""
        return _GEOMAlgo.Handle_GEOMAlgo_HAlgo_Perform(self, *args)


    def CheckData(self, *args):
        """CheckData(Handle_GEOMAlgo_HAlgo self)"""
        return _GEOMAlgo.Handle_GEOMAlgo_HAlgo_CheckData(self, *args)


    def CheckResult(self, *args):
        """CheckResult(Handle_GEOMAlgo_HAlgo self)"""
        return _GEOMAlgo.Handle_GEOMAlgo_HAlgo_CheckResult(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_GEOMAlgo_HAlgo self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.Handle_GEOMAlgo_HAlgo_ErrorStatus(self, *args)


    def WarningStatus(self, *args):
        """
        WarningStatus(Handle_GEOMAlgo_HAlgo self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.Handle_GEOMAlgo_HAlgo_WarningStatus(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GEOMAlgo_HAlgo self) -> char const *

        :rtype: const char *

        """
        return _GEOMAlgo.Handle_GEOMAlgo_HAlgo_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GEOMAlgo.Handle_GEOMAlgo_HAlgo_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GEOMAlgo.Handle_GEOMAlgo_HAlgo_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_GEOMAlgo_HAlgo self)

        Memory deallocator for transient classes


        """
        return _GEOMAlgo.Handle_GEOMAlgo_HAlgo_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GEOMAlgo_HAlgo self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GEOMAlgo_HAlgo self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.Handle_GEOMAlgo_HAlgo_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GEOMAlgo_HAlgo self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GEOMAlgo_HAlgo self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.Handle_GEOMAlgo_HAlgo_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GEOMAlgo_HAlgo self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GEOMAlgo.Handle_GEOMAlgo_HAlgo_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GEOMAlgo_HAlgo self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.Handle_GEOMAlgo_HAlgo_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GEOMAlgo_HAlgo self)

        Increments the reference counter of this object


        """
        return _GEOMAlgo.Handle_GEOMAlgo_HAlgo_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GEOMAlgo_HAlgo self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.Handle_GEOMAlgo_HAlgo_DecrementRefCounter(self, *args)

Handle_GEOMAlgo_HAlgo_swigregister = _GEOMAlgo.Handle_GEOMAlgo_HAlgo_swigregister
Handle_GEOMAlgo_HAlgo_swigregister(Handle_GEOMAlgo_HAlgo)

def Handle_GEOMAlgo_HAlgo_DownCast(thing):
    return _GEOMAlgo.Handle_GEOMAlgo_HAlgo_DownCast(thing)
Handle_GEOMAlgo_HAlgo_DownCast = _GEOMAlgo.Handle_GEOMAlgo_HAlgo_DownCast

class GEOMAlgo_SolidSolid(GEOMAlgo_ShellSolid):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(GEOMAlgo_SolidSolid self) -> GEOMAlgo_SolidSolid"""
        this = _GEOMAlgo.new_GEOMAlgo_SolidSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """Perform(GEOMAlgo_SolidSolid self)"""
        return _GEOMAlgo.GEOMAlgo_SolidSolid_Perform(self, *args)


    def SetShape2(self, *args):
        """
        SetShape2(GEOMAlgo_SolidSolid self, TopoDS_Shape aS)

        :type aS: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _GEOMAlgo.GEOMAlgo_SolidSolid_SetShape2(self, *args)


    def Shape2(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _GEOMAlgo.GEOMAlgo_SolidSolid_Shape2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_SolidSolid
GEOMAlgo_SolidSolid_swigregister = _GEOMAlgo.GEOMAlgo_SolidSolid_swigregister
GEOMAlgo_SolidSolid_swigregister(GEOMAlgo_SolidSolid)


try:
	TColStd_MapIntegerHasher = TColStd.NCollection_DefaultHasher_Standard_Integer
except AttributeError:
	pass # does not exist, probably ignored


try:
	GEOMAlgo_ListOfPnt = NCollection_List_gp_Pnt
except NameError:
	pass # does not exist, probably ignored

class GEOMAlgo_AlgoTools(object):
    """Auxiliary tools for Algorithms <br>"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FaceNormal(*args):
        """
        FaceNormal(TopoDS_Face aF, Standard_Real const U, Standard_Real const V, gp_Vec aN)

        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type U: float
        :type V: float
        :type aN: OCC.wrapper.gp.gp_Vec

        """
        return _GEOMAlgo.GEOMAlgo_AlgoTools_FaceNormal(*args)

    FaceNormal = staticmethod(FaceNormal)

    def PntInFace(*args):
        """
        PntInFace(TopoDS_Face theF, gp_Pnt theP, gp_Pnt2d theP2D) -> Standard_Integer

        Computes a point <theP> inside the face <theF>. <br>
        <theP2D> - 2D representation of <theP> <br>
        on the surface of <theF> <br>
        Returns 0 in case of success. <br>

        :type theF: OCC.wrapper.TopoDS.TopoDS_Face
        :type theP: OCC.wrapper.gp.gp_Pnt
        :type theP2D: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.GEOMAlgo_AlgoTools_PntInFace(*args)

    PntInFace = staticmethod(PntInFace)

    def IsCompositeShape(*args):
        """
        IsCompositeShape(TopoDS_Shape aS) -> Standard_Boolean

        :type aS: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_AlgoTools_IsCompositeShape(*args)

    IsCompositeShape = staticmethod(IsCompositeShape)

    def BuildTriangulation(*args):
        """
        BuildTriangulation(TopoDS_Shape aS) -> Standard_Boolean

        :type aS: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_AlgoTools_BuildTriangulation(*args)

    BuildTriangulation = staticmethod(BuildTriangulation)

    def RefineSDShapes(*args):
        """
        RefineSDShapes(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher aMSD, Standard_Real const aTol, Handle_IntTools_Context aCtx) -> Standard_Integer

        :type aMSD: OCC.wrapper.GEOMAlgo.GEOMAlgo_IndexedDataMapOfPassKeyShapeListOfShape
        :type aTol: float
        :type aCtx: OCC.wrapper.IntTools.Handle_IntTools_Context
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.GEOMAlgo_AlgoTools_RefineSDShapes(*args)

    RefineSDShapes = staticmethod(RefineSDShapes)

    def FindSDShapes(*args):
        """
        FindSDShapes(NCollection_List_TopoDS_Shape aLE, Standard_Real const aTol, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher aMEE, Handle_IntTools_Context aCtx) -> Standard_Integer
        FindSDShapes(TopoDS_Shape aE1, NCollection_List_TopoDS_Shape aLE, Standard_Real const aTol, NCollection_List_TopoDS_Shape aLESD, Handle_IntTools_Context aCtx) -> Standard_Integer

        :type aE1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aLE: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type aTol: float
        :type aLESD: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type aCtx: OCC.wrapper.IntTools.Handle_IntTools_Context
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.GEOMAlgo_AlgoTools_FindSDShapes(*args)

    FindSDShapes = staticmethod(FindSDShapes)

    def PointOnShape(*args):
        """
        PointOnShape(TopoDS_Shape aS, gp_Pnt aP3D)

        :type aS: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aP3D: OCC.wrapper.gp.gp_Pnt

        """
        return _GEOMAlgo.GEOMAlgo_AlgoTools_PointOnShape(*args)

    PointOnShape = staticmethod(PointOnShape)

    def PointOnEdge(*args):
        """
        PointOnEdge(TopoDS_Edge aE, gp_Pnt aP3D)
        PointOnEdge(TopoDS_Edge aE, Standard_Real const aT, gp_Pnt aP3D)

        :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aT: float
        :type aP3D: OCC.wrapper.gp.gp_Pnt

        """
        return _GEOMAlgo.GEOMAlgo_AlgoTools_PointOnEdge(*args)

    PointOnEdge = staticmethod(PointOnEdge)

    def PointOnFace(*args):
        """
        PointOnFace(TopoDS_Face aF, gp_Pnt aP3D)
        PointOnFace(TopoDS_Face aF, Standard_Real const aU, Standard_Real const aV, gp_Pnt aP3D)

        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type aU: float
        :type aV: float
        :type aP3D: OCC.wrapper.gp.gp_Pnt

        """
        return _GEOMAlgo.GEOMAlgo_AlgoTools_PointOnFace(*args)

    PointOnFace = staticmethod(PointOnFace)

    def ProjectPointOnShape(*args):
        """
        ProjectPointOnShape(gp_Pnt aP1, TopoDS_Shape aS, gp_Pnt aP2, Handle_IntTools_Context aCtx) -> Standard_Boolean

        :type aP1: OCC.wrapper.gp.gp_Pnt
        :type aS: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aP2: OCC.wrapper.gp.gp_Pnt
        :type aCtx: OCC.wrapper.IntTools.Handle_IntTools_Context
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_AlgoTools_ProjectPointOnShape(*args)

    ProjectPointOnShape = staticmethod(ProjectPointOnShape)

    def RefinePCurveForEdgeOnFace(*args):
        """
        RefinePCurveForEdgeOnFace(TopoDS_Edge aE, TopoDS_Face aF, Standard_Real const aUMin, Standard_Real const aUMax)

        :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type aUMin: float
        :type aUMax: float

        """
        return _GEOMAlgo.GEOMAlgo_AlgoTools_RefinePCurveForEdgeOnFace(*args)

    RefinePCurveForEdgeOnFace = staticmethod(RefinePCurveForEdgeOnFace)

    def IsUPeriodic(*args):
        """
        IsUPeriodic(Handle_Geom_Surface aS) -> Standard_Boolean

        :type aS: OCC.wrapper.Geom.Handle_Geom_Surface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_AlgoTools_IsUPeriodic(*args)

    IsUPeriodic = staticmethod(IsUPeriodic)

    def MakeContainer(*args):
        """
        MakeContainer(TopAbs_ShapeEnum const theType, TopoDS_Shape theC)

        :type theType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type theC: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _GEOMAlgo.GEOMAlgo_AlgoTools_MakeContainer(*args)

    MakeContainer = staticmethod(MakeContainer)

    def IsSplitToReverse(*args):
        """
        IsSplitToReverse(TopoDS_Edge theSplit, TopoDS_Edge theEdge, Handle_IntTools_Context theCtx) -> Standard_Boolean

        :type theSplit: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theCtx: OCC.wrapper.IntTools.Handle_IntTools_Context
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.GEOMAlgo_AlgoTools_IsSplitToReverse(*args)

    IsSplitToReverse = staticmethod(IsSplitToReverse)

    def BuildPCurveForEdgeOnFace(*args):
        """
        BuildPCurveForEdgeOnFace(TopoDS_Edge aEold, TopoDS_Edge aEnew, TopoDS_Face aF, Handle_IntTools_Context aCtx) -> Standard_Integer

        :type aEold: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aEnew: OCC.wrapper.TopoDS.TopoDS_Edge
        :type aF: OCC.wrapper.TopoDS.TopoDS_Face
        :type aCtx: OCC.wrapper.IntTools.Handle_IntTools_Context
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.GEOMAlgo_AlgoTools_BuildPCurveForEdgeOnFace(*args)

    BuildPCurveForEdgeOnFace = staticmethod(BuildPCurveForEdgeOnFace)

    def FindChains(*args):
        """
        FindChains(GEOMAlgo_ListOfCoupleOfShapes const & aLCS, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher aMapChains)
        FindChains(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher aMCV, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher aMapChains)

        :type aMCV: OCC.wrapper.GEOMAlgo.GEOMAlgo_IndexedDataMapOfShapeIndexedMapOfShape
        :type aMapChains: OCC.wrapper.GEOMAlgo.GEOMAlgo_IndexedDataMapOfShapeIndexedMapOfShape

        """
        return _GEOMAlgo.GEOMAlgo_AlgoTools_FindChains(*args)

    FindChains = staticmethod(FindChains)

    def CopyShape(*args):
        """
        CopyShape(TopoDS_Shape aS, TopoDS_Shape aSC)
        CopyShape(TopoDS_Shape aS, TopoDS_Shape aSC, NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher aMSS)

        :type aS: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aSC: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aMSS: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeShape

        """
        return _GEOMAlgo.GEOMAlgo_AlgoTools_CopyShape(*args)

    CopyShape = staticmethod(CopyShape)

    def __init__(self):
        """Auxiliary tools for Algorithms <br>"""
        this = _GEOMAlgo.new_GEOMAlgo_AlgoTools()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GEOMAlgo.delete_GEOMAlgo_AlgoTools
GEOMAlgo_AlgoTools_swigregister = _GEOMAlgo.GEOMAlgo_AlgoTools_swigregister
GEOMAlgo_AlgoTools_swigregister(GEOMAlgo_AlgoTools)

def GEOMAlgo_AlgoTools_FaceNormal(*args):
    """
    GEOMAlgo_AlgoTools_FaceNormal(TopoDS_Face aF, Standard_Real const U, Standard_Real const V, gp_Vec aN)

    :type aF: OCC.wrapper.TopoDS.TopoDS_Face
    :type U: float
    :type V: float
    :type aN: OCC.wrapper.gp.gp_Vec

    """
    return _GEOMAlgo.GEOMAlgo_AlgoTools_FaceNormal(*args)

def GEOMAlgo_AlgoTools_PntInFace(*args):
    """
    GEOMAlgo_AlgoTools_PntInFace(TopoDS_Face theF, gp_Pnt theP, gp_Pnt2d theP2D) -> Standard_Integer

    Computes a point <theP> inside the face <theF>. <br>
    <theP2D> - 2D representation of <theP> <br>
    on the surface of <theF> <br>
    Returns 0 in case of success. <br>

    :type theF: OCC.wrapper.TopoDS.TopoDS_Face
    :type theP: OCC.wrapper.gp.gp_Pnt
    :type theP2D: OCC.wrapper.gp.gp_Pnt2d
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _GEOMAlgo.GEOMAlgo_AlgoTools_PntInFace(*args)

def GEOMAlgo_AlgoTools_IsCompositeShape(*args):
    """
    GEOMAlgo_AlgoTools_IsCompositeShape(TopoDS_Shape aS) -> Standard_Boolean

    :type aS: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _GEOMAlgo.GEOMAlgo_AlgoTools_IsCompositeShape(*args)

def GEOMAlgo_AlgoTools_BuildTriangulation(*args):
    """
    GEOMAlgo_AlgoTools_BuildTriangulation(TopoDS_Shape aS) -> Standard_Boolean

    :type aS: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _GEOMAlgo.GEOMAlgo_AlgoTools_BuildTriangulation(*args)

def GEOMAlgo_AlgoTools_RefineSDShapes(*args):
    """
    GEOMAlgo_AlgoTools_RefineSDShapes(NCollection_IndexedDataMap_GEOMAlgo_PassKeyShape_TopTools_ListOfShape_GEOMAlgo_PassKeyShapeMapHasher aMSD, Standard_Real const aTol, Handle_IntTools_Context aCtx) -> Standard_Integer

    :type aMSD: OCC.wrapper.GEOMAlgo.GEOMAlgo_IndexedDataMapOfPassKeyShapeListOfShape
    :type aTol: float
    :type aCtx: OCC.wrapper.IntTools.Handle_IntTools_Context
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _GEOMAlgo.GEOMAlgo_AlgoTools_RefineSDShapes(*args)

def GEOMAlgo_AlgoTools_FindSDShapes(*args):
    """
    FindSDShapes(NCollection_List_TopoDS_Shape aLE, Standard_Real const aTol, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher aMEE, Handle_IntTools_Context aCtx) -> Standard_Integer
    GEOMAlgo_AlgoTools_FindSDShapes(TopoDS_Shape aE1, NCollection_List_TopoDS_Shape aLE, Standard_Real const aTol, NCollection_List_TopoDS_Shape aLESD, Handle_IntTools_Context aCtx) -> Standard_Integer

    :type aE1: OCC.wrapper.TopoDS.TopoDS_Shape
    :type aLE: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type aTol: float
    :type aLESD: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type aCtx: OCC.wrapper.IntTools.Handle_IntTools_Context
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _GEOMAlgo.GEOMAlgo_AlgoTools_FindSDShapes(*args)

def GEOMAlgo_AlgoTools_PointOnShape(*args):
    """
    GEOMAlgo_AlgoTools_PointOnShape(TopoDS_Shape aS, gp_Pnt aP3D)

    :type aS: OCC.wrapper.TopoDS.TopoDS_Shape
    :type aP3D: OCC.wrapper.gp.gp_Pnt

    """
    return _GEOMAlgo.GEOMAlgo_AlgoTools_PointOnShape(*args)

def GEOMAlgo_AlgoTools_PointOnEdge(*args):
    """
    PointOnEdge(TopoDS_Edge aE, gp_Pnt aP3D)
    GEOMAlgo_AlgoTools_PointOnEdge(TopoDS_Edge aE, Standard_Real const aT, gp_Pnt aP3D)

    :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
    :type aT: float
    :type aP3D: OCC.wrapper.gp.gp_Pnt

    """
    return _GEOMAlgo.GEOMAlgo_AlgoTools_PointOnEdge(*args)

def GEOMAlgo_AlgoTools_PointOnFace(*args):
    """
    PointOnFace(TopoDS_Face aF, gp_Pnt aP3D)
    GEOMAlgo_AlgoTools_PointOnFace(TopoDS_Face aF, Standard_Real const aU, Standard_Real const aV, gp_Pnt aP3D)

    :type aF: OCC.wrapper.TopoDS.TopoDS_Face
    :type aU: float
    :type aV: float
    :type aP3D: OCC.wrapper.gp.gp_Pnt

    """
    return _GEOMAlgo.GEOMAlgo_AlgoTools_PointOnFace(*args)

def GEOMAlgo_AlgoTools_ProjectPointOnShape(*args):
    """
    GEOMAlgo_AlgoTools_ProjectPointOnShape(gp_Pnt aP1, TopoDS_Shape aS, gp_Pnt aP2, Handle_IntTools_Context aCtx) -> Standard_Boolean

    :type aP1: OCC.wrapper.gp.gp_Pnt
    :type aS: OCC.wrapper.TopoDS.TopoDS_Shape
    :type aP2: OCC.wrapper.gp.gp_Pnt
    :type aCtx: OCC.wrapper.IntTools.Handle_IntTools_Context
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _GEOMAlgo.GEOMAlgo_AlgoTools_ProjectPointOnShape(*args)

def GEOMAlgo_AlgoTools_RefinePCurveForEdgeOnFace(*args):
    """
    GEOMAlgo_AlgoTools_RefinePCurveForEdgeOnFace(TopoDS_Edge aE, TopoDS_Face aF, Standard_Real const aUMin, Standard_Real const aUMax)

    :type aE: OCC.wrapper.TopoDS.TopoDS_Edge
    :type aF: OCC.wrapper.TopoDS.TopoDS_Face
    :type aUMin: float
    :type aUMax: float

    """
    return _GEOMAlgo.GEOMAlgo_AlgoTools_RefinePCurveForEdgeOnFace(*args)

def GEOMAlgo_AlgoTools_IsUPeriodic(*args):
    """
    GEOMAlgo_AlgoTools_IsUPeriodic(Handle_Geom_Surface aS) -> Standard_Boolean

    :type aS: OCC.wrapper.Geom.Handle_Geom_Surface
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _GEOMAlgo.GEOMAlgo_AlgoTools_IsUPeriodic(*args)

def GEOMAlgo_AlgoTools_MakeContainer(*args):
    """
    GEOMAlgo_AlgoTools_MakeContainer(TopAbs_ShapeEnum const theType, TopoDS_Shape theC)

    :type theType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
    :type theC: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _GEOMAlgo.GEOMAlgo_AlgoTools_MakeContainer(*args)

def GEOMAlgo_AlgoTools_IsSplitToReverse(*args):
    """
    GEOMAlgo_AlgoTools_IsSplitToReverse(TopoDS_Edge theSplit, TopoDS_Edge theEdge, Handle_IntTools_Context theCtx) -> Standard_Boolean

    :type theSplit: OCC.wrapper.TopoDS.TopoDS_Edge
    :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
    :type theCtx: OCC.wrapper.IntTools.Handle_IntTools_Context
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _GEOMAlgo.GEOMAlgo_AlgoTools_IsSplitToReverse(*args)

def GEOMAlgo_AlgoTools_BuildPCurveForEdgeOnFace(*args):
    """
    GEOMAlgo_AlgoTools_BuildPCurveForEdgeOnFace(TopoDS_Edge aEold, TopoDS_Edge aEnew, TopoDS_Face aF, Handle_IntTools_Context aCtx) -> Standard_Integer

    :type aEold: OCC.wrapper.TopoDS.TopoDS_Edge
    :type aEnew: OCC.wrapper.TopoDS.TopoDS_Edge
    :type aF: OCC.wrapper.TopoDS.TopoDS_Face
    :type aCtx: OCC.wrapper.IntTools.Handle_IntTools_Context
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _GEOMAlgo.GEOMAlgo_AlgoTools_BuildPCurveForEdgeOnFace(*args)

def GEOMAlgo_AlgoTools_FindChains(*args):
    """
    FindChains(GEOMAlgo_ListOfCoupleOfShapes const & aLCS, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher aMapChains)
    GEOMAlgo_AlgoTools_FindChains(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher aMCV, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_IndexedMapOfShape_TopTools_ShapeMapHasher aMapChains)

    :type aMCV: OCC.wrapper.GEOMAlgo.GEOMAlgo_IndexedDataMapOfShapeIndexedMapOfShape
    :type aMapChains: OCC.wrapper.GEOMAlgo.GEOMAlgo_IndexedDataMapOfShapeIndexedMapOfShape

    """
    return _GEOMAlgo.GEOMAlgo_AlgoTools_FindChains(*args)

def GEOMAlgo_AlgoTools_CopyShape(*args):
    """
    CopyShape(TopoDS_Shape aS, TopoDS_Shape aSC)
    GEOMAlgo_AlgoTools_CopyShape(TopoDS_Shape aS, TopoDS_Shape aSC, NCollection_IndexedDataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher aMSS)

    :type aS: OCC.wrapper.TopoDS.TopoDS_Shape
    :type aSC: OCC.wrapper.TopoDS.TopoDS_Shape
    :type aMSS: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeShape

    """
    return _GEOMAlgo.GEOMAlgo_AlgoTools_CopyShape(*args)

class NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,gp_Pnt,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,gp_Pnt,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,gp_Pnt,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,gp_Pnt,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _GEOMAlgo.new_NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, gp_Pnt theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, gp_Pnt theItem) -> gp_Pnt

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> gp_Pnt

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> gp_Pnt

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> gp_Pnt

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _GEOMAlgo.delete_NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_swigregister = _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _GEOMAlgo.new_NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GEOMAlgo.delete_NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _GEOMAlgo.NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher_IteratorHelper)


try:
	GEOMAlgo_DataMapOfShapePnt = NCollection_DataMap_TopoDS_Shape_gp_Pnt_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored




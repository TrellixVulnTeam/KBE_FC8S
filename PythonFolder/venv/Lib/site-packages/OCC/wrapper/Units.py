# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Units')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Units')
    _Units = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Units', [dirname(__file__)])
        except ImportError:
            import _Units
            return _Units
        try:
            _mod = imp.load_module('_Units', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Units = swig_import_helper()
    del swig_import_helper
else:
    import _Units
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Units.delete_SwigPyIterator

    def value(self):
        return _Units.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Units.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Units.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Units.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Units.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Units.SwigPyIterator_copy(self)

    def next(self):
        return _Units.SwigPyIterator_next(self)

    def __next__(self):
        return _Units.SwigPyIterator___next__(self)

    def previous(self):
        return _Units.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Units.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Units.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Units.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Units.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Units.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Units.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Units.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Units.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Units.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Units.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Units.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Units.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Units.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Units.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Units.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Units.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Units.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Units.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Units.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Units.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Units.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Units.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Units.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Units.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Units.ptr_to_number(item)
ptr_to_number = _Units.ptr_to_number

def HashCode(*args):
    return _Units.HashCode(*args)
HashCode = _Units.HashCode

def ptr_equal(a, b):
    return _Units.ptr_equal(a, b)
ptr_equal = _Units.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
class Units_Token(Standard.Standard_Transient):
    """
    This class defines an elementary word contained in
    a Sentence object.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Units_Token
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Units_Token(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Units_Token self) -> Units_Token
        __init__(Units_Token self, Standard_CString const aword) -> Units_Token
        __init__(Units_Token self, Handle_Units_Token atoken) -> Units_Token
        __init__(Units_Token self, Standard_CString const aword, Standard_CString const amean) -> Units_Token
        __init__(Units_Token self, Standard_CString const aword, Standard_CString const amean, Standard_Real const avalue) -> Units_Token
        __init__(Units_Token self, Standard_CString const aword, Standard_CString const amean, Standard_Real const avalue, Handle_Units_Dimensions adimension) -> Units_Token

        Creates and returns  a  token.  <aword> is   a  string
        containing the   available   word, <amean>   gives the
        signification of  the  token, <avalue> is  the numeric
        value  of the dimension,  and <adimensions>   is   the
        dimension of the given word <aword>.

        :type aword: OCC.wrapper.Standard.Standard_CString
        :type amean: OCC.wrapper.Standard.Standard_CString
        :type avalue: float
        :type adimension: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        this = _Units.new_Units_Token(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Creates(self, *args):
        """
        Creates(Units_Token self) -> Handle_Units_Token

        Creates and returns a  token, which is a ShiftedToken.

        :rtype: OCC.wrapper.Units.Handle_Units_Token

        """
        return _Units.Units_Token_Creates(self, *args)


    def Length(self, *args):
        """
        Length(Units_Token self) -> Standard_Integer

        Returns the length of the word.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Units_Token_Length(self, *args)


    def Word(self, *args):
        """
        Word(Units_Token self) -> TCollection_AsciiString
        Word(Units_Token self, Standard_CString const aword)

        Sets the field <theword> to <aword>.

        :type aword: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Units_Token_Word(self, *args)


    def Mean(self, *args):
        """
        Mean(Units_Token self) -> TCollection_AsciiString
        Mean(Units_Token self, Standard_CString const amean)

        Sets the field <themean> to <amean>.

        :type amean: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Units_Token_Mean(self, *args)


    def Value(self, *args):
        """
        Value(Units_Token self) -> Standard_Real
        Value(Units_Token self, Standard_Real const avalue)

        Sets the field <thevalue> to <avalue>.

        :type avalue: float

        """
        return _Units.Units_Token_Value(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Units_Token self) -> Handle_Units_Dimensions
        Dimensions(Units_Token self, Handle_Units_Dimensions adimensions)

        Sets the field <thedimensions> to <adimensions>.

        :type adimensions: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Units_Token_Dimensions(self, *args)


    def Update(self, *args):
        """
        Update(Units_Token self, Standard_CString const amean)

        Updates     the  token  <me>    with  the   additional
        signification  <amean> by  concatenation   of the  two
        strings   <themean>    and   <amean>.   If    the  two
        significations are  the same  , an information message
        is written in the output device.

        :type amean: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Units_Token_Update(self, *args)


    def Add(self, *args):
        """
        Add(Units_Token self, Standard_Integer const aninteger) -> Handle_Units_Token
        Add(Units_Token self, Handle_Units_Token atoken) -> Handle_Units_Token

        Returns a  token which is  the addition  of  <me>  and
        another token <atoken>. The  addition  is  possible if
        and only if the dimensions are the same.

        :type atoken: OCC.wrapper.Units.Handle_Units_Token
        :rtype: OCC.wrapper.Units.Handle_Units_Token

        """
        return _Units.Units_Token_Add(self, *args)


    def Subtract(self, *args):
        """
        Subtract(Units_Token self, Handle_Units_Token atoken) -> Handle_Units_Token

        Returns a token  which is the  subtraction of <me> and
        another token <atoken>. The subtraction is possible if
        and only if the dimensions are the same.

        :type atoken: OCC.wrapper.Units.Handle_Units_Token
        :rtype: OCC.wrapper.Units.Handle_Units_Token

        """
        return _Units.Units_Token_Subtract(self, *args)


    def Multiply(self, *args):
        """
        Multiply(Units_Token self, Handle_Units_Token atoken) -> Handle_Units_Token

        Returns a  token  which  is the  product of   <me> and
        another token <atoken>.

        :type atoken: OCC.wrapper.Units.Handle_Units_Token
        :rtype: OCC.wrapper.Units.Handle_Units_Token

        """
        return _Units.Units_Token_Multiply(self, *args)


    def Multiplied(self, *args):
        """
        Multiplied(Units_Token self, Standard_Real const avalue) -> Standard_Real

        This   virtual method is   called  by  the Measurement
        methods,  to  compute    the   measurement   during  a
        conversion.

        :type avalue: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Units_Token_Multiplied(self, *args)


    def Divide(self, *args):
        """
        Divide(Units_Token self, Handle_Units_Token atoken) -> Handle_Units_Token

        Returns a token which is the division of <me> by another
        token <atoken>.

        :type atoken: OCC.wrapper.Units.Handle_Units_Token
        :rtype: OCC.wrapper.Units.Handle_Units_Token

        """
        return _Units.Units_Token_Divide(self, *args)


    def Divided(self, *args):
        """
        Divided(Units_Token self, Standard_Real const avalue) -> Standard_Real

        This  virtual  method  is  called by  the  Measurement
        methods,   to   compute   the measurement  during    a
        conversion.

        :type avalue: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Units_Token_Divided(self, *args)


    def Power(self, *args):
        """
        Power(Units_Token self, Handle_Units_Token atoken) -> Handle_Units_Token
        Power(Units_Token self, Standard_Real const anexponent) -> Handle_Units_Token

        Returns a token which is <me> to the power  of <anexponent>.

        :type anexponent: float
        :rtype: OCC.wrapper.Units.Handle_Units_Token

        """
        return _Units.Units_Token_Power(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(Units_Token self, Standard_CString const astring) -> Standard_Boolean
        IsEqual(Units_Token self, Handle_Units_Token atoken) -> Standard_Boolean

        Returns true  if the  field  <theword> and  the string
        <theword> contained  in  the  token <atoken>  are  the
        same, false otherwise.

        :type atoken: OCC.wrapper.Units.Handle_Units_Token
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Units_Token_IsEqual(self, *args)


    def IsNotEqual(self, *args):
        """
        IsNotEqual(Units_Token self, Standard_CString const astring) -> Standard_Boolean
        IsNotEqual(Units_Token self, Handle_Units_Token atoken) -> Standard_Boolean

        Returns false if  the field <theword>  and the  string
        <theword> contained  in the  token  <atoken>  are  the
        same, true otherwise.

        :type atoken: OCC.wrapper.Units.Handle_Units_Token
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Units_Token_IsNotEqual(self, *args)


    def IsLessOrEqual(self, *args):
        """
        IsLessOrEqual(Units_Token self, Standard_CString const astring) -> Standard_Boolean

        Returns   true  if the   field <theword>  is  strictly
        contained at  the beginning  of the string  <astring>,
        false otherwise.

        :type astring: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Units_Token_IsLessOrEqual(self, *args)


    def IsGreater(self, *args):
        """
        IsGreater(Units_Token self, Standard_CString const astring) -> Standard_Boolean
        IsGreater(Units_Token self, Handle_Units_Token atoken) -> Standard_Boolean

        Returns false  if   the field   <theword> is  strictly
        contained at  the  beginning  of the string <astring>,
        true otherwise.

        :type atoken: OCC.wrapper.Units.Handle_Units_Token
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Units_Token_IsGreater(self, *args)


    def IsGreaterOrEqual(self, *args):
        """
        IsGreaterOrEqual(Units_Token self, Handle_Units_Token atoken) -> Standard_Boolean

        Returns true  if  the string <astring>   is   strictly
        contained   at the  beginning  of  the field <theword>
        false otherwise.

        :type atoken: OCC.wrapper.Units.Handle_Units_Token
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Units_Token_IsGreaterOrEqual(self, *args)


    def Dump(self, *args):
        """
        Dump(Units_Token self, Standard_Integer const ashift, Standard_Integer const alevel)

        Useful for debugging

        :type ashift: int
        :type alevel: int

        """
        return _Units.Units_Token_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Units.Units_Token_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Units.Units_Token_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Units_Token_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Units.delete_Units_Token
Units_Token_swigregister = _Units.Units_Token_swigregister
Units_Token_swigregister(Units_Token)

def Units_Token_get_type_name(*args):
    """
    Units_Token_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Units.Units_Token_get_type_name(*args)

def Units_Token_get_type_descriptor(*args):
    """
    Units_Token_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Units.Units_Token_get_type_descriptor(*args)

class Units_ShiftedToken(Units_Token):
    """
    The  ShiftedToken class  inherits   from Token and
    describes tokens which have  a gap in  addition of
    the  multiplicative factor.   This kind  of  token
    allows  the  description of linear functions which
    do not pass through the origin, of the form :

    y = ax  +b

    where <x> and  <y>  are the unknown variables, <a>
    the mutiplicative factor, and <b> the gap relative
    to the ordinate axis.

    An example is the  tranlation between the  Celsius
    and Fahrenheit degree of temperature.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Units_ShiftedToken
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Units_ShiftedToken(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Units_ShiftedToken self, Standard_CString const aword, Standard_CString const amean, Standard_Real const avalue, Standard_Real const amove, Handle_Units_Dimensions adimensions) -> Units_ShiftedToken

        Creates and returns a  shifted   token.  <aword> is  a
        string containing the   available word, <amean>  gives
        the signification   of the   token,  <avalue> is   the
        numeric value  of the  dimension, <amove> is  the gap,
        and <adimensions> is  the dimension of the given  word
        <aword>.

        :type aword: OCC.wrapper.Standard.Standard_CString
        :type amean: OCC.wrapper.Standard.Standard_CString
        :type avalue: float
        :type amove: float
        :type adimensions: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        this = _Units.new_Units_ShiftedToken(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Creates(self, *args):
        """
        Creates(Units_ShiftedToken self) -> Handle_Units_Token

        Creates and returns a  token, which is a ShiftedToken.

        :rtype: OCC.wrapper.Units.Handle_Units_Token

        """
        return _Units.Units_ShiftedToken_Creates(self, *args)


    def Move(self, *args):
        """
        Move(Units_ShiftedToken self) -> Standard_Real

        Returns the gap <themove>

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Units_ShiftedToken_Move(self, *args)


    def Multiplied(self, *args):
        """
        Multiplied(Units_ShiftedToken self, Standard_Real const avalue) -> Standard_Real

        This  virtual   method  is  called  by the Measurement
        methods,  to   compute  the   measurement    during  a
        conversion.

        :type avalue: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Units_ShiftedToken_Multiplied(self, *args)


    def Divided(self, *args):
        """
        Divided(Units_ShiftedToken self, Standard_Real const avalue) -> Standard_Real

        This   virtual  method is  called  by  the Measurement
        methods,   to   compute   the   measurement   during a
        conversion.

        :type avalue: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Units_ShiftedToken_Divided(self, *args)


    def Dump(self, *args):
        """
        Dump(Units_ShiftedToken self, Standard_Integer const ashift, Standard_Integer const alevel)

        :type ashift: int
        :type alevel: int

        """
        return _Units.Units_ShiftedToken_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Units.Units_ShiftedToken_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Units.Units_ShiftedToken_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Units_ShiftedToken_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Units.delete_Units_ShiftedToken
Units_ShiftedToken_swigregister = _Units.Units_ShiftedToken_swigregister
Units_ShiftedToken_swigregister(Units_ShiftedToken)

def Units_ShiftedToken_get_type_name(*args):
    """
    Units_ShiftedToken_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Units.Units_ShiftedToken_get_type_name(*args)

def Units_ShiftedToken_get_type_descriptor(*args):
    """
    Units_ShiftedToken_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Units.Units_ShiftedToken_get_type_descriptor(*args)

class Units_Dimensions(Standard.Standard_Transient):
    """
    This class includes all  the methods to create and
    manipulate    the   dimensions  of the    physical
    quantities.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Units_Dimensions
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Units_Dimensions(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Units_Dimensions self, Standard_Real const amass, Standard_Real const alength, Standard_Real const atime, Standard_Real const anelectriccurrent, Standard_Real const athermodynamictemperature, Standard_Real const anamountofsubstance, Standard_Real const aluminousintensity, Standard_Real const aplaneangle, Standard_Real const asolidangle) -> Units_Dimensions

        Returns  a  Dimensions  object  which  represents  the
        dimension  of  a  physical  quantity.    Each  of  the
        <amass>,  <alength>,   <atime>,   <anelectriccurrent>,
        <athermodynamictemperature>,    <anamountofsubstance>,
        <aluminousintensity>, <aplaneangle>, <asolidangle> are
        the powers for  the 7  fundamental  units of  physical
        quantity and  the 2  secondary  fundamental  units  of
        physical quantity.

        :type amass: float
        :type alength: float
        :type atime: float
        :type anelectriccurrent: float
        :type athermodynamictemperature: float
        :type anamountofsubstance: float
        :type aluminousintensity: float
        :type aplaneangle: float
        :type asolidangle: float

        """
        this = _Units.new_Units_Dimensions(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Mass(self, *args):
        """
        Mass(Units_Dimensions self) -> Standard_Real

        Returns the power of mass stored in the dimensions.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Units_Dimensions_Mass(self, *args)


    def Length(self, *args):
        """
        Length(Units_Dimensions self) -> Standard_Real

        Returns the power of length stored in the dimensions.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Units_Dimensions_Length(self, *args)


    def Time(self, *args):
        """
        Time(Units_Dimensions self) -> Standard_Real

        Returns the power of time stored in the dimensions.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Units_Dimensions_Time(self, *args)


    def ElectricCurrent(self, *args):
        """
        ElectricCurrent(Units_Dimensions self) -> Standard_Real

        Returns the  power of  electrical  intensity (current)
        stored in the dimensions.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Units_Dimensions_ElectricCurrent(self, *args)


    def ThermodynamicTemperature(self, *args):
        """
        ThermodynamicTemperature(Units_Dimensions self) -> Standard_Real

        Returns  the  power  of   temperature stored  in   the
        dimensions.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Units_Dimensions_ThermodynamicTemperature(self, *args)


    def AmountOfSubstance(self, *args):
        """
        AmountOfSubstance(Units_Dimensions self) -> Standard_Real

        Returns  the power   of quantity   of  material (mole)
        stored in the dimensions.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Units_Dimensions_AmountOfSubstance(self, *args)


    def LuminousIntensity(self, *args):
        """
        LuminousIntensity(Units_Dimensions self) -> Standard_Real

        Returns the  power of light   intensity stored  in the
        dimensions.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Units_Dimensions_LuminousIntensity(self, *args)


    def PlaneAngle(self, *args):
        """
        PlaneAngle(Units_Dimensions self) -> Standard_Real

        Returns  the power   of plane   angle  stored  in  the
        dimensions.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Units_Dimensions_PlaneAngle(self, *args)


    def SolidAngle(self, *args):
        """
        SolidAngle(Units_Dimensions self) -> Standard_Real

        Returns the   power   of  solid angle stored   in  the
        dimensions.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Units_Dimensions_SolidAngle(self, *args)


    def Quantity(self, *args):
        """
        Quantity(Units_Dimensions self) -> Standard_CString

        Returns the quantity string of the dimension

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Units_Dimensions_Quantity(self, *args)


    def Multiply(self, *args):
        """
        Multiply(Units_Dimensions self, Handle_Units_Dimensions adimensions) -> Handle_Units_Dimensions

        Creates and returns  a new Dimensions  object which is
        the   result   of the  multiplication    of  <me>  and
        <adimensions>.

        :type adimensions: OCC.wrapper.Units.Handle_Units_Dimensions
        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Units_Dimensions_Multiply(self, *args)


    def Divide(self, *args):
        """
        Divide(Units_Dimensions self, Handle_Units_Dimensions adimensions) -> Handle_Units_Dimensions

        Creates and returns a new  Dimensions object which  is
        the result of the division of <me> by <adimensions>.

        :type adimensions: OCC.wrapper.Units.Handle_Units_Dimensions
        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Units_Dimensions_Divide(self, *args)


    def Power(self, *args):
        """
        Power(Units_Dimensions self, Standard_Real const anexponent) -> Handle_Units_Dimensions

        Creates  and returns a new  Dimensions object which is
        the result of the power of <me> and <anexponent>.

        :type anexponent: float
        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Units_Dimensions_Power(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(Units_Dimensions self, Handle_Units_Dimensions adimensions) -> Standard_Boolean

        Returns true if  <me>  and <adimensions> have the same
        dimensions, false otherwise.

        :type adimensions: OCC.wrapper.Units.Handle_Units_Dimensions
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Units_Dimensions_IsEqual(self, *args)


    def IsNotEqual(self, *args):
        """
        IsNotEqual(Units_Dimensions self, Handle_Units_Dimensions adimensions) -> Standard_Boolean

        Returns false if <me> and  <adimensions> have the same
        dimensions, true otherwise.

        :type adimensions: OCC.wrapper.Units.Handle_Units_Dimensions
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Units_Dimensions_IsNotEqual(self, *args)


    def Dump(self, *args):
        """
        Dump(Units_Dimensions self, Standard_Integer const ashift)

        Useful for degugging.

        :type ashift: int

        """
        return _Units.Units_Dimensions_Dump(self, *args)


    def ALess(*args):
        """
        ALess() -> Handle_Units_Dimensions

        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Units_Dimensions_ALess(*args)

    ALess = staticmethod(ALess)

    def AMass(*args):
        """
        AMass() -> Handle_Units_Dimensions

        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Units_Dimensions_AMass(*args)

    AMass = staticmethod(AMass)

    def ALength(*args):
        """
        ALength() -> Handle_Units_Dimensions

        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Units_Dimensions_ALength(*args)

    ALength = staticmethod(ALength)

    def ATime(*args):
        """
        ATime() -> Handle_Units_Dimensions

        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Units_Dimensions_ATime(*args)

    ATime = staticmethod(ATime)

    def AElectricCurrent(*args):
        """
        AElectricCurrent() -> Handle_Units_Dimensions

        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Units_Dimensions_AElectricCurrent(*args)

    AElectricCurrent = staticmethod(AElectricCurrent)

    def AThermodynamicTemperature(*args):
        """
        AThermodynamicTemperature() -> Handle_Units_Dimensions

        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Units_Dimensions_AThermodynamicTemperature(*args)

    AThermodynamicTemperature = staticmethod(AThermodynamicTemperature)

    def AAmountOfSubstance(*args):
        """
        AAmountOfSubstance() -> Handle_Units_Dimensions

        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Units_Dimensions_AAmountOfSubstance(*args)

    AAmountOfSubstance = staticmethod(AAmountOfSubstance)

    def ALuminousIntensity(*args):
        """
        ALuminousIntensity() -> Handle_Units_Dimensions

        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Units_Dimensions_ALuminousIntensity(*args)

    ALuminousIntensity = staticmethod(ALuminousIntensity)

    def APlaneAngle(*args):
        """
        APlaneAngle() -> Handle_Units_Dimensions

        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Units_Dimensions_APlaneAngle(*args)

    APlaneAngle = staticmethod(APlaneAngle)

    def ASolidAngle(*args):
        """
        ASolidAngle() -> Handle_Units_Dimensions

        Returns the basic dimensions.

        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Units_Dimensions_ASolidAngle(*args)

    ASolidAngle = staticmethod(ASolidAngle)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Units.Units_Dimensions_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Units.Units_Dimensions_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Units_Dimensions_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Units.delete_Units_Dimensions
Units_Dimensions_swigregister = _Units.Units_Dimensions_swigregister
Units_Dimensions_swigregister(Units_Dimensions)

def Units_Dimensions_ALess(*args):
    """
    Units_Dimensions_ALess() -> Handle_Units_Dimensions

    :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

    """
    return _Units.Units_Dimensions_ALess(*args)

def Units_Dimensions_AMass(*args):
    """
    Units_Dimensions_AMass() -> Handle_Units_Dimensions

    :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

    """
    return _Units.Units_Dimensions_AMass(*args)

def Units_Dimensions_ALength(*args):
    """
    Units_Dimensions_ALength() -> Handle_Units_Dimensions

    :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

    """
    return _Units.Units_Dimensions_ALength(*args)

def Units_Dimensions_ATime(*args):
    """
    Units_Dimensions_ATime() -> Handle_Units_Dimensions

    :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

    """
    return _Units.Units_Dimensions_ATime(*args)

def Units_Dimensions_AElectricCurrent(*args):
    """
    Units_Dimensions_AElectricCurrent() -> Handle_Units_Dimensions

    :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

    """
    return _Units.Units_Dimensions_AElectricCurrent(*args)

def Units_Dimensions_AThermodynamicTemperature(*args):
    """
    Units_Dimensions_AThermodynamicTemperature() -> Handle_Units_Dimensions

    :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

    """
    return _Units.Units_Dimensions_AThermodynamicTemperature(*args)

def Units_Dimensions_AAmountOfSubstance(*args):
    """
    Units_Dimensions_AAmountOfSubstance() -> Handle_Units_Dimensions

    :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

    """
    return _Units.Units_Dimensions_AAmountOfSubstance(*args)

def Units_Dimensions_ALuminousIntensity(*args):
    """
    Units_Dimensions_ALuminousIntensity() -> Handle_Units_Dimensions

    :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

    """
    return _Units.Units_Dimensions_ALuminousIntensity(*args)

def Units_Dimensions_APlaneAngle(*args):
    """
    Units_Dimensions_APlaneAngle() -> Handle_Units_Dimensions

    :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

    """
    return _Units.Units_Dimensions_APlaneAngle(*args)

def Units_Dimensions_ASolidAngle(*args):
    """
    Units_Dimensions_ASolidAngle() -> Handle_Units_Dimensions

    Returns the basic dimensions.

    :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

    """
    return _Units.Units_Dimensions_ASolidAngle(*args)

def Units_Dimensions_get_type_name(*args):
    """
    Units_Dimensions_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Units.Units_Dimensions_get_type_name(*args)

def Units_Dimensions_get_type_descriptor(*args):
    """
    Units_Dimensions_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Units.Units_Dimensions_get_type_descriptor(*args)

class Units_UnitsDictionary(Standard.Standard_Transient):
    """
    This class creates  a dictionary of all  the units
    you want to know.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Units_UnitsDictionary
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Units_UnitsDictionary(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Units_UnitsDictionary self) -> Units_UnitsDictionary

        Returns an empty instance of UnitsDictionary.


        """
        this = _Units.new_Units_UnitsDictionary(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Creates(self, *args):
        """
        Creates(Units_UnitsDictionary self)

        Returns a  UnitsDictionary object  which  contains the
        sequence  of all   the  units  you want to   consider,
        physical quantity by physical quantity.


        """
        return _Units.Units_UnitsDictionary_Creates(self, *args)


    def Sequence(self, *args):
        """
        Sequence(Units_UnitsDictionary self) -> Handle_Units_QuantitiesSequence

        Returns   the  head   of   the  sequence  of  physical
        quantities.

        :rtype: OCC.wrapper.Units.Handle_Units_QuantitiesSequence

        """
        return _Units.Units_UnitsDictionary_Sequence(self, *args)


    def ActiveUnit(self, *args):
        """
        ActiveUnit(Units_UnitsDictionary self, Standard_CString const aquantity) -> TCollection_AsciiString

        Returns for <aquantity> the active unit.

        :type aquantity: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Units.Units_UnitsDictionary_ActiveUnit(self, *args)


    def Dump(self, *args):
        """
        Dump(Units_UnitsDictionary self, Standard_Integer const alevel)
        Dump(Units_UnitsDictionary self, Handle_Units_Dimensions adimensions)

        Dumps  for a     designated  physical       dimensions
        <adimensions> all the previously stored units.

        :type adimensions: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Units_UnitsDictionary_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Units.Units_UnitsDictionary_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Units.Units_UnitsDictionary_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Units_UnitsDictionary_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Units.delete_Units_UnitsDictionary
Units_UnitsDictionary_swigregister = _Units.Units_UnitsDictionary_swigregister
Units_UnitsDictionary_swigregister(Units_UnitsDictionary)

def Units_UnitsDictionary_get_type_name(*args):
    """
    Units_UnitsDictionary_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Units.Units_UnitsDictionary_get_type_name(*args)

def Units_UnitsDictionary_get_type_descriptor(*args):
    """
    Units_UnitsDictionary_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Units.Units_UnitsDictionary_get_type_descriptor(*args)

class Units_Quantity(Standard.Standard_Transient):
    """
    This  class stores  in its  field all the possible
    units of all the unit systems for a given physical
    quantity. Each unit's  value  is  expressed in the
    S.I. unit system.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Units_Quantity
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Units_Quantity(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Units_Quantity self, Standard_CString const aname, Handle_Units_Dimensions adimensions, Handle_Units_UnitsSequence aunitssequence) -> Units_Quantity

        Creates  a new Quantity  object with <aname> which  is
        the name of the physical quantity, <adimensions> which
        is the physical dimensions, and <aunitssequence> which
        describes all the units known for this quantity.

        :type aname: OCC.wrapper.Standard.Standard_CString
        :type adimensions: OCC.wrapper.Units.Handle_Units_Dimensions
        :type aunitssequence: OCC.wrapper.Units.Handle_Units_UnitsSequence

        """
        this = _Units.new_Units_Quantity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Name(self, *args):
        """
        Name(Units_Quantity self) -> TCollection_AsciiString

        Returns in a AsciiString from TCollection the name of the quantity.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Units.Units_Quantity_Name(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Units_Quantity self) -> Handle_Units_Dimensions

        Returns the physical dimensions of the quantity.

        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Units_Quantity_Dimensions(self, *args)


    def Sequence(self, *args):
        """
        Sequence(Units_Quantity self) -> Handle_Units_UnitsSequence

        Returns <theunitssequence>, which  is the  sequence of
        all the units stored for this physical quantity.

        :rtype: OCC.wrapper.Units.Handle_Units_UnitsSequence

        """
        return _Units.Units_Quantity_Sequence(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(Units_Quantity self, Standard_CString const astring) -> Standard_Boolean

        Returns True if the name of the Quantity <me> is equal
        to <astring>, False otherwise.

        :type astring: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Units_Quantity_IsEqual(self, *args)


    def Dump(self, *args):
        """
        Dump(Units_Quantity self, Standard_Integer const ashift, Standard_Integer const alevel)

        Useful for debugging.

        :type ashift: int
        :type alevel: int

        """
        return _Units.Units_Quantity_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Units.Units_Quantity_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Units.Units_Quantity_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Units_Quantity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Units.delete_Units_Quantity
Units_Quantity_swigregister = _Units.Units_Quantity_swigregister
Units_Quantity_swigregister(Units_Quantity)

def Units_Quantity_get_type_name(*args):
    """
    Units_Quantity_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Units.Units_Quantity_get_type_name(*args)

def Units_Quantity_get_type_descriptor(*args):
    """
    Units_Quantity_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Units.Units_Quantity_get_type_descriptor(*args)

class Units_UnitsSystem(Standard.Standard_Transient):
    """
    This class  allows  the  user  to  define his  own
    system of units.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Units_UnitsSystem
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Units_UnitsSystem(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Units_UnitsSystem self) -> Units_UnitsSystem
        __init__(Units_UnitsSystem self, Standard_CString const aName, Standard_Boolean const Verbose) -> Units_UnitsSystem

        Returns an instance of UnitsSystem initialized to the
        S.I. units system upgraded by the base system units decription
        file.
        Attempts to find the four following files:
        $CSF_`aName`Defaults/.aName
        $CSF_`aName`SiteDefaults/.aName
        $CSF_`aName`GroupDefaults/.aName
        $CSF_`aName`UserDefaults/.aName
        See : Resource_Manager for the description of this file.

        :type aName: OCC.wrapper.Standard.Standard_CString
        :type Verbose: bool

        """
        this = _Units.new_Units_UnitsSystem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def QuantitiesSequence(self, *args):
        """
        QuantitiesSequence(Units_UnitsSystem self) -> Handle_Units_QuantitiesSequence

        Returns the sequence of refined quantities.

        :rtype: OCC.wrapper.Units.Handle_Units_QuantitiesSequence

        """
        return _Units.Units_UnitsSystem_QuantitiesSequence(self, *args)


    def ActiveUnitsSequence(self, *args):
        """
        ActiveUnitsSequence(Units_UnitsSystem self) -> Handle_TColStd_HSequenceOfInteger

        Returns a sequence of integer in correspondance with
        the sequence of quantities, which indicates, for each
        redefined quantity, the index into the sequence of
        units, of the active unit.

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfInteger

        """
        return _Units.Units_UnitsSystem_ActiveUnitsSequence(self, *args)


    def Specify(self, *args):
        """
        Specify(Units_UnitsSystem self, Standard_CString const aquantity, Standard_CString const aunit)

        Specifies for <aquantity> the unit <aunit> used.

        :type aquantity: OCC.wrapper.Standard.Standard_CString
        :type aunit: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Units_UnitsSystem_Specify(self, *args)


    def Remove(self, *args):
        """
        Remove(Units_UnitsSystem self, Standard_CString const aquantity, Standard_CString const aunit)

        Removes for <aquantity> the unit <aunit> used.

        :type aquantity: OCC.wrapper.Standard.Standard_CString
        :type aunit: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Units_UnitsSystem_Remove(self, *args)


    def Activate(self, *args):
        """
        Activate(Units_UnitsSystem self, Standard_CString const aquantity, Standard_CString const aunit)

        Specifies for <aquantity> the unit <aunit> used.

        :type aquantity: OCC.wrapper.Standard.Standard_CString
        :type aunit: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Units_UnitsSystem_Activate(self, *args)


    def Activates(self, *args):
        """
        Activates(Units_UnitsSystem self)

        Activates the first unit of all defined system quantities


        """
        return _Units.Units_UnitsSystem_Activates(self, *args)


    def ActiveUnit(self, *args):
        """
        ActiveUnit(Units_UnitsSystem self, Standard_CString const aquantity) -> TCollection_AsciiString

        Returns for <aquantity> the active unit.

        :type aquantity: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Units.Units_UnitsSystem_ActiveUnit(self, *args)


    def ConvertValueToUserSystem(self, *args):
        """
        ConvertValueToUserSystem(Units_UnitsSystem self, Standard_CString const aquantity, Standard_Real const avalue, Standard_CString const aunit) -> Standard_Real

        Converts a real value <avalue> from the unit <aunit>
        belonging to the physical dimensions <aquantity> to
        the corresponding unit of the user system.

        :type aquantity: OCC.wrapper.Standard.Standard_CString
        :type avalue: float
        :type aunit: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Units_UnitsSystem_ConvertValueToUserSystem(self, *args)


    def ConvertSIValueToUserSystem(self, *args):
        """
        ConvertSIValueToUserSystem(Units_UnitsSystem self, Standard_CString const aquantity, Standard_Real const avalue) -> Standard_Real

        Converts the real value <avalue> from the S.I. system
        of units to the user system of units. <aquantity> is
        the physical dimensions of the measurement.

        :type aquantity: OCC.wrapper.Standard.Standard_CString
        :type avalue: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Units_UnitsSystem_ConvertSIValueToUserSystem(self, *args)


    def ConvertUserSystemValueToSI(self, *args):
        """
        ConvertUserSystemValueToSI(Units_UnitsSystem self, Standard_CString const aquantity, Standard_Real const avalue) -> Standard_Real

        Converts the real value <avalue> from the user system
        of units to the S.I. system of units. <aquantity> is
        the physical dimensions of the measurement.

        :type aquantity: OCC.wrapper.Standard.Standard_CString
        :type avalue: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Units_UnitsSystem_ConvertUserSystemValueToSI(self, *args)


    def Dump(self, *args):
        """Dump(Units_UnitsSystem self)"""
        return _Units.Units_UnitsSystem_Dump(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Units_UnitsSystem self) -> Standard_Boolean

        Returns TRUE if no units has been defined in the system.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Units_UnitsSystem_IsEmpty(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Units.Units_UnitsSystem_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Units.Units_UnitsSystem_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Units_UnitsSystem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Units.delete_Units_UnitsSystem
Units_UnitsSystem_swigregister = _Units.Units_UnitsSystem_swigregister
Units_UnitsSystem_swigregister(Units_UnitsSystem)

def Units_UnitsSystem_get_type_name(*args):
    """
    Units_UnitsSystem_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Units.Units_UnitsSystem_get_type_name(*args)

def Units_UnitsSystem_get_type_descriptor(*args):
    """
    Units_UnitsSystem_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Units.Units_UnitsSystem_get_type_descriptor(*args)

class Units_NoSuchUnit(Standard.Standard_NoSuchObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Units_NoSuchUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Units_NoSuchUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Units_NoSuchUnit self) -> Units_NoSuchUnit
        __init__(Units_NoSuchUnit self, Standard_CString const theMessage) -> Units_NoSuchUnit

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Units.new_Units_NoSuchUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Units_NoSuchUnit

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Units.Handle_Units_NoSuchUnit

        """
        return _Units.Units_NoSuchUnit_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Units.Units_NoSuchUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Units.Units_NoSuchUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Units_NoSuchUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Units.delete_Units_NoSuchUnit
Units_NoSuchUnit_swigregister = _Units.Units_NoSuchUnit_swigregister
Units_NoSuchUnit_swigregister(Units_NoSuchUnit)

def Units_NoSuchUnit_NewInstance(*args):
    """
    Units_NoSuchUnit_NewInstance(Standard_CString const theMessage) -> Handle_Units_NoSuchUnit

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Units.Handle_Units_NoSuchUnit

    """
    return _Units.Units_NoSuchUnit_NewInstance(*args)

def Units_NoSuchUnit_get_type_name(*args):
    """
    Units_NoSuchUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Units.Units_NoSuchUnit_get_type_name(*args)

def Units_NoSuchUnit_get_type_descriptor(*args):
    """
    Units_NoSuchUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Units.Units_NoSuchUnit_get_type_descriptor(*args)

class Units_Lexicon(Standard.Standard_Transient):
    """
    This class defines a lexicon useful to analyse and
    recognize the  different key words  included  in a
    sentence.  The lexicon is stored  in a sequence of
    tokens.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Units_Lexicon
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Units_Lexicon(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Units_Lexicon self) -> Units_Lexicon

        Creates an empty instance of Lexicon.


        """
        this = _Units.new_Units_Lexicon(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Creates(self, *args):
        """
        Creates(Units_Lexicon self)

        Reads the file <afilename> to create a sequence  of tokens
        stored in <thesequenceoftokens>.


        """
        return _Units.Units_Lexicon_Creates(self, *args)


    def Sequence(self, *args):
        """
        Sequence(Units_Lexicon self) -> Handle_Units_TokensSequence

        Returns the first item of the sequence of tokens.

        :rtype: OCC.wrapper.Units.Handle_Units_TokensSequence

        """
        return _Units.Units_Lexicon_Sequence(self, *args)


    def AddToken(self, *args):
        """
        AddToken(Units_Lexicon self, Standard_CString const aword, Standard_CString const amean, Standard_Real const avalue)

        Adds to the lexicon a new token with <aword>, <amean>,
        <avalue>  as  arguments.  If there is  already a token
        with   the  field  <theword>  equal    to <aword>, the
        existing token is updated.

        :type aword: OCC.wrapper.Standard.Standard_CString
        :type amean: OCC.wrapper.Standard.Standard_CString
        :type avalue: float

        """
        return _Units.Units_Lexicon_AddToken(self, *args)


    def Dump(self, *args):
        """
        Dump(Units_Lexicon self)

        Useful for debugging.


        """
        return _Units.Units_Lexicon_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Units.Units_Lexicon_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Units.Units_Lexicon_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Units_Lexicon_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Units.delete_Units_Lexicon
Units_Lexicon_swigregister = _Units.Units_Lexicon_swigregister
Units_Lexicon_swigregister(Units_Lexicon)

def Units_Lexicon_get_type_name(*args):
    """
    Units_Lexicon_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Units.Units_Lexicon_get_type_name(*args)

def Units_Lexicon_get_type_descriptor(*args):
    """
    Units_Lexicon_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Units.Units_Lexicon_get_type_descriptor(*args)

class Units_QuantitiesSequence(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Units_QuantitiesSequence
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Units_QuantitiesSequence(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Units_QuantitiesSequence self) -> Units_QuantitiesSequence
        __init__(Units_QuantitiesSequence self, NCollection_Sequence_Handle_Units_Quantity theOther) -> Units_QuantitiesSequence

        :type theOther: OCC.wrapper.Units.Units_QtsSequence

        """
        this = _Units.new_Units_QuantitiesSequence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.Units.Units_QtsSequence

        """
        res = _Units.Units_QuantitiesSequence_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Units_QuantitiesSequence self, Handle_Units_Quantity theItem)
        Append(Units_QuantitiesSequence self, NCollection_Sequence_Handle_Units_Quantity theSequence)

        :type theSequence: OCC.wrapper.Units.Units_QtsSequence

        """
        return _Units.Units_QuantitiesSequence_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Units_QuantitiesSequence self) -> NCollection_Sequence_Handle_Units_Quantity

        :rtype: OCC.wrapper.Units.Units_QtsSequence

        """
        return _Units.Units_QuantitiesSequence_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Units.Units_QuantitiesSequence_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Units.Units_QuantitiesSequence_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Units_QuantitiesSequence_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Units.delete_Units_QuantitiesSequence
Units_QuantitiesSequence_swigregister = _Units.Units_QuantitiesSequence_swigregister
Units_QuantitiesSequence_swigregister(Units_QuantitiesSequence)

def Units_QuantitiesSequence_get_type_name(*args):
    """
    Units_QuantitiesSequence_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Units.Units_QuantitiesSequence_get_type_name(*args)

def Units_QuantitiesSequence_get_type_descriptor(*args):
    """
    Units_QuantitiesSequence_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Units.Units_QuantitiesSequence_get_type_descriptor(*args)

class Units_UnitsSequence(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Units_UnitsSequence
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Units_UnitsSequence(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Units_UnitsSequence self) -> Units_UnitsSequence
        __init__(Units_UnitsSequence self, NCollection_Sequence_Handle_Units_Unit theOther) -> Units_UnitsSequence

        :type theOther: OCC.wrapper.Units.Units_UtsSequence

        """
        this = _Units.new_Units_UnitsSequence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.Units.Units_UtsSequence

        """
        res = _Units.Units_UnitsSequence_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Units_UnitsSequence self, Handle_Units_Unit theItem)
        Append(Units_UnitsSequence self, NCollection_Sequence_Handle_Units_Unit theSequence)

        :type theSequence: OCC.wrapper.Units.Units_UtsSequence

        """
        return _Units.Units_UnitsSequence_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Units_UnitsSequence self) -> NCollection_Sequence_Handle_Units_Unit

        :rtype: OCC.wrapper.Units.Units_UtsSequence

        """
        return _Units.Units_UnitsSequence_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Units.Units_UnitsSequence_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Units.Units_UnitsSequence_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Units_UnitsSequence_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Units.delete_Units_UnitsSequence
Units_UnitsSequence_swigregister = _Units.Units_UnitsSequence_swigregister
Units_UnitsSequence_swigregister(Units_UnitsSequence)

def Units_UnitsSequence_get_type_name(*args):
    """
    Units_UnitsSequence_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Units.Units_UnitsSequence_get_type_name(*args)

def Units_UnitsSequence_get_type_descriptor(*args):
    """
    Units_UnitsSequence_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Units.Units_UnitsSequence_get_type_descriptor(*args)

class Units_Sentence(object):
    """
    This class describes all the methods to create and
    compute an expression contained in a string.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Units_Sentence self, Handle_Units_Lexicon alexicon, Standard_CString const astring) -> Units_Sentence

        Creates and  returns  a   Sentence, by  analyzing  the
        string <astring> with the lexicon <alexicon>.

        :type alexicon: OCC.wrapper.Units.Handle_Units_Lexicon
        :type astring: OCC.wrapper.Standard.Standard_CString

        """
        this = _Units.new_Units_Sentence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetConstants(self, *args):
        """
        SetConstants(Units_Sentence self)

        For each constant encountered, sets the value.


        """
        return _Units.Units_Sentence_SetConstants(self, *args)


    def Sequence(self, *args):
        """
        Sequence(Units_Sentence self) -> Handle_Units_TokensSequence
        Sequence(Units_Sentence self, Handle_Units_TokensSequence asequenceoftokens)

        Sets the field <thesequenceoftokens> to <asequenceoftokens>.

        :type asequenceoftokens: OCC.wrapper.Units.Handle_Units_TokensSequence

        """
        return _Units.Units_Sentence_Sequence(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(Units_Sentence self) -> Handle_Units_Token

        Computes and  returns in a   token the result  of  the
        expression.

        :rtype: OCC.wrapper.Units.Handle_Units_Token

        """
        return _Units.Units_Sentence_Evaluate(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Units_Sentence self) -> Standard_Boolean

        Return True if number of created tokens > 0
        (i.e creation of sentence is succesfull)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Units_Sentence_IsDone(self, *args)


    def Dump(self, *args):
        """
        Dump(Units_Sentence self)

        Useful for debugging.


        """
        return _Units.Units_Sentence_Dump(self, *args)

    __swig_destroy__ = _Units.delete_Units_Sentence
Units_Sentence_swigregister = _Units.Units_Sentence_swigregister
Units_Sentence_swigregister(Units_Sentence)

class Handle_Units_Quantity(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Units_Quantity self)

        Nullify the handle


        """
        return _Units.Handle_Units_Quantity_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Units_Quantity self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Units.Handle_Units_Quantity_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Units_Quantity self, Units_Quantity thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Units.Handle_Units_Quantity_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Units_Quantity self, Handle_Units_Quantity theHandle) -> Handle_Units_Quantity
        assign(Handle_Units_Quantity self, Units_Quantity thePtr) -> Handle_Units_Quantity
        assign(Handle_Units_Quantity self, Handle_Units_Quantity theHandle) -> Handle_Units_Quantity

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Units.Handle_Units_Quantity_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Units_Quantity self) -> Units_Quantity

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Units.Handle_Units_Quantity_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Units_Quantity self) -> Units_Quantity

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Units.Handle_Units_Quantity___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Units_Quantity self) -> Units_Quantity

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Units.Handle_Units_Quantity___ref__(self, *args)


    def __hash__(self):
        return _Units.Handle_Units_Quantity___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Units.Handle_Units_Quantity___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Units.new_Handle_Units_Quantity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Units.Handle_Units_Quantity_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_Quantity

    def Name(self, *args):
        """
        Name(Handle_Units_Quantity self) -> TCollection_AsciiString

        Returns in a AsciiString from TCollection the name of the quantity.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Units.Handle_Units_Quantity_Name(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_Units_Quantity self) -> Handle_Units_Dimensions

        Returns the physical dimensions of the quantity.

        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Handle_Units_Quantity_Dimensions(self, *args)


    def Sequence(self, *args):
        """
        Sequence(Handle_Units_Quantity self) -> Handle_Units_UnitsSequence

        Returns <theunitssequence>, which  is the  sequence of
        all the units stored for this physical quantity.

        :rtype: OCC.wrapper.Units.Handle_Units_UnitsSequence

        """
        return _Units.Handle_Units_Quantity_Sequence(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(Handle_Units_Quantity self, Standard_CString const astring) -> Standard_Boolean

        Returns True if the name of the Quantity <me> is equal
        to <astring>, False otherwise.

        :type astring: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_Quantity_IsEqual(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_Units_Quantity self, Standard_Integer const ashift, Standard_Integer const alevel)

        Useful for debugging.

        :type ashift: int
        :type alevel: int

        """
        return _Units.Handle_Units_Quantity_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Units_Quantity self) -> char const *

        :rtype: const char *

        """
        return _Units.Handle_Units_Quantity_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_Quantity_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_Quantity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Units_Quantity self)

        Memory deallocator for transient classes


        """
        return _Units.Handle_Units_Quantity_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Units_Quantity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Units_Quantity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_Quantity_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Units_Quantity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Units_Quantity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_Quantity_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Units_Quantity self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Units.Handle_Units_Quantity_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Units_Quantity self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_Quantity_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Units_Quantity self)

        Increments the reference counter of this object


        """
        return _Units.Handle_Units_Quantity_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Units_Quantity self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_Quantity_DecrementRefCounter(self, *args)

Handle_Units_Quantity_swigregister = _Units.Handle_Units_Quantity_swigregister
Handle_Units_Quantity_swigregister(Handle_Units_Quantity)

def Handle_Units_Quantity_DownCast(thing):
    return _Units.Handle_Units_Quantity_DownCast(thing)
Handle_Units_Quantity_DownCast = _Units.Handle_Units_Quantity_DownCast

class Handle_Units_UnitsSystem(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Units_UnitsSystem self)

        Nullify the handle


        """
        return _Units.Handle_Units_UnitsSystem_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Units_UnitsSystem self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Units.Handle_Units_UnitsSystem_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Units_UnitsSystem self, Units_UnitsSystem thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Units.Handle_Units_UnitsSystem_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Units_UnitsSystem self, Handle_Units_UnitsSystem theHandle) -> Handle_Units_UnitsSystem
        assign(Handle_Units_UnitsSystem self, Units_UnitsSystem thePtr) -> Handle_Units_UnitsSystem
        assign(Handle_Units_UnitsSystem self, Handle_Units_UnitsSystem theHandle) -> Handle_Units_UnitsSystem

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Units.Handle_Units_UnitsSystem_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Units_UnitsSystem self) -> Units_UnitsSystem

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Units.Handle_Units_UnitsSystem_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Units_UnitsSystem self) -> Units_UnitsSystem

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Units.Handle_Units_UnitsSystem___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Units_UnitsSystem self) -> Units_UnitsSystem

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Units.Handle_Units_UnitsSystem___ref__(self, *args)


    def __hash__(self):
        return _Units.Handle_Units_UnitsSystem___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Units.Handle_Units_UnitsSystem___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Units.new_Handle_Units_UnitsSystem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Units.Handle_Units_UnitsSystem_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_UnitsSystem

    def QuantitiesSequence(self, *args):
        """
        QuantitiesSequence(Handle_Units_UnitsSystem self) -> Handle_Units_QuantitiesSequence

        Returns the sequence of refined quantities.

        :rtype: OCC.wrapper.Units.Handle_Units_QuantitiesSequence

        """
        return _Units.Handle_Units_UnitsSystem_QuantitiesSequence(self, *args)


    def ActiveUnitsSequence(self, *args):
        """
        ActiveUnitsSequence(Handle_Units_UnitsSystem self) -> Handle_TColStd_HSequenceOfInteger

        Returns a sequence of integer in correspondance with
        the sequence of quantities, which indicates, for each
        redefined quantity, the index into the sequence of
        units, of the active unit.

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfInteger

        """
        return _Units.Handle_Units_UnitsSystem_ActiveUnitsSequence(self, *args)


    def Specify(self, *args):
        """
        Specify(Handle_Units_UnitsSystem self, Standard_CString const aquantity, Standard_CString const aunit)

        Specifies for <aquantity> the unit <aunit> used.

        :type aquantity: OCC.wrapper.Standard.Standard_CString
        :type aunit: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Handle_Units_UnitsSystem_Specify(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_Units_UnitsSystem self, Standard_CString const aquantity, Standard_CString const aunit)

        Removes for <aquantity> the unit <aunit> used.

        :type aquantity: OCC.wrapper.Standard.Standard_CString
        :type aunit: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Handle_Units_UnitsSystem_Remove(self, *args)


    def Activate(self, *args):
        """
        Activate(Handle_Units_UnitsSystem self, Standard_CString const aquantity, Standard_CString const aunit)

        Specifies for <aquantity> the unit <aunit> used.

        :type aquantity: OCC.wrapper.Standard.Standard_CString
        :type aunit: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Handle_Units_UnitsSystem_Activate(self, *args)


    def Activates(self, *args):
        """
        Activates(Handle_Units_UnitsSystem self)

        Activates the first unit of all defined system quantities


        """
        return _Units.Handle_Units_UnitsSystem_Activates(self, *args)


    def ActiveUnit(self, *args):
        """
        ActiveUnit(Handle_Units_UnitsSystem self, Standard_CString const aquantity) -> TCollection_AsciiString

        Returns for <aquantity> the active unit.

        :type aquantity: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Units.Handle_Units_UnitsSystem_ActiveUnit(self, *args)


    def ConvertValueToUserSystem(self, *args):
        """
        ConvertValueToUserSystem(Handle_Units_UnitsSystem self, Standard_CString const aquantity, Standard_Real const avalue, Standard_CString const aunit) -> Standard_Real

        Converts a real value <avalue> from the unit <aunit>
        belonging to the physical dimensions <aquantity> to
        the corresponding unit of the user system.

        :type aquantity: OCC.wrapper.Standard.Standard_CString
        :type avalue: float
        :type aunit: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Handle_Units_UnitsSystem_ConvertValueToUserSystem(self, *args)


    def ConvertSIValueToUserSystem(self, *args):
        """
        ConvertSIValueToUserSystem(Handle_Units_UnitsSystem self, Standard_CString const aquantity, Standard_Real const avalue) -> Standard_Real

        Converts the real value <avalue> from the S.I. system
        of units to the user system of units. <aquantity> is
        the physical dimensions of the measurement.

        :type aquantity: OCC.wrapper.Standard.Standard_CString
        :type avalue: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Handle_Units_UnitsSystem_ConvertSIValueToUserSystem(self, *args)


    def ConvertUserSystemValueToSI(self, *args):
        """
        ConvertUserSystemValueToSI(Handle_Units_UnitsSystem self, Standard_CString const aquantity, Standard_Real const avalue) -> Standard_Real

        Converts the real value <avalue> from the user system
        of units to the S.I. system of units. <aquantity> is
        the physical dimensions of the measurement.

        :type aquantity: OCC.wrapper.Standard.Standard_CString
        :type avalue: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Handle_Units_UnitsSystem_ConvertUserSystemValueToSI(self, *args)


    def Dump(self, *args):
        """Dump(Handle_Units_UnitsSystem self)"""
        return _Units.Handle_Units_UnitsSystem_Dump(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_Units_UnitsSystem self) -> Standard_Boolean

        Returns TRUE if no units has been defined in the system.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_UnitsSystem_IsEmpty(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Units_UnitsSystem self) -> char const *

        :rtype: const char *

        """
        return _Units.Handle_Units_UnitsSystem_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_UnitsSystem_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_UnitsSystem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Units_UnitsSystem self)

        Memory deallocator for transient classes


        """
        return _Units.Handle_Units_UnitsSystem_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Units_UnitsSystem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Units_UnitsSystem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_UnitsSystem_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Units_UnitsSystem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Units_UnitsSystem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_UnitsSystem_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Units_UnitsSystem self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Units.Handle_Units_UnitsSystem_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Units_UnitsSystem self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_UnitsSystem_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Units_UnitsSystem self)

        Increments the reference counter of this object


        """
        return _Units.Handle_Units_UnitsSystem_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Units_UnitsSystem self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_UnitsSystem_DecrementRefCounter(self, *args)

Handle_Units_UnitsSystem_swigregister = _Units.Handle_Units_UnitsSystem_swigregister
Handle_Units_UnitsSystem_swigregister(Handle_Units_UnitsSystem)

def Handle_Units_UnitsSystem_DownCast(thing):
    return _Units.Handle_Units_UnitsSystem_DownCast(thing)
Handle_Units_UnitsSystem_DownCast = _Units.Handle_Units_UnitsSystem_DownCast

class Handle_Units_UnitsDictionary(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Units_UnitsDictionary self)

        Nullify the handle


        """
        return _Units.Handle_Units_UnitsDictionary_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Units_UnitsDictionary self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Units.Handle_Units_UnitsDictionary_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Units_UnitsDictionary self, Units_UnitsDictionary thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Units.Handle_Units_UnitsDictionary_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Units_UnitsDictionary self, Handle_Units_UnitsDictionary theHandle) -> Handle_Units_UnitsDictionary
        assign(Handle_Units_UnitsDictionary self, Units_UnitsDictionary thePtr) -> Handle_Units_UnitsDictionary
        assign(Handle_Units_UnitsDictionary self, Handle_Units_UnitsDictionary theHandle) -> Handle_Units_UnitsDictionary

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Units.Handle_Units_UnitsDictionary_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Units_UnitsDictionary self) -> Units_UnitsDictionary

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Units.Handle_Units_UnitsDictionary_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Units_UnitsDictionary self) -> Units_UnitsDictionary

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Units.Handle_Units_UnitsDictionary___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Units_UnitsDictionary self) -> Units_UnitsDictionary

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Units.Handle_Units_UnitsDictionary___ref__(self, *args)


    def __hash__(self):
        return _Units.Handle_Units_UnitsDictionary___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Units.Handle_Units_UnitsDictionary___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Units.new_Handle_Units_UnitsDictionary(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Units.Handle_Units_UnitsDictionary_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_UnitsDictionary

    def Creates(self, *args):
        """
        Creates(Handle_Units_UnitsDictionary self)

        Returns a  UnitsDictionary object  which  contains the
        sequence  of all   the  units  you want to   consider,
        physical quantity by physical quantity.


        """
        return _Units.Handle_Units_UnitsDictionary_Creates(self, *args)


    def Sequence(self, *args):
        """
        Sequence(Handle_Units_UnitsDictionary self) -> Handle_Units_QuantitiesSequence

        Returns   the  head   of   the  sequence  of  physical
        quantities.

        :rtype: OCC.wrapper.Units.Handle_Units_QuantitiesSequence

        """
        return _Units.Handle_Units_UnitsDictionary_Sequence(self, *args)


    def ActiveUnit(self, *args):
        """
        ActiveUnit(Handle_Units_UnitsDictionary self, Standard_CString const aquantity) -> TCollection_AsciiString

        Returns for <aquantity> the active unit.

        :type aquantity: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Units.Handle_Units_UnitsDictionary_ActiveUnit(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_Units_UnitsDictionary self, Standard_Integer const alevel)
        Dump(Handle_Units_UnitsDictionary self, Handle_Units_Dimensions adimensions)

        Dumps  for a     designated  physical       dimensions
        <adimensions> all the previously stored units.

        :type adimensions: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Handle_Units_UnitsDictionary_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Units_UnitsDictionary self) -> char const *

        :rtype: const char *

        """
        return _Units.Handle_Units_UnitsDictionary_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_UnitsDictionary_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_UnitsDictionary_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Units_UnitsDictionary self)

        Memory deallocator for transient classes


        """
        return _Units.Handle_Units_UnitsDictionary_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Units_UnitsDictionary self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Units_UnitsDictionary self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_UnitsDictionary_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Units_UnitsDictionary self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Units_UnitsDictionary self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_UnitsDictionary_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Units_UnitsDictionary self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Units.Handle_Units_UnitsDictionary_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Units_UnitsDictionary self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_UnitsDictionary_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Units_UnitsDictionary self)

        Increments the reference counter of this object


        """
        return _Units.Handle_Units_UnitsDictionary_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Units_UnitsDictionary self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_UnitsDictionary_DecrementRefCounter(self, *args)

Handle_Units_UnitsDictionary_swigregister = _Units.Handle_Units_UnitsDictionary_swigregister
Handle_Units_UnitsDictionary_swigregister(Handle_Units_UnitsDictionary)

def Handle_Units_UnitsDictionary_DownCast(thing):
    return _Units.Handle_Units_UnitsDictionary_DownCast(thing)
Handle_Units_UnitsDictionary_DownCast = _Units.Handle_Units_UnitsDictionary_DownCast

class Handle_Units_Dimensions(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Units_Dimensions self)

        Nullify the handle


        """
        return _Units.Handle_Units_Dimensions_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Units_Dimensions self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Units.Handle_Units_Dimensions_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Units_Dimensions self, Units_Dimensions thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Units.Handle_Units_Dimensions_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Units_Dimensions self, Handle_Units_Dimensions theHandle) -> Handle_Units_Dimensions
        assign(Handle_Units_Dimensions self, Units_Dimensions thePtr) -> Handle_Units_Dimensions
        assign(Handle_Units_Dimensions self, Handle_Units_Dimensions theHandle) -> Handle_Units_Dimensions

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Units.Handle_Units_Dimensions_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Units_Dimensions self) -> Units_Dimensions

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Units.Handle_Units_Dimensions_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Units_Dimensions self) -> Units_Dimensions

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Units.Handle_Units_Dimensions___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Units_Dimensions self) -> Units_Dimensions

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Units.Handle_Units_Dimensions___ref__(self, *args)


    def __hash__(self):
        return _Units.Handle_Units_Dimensions___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Units.Handle_Units_Dimensions___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Units.new_Handle_Units_Dimensions(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Units.Handle_Units_Dimensions_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_Dimensions

    def Mass(self, *args):
        """
        Mass(Handle_Units_Dimensions self) -> Standard_Real

        Returns the power of mass stored in the dimensions.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Handle_Units_Dimensions_Mass(self, *args)


    def Length(self, *args):
        """
        Length(Handle_Units_Dimensions self) -> Standard_Real

        Returns the power of length stored in the dimensions.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Handle_Units_Dimensions_Length(self, *args)


    def Time(self, *args):
        """
        Time(Handle_Units_Dimensions self) -> Standard_Real

        Returns the power of time stored in the dimensions.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Handle_Units_Dimensions_Time(self, *args)


    def ElectricCurrent(self, *args):
        """
        ElectricCurrent(Handle_Units_Dimensions self) -> Standard_Real

        Returns the  power of  electrical  intensity (current)
        stored in the dimensions.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Handle_Units_Dimensions_ElectricCurrent(self, *args)


    def ThermodynamicTemperature(self, *args):
        """
        ThermodynamicTemperature(Handle_Units_Dimensions self) -> Standard_Real

        Returns  the  power  of   temperature stored  in   the
        dimensions.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Handle_Units_Dimensions_ThermodynamicTemperature(self, *args)


    def AmountOfSubstance(self, *args):
        """
        AmountOfSubstance(Handle_Units_Dimensions self) -> Standard_Real

        Returns  the power   of quantity   of  material (mole)
        stored in the dimensions.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Handle_Units_Dimensions_AmountOfSubstance(self, *args)


    def LuminousIntensity(self, *args):
        """
        LuminousIntensity(Handle_Units_Dimensions self) -> Standard_Real

        Returns the  power of light   intensity stored  in the
        dimensions.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Handle_Units_Dimensions_LuminousIntensity(self, *args)


    def PlaneAngle(self, *args):
        """
        PlaneAngle(Handle_Units_Dimensions self) -> Standard_Real

        Returns  the power   of plane   angle  stored  in  the
        dimensions.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Handle_Units_Dimensions_PlaneAngle(self, *args)


    def SolidAngle(self, *args):
        """
        SolidAngle(Handle_Units_Dimensions self) -> Standard_Real

        Returns the   power   of  solid angle stored   in  the
        dimensions.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Handle_Units_Dimensions_SolidAngle(self, *args)


    def Quantity(self, *args):
        """
        Quantity(Handle_Units_Dimensions self) -> Standard_CString

        Returns the quantity string of the dimension

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Handle_Units_Dimensions_Quantity(self, *args)


    def Multiply(self, *args):
        """
        Multiply(Handle_Units_Dimensions self, Handle_Units_Dimensions adimensions) -> Handle_Units_Dimensions

        Creates and returns  a new Dimensions  object which is
        the   result   of the  multiplication    of  <me>  and
        <adimensions>.

        :type adimensions: OCC.wrapper.Units.Handle_Units_Dimensions
        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Handle_Units_Dimensions_Multiply(self, *args)


    def Divide(self, *args):
        """
        Divide(Handle_Units_Dimensions self, Handle_Units_Dimensions adimensions) -> Handle_Units_Dimensions

        Creates and returns a new  Dimensions object which  is
        the result of the division of <me> by <adimensions>.

        :type adimensions: OCC.wrapper.Units.Handle_Units_Dimensions
        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Handle_Units_Dimensions_Divide(self, *args)


    def Power(self, *args):
        """
        Power(Handle_Units_Dimensions self, Standard_Real const anexponent) -> Handle_Units_Dimensions

        Creates  and returns a new  Dimensions object which is
        the result of the power of <me> and <anexponent>.

        :type anexponent: float
        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Handle_Units_Dimensions_Power(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(Handle_Units_Dimensions self, Handle_Units_Dimensions adimensions) -> Standard_Boolean

        Returns true if  <me>  and <adimensions> have the same
        dimensions, false otherwise.

        :type adimensions: OCC.wrapper.Units.Handle_Units_Dimensions
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_Dimensions_IsEqual(self, *args)


    def IsNotEqual(self, *args):
        """
        IsNotEqual(Handle_Units_Dimensions self, Handle_Units_Dimensions adimensions) -> Standard_Boolean

        Returns false if <me> and  <adimensions> have the same
        dimensions, true otherwise.

        :type adimensions: OCC.wrapper.Units.Handle_Units_Dimensions
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_Dimensions_IsNotEqual(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_Units_Dimensions self, Standard_Integer const ashift)

        Useful for degugging.

        :type ashift: int

        """
        return _Units.Handle_Units_Dimensions_Dump(self, *args)


    def ALess(self, *args):
        """
        ALess(Handle_Units_Dimensions self) -> Handle_Units_Dimensions

        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Handle_Units_Dimensions_ALess(self, *args)


    def AMass(self, *args):
        """
        AMass(Handle_Units_Dimensions self) -> Handle_Units_Dimensions

        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Handle_Units_Dimensions_AMass(self, *args)


    def ALength(self, *args):
        """
        ALength(Handle_Units_Dimensions self) -> Handle_Units_Dimensions

        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Handle_Units_Dimensions_ALength(self, *args)


    def ATime(self, *args):
        """
        ATime(Handle_Units_Dimensions self) -> Handle_Units_Dimensions

        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Handle_Units_Dimensions_ATime(self, *args)


    def AElectricCurrent(self, *args):
        """
        AElectricCurrent(Handle_Units_Dimensions self) -> Handle_Units_Dimensions

        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Handle_Units_Dimensions_AElectricCurrent(self, *args)


    def AThermodynamicTemperature(self, *args):
        """
        AThermodynamicTemperature(Handle_Units_Dimensions self) -> Handle_Units_Dimensions

        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Handle_Units_Dimensions_AThermodynamicTemperature(self, *args)


    def AAmountOfSubstance(self, *args):
        """
        AAmountOfSubstance(Handle_Units_Dimensions self) -> Handle_Units_Dimensions

        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Handle_Units_Dimensions_AAmountOfSubstance(self, *args)


    def ALuminousIntensity(self, *args):
        """
        ALuminousIntensity(Handle_Units_Dimensions self) -> Handle_Units_Dimensions

        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Handle_Units_Dimensions_ALuminousIntensity(self, *args)


    def APlaneAngle(self, *args):
        """
        APlaneAngle(Handle_Units_Dimensions self) -> Handle_Units_Dimensions

        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Handle_Units_Dimensions_APlaneAngle(self, *args)


    def ASolidAngle(self, *args):
        """
        ASolidAngle(Handle_Units_Dimensions self) -> Handle_Units_Dimensions

        Returns the basic dimensions.

        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Handle_Units_Dimensions_ASolidAngle(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Units_Dimensions self) -> char const *

        :rtype: const char *

        """
        return _Units.Handle_Units_Dimensions_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_Dimensions_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_Dimensions_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Units_Dimensions self)

        Memory deallocator for transient classes


        """
        return _Units.Handle_Units_Dimensions_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Units_Dimensions self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Units_Dimensions self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_Dimensions_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Units_Dimensions self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Units_Dimensions self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_Dimensions_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Units_Dimensions self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Units.Handle_Units_Dimensions_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Units_Dimensions self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_Dimensions_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Units_Dimensions self)

        Increments the reference counter of this object


        """
        return _Units.Handle_Units_Dimensions_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Units_Dimensions self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_Dimensions_DecrementRefCounter(self, *args)

Handle_Units_Dimensions_swigregister = _Units.Handle_Units_Dimensions_swigregister
Handle_Units_Dimensions_swigregister(Handle_Units_Dimensions)

def Handle_Units_Dimensions_DownCast(thing):
    return _Units.Handle_Units_Dimensions_DownCast(thing)
Handle_Units_Dimensions_DownCast = _Units.Handle_Units_Dimensions_DownCast

class Handle_Units_ShiftedToken(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Units_ShiftedToken self)

        Nullify the handle


        """
        return _Units.Handle_Units_ShiftedToken_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Units_ShiftedToken self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Units.Handle_Units_ShiftedToken_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Units_ShiftedToken self, Units_ShiftedToken thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Units.Handle_Units_ShiftedToken_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Units_ShiftedToken self, Handle_Units_ShiftedToken theHandle) -> Handle_Units_ShiftedToken
        assign(Handle_Units_ShiftedToken self, Units_ShiftedToken thePtr) -> Handle_Units_ShiftedToken
        assign(Handle_Units_ShiftedToken self, Handle_Units_ShiftedToken theHandle) -> Handle_Units_ShiftedToken

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Units.Handle_Units_ShiftedToken_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Units_ShiftedToken self) -> Units_ShiftedToken

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Units.Handle_Units_ShiftedToken_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Units_ShiftedToken self) -> Units_ShiftedToken

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Units.Handle_Units_ShiftedToken___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Units_ShiftedToken self) -> Units_ShiftedToken

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Units.Handle_Units_ShiftedToken___ref__(self, *args)


    def __hash__(self):
        return _Units.Handle_Units_ShiftedToken___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Units.Handle_Units_ShiftedToken___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Units.new_Handle_Units_ShiftedToken(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Units.Handle_Units_ShiftedToken_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_ShiftedToken

    def Creates(self, *args):
        """
        Creates(Handle_Units_ShiftedToken self) -> Handle_Units_Token

        Creates and returns a  token, which is a ShiftedToken.

        :rtype: OCC.wrapper.Units.Handle_Units_Token

        """
        return _Units.Handle_Units_ShiftedToken_Creates(self, *args)


    def Move(self, *args):
        """
        Move(Handle_Units_ShiftedToken self) -> Standard_Real

        Returns the gap <themove>

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Handle_Units_ShiftedToken_Move(self, *args)


    def Multiplied(self, *args):
        """
        Multiplied(Handle_Units_ShiftedToken self, Standard_Real const avalue) -> Standard_Real

        This  virtual   method  is  called  by the Measurement
        methods,  to   compute  the   measurement    during  a
        conversion.

        :type avalue: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Handle_Units_ShiftedToken_Multiplied(self, *args)


    def Divided(self, *args):
        """
        Divided(Handle_Units_ShiftedToken self, Standard_Real const avalue) -> Standard_Real

        This   virtual  method is  called  by  the Measurement
        methods,   to   compute   the   measurement   during a
        conversion.

        :type avalue: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Handle_Units_ShiftedToken_Divided(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_Units_ShiftedToken self, Standard_Integer const ashift, Standard_Integer const alevel)

        :type ashift: int
        :type alevel: int

        """
        return _Units.Handle_Units_ShiftedToken_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Units_ShiftedToken self) -> char const *

        :rtype: const char *

        """
        return _Units.Handle_Units_ShiftedToken_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_ShiftedToken_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_ShiftedToken_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Length(self, *args):
        """
        Length(Handle_Units_ShiftedToken self) -> Standard_Integer

        Returns the length of the word.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_ShiftedToken_Length(self, *args)


    def Word(self, *args):
        """
        Word(Handle_Units_ShiftedToken self) -> TCollection_AsciiString
        Word(Handle_Units_ShiftedToken self, Standard_CString const aword)

        Sets the field <theword> to <aword>.

        :type aword: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Handle_Units_ShiftedToken_Word(self, *args)


    def Mean(self, *args):
        """
        Mean(Handle_Units_ShiftedToken self) -> TCollection_AsciiString
        Mean(Handle_Units_ShiftedToken self, Standard_CString const amean)

        Sets the field <themean> to <amean>.

        :type amean: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Handle_Units_ShiftedToken_Mean(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Units_ShiftedToken self) -> Standard_Real
        Value(Handle_Units_ShiftedToken self, Standard_Real const avalue)

        Sets the field <thevalue> to <avalue>.

        :type avalue: float

        """
        return _Units.Handle_Units_ShiftedToken_Value(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_Units_ShiftedToken self) -> Handle_Units_Dimensions
        Dimensions(Handle_Units_ShiftedToken self, Handle_Units_Dimensions adimensions)

        Sets the field <thedimensions> to <adimensions>.

        :type adimensions: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Handle_Units_ShiftedToken_Dimensions(self, *args)


    def Update(self, *args):
        """
        Update(Handle_Units_ShiftedToken self, Standard_CString const amean)

        Updates     the  token  <me>    with  the   additional
        signification  <amean> by  concatenation   of the  two
        strings   <themean>    and   <amean>.   If    the  two
        significations are  the same  , an information message
        is written in the output device.

        :type amean: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Handle_Units_ShiftedToken_Update(self, *args)


    def Add(self, *args):
        """
        Add(Handle_Units_ShiftedToken self, Standard_Integer const aninteger) -> Handle_Units_Token
        Add(Handle_Units_ShiftedToken self, Handle_Units_Token atoken) -> Handle_Units_Token

        Returns a  token which is  the addition  of  <me>  and
        another token <atoken>. The  addition  is  possible if
        and only if the dimensions are the same.

        :type atoken: OCC.wrapper.Units.Handle_Units_Token
        :rtype: OCC.wrapper.Units.Handle_Units_Token

        """
        return _Units.Handle_Units_ShiftedToken_Add(self, *args)


    def Subtract(self, *args):
        """
        Subtract(Handle_Units_ShiftedToken self, Handle_Units_Token atoken) -> Handle_Units_Token

        Returns a token  which is the  subtraction of <me> and
        another token <atoken>. The subtraction is possible if
        and only if the dimensions are the same.

        :type atoken: OCC.wrapper.Units.Handle_Units_Token
        :rtype: OCC.wrapper.Units.Handle_Units_Token

        """
        return _Units.Handle_Units_ShiftedToken_Subtract(self, *args)


    def Multiply(self, *args):
        """
        Multiply(Handle_Units_ShiftedToken self, Handle_Units_Token atoken) -> Handle_Units_Token

        Returns a  token  which  is the  product of   <me> and
        another token <atoken>.

        :type atoken: OCC.wrapper.Units.Handle_Units_Token
        :rtype: OCC.wrapper.Units.Handle_Units_Token

        """
        return _Units.Handle_Units_ShiftedToken_Multiply(self, *args)


    def Divide(self, *args):
        """
        Divide(Handle_Units_ShiftedToken self, Handle_Units_Token atoken) -> Handle_Units_Token

        Returns a token which is the division of <me> by another
        token <atoken>.

        :type atoken: OCC.wrapper.Units.Handle_Units_Token
        :rtype: OCC.wrapper.Units.Handle_Units_Token

        """
        return _Units.Handle_Units_ShiftedToken_Divide(self, *args)


    def Power(self, *args):
        """
        Power(Handle_Units_ShiftedToken self, Handle_Units_Token atoken) -> Handle_Units_Token
        Power(Handle_Units_ShiftedToken self, Standard_Real const anexponent) -> Handle_Units_Token

        Returns a token which is <me> to the power  of <anexponent>.

        :type anexponent: float
        :rtype: OCC.wrapper.Units.Handle_Units_Token

        """
        return _Units.Handle_Units_ShiftedToken_Power(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(Handle_Units_ShiftedToken self, Standard_CString const astring) -> Standard_Boolean
        IsEqual(Handle_Units_ShiftedToken self, Handle_Units_Token atoken) -> Standard_Boolean

        Returns true  if the  field  <theword> and  the string
        <theword> contained  in  the  token <atoken>  are  the
        same, false otherwise.

        :type atoken: OCC.wrapper.Units.Handle_Units_Token
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_ShiftedToken_IsEqual(self, *args)


    def IsNotEqual(self, *args):
        """
        IsNotEqual(Handle_Units_ShiftedToken self, Standard_CString const astring) -> Standard_Boolean
        IsNotEqual(Handle_Units_ShiftedToken self, Handle_Units_Token atoken) -> Standard_Boolean

        Returns false if  the field <theword>  and the  string
        <theword> contained  in the  token  <atoken>  are  the
        same, true otherwise.

        :type atoken: OCC.wrapper.Units.Handle_Units_Token
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_ShiftedToken_IsNotEqual(self, *args)


    def IsLessOrEqual(self, *args):
        """
        IsLessOrEqual(Handle_Units_ShiftedToken self, Standard_CString const astring) -> Standard_Boolean

        Returns   true  if the   field <theword>  is  strictly
        contained at  the beginning  of the string  <astring>,
        false otherwise.

        :type astring: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_ShiftedToken_IsLessOrEqual(self, *args)


    def IsGreater(self, *args):
        """
        IsGreater(Handle_Units_ShiftedToken self, Standard_CString const astring) -> Standard_Boolean
        IsGreater(Handle_Units_ShiftedToken self, Handle_Units_Token atoken) -> Standard_Boolean

        Returns false  if   the field   <theword> is  strictly
        contained at  the  beginning  of the string <astring>,
        true otherwise.

        :type atoken: OCC.wrapper.Units.Handle_Units_Token
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_ShiftedToken_IsGreater(self, *args)


    def IsGreaterOrEqual(self, *args):
        """
        IsGreaterOrEqual(Handle_Units_ShiftedToken self, Handle_Units_Token atoken) -> Standard_Boolean

        Returns true  if  the string <astring>   is   strictly
        contained   at the  beginning  of  the field <theword>
        false otherwise.

        :type atoken: OCC.wrapper.Units.Handle_Units_Token
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_ShiftedToken_IsGreaterOrEqual(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Units_ShiftedToken self)

        Memory deallocator for transient classes


        """
        return _Units.Handle_Units_ShiftedToken_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Units_ShiftedToken self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Units_ShiftedToken self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_ShiftedToken_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Units_ShiftedToken self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Units_ShiftedToken self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_ShiftedToken_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Units_ShiftedToken self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Units.Handle_Units_ShiftedToken_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Units_ShiftedToken self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_ShiftedToken_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Units_ShiftedToken self)

        Increments the reference counter of this object


        """
        return _Units.Handle_Units_ShiftedToken_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Units_ShiftedToken self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_ShiftedToken_DecrementRefCounter(self, *args)

Handle_Units_ShiftedToken_swigregister = _Units.Handle_Units_ShiftedToken_swigregister
Handle_Units_ShiftedToken_swigregister(Handle_Units_ShiftedToken)

def Handle_Units_ShiftedToken_DownCast(thing):
    return _Units.Handle_Units_ShiftedToken_DownCast(thing)
Handle_Units_ShiftedToken_DownCast = _Units.Handle_Units_ShiftedToken_DownCast

class Units_Measurement(object):
    """
    This class  defines  a measurement which is the
    association of a real value and a unit.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Units_Measurement self) -> Units_Measurement
        __init__(Units_Measurement self, Standard_Real const avalue, Handle_Units_Token atoken) -> Units_Measurement
        __init__(Units_Measurement self, Standard_Real const avalue, Standard_CString const aunit) -> Units_Measurement

        Returns an  instance of this  class.  <avalue> defines
        the  measurement, and <aunit> the   unit used,
        described in natural language.

        :type avalue: float
        :type aunit: OCC.wrapper.Standard.Standard_CString

        """
        this = _Units.new_Units_Measurement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Convert(self, *args):
        """
        Convert(Units_Measurement self, Standard_CString const aunit)

        Converts (if   possible)  the  measurement   object into
        another   unit.      <aunit>   must  have    the  same
        dimensionality as  the  unit  contained in   the token
        <thetoken>.

        :type aunit: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Units_Measurement_Convert(self, *args)


    def Integer(self, *args):
        """
        Integer(Units_Measurement self) -> Units_Measurement

        Returns a Measurement object with the integer value of
        the measurement contained in <me>.

        :rtype: OCC.wrapper.Units.Units_Measurement

        """
        return _Units.Units_Measurement_Integer(self, *args)


    def Fractional(self, *args):
        """
        Fractional(Units_Measurement self) -> Units_Measurement

        Returns a Measurement object with the fractional value
        of the measurement contained in <me>.

        :rtype: OCC.wrapper.Units.Units_Measurement

        """
        return _Units.Units_Measurement_Fractional(self, *args)


    def Measurement(self, *args):
        """
        Measurement(Units_Measurement self) -> Standard_Real

        Returns the value of the measurement.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Units_Measurement_Measurement(self, *args)


    def Token(self, *args):
        """
        Token(Units_Measurement self) -> Handle_Units_Token

        Returns the token contained in <me>.

        :rtype: OCC.wrapper.Units.Handle_Units_Token

        """
        return _Units.Units_Measurement_Token(self, *args)


    def Add(self, *args):
        """
        Add(Units_Measurement self, Units_Measurement ameasurement) -> Units_Measurement

        Returns (if it is possible) a measurement which is the
        addition  of  <me>  and  <ameasurement>.  The   chosen
        returned unit is the unit of <me>.

        :type ameasurement: OCC.wrapper.Units.Units_Measurement
        :rtype: OCC.wrapper.Units.Units_Measurement

        """
        return _Units.Units_Measurement_Add(self, *args)


    def __add__(self, *args):
        """
        __add__(Units_Measurement self, Units_Measurement ameasurement) -> Units_Measurement

        :type ameasurement: OCC.wrapper.Units.Units_Measurement
        :rtype: OCC.wrapper.Units.Units_Measurement

        """
        return _Units.Units_Measurement___add__(self, *args)


    def Subtract(self, *args):
        """
        Subtract(Units_Measurement self, Units_Measurement ameasurement) -> Units_Measurement

        Returns (if it is possible) a measurement which is the
        subtraction of  <me>  and <ameasurement>.   The chosen
        returned unit is the unit of <me>.

        :type ameasurement: OCC.wrapper.Units.Units_Measurement
        :rtype: OCC.wrapper.Units.Units_Measurement

        """
        return _Units.Units_Measurement_Subtract(self, *args)


    def __sub__(self, *args):
        """
        __sub__(Units_Measurement self, Units_Measurement ameasurement) -> Units_Measurement

        :type ameasurement: OCC.wrapper.Units.Units_Measurement
        :rtype: OCC.wrapper.Units.Units_Measurement

        """
        return _Units.Units_Measurement___sub__(self, *args)


    def Multiply(self, *args):
        """
        Multiply(Units_Measurement self, Units_Measurement ameasurement) -> Units_Measurement
        Multiply(Units_Measurement self, Standard_Real const avalue) -> Units_Measurement

        Returns  a measurement which  is the multiplication of
        <me> with the value  <avalue>.

        :type avalue: float
        :rtype: OCC.wrapper.Units.Units_Measurement

        """
        return _Units.Units_Measurement_Multiply(self, *args)


    def __mul__(self, *args):
        """
        __mul__(Units_Measurement self, Units_Measurement ameasurement) -> Units_Measurement
        __mul__(Units_Measurement self, Standard_Real const avalue) -> Units_Measurement

        :type avalue: float
        :rtype: OCC.wrapper.Units.Units_Measurement

        """
        return _Units.Units_Measurement___mul__(self, *args)


    def Divide(self, *args):
        """
        Divide(Units_Measurement self, Units_Measurement ameasurement) -> Units_Measurement
        Divide(Units_Measurement self, Standard_Real const avalue) -> Units_Measurement

        Returns  a measurement which  is the division of <me> by
        the constant <avalue>.

        :type avalue: float
        :rtype: OCC.wrapper.Units.Units_Measurement

        """
        return _Units.Units_Measurement_Divide(self, *args)


    def __truediv__(self, *args):
        return _Units.Units_Measurement___truediv__(self, *args)
    __div__ = __truediv__



    def Power(self, *args):
        """
        Power(Units_Measurement self, Standard_Real const anexponent) -> Units_Measurement

        Returns   a    measurement  which   is <me>    powered
        <anexponent>.

        :type anexponent: float
        :rtype: OCC.wrapper.Units.Units_Measurement

        """
        return _Units.Units_Measurement_Power(self, *args)


    def HasToken(self, *args):
        """
        HasToken(Units_Measurement self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Units_Measurement_HasToken(self, *args)


    def Dump(self, *args):
        """
        Dump(Units_Measurement self)

        Useful for debugging.


        """
        return _Units.Units_Measurement_Dump(self, *args)

    __swig_destroy__ = _Units.delete_Units_Measurement
Units_Measurement_swigregister = _Units.Units_Measurement_swigregister
Units_Measurement_swigregister(Units_Measurement)

class NCollection_Sequence_Handle_Units_Quantity(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_Units_Quantity self) -> NCollection_Sequence< opencascade::handle< Units_Quantity > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Units.NCollection_Sequence_Handle_Units_Quantity_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_Units_Quantity self) -> NCollection_Sequence< opencascade::handle< Units_Quantity > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Units.NCollection_Sequence_Handle_Units_Quantity_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_Units_Quantity self) -> NCollection_Sequence< opencascade::handle< Units_Quantity > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Units.NCollection_Sequence_Handle_Units_Quantity_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_Units_Quantity self) -> NCollection_Sequence< opencascade::handle< Units_Quantity > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Units.NCollection_Sequence_Handle_Units_Quantity_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Units.new_NCollection_Sequence_Handle_Units_Quantity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_Units_Quantity self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.NCollection_Sequence_Handle_Units_Quantity_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_Units_Quantity self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.NCollection_Sequence_Handle_Units_Quantity_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_Units_Quantity self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.NCollection_Sequence_Handle_Units_Quantity_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_Units_Quantity self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.NCollection_Sequence_Handle_Units_Quantity_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_Units_Quantity self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.NCollection_Sequence_Handle_Units_Quantity_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_Units_Quantity self)

        Reverse sequence


        """
        return _Units.NCollection_Sequence_Handle_Units_Quantity_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_Units_Quantity self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Units.NCollection_Sequence_Handle_Units_Quantity_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Units.NCollection_Sequence_Handle_Units_Quantity_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_Units_Quantity self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Units.NCollection_Sequence_Handle_Units_Quantity_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_Units_Quantity self, NCollection_Sequence_Handle_Units_Quantity theOther) -> NCollection_Sequence_Handle_Units_Quantity

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Units.NCollection_Sequence_Handle_Units_Quantity_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_Units_Quantity self, NCollection_Sequence_Handle_Units_Quantity theOther) -> NCollection_Sequence_Handle_Units_Quantity

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Units.NCollection_Sequence_Handle_Units_Quantity_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_Units_Quantity self, NCollection_Sequence< opencascade::handle< Units_Quantity > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_Units_Quantity self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_Units_Quantity self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Units.NCollection_Sequence_Handle_Units_Quantity_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_Units_Quantity self, Handle_Units_Quantity theItem)
        Append(NCollection_Sequence_Handle_Units_Quantity self, NCollection_Sequence_Handle_Units_Quantity theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Units.NCollection_Sequence_Handle_Units_Quantity_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_Units_Quantity self, Handle_Units_Quantity theItem)
        Prepend(NCollection_Sequence_Handle_Units_Quantity self, NCollection_Sequence_Handle_Units_Quantity theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Units.NCollection_Sequence_Handle_Units_Quantity_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_Units_Quantity self, Standard_Integer const theIndex, Handle_Units_Quantity theItem)
        InsertBefore(NCollection_Sequence_Handle_Units_Quantity self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Units_Quantity theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Units.NCollection_Sequence_Handle_Units_Quantity_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_Units_Quantity self, NCollection_Sequence< opencascade::handle< Units_Quantity > >::Iterator & thePosition, Handle_Units_Quantity theItem)
        InsertAfter(NCollection_Sequence_Handle_Units_Quantity self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Units_Quantity theSeq)
        InsertAfter(NCollection_Sequence_Handle_Units_Quantity self, Standard_Integer const theIndex, Handle_Units_Quantity theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Units.NCollection_Sequence_Handle_Units_Quantity_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_Units_Quantity self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Units_Quantity theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Units.NCollection_Sequence_Handle_Units_Quantity_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Units.NCollection_Sequence_Handle_Units_Quantity_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_Units_Quantity self) -> Handle_Units_Quantity

        First item access

        :rtype: TheItemType &

        """
        return _Units.NCollection_Sequence_Handle_Units_Quantity_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Units.NCollection_Sequence_Handle_Units_Quantity_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_Units_Quantity self) -> Handle_Units_Quantity

        Last item access

        :rtype: TheItemType &

        """
        return _Units.NCollection_Sequence_Handle_Units_Quantity_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Units.NCollection_Sequence_Handle_Units_Quantity_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_Units_Quantity self, Standard_Integer const theIndex) -> Handle_Units_Quantity

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Units.NCollection_Sequence_Handle_Units_Quantity_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Units.NCollection_Sequence_Handle_Units_Quantity___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_Units_Quantity self, Standard_Integer const theIndex, Handle_Units_Quantity theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Units.NCollection_Sequence_Handle_Units_Quantity_SetValue(self, *args)


    def __iter__(self):
        return _Units.NCollection_Sequence_Handle_Units_Quantity___iter__(self)
    __swig_destroy__ = _Units.delete_NCollection_Sequence_Handle_Units_Quantity
NCollection_Sequence_Handle_Units_Quantity_swigregister = _Units.NCollection_Sequence_Handle_Units_Quantity_swigregister
NCollection_Sequence_Handle_Units_Quantity_swigregister(NCollection_Sequence_Handle_Units_Quantity)

def NCollection_Sequence_Handle_Units_Quantity_delNode(*args):
    """
    NCollection_Sequence_Handle_Units_Quantity_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Units.NCollection_Sequence_Handle_Units_Quantity_delNode(*args)

class NCollection_Sequence_Handle_Units_Quantity_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Units.new_NCollection_Sequence_Handle_Units_Quantity_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Units.delete_NCollection_Sequence_Handle_Units_Quantity_IteratorHelper

    def __next__(self):
        return _Units.NCollection_Sequence_Handle_Units_Quantity_IteratorHelper___next__(self)
NCollection_Sequence_Handle_Units_Quantity_IteratorHelper_swigregister = _Units.NCollection_Sequence_Handle_Units_Quantity_IteratorHelper_swigregister
NCollection_Sequence_Handle_Units_Quantity_IteratorHelper_swigregister(NCollection_Sequence_Handle_Units_Quantity_IteratorHelper)


try:
	Units_QtsSequence = NCollection_Sequence_Handle_Units_Quantity
except NameError:
	pass # does not exist, probably ignored

class Units_TokensSequence(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Units_TokensSequence
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Units_TokensSequence(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Units_TokensSequence self) -> Units_TokensSequence
        __init__(Units_TokensSequence self, NCollection_Sequence_Handle_Units_Token theOther) -> Units_TokensSequence

        :type theOther: OCC.wrapper.Units.Units_TksSequence

        """
        this = _Units.new_Units_TokensSequence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.Units.Units_TksSequence

        """
        res = _Units.Units_TokensSequence_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Units_TokensSequence self, Handle_Units_Token theItem)
        Append(Units_TokensSequence self, NCollection_Sequence_Handle_Units_Token theSequence)

        :type theSequence: OCC.wrapper.Units.Units_TksSequence

        """
        return _Units.Units_TokensSequence_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Units_TokensSequence self) -> NCollection_Sequence_Handle_Units_Token

        :rtype: OCC.wrapper.Units.Units_TksSequence

        """
        return _Units.Units_TokensSequence_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Units.Units_TokensSequence_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Units.Units_TokensSequence_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Units_TokensSequence_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Units.delete_Units_TokensSequence
Units_TokensSequence_swigregister = _Units.Units_TokensSequence_swigregister
Units_TokensSequence_swigregister(Units_TokensSequence)

def Units_TokensSequence_get_type_name(*args):
    """
    Units_TokensSequence_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Units.Units_TokensSequence_get_type_name(*args)

def Units_TokensSequence_get_type_descriptor(*args):
    """
    Units_TokensSequence_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Units.Units_TokensSequence_get_type_descriptor(*args)

class Units_UnitSentence(Units_Sentence):
    """
    This   class describes   all    the  facilities to
    manipulate and compute units contained in a string
    expression.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Units_UnitSentence self, Standard_CString const astring) -> Units_UnitSentence
        __init__(Units_UnitSentence self, Standard_CString const astring, Handle_Units_QuantitiesSequence aquantitiessequence) -> Units_UnitSentence

        Creates  and returns    a  UnitSentence.  The   string
        <astring> describes in natural language the unit to be
        analysed.   The    sequence     of physical quantities
        <asequenceofquantities>   describes    the   available
        dictionary of units you want to use.

        :type astring: OCC.wrapper.Standard.Standard_CString
        :type aquantitiessequence: OCC.wrapper.Units.Handle_Units_QuantitiesSequence

        """
        this = _Units.new_Units_UnitSentence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Analyse(self, *args):
        """
        Analyse(Units_UnitSentence self)

        Analyzes   the sequence  of   tokens  created  by  the
        constructor to  find  the true significance   of  each
        token.


        """
        return _Units.Units_UnitSentence_Analyse(self, *args)


    def SetUnits(self, *args):
        """
        SetUnits(Units_UnitSentence self, Handle_Units_QuantitiesSequence aquantitiessequence)

        For each token which  represents a unit, finds  in the
        sequence    of    physical   quantities      all   the
        characteristics of the unit found.

        :type aquantitiessequence: OCC.wrapper.Units.Handle_Units_QuantitiesSequence

        """
        return _Units.Units_UnitSentence_SetUnits(self, *args)

    __swig_destroy__ = _Units.delete_Units_UnitSentence
Units_UnitSentence_swigregister = _Units.Units_UnitSentence_swigregister
Units_UnitSentence_swigregister(Units_UnitSentence)

class Units_(object):
    """
    This  package provides all the  facilities  to create
    and question a dictionary of  units,  and also  to
    manipulate measurements which are real values with
    units.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def UnitsFile(*args):
        """
        UnitsFile(Standard_CString const afile)

        Defines the location of the file containing all the
        information useful in creating the dictionary of all
        the units known to the system.

        :type afile: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Units__UnitsFile(*args)

    UnitsFile = staticmethod(UnitsFile)

    def LexiconFile(*args):
        """
        LexiconFile(Standard_CString const afile)

        Defines the location of the file containing the lexicon
        useful in manipulating composite units.

        :type afile: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Units__LexiconFile(*args)

    LexiconFile = staticmethod(LexiconFile)

    def DictionaryOfUnits(*args):
        """
        DictionaryOfUnits(Standard_Boolean const amode) -> Handle_Units_UnitsDictionary

        Returns a unique instance of the dictionary of units.
        If <amode> is True, then it forces the recomputation of
        the dictionary of units.

        :type amode: bool
        :rtype: OCC.wrapper.Units.Handle_Units_UnitsDictionary

        """
        return _Units.Units__DictionaryOfUnits(*args)

    DictionaryOfUnits = staticmethod(DictionaryOfUnits)

    def Quantity(*args):
        """
        Quantity(Standard_CString const aquantity) -> Handle_Units_Quantity

        Returns a unique quantity instance corresponding to <aquantity>.

        :type aquantity: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Units.Handle_Units_Quantity

        """
        return _Units.Units__Quantity(*args)

    Quantity = staticmethod(Quantity)

    def FirstQuantity(*args):
        """
        FirstQuantity(Standard_CString const aunit) -> Standard_CString

        Returns the first quantity string founded from the unit <aUnit>.

        :type aunit: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Units__FirstQuantity(*args)

    FirstQuantity = staticmethod(FirstQuantity)

    def LexiconUnits(*args):
        """
        LexiconUnits(Standard_Boolean const amode) -> Handle_Units_Lexicon

        Returns a unique instance of the Units_Lexicon.
        If <amode> is True, it forces the recomputation of
        the dictionary of units, and by consequence the
        completion of the Units_Lexicon.

        :type amode: bool
        :rtype: OCC.wrapper.Units.Handle_Units_Lexicon

        """
        return _Units.Units__LexiconUnits(*args)

    LexiconUnits = staticmethod(LexiconUnits)

    def LexiconFormula(*args):
        """
        LexiconFormula() -> Handle_Units_Lexicon

        Return a unique instance of LexiconFormula.

        :rtype: OCC.wrapper.Units.Handle_Units_Lexicon

        """
        return _Units.Units__LexiconFormula(*args)

    LexiconFormula = staticmethod(LexiconFormula)

    def NullDimensions(*args):
        """
        NullDimensions() -> Handle_Units_Dimensions

        Returns always the same instance of Dimensions.

        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Units__NullDimensions(*args)

    NullDimensions = staticmethod(NullDimensions)

    def Convert(*args):
        """
        Convert(Standard_Real const avalue, Standard_CString const afirstunit, Standard_CString const asecondunit) -> Standard_Real

        Converts <avalue> expressed in <afirstunit> into the <asecondunit>.

        :type avalue: float
        :type afirstunit: OCC.wrapper.Standard.Standard_CString
        :type asecondunit: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Units__Convert(*args)

    Convert = staticmethod(Convert)

    def ToSI(*args):
        """
        ToSI(Standard_Real const aData, Standard_CString const aUnit) -> Standard_Real
        ToSI(Standard_Real const aData, Standard_CString const aUnit, Handle_Units_Dimensions aDim) -> Standard_Real

        :type aData: float
        :type aUnit: OCC.wrapper.Standard.Standard_CString
        :type aDim: OCC.wrapper.Units.Handle_Units_Dimensions
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Units__ToSI(*args)

    ToSI = staticmethod(ToSI)

    def FromSI(*args):
        """
        FromSI(Standard_Real const aData, Standard_CString const aUnit) -> Standard_Real
        FromSI(Standard_Real const aData, Standard_CString const aUnit, Handle_Units_Dimensions aDim) -> Standard_Real

        :type aData: float
        :type aUnit: OCC.wrapper.Standard.Standard_CString
        :type aDim: OCC.wrapper.Units.Handle_Units_Dimensions
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Units__FromSI(*args)

    FromSI = staticmethod(FromSI)

    def Dimensions(*args):
        """
        Dimensions(Standard_CString const aType) -> Handle_Units_Dimensions

        return the dimension associated to the Type

        :type aType: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Units__Dimensions(*args)

    Dimensions = staticmethod(Dimensions)

    def __init__(self):
        """
        This  package provides all the  facilities  to create
        and question a dictionary of  units,  and also  to
        manipulate measurements which are real values with
        units.
        """
        this = _Units.new_Units_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Units.delete_Units_
Units__swigregister = _Units.Units__swigregister
Units__swigregister(Units_)

def Units__UnitsFile(*args):
    """
    Units__UnitsFile(Standard_CString const afile)

    Defines the location of the file containing all the
    information useful in creating the dictionary of all
    the units known to the system.

    :type afile: OCC.wrapper.Standard.Standard_CString

    """
    return _Units.Units__UnitsFile(*args)

def Units__LexiconFile(*args):
    """
    Units__LexiconFile(Standard_CString const afile)

    Defines the location of the file containing the lexicon
    useful in manipulating composite units.

    :type afile: OCC.wrapper.Standard.Standard_CString

    """
    return _Units.Units__LexiconFile(*args)

def Units__DictionaryOfUnits(*args):
    """
    Units__DictionaryOfUnits(Standard_Boolean const amode) -> Handle_Units_UnitsDictionary

    Returns a unique instance of the dictionary of units.
    If <amode> is True, then it forces the recomputation of
    the dictionary of units.

    :type amode: bool
    :rtype: OCC.wrapper.Units.Handle_Units_UnitsDictionary

    """
    return _Units.Units__DictionaryOfUnits(*args)

def Units__Quantity(*args):
    """
    Units__Quantity(Standard_CString const aquantity) -> Handle_Units_Quantity

    Returns a unique quantity instance corresponding to <aquantity>.

    :type aquantity: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Units.Handle_Units_Quantity

    """
    return _Units.Units__Quantity(*args)

def Units__FirstQuantity(*args):
    """
    Units__FirstQuantity(Standard_CString const aunit) -> Standard_CString

    Returns the first quantity string founded from the unit <aUnit>.

    :type aunit: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_CString

    """
    return _Units.Units__FirstQuantity(*args)

def Units__LexiconUnits(*args):
    """
    Units__LexiconUnits(Standard_Boolean const amode) -> Handle_Units_Lexicon

    Returns a unique instance of the Units_Lexicon.
    If <amode> is True, it forces the recomputation of
    the dictionary of units, and by consequence the
    completion of the Units_Lexicon.

    :type amode: bool
    :rtype: OCC.wrapper.Units.Handle_Units_Lexicon

    """
    return _Units.Units__LexiconUnits(*args)

def Units__LexiconFormula(*args):
    """
    Units__LexiconFormula() -> Handle_Units_Lexicon

    Return a unique instance of LexiconFormula.

    :rtype: OCC.wrapper.Units.Handle_Units_Lexicon

    """
    return _Units.Units__LexiconFormula(*args)

def Units__NullDimensions(*args):
    """
    Units__NullDimensions() -> Handle_Units_Dimensions

    Returns always the same instance of Dimensions.

    :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

    """
    return _Units.Units__NullDimensions(*args)

def Units__Convert(*args):
    """
    Units__Convert(Standard_Real const avalue, Standard_CString const afirstunit, Standard_CString const asecondunit) -> Standard_Real

    Converts <avalue> expressed in <afirstunit> into the <asecondunit>.

    :type avalue: float
    :type afirstunit: OCC.wrapper.Standard.Standard_CString
    :type asecondunit: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Units.Units__Convert(*args)

def Units__ToSI(*args):
    """
    ToSI(Standard_Real const aData, Standard_CString const aUnit) -> Standard_Real
    Units__ToSI(Standard_Real const aData, Standard_CString const aUnit, Handle_Units_Dimensions aDim) -> Standard_Real

    :type aData: float
    :type aUnit: OCC.wrapper.Standard.Standard_CString
    :type aDim: OCC.wrapper.Units.Handle_Units_Dimensions
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Units.Units__ToSI(*args)

def Units__FromSI(*args):
    """
    FromSI(Standard_Real const aData, Standard_CString const aUnit) -> Standard_Real
    Units__FromSI(Standard_Real const aData, Standard_CString const aUnit, Handle_Units_Dimensions aDim) -> Standard_Real

    :type aData: float
    :type aUnit: OCC.wrapper.Standard.Standard_CString
    :type aDim: OCC.wrapper.Units.Handle_Units_Dimensions
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Units.Units__FromSI(*args)

def Units__Dimensions(*args):
    """
    Units__Dimensions(Standard_CString const aType) -> Handle_Units_Dimensions

    return the dimension associated to the Type

    :type aType: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Units.Handle_Units_Dimensions

    """
    return _Units.Units__Dimensions(*args)

class Units_UnitsLexicon(Units_Lexicon):
    """
    This class defines a lexicon useful to analyse and
    recognize the different key  words  included  in a
    sentence. The  lexicon is stored  in a sequence of
    tokens.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Units_UnitsLexicon
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Units_UnitsLexicon(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Units_UnitsLexicon self) -> Units_UnitsLexicon

        Returns an empty instance of UnitsLexicon


        """
        this = _Units.new_Units_UnitsLexicon(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Creates(self, *args):
        """
        Creates(Units_UnitsLexicon self, Standard_Boolean const amode)

        Reads  the files  <afilename1>  and  <afilename2>   to
        create     a   sequence     of    tokens   stored   in
        <thesequenceoftokens>.

        :type amode: bool

        """
        return _Units.Units_UnitsLexicon_Creates(self, *args)


    def Dump(self, *args):
        """
        Dump(Units_UnitsLexicon self)

        Useful for debugging.


        """
        return _Units.Units_UnitsLexicon_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Units.Units_UnitsLexicon_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Units.Units_UnitsLexicon_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Units_UnitsLexicon_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Units.delete_Units_UnitsLexicon
Units_UnitsLexicon_swigregister = _Units.Units_UnitsLexicon_swigregister
Units_UnitsLexicon_swigregister(Units_UnitsLexicon)

def Units_UnitsLexicon_get_type_name(*args):
    """
    Units_UnitsLexicon_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Units.Units_UnitsLexicon_get_type_name(*args)

def Units_UnitsLexicon_get_type_descriptor(*args):
    """
    Units_UnitsLexicon_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Units.Units_UnitsLexicon_get_type_descriptor(*args)

class Units_MathSentence(Units_Sentence):
    """
    This class  defines all the methods to  create and
    compute an algebraic formula.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Units_MathSentence self, Standard_CString const astring) -> Units_MathSentence

        Creates and returns a  MathSentence object. The string
        <astring>  describes  an algebraic  formula in natural
        language.

        :type astring: OCC.wrapper.Standard.Standard_CString

        """
        this = _Units.new_Units_MathSentence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Units.delete_Units_MathSentence
Units_MathSentence_swigregister = _Units.Units_MathSentence_swigregister
Units_MathSentence_swigregister(Units_MathSentence)

class Handle_Units_NoSuchUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Units_NoSuchUnit self)

        Nullify the handle


        """
        return _Units.Handle_Units_NoSuchUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Units_NoSuchUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Units.Handle_Units_NoSuchUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Units_NoSuchUnit self, Units_NoSuchUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Units.Handle_Units_NoSuchUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Units_NoSuchUnit self, Handle_Units_NoSuchUnit theHandle) -> Handle_Units_NoSuchUnit
        assign(Handle_Units_NoSuchUnit self, Units_NoSuchUnit thePtr) -> Handle_Units_NoSuchUnit
        assign(Handle_Units_NoSuchUnit self, Handle_Units_NoSuchUnit theHandle) -> Handle_Units_NoSuchUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Units.Handle_Units_NoSuchUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Units_NoSuchUnit self) -> Units_NoSuchUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Units.Handle_Units_NoSuchUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Units_NoSuchUnit self) -> Units_NoSuchUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Units.Handle_Units_NoSuchUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Units_NoSuchUnit self) -> Units_NoSuchUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Units.Handle_Units_NoSuchUnit___ref__(self, *args)


    def __hash__(self):
        return _Units.Handle_Units_NoSuchUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Units.Handle_Units_NoSuchUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Units.new_Handle_Units_NoSuchUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Units.Handle_Units_NoSuchUnit_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_NoSuchUnit

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Units_NoSuchUnit self, Standard_CString const theMessage) -> Handle_Units_NoSuchUnit

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Units.Handle_Units_NoSuchUnit

        """
        return _Units.Handle_Units_NoSuchUnit_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Units_NoSuchUnit self) -> char const *

        :rtype: const char *

        """
        return _Units.Handle_Units_NoSuchUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_NoSuchUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_NoSuchUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Units_NoSuchUnit self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Units.Handle_Units_NoSuchUnit_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Units_NoSuchUnit self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Handle_Units_NoSuchUnit_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Units_NoSuchUnit self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Handle_Units_NoSuchUnit_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Units_NoSuchUnit self)
        Reraise(Handle_Units_NoSuchUnit self, Standard_CString const aMessage)
        Reraise(Handle_Units_NoSuchUnit self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Units.Handle_Units_NoSuchUnit_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Units_NoSuchUnit self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Units.Handle_Units_NoSuchUnit_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Units_NoSuchUnit self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Units.Handle_Units_NoSuchUnit_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Units_NoSuchUnit self)

        Memory deallocator for transient classes


        """
        return _Units.Handle_Units_NoSuchUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Units_NoSuchUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Units_NoSuchUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_NoSuchUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Units_NoSuchUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Units_NoSuchUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_NoSuchUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Units_NoSuchUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Units.Handle_Units_NoSuchUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Units_NoSuchUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_NoSuchUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Units_NoSuchUnit self)

        Increments the reference counter of this object


        """
        return _Units.Handle_Units_NoSuchUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Units_NoSuchUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_NoSuchUnit_DecrementRefCounter(self, *args)

Handle_Units_NoSuchUnit_swigregister = _Units.Handle_Units_NoSuchUnit_swigregister
Handle_Units_NoSuchUnit_swigregister(Handle_Units_NoSuchUnit)

def Handle_Units_NoSuchUnit_DownCast(thing):
    return _Units.Handle_Units_NoSuchUnit_DownCast(thing)
Handle_Units_NoSuchUnit_DownCast = _Units.Handle_Units_NoSuchUnit_DownCast

class Handle_Units_Lexicon(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Units_Lexicon self)

        Nullify the handle


        """
        return _Units.Handle_Units_Lexicon_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Units_Lexicon self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Units.Handle_Units_Lexicon_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Units_Lexicon self, Units_Lexicon thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Units.Handle_Units_Lexicon_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Units_Lexicon self, Handle_Units_Lexicon theHandle) -> Handle_Units_Lexicon
        assign(Handle_Units_Lexicon self, Units_Lexicon thePtr) -> Handle_Units_Lexicon
        assign(Handle_Units_Lexicon self, Handle_Units_Lexicon theHandle) -> Handle_Units_Lexicon

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Units.Handle_Units_Lexicon_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Units_Lexicon self) -> Units_Lexicon

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Units.Handle_Units_Lexicon_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Units_Lexicon self) -> Units_Lexicon

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Units.Handle_Units_Lexicon___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Units_Lexicon self) -> Units_Lexicon

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Units.Handle_Units_Lexicon___ref__(self, *args)


    def __hash__(self):
        return _Units.Handle_Units_Lexicon___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Units.Handle_Units_Lexicon___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Units.new_Handle_Units_Lexicon(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Units.Handle_Units_Lexicon_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_Lexicon

    def Creates(self, *args):
        """
        Creates(Handle_Units_Lexicon self)

        Reads the file <afilename> to create a sequence  of tokens
        stored in <thesequenceoftokens>.


        """
        return _Units.Handle_Units_Lexicon_Creates(self, *args)


    def Sequence(self, *args):
        """
        Sequence(Handle_Units_Lexicon self) -> Handle_Units_TokensSequence

        Returns the first item of the sequence of tokens.

        :rtype: OCC.wrapper.Units.Handle_Units_TokensSequence

        """
        return _Units.Handle_Units_Lexicon_Sequence(self, *args)


    def AddToken(self, *args):
        """
        AddToken(Handle_Units_Lexicon self, Standard_CString const aword, Standard_CString const amean, Standard_Real const avalue)

        Adds to the lexicon a new token with <aword>, <amean>,
        <avalue>  as  arguments.  If there is  already a token
        with   the  field  <theword>  equal    to <aword>, the
        existing token is updated.

        :type aword: OCC.wrapper.Standard.Standard_CString
        :type amean: OCC.wrapper.Standard.Standard_CString
        :type avalue: float

        """
        return _Units.Handle_Units_Lexicon_AddToken(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_Units_Lexicon self)

        Useful for debugging.


        """
        return _Units.Handle_Units_Lexicon_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Units_Lexicon self) -> char const *

        :rtype: const char *

        """
        return _Units.Handle_Units_Lexicon_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_Lexicon_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_Lexicon_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Units_Lexicon self)

        Memory deallocator for transient classes


        """
        return _Units.Handle_Units_Lexicon_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Units_Lexicon self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Units_Lexicon self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_Lexicon_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Units_Lexicon self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Units_Lexicon self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_Lexicon_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Units_Lexicon self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Units.Handle_Units_Lexicon_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Units_Lexicon self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_Lexicon_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Units_Lexicon self)

        Increments the reference counter of this object


        """
        return _Units.Handle_Units_Lexicon_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Units_Lexicon self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_Lexicon_DecrementRefCounter(self, *args)

Handle_Units_Lexicon_swigregister = _Units.Handle_Units_Lexicon_swigregister
Handle_Units_Lexicon_swigregister(Handle_Units_Lexicon)

def Handle_Units_Lexicon_DownCast(thing):
    return _Units.Handle_Units_Lexicon_DownCast(thing)
Handle_Units_Lexicon_DownCast = _Units.Handle_Units_Lexicon_DownCast

class Handle_Units_UnitsSequence(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Units_UnitsSequence self)

        Nullify the handle


        """
        return _Units.Handle_Units_UnitsSequence_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Units_UnitsSequence self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Units.Handle_Units_UnitsSequence_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Units_UnitsSequence self, Units_UnitsSequence thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Units.Handle_Units_UnitsSequence_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Units_UnitsSequence self, Handle_Units_UnitsSequence theHandle) -> Handle_Units_UnitsSequence
        assign(Handle_Units_UnitsSequence self, Units_UnitsSequence thePtr) -> Handle_Units_UnitsSequence
        assign(Handle_Units_UnitsSequence self, Handle_Units_UnitsSequence theHandle) -> Handle_Units_UnitsSequence

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Units.Handle_Units_UnitsSequence_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Units_UnitsSequence self) -> Units_UnitsSequence

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Units.Handle_Units_UnitsSequence_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Units_UnitsSequence self) -> Units_UnitsSequence

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Units.Handle_Units_UnitsSequence___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Units_UnitsSequence self) -> Units_UnitsSequence

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Units.Handle_Units_UnitsSequence___ref__(self, *args)


    def __hash__(self):
        return _Units.Handle_Units_UnitsSequence___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Units.Handle_Units_UnitsSequence___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Units.new_Handle_Units_UnitsSequence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Units.Handle_Units_UnitsSequence_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_UnitsSequence

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.Units.Units_UtsSequence

        """
        res = _Units.Handle_Units_UnitsSequence_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_Units_UnitsSequence self, Handle_Units_Unit theItem)
        Append(Handle_Units_UnitsSequence self, NCollection_Sequence_Handle_Units_Unit theSequence)

        :type theSequence: OCC.wrapper.Units.Units_UtsSequence

        """
        return _Units.Handle_Units_UnitsSequence_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_Units_UnitsSequence self) -> NCollection_Sequence_Handle_Units_Unit

        :rtype: OCC.wrapper.Units.Units_UtsSequence

        """
        return _Units.Handle_Units_UnitsSequence_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Units_UnitsSequence self) -> char const *

        :rtype: const char *

        """
        return _Units.Handle_Units_UnitsSequence_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_UnitsSequence_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_UnitsSequence_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Units_UnitsSequence self)

        Memory deallocator for transient classes


        """
        return _Units.Handle_Units_UnitsSequence_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Units_UnitsSequence self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Units_UnitsSequence self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_UnitsSequence_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Units_UnitsSequence self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Units_UnitsSequence self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_UnitsSequence_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Units_UnitsSequence self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Units.Handle_Units_UnitsSequence_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Units_UnitsSequence self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_UnitsSequence_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Units_UnitsSequence self)

        Increments the reference counter of this object


        """
        return _Units.Handle_Units_UnitsSequence_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Units_UnitsSequence self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_UnitsSequence_DecrementRefCounter(self, *args)

Handle_Units_UnitsSequence_swigregister = _Units.Handle_Units_UnitsSequence_swigregister
Handle_Units_UnitsSequence_swigregister(Handle_Units_UnitsSequence)

def Handle_Units_UnitsSequence_DownCast(thing):
    return _Units.Handle_Units_UnitsSequence_DownCast(thing)
Handle_Units_UnitsSequence_DownCast = _Units.Handle_Units_UnitsSequence_DownCast

class Units_NoSuchType(Standard.Standard_NoSuchObject):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Units_NoSuchType
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Units_NoSuchType(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Units_NoSuchType self) -> Units_NoSuchType
        __init__(Units_NoSuchType self, Standard_CString const theMessage) -> Units_NoSuchType

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _Units.new_Units_NoSuchType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_Units_NoSuchType

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Units.Handle_Units_NoSuchType

        """
        return _Units.Units_NoSuchType_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Units.Units_NoSuchType_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Units.Units_NoSuchType_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Units_NoSuchType_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Units.delete_Units_NoSuchType
Units_NoSuchType_swigregister = _Units.Units_NoSuchType_swigregister
Units_NoSuchType_swigregister(Units_NoSuchType)

def Units_NoSuchType_NewInstance(*args):
    """
    Units_NoSuchType_NewInstance(Standard_CString const theMessage) -> Handle_Units_NoSuchType

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.Units.Handle_Units_NoSuchType

    """
    return _Units.Units_NoSuchType_NewInstance(*args)

def Units_NoSuchType_get_type_name(*args):
    """
    Units_NoSuchType_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Units.Units_NoSuchType_get_type_name(*args)

def Units_NoSuchType_get_type_descriptor(*args):
    """
    Units_NoSuchType_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Units.Units_NoSuchType_get_type_descriptor(*args)

class Units_Unit(Standard.Standard_Transient):
    """
    This class defines an elementary word contained in
    a physical quantity.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Units_Unit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Units_Unit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Units_Unit self, Standard_CString const aname, Standard_CString const asymbol, Standard_Real const avalue, Handle_Units_Quantity aquantity) -> Units_Unit
        __init__(Units_Unit self, Standard_CString const aname, Standard_CString const asymbol) -> Units_Unit
        __init__(Units_Unit self, Standard_CString const aname) -> Units_Unit

        Creates  and returns a  unit.  <aname> is  the name of
        the  unit.

        :type aname: OCC.wrapper.Standard.Standard_CString

        """
        this = _Units.new_Units_Unit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Name(self, *args):
        """
        Name(Units_Unit self) -> TCollection_AsciiString

        Returns the name of the unit <thename>

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Units.Units_Unit_Name(self, *args)


    def Symbol(self, *args):
        """
        Symbol(Units_Unit self, Standard_CString const asymbol)

        Adds a new symbol <asymbol> attached to <me>.

        :type asymbol: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Units_Unit_Symbol(self, *args)


    def SymbolsSequence(self, *args):
        """
        SymbolsSequence(Units_Unit self) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the sequence of symbols <thesymbolssequence>

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _Units.Units_Unit_SymbolsSequence(self, *args)


    def Value(self, *args):
        """
        Value(Units_Unit self) -> Standard_Real
        Value(Units_Unit self, Standard_Real const avalue)

        Sets the value <avalue> to <me>.

        :type avalue: float

        """
        return _Units.Units_Unit_Value(self, *args)


    def Quantity(self, *args):
        """
        Quantity(Units_Unit self) -> Handle_Units_Quantity
        Quantity(Units_Unit self, Handle_Units_Quantity aquantity)

        Sets the physical Quantity <aquantity> to <me>.

        :type aquantity: OCC.wrapper.Units.Handle_Units_Quantity

        """
        return _Units.Units_Unit_Quantity(self, *args)


    def Token(self, *args):
        """
        Token(Units_Unit self) -> Handle_Units_Token

        Starting with <me>, returns a new Token object.

        :rtype: OCC.wrapper.Units.Handle_Units_Token

        """
        return _Units.Units_Unit_Token(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(Units_Unit self, Standard_CString const astring) -> Standard_Boolean

        Compares all the symbols  linked  within <me> with the
        name of <atoken>,  and returns  True  if there is  one
        symbol equal to the name, False otherwise.

        :type astring: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Units_Unit_IsEqual(self, *args)


    def Dump(self, *args):
        """
        Dump(Units_Unit self, Standard_Integer const ashift, Standard_Integer const alevel)

        Useful for debugging

        :type ashift: int
        :type alevel: int

        """
        return _Units.Units_Unit_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Units.Units_Unit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Units.Units_Unit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Units_Unit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Units.delete_Units_Unit
Units_Unit_swigregister = _Units.Units_Unit_swigregister
Units_Unit_swigregister(Units_Unit)

def Units_Unit_get_type_name(*args):
    """
    Units_Unit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Units.Units_Unit_get_type_name(*args)

def Units_Unit_get_type_descriptor(*args):
    """
    Units_Unit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Units.Units_Unit_get_type_descriptor(*args)

class Handle_Units_QuantitiesSequence(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Units_QuantitiesSequence self)

        Nullify the handle


        """
        return _Units.Handle_Units_QuantitiesSequence_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Units_QuantitiesSequence self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Units.Handle_Units_QuantitiesSequence_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Units_QuantitiesSequence self, Units_QuantitiesSequence thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Units.Handle_Units_QuantitiesSequence_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Units_QuantitiesSequence self, Handle_Units_QuantitiesSequence theHandle) -> Handle_Units_QuantitiesSequence
        assign(Handle_Units_QuantitiesSequence self, Units_QuantitiesSequence thePtr) -> Handle_Units_QuantitiesSequence
        assign(Handle_Units_QuantitiesSequence self, Handle_Units_QuantitiesSequence theHandle) -> Handle_Units_QuantitiesSequence

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Units.Handle_Units_QuantitiesSequence_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Units_QuantitiesSequence self) -> Units_QuantitiesSequence

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Units.Handle_Units_QuantitiesSequence_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Units_QuantitiesSequence self) -> Units_QuantitiesSequence

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Units.Handle_Units_QuantitiesSequence___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Units_QuantitiesSequence self) -> Units_QuantitiesSequence

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Units.Handle_Units_QuantitiesSequence___ref__(self, *args)


    def __hash__(self):
        return _Units.Handle_Units_QuantitiesSequence___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Units.Handle_Units_QuantitiesSequence___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Units.new_Handle_Units_QuantitiesSequence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Units.Handle_Units_QuantitiesSequence_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_QuantitiesSequence

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.Units.Units_QtsSequence

        """
        res = _Units.Handle_Units_QuantitiesSequence_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_Units_QuantitiesSequence self, Handle_Units_Quantity theItem)
        Append(Handle_Units_QuantitiesSequence self, NCollection_Sequence_Handle_Units_Quantity theSequence)

        :type theSequence: OCC.wrapper.Units.Units_QtsSequence

        """
        return _Units.Handle_Units_QuantitiesSequence_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_Units_QuantitiesSequence self) -> NCollection_Sequence_Handle_Units_Quantity

        :rtype: OCC.wrapper.Units.Units_QtsSequence

        """
        return _Units.Handle_Units_QuantitiesSequence_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Units_QuantitiesSequence self) -> char const *

        :rtype: const char *

        """
        return _Units.Handle_Units_QuantitiesSequence_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_QuantitiesSequence_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_QuantitiesSequence_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Units_QuantitiesSequence self)

        Memory deallocator for transient classes


        """
        return _Units.Handle_Units_QuantitiesSequence_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Units_QuantitiesSequence self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Units_QuantitiesSequence self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_QuantitiesSequence_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Units_QuantitiesSequence self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Units_QuantitiesSequence self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_QuantitiesSequence_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Units_QuantitiesSequence self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Units.Handle_Units_QuantitiesSequence_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Units_QuantitiesSequence self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_QuantitiesSequence_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Units_QuantitiesSequence self)

        Increments the reference counter of this object


        """
        return _Units.Handle_Units_QuantitiesSequence_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Units_QuantitiesSequence self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_QuantitiesSequence_DecrementRefCounter(self, *args)

Handle_Units_QuantitiesSequence_swigregister = _Units.Handle_Units_QuantitiesSequence_swigregister
Handle_Units_QuantitiesSequence_swigregister(Handle_Units_QuantitiesSequence)

def Handle_Units_QuantitiesSequence_DownCast(thing):
    return _Units.Handle_Units_QuantitiesSequence_DownCast(thing)
Handle_Units_QuantitiesSequence_DownCast = _Units.Handle_Units_QuantitiesSequence_DownCast

class Handle_Units_UnitsLexicon(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Units_UnitsLexicon self)

        Nullify the handle


        """
        return _Units.Handle_Units_UnitsLexicon_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Units_UnitsLexicon self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Units.Handle_Units_UnitsLexicon_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Units_UnitsLexicon self, Units_UnitsLexicon thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Units.Handle_Units_UnitsLexicon_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Units_UnitsLexicon self, Handle_Units_UnitsLexicon theHandle) -> Handle_Units_UnitsLexicon
        assign(Handle_Units_UnitsLexicon self, Units_UnitsLexicon thePtr) -> Handle_Units_UnitsLexicon
        assign(Handle_Units_UnitsLexicon self, Handle_Units_UnitsLexicon theHandle) -> Handle_Units_UnitsLexicon

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Units.Handle_Units_UnitsLexicon_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Units_UnitsLexicon self) -> Units_UnitsLexicon

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Units.Handle_Units_UnitsLexicon_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Units_UnitsLexicon self) -> Units_UnitsLexicon

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Units.Handle_Units_UnitsLexicon___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Units_UnitsLexicon self) -> Units_UnitsLexicon

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Units.Handle_Units_UnitsLexicon___ref__(self, *args)


    def __hash__(self):
        return _Units.Handle_Units_UnitsLexicon___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Units.Handle_Units_UnitsLexicon___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Units.new_Handle_Units_UnitsLexicon(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Units.Handle_Units_UnitsLexicon_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_UnitsLexicon

    def Creates(self, *args):
        """
        Creates(Handle_Units_UnitsLexicon self, Standard_Boolean const amode)

        Reads  the files  <afilename1>  and  <afilename2>   to
        create     a   sequence     of    tokens   stored   in
        <thesequenceoftokens>.

        :type amode: bool

        """
        return _Units.Handle_Units_UnitsLexicon_Creates(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_Units_UnitsLexicon self)

        Useful for debugging.


        """
        return _Units.Handle_Units_UnitsLexicon_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Units_UnitsLexicon self) -> char const *

        :rtype: const char *

        """
        return _Units.Handle_Units_UnitsLexicon_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_UnitsLexicon_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_UnitsLexicon_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Sequence(self, *args):
        """
        Sequence(Handle_Units_UnitsLexicon self) -> Handle_Units_TokensSequence

        Returns the first item of the sequence of tokens.

        :rtype: OCC.wrapper.Units.Handle_Units_TokensSequence

        """
        return _Units.Handle_Units_UnitsLexicon_Sequence(self, *args)


    def AddToken(self, *args):
        """
        AddToken(Handle_Units_UnitsLexicon self, Standard_CString const aword, Standard_CString const amean, Standard_Real const avalue)

        Adds to the lexicon a new token with <aword>, <amean>,
        <avalue>  as  arguments.  If there is  already a token
        with   the  field  <theword>  equal    to <aword>, the
        existing token is updated.

        :type aword: OCC.wrapper.Standard.Standard_CString
        :type amean: OCC.wrapper.Standard.Standard_CString
        :type avalue: float

        """
        return _Units.Handle_Units_UnitsLexicon_AddToken(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Units_UnitsLexicon self)

        Memory deallocator for transient classes


        """
        return _Units.Handle_Units_UnitsLexicon_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Units_UnitsLexicon self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Units_UnitsLexicon self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_UnitsLexicon_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Units_UnitsLexicon self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Units_UnitsLexicon self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_UnitsLexicon_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Units_UnitsLexicon self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Units.Handle_Units_UnitsLexicon_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Units_UnitsLexicon self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_UnitsLexicon_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Units_UnitsLexicon self)

        Increments the reference counter of this object


        """
        return _Units.Handle_Units_UnitsLexicon_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Units_UnitsLexicon self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_UnitsLexicon_DecrementRefCounter(self, *args)

Handle_Units_UnitsLexicon_swigregister = _Units.Handle_Units_UnitsLexicon_swigregister
Handle_Units_UnitsLexicon_swigregister(Handle_Units_UnitsLexicon)

def Handle_Units_UnitsLexicon_DownCast(thing):
    return _Units.Handle_Units_UnitsLexicon_DownCast(thing)
Handle_Units_UnitsLexicon_DownCast = _Units.Handle_Units_UnitsLexicon_DownCast

class Handle_Units_Unit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Units_Unit self)

        Nullify the handle


        """
        return _Units.Handle_Units_Unit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Units_Unit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Units.Handle_Units_Unit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Units_Unit self, Units_Unit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Units.Handle_Units_Unit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Units_Unit self, Handle_Units_Unit theHandle) -> Handle_Units_Unit
        assign(Handle_Units_Unit self, Units_Unit thePtr) -> Handle_Units_Unit
        assign(Handle_Units_Unit self, Handle_Units_Unit theHandle) -> Handle_Units_Unit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Units.Handle_Units_Unit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Units_Unit self) -> Units_Unit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Units.Handle_Units_Unit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Units_Unit self) -> Units_Unit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Units.Handle_Units_Unit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Units_Unit self) -> Units_Unit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Units.Handle_Units_Unit___ref__(self, *args)


    def __hash__(self):
        return _Units.Handle_Units_Unit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Units.Handle_Units_Unit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Units.new_Handle_Units_Unit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Units.Handle_Units_Unit_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_Unit

    def Name(self, *args):
        """
        Name(Handle_Units_Unit self) -> TCollection_AsciiString

        Returns the name of the unit <thename>

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Units.Handle_Units_Unit_Name(self, *args)


    def Symbol(self, *args):
        """
        Symbol(Handle_Units_Unit self, Standard_CString const asymbol)

        Adds a new symbol <asymbol> attached to <me>.

        :type asymbol: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Handle_Units_Unit_Symbol(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Units_Unit self) -> Standard_Real
        Value(Handle_Units_Unit self, Standard_Real const avalue)

        Sets the value <avalue> to <me>.

        :type avalue: float

        """
        return _Units.Handle_Units_Unit_Value(self, *args)


    def Quantity(self, *args):
        """
        Quantity(Handle_Units_Unit self) -> Handle_Units_Quantity
        Quantity(Handle_Units_Unit self, Handle_Units_Quantity aquantity)

        Sets the physical Quantity <aquantity> to <me>.

        :type aquantity: OCC.wrapper.Units.Handle_Units_Quantity

        """
        return _Units.Handle_Units_Unit_Quantity(self, *args)


    def SymbolsSequence(self, *args):
        """
        SymbolsSequence(Handle_Units_Unit self) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the sequence of symbols <thesymbolssequence>

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _Units.Handle_Units_Unit_SymbolsSequence(self, *args)


    def Token(self, *args):
        """
        Token(Handle_Units_Unit self) -> Handle_Units_Token

        Starting with <me>, returns a new Token object.

        :rtype: OCC.wrapper.Units.Handle_Units_Token

        """
        return _Units.Handle_Units_Unit_Token(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(Handle_Units_Unit self, Standard_CString const astring) -> Standard_Boolean

        Compares all the symbols  linked  within <me> with the
        name of <atoken>,  and returns  True  if there is  one
        symbol equal to the name, False otherwise.

        :type astring: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_Unit_IsEqual(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_Units_Unit self, Standard_Integer const ashift, Standard_Integer const alevel)

        Useful for debugging

        :type ashift: int
        :type alevel: int

        """
        return _Units.Handle_Units_Unit_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Units_Unit self) -> char const *

        :rtype: const char *

        """
        return _Units.Handle_Units_Unit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_Unit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_Unit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Units_Unit self)

        Memory deallocator for transient classes


        """
        return _Units.Handle_Units_Unit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Units_Unit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Units_Unit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_Unit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Units_Unit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Units_Unit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_Unit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Units_Unit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Units.Handle_Units_Unit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Units_Unit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_Unit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Units_Unit self)

        Increments the reference counter of this object


        """
        return _Units.Handle_Units_Unit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Units_Unit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_Unit_DecrementRefCounter(self, *args)

Handle_Units_Unit_swigregister = _Units.Handle_Units_Unit_swigregister
Handle_Units_Unit_swigregister(Handle_Units_Unit)

def Handle_Units_Unit_DownCast(thing):
    return _Units.Handle_Units_Unit_DownCast(thing)
Handle_Units_Unit_DownCast = _Units.Handle_Units_Unit_DownCast

class Handle_Units_Token(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Units_Token self)

        Nullify the handle


        """
        return _Units.Handle_Units_Token_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Units_Token self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Units.Handle_Units_Token_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Units_Token self, Units_Token thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Units.Handle_Units_Token_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Units_Token self, Handle_Units_Token theHandle) -> Handle_Units_Token
        assign(Handle_Units_Token self, Units_Token thePtr) -> Handle_Units_Token
        assign(Handle_Units_Token self, Handle_Units_Token theHandle) -> Handle_Units_Token

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Units.Handle_Units_Token_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Units_Token self) -> Units_Token

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Units.Handle_Units_Token_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Units_Token self) -> Units_Token

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Units.Handle_Units_Token___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Units_Token self) -> Units_Token

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Units.Handle_Units_Token___ref__(self, *args)


    def __hash__(self):
        return _Units.Handle_Units_Token___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Units.Handle_Units_Token___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Units.new_Handle_Units_Token(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Units.Handle_Units_Token_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_Token

    def Creates(self, *args):
        """
        Creates(Handle_Units_Token self) -> Handle_Units_Token

        Creates and returns a  token, which is a ShiftedToken.

        :rtype: OCC.wrapper.Units.Handle_Units_Token

        """
        return _Units.Handle_Units_Token_Creates(self, *args)


    def Length(self, *args):
        """
        Length(Handle_Units_Token self) -> Standard_Integer

        Returns the length of the word.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_Token_Length(self, *args)


    def Word(self, *args):
        """
        Word(Handle_Units_Token self) -> TCollection_AsciiString
        Word(Handle_Units_Token self, Standard_CString const aword)

        Sets the field <theword> to <aword>.

        :type aword: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Handle_Units_Token_Word(self, *args)


    def Mean(self, *args):
        """
        Mean(Handle_Units_Token self) -> TCollection_AsciiString
        Mean(Handle_Units_Token self, Standard_CString const amean)

        Sets the field <themean> to <amean>.

        :type amean: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Handle_Units_Token_Mean(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Units_Token self) -> Standard_Real
        Value(Handle_Units_Token self, Standard_Real const avalue)

        Sets the field <thevalue> to <avalue>.

        :type avalue: float

        """
        return _Units.Handle_Units_Token_Value(self, *args)


    def Dimensions(self, *args):
        """
        Dimensions(Handle_Units_Token self) -> Handle_Units_Dimensions
        Dimensions(Handle_Units_Token self, Handle_Units_Dimensions adimensions)

        Sets the field <thedimensions> to <adimensions>.

        :type adimensions: OCC.wrapper.Units.Handle_Units_Dimensions

        """
        return _Units.Handle_Units_Token_Dimensions(self, *args)


    def Update(self, *args):
        """
        Update(Handle_Units_Token self, Standard_CString const amean)

        Updates     the  token  <me>    with  the   additional
        signification  <amean> by  concatenation   of the  two
        strings   <themean>    and   <amean>.   If    the  two
        significations are  the same  , an information message
        is written in the output device.

        :type amean: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Handle_Units_Token_Update(self, *args)


    def Add(self, *args):
        """
        Add(Handle_Units_Token self, Standard_Integer const aninteger) -> Handle_Units_Token
        Add(Handle_Units_Token self, Handle_Units_Token atoken) -> Handle_Units_Token

        Returns a  token which is  the addition  of  <me>  and
        another token <atoken>. The  addition  is  possible if
        and only if the dimensions are the same.

        :type atoken: OCC.wrapper.Units.Handle_Units_Token
        :rtype: OCC.wrapper.Units.Handle_Units_Token

        """
        return _Units.Handle_Units_Token_Add(self, *args)


    def Subtract(self, *args):
        """
        Subtract(Handle_Units_Token self, Handle_Units_Token atoken) -> Handle_Units_Token

        Returns a token  which is the  subtraction of <me> and
        another token <atoken>. The subtraction is possible if
        and only if the dimensions are the same.

        :type atoken: OCC.wrapper.Units.Handle_Units_Token
        :rtype: OCC.wrapper.Units.Handle_Units_Token

        """
        return _Units.Handle_Units_Token_Subtract(self, *args)


    def Multiply(self, *args):
        """
        Multiply(Handle_Units_Token self, Handle_Units_Token atoken) -> Handle_Units_Token

        Returns a  token  which  is the  product of   <me> and
        another token <atoken>.

        :type atoken: OCC.wrapper.Units.Handle_Units_Token
        :rtype: OCC.wrapper.Units.Handle_Units_Token

        """
        return _Units.Handle_Units_Token_Multiply(self, *args)


    def Multiplied(self, *args):
        """
        Multiplied(Handle_Units_Token self, Standard_Real const avalue) -> Standard_Real

        This   virtual method is   called  by  the Measurement
        methods,  to  compute    the   measurement   during  a
        conversion.

        :type avalue: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Handle_Units_Token_Multiplied(self, *args)


    def Divide(self, *args):
        """
        Divide(Handle_Units_Token self, Handle_Units_Token atoken) -> Handle_Units_Token

        Returns a token which is the division of <me> by another
        token <atoken>.

        :type atoken: OCC.wrapper.Units.Handle_Units_Token
        :rtype: OCC.wrapper.Units.Handle_Units_Token

        """
        return _Units.Handle_Units_Token_Divide(self, *args)


    def Divided(self, *args):
        """
        Divided(Handle_Units_Token self, Standard_Real const avalue) -> Standard_Real

        This  virtual  method  is  called by  the  Measurement
        methods,   to   compute   the measurement  during    a
        conversion.

        :type avalue: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Handle_Units_Token_Divided(self, *args)


    def Power(self, *args):
        """
        Power(Handle_Units_Token self, Handle_Units_Token atoken) -> Handle_Units_Token
        Power(Handle_Units_Token self, Standard_Real const anexponent) -> Handle_Units_Token

        Returns a token which is <me> to the power  of <anexponent>.

        :type anexponent: float
        :rtype: OCC.wrapper.Units.Handle_Units_Token

        """
        return _Units.Handle_Units_Token_Power(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(Handle_Units_Token self, Standard_CString const astring) -> Standard_Boolean
        IsEqual(Handle_Units_Token self, Handle_Units_Token atoken) -> Standard_Boolean

        Returns true  if the  field  <theword> and  the string
        <theword> contained  in  the  token <atoken>  are  the
        same, false otherwise.

        :type atoken: OCC.wrapper.Units.Handle_Units_Token
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_Token_IsEqual(self, *args)


    def IsNotEqual(self, *args):
        """
        IsNotEqual(Handle_Units_Token self, Standard_CString const astring) -> Standard_Boolean
        IsNotEqual(Handle_Units_Token self, Handle_Units_Token atoken) -> Standard_Boolean

        Returns false if  the field <theword>  and the  string
        <theword> contained  in the  token  <atoken>  are  the
        same, true otherwise.

        :type atoken: OCC.wrapper.Units.Handle_Units_Token
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_Token_IsNotEqual(self, *args)


    def IsLessOrEqual(self, *args):
        """
        IsLessOrEqual(Handle_Units_Token self, Standard_CString const astring) -> Standard_Boolean

        Returns   true  if the   field <theword>  is  strictly
        contained at  the beginning  of the string  <astring>,
        false otherwise.

        :type astring: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_Token_IsLessOrEqual(self, *args)


    def IsGreater(self, *args):
        """
        IsGreater(Handle_Units_Token self, Standard_CString const astring) -> Standard_Boolean
        IsGreater(Handle_Units_Token self, Handle_Units_Token atoken) -> Standard_Boolean

        Returns false  if   the field   <theword> is  strictly
        contained at  the  beginning  of the string <astring>,
        true otherwise.

        :type atoken: OCC.wrapper.Units.Handle_Units_Token
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_Token_IsGreater(self, *args)


    def IsGreaterOrEqual(self, *args):
        """
        IsGreaterOrEqual(Handle_Units_Token self, Handle_Units_Token atoken) -> Standard_Boolean

        Returns true  if  the string <astring>   is   strictly
        contained   at the  beginning  of  the field <theword>
        false otherwise.

        :type atoken: OCC.wrapper.Units.Handle_Units_Token
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_Token_IsGreaterOrEqual(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_Units_Token self, Standard_Integer const ashift, Standard_Integer const alevel)

        Useful for debugging

        :type ashift: int
        :type alevel: int

        """
        return _Units.Handle_Units_Token_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Units_Token self) -> char const *

        :rtype: const char *

        """
        return _Units.Handle_Units_Token_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_Token_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_Token_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Units_Token self)

        Memory deallocator for transient classes


        """
        return _Units.Handle_Units_Token_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Units_Token self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Units_Token self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_Token_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Units_Token self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Units_Token self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_Token_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Units_Token self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Units.Handle_Units_Token_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Units_Token self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_Token_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Units_Token self)

        Increments the reference counter of this object


        """
        return _Units.Handle_Units_Token_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Units_Token self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_Token_DecrementRefCounter(self, *args)

Handle_Units_Token_swigregister = _Units.Handle_Units_Token_swigregister
Handle_Units_Token_swigregister(Handle_Units_Token)

def Handle_Units_Token_DownCast(thing):
    return _Units.Handle_Units_Token_DownCast(thing)
Handle_Units_Token_DownCast = _Units.Handle_Units_Token_DownCast

class Handle_Units_TokensSequence(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Units_TokensSequence self)

        Nullify the handle


        """
        return _Units.Handle_Units_TokensSequence_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Units_TokensSequence self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Units.Handle_Units_TokensSequence_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Units_TokensSequence self, Units_TokensSequence thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Units.Handle_Units_TokensSequence_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Units_TokensSequence self, Handle_Units_TokensSequence theHandle) -> Handle_Units_TokensSequence
        assign(Handle_Units_TokensSequence self, Units_TokensSequence thePtr) -> Handle_Units_TokensSequence
        assign(Handle_Units_TokensSequence self, Handle_Units_TokensSequence theHandle) -> Handle_Units_TokensSequence

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Units.Handle_Units_TokensSequence_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Units_TokensSequence self) -> Units_TokensSequence

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Units.Handle_Units_TokensSequence_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Units_TokensSequence self) -> Units_TokensSequence

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Units.Handle_Units_TokensSequence___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Units_TokensSequence self) -> Units_TokensSequence

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Units.Handle_Units_TokensSequence___ref__(self, *args)


    def __hash__(self):
        return _Units.Handle_Units_TokensSequence___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Units.Handle_Units_TokensSequence___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Units.new_Handle_Units_TokensSequence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Units.Handle_Units_TokensSequence_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_TokensSequence

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.Units.Units_TksSequence

        """
        res = _Units.Handle_Units_TokensSequence_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_Units_TokensSequence self, Handle_Units_Token theItem)
        Append(Handle_Units_TokensSequence self, NCollection_Sequence_Handle_Units_Token theSequence)

        :type theSequence: OCC.wrapper.Units.Units_TksSequence

        """
        return _Units.Handle_Units_TokensSequence_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_Units_TokensSequence self) -> NCollection_Sequence_Handle_Units_Token

        :rtype: OCC.wrapper.Units.Units_TksSequence

        """
        return _Units.Handle_Units_TokensSequence_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Units_TokensSequence self) -> char const *

        :rtype: const char *

        """
        return _Units.Handle_Units_TokensSequence_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_TokensSequence_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_TokensSequence_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Units_TokensSequence self)

        Memory deallocator for transient classes


        """
        return _Units.Handle_Units_TokensSequence_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Units_TokensSequence self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Units_TokensSequence self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_TokensSequence_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Units_TokensSequence self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Units_TokensSequence self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_TokensSequence_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Units_TokensSequence self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Units.Handle_Units_TokensSequence_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Units_TokensSequence self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_TokensSequence_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Units_TokensSequence self)

        Increments the reference counter of this object


        """
        return _Units.Handle_Units_TokensSequence_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Units_TokensSequence self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_TokensSequence_DecrementRefCounter(self, *args)

Handle_Units_TokensSequence_swigregister = _Units.Handle_Units_TokensSequence_swigregister
Handle_Units_TokensSequence_swigregister(Handle_Units_TokensSequence)

def Handle_Units_TokensSequence_DownCast(thing):
    return _Units.Handle_Units_TokensSequence_DownCast(thing)
Handle_Units_TokensSequence_DownCast = _Units.Handle_Units_TokensSequence_DownCast

class NCollection_Sequence_Handle_Units_Unit(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_Units_Unit self) -> NCollection_Sequence< opencascade::handle< Units_Unit > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Units.NCollection_Sequence_Handle_Units_Unit_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_Units_Unit self) -> NCollection_Sequence< opencascade::handle< Units_Unit > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Units.NCollection_Sequence_Handle_Units_Unit_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_Units_Unit self) -> NCollection_Sequence< opencascade::handle< Units_Unit > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Units.NCollection_Sequence_Handle_Units_Unit_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_Units_Unit self) -> NCollection_Sequence< opencascade::handle< Units_Unit > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Units.NCollection_Sequence_Handle_Units_Unit_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Units.new_NCollection_Sequence_Handle_Units_Unit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_Units_Unit self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.NCollection_Sequence_Handle_Units_Unit_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_Units_Unit self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.NCollection_Sequence_Handle_Units_Unit_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_Units_Unit self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.NCollection_Sequence_Handle_Units_Unit_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_Units_Unit self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.NCollection_Sequence_Handle_Units_Unit_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_Units_Unit self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.NCollection_Sequence_Handle_Units_Unit_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_Units_Unit self)

        Reverse sequence


        """
        return _Units.NCollection_Sequence_Handle_Units_Unit_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_Units_Unit self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Units.NCollection_Sequence_Handle_Units_Unit_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Units.NCollection_Sequence_Handle_Units_Unit_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_Units_Unit self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Units.NCollection_Sequence_Handle_Units_Unit_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_Units_Unit self, NCollection_Sequence_Handle_Units_Unit theOther) -> NCollection_Sequence_Handle_Units_Unit

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Units.NCollection_Sequence_Handle_Units_Unit_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_Units_Unit self, NCollection_Sequence_Handle_Units_Unit theOther) -> NCollection_Sequence_Handle_Units_Unit

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Units.NCollection_Sequence_Handle_Units_Unit_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_Units_Unit self, NCollection_Sequence< opencascade::handle< Units_Unit > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_Units_Unit self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_Units_Unit self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Units.NCollection_Sequence_Handle_Units_Unit_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_Units_Unit self, Handle_Units_Unit theItem)
        Append(NCollection_Sequence_Handle_Units_Unit self, NCollection_Sequence_Handle_Units_Unit theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Units.NCollection_Sequence_Handle_Units_Unit_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_Units_Unit self, Handle_Units_Unit theItem)
        Prepend(NCollection_Sequence_Handle_Units_Unit self, NCollection_Sequence_Handle_Units_Unit theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Units.NCollection_Sequence_Handle_Units_Unit_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_Units_Unit self, Standard_Integer const theIndex, Handle_Units_Unit theItem)
        InsertBefore(NCollection_Sequence_Handle_Units_Unit self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Units_Unit theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Units.NCollection_Sequence_Handle_Units_Unit_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_Units_Unit self, NCollection_Sequence< opencascade::handle< Units_Unit > >::Iterator & thePosition, Handle_Units_Unit theItem)
        InsertAfter(NCollection_Sequence_Handle_Units_Unit self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Units_Unit theSeq)
        InsertAfter(NCollection_Sequence_Handle_Units_Unit self, Standard_Integer const theIndex, Handle_Units_Unit theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Units.NCollection_Sequence_Handle_Units_Unit_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_Units_Unit self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Units_Unit theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Units.NCollection_Sequence_Handle_Units_Unit_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Units.NCollection_Sequence_Handle_Units_Unit_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_Units_Unit self) -> Handle_Units_Unit

        First item access

        :rtype: TheItemType &

        """
        return _Units.NCollection_Sequence_Handle_Units_Unit_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Units.NCollection_Sequence_Handle_Units_Unit_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_Units_Unit self) -> Handle_Units_Unit

        Last item access

        :rtype: TheItemType &

        """
        return _Units.NCollection_Sequence_Handle_Units_Unit_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Units.NCollection_Sequence_Handle_Units_Unit_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_Units_Unit self, Standard_Integer const theIndex) -> Handle_Units_Unit

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Units.NCollection_Sequence_Handle_Units_Unit_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Units.NCollection_Sequence_Handle_Units_Unit___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_Units_Unit self, Standard_Integer const theIndex, Handle_Units_Unit theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Units.NCollection_Sequence_Handle_Units_Unit_SetValue(self, *args)


    def __iter__(self):
        return _Units.NCollection_Sequence_Handle_Units_Unit___iter__(self)
    __swig_destroy__ = _Units.delete_NCollection_Sequence_Handle_Units_Unit
NCollection_Sequence_Handle_Units_Unit_swigregister = _Units.NCollection_Sequence_Handle_Units_Unit_swigregister
NCollection_Sequence_Handle_Units_Unit_swigregister(NCollection_Sequence_Handle_Units_Unit)

def NCollection_Sequence_Handle_Units_Unit_delNode(*args):
    """
    NCollection_Sequence_Handle_Units_Unit_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Units.NCollection_Sequence_Handle_Units_Unit_delNode(*args)

class NCollection_Sequence_Handle_Units_Unit_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Units.new_NCollection_Sequence_Handle_Units_Unit_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Units.delete_NCollection_Sequence_Handle_Units_Unit_IteratorHelper

    def __next__(self):
        return _Units.NCollection_Sequence_Handle_Units_Unit_IteratorHelper___next__(self)
NCollection_Sequence_Handle_Units_Unit_IteratorHelper_swigregister = _Units.NCollection_Sequence_Handle_Units_Unit_IteratorHelper_swigregister
NCollection_Sequence_Handle_Units_Unit_IteratorHelper_swigregister(NCollection_Sequence_Handle_Units_Unit_IteratorHelper)


try:
	Units_UtsSequence = NCollection_Sequence_Handle_Units_Unit
except NameError:
	pass # does not exist, probably ignored

class Units_ShiftedUnit(Units_Unit):
    """
    This class is useful   to describe  units  with  a
    shifted origin in relation to another unit. A well
    known example  is the  Celsius degrees in relation
    to Kelvin degrees. The shift of the Celsius origin
    is 273.15 Kelvin degrees.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Units_ShiftedUnit
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Units_ShiftedUnit(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Units_ShiftedUnit self, Standard_CString const aname, Standard_CString const asymbol, Standard_Real const avalue, Standard_Real const amove, Handle_Units_Quantity aquantity) -> Units_ShiftedUnit
        __init__(Units_ShiftedUnit self, Standard_CString const aname, Standard_CString const asymbol) -> Units_ShiftedUnit
        __init__(Units_ShiftedUnit self, Standard_CString const aname) -> Units_ShiftedUnit

        Creates  and returns a  unit.  <aname> is  the name of
        the  unit.

        :type aname: OCC.wrapper.Standard.Standard_CString

        """
        this = _Units.new_Units_ShiftedUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Move(self, *args):
        """
        Move(Units_ShiftedUnit self, Standard_Real const amove)
        Move(Units_ShiftedUnit self) -> Standard_Real

        Returns the shifted value <themove>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Units_ShiftedUnit_Move(self, *args)


    def Token(self, *args):
        """
        Token(Units_ShiftedUnit self) -> Handle_Units_Token

        This redefined method returns a ShiftedToken object.

        :rtype: OCC.wrapper.Units.Handle_Units_Token

        """
        return _Units.Units_ShiftedUnit_Token(self, *args)


    def Dump(self, *args):
        """
        Dump(Units_ShiftedUnit self, Standard_Integer const ashift, Standard_Integer const alevel)

        :type ashift: int
        :type alevel: int

        """
        return _Units.Units_ShiftedUnit_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Units.Units_ShiftedUnit_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Units.Units_ShiftedUnit_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Units_ShiftedUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Units.delete_Units_ShiftedUnit
Units_ShiftedUnit_swigregister = _Units.Units_ShiftedUnit_swigregister
Units_ShiftedUnit_swigregister(Units_ShiftedUnit)

def Units_ShiftedUnit_get_type_name(*args):
    """
    Units_ShiftedUnit_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Units.Units_ShiftedUnit_get_type_name(*args)

def Units_ShiftedUnit_get_type_descriptor(*args):
    """
    Units_ShiftedUnit_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Units.Units_ShiftedUnit_get_type_descriptor(*args)

class Units_Explorer(object):
    """
    This class provides all the services to explore
    UnitsSystem or UnitsDictionary.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Units_Explorer self) -> Units_Explorer
        __init__(Units_Explorer self, Handle_Units_UnitsSystem aunitssystem) -> Units_Explorer
        __init__(Units_Explorer self, Handle_Units_UnitsDictionary aunitsdictionary) -> Units_Explorer
        __init__(Units_Explorer self, Handle_Units_UnitsSystem aunitssystem, Standard_CString const aquantity) -> Units_Explorer
        __init__(Units_Explorer self, Handle_Units_UnitsDictionary aunitsdictionary, Standard_CString const aquantity) -> Units_Explorer

        Creates a  new instance of the class,  initialized with
        the  UnitsDictionary <aunitsdictionary> and positioned
        at the quantity <aquantity>.

        :type aunitsdictionary: OCC.wrapper.Units.Handle_Units_UnitsDictionary
        :type aquantity: OCC.wrapper.Standard.Standard_CString

        """
        this = _Units.new_Units_Explorer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(Units_Explorer self, Handle_Units_UnitsSystem aunitssystem)
        Init(Units_Explorer self, Handle_Units_UnitsDictionary aunitsdictionary)
        Init(Units_Explorer self, Handle_Units_UnitsSystem aunitssystem, Standard_CString const aquantity)
        Init(Units_Explorer self, Handle_Units_UnitsDictionary aunitsdictionary, Standard_CString const aquantity)

        Initializes  the  instance   of  the  class  with  the
        UnitsDictionary  <aunitsdictionary> and positioned  at
        the quantity <aquantity>.

        :type aunitsdictionary: OCC.wrapper.Units.Handle_Units_UnitsDictionary
        :type aquantity: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Units_Explorer_Init(self, *args)


    def MoreQuantity(self, *args):
        """
        MoreQuantity(Units_Explorer self) -> Standard_Boolean

        Returns True if there is another Quantity to explore,
        False otherwise.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Units_Explorer_MoreQuantity(self, *args)


    def NextQuantity(self, *args):
        """
        NextQuantity(Units_Explorer self)

        Sets the next Quantity current.


        """
        return _Units.Units_Explorer_NextQuantity(self, *args)


    def Quantity(self, *args):
        """
        Quantity(Units_Explorer self) -> TCollection_AsciiString

        Returns the name of the current Quantity.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Units.Units_Explorer_Quantity(self, *args)


    def MoreUnit(self, *args):
        """
        MoreUnit(Units_Explorer self) -> Standard_Boolean

        Returns True if there is another Unit to explore,
        False otherwise.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Units_Explorer_MoreUnit(self, *args)


    def NextUnit(self, *args):
        """
        NextUnit(Units_Explorer self)

        Sets the next Unit current.


        """
        return _Units.Units_Explorer_NextUnit(self, *args)


    def Unit(self, *args):
        """
        Unit(Units_Explorer self) -> TCollection_AsciiString

        Returns the name of the current unit.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Units.Units_Explorer_Unit(self, *args)


    def IsActive(self, *args):
        """
        IsActive(Units_Explorer self) -> Standard_Boolean

        If the  units system  to  explore  is  a user  system,
        returns True  if  the  current unit  is  active, False
        otherwise.

        If   the   units  system  to  explore  is   the  units
        dictionary,  returns True if the  current unit is  the
        S.I. unit.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Units_Explorer_IsActive(self, *args)

    __swig_destroy__ = _Units.delete_Units_Explorer
Units_Explorer_swigregister = _Units.Units_Explorer_swigregister
Units_Explorer_swigregister(Units_Explorer)

class NCollection_Sequence_Handle_Units_Token(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_Units_Token self) -> NCollection_Sequence< opencascade::handle< Units_Token > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Units.NCollection_Sequence_Handle_Units_Token_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_Units_Token self) -> NCollection_Sequence< opencascade::handle< Units_Token > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Units.NCollection_Sequence_Handle_Units_Token_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_Units_Token self) -> NCollection_Sequence< opencascade::handle< Units_Token > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Units.NCollection_Sequence_Handle_Units_Token_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_Units_Token self) -> NCollection_Sequence< opencascade::handle< Units_Token > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Units.NCollection_Sequence_Handle_Units_Token_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Units.new_NCollection_Sequence_Handle_Units_Token(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_Units_Token self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.NCollection_Sequence_Handle_Units_Token_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_Units_Token self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.NCollection_Sequence_Handle_Units_Token_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_Units_Token self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.NCollection_Sequence_Handle_Units_Token_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_Units_Token self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.NCollection_Sequence_Handle_Units_Token_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_Units_Token self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.NCollection_Sequence_Handle_Units_Token_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_Units_Token self)

        Reverse sequence


        """
        return _Units.NCollection_Sequence_Handle_Units_Token_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_Units_Token self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Units.NCollection_Sequence_Handle_Units_Token_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Units.NCollection_Sequence_Handle_Units_Token_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_Units_Token self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Units.NCollection_Sequence_Handle_Units_Token_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_Units_Token self, NCollection_Sequence_Handle_Units_Token theOther) -> NCollection_Sequence_Handle_Units_Token

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Units.NCollection_Sequence_Handle_Units_Token_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_Units_Token self, NCollection_Sequence_Handle_Units_Token theOther) -> NCollection_Sequence_Handle_Units_Token

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Units.NCollection_Sequence_Handle_Units_Token_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_Units_Token self, NCollection_Sequence< opencascade::handle< Units_Token > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_Units_Token self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_Units_Token self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Units.NCollection_Sequence_Handle_Units_Token_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_Units_Token self, Handle_Units_Token theItem)
        Append(NCollection_Sequence_Handle_Units_Token self, NCollection_Sequence_Handle_Units_Token theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Units.NCollection_Sequence_Handle_Units_Token_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_Units_Token self, Handle_Units_Token theItem)
        Prepend(NCollection_Sequence_Handle_Units_Token self, NCollection_Sequence_Handle_Units_Token theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Units.NCollection_Sequence_Handle_Units_Token_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_Units_Token self, Standard_Integer const theIndex, Handle_Units_Token theItem)
        InsertBefore(NCollection_Sequence_Handle_Units_Token self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Units_Token theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Units.NCollection_Sequence_Handle_Units_Token_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_Units_Token self, NCollection_Sequence< opencascade::handle< Units_Token > >::Iterator & thePosition, Handle_Units_Token theItem)
        InsertAfter(NCollection_Sequence_Handle_Units_Token self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Units_Token theSeq)
        InsertAfter(NCollection_Sequence_Handle_Units_Token self, Standard_Integer const theIndex, Handle_Units_Token theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Units.NCollection_Sequence_Handle_Units_Token_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_Units_Token self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Units_Token theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Units.NCollection_Sequence_Handle_Units_Token_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Units.NCollection_Sequence_Handle_Units_Token_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_Units_Token self) -> Handle_Units_Token

        First item access

        :rtype: TheItemType &

        """
        return _Units.NCollection_Sequence_Handle_Units_Token_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Units.NCollection_Sequence_Handle_Units_Token_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_Units_Token self) -> Handle_Units_Token

        Last item access

        :rtype: TheItemType &

        """
        return _Units.NCollection_Sequence_Handle_Units_Token_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Units.NCollection_Sequence_Handle_Units_Token_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_Units_Token self, Standard_Integer const theIndex) -> Handle_Units_Token

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Units.NCollection_Sequence_Handle_Units_Token_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Units.NCollection_Sequence_Handle_Units_Token___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_Units_Token self, Standard_Integer const theIndex, Handle_Units_Token theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Units.NCollection_Sequence_Handle_Units_Token_SetValue(self, *args)


    def __iter__(self):
        return _Units.NCollection_Sequence_Handle_Units_Token___iter__(self)
    __swig_destroy__ = _Units.delete_NCollection_Sequence_Handle_Units_Token
NCollection_Sequence_Handle_Units_Token_swigregister = _Units.NCollection_Sequence_Handle_Units_Token_swigregister
NCollection_Sequence_Handle_Units_Token_swigregister(NCollection_Sequence_Handle_Units_Token)

def NCollection_Sequence_Handle_Units_Token_delNode(*args):
    """
    NCollection_Sequence_Handle_Units_Token_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Units.NCollection_Sequence_Handle_Units_Token_delNode(*args)

class NCollection_Sequence_Handle_Units_Token_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Units.new_NCollection_Sequence_Handle_Units_Token_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Units.delete_NCollection_Sequence_Handle_Units_Token_IteratorHelper

    def __next__(self):
        return _Units.NCollection_Sequence_Handle_Units_Token_IteratorHelper___next__(self)
NCollection_Sequence_Handle_Units_Token_IteratorHelper_swigregister = _Units.NCollection_Sequence_Handle_Units_Token_IteratorHelper_swigregister
NCollection_Sequence_Handle_Units_Token_IteratorHelper_swigregister(NCollection_Sequence_Handle_Units_Token_IteratorHelper)


try:
	Units_TksSequence = NCollection_Sequence_Handle_Units_Token
except NameError:
	pass # does not exist, probably ignored

class Handle_Units_NoSuchType(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Units_NoSuchType self)

        Nullify the handle


        """
        return _Units.Handle_Units_NoSuchType_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Units_NoSuchType self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Units.Handle_Units_NoSuchType_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Units_NoSuchType self, Units_NoSuchType thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Units.Handle_Units_NoSuchType_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Units_NoSuchType self, Handle_Units_NoSuchType theHandle) -> Handle_Units_NoSuchType
        assign(Handle_Units_NoSuchType self, Units_NoSuchType thePtr) -> Handle_Units_NoSuchType
        assign(Handle_Units_NoSuchType self, Handle_Units_NoSuchType theHandle) -> Handle_Units_NoSuchType

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Units.Handle_Units_NoSuchType_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Units_NoSuchType self) -> Units_NoSuchType

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Units.Handle_Units_NoSuchType_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Units_NoSuchType self) -> Units_NoSuchType

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Units.Handle_Units_NoSuchType___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Units_NoSuchType self) -> Units_NoSuchType

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Units.Handle_Units_NoSuchType___ref__(self, *args)


    def __hash__(self):
        return _Units.Handle_Units_NoSuchType___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Units.Handle_Units_NoSuchType___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Units.new_Handle_Units_NoSuchType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Units.Handle_Units_NoSuchType_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_NoSuchType

    def NewInstance(self, *args):
        """
        NewInstance(Handle_Units_NoSuchType self, Standard_CString const theMessage) -> Handle_Units_NoSuchType

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Units.Handle_Units_NoSuchType

        """
        return _Units.Handle_Units_NoSuchType_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Units_NoSuchType self) -> char const *

        :rtype: const char *

        """
        return _Units.Handle_Units_NoSuchType_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_NoSuchType_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_NoSuchType_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_Units_NoSuchType self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _Units.Handle_Units_NoSuchType_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_Units_NoSuchType self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Handle_Units_NoSuchType_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_Units_NoSuchType self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Handle_Units_NoSuchType_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_Units_NoSuchType self)
        Reraise(Handle_Units_NoSuchType self, Standard_CString const aMessage)
        Reraise(Handle_Units_NoSuchType self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _Units.Handle_Units_NoSuchType_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_Units_NoSuchType self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _Units.Handle_Units_NoSuchType_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_Units_NoSuchType self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _Units.Handle_Units_NoSuchType_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Units_NoSuchType self)

        Memory deallocator for transient classes


        """
        return _Units.Handle_Units_NoSuchType_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Units_NoSuchType self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Units_NoSuchType self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_NoSuchType_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Units_NoSuchType self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Units_NoSuchType self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_NoSuchType_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Units_NoSuchType self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Units.Handle_Units_NoSuchType_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Units_NoSuchType self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_NoSuchType_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Units_NoSuchType self)

        Increments the reference counter of this object


        """
        return _Units.Handle_Units_NoSuchType_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Units_NoSuchType self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_NoSuchType_DecrementRefCounter(self, *args)

Handle_Units_NoSuchType_swigregister = _Units.Handle_Units_NoSuchType_swigregister
Handle_Units_NoSuchType_swigregister(Handle_Units_NoSuchType)

def Handle_Units_NoSuchType_DownCast(thing):
    return _Units.Handle_Units_NoSuchType_DownCast(thing)
Handle_Units_NoSuchType_DownCast = _Units.Handle_Units_NoSuchType_DownCast

class Handle_Units_ShiftedUnit(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Units_ShiftedUnit self)

        Nullify the handle


        """
        return _Units.Handle_Units_ShiftedUnit_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Units_ShiftedUnit self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Units.Handle_Units_ShiftedUnit_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Units_ShiftedUnit self, Units_ShiftedUnit thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Units.Handle_Units_ShiftedUnit_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Units_ShiftedUnit self, Handle_Units_ShiftedUnit theHandle) -> Handle_Units_ShiftedUnit
        assign(Handle_Units_ShiftedUnit self, Units_ShiftedUnit thePtr) -> Handle_Units_ShiftedUnit
        assign(Handle_Units_ShiftedUnit self, Handle_Units_ShiftedUnit theHandle) -> Handle_Units_ShiftedUnit

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Units.Handle_Units_ShiftedUnit_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Units_ShiftedUnit self) -> Units_ShiftedUnit

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Units.Handle_Units_ShiftedUnit_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Units_ShiftedUnit self) -> Units_ShiftedUnit

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Units.Handle_Units_ShiftedUnit___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Units_ShiftedUnit self) -> Units_ShiftedUnit

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Units.Handle_Units_ShiftedUnit___ref__(self, *args)


    def __hash__(self):
        return _Units.Handle_Units_ShiftedUnit___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Units.Handle_Units_ShiftedUnit___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Units.new_Handle_Units_ShiftedUnit(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Units.Handle_Units_ShiftedUnit_DownCast)
    __swig_destroy__ = _Units.delete_Handle_Units_ShiftedUnit

    def Move(self, *args):
        """
        Move(Handle_Units_ShiftedUnit self, Standard_Real const amove)
        Move(Handle_Units_ShiftedUnit self) -> Standard_Real

        Returns the shifted value <themove>.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Units.Handle_Units_ShiftedUnit_Move(self, *args)


    def Token(self, *args):
        """
        Token(Handle_Units_ShiftedUnit self) -> Handle_Units_Token

        This redefined method returns a ShiftedToken object.

        :rtype: OCC.wrapper.Units.Handle_Units_Token

        """
        return _Units.Handle_Units_ShiftedUnit_Token(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_Units_ShiftedUnit self, Standard_Integer const ashift, Standard_Integer const alevel)

        :type ashift: int
        :type alevel: int

        """
        return _Units.Handle_Units_ShiftedUnit_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Units_ShiftedUnit self) -> char const *

        :rtype: const char *

        """
        return _Units.Handle_Units_ShiftedUnit_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_ShiftedUnit_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Units.Handle_Units_ShiftedUnit_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_Units_ShiftedUnit self) -> TCollection_AsciiString

        Returns the name of the unit <thename>

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _Units.Handle_Units_ShiftedUnit_Name(self, *args)


    def Symbol(self, *args):
        """
        Symbol(Handle_Units_ShiftedUnit self, Standard_CString const asymbol)

        Adds a new symbol <asymbol> attached to <me>.

        :type asymbol: OCC.wrapper.Standard.Standard_CString

        """
        return _Units.Handle_Units_ShiftedUnit_Symbol(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Units_ShiftedUnit self) -> Standard_Real
        Value(Handle_Units_ShiftedUnit self, Standard_Real const avalue)

        Sets the value <avalue> to <me>.

        :type avalue: float

        """
        return _Units.Handle_Units_ShiftedUnit_Value(self, *args)


    def Quantity(self, *args):
        """
        Quantity(Handle_Units_ShiftedUnit self) -> Handle_Units_Quantity
        Quantity(Handle_Units_ShiftedUnit self, Handle_Units_Quantity aquantity)

        Sets the physical Quantity <aquantity> to <me>.

        :type aquantity: OCC.wrapper.Units.Handle_Units_Quantity

        """
        return _Units.Handle_Units_ShiftedUnit_Quantity(self, *args)


    def SymbolsSequence(self, *args):
        """
        SymbolsSequence(Handle_Units_ShiftedUnit self) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the sequence of symbols <thesymbolssequence>

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _Units.Handle_Units_ShiftedUnit_SymbolsSequence(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(Handle_Units_ShiftedUnit self, Standard_CString const astring) -> Standard_Boolean

        Compares all the symbols  linked  within <me> with the
        name of <atoken>,  and returns  True  if there is  one
        symbol equal to the name, False otherwise.

        :type astring: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_ShiftedUnit_IsEqual(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Units_ShiftedUnit self)

        Memory deallocator for transient classes


        """
        return _Units.Handle_Units_ShiftedUnit_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Units_ShiftedUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Units_ShiftedUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_ShiftedUnit_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Units_ShiftedUnit self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Units_ShiftedUnit self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Units.Handle_Units_ShiftedUnit_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Units_ShiftedUnit self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Units.Handle_Units_ShiftedUnit_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Units_ShiftedUnit self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_ShiftedUnit_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Units_ShiftedUnit self)

        Increments the reference counter of this object


        """
        return _Units.Handle_Units_ShiftedUnit_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Units_ShiftedUnit self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Units.Handle_Units_ShiftedUnit_DecrementRefCounter(self, *args)

Handle_Units_ShiftedUnit_swigregister = _Units.Handle_Units_ShiftedUnit_swigregister
Handle_Units_ShiftedUnit_swigregister(Handle_Units_ShiftedUnit)

def Handle_Units_ShiftedUnit_DownCast(thing):
    return _Units.Handle_Units_ShiftedUnit_DownCast(thing)
Handle_Units_ShiftedUnit_DownCast = _Units.Handle_Units_ShiftedUnit_DownCast




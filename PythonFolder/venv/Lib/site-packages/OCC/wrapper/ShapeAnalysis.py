# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_ShapeAnalysis')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_ShapeAnalysis')
    _ShapeAnalysis = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ShapeAnalysis', [dirname(__file__)])
        except ImportError:
            import _ShapeAnalysis
            return _ShapeAnalysis
        try:
            _mod = imp.load_module('_ShapeAnalysis', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _ShapeAnalysis = swig_import_helper()
    del swig_import_helper
else:
    import _ShapeAnalysis
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ShapeAnalysis.delete_SwigPyIterator

    def value(self):
        return _ShapeAnalysis.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _ShapeAnalysis.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _ShapeAnalysis.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _ShapeAnalysis.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _ShapeAnalysis.SwigPyIterator_equal(self, x)

    def copy(self):
        return _ShapeAnalysis.SwigPyIterator_copy(self)

    def next(self):
        return _ShapeAnalysis.SwigPyIterator_next(self)

    def __next__(self):
        return _ShapeAnalysis.SwigPyIterator___next__(self)

    def previous(self):
        return _ShapeAnalysis.SwigPyIterator_previous(self)

    def advance(self, n):
        return _ShapeAnalysis.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _ShapeAnalysis.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _ShapeAnalysis.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _ShapeAnalysis.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _ShapeAnalysis.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _ShapeAnalysis.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _ShapeAnalysis.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _ShapeAnalysis.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _ShapeAnalysis.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_ShapeAnalysis.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _ShapeAnalysis.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _ShapeAnalysis.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeAnalysis.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _ShapeAnalysis.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _ShapeAnalysis.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _ShapeAnalysis.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _ShapeAnalysis.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_ShapeAnalysis.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _ShapeAnalysis.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _ShapeAnalysis.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeAnalysis.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _ShapeAnalysis.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _ShapeAnalysis.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _ShapeAnalysis.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _ShapeAnalysis.ptr_to_number(item)
ptr_to_number = _ShapeAnalysis.ptr_to_number

def HashCode(*args):
    return _ShapeAnalysis.HashCode(*args)
HashCode = _ShapeAnalysis.HashCode

def ptr_equal(a, b):
    return _ShapeAnalysis.ptr_equal(a, b)
ptr_equal = _ShapeAnalysis.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntRes2d
else:
    import IntRes2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ShapeExtend
else:
    import ShapeExtend
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColGeom
else:
    import TColGeom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
class ShapeAnalysis_TransferParameters(Standard.Standard_Transient):
    """
    This tool is used for transferring parameters
    from 3d curve of the edge to pcurve and vice versa.

    Default behaviour is to trsnafer parameters with help
    of linear transformation:

    T2d = myShift + myScale * T3d
    where
    myScale = ( Last2d - First2d ) / ( Last3d - First3d )
    myShift = First2d - First3d * myScale
    [First3d, Last3d] and [First2d, Last2d] are ranges of
    edge on curve and pcurve

    This behaviour can be redefined in derived classes, for example,
    using projection.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeAnalysis_TransferParameters
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeAnalysis_TransferParameters(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeAnalysis_TransferParameters self) -> ShapeAnalysis_TransferParameters
        __init__(ShapeAnalysis_TransferParameters self, TopoDS_Edge E, TopoDS_Face F) -> ShapeAnalysis_TransferParameters

        Creates a tool and initializes it with edge and face

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        this = _ShapeAnalysis.new_ShapeAnalysis_TransferParameters(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(ShapeAnalysis_TransferParameters self, TopoDS_Edge E, TopoDS_Face F)

        Initialize a tool with edge and face

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _ShapeAnalysis.ShapeAnalysis_TransferParameters_Init(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(ShapeAnalysis_TransferParameters self, Standard_Real const maxtol)

        Sets maximal tolerance to use linear recomputation of
        parameters.

        :type maxtol: float

        """
        return _ShapeAnalysis.ShapeAnalysis_TransferParameters_SetMaxTolerance(self, *args)


    def Perform(self, *args):
        """
        Perform(ShapeAnalysis_TransferParameters self, Handle_TColStd_HSequenceOfReal Params, Standard_Boolean const To2d) -> Handle_TColStd_HSequenceOfReal
        Perform(ShapeAnalysis_TransferParameters self, Standard_Real const Param, Standard_Boolean const To2d) -> Standard_Real

        Transfers parameter given by sequence Params from 3d curve
        to pcurve (if To2d is True) or back (if To2d is False)

        :type Param: float
        :type To2d: bool
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_TransferParameters_Perform(self, *args)


    def TransferRange(self, *args):
        """
        TransferRange(ShapeAnalysis_TransferParameters self, TopoDS_Edge newEdge, Standard_Real const prevPar, Standard_Real const currPar, Standard_Boolean const To2d)

        Recomputes range of curves from NewEdge.
        If Is2d equals True parameters are recomputed by curve2d else by curve3d.

        :type newEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type prevPar: float
        :type currPar: float
        :type To2d: bool

        """
        return _ShapeAnalysis.ShapeAnalysis_TransferParameters_TransferRange(self, *args)


    def IsSameRange(self, *args):
        """
        IsSameRange(ShapeAnalysis_TransferParameters self) -> Standard_Boolean

        Returns True if 3d curve of edge and pcurve are SameRange
        (in default implementation, if myScale == 1 and myShift == 0)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_TransferParameters_IsSameRange(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeAnalysis.ShapeAnalysis_TransferParameters_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeAnalysis.ShapeAnalysis_TransferParameters_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeAnalysis.ShapeAnalysis_TransferParameters_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_TransferParameters
ShapeAnalysis_TransferParameters_swigregister = _ShapeAnalysis.ShapeAnalysis_TransferParameters_swigregister
ShapeAnalysis_TransferParameters_swigregister(ShapeAnalysis_TransferParameters)

def ShapeAnalysis_TransferParameters_get_type_name(*args):
    """
    ShapeAnalysis_TransferParameters_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeAnalysis.ShapeAnalysis_TransferParameters_get_type_name(*args)

def ShapeAnalysis_TransferParameters_get_type_descriptor(*args):
    """
    ShapeAnalysis_TransferParameters_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeAnalysis.ShapeAnalysis_TransferParameters_get_type_descriptor(*args)

class ShapeAnalysis_HSequenceOfFreeBounds(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeAnalysis_HSequenceOfFreeBounds
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeAnalysis_HSequenceOfFreeBounds(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeAnalysis_HSequenceOfFreeBounds self) -> ShapeAnalysis_HSequenceOfFreeBounds
        __init__(ShapeAnalysis_HSequenceOfFreeBounds self, NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData theOther) -> ShapeAnalysis_HSequenceOfFreeBounds

        :type theOther: OCC.wrapper.ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds

        """
        this = _ShapeAnalysis.new_ShapeAnalysis_HSequenceOfFreeBounds(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds

        """
        res = _ShapeAnalysis.ShapeAnalysis_HSequenceOfFreeBounds_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(ShapeAnalysis_HSequenceOfFreeBounds self, Handle_ShapeAnalysis_FreeBoundData theItem)
        Append(ShapeAnalysis_HSequenceOfFreeBounds self, NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData theSequence)

        :type theSequence: OCC.wrapper.ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds

        """
        return _ShapeAnalysis.ShapeAnalysis_HSequenceOfFreeBounds_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(ShapeAnalysis_HSequenceOfFreeBounds self) -> NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData

        :rtype: OCC.wrapper.ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds

        """
        return _ShapeAnalysis.ShapeAnalysis_HSequenceOfFreeBounds_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeAnalysis.ShapeAnalysis_HSequenceOfFreeBounds_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeAnalysis.ShapeAnalysis_HSequenceOfFreeBounds_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeAnalysis.ShapeAnalysis_HSequenceOfFreeBounds_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_HSequenceOfFreeBounds
ShapeAnalysis_HSequenceOfFreeBounds_swigregister = _ShapeAnalysis.ShapeAnalysis_HSequenceOfFreeBounds_swigregister
ShapeAnalysis_HSequenceOfFreeBounds_swigregister(ShapeAnalysis_HSequenceOfFreeBounds)

def ShapeAnalysis_HSequenceOfFreeBounds_get_type_name(*args):
    """
    ShapeAnalysis_HSequenceOfFreeBounds_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeAnalysis.ShapeAnalysis_HSequenceOfFreeBounds_get_type_name(*args)

def ShapeAnalysis_HSequenceOfFreeBounds_get_type_descriptor(*args):
    """
    ShapeAnalysis_HSequenceOfFreeBounds_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeAnalysis.ShapeAnalysis_HSequenceOfFreeBounds_get_type_descriptor(*args)

class ShapeAnalysis_TransferParametersProj(ShapeAnalysis_TransferParameters):
    """
    This tool is used for transferring parameters
    from 3d curve of the edge to pcurve and vice versa.
    This tool transfers parameters with help of
    projection points from curve 3d on curve 2d and
    vice versa
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeAnalysis_TransferParametersProj
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeAnalysis_TransferParametersProj(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeAnalysis_TransferParametersProj self) -> ShapeAnalysis_TransferParametersProj
        __init__(ShapeAnalysis_TransferParametersProj self, TopoDS_Edge E, TopoDS_Face F) -> ShapeAnalysis_TransferParametersProj

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        this = _ShapeAnalysis.new_ShapeAnalysis_TransferParametersProj(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(ShapeAnalysis_TransferParametersProj self, TopoDS_Edge E, TopoDS_Face F)

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _ShapeAnalysis.ShapeAnalysis_TransferParametersProj_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(ShapeAnalysis_TransferParametersProj self, Handle_TColStd_HSequenceOfReal Papams, Standard_Boolean const To2d) -> Handle_TColStd_HSequenceOfReal
        Perform(ShapeAnalysis_TransferParametersProj self, Standard_Real const Param, Standard_Boolean const To2d) -> Standard_Real

        Transfers parameter given by  Param from 3d curve
        to pcurve (if To2d is True) or back (if To2d is False)

        :type Param: float
        :type To2d: bool
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_TransferParametersProj_Perform(self, *args)


    def ForceProjection(self, *args):
        """
        ForceProjection(ShapeAnalysis_TransferParametersProj self) -> Standard_Boolean &

        Returns modifiable flag forcing projection
        If it is False (default), projection is done only
        if edge is not SameParameter or if tolerance of edge
        is greater than MaxTolerance()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_TransferParametersProj_ForceProjection(self, *args)


    def TransferRange(self, *args):
        """
        TransferRange(ShapeAnalysis_TransferParametersProj self, TopoDS_Edge newEdge, Standard_Real const prevPar, Standard_Real const currPar, Standard_Boolean const Is2d)

        Recomputes range of curves from NewEdge.
        If Is2d equals True parameters are recomputed by curve2d else by curve3d.

        :type newEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type prevPar: float
        :type currPar: float
        :type Is2d: bool

        """
        return _ShapeAnalysis.ShapeAnalysis_TransferParametersProj_TransferRange(self, *args)


    def IsSameRange(self, *args):
        """
        IsSameRange(ShapeAnalysis_TransferParametersProj self) -> Standard_Boolean

        Returns False;

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_TransferParametersProj_IsSameRange(self, *args)


    def CopyNMVertex(*args):
        """
        CopyNMVertex(TopoDS_Vertex theVert, TopoDS_Edge toedge, TopoDS_Edge fromedge) -> TopoDS_Vertex
        CopyNMVertex(TopoDS_Vertex theVert, TopoDS_Face toFace, TopoDS_Face fromFace) -> TopoDS_Vertex

        Make a copy of non-manifold vertex theVert
        (i.e. create new  TVertex and replace PointRepresentations for this vertex
        from fromFace to toFace. Other representations were copied)

        :type theVert: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type toFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type fromFace: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _ShapeAnalysis.ShapeAnalysis_TransferParametersProj_CopyNMVertex(*args)

    CopyNMVertex = staticmethod(CopyNMVertex)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeAnalysis.ShapeAnalysis_TransferParametersProj_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeAnalysis.ShapeAnalysis_TransferParametersProj_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeAnalysis.ShapeAnalysis_TransferParametersProj_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_TransferParametersProj
ShapeAnalysis_TransferParametersProj_swigregister = _ShapeAnalysis.ShapeAnalysis_TransferParametersProj_swigregister
ShapeAnalysis_TransferParametersProj_swigregister(ShapeAnalysis_TransferParametersProj)

def ShapeAnalysis_TransferParametersProj_CopyNMVertex(*args):
    """
    CopyNMVertex(TopoDS_Vertex theVert, TopoDS_Edge toedge, TopoDS_Edge fromedge) -> TopoDS_Vertex
    ShapeAnalysis_TransferParametersProj_CopyNMVertex(TopoDS_Vertex theVert, TopoDS_Face toFace, TopoDS_Face fromFace) -> TopoDS_Vertex

    Make a copy of non-manifold vertex theVert
    (i.e. create new  TVertex and replace PointRepresentations for this vertex
    from fromFace to toFace. Other representations were copied)

    :type theVert: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type toFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type fromFace: OCC.wrapper.TopoDS.TopoDS_Face
    :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

    """
    return _ShapeAnalysis.ShapeAnalysis_TransferParametersProj_CopyNMVertex(*args)

def ShapeAnalysis_TransferParametersProj_get_type_name(*args):
    """
    ShapeAnalysis_TransferParametersProj_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeAnalysis.ShapeAnalysis_TransferParametersProj_get_type_name(*args)

def ShapeAnalysis_TransferParametersProj_get_type_descriptor(*args):
    """
    ShapeAnalysis_TransferParametersProj_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeAnalysis.ShapeAnalysis_TransferParametersProj_get_type_descriptor(*args)

class ShapeAnalysis_FreeBoundData(Standard.Standard_Transient):
    """
    This class is intended to represent free bound and to store
    its properties.

    This class is used by ShapeAnalysis_FreeBoundsProperties
    class when storing each free bound and its properties.

    The properties stored in this class are the following:
    - area of the contour,
    - perimeter of the contour,
    - ratio of average length to average width of the contour,
    - average width of contour,
    - notches (narrow 'V'-like sub-contours) on the contour and
    their maximum width.

    This class provides methods for setting and getting fields
    only.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeAnalysis_FreeBoundData
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeAnalysis_FreeBoundData(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeAnalysis_FreeBoundData self) -> ShapeAnalysis_FreeBoundData
        __init__(ShapeAnalysis_FreeBoundData self, TopoDS_Wire freebound) -> ShapeAnalysis_FreeBoundData

        Creates object with contour given in the form of TopoDS_Wire

        :type freebound: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        this = _ShapeAnalysis.new_ShapeAnalysis_FreeBoundData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Clear(self, *args):
        """
        Clear(ShapeAnalysis_FreeBoundData self)

        Clears all properties of the contour.
        Contour bound itself is not cleared.


        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_Clear(self, *args)


    def SetFreeBound(self, *args):
        """
        SetFreeBound(ShapeAnalysis_FreeBoundData self, TopoDS_Wire freebound)

        Sets contour

        :type freebound: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_SetFreeBound(self, *args)


    def SetArea(self, *args):
        """
        SetArea(ShapeAnalysis_FreeBoundData self, Standard_Real const area)

        Sets area of the contour

        :type area: float

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_SetArea(self, *args)


    def SetPerimeter(self, *args):
        """
        SetPerimeter(ShapeAnalysis_FreeBoundData self, Standard_Real const perimeter)

        Sets perimeter of the contour

        :type perimeter: float

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_SetPerimeter(self, *args)


    def SetRatio(self, *args):
        """
        SetRatio(ShapeAnalysis_FreeBoundData self, Standard_Real const ratio)

        Sets ratio of average length to average width of the contour

        :type ratio: float

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_SetRatio(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(ShapeAnalysis_FreeBoundData self, Standard_Real const width)

        Sets average width of the contour

        :type width: float

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_SetWidth(self, *args)


    def AddNotch(self, *args):
        """
        AddNotch(ShapeAnalysis_FreeBoundData self, TopoDS_Wire notch, Standard_Real const width)

        Adds notch on the contour with its maximum width

        :type notch: OCC.wrapper.TopoDS.TopoDS_Wire
        :type width: float

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_AddNotch(self, *args)


    def FreeBound(self, *args):
        """
        FreeBound(ShapeAnalysis_FreeBoundData self) -> TopoDS_Wire

        Returns contour

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_FreeBound(self, *args)


    def Area(self, *args):
        """
        Area(ShapeAnalysis_FreeBoundData self) -> Standard_Real

        Returns area of the contour

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_Area(self, *args)


    def Perimeter(self, *args):
        """
        Perimeter(ShapeAnalysis_FreeBoundData self) -> Standard_Real

        Returns perimeter of the contour

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_Perimeter(self, *args)


    def Ratio(self, *args):
        """
        Ratio(ShapeAnalysis_FreeBoundData self) -> Standard_Real

        Returns ratio of average length to average width of the contour

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_Ratio(self, *args)


    def Width(self, *args):
        """
        Width(ShapeAnalysis_FreeBoundData self) -> Standard_Real

        Returns average width of the contour

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_Width(self, *args)


    def NbNotches(self, *args):
        """
        NbNotches(ShapeAnalysis_FreeBoundData self) -> Standard_Integer

        Returns number of notches on the contour

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_NbNotches(self, *args)


    def Notches(self, *args):
        """
        Notches(ShapeAnalysis_FreeBoundData self) -> Handle_TopTools_HSequenceOfShape

        Returns sequence of notches on the contour

        :rtype: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_Notches(self, *args)


    def Notch(self, *args):
        """
        Notch(ShapeAnalysis_FreeBoundData self, Standard_Integer const index) -> TopoDS_Wire

        Returns notch on the contour

        :type index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_Notch(self, *args)


    def NotchWidth(self, *args):
        """
        NotchWidth(ShapeAnalysis_FreeBoundData self, Standard_Integer const index) -> Standard_Real
        NotchWidth(ShapeAnalysis_FreeBoundData self, TopoDS_Wire notch) -> Standard_Real

        Returns maximum width of notch specified as TopoDS_Wire
        on the contour

        :type notch: OCC.wrapper.TopoDS.TopoDS_Wire
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_NotchWidth(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeAnalysis.ShapeAnalysis_FreeBoundData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_FreeBoundData
ShapeAnalysis_FreeBoundData_swigregister = _ShapeAnalysis.ShapeAnalysis_FreeBoundData_swigregister
ShapeAnalysis_FreeBoundData_swigregister(ShapeAnalysis_FreeBoundData)

def ShapeAnalysis_FreeBoundData_get_type_name(*args):
    """
    ShapeAnalysis_FreeBoundData_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_get_type_name(*args)

def ShapeAnalysis_FreeBoundData_get_type_descriptor(*args):
    """
    ShapeAnalysis_FreeBoundData_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeAnalysis.ShapeAnalysis_FreeBoundData_get_type_descriptor(*args)

class ShapeAnalysis_Surface(Standard.Standard_Transient):
    """
    Complements standard tool Geom_Surface by providing additional
    functionality for detection surface singularities, checking
    spatial surface closure and computing projections of 3D points
    onto a surface.

    * The singularities
    Each singularity stores the precision with which corresponding
    surface iso-line is considered as degenerated.
    The number of singularities is determined by specifying precision
    and always not greater than 4.

    * The spatial closure
    The check for spatial closure is performed with given precision
    (default value is Precision::Confusion).
    If Geom_Surface says that the surface is closed, this class
    also says this. Otherwise additional analysis is performed.

    * The parameters of 3D point on the surface
    The projection of the point is performed with given precision.
    This class tries to find a solution taking into account possible
    singularities.
    Additional method for searching the solution from already built
    one is also provided.

    This tool is optimised: computes most information only once
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeAnalysis_Surface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeAnalysis_Surface(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeAnalysis_Surface self, Handle_Geom_Surface S) -> ShapeAnalysis_Surface

        Creates an analyzer object on the basis of existing surface

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        this = _ShapeAnalysis.new_ShapeAnalysis_Surface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(ShapeAnalysis_Surface self, Handle_Geom_Surface S)
        Init(ShapeAnalysis_Surface self, Handle_ShapeAnalysis_Surface other)

        Reads all the data from another Surface, without recomputing

        :type other: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_Surface

        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_Init(self, *args)


    def SetDomain(self, *args):
        """
        SetDomain(ShapeAnalysis_Surface self, Standard_Real const U1, Standard_Real const U2, Standard_Real const V1, Standard_Real const V2)

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_SetDomain(self, *args)


    def Surface(self, *args):
        """
        Returns a surface being analyzed

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _ShapeAnalysis.ShapeAnalysis_Surface_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Adaptor3d(self, *args):
        """
        Returns the Adaptor.
        Creates it if not yet done.

        :rtype: OCC.wrapper.GeomAdaptor.Handle_GeomAdaptor_HSurface

        """
        res = _ShapeAnalysis.ShapeAnalysis_Surface_Adaptor3d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TrueAdaptor3d(self, *args):
        """
        Returns the Adaptor (may be Null if method Adaptor() was not called)

        :rtype: OCC.wrapper.GeomAdaptor.Handle_GeomAdaptor_HSurface

        """
        res = _ShapeAnalysis.ShapeAnalysis_Surface_TrueAdaptor3d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Gap(self, *args):
        """
        Gap(ShapeAnalysis_Surface self) -> Standard_Real

        Returns 3D distance found by one of the following methods.
        IsDegenerated, DegeneratedValues, ProjectDegenerated
        (distance between 3D point and found or last (if not found)
        singularity),
        IsUClosed, IsVClosed (minimum value of precision to consider
        the surface to be closed),
        ValueOfUV (distance between 3D point and found solution).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_Gap(self, *args)


    def Value(self, *args):
        """
        Value(ShapeAnalysis_Surface self, Standard_Real const u, Standard_Real const v) -> gp_Pnt
        Value(ShapeAnalysis_Surface self, gp_Pnt2d p2d) -> gp_Pnt

        Returns a 3d point specified by a point in surface
        parametrical space

        :type p2d: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_Value(self, *args)


    def HasSingularities(self, *args):
        """
        HasSingularities(ShapeAnalysis_Surface self, Standard_Real const preci) -> Standard_Boolean

        Returns True if the surface has singularities for the given
        precision (i.e. if there are surface singularities with sizes
        not greater than precision).

        :type preci: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_HasSingularities(self, *args)


    def NbSingularities(self, *args):
        """
        NbSingularities(ShapeAnalysis_Surface self, Standard_Real const preci) -> Standard_Integer

        Returns the number of singularities for the given precision
        (i.e. number of surface singularities with sizes not greater
        than precision).

        :type preci: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_NbSingularities(self, *args)


    def Singularity(self, *args):
        """
        Singularity(ShapeAnalysis_Surface self, Standard_Integer const num, gp_Pnt P3d, gp_Pnt2d firstP2d, gp_Pnt2d lastP2d) -> Standard_Boolean

        Returns the characteristics of the singularity specified by
        its rank number <num>.
        That means, that it is not neccessary for <num> to be in the
        range [1, NbSingularities] but must be not greater than
        possible (see ComputeSingularities).
        The returned characteristics are:
        preci: the smallest precision with which the iso-line is
        considered as degenerated,
        P3d: 3D point of singularity (middle point of the surface
        iso-line),
        firstP2d and lastP2d: first and last 2D points of the
        iso-line in parametrical surface,
        firstpar and lastpar: first and last parameters of the
        iso-line in parametrical surface,
        uisodeg: if the degenerated iso-line is U-iso (True) or
        V-iso (False).
        Returns False if <num> is out of range, else returns True.

        :type num: int
        :type preci: float
        :type P3d: OCC.wrapper.gp.gp_Pnt
        :type firstP2d: OCC.wrapper.gp.gp_Pnt2d
        :type lastP2d: OCC.wrapper.gp.gp_Pnt2d
        :type firstpar: float
        :type lastpar: float
        :type uisodeg: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_Singularity(self, *args)


    def DegeneratedValues(self, *args):
        """
        DegeneratedValues(ShapeAnalysis_Surface self, gp_Pnt P3d, Standard_Real const preci, gp_Pnt2d firstP2d, gp_Pnt2d lastP2d, Standard_Boolean const forward) -> Standard_Boolean

        Returns True if there is at least one surface iso-line which
        is considered as degenerated with <preci> and distance
        between P3d and corresponding singular point is less than
        <preci> (like IsDegenerated).
        Returns characteristics of the first found boundary matching
        those criteria.

        :type P3d: OCC.wrapper.gp.gp_Pnt
        :type preci: float
        :type firstP2d: OCC.wrapper.gp.gp_Pnt2d
        :type lastP2d: OCC.wrapper.gp.gp_Pnt2d
        :type firstpar: float
        :type lastpar: float
        :type forward: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_DegeneratedValues(self, *args)


    def ProjectDegenerated(self, *args):
        """
        ProjectDegenerated(ShapeAnalysis_Surface self, gp_Pnt P3d, Standard_Real const preci, gp_Pnt2d neighbour, gp_Pnt2d result) -> Standard_Boolean
        ProjectDegenerated(ShapeAnalysis_Surface self, Standard_Integer const nbrPnt, NCollection_Sequence_gp_Pnt points, NCollection_Sequence_gp_Pnt2d pnt2d, Standard_Real const preci, Standard_Boolean const direct) -> Standard_Boolean

        Checks points at the beginning (direct is True) or end
        (direct is False) of array <points> to lie in singularity of
        surface, and if yes, adjusts the indeterminate 2d coordinate
        of these points by nearest point which is not in singularity.
        Returns True if some points were adjusted.

        :type nbrPnt: int
        :type points: OCC.wrapper.TColgp.TColgp_SequenceOfPnt
        :type pnt2d: OCC.wrapper.TColgp.TColgp_SequenceOfPnt2d
        :type preci: float
        :type direct: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_ProjectDegenerated(self, *args)


    def IsDegenerated(self, *args):
        """
        IsDegenerated(ShapeAnalysis_Surface self, gp_Pnt P3d, Standard_Real const preci) -> Standard_Boolean
        IsDegenerated(ShapeAnalysis_Surface self, gp_Pnt2d p2d1, gp_Pnt2d p2d2, Standard_Real const tol, Standard_Real const ratio) -> Standard_Boolean

        Returns True if straight pcurve going from point p2d1 to p2d2
        is degenerate, i.e. lies in the singularity of the surface.
        NOTE: it uses another method of detecting singularity than
        used by ComputeSingularities() et al.!
        For that, maximums of distances between points p2d1, p2d2
        and 0.5*(p2d1+p2d2) and between corresponding 3d points are
        computed.
        The pcurve (p2d1, p2d2) is considered as degenerate if:
        - max distance in 3d is less than <tol>
        - max distance in 2d is at least <ratio> times greather than
        the Resolution computed from max distance in 3d
        (max3d < tol && max2d > ratio * Resolution(max3d))
        NOTE: <ratio> should be >1 (e.g. 10)

        :type p2d1: OCC.wrapper.gp.gp_Pnt2d
        :type p2d2: OCC.wrapper.gp.gp_Pnt2d
        :type tol: float
        :type ratio: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_IsDegenerated(self, *args)


    def Bounds(self, *args):
        """
        Bounds(ShapeAnalysis_Surface self)

        Returns the bounds of the surface
        (from Bounds from Surface, but buffered)

        :type ufirst: float
        :type ulast: float
        :type vfirst: float
        :type vlast: float

        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_Bounds(self, *args)


    def ComputeBoundIsos(self, *args):
        """
        ComputeBoundIsos(ShapeAnalysis_Surface self)

        Computes bound isos (protected against exceptions)


        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_ComputeBoundIsos(self, *args)


    def UIso(self, *args):
        """
        UIso(ShapeAnalysis_Surface self, Standard_Real const U) -> Handle_Geom_Curve

        Returns a U-Iso. Null if not possible or failed
        Remark : bound isos are buffered

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(ShapeAnalysis_Surface self, Standard_Real const V) -> Handle_Geom_Curve

        Returns a V-Iso. Null if not possible or failed
        Remark : bound isos are buffered

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_VIso(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(ShapeAnalysis_Surface self, Standard_Real const preci=-1) -> Standard_Boolean

        Tells if the Surface is spatially closed in U with given
        precision. If <preci> < 0 then Precision::Confusion is used.
        If Geom_Surface says that the surface is U-closed, this method
        also says this. Otherwise additional analysis is performed,
        comparing given precision with the following distances:
        - periodic B-Splines are closed,
        - polinomial B-Spline with boundary multiplicities degree+1
        and Bezier - maximum distance between poles,
        - rational B-Spline or one with boundary multiplicities not
        degree+1 - maximum distance computed at knots and their
        middles,
        - surface of extrusion - distance between ends of basis
        curve,
        - other (RectangularTrimmed and Offset) - maximum distance
        computed at 100 equi-distanted points.

        :type preci: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(ShapeAnalysis_Surface self, Standard_Real const preci=-1) -> Standard_Boolean

        Tells if the Surface is spatially closed in V with given
        precision. If <preci> < 0 then Precision::Confusion is used.
        If Geom_Surface says that the surface is V-closed, this method
        also says this. Otherwise additional analysis is performed,
        comparing given precision with the following distances:
        - periodic B-Splines are closed,
        - polinomial B-Spline with boundary multiplicities degree+1
        and Bezier - maximum distance between poles,
        - rational B-Spline or one with boundary multiplicities not
        degree+1 - maximum distance computed at knots and their
        middles,
        - surface of revolution - distance between ends of basis
        curve,
        - other (RectangularTrimmed and Offset) - maximum distance
        computed at 100 equi-distanted points.

        :type preci: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_IsVClosed(self, *args)


    def ValueOfUV(self, *args):
        """
        ValueOfUV(ShapeAnalysis_Surface self, gp_Pnt P3D, Standard_Real const preci) -> gp_Pnt2d

        Computes the parameters in the surface parametrical space of
        3D point.
        The result is parameters of the point projected onto the
        surface.
        This method enhances functionality provided by the standard
        tool GeomAPI_ProjectPointOnSurface by treatment of cases when
        the projected point is near to the surface boundaries and
        when this standard tool fails.

        :type P3D: OCC.wrapper.gp.gp_Pnt
        :type preci: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_ValueOfUV(self, *args)


    def NextValueOfUV(self, *args):
        """
        NextValueOfUV(ShapeAnalysis_Surface self, gp_Pnt2d p2dPrev, gp_Pnt P3D, Standard_Real const preci, Standard_Real const maxpreci=-1.0) -> gp_Pnt2d

        Projects a point P3D on the surface.
        Does the same thing as ValueOfUV but tries to optimize
        computations by taking into account previous point <p2dPrev>:
        makes a step by UV and tries Newton algorithm.
        If <maxpreci> >0. and distance between solution and
        P3D is greater than <maxpreci>, that solution is considered
        as bad, and ValueOfUV() is used.
        If not succeded, calls ValueOfUV()

        :type p2dPrev: OCC.wrapper.gp.gp_Pnt2d
        :type P3D: OCC.wrapper.gp.gp_Pnt
        :type preci: float
        :type maxpreci: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_NextValueOfUV(self, *args)


    def UVFromIso(self, *args):
        """
        UVFromIso(ShapeAnalysis_Surface self, gp_Pnt P3D, Standard_Real const preci) -> Standard_Real

        Tries a refinement of an already computed couple (U,V) by
        using projecting 3D point on iso-lines:
        1. boundaries of the surface,
        2. iso-lines passing through (U,V)
        3. iteratively received iso-lines passing through new U and
        new V (number of iterations is limited by 5 in each
        direction)
        Returns the best resulting distance between P3D and Value(U,V)
        in the case of success. Else, returns a very great value

        :type P3D: OCC.wrapper.gp.gp_Pnt
        :type preci: float
        :type U: float
        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_UVFromIso(self, *args)


    def UCloseVal(self, *args):
        """
        UCloseVal(ShapeAnalysis_Surface self) -> Standard_Real

        Returns minimum value to consider the surface as U-closed

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_UCloseVal(self, *args)


    def VCloseVal(self, *args):
        """
        VCloseVal(ShapeAnalysis_Surface self) -> Standard_Real

        Returns minimum value to consider the surface as V-closed

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_VCloseVal(self, *args)


    def GetBoxUF(self, *args):
        """
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        res = _ShapeAnalysis.ShapeAnalysis_Surface_GetBoxUF(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetBoxUL(self, *args):
        """
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        res = _ShapeAnalysis.ShapeAnalysis_Surface_GetBoxUL(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetBoxVF(self, *args):
        """
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        res = _ShapeAnalysis.ShapeAnalysis_Surface_GetBoxVF(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetBoxVL(self, *args):
        """
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        res = _ShapeAnalysis.ShapeAnalysis_Surface_GetBoxVL(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeAnalysis.ShapeAnalysis_Surface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeAnalysis.ShapeAnalysis_Surface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_Surface
ShapeAnalysis_Surface_swigregister = _ShapeAnalysis.ShapeAnalysis_Surface_swigregister
ShapeAnalysis_Surface_swigregister(ShapeAnalysis_Surface)

def ShapeAnalysis_Surface_get_type_name(*args):
    """
    ShapeAnalysis_Surface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeAnalysis.ShapeAnalysis_Surface_get_type_name(*args)

def ShapeAnalysis_Surface_get_type_descriptor(*args):
    """
    ShapeAnalysis_Surface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeAnalysis.ShapeAnalysis_Surface_get_type_descriptor(*args)

class Handle_ShapeAnalysis_HSequenceOfFreeBounds(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeAnalysis_HSequenceOfFreeBounds self)

        Nullify the handle


        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeAnalysis_HSequenceOfFreeBounds self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeAnalysis_HSequenceOfFreeBounds self, ShapeAnalysis_HSequenceOfFreeBounds thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeAnalysis_HSequenceOfFreeBounds self, Handle_ShapeAnalysis_HSequenceOfFreeBounds theHandle) -> Handle_ShapeAnalysis_HSequenceOfFreeBounds
        assign(Handle_ShapeAnalysis_HSequenceOfFreeBounds self, ShapeAnalysis_HSequenceOfFreeBounds thePtr) -> Handle_ShapeAnalysis_HSequenceOfFreeBounds
        assign(Handle_ShapeAnalysis_HSequenceOfFreeBounds self, Handle_ShapeAnalysis_HSequenceOfFreeBounds theHandle) -> Handle_ShapeAnalysis_HSequenceOfFreeBounds

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeAnalysis_HSequenceOfFreeBounds self) -> ShapeAnalysis_HSequenceOfFreeBounds

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeAnalysis_HSequenceOfFreeBounds self) -> ShapeAnalysis_HSequenceOfFreeBounds

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeAnalysis_HSequenceOfFreeBounds self) -> ShapeAnalysis_HSequenceOfFreeBounds

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds___ref__(self, *args)


    def __hash__(self):
        return _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeAnalysis.new_Handle_ShapeAnalysis_HSequenceOfFreeBounds(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_DownCast)
    __swig_destroy__ = _ShapeAnalysis.delete_Handle_ShapeAnalysis_HSequenceOfFreeBounds

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds

        """
        res = _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_ShapeAnalysis_HSequenceOfFreeBounds self, Handle_ShapeAnalysis_FreeBoundData theItem)
        Append(Handle_ShapeAnalysis_HSequenceOfFreeBounds self, NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData theSequence)

        :type theSequence: OCC.wrapper.ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_ShapeAnalysis_HSequenceOfFreeBounds self) -> NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData

        :rtype: OCC.wrapper.ShapeAnalysis.ShapeAnalysis_SequenceOfFreeBounds

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeAnalysis_HSequenceOfFreeBounds self) -> char const *

        :rtype: const char *

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ShapeAnalysis_HSequenceOfFreeBounds self)

        Memory deallocator for transient classes


        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeAnalysis_HSequenceOfFreeBounds self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeAnalysis_HSequenceOfFreeBounds self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeAnalysis_HSequenceOfFreeBounds self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeAnalysis_HSequenceOfFreeBounds self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeAnalysis_HSequenceOfFreeBounds self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeAnalysis_HSequenceOfFreeBounds self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeAnalysis_HSequenceOfFreeBounds self)

        Increments the reference counter of this object


        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeAnalysis_HSequenceOfFreeBounds self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_DecrementRefCounter(self, *args)

Handle_ShapeAnalysis_HSequenceOfFreeBounds_swigregister = _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_swigregister
Handle_ShapeAnalysis_HSequenceOfFreeBounds_swigregister(Handle_ShapeAnalysis_HSequenceOfFreeBounds)

def Handle_ShapeAnalysis_HSequenceOfFreeBounds_DownCast(thing):
    return _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_DownCast(thing)
Handle_ShapeAnalysis_HSequenceOfFreeBounds_DownCast = _ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds_DownCast

class ShapeAnalysis_Geom(object):
    """Analyzing tool aimed to work on primitive geometrical objects"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def NearestPlane(*args):
        """
        NearestPlane(NCollection_Array1_gp_Pnt Pnts, gp_Pln aPln) -> Standard_Boolean

        Builds a plane out of a set of points in array
        Returns in <dmax> the maximal distance between the produced
        plane and given points

        :type Pnts: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type aPln: OCC.wrapper.gp.gp_Pln
        :type Dmax: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Geom_NearestPlane(*args)

    NearestPlane = staticmethod(NearestPlane)

    def PositionTrsf(*args):
        """
        PositionTrsf(Handle_TColStd_HArray2OfReal coefs, gp_Trsf trsf, Standard_Real const unit, Standard_Real const prec) -> Standard_Boolean

        Builds transfromation object out of matrix.
        Matrix must be 3 x 4.
        Unit is used as multiplier.

        :type coefs: OCC.wrapper.TColStd.Handle_TColStd_HArray2OfReal
        :type trsf: OCC.wrapper.gp.gp_Trsf
        :type unit: float
        :type prec: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Geom_PositionTrsf(*args)

    PositionTrsf = staticmethod(PositionTrsf)

    def __init__(self):
        """Analyzing tool aimed to work on primitive geometrical objects"""
        this = _ShapeAnalysis.new_ShapeAnalysis_Geom()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_Geom
ShapeAnalysis_Geom_swigregister = _ShapeAnalysis.ShapeAnalysis_Geom_swigregister
ShapeAnalysis_Geom_swigregister(ShapeAnalysis_Geom)

def ShapeAnalysis_Geom_NearestPlane(*args):
    """
    ShapeAnalysis_Geom_NearestPlane(NCollection_Array1_gp_Pnt Pnts, gp_Pln aPln) -> Standard_Boolean

    Builds a plane out of a set of points in array
    Returns in <dmax> the maximal distance between the produced
    plane and given points

    :type Pnts: OCC.wrapper.TColgp.TColgp_Array1OfPnt
    :type aPln: OCC.wrapper.gp.gp_Pln
    :type Dmax: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _ShapeAnalysis.ShapeAnalysis_Geom_NearestPlane(*args)

def ShapeAnalysis_Geom_PositionTrsf(*args):
    """
    ShapeAnalysis_Geom_PositionTrsf(Handle_TColStd_HArray2OfReal coefs, gp_Trsf trsf, Standard_Real const unit, Standard_Real const prec) -> Standard_Boolean

    Builds transfromation object out of matrix.
    Matrix must be 3 x 4.
    Unit is used as multiplier.

    :type coefs: OCC.wrapper.TColStd.Handle_TColStd_HArray2OfReal
    :type trsf: OCC.wrapper.gp.gp_Trsf
    :type unit: float
    :type prec: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _ShapeAnalysis.ShapeAnalysis_Geom_PositionTrsf(*args)

class NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self) -> NCollection_Sequence< opencascade::handle< ShapeAnalysis_FreeBoundData > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self) -> NCollection_Sequence< opencascade::handle< ShapeAnalysis_FreeBoundData > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self) -> NCollection_Sequence< opencascade::handle< ShapeAnalysis_FreeBoundData > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self) -> NCollection_Sequence< opencascade::handle< ShapeAnalysis_FreeBoundData > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _ShapeAnalysis.new_NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self)

        Reverse sequence


        """
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self, NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData theOther) -> NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self, NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData theOther) -> NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self, NCollection_Sequence< opencascade::handle< ShapeAnalysis_FreeBoundData > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self, Handle_ShapeAnalysis_FreeBoundData theItem)
        Append(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self, NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self, Handle_ShapeAnalysis_FreeBoundData theItem)
        Prepend(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self, NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self, Standard_Integer const theIndex, Handle_ShapeAnalysis_FreeBoundData theItem)
        InsertBefore(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self, Standard_Integer const theIndex, NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self, NCollection_Sequence< opencascade::handle< ShapeAnalysis_FreeBoundData > >::Iterator & thePosition, Handle_ShapeAnalysis_FreeBoundData theItem)
        InsertAfter(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self, Standard_Integer const theIndex, NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData theSeq)
        InsertAfter(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self, Standard_Integer const theIndex, Handle_ShapeAnalysis_FreeBoundData theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self, Standard_Integer const theIndex, NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self) -> Handle_ShapeAnalysis_FreeBoundData

        First item access

        :rtype: TheItemType &

        """
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self) -> Handle_ShapeAnalysis_FreeBoundData

        Last item access

        :rtype: TheItemType &

        """
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self, Standard_Integer const theIndex) -> Handle_ShapeAnalysis_FreeBoundData

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData self, Standard_Integer const theIndex, Handle_ShapeAnalysis_FreeBoundData theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_SetValue(self, *args)


    def __iter__(self):
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData___iter__(self)
    __swig_destroy__ = _ShapeAnalysis.delete_NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData
NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_swigregister = _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_swigregister
NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_swigregister(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData)

def NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_delNode(*args):
    """
    NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_delNode(*args)

class NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _ShapeAnalysis.new_NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeAnalysis.delete_NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_IteratorHelper

    def __next__(self):
        return _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_IteratorHelper___next__(self)
NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_IteratorHelper_swigregister = _ShapeAnalysis.NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_IteratorHelper_swigregister
NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_IteratorHelper_swigregister(NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData_IteratorHelper)


try:
	ShapeAnalysis_SequenceOfFreeBounds = NCollection_Sequence_Handle_ShapeAnalysis_FreeBoundData
except NameError:
	pass # does not exist, probably ignored

class ShapeAnalysis_Shell(object):
    """
    This class provides operators to analyze edges orientation
    in the shell.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Clear(self, *args):
        """
        Clear(ShapeAnalysis_Shell self)

        Clears data about loaded shells and performed checks


        """
        return _ShapeAnalysis.ShapeAnalysis_Shell_Clear(self, *args)


    def LoadShells(self, *args):
        """
        LoadShells(ShapeAnalysis_Shell self, TopoDS_Shape shape)

        Adds shells contained in the <shape> to the list of loaded shells

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeAnalysis.ShapeAnalysis_Shell_LoadShells(self, *args)


    def CheckOrientedShells(self, *args):
        """
        CheckOrientedShells(ShapeAnalysis_Shell self, TopoDS_Shape shape, Standard_Boolean const alsofree, Standard_Boolean const checkinternaledges) -> Standard_Boolean

        Checks if shells fulfill orientation condition, i.e. if each
        edge is, either present once (free edge) or twice (connected
        edge) but with different orientations (FORWARD/REVERSED)
        Edges which do not fulfill these conditions are bad

        If <alsofree> is True free edges are considered.
        Free edges can be queried but are not bad

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type alsofree: bool
        :type checkinternaledges: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Shell_CheckOrientedShells(self, *args)


    def IsLoaded(self, *args):
        """
        IsLoaded(ShapeAnalysis_Shell self, TopoDS_Shape shape) -> Standard_Boolean

        Tells if a shape is loaded (only shells are checked)

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Shell_IsLoaded(self, *args)


    def NbLoaded(self, *args):
        """
        NbLoaded(ShapeAnalysis_Shell self) -> Standard_Integer

        Returns the actual number of loaded shapes (i.e. shells)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_Shell_NbLoaded(self, *args)


    def Loaded(self, *args):
        """
        Loaded(ShapeAnalysis_Shell self, Standard_Integer const num) -> TopoDS_Shape

        Returns a loaded shape specified by its rank number.
        Returns null shape if <num> is out of range

        :type num: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeAnalysis.ShapeAnalysis_Shell_Loaded(self, *args)


    def HasBadEdges(self, *args):
        """
        HasBadEdges(ShapeAnalysis_Shell self) -> Standard_Boolean

        Tells if at least one edge is recorded as bad

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Shell_HasBadEdges(self, *args)


    def BadEdges(self, *args):
        """
        BadEdges(ShapeAnalysis_Shell self) -> TopoDS_Compound

        Returns the list of bad edges as a Compound
        It is empty (not null) if no edge are recorded as bad

        :rtype: OCC.wrapper.TopoDS.TopoDS_Compound

        """
        return _ShapeAnalysis.ShapeAnalysis_Shell_BadEdges(self, *args)


    def HasFreeEdges(self, *args):
        """
        HasFreeEdges(ShapeAnalysis_Shell self) -> Standard_Boolean

        Tells if at least one edge is recorded as free (not connected)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Shell_HasFreeEdges(self, *args)


    def FreeEdges(self, *args):
        """
        FreeEdges(ShapeAnalysis_Shell self) -> TopoDS_Compound

        Returns the list of free (not connected) edges as a Compound
        It is empty (not null) if no edge are recorded as free

        :rtype: OCC.wrapper.TopoDS.TopoDS_Compound

        """
        return _ShapeAnalysis.ShapeAnalysis_Shell_FreeEdges(self, *args)


    def HasConnectedEdges(self, *args):
        """
        HasConnectedEdges(ShapeAnalysis_Shell self) -> Standard_Boolean

        Tells if at least one edge is connected (shared twice or more)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Shell_HasConnectedEdges(self, *args)


    def __init__(self):
        """
        This class provides operators to analyze edges orientation
        in the shell.
        """
        this = _ShapeAnalysis.new_ShapeAnalysis_Shell()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_Shell
ShapeAnalysis_Shell_swigregister = _ShapeAnalysis.ShapeAnalysis_Shell_swigregister
ShapeAnalysis_Shell_swigregister(ShapeAnalysis_Shell)

class ShapeAnalysis_FreeBounds(object):
    """
    This class is intended to output free bounds of the shape
    (free bounds are the wires consisting of edges referenced by the
    only face).
    This class works on two distinct types of shapes when analyzing
    their free bounds:
    1. compound of faces.
    Analyzer of sewing algorithm (BRepAlgo_Sewing) is used for
    for forecasting free bounds that would be obtained after
    performing sewing
    2. compound of shells.
    Actual free bounds (edges shared by the only face in the shell)
    are output in this case. ShapeAnalysis_Shell is used for that.

    When connecting edges into the wires algorithm tries to build
    wires of maximum length. Two options are provided for a user
    to extract closed sub-contours out of closed and/or open contours.

    Free bounds are returned as two compounds, one for closed and one
    for open wires.

    This class also provides some static methods for advanced use:
    connecting edges/wires to wires, extracting closed sub-wires out
    of wires, dispatching wires into compounds for closed and open
    wires.
    NOTE. Ends of the edge or wire mean hereafter their end vertices.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeAnalysis_FreeBounds self) -> ShapeAnalysis_FreeBounds
        __init__(ShapeAnalysis_FreeBounds self, TopoDS_Shape shape, Standard_Real const toler, Standard_Boolean const splitclosed, Standard_Boolean const splitopen) -> ShapeAnalysis_FreeBounds
        __init__(ShapeAnalysis_FreeBounds self, TopoDS_Shape shape, Standard_Boolean const splitclosed, Standard_Boolean const splitopen, Standard_Boolean const checkinternaledges) -> ShapeAnalysis_FreeBounds

        Builds actual free bounds of the <shape>.
        <shape> should be a compound of shells.
        This constructor is to be used for getting free edges (ones
        referenced by the only face) with help of analyzer
        ShapeAnalysis_Shell.
        Free edges are connected into wires only when they share the
        same vertex.
        If <splitclosed> is True extracts closed sub-wires out of
        built closed wires.
        If <splitopen> is True extracts closed sub-wires out of
        built open wires.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type splitclosed: bool
        :type splitopen: bool
        :type checkinternaledges: bool

        """
        this = _ShapeAnalysis.new_ShapeAnalysis_FreeBounds(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetClosedWires(self, *args):
        """
        Returns compound of closed wires out of free edges.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Compound

        """
        res = _ShapeAnalysis.ShapeAnalysis_FreeBounds_GetClosedWires(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetOpenWires(self, *args):
        """
        Returns compound of open wires out of free edges.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Compound

        """
        res = _ShapeAnalysis.ShapeAnalysis_FreeBounds_GetOpenWires(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ConnectEdgesToWires(*args):
        """
        ConnectEdgesToWires(Handle_TopTools_HSequenceOfShape edges, Standard_Real const toler, Standard_Boolean const shared, Handle_TopTools_HSequenceOfShape wires)

        Builds sequnce of <wires> out of sequence of not sorted
        <edges>.
        Tries to build wires of maximum length. Building a wire is
        stopped when no edges can be connected to it at its head or
        at its tail.

        Orientation of the edge can change when connecting.
        If <shared> is True connection is performed only when
        adjacent edges share the same vertex.
        If <shared> is False connection is performed only when
        ends of adjacent edges are at distance less than <toler>.

        :type edges: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type toler: float
        :type shared: bool
        :type wires: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBounds_ConnectEdgesToWires(*args)

    ConnectEdgesToWires = staticmethod(ConnectEdgesToWires)

    def ConnectWiresToWires(*args):
        """
        ConnectWiresToWires(Handle_TopTools_HSequenceOfShape iwires, Standard_Real const toler, Standard_Boolean const shared, Handle_TopTools_HSequenceOfShape owires)
        ConnectWiresToWires(Handle_TopTools_HSequenceOfShape iwires, Standard_Real const toler, Standard_Boolean const shared, Handle_TopTools_HSequenceOfShape owires, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher vertices)

        Builds sequnce of <owires> out of sequence of not sorted
        <iwires>.
        Tries to build wires of maximum length. Building a wire is
        stopped when no wires can be connected to it at its head or
        at its tail.

        Orientation of the wire can change when connecting.
        If <shared> is True connection is performed only when
        adjacent wires share the same vertex.
        If <shared> is False connection is performed only when
        ends of adjacent wires are at distance less than <toler>.
        Map <vertices> stores the correspondence between original
        end vertices of the wires and new connecting vertices.

        :type iwires: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type toler: float
        :type shared: bool
        :type owires: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type vertices: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBounds_ConnectWiresToWires(*args)

    ConnectWiresToWires = staticmethod(ConnectWiresToWires)

    def SplitWires(*args):
        """
        SplitWires(Handle_TopTools_HSequenceOfShape wires, Standard_Real const toler, Standard_Boolean const shared, Handle_TopTools_HSequenceOfShape closed, Handle_TopTools_HSequenceOfShape open)

        Extracts closed sub-wires out of <wires> and adds them
        to <closed>, open wires remained after extraction are put
        into <open>.
        If <shared> is True extraction is performed only when
        edges share the same vertex.
        If <shared> is False connection is performed only when
        ends of the edges are at distance less than <toler>.

        :type wires: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type toler: float
        :type shared: bool
        :type closed: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type open: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBounds_SplitWires(*args)

    SplitWires = staticmethod(SplitWires)

    def DispatchWires(*args):
        """
        DispatchWires(Handle_TopTools_HSequenceOfShape wires, TopoDS_Compound closed, TopoDS_Compound open)

        Dispatches sequence of <wires> into two compounds
        <closed> for closed wires and <open> for open wires.
        If a compound is not empty wires are added into it.

        :type wires: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type closed: OCC.wrapper.TopoDS.TopoDS_Compound
        :type open: OCC.wrapper.TopoDS.TopoDS_Compound

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBounds_DispatchWires(*args)

    DispatchWires = staticmethod(DispatchWires)
    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_FreeBounds
ShapeAnalysis_FreeBounds_swigregister = _ShapeAnalysis.ShapeAnalysis_FreeBounds_swigregister
ShapeAnalysis_FreeBounds_swigregister(ShapeAnalysis_FreeBounds)

def ShapeAnalysis_FreeBounds_ConnectEdgesToWires(*args):
    """
    ShapeAnalysis_FreeBounds_ConnectEdgesToWires(Handle_TopTools_HSequenceOfShape edges, Standard_Real const toler, Standard_Boolean const shared, Handle_TopTools_HSequenceOfShape wires)

    Builds sequnce of <wires> out of sequence of not sorted
    <edges>.
    Tries to build wires of maximum length. Building a wire is
    stopped when no edges can be connected to it at its head or
    at its tail.

    Orientation of the edge can change when connecting.
    If <shared> is True connection is performed only when
    adjacent edges share the same vertex.
    If <shared> is False connection is performed only when
    ends of adjacent edges are at distance less than <toler>.

    :type edges: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
    :type toler: float
    :type shared: bool
    :type wires: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape

    """
    return _ShapeAnalysis.ShapeAnalysis_FreeBounds_ConnectEdgesToWires(*args)

def ShapeAnalysis_FreeBounds_ConnectWiresToWires(*args):
    """
    ConnectWiresToWires(Handle_TopTools_HSequenceOfShape iwires, Standard_Real const toler, Standard_Boolean const shared, Handle_TopTools_HSequenceOfShape owires)
    ShapeAnalysis_FreeBounds_ConnectWiresToWires(Handle_TopTools_HSequenceOfShape iwires, Standard_Real const toler, Standard_Boolean const shared, Handle_TopTools_HSequenceOfShape owires, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher vertices)

    Builds sequnce of <owires> out of sequence of not sorted
    <iwires>.
    Tries to build wires of maximum length. Building a wire is
    stopped when no wires can be connected to it at its head or
    at its tail.

    Orientation of the wire can change when connecting.
    If <shared> is True connection is performed only when
    adjacent wires share the same vertex.
    If <shared> is False connection is performed only when
    ends of adjacent wires are at distance less than <toler>.
    Map <vertices> stores the correspondence between original
    end vertices of the wires and new connecting vertices.

    :type iwires: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
    :type toler: float
    :type shared: bool
    :type owires: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
    :type vertices: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape

    """
    return _ShapeAnalysis.ShapeAnalysis_FreeBounds_ConnectWiresToWires(*args)

def ShapeAnalysis_FreeBounds_SplitWires(*args):
    """
    ShapeAnalysis_FreeBounds_SplitWires(Handle_TopTools_HSequenceOfShape wires, Standard_Real const toler, Standard_Boolean const shared, Handle_TopTools_HSequenceOfShape closed, Handle_TopTools_HSequenceOfShape open)

    Extracts closed sub-wires out of <wires> and adds them
    to <closed>, open wires remained after extraction are put
    into <open>.
    If <shared> is True extraction is performed only when
    edges share the same vertex.
    If <shared> is False connection is performed only when
    ends of the edges are at distance less than <toler>.

    :type wires: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
    :type toler: float
    :type shared: bool
    :type closed: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
    :type open: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape

    """
    return _ShapeAnalysis.ShapeAnalysis_FreeBounds_SplitWires(*args)

def ShapeAnalysis_FreeBounds_DispatchWires(*args):
    """
    ShapeAnalysis_FreeBounds_DispatchWires(Handle_TopTools_HSequenceOfShape wires, TopoDS_Compound closed, TopoDS_Compound open)

    Dispatches sequence of <wires> into two compounds
    <closed> for closed wires and <open> for open wires.
    If a compound is not empty wires are added into it.

    :type wires: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
    :type closed: OCC.wrapper.TopoDS.TopoDS_Compound
    :type open: OCC.wrapper.TopoDS.TopoDS_Compound

    """
    return _ShapeAnalysis.ShapeAnalysis_FreeBounds_DispatchWires(*args)

class NCollection_UBTree_Standard_Integer_Bnd_Box(object):
    """
    The algorithm of unbalanced binary tree of overlapped bounding boxes.

    Once the tree of boxes  of geometric objects is constructed, the algorithm
    is capable of fast geometric selection of objects.  The tree can be easily
    updated by adding to it a new object with bounding box.

    The time of adding to the tree  of one object is O(log(N)), where N is the
    total number of  objects, so the time  of building a tree of  N objects is
    O(N(log(N)). The search time of one object is O(log(N)).

    Defining  various classes  inheriting NCollection_UBTree::Selector  we can
    perform various kinds of selection over the same b-tree object

    The object  may be of any  type allowing copying. Among  the best suitable
    solutions there can  be a pointer to an object,  handled object or integer
    index of object inside some  collection.  The bounding object may have any
    dimension  and  geometry. The  minimal  interface  of TheBndType  (besides
    public empty and copy constructor and operator =) used in UBTree algorithm
    is as the following:
    @code
    class MyBndType
    {
    public:
    inline void                   Add (const MyBndType& other);
    // Updates me with other bounding

    inline Standard_Boolean       IsOut (const MyBndType& other) const;
    // Classifies other bounding relatively me

    inline Standard_Real          SquareExtent() const;
    // Computes the squared maximal linear extent of me.
    // (For box it is the squared diagonal of box)
    };
    @endcode
    To select objects you need to define a class derived from UBTree::Selector
    that  should  redefine  the  necessary  virtual methods  to  maintain  the
    selection condition.  The object  of this class  is also used  to retrieve
    selected objects after search.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        The algorithm of unbalanced binary tree of overlapped bounding boxes.

        Once the tree of boxes  of geometric objects is constructed, the algorithm
        is capable of fast geometric selection of objects.  The tree can be easily
        updated by adding to it a new object with bounding box.

        The time of adding to the tree  of one object is O(log(N)), where N is the
        total number of  objects, so the time  of building a tree of  N objects is
        O(N(log(N)). The search time of one object is O(log(N)).

        Defining  various classes  inheriting NCollection_UBTree::Selector  we can
        perform various kinds of selection over the same b-tree object

        The object  may be of any  type allowing copying. Among  the best suitable
        solutions there can  be a pointer to an object,  handled object or integer
        index of object inside some  collection.  The bounding object may have any
        dimension  and  geometry. The  minimal  interface  of TheBndType  (besides
        public empty and copy constructor and operator =) used in UBTree algorithm
        is as the following:
        @code
        class MyBndType
        {
        public:
        inline void                   Add (const MyBndType& other);
        // Updates me with other bounding

        inline Standard_Boolean       IsOut (const MyBndType& other) const;
        // Classifies other bounding relatively me

        inline Standard_Real          SquareExtent() const;
        // Computes the squared maximal linear extent of me.
        // (For box it is the squared diagonal of box)
        };
        @endcode
        To select objects you need to define a class derived from UBTree::Selector
        that  should  redefine  the  necessary  virtual methods  to  maintain  the
        selection condition.  The object  of this class  is also used  to retrieve
        selected objects after search.
        """
        this = _ShapeAnalysis.new_NCollection_UBTree_Standard_Integer_Bnd_Box(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args):
        """
        Add(NCollection_UBTree_Standard_Integer_Bnd_Box self, int const & theObj, Bnd_Box theBnd) -> Standard_Boolean

        Update the tree with a new object and its bounding box.
        @param theObj
        added object
        @param theBnd
        bounding box of the object.
        @return
        always True

        :type theObj: const TheObjType &
        :type theBnd: const TheBndType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.NCollection_UBTree_Standard_Integer_Bnd_Box_Add(self, *args)


    def Select(self, *args):
        """
        Select(NCollection_UBTree_Standard_Integer_Bnd_Box self, NCollection_UBTree< Standard_Integer,Bnd_Box >::Selector & theSelector) -> Standard_Integer

        Searches in the branch all objects conforming to the given selector.
        @return
        the number of objects accepted

        :type theBranch: OCC.wrapper.NCollection.TreeNode
        :type theSelector: OCC.wrapper.NCollection.Selector
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.NCollection_UBTree_Standard_Integer_Bnd_Box_Select(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_UBTree_Standard_Integer_Bnd_Box self, Handle_NCollection_BaseAllocator aNewAlloc=0)

        Clears the contents of the tree.
        @param aNewAlloc
        Optional:   a new allocator that will be used when the tree is rebuilt
        anew. This makes sense if the memory allocator needs re-initialisation
        (like NCollection_IncAllocator).  By default the previous allocator is
        kept.

        :type aNewAlloc: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _ShapeAnalysis.NCollection_UBTree_Standard_Integer_Bnd_Box_Clear(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_UBTree_Standard_Integer_Bnd_Box self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.NCollection_UBTree_Standard_Integer_Bnd_Box_IsEmpty(self, *args)


    def Root(self, *args):
        """
        @return
        the root node of the tree

        :rtype: OCC.wrapper.NCollection.TreeNode

        """
        res = _ShapeAnalysis.NCollection_UBTree_Standard_Integer_Bnd_Box_Root(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Allocator(self, *args):
        """
        Recommended to be used only in sub-classes.
        @return
        Allocator object used in this instance of UBTree.

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        res = _ShapeAnalysis.NCollection_UBTree_Standard_Integer_Bnd_Box_Allocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeAnalysis.delete_NCollection_UBTree_Standard_Integer_Bnd_Box
NCollection_UBTree_Standard_Integer_Bnd_Box_swigregister = _ShapeAnalysis.NCollection_UBTree_Standard_Integer_Bnd_Box_swigregister
NCollection_UBTree_Standard_Integer_Bnd_Box_swigregister(NCollection_UBTree_Standard_Integer_Bnd_Box)


try:
	ShapeAnalysis_BoxBndTree = NCollection_UBTree_Standard_Integer_Bnd_Box
except NameError:
	pass # does not exist, probably ignored

class ShapeAnalysis_Edge(object):
    """
    Tool for analyzing the edge.
    Queries geometrical representations of the edge (3d curve, pcurve
    on the given face or surface) and topological sub-shapes (bounding
    vertices).
    Provides methods for analyzing geometry and topology consistency
    (3d and pcurve(s) consistency, their adjacency to the vertices).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeAnalysis_Edge self) -> ShapeAnalysis_Edge

        Empty constructor; initialises Status to OK


        """
        this = _ShapeAnalysis.new_ShapeAnalysis_Edge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def HasCurve3d(self, *args):
        """
        HasCurve3d(ShapeAnalysis_Edge self, TopoDS_Edge edge) -> Standard_Boolean

        Tells if the edge has a 3d curve

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_HasCurve3d(self, *args)


    def Curve3d(self, *args):
        """
        Curve3d(ShapeAnalysis_Edge self, TopoDS_Edge edge, Handle_Geom_Curve C3d, Standard_Boolean const orient) -> Standard_Boolean

        Returns the 3d curve and bounding parameteres for the edge
        Returns False if no 3d curve.
        If <orient> is True (default), takes orientation into account:
        if the edge is reversed, cf and cl are toggled

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C3d: OCC.wrapper.Geom.Handle_Geom_Curve
        :type cf: float
        :type cl: float
        :type orient: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_Curve3d(self, *args)


    def IsClosed3d(self, *args):
        """
        IsClosed3d(ShapeAnalysis_Edge self, TopoDS_Edge edge) -> Standard_Boolean

        Gives True if the edge has a 3d curve, this curve is closed,
        and the edge has the same vertex at start and end

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_IsClosed3d(self, *args)


    def HasPCurve(self, *args):
        """
        HasPCurve(ShapeAnalysis_Edge self, TopoDS_Edge edge, TopoDS_Face face) -> Standard_Boolean
        HasPCurve(ShapeAnalysis_Edge self, TopoDS_Edge edge, Handle_Geom_Surface surface, TopLoc_Location location) -> Standard_Boolean

        Tells if the edge has a pcurve on the surface (with location).

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type surface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type location: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_HasPCurve(self, *args)


    def PCurve(self, *args):
        """
        PCurve(ShapeAnalysis_Edge self, TopoDS_Edge edge, TopoDS_Face face, Handle_Geom2d_Curve C2d, Standard_Boolean const orient) -> Standard_Boolean
        PCurve(ShapeAnalysis_Edge self, TopoDS_Edge edge, Handle_Geom_Surface surface, TopLoc_Location location, Handle_Geom2d_Curve C2d, Standard_Boolean const orient) -> Standard_Boolean

        Returns the pcurve and bounding parameteres for the edge
        lying on the surface.
        Returns False if the edge has no pcurve on this surface.
        If <orient> is True (default), takes orientation into account:
        if the edge is reversed, cf and cl are toggled

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type surface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type location: OCC.wrapper.TopLoc.TopLoc_Location
        :type C2d: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type cf: float
        :type cl: float
        :type orient: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_PCurve(self, *args)


    def BoundUV(self, *args):
        """
        BoundUV(ShapeAnalysis_Edge self, TopoDS_Edge edge, TopoDS_Face face, gp_Pnt2d first, gp_Pnt2d last) -> Standard_Boolean
        BoundUV(ShapeAnalysis_Edge self, TopoDS_Edge edge, Handle_Geom_Surface surface, TopLoc_Location location, gp_Pnt2d first, gp_Pnt2d last) -> Standard_Boolean

        Returns the ends of pcurve
        Calls method PCurve with <orient> equal to True

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type surface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type location: OCC.wrapper.TopLoc.TopLoc_Location
        :type first: OCC.wrapper.gp.gp_Pnt2d
        :type last: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_BoundUV(self, *args)


    def IsSeam(self, *args):
        """
        IsSeam(ShapeAnalysis_Edge self, TopoDS_Edge edge, TopoDS_Face face) -> Standard_Boolean
        IsSeam(ShapeAnalysis_Edge self, TopoDS_Edge edge, Handle_Geom_Surface surface, TopLoc_Location location) -> Standard_Boolean

        Returns True if the edge has two pcurves on one surface

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type surface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type location: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_IsSeam(self, *args)


    def FirstVertex(self, *args):
        """
        FirstVertex(ShapeAnalysis_Edge self, TopoDS_Edge edge) -> TopoDS_Vertex

        Returns start vertex of the edge (taking edge orientation
        into account).

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_FirstVertex(self, *args)


    def LastVertex(self, *args):
        """
        LastVertex(ShapeAnalysis_Edge self, TopoDS_Edge edge) -> TopoDS_Vertex

        Returns end vertex of the edge (taking edge orientation
        into account).

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_LastVertex(self, *args)


    def GetEndTangent2d(self, *args):
        """
        GetEndTangent2d(ShapeAnalysis_Edge self, TopoDS_Edge edge, TopoDS_Face face, Standard_Boolean const atEnd, gp_Pnt2d pos, gp_Vec2d tang, Standard_Real const dparam=0.0) -> Standard_Boolean
        GetEndTangent2d(ShapeAnalysis_Edge self, TopoDS_Edge edge, Handle_Geom_Surface surface, TopLoc_Location location, Standard_Boolean const atEnd, gp_Pnt2d pos, gp_Vec2d tang, Standard_Real const dparam=0.0) -> Standard_Boolean

        Returns tangent of the edge pcurve at its start (if atEnd is
        False) or end (if True), regarding the orientation of edge.
        If edge is REVERSED, tangent is reversed before return.
        Returns True if pcurve is available and tangent is computed
        and is not null, else False.

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type surface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type location: OCC.wrapper.TopLoc.TopLoc_Location
        :type atEnd: bool
        :type pos: OCC.wrapper.gp.gp_Pnt2d
        :type tang: OCC.wrapper.gp.gp_Vec2d
        :type dparam: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_GetEndTangent2d(self, *args)


    def CheckVerticesWithCurve3d(self, *args):
        """
        CheckVerticesWithCurve3d(ShapeAnalysis_Edge self, TopoDS_Edge edge, Standard_Real const preci=-1, Standard_Integer const vtx=0) -> Standard_Boolean

        Checks the start and/or end vertex of the edge for matching
        with 3d curve with the given precision.
        <vtx> = 1 : start vertex only
        <vtx> = 2 : end vertex only
        <vtx> = 0 : both (default)
        If preci < 0 the vertices are considered with their own
        tolerances, else with the given <preci>.

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type preci: float
        :type vtx: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_CheckVerticesWithCurve3d(self, *args)


    def CheckVerticesWithPCurve(self, *args):
        """
        CheckVerticesWithPCurve(ShapeAnalysis_Edge self, TopoDS_Edge edge, TopoDS_Face face, Standard_Real const preci=-1, Standard_Integer const vtx=0) -> Standard_Boolean
        CheckVerticesWithPCurve(ShapeAnalysis_Edge self, TopoDS_Edge edge, Handle_Geom_Surface surface, TopLoc_Location location, Standard_Real const preci=-1, Standard_Integer const vtx=0) -> Standard_Boolean

        Checks the start and/or end vertex of the edge for matching
        with pcurve with the given precision.
        <vtx> = 1 : start vertex
        <vtx> = 2 : end vertex
        <vtx> = 0 : both
        If preci < 0 the vertices are considered with their own
        tolerances, else with the given <preci>.

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type surface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type location: OCC.wrapper.TopLoc.TopLoc_Location
        :type preci: float
        :type vtx: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_CheckVerticesWithPCurve(self, *args)


    def CheckVertexTolerance(self, *args):
        """
        CheckVertexTolerance(ShapeAnalysis_Edge self, TopoDS_Edge edge, TopoDS_Face face) -> Standard_Boolean
        CheckVertexTolerance(ShapeAnalysis_Edge self, TopoDS_Edge edge) -> Standard_Boolean

        Checks if it is necessary to increase tolerances of the edge
        vertices to comprise the ends of 3d curve and pcurve on
        the given face (first method) or all pcurves stored in an edge
        (second one)
        toler1 returns necessary tolerance for first vertex,
        toler2 returns necessary tolerance for last vertex.

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type toler1: float
        :type toler2: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_CheckVertexTolerance(self, *args)


    def CheckCurve3dWithPCurve(self, *args):
        """
        CheckCurve3dWithPCurve(ShapeAnalysis_Edge self, TopoDS_Edge edge, TopoDS_Face face) -> Standard_Boolean
        CheckCurve3dWithPCurve(ShapeAnalysis_Edge self, TopoDS_Edge edge, Handle_Geom_Surface surface, TopLoc_Location location) -> Standard_Boolean

        Checks mutual orientation of 3d curve and pcurve on the
        analysis of curves bounding points

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type surface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type location: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_CheckCurve3dWithPCurve(self, *args)


    def Status(self, *args):
        """
        Status(ShapeAnalysis_Edge self, ShapeExtend_Status const status) -> Standard_Boolean

        Returns the status (in the form of True/False) of last Check

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_Status(self, *args)


    def CheckSameParameter(self, *args):
        """
        CheckSameParameter(ShapeAnalysis_Edge self, TopoDS_Edge edge, Standard_Integer const NbControl=23) -> Standard_Boolean
        CheckSameParameter(ShapeAnalysis_Edge self, TopoDS_Edge theEdge, TopoDS_Face theFace, Standard_Integer const theNbControl=23) -> Standard_Boolean

        Checks the edge to be SameParameter.
        Calculates the maximal deviation between 3d curve and each
        pcurve of the edge on <NbControl> equidistant points (the same
        algorithm as in BRepCheck; default value is 23 as in BRepCheck).
        This deviation is returned in <maxdev> parameter.
        If deviation is greater than tolerance of the edge (i.e.
        incorrect flag) returns False, else returns True.

        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theMaxdev: float
        :type theNbControl: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_CheckSameParameter(self, *args)


    def CheckPCurveRange(self, *args):
        """
        CheckPCurveRange(ShapeAnalysis_Edge self, Standard_Real const theFirst, Standard_Real const theLast, Handle_Geom2d_Curve thePC) -> Standard_Boolean

        Checks possibility for pcurve thePC to have range [theFirst, theLast] (edge range)
        having respect to real first, last parameters of thePC 

        :type theFirst: float
        :type theLast: float
        :type thePC: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_CheckPCurveRange(self, *args)


    def ComputeDeviation(*args):
        """
        ComputeDeviation(Adaptor3d_Curve CRef, Adaptor3d_Curve Other, Standard_Boolean const SameParameter, Standard_Integer const NCONTROL) -> Standard_Boolean

        Computes the maximal deviation between the two curve
        representations.
        dev is an input/output parameter and contains the computed
        deviation (should be initialized with 0. for the first call).
        Used by CheckSameParameter().

        :type CRef: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type Other: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type SameParameter: bool
        :type dev: float
        :type NCONTROL: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_ComputeDeviation(*args)

    ComputeDeviation = staticmethod(ComputeDeviation)

    def CheckOverlapping(self, *args):
        """
        CheckOverlapping(ShapeAnalysis_Edge self, TopoDS_Edge theEdge1, TopoDS_Edge theEdge2, Standard_Real const theDomainDist=0.0) -> Standard_Boolean

        Checks the first edge is overlapped with second edge.
        If distance between two edges is less then theTolOverlap
        edges is overlapped.
        theDomainDis - length of part of edges on wich edges is overlapped.

        :type theEdge1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theEdge2: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theTolOverlap: float
        :type theDomainDist: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Edge_CheckOverlapping(self, *args)

    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_Edge
ShapeAnalysis_Edge_swigregister = _ShapeAnalysis.ShapeAnalysis_Edge_swigregister
ShapeAnalysis_Edge_swigregister(ShapeAnalysis_Edge)

def ShapeAnalysis_Edge_ComputeDeviation(*args):
    """
    ShapeAnalysis_Edge_ComputeDeviation(Adaptor3d_Curve CRef, Adaptor3d_Curve Other, Standard_Boolean const SameParameter, Standard_Integer const NCONTROL) -> Standard_Boolean

    Computes the maximal deviation between the two curve
    representations.
    dev is an input/output parameter and contains the computed
    deviation (should be initialized with 0. for the first call).
    Used by CheckSameParameter().

    :type CRef: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type Other: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type SameParameter: bool
    :type dev: float
    :type NCONTROL: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _ShapeAnalysis.ShapeAnalysis_Edge_ComputeDeviation(*args)

class Handle_ShapeAnalysis_TransferParametersProj(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeAnalysis_TransferParametersProj self)

        Nullify the handle


        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeAnalysis_TransferParametersProj self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeAnalysis_TransferParametersProj self, ShapeAnalysis_TransferParametersProj thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeAnalysis_TransferParametersProj self, Handle_ShapeAnalysis_TransferParametersProj theHandle) -> Handle_ShapeAnalysis_TransferParametersProj
        assign(Handle_ShapeAnalysis_TransferParametersProj self, ShapeAnalysis_TransferParametersProj thePtr) -> Handle_ShapeAnalysis_TransferParametersProj
        assign(Handle_ShapeAnalysis_TransferParametersProj self, Handle_ShapeAnalysis_TransferParametersProj theHandle) -> Handle_ShapeAnalysis_TransferParametersProj

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeAnalysis_TransferParametersProj self) -> ShapeAnalysis_TransferParametersProj

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeAnalysis_TransferParametersProj self) -> ShapeAnalysis_TransferParametersProj

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeAnalysis_TransferParametersProj self) -> ShapeAnalysis_TransferParametersProj

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj___ref__(self, *args)


    def __hash__(self):
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeAnalysis.new_Handle_ShapeAnalysis_TransferParametersProj(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_DownCast)
    __swig_destroy__ = _ShapeAnalysis.delete_Handle_ShapeAnalysis_TransferParametersProj

    def Init(self, *args):
        """
        Init(Handle_ShapeAnalysis_TransferParametersProj self, TopoDS_Edge E, TopoDS_Face F)

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_ShapeAnalysis_TransferParametersProj self, Handle_TColStd_HSequenceOfReal Papams, Standard_Boolean const To2d) -> Handle_TColStd_HSequenceOfReal
        Perform(Handle_ShapeAnalysis_TransferParametersProj self, Standard_Real const Param, Standard_Boolean const To2d) -> Standard_Real

        Transfers parameter given by  Param from 3d curve
        to pcurve (if To2d is True) or back (if To2d is False)

        :type Param: float
        :type To2d: bool
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_Perform(self, *args)


    def ForceProjection(self, *args):
        """
        ForceProjection(Handle_ShapeAnalysis_TransferParametersProj self) -> Standard_Boolean &

        Returns modifiable flag forcing projection
        If it is False (default), projection is done only
        if edge is not SameParameter or if tolerance of edge
        is greater than MaxTolerance()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_ForceProjection(self, *args)


    def TransferRange(self, *args):
        """
        TransferRange(Handle_ShapeAnalysis_TransferParametersProj self, TopoDS_Edge newEdge, Standard_Real const prevPar, Standard_Real const currPar, Standard_Boolean const Is2d)

        Recomputes range of curves from NewEdge.
        If Is2d equals True parameters are recomputed by curve2d else by curve3d.

        :type newEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type prevPar: float
        :type currPar: float
        :type Is2d: bool

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_TransferRange(self, *args)


    def IsSameRange(self, *args):
        """
        IsSameRange(Handle_ShapeAnalysis_TransferParametersProj self) -> Standard_Boolean

        Returns False;

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_IsSameRange(self, *args)


    def CopyNMVertex(self, *args):
        """
        CopyNMVertex(Handle_ShapeAnalysis_TransferParametersProj self, TopoDS_Vertex theVert, TopoDS_Edge toedge, TopoDS_Edge fromedge) -> TopoDS_Vertex
        CopyNMVertex(Handle_ShapeAnalysis_TransferParametersProj self, TopoDS_Vertex theVert, TopoDS_Face toFace, TopoDS_Face fromFace) -> TopoDS_Vertex

        Make a copy of non-manifold vertex theVert
        (i.e. create new  TVertex and replace PointRepresentations for this vertex
        from fromFace to toFace. Other representations were copied)

        :type theVert: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type toFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type fromFace: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_CopyNMVertex(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeAnalysis_TransferParametersProj self) -> char const *

        :rtype: const char *

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(Handle_ShapeAnalysis_TransferParametersProj self, Standard_Real const maxtol)

        Sets maximal tolerance to use linear recomputation of
        parameters.

        :type maxtol: float

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_SetMaxTolerance(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeAnalysis_TransferParametersProj self)

        Memory deallocator for transient classes


        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeAnalysis_TransferParametersProj self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeAnalysis_TransferParametersProj self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeAnalysis_TransferParametersProj self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeAnalysis_TransferParametersProj self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeAnalysis_TransferParametersProj self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeAnalysis_TransferParametersProj self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeAnalysis_TransferParametersProj self)

        Increments the reference counter of this object


        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeAnalysis_TransferParametersProj self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_DecrementRefCounter(self, *args)

Handle_ShapeAnalysis_TransferParametersProj_swigregister = _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_swigregister
Handle_ShapeAnalysis_TransferParametersProj_swigregister(Handle_ShapeAnalysis_TransferParametersProj)

def Handle_ShapeAnalysis_TransferParametersProj_DownCast(thing):
    return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_DownCast(thing)
Handle_ShapeAnalysis_TransferParametersProj_DownCast = _ShapeAnalysis.Handle_ShapeAnalysis_TransferParametersProj_DownCast

class ShapeAnalysis_FreeBoundsProperties(object):
    """
    This class is intended to calculate shape free bounds
    properties.
    This class provides the following functionalities:
    - calculates area of the contour,
    - calculates perimeter of the contour,
    - calculates ratio of average length to average width of the
    contour,
    - estimates average width of contour,
    - finds the notches (narrow 'V'-like sub-contour) on the
    contour.

    For getting free bounds this class uses
    ShapeAnalysis_FreeBounds class.

    For description of parameters used for initializing this
    class refer to CDL of ShapeAnalysis_FreeBounds.

    Properties of each contour are stored in the data structure
    ShapeAnalysis_FreeBoundData.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeAnalysis_FreeBoundsProperties self) -> ShapeAnalysis_FreeBoundsProperties
        __init__(ShapeAnalysis_FreeBoundsProperties self, TopoDS_Shape shape, Standard_Real const tolerance, Standard_Boolean const splitclosed, Standard_Boolean const splitopen) -> ShapeAnalysis_FreeBoundsProperties
        __init__(ShapeAnalysis_FreeBoundsProperties self, TopoDS_Shape shape, Standard_Boolean const splitclosed, Standard_Boolean const splitopen) -> ShapeAnalysis_FreeBoundsProperties

        Creates the object and calls corresponding Init.
        <shape> should be a compound of shells.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type splitclosed: bool
        :type splitopen: bool

        """
        this = _ShapeAnalysis.new_ShapeAnalysis_FreeBoundsProperties(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(ShapeAnalysis_FreeBoundsProperties self, TopoDS_Shape shape, Standard_Real const tolerance, Standard_Boolean const splitclosed, Standard_Boolean const splitopen)
        Init(ShapeAnalysis_FreeBoundsProperties self, TopoDS_Shape shape, Standard_Boolean const splitclosed, Standard_Boolean const splitopen)

        Initializes the object with given parameters.
        <shape> should be a compound of shells.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type splitclosed: bool
        :type splitopen: bool

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(ShapeAnalysis_FreeBoundsProperties self) -> Standard_Boolean

        Builds and analyzes free bounds of the shape.
        First calls ShapeAnalysis_FreeBounds for building free
        bounds.
        Then on each free bound computes its properties:
        - area of the contour,
        - perimeter of the contour,
        - ratio of average length to average width of the contour,
        - average width of contour,
        - notches on the contour and for each notch
        - maximum width of the notch.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_Perform(self, *args)


    def IsLoaded(self, *args):
        """
        IsLoaded(ShapeAnalysis_FreeBoundsProperties self) -> Standard_Boolean

        Returns True if shape is loaded

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_IsLoaded(self, *args)


    def Shape(self, *args):
        """
        Shape(ShapeAnalysis_FreeBoundsProperties self) -> TopoDS_Shape

        Returns shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_Shape(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(ShapeAnalysis_FreeBoundsProperties self) -> Standard_Real

        Returns tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_Tolerance(self, *args)


    def NbFreeBounds(self, *args):
        """
        NbFreeBounds(ShapeAnalysis_FreeBoundsProperties self) -> Standard_Integer

        Returns number of free bounds

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_NbFreeBounds(self, *args)


    def NbClosedFreeBounds(self, *args):
        """
        NbClosedFreeBounds(ShapeAnalysis_FreeBoundsProperties self) -> Standard_Integer

        Returns number of closed free bounds

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_NbClosedFreeBounds(self, *args)


    def NbOpenFreeBounds(self, *args):
        """
        NbOpenFreeBounds(ShapeAnalysis_FreeBoundsProperties self) -> Standard_Integer

        Returns number of open free bounds

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_NbOpenFreeBounds(self, *args)


    def ClosedFreeBounds(self, *args):
        """
        ClosedFreeBounds(ShapeAnalysis_FreeBoundsProperties self) -> Handle_ShapeAnalysis_HSequenceOfFreeBounds

        Returns all closed free bounds

        :rtype: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_ClosedFreeBounds(self, *args)


    def OpenFreeBounds(self, *args):
        """
        OpenFreeBounds(ShapeAnalysis_FreeBoundsProperties self) -> Handle_ShapeAnalysis_HSequenceOfFreeBounds

        Returns all open free bounds

        :rtype: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_HSequenceOfFreeBounds

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_OpenFreeBounds(self, *args)


    def ClosedFreeBound(self, *args):
        """
        ClosedFreeBound(ShapeAnalysis_FreeBoundsProperties self, Standard_Integer const index) -> Handle_ShapeAnalysis_FreeBoundData

        Returns properties of closed free bound specified by its rank
        number

        :type index: int
        :rtype: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_ClosedFreeBound(self, *args)


    def OpenFreeBound(self, *args):
        """
        OpenFreeBound(ShapeAnalysis_FreeBoundsProperties self, Standard_Integer const index) -> Handle_ShapeAnalysis_FreeBoundData

        Returns properties of open free bound specified by its rank
        number

        :type index: int
        :rtype: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_OpenFreeBound(self, *args)


    def DispatchBounds(self, *args):
        """
        DispatchBounds(ShapeAnalysis_FreeBoundsProperties self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_DispatchBounds(self, *args)


    def CheckContours(self, *args):
        """
        CheckContours(ShapeAnalysis_FreeBoundsProperties self, Standard_Real const prec=0.0) -> Standard_Boolean

        :type prec: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_CheckContours(self, *args)


    def CheckNotches(self, *args):
        """
        CheckNotches(ShapeAnalysis_FreeBoundsProperties self, Standard_Real const prec=0.0) -> Standard_Boolean
        CheckNotches(ShapeAnalysis_FreeBoundsProperties self, Handle_ShapeAnalysis_FreeBoundData fbData, Standard_Real const prec=0.0) -> Standard_Boolean
        CheckNotches(ShapeAnalysis_FreeBoundsProperties self, TopoDS_Wire freebound, Standard_Integer const num, TopoDS_Wire notch, Standard_Real const prec=0.0) -> Standard_Boolean

        :type freebound: OCC.wrapper.TopoDS.TopoDS_Wire
        :type num: int
        :type notch: OCC.wrapper.TopoDS.TopoDS_Wire
        :type distMax: float
        :type prec: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_CheckNotches(self, *args)


    def FillProperties(self, *args):
        """
        FillProperties(ShapeAnalysis_FreeBoundsProperties self, Handle_ShapeAnalysis_FreeBoundData fbData, Standard_Real const prec=0.0) -> Standard_Boolean

        :type fbData: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData
        :type prec: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_FillProperties(self, *args)

    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_FreeBoundsProperties
ShapeAnalysis_FreeBoundsProperties_swigregister = _ShapeAnalysis.ShapeAnalysis_FreeBoundsProperties_swigregister
ShapeAnalysis_FreeBoundsProperties_swigregister(ShapeAnalysis_FreeBoundsProperties)

class Handle_ShapeAnalysis_TransferParameters(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeAnalysis_TransferParameters self)

        Nullify the handle


        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeAnalysis_TransferParameters self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeAnalysis_TransferParameters self, ShapeAnalysis_TransferParameters thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeAnalysis_TransferParameters self, Handle_ShapeAnalysis_TransferParameters theHandle) -> Handle_ShapeAnalysis_TransferParameters
        assign(Handle_ShapeAnalysis_TransferParameters self, ShapeAnalysis_TransferParameters thePtr) -> Handle_ShapeAnalysis_TransferParameters
        assign(Handle_ShapeAnalysis_TransferParameters self, Handle_ShapeAnalysis_TransferParameters theHandle) -> Handle_ShapeAnalysis_TransferParameters

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeAnalysis_TransferParameters self) -> ShapeAnalysis_TransferParameters

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeAnalysis_TransferParameters self) -> ShapeAnalysis_TransferParameters

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeAnalysis_TransferParameters self) -> ShapeAnalysis_TransferParameters

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters___ref__(self, *args)


    def __hash__(self):
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeAnalysis.new_Handle_ShapeAnalysis_TransferParameters(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_DownCast)
    __swig_destroy__ = _ShapeAnalysis.delete_Handle_ShapeAnalysis_TransferParameters

    def Init(self, *args):
        """
        Init(Handle_ShapeAnalysis_TransferParameters self, TopoDS_Edge E, TopoDS_Face F)

        Initialize a tool with edge and face

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_Init(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(Handle_ShapeAnalysis_TransferParameters self, Standard_Real const maxtol)

        Sets maximal tolerance to use linear recomputation of
        parameters.

        :type maxtol: float

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_SetMaxTolerance(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_ShapeAnalysis_TransferParameters self, Handle_TColStd_HSequenceOfReal Params, Standard_Boolean const To2d) -> Handle_TColStd_HSequenceOfReal
        Perform(Handle_ShapeAnalysis_TransferParameters self, Standard_Real const Param, Standard_Boolean const To2d) -> Standard_Real

        Transfers parameter given by sequence Params from 3d curve
        to pcurve (if To2d is True) or back (if To2d is False)

        :type Param: float
        :type To2d: bool
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_Perform(self, *args)


    def TransferRange(self, *args):
        """
        TransferRange(Handle_ShapeAnalysis_TransferParameters self, TopoDS_Edge newEdge, Standard_Real const prevPar, Standard_Real const currPar, Standard_Boolean const To2d)

        Recomputes range of curves from NewEdge.
        If Is2d equals True parameters are recomputed by curve2d else by curve3d.

        :type newEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type prevPar: float
        :type currPar: float
        :type To2d: bool

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_TransferRange(self, *args)


    def IsSameRange(self, *args):
        """
        IsSameRange(Handle_ShapeAnalysis_TransferParameters self) -> Standard_Boolean

        Returns True if 3d curve of edge and pcurve are SameRange
        (in default implementation, if myScale == 1 and myShift == 0)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_IsSameRange(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeAnalysis_TransferParameters self) -> char const *

        :rtype: const char *

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ShapeAnalysis_TransferParameters self)

        Memory deallocator for transient classes


        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeAnalysis_TransferParameters self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeAnalysis_TransferParameters self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeAnalysis_TransferParameters self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeAnalysis_TransferParameters self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeAnalysis_TransferParameters self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeAnalysis_TransferParameters self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeAnalysis_TransferParameters self)

        Increments the reference counter of this object


        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeAnalysis_TransferParameters self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_DecrementRefCounter(self, *args)

Handle_ShapeAnalysis_TransferParameters_swigregister = _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_swigregister
Handle_ShapeAnalysis_TransferParameters_swigregister(Handle_ShapeAnalysis_TransferParameters)

def Handle_ShapeAnalysis_TransferParameters_DownCast(thing):
    return _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_DownCast(thing)
Handle_ShapeAnalysis_TransferParameters_DownCast = _ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters_DownCast

class ShapeAnalysis_ShapeContents(object):
    """Dumps shape contents"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeAnalysis_ShapeContents self) -> ShapeAnalysis_ShapeContents

        Initialize fields and call ClearFlags()


        """
        this = _ShapeAnalysis.new_ShapeAnalysis_ShapeContents(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self, *args):
        """
        Clear(ShapeAnalysis_ShapeContents self)

        Clears all accumulated statictics


        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_Clear(self, *args)


    def ClearFlags(self, *args):
        """
        ClearFlags(ShapeAnalysis_ShapeContents self)

        Clears all flags


        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_ClearFlags(self, *args)


    def Perform(self, *args):
        """
        Perform(ShapeAnalysis_ShapeContents self, TopoDS_Shape shape)

        Counts quantities of sun-shapes in shape and
        stores sub-shapes according to flags

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_Perform(self, *args)


    def ModifyBigSplineMode(self, *args):
        """
        ModifyBigSplineMode(ShapeAnalysis_ShapeContents self) -> Standard_Boolean &

        Returns (modifiable) the flag which defines whether to store faces
        with edges if its 3D curves has more than 8192 poles.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_ModifyBigSplineMode(self, *args)


    def ModifyIndirectMode(self, *args):
        """
        ModifyIndirectMode(ShapeAnalysis_ShapeContents self) -> Standard_Boolean &

        Returns (modifiable) the flag which defines whether to store faces
        on indirect surfaces

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_ModifyIndirectMode(self, *args)


    def ModifyOffestSurfaceMode(self, *args):
        """
        ModifyOffestSurfaceMode(ShapeAnalysis_ShapeContents self) -> Standard_Boolean &

        Returns (modifiable) the flag which defines whether to store faces
        on offset surfaces.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_ModifyOffestSurfaceMode(self, *args)


    def ModifyTrimmed3dMode(self, *args):
        """
        ModifyTrimmed3dMode(ShapeAnalysis_ShapeContents self) -> Standard_Boolean &

        Returns (modifiable) the flag which defines whether to store faces
        with edges if ist 3D curves are trimmed curves

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_ModifyTrimmed3dMode(self, *args)


    def ModifyOffsetCurveMode(self, *args):
        """
        ModifyOffsetCurveMode(ShapeAnalysis_ShapeContents self) -> Standard_Boolean &

        Returns (modifiable) the flag which defines whether to store faces
        with edges if its 3D curves and pcurves are offest curves

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_ModifyOffsetCurveMode(self, *args)


    def ModifyTrimmed2dMode(self, *args):
        """
        ModifyTrimmed2dMode(ShapeAnalysis_ShapeContents self) -> Standard_Boolean &

        Returns (modifiable) the flag which defines whether to store faces
        with edges if its  pcurves are trimmed curves

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_ModifyTrimmed2dMode(self, *args)


    def NbSolids(self, *args):
        """
        NbSolids(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSolids(self, *args)


    def NbShells(self, *args):
        """
        NbShells(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbShells(self, *args)


    def NbFaces(self, *args):
        """
        NbFaces(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbFaces(self, *args)


    def NbWires(self, *args):
        """
        NbWires(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbWires(self, *args)


    def NbEdges(self, *args):
        """
        NbEdges(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbEdges(self, *args)


    def NbVertices(self, *args):
        """
        NbVertices(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbVertices(self, *args)


    def NbSolidsWithVoids(self, *args):
        """
        NbSolidsWithVoids(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSolidsWithVoids(self, *args)


    def NbBigSplines(self, *args):
        """
        NbBigSplines(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbBigSplines(self, *args)


    def NbC0Surfaces(self, *args):
        """
        NbC0Surfaces(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbC0Surfaces(self, *args)


    def NbC0Curves(self, *args):
        """
        NbC0Curves(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbC0Curves(self, *args)


    def NbOffsetSurf(self, *args):
        """
        NbOffsetSurf(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbOffsetSurf(self, *args)


    def NbIndirectSurf(self, *args):
        """
        NbIndirectSurf(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbIndirectSurf(self, *args)


    def NbOffsetCurves(self, *args):
        """
        NbOffsetCurves(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbOffsetCurves(self, *args)


    def NbTrimmedCurve2d(self, *args):
        """
        NbTrimmedCurve2d(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbTrimmedCurve2d(self, *args)


    def NbTrimmedCurve3d(self, *args):
        """
        NbTrimmedCurve3d(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbTrimmedCurve3d(self, *args)


    def NbBSplibeSurf(self, *args):
        """
        NbBSplibeSurf(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbBSplibeSurf(self, *args)


    def NbBezierSurf(self, *args):
        """
        NbBezierSurf(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbBezierSurf(self, *args)


    def NbTrimSurf(self, *args):
        """
        NbTrimSurf(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbTrimSurf(self, *args)


    def NbWireWitnSeam(self, *args):
        """
        NbWireWitnSeam(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbWireWitnSeam(self, *args)


    def NbWireWithSevSeams(self, *args):
        """
        NbWireWithSevSeams(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbWireWithSevSeams(self, *args)


    def NbFaceWithSevWires(self, *args):
        """
        NbFaceWithSevWires(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbFaceWithSevWires(self, *args)


    def NbNoPCurve(self, *args):
        """
        NbNoPCurve(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbNoPCurve(self, *args)


    def NbFreeFaces(self, *args):
        """
        NbFreeFaces(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbFreeFaces(self, *args)


    def NbFreeWires(self, *args):
        """
        NbFreeWires(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbFreeWires(self, *args)


    def NbFreeEdges(self, *args):
        """
        NbFreeEdges(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbFreeEdges(self, *args)


    def NbSharedSolids(self, *args):
        """
        NbSharedSolids(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSharedSolids(self, *args)


    def NbSharedShells(self, *args):
        """
        NbSharedShells(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSharedShells(self, *args)


    def NbSharedFaces(self, *args):
        """
        NbSharedFaces(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSharedFaces(self, *args)


    def NbSharedWires(self, *args):
        """
        NbSharedWires(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSharedWires(self, *args)


    def NbSharedFreeWires(self, *args):
        """
        NbSharedFreeWires(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSharedFreeWires(self, *args)


    def NbSharedFreeEdges(self, *args):
        """
        NbSharedFreeEdges(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSharedFreeEdges(self, *args)


    def NbSharedEdges(self, *args):
        """
        NbSharedEdges(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSharedEdges(self, *args)


    def NbSharedVertices(self, *args):
        """
        NbSharedVertices(ShapeAnalysis_ShapeContents self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_NbSharedVertices(self, *args)


    def BigSplineSec(self, *args):
        """
        BigSplineSec(ShapeAnalysis_ShapeContents self) -> Handle_TopTools_HSequenceOfShape

        :rtype: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_BigSplineSec(self, *args)


    def IndirectSec(self, *args):
        """
        IndirectSec(ShapeAnalysis_ShapeContents self) -> Handle_TopTools_HSequenceOfShape

        :rtype: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_IndirectSec(self, *args)


    def OffsetSurfaceSec(self, *args):
        """
        OffsetSurfaceSec(ShapeAnalysis_ShapeContents self) -> Handle_TopTools_HSequenceOfShape

        :rtype: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_OffsetSurfaceSec(self, *args)


    def Trimmed3dSec(self, *args):
        """
        Trimmed3dSec(ShapeAnalysis_ShapeContents self) -> Handle_TopTools_HSequenceOfShape

        :rtype: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_Trimmed3dSec(self, *args)


    def OffsetCurveSec(self, *args):
        """
        OffsetCurveSec(ShapeAnalysis_ShapeContents self) -> Handle_TopTools_HSequenceOfShape

        :rtype: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_OffsetCurveSec(self, *args)


    def Trimmed2dSec(self, *args):
        """
        Trimmed2dSec(ShapeAnalysis_ShapeContents self) -> Handle_TopTools_HSequenceOfShape

        :rtype: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeContents_Trimmed2dSec(self, *args)

    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_ShapeContents
ShapeAnalysis_ShapeContents_swigregister = _ShapeAnalysis.ShapeAnalysis_ShapeContents_swigregister
ShapeAnalysis_ShapeContents_swigregister(ShapeAnalysis_ShapeContents)

class ShapeAnalysis_ShapeTolerance(object):
    """
    Tool for computing shape tolerances (minimal, maximal, average),
    finding shape with tolerance matching given criteria,
    setting or limitating tolerances.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeAnalysis_ShapeTolerance self) -> ShapeAnalysis_ShapeTolerance

        Empty constructor


        """
        this = _ShapeAnalysis.new_ShapeAnalysis_ShapeTolerance(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Tolerance(self, *args):
        """
        Tolerance(ShapeAnalysis_ShapeTolerance self, TopoDS_Shape shape, Standard_Integer const mode, TopAbs_ShapeEnum const type=TopAbs_SHAPE) -> Standard_Real

        Determines a tolerance from the ones stored in a shape
        Remark : calls InitTolerance and AddTolerance,
        hence, can be used to start a series for cumulating tolerance
        <mode> = 0 : returns the average value between sub-shapes,
        <mode> > 0 : returns the maximal found,
        <mode> < 0 : returns the minimal found.
        <type> defines what kinds of sub-shapes to consider:
        SHAPE (default) : all : VERTEX, EDGE, FACE,
        VERTEX : only vertices,
        EDGE   : only edges,
        FACE   : only faces,
        SHELL  : combined SHELL + FACE, for each face (and containing
        shell), also checks EDGE and VERTEX

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type mode: int
        :type type: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeTolerance_Tolerance(self, *args)


    def OverTolerance(self, *args):
        """
        OverTolerance(ShapeAnalysis_ShapeTolerance self, TopoDS_Shape shape, Standard_Real const value, TopAbs_ShapeEnum const type=TopAbs_SHAPE) -> Handle_TopTools_HSequenceOfShape

        Determines which shapes have a tolerance over the given value
        <type> is interpreted as in the method Tolerance

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type value: float
        :type type: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeTolerance_OverTolerance(self, *args)


    def InTolerance(self, *args):
        """
        InTolerance(ShapeAnalysis_ShapeTolerance self, TopoDS_Shape shape, Standard_Real const valmin, Standard_Real const valmax, TopAbs_ShapeEnum const type=TopAbs_SHAPE) -> Handle_TopTools_HSequenceOfShape

        Determines which shapes have a tolerance within a given interval
        <type> is interpreted as in the method Tolerance

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type valmin: float
        :type valmax: float
        :type type: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeTolerance_InTolerance(self, *args)


    def InitTolerance(self, *args):
        """
        InitTolerance(ShapeAnalysis_ShapeTolerance self)

        Initializes computation of cumulated tolerance


        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeTolerance_InitTolerance(self, *args)


    def AddTolerance(self, *args):
        """
        AddTolerance(ShapeAnalysis_ShapeTolerance self, TopoDS_Shape shape, TopAbs_ShapeEnum const type=TopAbs_SHAPE)

        Adds data on new Shape to compute Cumulated Tolerance
        (prepares three computations : maximal, average, minimal)

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type type: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeTolerance_AddTolerance(self, *args)


    def GlobalTolerance(self, *args):
        """
        GlobalTolerance(ShapeAnalysis_ShapeTolerance self, Standard_Integer const mode) -> Standard_Real

        Returns the computed tolerance according to the <mode>
        <mode> = 0 : average
        <mode> > 0 : maximal
        <mode> < 0 : minimal

        :type mode: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_ShapeTolerance_GlobalTolerance(self, *args)

    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_ShapeTolerance
ShapeAnalysis_ShapeTolerance_swigregister = _ShapeAnalysis.ShapeAnalysis_ShapeTolerance_swigregister
ShapeAnalysis_ShapeTolerance_swigregister(ShapeAnalysis_ShapeTolerance)

class Handle_ShapeAnalysis_FreeBoundData(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeAnalysis_FreeBoundData self)

        Nullify the handle


        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeAnalysis_FreeBoundData self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeAnalysis_FreeBoundData self, ShapeAnalysis_FreeBoundData thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeAnalysis_FreeBoundData self, Handle_ShapeAnalysis_FreeBoundData theHandle) -> Handle_ShapeAnalysis_FreeBoundData
        assign(Handle_ShapeAnalysis_FreeBoundData self, ShapeAnalysis_FreeBoundData thePtr) -> Handle_ShapeAnalysis_FreeBoundData
        assign(Handle_ShapeAnalysis_FreeBoundData self, Handle_ShapeAnalysis_FreeBoundData theHandle) -> Handle_ShapeAnalysis_FreeBoundData

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeAnalysis_FreeBoundData self) -> ShapeAnalysis_FreeBoundData

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeAnalysis_FreeBoundData self) -> ShapeAnalysis_FreeBoundData

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeAnalysis_FreeBoundData self) -> ShapeAnalysis_FreeBoundData

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData___ref__(self, *args)


    def __hash__(self):
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeAnalysis.new_Handle_ShapeAnalysis_FreeBoundData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_DownCast)
    __swig_destroy__ = _ShapeAnalysis.delete_Handle_ShapeAnalysis_FreeBoundData

    def Clear(self, *args):
        """
        Clear(Handle_ShapeAnalysis_FreeBoundData self)

        Clears all properties of the contour.
        Contour bound itself is not cleared.


        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_Clear(self, *args)


    def SetFreeBound(self, *args):
        """
        SetFreeBound(Handle_ShapeAnalysis_FreeBoundData self, TopoDS_Wire freebound)

        Sets contour

        :type freebound: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_SetFreeBound(self, *args)


    def SetArea(self, *args):
        """
        SetArea(Handle_ShapeAnalysis_FreeBoundData self, Standard_Real const area)

        Sets area of the contour

        :type area: float

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_SetArea(self, *args)


    def SetPerimeter(self, *args):
        """
        SetPerimeter(Handle_ShapeAnalysis_FreeBoundData self, Standard_Real const perimeter)

        Sets perimeter of the contour

        :type perimeter: float

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_SetPerimeter(self, *args)


    def SetRatio(self, *args):
        """
        SetRatio(Handle_ShapeAnalysis_FreeBoundData self, Standard_Real const ratio)

        Sets ratio of average length to average width of the contour

        :type ratio: float

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_SetRatio(self, *args)


    def SetWidth(self, *args):
        """
        SetWidth(Handle_ShapeAnalysis_FreeBoundData self, Standard_Real const width)

        Sets average width of the contour

        :type width: float

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_SetWidth(self, *args)


    def AddNotch(self, *args):
        """
        AddNotch(Handle_ShapeAnalysis_FreeBoundData self, TopoDS_Wire notch, Standard_Real const width)

        Adds notch on the contour with its maximum width

        :type notch: OCC.wrapper.TopoDS.TopoDS_Wire
        :type width: float

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_AddNotch(self, *args)


    def FreeBound(self, *args):
        """
        FreeBound(Handle_ShapeAnalysis_FreeBoundData self) -> TopoDS_Wire

        Returns contour

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_FreeBound(self, *args)


    def Area(self, *args):
        """
        Area(Handle_ShapeAnalysis_FreeBoundData self) -> Standard_Real

        Returns area of the contour

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_Area(self, *args)


    def Perimeter(self, *args):
        """
        Perimeter(Handle_ShapeAnalysis_FreeBoundData self) -> Standard_Real

        Returns perimeter of the contour

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_Perimeter(self, *args)


    def Ratio(self, *args):
        """
        Ratio(Handle_ShapeAnalysis_FreeBoundData self) -> Standard_Real

        Returns ratio of average length to average width of the contour

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_Ratio(self, *args)


    def Width(self, *args):
        """
        Width(Handle_ShapeAnalysis_FreeBoundData self) -> Standard_Real

        Returns average width of the contour

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_Width(self, *args)


    def NbNotches(self, *args):
        """
        NbNotches(Handle_ShapeAnalysis_FreeBoundData self) -> Standard_Integer

        Returns number of notches on the contour

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_NbNotches(self, *args)


    def Notches(self, *args):
        """
        Notches(Handle_ShapeAnalysis_FreeBoundData self) -> Handle_TopTools_HSequenceOfShape

        Returns sequence of notches on the contour

        :rtype: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_Notches(self, *args)


    def Notch(self, *args):
        """
        Notch(Handle_ShapeAnalysis_FreeBoundData self, Standard_Integer const index) -> TopoDS_Wire

        Returns notch on the contour

        :type index: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_Notch(self, *args)


    def NotchWidth(self, *args):
        """
        NotchWidth(Handle_ShapeAnalysis_FreeBoundData self, Standard_Integer const index) -> Standard_Real
        NotchWidth(Handle_ShapeAnalysis_FreeBoundData self, TopoDS_Wire notch) -> Standard_Real

        Returns maximum width of notch specified as TopoDS_Wire
        on the contour

        :type notch: OCC.wrapper.TopoDS.TopoDS_Wire
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_NotchWidth(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeAnalysis_FreeBoundData self) -> char const *

        :rtype: const char *

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ShapeAnalysis_FreeBoundData self)

        Memory deallocator for transient classes


        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeAnalysis_FreeBoundData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeAnalysis_FreeBoundData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeAnalysis_FreeBoundData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeAnalysis_FreeBoundData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeAnalysis_FreeBoundData self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeAnalysis_FreeBoundData self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeAnalysis_FreeBoundData self)

        Increments the reference counter of this object


        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeAnalysis_FreeBoundData self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_DecrementRefCounter(self, *args)

Handle_ShapeAnalysis_FreeBoundData_swigregister = _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_swigregister
Handle_ShapeAnalysis_FreeBoundData_swigregister(Handle_ShapeAnalysis_FreeBoundData)

def Handle_ShapeAnalysis_FreeBoundData_DownCast(thing):
    return _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_DownCast(thing)
Handle_ShapeAnalysis_FreeBoundData_DownCast = _ShapeAnalysis.Handle_ShapeAnalysis_FreeBoundData_DownCast

class ShapeAnalysis_(object):
    """
    This package is intended to analyze geometrical objects
    and topological shapes. Analysis domain includes both
    exploring geometrical and topological properties of
    shapes and checking their conformance to Open CASCADE requirements.
    The directions of analysis provided by tools of this package are:
    computing quantities of subshapes,
    computing parameters of points on curve and surface,
    computing surface singularities,
    checking edge and wire consistency,
    checking edges order in the wire,
    checking face bounds orientation,
    checking small faces,
    analyzing shape tolerances,
    analyzing of free bounds of the shape.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def OuterWire(*args):
        """
        OuterWire(TopoDS_Face face) -> TopoDS_Wire

        Returns the outer wire on the face <Face>.
        This is replacement of the method BRepTools::OuterWire
        until it works badly.
        Returns the first wire oriented as outer according to
        FClass2d_Classifier. If none, last wire is returned.

        :type face: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _ShapeAnalysis.ShapeAnalysis__OuterWire(*args)

    OuterWire = staticmethod(OuterWire)

    def TotCross2D(*args):
        """
        TotCross2D(Handle_ShapeExtend_WireData sewd, TopoDS_Face aFace) -> Standard_Real

        Returns a total area of 2d wire

        :type sewd: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_WireData
        :type aFace: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis__TotCross2D(*args)

    TotCross2D = staticmethod(TotCross2D)

    def ContourArea(*args):
        """
        ContourArea(TopoDS_Wire theWire) -> Standard_Real

        Returns a total area of 3d wire

        :type theWire: OCC.wrapper.TopoDS.TopoDS_Wire
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis__ContourArea(*args)

    ContourArea = staticmethod(ContourArea)

    def IsOuterBound(*args):
        """
        IsOuterBound(TopoDS_Face face) -> Standard_Boolean

        Returns True if <F> has outer bound.

        :type face: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis__IsOuterBound(*args)

    IsOuterBound = staticmethod(IsOuterBound)

    def AdjustByPeriod(*args):
        """
        AdjustByPeriod(Standard_Real const Val, Standard_Real const ToVal, Standard_Real const Period) -> Standard_Real

        Returns a shift required to move point
        <Val> to the range [ToVal-Period/2,ToVal+Period/2].
        This shift will be the divisible by Period.
        Intended for adjusting parameters on periodic surfaces.

        :type Val: float
        :type ToVal: float
        :type Period: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis__AdjustByPeriod(*args)

    AdjustByPeriod = staticmethod(AdjustByPeriod)

    def AdjustToPeriod(*args):
        """
        AdjustToPeriod(Standard_Real const Val, Standard_Real const ValMin, Standard_Real const ValMax) -> Standard_Real

        Returns a shift required to move point
        <Val> to the range [ValMin,ValMax].
        This shift will be the divisible by Period
        with Period = ValMax - ValMin.
        Intended for adjusting parameters on periodic surfaces.

        :type Val: float
        :type ValMin: float
        :type ValMax: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis__AdjustToPeriod(*args)

    AdjustToPeriod = staticmethod(AdjustToPeriod)

    def FindBounds(*args):
        """
        FindBounds(TopoDS_Shape shape, TopoDS_Vertex V1, TopoDS_Vertex V2)

        Finds the start and end vertices of the shape
        Shape can be of the following type:
        vertex: V1 and V2 are the same and equal to <shape>,
        edge  : V1 is start and V2 is end vertex (see ShapeAnalysis_Edge
        methods FirstVertex and LastVertex),
        wire  : V1 is start vertex of the first edge, V2 is end vertex
        of the last edge (also see ShapeAnalysis_Edge).
        If wire contains no edges V1 and V2 are nullified
        If none of the above V1 and V2 are nullified

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type V1: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type V2: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _ShapeAnalysis.ShapeAnalysis__FindBounds(*args)

    FindBounds = staticmethod(FindBounds)

    def GetFaceUVBounds(*args):
        """
        GetFaceUVBounds(TopoDS_Face F)

        Computes exact UV bounds of all wires on the face

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type Umin: float
        :type Umax: float
        :type Vmin: float
        :type Vmax: float

        """
        return _ShapeAnalysis.ShapeAnalysis__GetFaceUVBounds(*args)

    GetFaceUVBounds = staticmethod(GetFaceUVBounds)

    def __init__(self):
        """
        This package is intended to analyze geometrical objects
        and topological shapes. Analysis domain includes both
        exploring geometrical and topological properties of
        shapes and checking their conformance to Open CASCADE requirements.
        The directions of analysis provided by tools of this package are:
        computing quantities of subshapes,
        computing parameters of points on curve and surface,
        computing surface singularities,
        checking edge and wire consistency,
        checking edges order in the wire,
        checking face bounds orientation,
        checking small faces,
        analyzing shape tolerances,
        analyzing of free bounds of the shape.
        """
        this = _ShapeAnalysis.new_ShapeAnalysis_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_
ShapeAnalysis__swigregister = _ShapeAnalysis.ShapeAnalysis__swigregister
ShapeAnalysis__swigregister(ShapeAnalysis_)

def ShapeAnalysis__OuterWire(*args):
    """
    ShapeAnalysis__OuterWire(TopoDS_Face face) -> TopoDS_Wire

    Returns the outer wire on the face <Face>.
    This is replacement of the method BRepTools::OuterWire
    until it works badly.
    Returns the first wire oriented as outer according to
    FClass2d_Classifier. If none, last wire is returned.

    :type face: OCC.wrapper.TopoDS.TopoDS_Face
    :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

    """
    return _ShapeAnalysis.ShapeAnalysis__OuterWire(*args)

def ShapeAnalysis__TotCross2D(*args):
    """
    ShapeAnalysis__TotCross2D(Handle_ShapeExtend_WireData sewd, TopoDS_Face aFace) -> Standard_Real

    Returns a total area of 2d wire

    :type sewd: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_WireData
    :type aFace: OCC.wrapper.TopoDS.TopoDS_Face
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _ShapeAnalysis.ShapeAnalysis__TotCross2D(*args)

def ShapeAnalysis__ContourArea(*args):
    """
    ShapeAnalysis__ContourArea(TopoDS_Wire theWire) -> Standard_Real

    Returns a total area of 3d wire

    :type theWire: OCC.wrapper.TopoDS.TopoDS_Wire
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _ShapeAnalysis.ShapeAnalysis__ContourArea(*args)

def ShapeAnalysis__IsOuterBound(*args):
    """
    ShapeAnalysis__IsOuterBound(TopoDS_Face face) -> Standard_Boolean

    Returns True if <F> has outer bound.

    :type face: OCC.wrapper.TopoDS.TopoDS_Face
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _ShapeAnalysis.ShapeAnalysis__IsOuterBound(*args)

def ShapeAnalysis__AdjustByPeriod(*args):
    """
    ShapeAnalysis__AdjustByPeriod(Standard_Real const Val, Standard_Real const ToVal, Standard_Real const Period) -> Standard_Real

    Returns a shift required to move point
    <Val> to the range [ToVal-Period/2,ToVal+Period/2].
    This shift will be the divisible by Period.
    Intended for adjusting parameters on periodic surfaces.

    :type Val: float
    :type ToVal: float
    :type Period: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _ShapeAnalysis.ShapeAnalysis__AdjustByPeriod(*args)

def ShapeAnalysis__AdjustToPeriod(*args):
    """
    ShapeAnalysis__AdjustToPeriod(Standard_Real const Val, Standard_Real const ValMin, Standard_Real const ValMax) -> Standard_Real

    Returns a shift required to move point
    <Val> to the range [ValMin,ValMax].
    This shift will be the divisible by Period
    with Period = ValMax - ValMin.
    Intended for adjusting parameters on periodic surfaces.

    :type Val: float
    :type ValMin: float
    :type ValMax: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _ShapeAnalysis.ShapeAnalysis__AdjustToPeriod(*args)

def ShapeAnalysis__FindBounds(*args):
    """
    ShapeAnalysis__FindBounds(TopoDS_Shape shape, TopoDS_Vertex V1, TopoDS_Vertex V2)

    Finds the start and end vertices of the shape
    Shape can be of the following type:
    vertex: V1 and V2 are the same and equal to <shape>,
    edge  : V1 is start and V2 is end vertex (see ShapeAnalysis_Edge
    methods FirstVertex and LastVertex),
    wire  : V1 is start vertex of the first edge, V2 is end vertex
    of the last edge (also see ShapeAnalysis_Edge).
    If wire contains no edges V1 and V2 are nullified
    If none of the above V1 and V2 are nullified

    :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type V1: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type V2: OCC.wrapper.TopoDS.TopoDS_Vertex

    """
    return _ShapeAnalysis.ShapeAnalysis__FindBounds(*args)

def ShapeAnalysis__GetFaceUVBounds(*args):
    """
    ShapeAnalysis__GetFaceUVBounds(TopoDS_Face F)

    Computes exact UV bounds of all wires on the face

    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type Umin: float
    :type Umax: float
    :type Vmin: float
    :type Vmax: float

    """
    return _ShapeAnalysis.ShapeAnalysis__GetFaceUVBounds(*args)

class ShapeAnalysis_Wire(Standard.Standard_Transient):
    """
    This class provides analysis of a wire to be compliant to
    CAS.CADE requirements.

    The functionalities provided are the following:
    1. consistency of 2d and 3d edge curve senses
    2. connection of adjacent edges regarding to:
    a. their vertices
    b. their pcurves
    c. their 3d curves
    3. adjacency of the edge vertices to its pcurve and 3d curve
    4. if a wire is closed or not (considering its 3d and 2d
    contour)
    5. if a wire is outer on its face (considering pcurves)

    This class can be used in conjunction with class
    ShapeFix_Wire, which will fix the problems detected by this class.

    The methods of the given class match to ones of the class
    ShapeFix_Wire, e.g., CheckSmall and FixSmall.
    This class also includes some auxilary methods
    (e.g., CheckOuterBound, etc.),
    which have no pair in ShapeFix_Wire.

    Like methods of ShapeFix_Wire the ones of this class are
    grouped into two levels:
    - Public which are recommended for use (the most global
    method is Perform),
    - Advanced, for optional use only

    For analyzing result of Public API checking methods use
    corresponding Status... method.
    The 'advanced' functions share the single status field which
    contains the result of the last performed 'advanced' method.
    It is quried by the method LastCheckStatus().

    In order to prepare an analyzer, it is necessary to load a wire,
    set face and precision.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeAnalysis_Wire
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeAnalysis_Wire(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeAnalysis_Wire self) -> ShapeAnalysis_Wire
        __init__(ShapeAnalysis_Wire self, TopoDS_Wire wire, TopoDS_Face face, Standard_Real const precision) -> ShapeAnalysis_Wire
        __init__(ShapeAnalysis_Wire self, Handle_ShapeExtend_WireData sbwd, TopoDS_Face face, Standard_Real const precision) -> ShapeAnalysis_Wire

        Creates the object with WireData object, face
        and precision

        :type sbwd: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_WireData
        :type face: OCC.wrapper.TopoDS.TopoDS_Face
        :type precision: float

        """
        this = _ShapeAnalysis.new_ShapeAnalysis_Wire(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(ShapeAnalysis_Wire self, TopoDS_Wire wire, TopoDS_Face face, Standard_Real const precision)
        Init(ShapeAnalysis_Wire self, Handle_ShapeExtend_WireData sbwd, TopoDS_Face face, Standard_Real const precision)

        Initializes the object with WireData object, face
        and precision

        :type sbwd: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_WireData
        :type face: OCC.wrapper.TopoDS.TopoDS_Face
        :type precision: float

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_Init(self, *args)


    def Load(self, *args):
        """
        Load(ShapeAnalysis_Wire self, TopoDS_Wire wire)
        Load(ShapeAnalysis_Wire self, Handle_ShapeExtend_WireData sbwd)

        Loads the object with WireData object

        :type sbwd: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_WireData

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_Load(self, *args)


    def SetFace(self, *args):
        """
        SetFace(ShapeAnalysis_Wire self, TopoDS_Face face)

        Loads the face the wire lies on

        :type face: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_SetFace(self, *args)


    def SetSurface(self, *args):
        """
        SetSurface(ShapeAnalysis_Wire self, Handle_Geom_Surface surface)
        SetSurface(ShapeAnalysis_Wire self, Handle_Geom_Surface surface, TopLoc_Location location)

        Loads the surface the wire lies on

        :type surface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type location: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_SetSurface(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(ShapeAnalysis_Wire self, Standard_Real const precision)

        :type precision: float

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_SetPrecision(self, *args)


    def ClearStatuses(self, *args):
        """
        ClearStatuses(ShapeAnalysis_Wire self)

        Unsets all the status and distance fields
        wire, face and precision are not cleared


        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_ClearStatuses(self, *args)


    def IsLoaded(self, *args):
        """
        IsLoaded(ShapeAnalysis_Wire self) -> Standard_Boolean

        Returns True if wire is loaded and has number of edges >0

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_IsLoaded(self, *args)


    def IsReady(self, *args):
        """
        IsReady(ShapeAnalysis_Wire self) -> Standard_Boolean

        Returns True if IsLoaded and underlying face is not null

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_IsReady(self, *args)


    def Precision(self, *args):
        """
        Precision(ShapeAnalysis_Wire self) -> Standard_Real

        Returns the value of precision

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_Precision(self, *args)


    def WireData(self, *args):
        """
        Returns wire object being analyzed

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_WireData

        """
        res = _ShapeAnalysis.ShapeAnalysis_Wire_WireData(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbEdges(self, *args):
        """
        NbEdges(ShapeAnalysis_Wire self) -> Standard_Integer

        Returns the number of edges in the wire, or 0 if it is not loaded

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_NbEdges(self, *args)


    def Face(self, *args):
        """
        Returns the working face

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _ShapeAnalysis.ShapeAnalysis_Wire_Face(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface(self, *args):
        """
        Returns the working surface

        :rtype: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_Surface

        """
        res = _ShapeAnalysis.ShapeAnalysis_Wire_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Perform(self, *args):
        """
        Perform(ShapeAnalysis_Wire self) -> Standard_Boolean

        Performs all the checks in the following order :
        CheckOrder, CheckSmall, CheckConected, CheckEdgeCurves,
        CheckDegenerated, CheckSelfIntersection, CheckLacking,
        CheckClosed
        Returns: True if at least one method returned True;
        For deeper analysis use Status...(status) methods

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_Perform(self, *args)


    def CheckEdgeCurves(self, *args):
        """
        CheckEdgeCurves(ShapeAnalysis_Wire self) -> Standard_Boolean

        Checks edges geometry (consitency of 2d and 3d senses, adjasment
        of curves to the vertices, etc.).
        The order of the checks :
        Call ShapeAnalysis_Wire to check:
        ShapeAnalysis_Edge::CheckCurve3dWithPCurve  (1),
        ShapeAnalysis_Edge::CheckVertcesWithPCurve  (2),
        ShapeAnalysis_Edge::CheckVertcesWithCurve3d (3),
        CheckSeam                                   (4)
        Additional:
        CheckGap3d                                  (5),
        CheckGap2d                                  (6),
        ShapeAnalysis_Edge::CheckSameParameter      (7)
        Returns: True if at least one check returned True
        Remark:  The numbers in brackets show with what DONEi or FAILi
        the status can be queried

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckEdgeCurves(self, *args)


    def CheckClosed(self, *args):
        """
        CheckClosed(ShapeAnalysis_Wire self, Standard_Real const prec=0.0) -> Standard_Boolean

        Checks if wire is closed, performs CheckConnected,
        CheckDegenerated and CheckLacking for the first and the last edges
        Returns: True if at least one check returned True
        Status:
        FAIL1 or DONE1: see CheckConnected
        FAIL2 or DONE2: see CheckDegenerated

        :type prec: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckClosed(self, *args)


    def CheckSelfIntersection(self, *args):
        """
        CheckSelfIntersection(ShapeAnalysis_Wire self) -> Standard_Boolean

        Checks self-intersection of the wire (considering pcurves)
        Looks for self-intersecting edges and each pair of intersecting
        edges.
        Warning: It does not check each edge with any other one (only each two
        adjacent edges)
        The order of the checks :
        CheckSelfIntersectingEdge, CheckIntersectingEdges
        Returns: True if at least one check returned True
        Status:  FAIL1 or DONE1 - see CheckSelfIntersectingEdge
        FAIL2 or DONE2 - see CheckIntersectingEdges

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckSelfIntersection(self, *args)


    def CheckGaps3d(self, *args):
        """
        CheckGaps3d(ShapeAnalysis_Wire self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckGaps3d(self, *args)


    def CheckGaps2d(self, *args):
        """
        CheckGaps2d(ShapeAnalysis_Wire self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckGaps2d(self, *args)


    def CheckCurveGaps(self, *args):
        """
        CheckCurveGaps(ShapeAnalysis_Wire self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckCurveGaps(self, *args)


    def CheckOrder(self, *args):
        """
        CheckOrder(ShapeAnalysis_Wire self, Standard_Boolean const isClosed, Standard_Boolean const mode3d) -> Standard_Boolean
        CheckOrder(ShapeAnalysis_Wire self, ShapeAnalysis_WireOrder sawo, Standard_Boolean const isClosed, Standard_Boolean const mode3d) -> Standard_Boolean

        Analyzes the order of the edges in the wire,
        uses class WireOrder for that purpose.
        Flag <isClosed> defines if the wire is closed or not
        Flag <mode3d> defines which mode is used (3d or 2d)
        Returns False if wire is already ordered (tail-to-head),
        True otherwise.
        Use returned WireOrder object for deeper analysis.
        Status:
        OK   : the same edges orientation, the same edges sequence
        DONE1: the same edges orientation, not the same edges sequence
        DONE2: as DONE1 and gaps more than myPrecision
        DONE3: not the same edges orientation (some need to be reversed)
        DONE4: as DONE3 and gaps more than myPrecision
        FAIL : algorithm failed (could not detect order)

        :type sawo: OCC.wrapper.ShapeAnalysis.ShapeAnalysis_WireOrder
        :type isClosed: bool
        :type mode3d: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckOrder(self, *args)


    def CheckConnected(self, *args):
        """
        CheckConnected(ShapeAnalysis_Wire self, Standard_Real const prec=0.0) -> Standard_Boolean
        CheckConnected(ShapeAnalysis_Wire self, Standard_Integer const num, Standard_Real const prec=0.0) -> Standard_Boolean

        Checks connected edges (num-th and preceeding).
        Tests with starting preci from <SBWD> or  with <prec> if
        it is greater.
        Considers Vertices.
        Returns: False if edges are connected by the common vertex, else True
        Status  :
        OK    : Vertices (end of num-1 th edge and start on num-th one)
        are already the same
        DONE1 : Absolutely confused (gp::Resolution)
        DONE2 : Confused at starting <preci> from <SBWD>
        DONE3 : Confused at <prec> but not <preci>
        FAIL1 : Not confused
        FAIL2 : Not confused but confused with <preci> if reverse num-th edge

        :type num: int
        :type prec: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckConnected(self, *args)


    def CheckSmall(self, *args):
        """
        CheckSmall(ShapeAnalysis_Wire self, Standard_Real const precsmall=0.0) -> Standard_Boolean
        CheckSmall(ShapeAnalysis_Wire self, Standard_Integer const num, Standard_Real const precsmall=0.0) -> Standard_Boolean

        Checks if an edge has a length not greater than myPreci or
        precsmall (if it is smaller)
        Returns: False if its length is greater than precision
        Status:
        OK   : edge is not small or degenerated
        DONE1: edge is small, vertices are the same
        DONE2: edge is small, vertices are not the same
        FAIL : no 3d curve and pcurve

        :type num: int
        :type precsmall: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckSmall(self, *args)


    def CheckSeam(self, *args):
        """
        CheckSeam(ShapeAnalysis_Wire self, Standard_Integer const num, Handle_Geom2d_Curve C1, Handle_Geom2d_Curve C2) -> Standard_Boolean
        CheckSeam(ShapeAnalysis_Wire self, Standard_Integer const num) -> Standard_Boolean

        Checks if a seam pcurves are correct oriented
        See previous functions for details

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckSeam(self, *args)


    def CheckDegenerated(self, *args):
        """
        CheckDegenerated(ShapeAnalysis_Wire self) -> Standard_Boolean
        CheckDegenerated(ShapeAnalysis_Wire self, Standard_Integer const num, gp_Pnt2d dgnr1, gp_Pnt2d dgnr2) -> Standard_Boolean
        CheckDegenerated(ShapeAnalysis_Wire self, Standard_Integer const num) -> Standard_Boolean

        Checks for degenerated edge between two adjacent ones.
        Remark : Calls previous function
        Status : See the function above for details

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckDegenerated(self, *args)


    def CheckGap3d(self, *args):
        """
        CheckGap3d(ShapeAnalysis_Wire self, Standard_Integer const num=0) -> Standard_Boolean

        Checks gap between edges in 3D (3d curves).
        Checks the distance between ends of 3d curves of the num-th
        and preceeding edge.
        The distance can be queried by MinDistance3d.

        Returns: True if status is DONE
        Status:
        OK   : Gap is less than myPrecision
        DONE : Gap is greater than myPrecision
        FAIL : No 3d curve(s) on the edge(s)

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckGap3d(self, *args)


    def CheckGap2d(self, *args):
        """
        CheckGap2d(ShapeAnalysis_Wire self, Standard_Integer const num=0) -> Standard_Boolean

        Checks gap between edges in 2D (pcurves).
        Checks the distance between ends of pcurves of the num-th
        and preceeding edge.
        The distance can be queried by MinDistance2d.

        Returns: True if status is DONE
        Status:
        OK   : Gap is less than parametric precision out of myPrecision
        DONE : Gap is greater than parametric precision out of myPrecision
        FAIL : No pcurve(s) on the edge(s)

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckGap2d(self, *args)


    def CheckCurveGap(self, *args):
        """
        CheckCurveGap(ShapeAnalysis_Wire self, Standard_Integer const num=0) -> Standard_Boolean

        Checks gap between points on 3D curve and points on surface
        generated by pcurve of the num-th edge.
        The distance can be queried by MinDistance3d.

        Returns: True if status is DONE
        Status:
        OK   : Gap is less than myPrecision
        DONE : Gap is greater than myPrecision
        FAIL : No 3d curve(s) on the edge(s)

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckCurveGap(self, *args)


    def CheckSelfIntersectingEdge(self, *args):
        """
        CheckSelfIntersectingEdge(ShapeAnalysis_Wire self, Standard_Integer const num, NCollection_Sequence_IntRes2d_IntersectionPoint points2d, NCollection_Sequence_gp_Pnt points3d) -> Standard_Boolean
        CheckSelfIntersectingEdge(ShapeAnalysis_Wire self, Standard_Integer const num) -> Standard_Boolean

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckSelfIntersectingEdge(self, *args)


    def CheckIntersectingEdges(self, *args):
        """
        CheckIntersectingEdges(ShapeAnalysis_Wire self, Standard_Integer const num, NCollection_Sequence_IntRes2d_IntersectionPoint points2d, NCollection_Sequence_gp_Pnt points3d, NCollection_Sequence_Standard_Real errors) -> Standard_Boolean
        CheckIntersectingEdges(ShapeAnalysis_Wire self, Standard_Integer const num) -> Standard_Boolean
        CheckIntersectingEdges(ShapeAnalysis_Wire self, Standard_Integer const num1, Standard_Integer const num2, NCollection_Sequence_IntRes2d_IntersectionPoint points2d, NCollection_Sequence_gp_Pnt points3d, NCollection_Sequence_Standard_Real errors) -> Standard_Boolean
        CheckIntersectingEdges(ShapeAnalysis_Wire self, Standard_Integer const num1, Standard_Integer const num2) -> Standard_Boolean

        Checks i-th and j-th edges for intersecting.
        Remark : Calls  previous method.
        Status : See the function above for details

        :type num1: int
        :type num2: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckIntersectingEdges(self, *args)


    def CheckLacking(self, *args):
        """
        CheckLacking(ShapeAnalysis_Wire self) -> Standard_Boolean
        CheckLacking(ShapeAnalysis_Wire self, Standard_Integer const num, Standard_Real const Tolerance, gp_Pnt2d p2d1, gp_Pnt2d p2d2) -> Standard_Boolean
        CheckLacking(ShapeAnalysis_Wire self, Standard_Integer const num, Standard_Real const Tolerance=0.0) -> Standard_Boolean

        Checks if there is a gap in 2D between edges and not comprised by vertex tolerance
        The value of SBWD.thepreci is used.
        Returns: False if no edge should be inserted
        Status:
        OK    : No edge is lacking (3d and 2d connection)
        DONE1 : The vertex tolerance should be increased only (2d gap is
        small)
        DONE2 : Edge can be inserted (3d and 2d gaps are large enough)

        :type num: int
        :type Tolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckLacking(self, *args)


    def CheckOuterBound(self, *args):
        """
        CheckOuterBound(ShapeAnalysis_Wire self, Standard_Boolean const APIMake) -> Standard_Boolean

        Checks if wire defines an outer bound on the face
        Uses ShapeAnalysis::IsOuterBound for analysis
        If <APIMake> is True uses BRepAPI_MakeWire to build the
        wire, if False (to be used only when edges share common
        vertices) uses BRep_Builder to build the wire

        :type APIMake: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckOuterBound(self, *args)


    def CheckNotchedEdges(self, *args):
        """
        CheckNotchedEdges(ShapeAnalysis_Wire self, Standard_Integer const num, Standard_Real const Tolerance=0.0) -> Standard_Boolean

        Detects a notch

        :type num: int
        :type shortNum: int
        :type param: float
        :type Tolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckNotchedEdges(self, *args)


    def CheckSmallArea(self, *args):
        """
        CheckSmallArea(ShapeAnalysis_Wire self, TopoDS_Wire theWire) -> Standard_Boolean

        Checks if wire has parametric area less than precision.

        :type theWire: OCC.wrapper.TopoDS.TopoDS_Wire
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckSmallArea(self, *args)


    def CheckShapeConnect(self, *args):
        """
        CheckShapeConnect(ShapeAnalysis_Wire self, TopoDS_Shape shape, Standard_Real const prec=0.0) -> Standard_Boolean
        CheckShapeConnect(ShapeAnalysis_Wire self, TopoDS_Shape shape, Standard_Real const prec=0.0) -> Standard_Boolean

        The same as previous CheckShapeConnect but is more advanced.
        It returns the distances between each end of <sbwd> and each
        end of <shape>. For example, <tailhead> stores distance
        between tail of <sbwd> and head of <shape>
        Remark:  First method CheckShapeConnect calls this one

        :type tailhead: float
        :type tailtail: float
        :type headtail: float
        :type headhead: float
        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type prec: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckShapeConnect(self, *args)


    def CheckLoop(self, *args):
        """
        CheckLoop(ShapeAnalysis_Wire self, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher aMapLoopVertices, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher aMapVertexEdges, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher aMapSmallEdges, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher aMapSeemEdges) -> Standard_Boolean

        Checks existance of loop on wire and return vertices wich are loop vertices
        (vertices belonging to a few pairs of edges)

        :type aMapLoopVertices: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape
        :type aMapVertexEdges: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
        :type aMapSmallEdges: OCC.wrapper.TopTools.TopTools_MapOfShape
        :type aMapSeemEdges: OCC.wrapper.TopTools.TopTools_MapOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckLoop(self, *args)


    def CheckTail(self, *args):
        """
        CheckTail(ShapeAnalysis_Wire self, TopoDS_Edge theEdge1, TopoDS_Edge theEdge2, Standard_Real const theMaxSine, Standard_Real const theMaxWidth, Standard_Real const theMaxTolerance, TopoDS_Edge theEdge11, TopoDS_Edge theEdge12, TopoDS_Edge theEdge21, TopoDS_Edge theEdge22) -> Standard_Boolean

        :type theEdge1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theEdge2: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theMaxSine: float
        :type theMaxWidth: float
        :type theMaxTolerance: float
        :type theEdge11: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theEdge12: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theEdge21: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theEdge22: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_CheckTail(self, *args)


    def StatusOrder(self, *args):
        """
        StatusOrder(ShapeAnalysis_Wire self, ShapeExtend_Status const Status) -> Standard_Boolean

        :type Status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_StatusOrder(self, *args)


    def StatusConnected(self, *args):
        """
        StatusConnected(ShapeAnalysis_Wire self, ShapeExtend_Status const Status) -> Standard_Boolean

        :type Status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_StatusConnected(self, *args)


    def StatusEdgeCurves(self, *args):
        """
        StatusEdgeCurves(ShapeAnalysis_Wire self, ShapeExtend_Status const Status) -> Standard_Boolean

        :type Status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_StatusEdgeCurves(self, *args)


    def StatusDegenerated(self, *args):
        """
        StatusDegenerated(ShapeAnalysis_Wire self, ShapeExtend_Status const Status) -> Standard_Boolean

        :type Status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_StatusDegenerated(self, *args)


    def StatusClosed(self, *args):
        """
        StatusClosed(ShapeAnalysis_Wire self, ShapeExtend_Status const Status) -> Standard_Boolean

        :type Status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_StatusClosed(self, *args)


    def StatusSmall(self, *args):
        """
        StatusSmall(ShapeAnalysis_Wire self, ShapeExtend_Status const Status) -> Standard_Boolean

        :type Status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_StatusSmall(self, *args)


    def StatusSelfIntersection(self, *args):
        """
        StatusSelfIntersection(ShapeAnalysis_Wire self, ShapeExtend_Status const Status) -> Standard_Boolean

        :type Status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_StatusSelfIntersection(self, *args)


    def StatusLacking(self, *args):
        """
        StatusLacking(ShapeAnalysis_Wire self, ShapeExtend_Status const Status) -> Standard_Boolean

        :type Status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_StatusLacking(self, *args)


    def StatusGaps3d(self, *args):
        """
        StatusGaps3d(ShapeAnalysis_Wire self, ShapeExtend_Status const Status) -> Standard_Boolean

        :type Status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_StatusGaps3d(self, *args)


    def StatusGaps2d(self, *args):
        """
        StatusGaps2d(ShapeAnalysis_Wire self, ShapeExtend_Status const Status) -> Standard_Boolean

        :type Status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_StatusGaps2d(self, *args)


    def StatusCurveGaps(self, *args):
        """
        StatusCurveGaps(ShapeAnalysis_Wire self, ShapeExtend_Status const Status) -> Standard_Boolean

        :type Status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_StatusCurveGaps(self, *args)


    def StatusLoop(self, *args):
        """
        StatusLoop(ShapeAnalysis_Wire self, ShapeExtend_Status const Status) -> Standard_Boolean

        :type Status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_StatusLoop(self, *args)


    def LastCheckStatus(self, *args):
        """
        LastCheckStatus(ShapeAnalysis_Wire self, ShapeExtend_Status const Status) -> Standard_Boolean

        Querying the status of the LAST perfomed 'Advanced' checking procedure

        :type Status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_LastCheckStatus(self, *args)


    def MinDistance3d(self, *args):
        """
        MinDistance3d(ShapeAnalysis_Wire self) -> Standard_Real

        Returns the last lowest distance in 3D computed by
        CheckOrientation, CheckConnected, CheckContinuity3d,
        CheckVertex, CheckNewVertex

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_MinDistance3d(self, *args)


    def MinDistance2d(self, *args):
        """
        MinDistance2d(ShapeAnalysis_Wire self) -> Standard_Real

        Returns the last lowest distance in 2D-UV computed by
        CheckContinuity2d

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_MinDistance2d(self, *args)


    def MaxDistance3d(self, *args):
        """
        MaxDistance3d(ShapeAnalysis_Wire self) -> Standard_Real

        Returns the last maximal distance in 3D computed by
        CheckOrientation, CheckConnected, CheckContinuity3d,
        CheckVertex, CheckNewVertex, CheckSameParameter

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_MaxDistance3d(self, *args)


    def MaxDistance2d(self, *args):
        """
        MaxDistance2d(ShapeAnalysis_Wire self) -> Standard_Real

        Returns the last maximal distance in 2D-UV computed by
        CheckContinuity2d

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_MaxDistance2d(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeAnalysis.ShapeAnalysis_Wire_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeAnalysis.ShapeAnalysis_Wire_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_Wire
ShapeAnalysis_Wire_swigregister = _ShapeAnalysis.ShapeAnalysis_Wire_swigregister
ShapeAnalysis_Wire_swigregister(ShapeAnalysis_Wire)

def ShapeAnalysis_Wire_get_type_name(*args):
    """
    ShapeAnalysis_Wire_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeAnalysis.ShapeAnalysis_Wire_get_type_name(*args)

def ShapeAnalysis_Wire_get_type_descriptor(*args):
    """
    ShapeAnalysis_Wire_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeAnalysis.ShapeAnalysis_Wire_get_type_descriptor(*args)

class ShapeAnalysis_CheckSmallFace(object):
    """Analysis of the face size"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeAnalysis_CheckSmallFace self) -> ShapeAnalysis_CheckSmallFace

        Creates an empty tool
        Checks a Shape i.e. each of its faces, records checks as
        diagnostics in the <infos>

        If <infos> has not been set before, no check is done

        For faces which are in a Shell, topological data are recorded
        to allow recovering connectivities after fixing or removing
        the small faces or parts of faces
        Enchains various checks on a face
        inshell : to compute more informations, relevant to topology


        """
        this = _ShapeAnalysis.new_ShapeAnalysis_CheckSmallFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsSpotFace(self, *args):
        """
        IsSpotFace(ShapeAnalysis_CheckSmallFace self, TopoDS_Face F, gp_Pnt spot, Standard_Real const tol=-1.0) -> Standard_Integer

        Checks if a Face is as a Spot
        Returns 0 if not, 1 if yes, 2 if yes and all vertices are the
        same
        By default, considers the tolerance zone of its vertices
        A given value <tol> may be given to check a spot of this size
        If a Face is a Spot, its location is returned in <spot>, and
        <spotol> returns an equivalent tolerance, which is computed as
        half of max dimension of min-max box of the face

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type spot: OCC.wrapper.gp.gp_Pnt
        :type spotol: float
        :type tol: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_IsSpotFace(self, *args)


    def CheckSpotFace(self, *args):
        """
        CheckSpotFace(ShapeAnalysis_CheckSmallFace self, TopoDS_Face F, Standard_Real const tol=-1.0) -> Standard_Boolean

        Acts as IsSpotFace, but records in <infos> a diagnostic
        "SpotFace" with the Pnt as value (data "Location")

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckSpotFace(self, *args)


    def IsStripSupport(self, *args):
        """
        IsStripSupport(ShapeAnalysis_CheckSmallFace self, TopoDS_Face F, Standard_Real const tol=-1.0) -> Standard_Boolean

        Checks if a Face lies on a Surface which is a strip
        So the Face is a strip. But a Face may be a strip elsewhere ..

        A given value <tol> may be given to check max width
        By default, considers the tolerance zone of its edges
        Returns 0 if not a strip support, 1 strip in U, 2 strip in V

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_IsStripSupport(self, *args)


    def CheckStripEdges(self, *args):
        """
        CheckStripEdges(ShapeAnalysis_CheckSmallFace self, TopoDS_Edge E1, TopoDS_Edge E2, Standard_Real const tol) -> Standard_Boolean

        Checks if two edges define a strip, i.e. distance maxi below
        tolerance, given or some of those of E1 and E2

        :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
        :type tol: float
        :type dmax: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckStripEdges(self, *args)


    def FindStripEdges(self, *args):
        """
        FindStripEdges(ShapeAnalysis_CheckSmallFace self, TopoDS_Face F, TopoDS_Edge E1, TopoDS_Edge E2, Standard_Real const tol) -> Standard_Boolean

        Searchs for two and only two edges up tolerance
        Returns True if OK, false if not 2 edges
        If True, returns the two edges and their maximum distance

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
        :type tol: float
        :type dmax: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_FindStripEdges(self, *args)


    def CheckSingleStrip(self, *args):
        """
        CheckSingleStrip(ShapeAnalysis_CheckSmallFace self, TopoDS_Face F, TopoDS_Edge E1, TopoDS_Edge E2, Standard_Real const tol=-1.0) -> Standard_Boolean

        Checks if a Face is a single strip, i.e. brings two great
        edges which are confused on their whole length, possible other
        edges are small or null length

        Returns 0 if not a strip support, 1 strip in U, 2 strip in V
        Records diagnostic in info if it is a single strip

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
        :type tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckSingleStrip(self, *args)


    def CheckStripFace(self, *args):
        """
        CheckStripFace(ShapeAnalysis_CheckSmallFace self, TopoDS_Face F, TopoDS_Edge E1, TopoDS_Edge E2, Standard_Real const tol=-1.0) -> Standard_Boolean

        Checks if a Face is as a Strip
        Returns 0 if not or non determined, 1 if in U, 2 if in V
        By default, considers the tolerance zone of its edges
        A given value <tol> may be given to check a strip of max this width

        If a Face is determined as a Strip, it is delinited by two
        lists of edges. These lists are recorded in diagnostic
        Diagnostic "StripFace" brings data "Direction" (U or V),
        "List1" , "List2" (if they could be computed)

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
        :type tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckStripFace(self, *args)


    def CheckSplittingVertices(self, *args):
        """
        CheckSplittingVertices(ShapeAnalysis_CheckSmallFace self, TopoDS_Face F, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher MapEdges, NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher MapParam, TopoDS_Compound theAllVert) -> Standard_Integer

        Checks if a Face brings vertices which split it, either
        confused with non adjacent vertices, or confused with their
        projection on non adjacent edges
        Returns the count of found splitting vertices
        Each vertex then brings a diagnostic "SplittingVertex",
        with data : "Face" for the face, "Edge" for the split edge

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type MapEdges: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
        :type MapParam: OCC.wrapper.ShapeAnalysis.ShapeAnalysis_DataMapOfShapeListOfReal
        :type theAllVert: OCC.wrapper.TopoDS.TopoDS_Compound
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckSplittingVertices(self, *args)


    def CheckPin(self, *args):
        """
        CheckPin(ShapeAnalysis_CheckSmallFace self, TopoDS_Face F) -> Standard_Boolean

        Checks if a Face has a pin, which can be edited
        No singularity : no pin, returns 0
        If there is a pin, checked topics, with returned value :
        - 0 : nothing to do more
        - 1 : "smooth", i.e. not a really sharp pin
        -> diagnostic "SmoothPin"
        - 2 : stretched pin, i.e. is possible to relimit the face by
        another vertex, so that this vertex still gives a pin
        -> diagnostic "StretchedPin" with location of vertex (Pnt)

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type whatrow: int
        :type sence: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckPin(self, *args)


    def CheckTwisted(self, *args):
        """
        CheckTwisted(ShapeAnalysis_CheckSmallFace self, TopoDS_Face F) -> Standard_Boolean

        Checks if a Face is twisted (apart from checking Pin, i.e. it
        does not give information on pin, only "it is twisted")

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type paramu: float
        :type paramv: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckTwisted(self, *args)


    def CheckPinFace(self, *args):
        """
        CheckPinFace(ShapeAnalysis_CheckSmallFace self, TopoDS_Face F, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher mapEdges, Standard_Real const toler=-1.0) -> Standard_Boolean

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type mapEdges: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape
        :type toler: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckPinFace(self, *args)


    def CheckPinEdges(self, *args):
        """
        CheckPinEdges(ShapeAnalysis_CheckSmallFace self, TopoDS_Edge theFirstEdge, TopoDS_Edge theSecondEdge, Standard_Real const coef1, Standard_Real const coef2, Standard_Real const toler) -> Standard_Boolean

        :type theFirstEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theSecondEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type coef1: float
        :type coef2: float
        :type toler: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_CheckPinEdges(self, *args)


    def Status(self, *args):
        """
        Status(ShapeAnalysis_CheckSmallFace self, ShapeExtend_Status const status) -> Standard_Boolean

        Returns the status of last call to Perform()
        ShapeExtend_OK   : face was OK, nothing done
        ShapeExtend_DONE1: some wires are fixed
        ShapeExtend_DONE2: orientation of wires fixed
        ShapeExtend_DONE3: missing seam added
        ShapeExtend_DONE4: small area wire removed
        ShapeExtend_DONE5: natural bounds added
        ShapeExtend_FAIL1: some fails during fixing wires
        ShapeExtend_FAIL2: cannot fix orientation of wires
        ShapeExtend_FAIL3: cannot add missing seam
        ShapeExtend_FAIL4: cannot remove small area wire

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_Status(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(ShapeAnalysis_CheckSmallFace self, Standard_Real const tol)

        Sets a fixed Tolerance to check small face
        By default, local tolerance zone is considered
        Sets a fixed MaxTolerance to check small face
        Sets a fixed Tolerance to check small face
        By default, local tolerance zone is considered
        Unset fixed tolerance, comes back to local tolerance zones
        Unset fixed tolerance, comes back to local tolerance zones

        :type tol: float

        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_SetTolerance(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(ShapeAnalysis_CheckSmallFace self) -> Standard_Real

        Returns the tolerance to check small faces, negative value if
        local tolerances zones are to be considered

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_Tolerance(self, *args)


    def StatusSpot(self, *args):
        """
        StatusSpot(ShapeAnalysis_CheckSmallFace self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_StatusSpot(self, *args)


    def StatusStrip(self, *args):
        """
        StatusStrip(ShapeAnalysis_CheckSmallFace self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_StatusStrip(self, *args)


    def StatusPin(self, *args):
        """
        StatusPin(ShapeAnalysis_CheckSmallFace self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_StatusPin(self, *args)


    def StatusTwisted(self, *args):
        """
        StatusTwisted(ShapeAnalysis_CheckSmallFace self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_StatusTwisted(self, *args)


    def StatusSplitVert(self, *args):
        """
        StatusSplitVert(ShapeAnalysis_CheckSmallFace self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_StatusSplitVert(self, *args)


    def StatusPinFace(self, *args):
        """
        StatusPinFace(ShapeAnalysis_CheckSmallFace self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_StatusPinFace(self, *args)


    def StatusPinEdges(self, *args):
        """
        StatusPinEdges(ShapeAnalysis_CheckSmallFace self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_StatusPinEdges(self, *args)

    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_CheckSmallFace
ShapeAnalysis_CheckSmallFace_swigregister = _ShapeAnalysis.ShapeAnalysis_CheckSmallFace_swigregister
ShapeAnalysis_CheckSmallFace_swigregister(ShapeAnalysis_CheckSmallFace)

class ShapeAnalysis_Curve(object):
    """
    Analyzing tool for 2d or 3d curve.
    Computes parameters of projected point onto a curve.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Project(self, *args):
        """
        Project(ShapeAnalysis_Curve self, Handle_Geom_Curve C3D, gp_Pnt P3D, Standard_Real const preci, gp_Pnt proj, Standard_Boolean const AdjustToEnds) -> Standard_Real
        Project(ShapeAnalysis_Curve self, Adaptor3d_Curve C3D, gp_Pnt P3D, Standard_Real const preci, gp_Pnt proj, Standard_Boolean const AdjustToEnds) -> Standard_Real
        Project(ShapeAnalysis_Curve self, Handle_Geom_Curve C3D, gp_Pnt P3D, Standard_Real const preci, gp_Pnt proj, Standard_Real const cf, Standard_Real const cl, Standard_Boolean const AdjustToEnds) -> Standard_Real

        Projects a Point on a Curve, but parameters are limited
        between <cf> and <cl>.
        The range [cf, cl] is extended with help of Adaptor3d on the
        basis of 3d precision <preci>.
        If AdjustToEnds is True, point will be adjusted to the end
        of the curve if distance is less than <preci>

        :type C3D: OCC.wrapper.Geom.Handle_Geom_Curve
        :type P3D: OCC.wrapper.gp.gp_Pnt
        :type preci: float
        :type proj: OCC.wrapper.gp.gp_Pnt
        :type param: float
        :type cf: float
        :type cl: float
        :type AdjustToEnds: bool
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_Curve_Project(self, *args)


    def ProjectAct(self, *args):
        """
        ProjectAct(ShapeAnalysis_Curve self, Adaptor3d_Curve C3D, gp_Pnt P3D, Standard_Real const preci, gp_Pnt proj) -> Standard_Real

        :type C3D: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type P3D: OCC.wrapper.gp.gp_Pnt
        :type preci: float
        :type proj: OCC.wrapper.gp.gp_Pnt
        :type param: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_Curve_ProjectAct(self, *args)


    def NextProject(self, *args):
        """
        NextProject(ShapeAnalysis_Curve self, Standard_Real const paramPrev, Handle_Geom_Curve C3D, gp_Pnt P3D, Standard_Real const preci, gp_Pnt proj, Standard_Real const cf, Standard_Real const cl, Standard_Boolean const AdjustToEnds) -> Standard_Real
        NextProject(ShapeAnalysis_Curve self, Standard_Real const paramPrev, Adaptor3d_Curve C3D, gp_Pnt P3D, Standard_Real const preci, gp_Pnt proj) -> Standard_Real

        Projects a Point on a Curve using Newton method.
        <paramPrev> is taken as the first approximation of solution.
        If Newton algorithm fails the method Project() is used.

        :type paramPrev: float
        :type C3D: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type P3D: OCC.wrapper.gp.gp_Pnt
        :type preci: float
        :type proj: OCC.wrapper.gp.gp_Pnt
        :type param: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_Curve_NextProject(self, *args)


    def ValidateRange(self, *args):
        """
        ValidateRange(ShapeAnalysis_Curve self, Handle_Geom_Curve Crv, Standard_Real const prec) -> Standard_Boolean

        Validate parameters First and Last for the given curve
        in order to make them valid for creation of edge.
        This includes:
        - limiting range [First,Last] by range of curve
        - adjusting range [First,Last] for periodic (or closed)
        curve if Last < First
        Returns True if parameters are OK or are successfully
        corrected, or False if parameters cannot be corrected.
        In the latter case, parameters are reset to range of curve.

        :type Crv: OCC.wrapper.Geom.Handle_Geom_Curve
        :type First: float
        :type Last: float
        :type prec: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Curve_ValidateRange(self, *args)


    def FillBndBox(self, *args):
        """
        FillBndBox(ShapeAnalysis_Curve self, Handle_Geom2d_Curve C2d, Standard_Real const First, Standard_Real const Last, Standard_Integer const NPoints, Standard_Boolean const Exact, Bnd_Box2d Box)

        Computes a boundary box on segment of curve C2d from First
        to Last. This is done by taking NPoints points from the
        curve and, if Exact is True, by searching for exact
        extrema. All these points are added to Box.

        :type C2d: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type First: float
        :type Last: float
        :type NPoints: int
        :type Exact: bool
        :type Box: OCC.wrapper.Bnd.Bnd_Box2d

        """
        return _ShapeAnalysis.ShapeAnalysis_Curve_FillBndBox(self, *args)


    def SelectForwardSeam(self, *args):
        """
        SelectForwardSeam(ShapeAnalysis_Curve self, Handle_Geom2d_Curve C1, Handle_Geom2d_Curve C2) -> Standard_Integer

        Defines which pcurve (C1 or C2) should be chosen for FORWARD
        seam edge.

        :type C1: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type C2: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_Curve_SelectForwardSeam(self, *args)


    def IsPlanar(*args):
        """
        IsPlanar(NCollection_Array1_gp_Pnt pnts, gp_XYZ Normal, Standard_Real const preci=0) -> Standard_Boolean
        IsPlanar(Handle_Geom_Curve curve, gp_XYZ Normal, Standard_Real const preci=0) -> Standard_Boolean

        Checks if curve is planar with given preci. If Normal has not zero
        modulus, checks with given normal

        :type curve: OCC.wrapper.Geom.Handle_Geom_Curve
        :type Normal: OCC.wrapper.gp.gp_XYZ
        :type preci: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Curve_IsPlanar(*args)

    IsPlanar = staticmethod(IsPlanar)

    def GetSamplePoints(*args):
        """
        GetSamplePoints(Handle_Geom2d_Curve curve, Standard_Real const first, Standard_Real const last, NCollection_Sequence_gp_Pnt2d seq) -> Standard_Boolean
        GetSamplePoints(Handle_Geom_Curve curve, Standard_Real const first, Standard_Real const last, NCollection_Sequence_gp_Pnt seq) -> Standard_Boolean

        Returns sample points which will serve as linearisation
        of the curve in range (first, last)

        :type curve: OCC.wrapper.Geom.Handle_Geom_Curve
        :type first: float
        :type last: float
        :type seq: OCC.wrapper.TColgp.TColgp_SequenceOfPnt
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Curve_GetSamplePoints(*args)

    GetSamplePoints = staticmethod(GetSamplePoints)

    def IsClosed(*args):
        """
        IsClosed(Handle_Geom_Curve curve, Standard_Real const preci=-1) -> Standard_Boolean

        Tells if the Curve is closed with given precision.
        If <preci> < 0 then Precision::Confusion is used.

        :type curve: OCC.wrapper.Geom.Handle_Geom_Curve
        :type preci: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Curve_IsClosed(*args)

    IsClosed = staticmethod(IsClosed)

    def IsPeriodic(*args):
        """
        IsPeriodic(Handle_Geom_Curve curve) -> Standard_Boolean
        IsPeriodic(Handle_Geom2d_Curve curve) -> Standard_Boolean

        The same as for Curve3d.

        :type curve: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_Curve_IsPeriodic(*args)

    IsPeriodic = staticmethod(IsPeriodic)

    def __init__(self):
        """
        Analyzing tool for 2d or 3d curve.
        Computes parameters of projected point onto a curve.
        """
        this = _ShapeAnalysis.new_ShapeAnalysis_Curve()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_Curve
ShapeAnalysis_Curve_swigregister = _ShapeAnalysis.ShapeAnalysis_Curve_swigregister
ShapeAnalysis_Curve_swigregister(ShapeAnalysis_Curve)

def ShapeAnalysis_Curve_IsPlanar(*args):
    """
    IsPlanar(NCollection_Array1_gp_Pnt pnts, gp_XYZ Normal, Standard_Real const preci=0) -> Standard_Boolean
    ShapeAnalysis_Curve_IsPlanar(Handle_Geom_Curve curve, gp_XYZ Normal, Standard_Real const preci=0) -> Standard_Boolean

    Checks if curve is planar with given preci. If Normal has not zero
    modulus, checks with given normal

    :type curve: OCC.wrapper.Geom.Handle_Geom_Curve
    :type Normal: OCC.wrapper.gp.gp_XYZ
    :type preci: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _ShapeAnalysis.ShapeAnalysis_Curve_IsPlanar(*args)

def ShapeAnalysis_Curve_GetSamplePoints(*args):
    """
    GetSamplePoints(Handle_Geom2d_Curve curve, Standard_Real const first, Standard_Real const last, NCollection_Sequence_gp_Pnt2d seq) -> Standard_Boolean
    ShapeAnalysis_Curve_GetSamplePoints(Handle_Geom_Curve curve, Standard_Real const first, Standard_Real const last, NCollection_Sequence_gp_Pnt seq) -> Standard_Boolean

    Returns sample points which will serve as linearisation
    of the curve in range (first, last)

    :type curve: OCC.wrapper.Geom.Handle_Geom_Curve
    :type first: float
    :type last: float
    :type seq: OCC.wrapper.TColgp.TColgp_SequenceOfPnt
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _ShapeAnalysis.ShapeAnalysis_Curve_GetSamplePoints(*args)

def ShapeAnalysis_Curve_IsClosed(*args):
    """
    ShapeAnalysis_Curve_IsClosed(Handle_Geom_Curve curve, Standard_Real const preci=-1) -> Standard_Boolean

    Tells if the Curve is closed with given precision.
    If <preci> < 0 then Precision::Confusion is used.

    :type curve: OCC.wrapper.Geom.Handle_Geom_Curve
    :type preci: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _ShapeAnalysis.ShapeAnalysis_Curve_IsClosed(*args)

def ShapeAnalysis_Curve_IsPeriodic(*args):
    """
    IsPeriodic(Handle_Geom_Curve curve) -> Standard_Boolean
    ShapeAnalysis_Curve_IsPeriodic(Handle_Geom2d_Curve curve) -> Standard_Boolean

    The same as for Curve3d.

    :type curve: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _ShapeAnalysis.ShapeAnalysis_Curve_IsPeriodic(*args)

class Handle_ShapeAnalysis_Surface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeAnalysis_Surface self)

        Nullify the handle


        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeAnalysis_Surface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeAnalysis_Surface self, ShapeAnalysis_Surface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeAnalysis_Surface self, Handle_ShapeAnalysis_Surface theHandle) -> Handle_ShapeAnalysis_Surface
        assign(Handle_ShapeAnalysis_Surface self, ShapeAnalysis_Surface thePtr) -> Handle_ShapeAnalysis_Surface
        assign(Handle_ShapeAnalysis_Surface self, Handle_ShapeAnalysis_Surface theHandle) -> Handle_ShapeAnalysis_Surface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeAnalysis_Surface self) -> ShapeAnalysis_Surface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeAnalysis_Surface self) -> ShapeAnalysis_Surface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeAnalysis_Surface self) -> ShapeAnalysis_Surface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface___ref__(self, *args)


    def __hash__(self):
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeAnalysis.Handle_ShapeAnalysis_Surface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeAnalysis.new_Handle_ShapeAnalysis_Surface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeAnalysis.Handle_ShapeAnalysis_Surface_DownCast)
    __swig_destroy__ = _ShapeAnalysis.delete_Handle_ShapeAnalysis_Surface

    def Init(self, *args):
        """
        Init(Handle_ShapeAnalysis_Surface self, Handle_Geom_Surface S)
        Init(Handle_ShapeAnalysis_Surface self, Handle_ShapeAnalysis_Surface other)

        Reads all the data from another Surface, without recomputing

        :type other: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_Surface

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_Init(self, *args)


    def SetDomain(self, *args):
        """
        SetDomain(Handle_ShapeAnalysis_Surface self, Standard_Real const U1, Standard_Real const U2, Standard_Real const V1, Standard_Real const V2)

        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_SetDomain(self, *args)


    def Surface(self, *args):
        """
        Returns a surface being analyzed

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _ShapeAnalysis.Handle_ShapeAnalysis_Surface_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Adaptor3d(self, *args):
        """
        Returns the Adaptor.
        Creates it if not yet done.

        :rtype: OCC.wrapper.GeomAdaptor.Handle_GeomAdaptor_HSurface

        """
        res = _ShapeAnalysis.Handle_ShapeAnalysis_Surface_Adaptor3d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TrueAdaptor3d(self, *args):
        """
        Returns the Adaptor (may be Null if method Adaptor() was not called)

        :rtype: OCC.wrapper.GeomAdaptor.Handle_GeomAdaptor_HSurface

        """
        res = _ShapeAnalysis.Handle_ShapeAnalysis_Surface_TrueAdaptor3d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Gap(self, *args):
        """
        Gap(Handle_ShapeAnalysis_Surface self) -> Standard_Real

        Returns 3D distance found by one of the following methods.
        IsDegenerated, DegeneratedValues, ProjectDegenerated
        (distance between 3D point and found or last (if not found)
        singularity),
        IsUClosed, IsVClosed (minimum value of precision to consider
        the surface to be closed),
        ValueOfUV (distance between 3D point and found solution).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_Gap(self, *args)


    def Value(self, *args):
        """
        Value(Handle_ShapeAnalysis_Surface self, Standard_Real const u, Standard_Real const v) -> gp_Pnt
        Value(Handle_ShapeAnalysis_Surface self, gp_Pnt2d p2d) -> gp_Pnt

        Returns a 3d point specified by a point in surface
        parametrical space

        :type p2d: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_Value(self, *args)


    def HasSingularities(self, *args):
        """
        HasSingularities(Handle_ShapeAnalysis_Surface self, Standard_Real const preci) -> Standard_Boolean

        Returns True if the surface has singularities for the given
        precision (i.e. if there are surface singularities with sizes
        not greater than precision).

        :type preci: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_HasSingularities(self, *args)


    def NbSingularities(self, *args):
        """
        NbSingularities(Handle_ShapeAnalysis_Surface self, Standard_Real const preci) -> Standard_Integer

        Returns the number of singularities for the given precision
        (i.e. number of surface singularities with sizes not greater
        than precision).

        :type preci: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_NbSingularities(self, *args)


    def Singularity(self, *args):
        """
        Singularity(Handle_ShapeAnalysis_Surface self, Standard_Integer const num, gp_Pnt P3d, gp_Pnt2d firstP2d, gp_Pnt2d lastP2d) -> Standard_Boolean

        Returns the characteristics of the singularity specified by
        its rank number <num>.
        That means, that it is not neccessary for <num> to be in the
        range [1, NbSingularities] but must be not greater than
        possible (see ComputeSingularities).
        The returned characteristics are:
        preci: the smallest precision with which the iso-line is
        considered as degenerated,
        P3d: 3D point of singularity (middle point of the surface
        iso-line),
        firstP2d and lastP2d: first and last 2D points of the
        iso-line in parametrical surface,
        firstpar and lastpar: first and last parameters of the
        iso-line in parametrical surface,
        uisodeg: if the degenerated iso-line is U-iso (True) or
        V-iso (False).
        Returns False if <num> is out of range, else returns True.

        :type num: int
        :type preci: float
        :type P3d: OCC.wrapper.gp.gp_Pnt
        :type firstP2d: OCC.wrapper.gp.gp_Pnt2d
        :type lastP2d: OCC.wrapper.gp.gp_Pnt2d
        :type firstpar: float
        :type lastpar: float
        :type uisodeg: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_Singularity(self, *args)


    def IsDegenerated(self, *args):
        """
        IsDegenerated(Handle_ShapeAnalysis_Surface self, gp_Pnt P3d, Standard_Real const preci) -> Standard_Boolean
        IsDegenerated(Handle_ShapeAnalysis_Surface self, gp_Pnt2d p2d1, gp_Pnt2d p2d2, Standard_Real const tol, Standard_Real const ratio) -> Standard_Boolean

        Returns True if straight pcurve going from point p2d1 to p2d2
        is degenerate, i.e. lies in the singularity of the surface.
        NOTE: it uses another method of detecting singularity than
        used by ComputeSingularities() et al.!
        For that, maximums of distances between points p2d1, p2d2
        and 0.5*(p2d1+p2d2) and between corresponding 3d points are
        computed.
        The pcurve (p2d1, p2d2) is considered as degenerate if:
        - max distance in 3d is less than <tol>
        - max distance in 2d is at least <ratio> times greather than
        the Resolution computed from max distance in 3d
        (max3d < tol && max2d > ratio * Resolution(max3d))
        NOTE: <ratio> should be >1 (e.g. 10)

        :type p2d1: OCC.wrapper.gp.gp_Pnt2d
        :type p2d2: OCC.wrapper.gp.gp_Pnt2d
        :type tol: float
        :type ratio: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_IsDegenerated(self, *args)


    def DegeneratedValues(self, *args):
        """
        DegeneratedValues(Handle_ShapeAnalysis_Surface self, gp_Pnt P3d, Standard_Real const preci, gp_Pnt2d firstP2d, gp_Pnt2d lastP2d, Standard_Boolean const forward) -> Standard_Boolean

        Returns True if there is at least one surface iso-line which
        is considered as degenerated with <preci> and distance
        between P3d and corresponding singular point is less than
        <preci> (like IsDegenerated).
        Returns characteristics of the first found boundary matching
        those criteria.

        :type P3d: OCC.wrapper.gp.gp_Pnt
        :type preci: float
        :type firstP2d: OCC.wrapper.gp.gp_Pnt2d
        :type lastP2d: OCC.wrapper.gp.gp_Pnt2d
        :type firstpar: float
        :type lastpar: float
        :type forward: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_DegeneratedValues(self, *args)


    def ProjectDegenerated(self, *args):
        """
        ProjectDegenerated(Handle_ShapeAnalysis_Surface self, gp_Pnt P3d, Standard_Real const preci, gp_Pnt2d neighbour, gp_Pnt2d result) -> Standard_Boolean
        ProjectDegenerated(Handle_ShapeAnalysis_Surface self, Standard_Integer const nbrPnt, NCollection_Sequence_gp_Pnt points, NCollection_Sequence_gp_Pnt2d pnt2d, Standard_Real const preci, Standard_Boolean const direct) -> Standard_Boolean

        Checks points at the beginning (direct is True) or end
        (direct is False) of array <points> to lie in singularity of
        surface, and if yes, adjusts the indeterminate 2d coordinate
        of these points by nearest point which is not in singularity.
        Returns True if some points were adjusted.

        :type nbrPnt: int
        :type points: OCC.wrapper.TColgp.TColgp_SequenceOfPnt
        :type pnt2d: OCC.wrapper.TColgp.TColgp_SequenceOfPnt2d
        :type preci: float
        :type direct: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_ProjectDegenerated(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_ShapeAnalysis_Surface self)

        Returns the bounds of the surface
        (from Bounds from Surface, but buffered)

        :type ufirst: float
        :type ulast: float
        :type vfirst: float
        :type vlast: float

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_Bounds(self, *args)


    def ComputeBoundIsos(self, *args):
        """
        ComputeBoundIsos(Handle_ShapeAnalysis_Surface self)

        Computes bound isos (protected against exceptions)


        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_ComputeBoundIsos(self, *args)


    def UIso(self, *args):
        """
        UIso(Handle_ShapeAnalysis_Surface self, Standard_Real const U) -> Handle_Geom_Curve

        Returns a U-Iso. Null if not possible or failed
        Remark : bound isos are buffered

        :type U: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_UIso(self, *args)


    def VIso(self, *args):
        """
        VIso(Handle_ShapeAnalysis_Surface self, Standard_Real const V) -> Handle_Geom_Curve

        Returns a V-Iso. Null if not possible or failed
        Remark : bound isos are buffered

        :type V: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_VIso(self, *args)


    def IsUClosed(self, *args):
        """
        IsUClosed(Handle_ShapeAnalysis_Surface self, Standard_Real const preci=-1) -> Standard_Boolean

        Tells if the Surface is spatially closed in U with given
        precision. If <preci> < 0 then Precision::Confusion is used.
        If Geom_Surface says that the surface is U-closed, this method
        also says this. Otherwise additional analysis is performed,
        comparing given precision with the following distances:
        - periodic B-Splines are closed,
        - polinomial B-Spline with boundary multiplicities degree+1
        and Bezier - maximum distance between poles,
        - rational B-Spline or one with boundary multiplicities not
        degree+1 - maximum distance computed at knots and their
        middles,
        - surface of extrusion - distance between ends of basis
        curve,
        - other (RectangularTrimmed and Offset) - maximum distance
        computed at 100 equi-distanted points.

        :type preci: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_IsUClosed(self, *args)


    def IsVClosed(self, *args):
        """
        IsVClosed(Handle_ShapeAnalysis_Surface self, Standard_Real const preci=-1) -> Standard_Boolean

        Tells if the Surface is spatially closed in V with given
        precision. If <preci> < 0 then Precision::Confusion is used.
        If Geom_Surface says that the surface is V-closed, this method
        also says this. Otherwise additional analysis is performed,
        comparing given precision with the following distances:
        - periodic B-Splines are closed,
        - polinomial B-Spline with boundary multiplicities degree+1
        and Bezier - maximum distance between poles,
        - rational B-Spline or one with boundary multiplicities not
        degree+1 - maximum distance computed at knots and their
        middles,
        - surface of revolution - distance between ends of basis
        curve,
        - other (RectangularTrimmed and Offset) - maximum distance
        computed at 100 equi-distanted points.

        :type preci: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_IsVClosed(self, *args)


    def ValueOfUV(self, *args):
        """
        ValueOfUV(Handle_ShapeAnalysis_Surface self, gp_Pnt P3D, Standard_Real const preci) -> gp_Pnt2d

        Computes the parameters in the surface parametrical space of
        3D point.
        The result is parameters of the point projected onto the
        surface.
        This method enhances functionality provided by the standard
        tool GeomAPI_ProjectPointOnSurface by treatment of cases when
        the projected point is near to the surface boundaries and
        when this standard tool fails.

        :type P3D: OCC.wrapper.gp.gp_Pnt
        :type preci: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_ValueOfUV(self, *args)


    def NextValueOfUV(self, *args):
        """
        NextValueOfUV(Handle_ShapeAnalysis_Surface self, gp_Pnt2d p2dPrev, gp_Pnt P3D, Standard_Real const preci, Standard_Real const maxpreci=-1.0) -> gp_Pnt2d

        Projects a point P3D on the surface.
        Does the same thing as ValueOfUV but tries to optimize
        computations by taking into account previous point <p2dPrev>:
        makes a step by UV and tries Newton algorithm.
        If <maxpreci> >0. and distance between solution and
        P3D is greater than <maxpreci>, that solution is considered
        as bad, and ValueOfUV() is used.
        If not succeded, calls ValueOfUV()

        :type p2dPrev: OCC.wrapper.gp.gp_Pnt2d
        :type P3D: OCC.wrapper.gp.gp_Pnt
        :type preci: float
        :type maxpreci: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_NextValueOfUV(self, *args)


    def UVFromIso(self, *args):
        """
        UVFromIso(Handle_ShapeAnalysis_Surface self, gp_Pnt P3D, Standard_Real const preci) -> Standard_Real

        Tries a refinement of an already computed couple (U,V) by
        using projecting 3D point on iso-lines:
        1. boundaries of the surface,
        2. iso-lines passing through (U,V)
        3. iteratively received iso-lines passing through new U and
        new V (number of iterations is limited by 5 in each
        direction)
        Returns the best resulting distance between P3D and Value(U,V)
        in the case of success. Else, returns a very great value

        :type P3D: OCC.wrapper.gp.gp_Pnt
        :type preci: float
        :type U: float
        :type V: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_UVFromIso(self, *args)


    def UCloseVal(self, *args):
        """
        UCloseVal(Handle_ShapeAnalysis_Surface self) -> Standard_Real

        Returns minimum value to consider the surface as U-closed

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_UCloseVal(self, *args)


    def VCloseVal(self, *args):
        """
        VCloseVal(Handle_ShapeAnalysis_Surface self) -> Standard_Real

        Returns minimum value to consider the surface as V-closed

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_VCloseVal(self, *args)


    def GetBoxUF(self, *args):
        """
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        res = _ShapeAnalysis.Handle_ShapeAnalysis_Surface_GetBoxUF(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetBoxUL(self, *args):
        """
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        res = _ShapeAnalysis.Handle_ShapeAnalysis_Surface_GetBoxUL(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetBoxVF(self, *args):
        """
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        res = _ShapeAnalysis.Handle_ShapeAnalysis_Surface_GetBoxVF(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetBoxVL(self, *args):
        """
        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        res = _ShapeAnalysis.Handle_ShapeAnalysis_Surface_GetBoxVL(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeAnalysis_Surface self) -> char const *

        :rtype: const char *

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeAnalysis.Handle_ShapeAnalysis_Surface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeAnalysis.Handle_ShapeAnalysis_Surface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ShapeAnalysis_Surface self)

        Memory deallocator for transient classes


        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeAnalysis_Surface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeAnalysis_Surface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeAnalysis_Surface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeAnalysis_Surface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeAnalysis_Surface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeAnalysis_Surface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeAnalysis_Surface self)

        Increments the reference counter of this object


        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeAnalysis_Surface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_DecrementRefCounter(self, *args)

Handle_ShapeAnalysis_Surface_swigregister = _ShapeAnalysis.Handle_ShapeAnalysis_Surface_swigregister
Handle_ShapeAnalysis_Surface_swigregister(Handle_ShapeAnalysis_Surface)

def Handle_ShapeAnalysis_Surface_DownCast(thing):
    return _ShapeAnalysis.Handle_ShapeAnalysis_Surface_DownCast(thing)
Handle_ShapeAnalysis_Surface_DownCast = _ShapeAnalysis.Handle_ShapeAnalysis_Surface_DownCast

class NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TColStd_ListOfReal,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _ShapeAnalysis.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TColStd_ListOfReal,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _ShapeAnalysis.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TColStd_ListOfReal,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _ShapeAnalysis.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TColStd_ListOfReal,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _ShapeAnalysis.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _ShapeAnalysis.new_NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _ShapeAnalysis.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _ShapeAnalysis.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _ShapeAnalysis.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _ShapeAnalysis.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_List_Standard_Real theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_List_Standard_Real theItem) -> NCollection_List_Standard_Real

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _ShapeAnalysis.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_List_Standard_Real

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _ShapeAnalysis.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _ShapeAnalysis.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_List_Standard_Real

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _ShapeAnalysis.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_List_Standard_Real

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _ShapeAnalysis.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _ShapeAnalysis.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _ShapeAnalysis.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _ShapeAnalysis.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _ShapeAnalysis.delete_NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_swigregister = _ShapeAnalysis.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _ShapeAnalysis.new_NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeAnalysis.delete_NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _ShapeAnalysis.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _ShapeAnalysis.NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher_IteratorHelper)


try:
	ShapeAnalysis_DataMapOfShapeListOfReal = NCollection_DataMap_TopoDS_Shape_TColStd_ListOfReal_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class ShapeAnalysis_WireOrder(object):
    """
    This class is intended to control and, if possible, redefine
    the order of a list of edges which define a wire
    Edges are not given directly, but as their bounds (start,end)

    This allows to use this tool, either on existing wire, or on
    data just taken from a file (coordinates are easy to get)

    It can work, either in 2D, or in 3D, but not miscible
    Warning about tolerance : according to the mode (2D/3D), it
    must be given as 2D or 3D (i.e. metric) tolerance, uniform
    on the whole list

    Two phases : firstly add the couples (start,end)
    secondly perform then get the result
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeAnalysis_WireOrder self) -> ShapeAnalysis_WireOrder
        __init__(ShapeAnalysis_WireOrder self, Standard_Boolean const mode3d, Standard_Real const tol) -> ShapeAnalysis_WireOrder

        Creates a WireOrder in 3D (if mode3d is True) or 2D (if False)
        with a tolerance

        :type mode3d: bool
        :type tol: float

        """
        this = _ShapeAnalysis.new_ShapeAnalysis_WireOrder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetMode(self, *args):
        """
        SetMode(ShapeAnalysis_WireOrder self, Standard_Boolean const mode3d, Standard_Real const tol)

        Sets new values. Clears the connexion list
        If <mode3d> changes, also clears the edge list (else, doesnt)

        :type mode3d: bool
        :type tol: float

        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_SetMode(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(ShapeAnalysis_WireOrder self) -> Standard_Real

        Returns the working tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_Tolerance(self, *args)


    def Clear(self, *args):
        """
        Clear(ShapeAnalysis_WireOrder self)

        Clears the list of edges, but not mode and tol


        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_Clear(self, *args)


    def Add(self, *args):
        """
        Add(ShapeAnalysis_WireOrder self, gp_XYZ start3d, gp_XYZ end3d)
        Add(ShapeAnalysis_WireOrder self, gp_XY start2d, gp_XY end2d)

        Adds a couple of points 2D (start,end)

        :type start2d: OCC.wrapper.gp.gp_XY
        :type end2d: OCC.wrapper.gp.gp_XY

        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_Add(self, *args)


    def NbEdges(self, *args):
        """
        NbEdges(ShapeAnalysis_WireOrder self) -> Standard_Integer

        Returns the count of added couples of points (one per edges)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_NbEdges(self, *args)


    def KeepLoopsMode(self, *args):
        """
        KeepLoopsMode(ShapeAnalysis_WireOrder self) -> Standard_Boolean &

        If this mode is True method perform does not sort edges of
        different loops. The resulting order is first loop, second
        one etc...

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_KeepLoopsMode(self, *args)


    def Perform(self, *args):
        """
        Perform(ShapeAnalysis_WireOrder self, Standard_Boolean const closed)

        Computes the better order
        If <closed> is True (D) considers also closure
        Optimised if the couples were already in order
        The criterium is : two couples in order if distance between
        end-prec and start-cur is less then starting tolerance <tol>
        Else, the smallest distance is reached
        Gap corresponds to a smallest distance greater than <tol>

        :type closed: bool

        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(ShapeAnalysis_WireOrder self) -> Standard_Boolean

        Tells if Perform has been done
        Else, the following methods returns original values

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_IsDone(self, *args)


    def Status(self, *args):
        """
        Status(ShapeAnalysis_WireOrder self) -> Standard_Integer

        Returns the status of the order (0 if not done) :
        0 : all edges are direct and in sequence
        1 : all edges are direct but some are not in sequence
        2 : in addition, unresolved gaps remain
        -1 : some edges are reversed, but no gap remain
        -2 : some edges are reversed and some gaps remain
        -10 : COULD NOT BE RESOLVED, Failure on Reorder
        gap : regarding starting <tol>

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_Status(self, *args)


    def Ordered(self, *args):
        """
        Ordered(ShapeAnalysis_WireOrder self, Standard_Integer const n) -> Standard_Integer

        Returns the number of original edge which correspond to the
        newly ordered number <n>
        Warning : the returned value is NEGATIVE if edge should be reversed

        :type n: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_Ordered(self, *args)


    def XYZ(self, *args):
        """
        XYZ(ShapeAnalysis_WireOrder self, Standard_Integer const num, gp_XYZ start3d, gp_XYZ end3d)

        Returns the values of the couple <num>, as 3D values

        :type num: int
        :type start3d: OCC.wrapper.gp.gp_XYZ
        :type end3d: OCC.wrapper.gp.gp_XYZ

        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_XYZ(self, *args)


    def XY(self, *args):
        """
        XY(ShapeAnalysis_WireOrder self, Standard_Integer const num, gp_XY start2d, gp_XY end2d)

        Returns the values of the couple <num>, as 2D values

        :type num: int
        :type start2d: OCC.wrapper.gp.gp_XY
        :type end2d: OCC.wrapper.gp.gp_XY

        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_XY(self, *args)


    def Gap(self, *args):
        """
        Gap(ShapeAnalysis_WireOrder self, Standard_Integer const num=0) -> Standard_Real

        Returns the gap between a couple and its preceeding
        <num> is considered ordered
        If <num> = 0 (D), returns the greatest gap found

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_Gap(self, *args)


    def SetChains(self, *args):
        """
        SetChains(ShapeAnalysis_WireOrder self, Standard_Real const gap)

        Determines the chains inside which successive edges have a gap
        less than a given value. Queried by NbChains and Chain

        :type gap: float

        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_SetChains(self, *args)


    def NbChains(self, *args):
        """
        NbChains(ShapeAnalysis_WireOrder self) -> Standard_Integer

        Returns the count of computed chains

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_NbChains(self, *args)


    def Chain(self, *args):
        """
        Chain(ShapeAnalysis_WireOrder self, Standard_Integer const num)

        Returns, for the chain n0 num, starting and ending numbers of
        edges. In the list of ordered edges (see Ordered for originals)

        :type num: int
        :type n1: int
        :type n2: int

        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_Chain(self, *args)


    def SetCouples(self, *args):
        """
        SetCouples(ShapeAnalysis_WireOrder self, Standard_Real const gap)

        Determines the couples of edges for which end and start fit
        inside a given gap. Queried by NbCouples and Couple

        :type gap: float

        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_SetCouples(self, *args)


    def NbCouples(self, *args):
        """
        NbCouples(ShapeAnalysis_WireOrder self) -> Standard_Integer

        Returns the count of computed couples

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_NbCouples(self, *args)


    def Couple(self, *args):
        """
        Couple(ShapeAnalysis_WireOrder self, Standard_Integer const num)

        Returns, for the couple n0 num, the two implied edges
        In the list of ordered edges

        :type num: int
        :type n1: int
        :type n2: int

        """
        return _ShapeAnalysis.ShapeAnalysis_WireOrder_Couple(self, *args)

    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_WireOrder
ShapeAnalysis_WireOrder_swigregister = _ShapeAnalysis.ShapeAnalysis_WireOrder_swigregister
ShapeAnalysis_WireOrder_swigregister(ShapeAnalysis_WireOrder)


try:
	TColStd_ListOfReal = TColStd.NCollection_List_Standard_Real
except AttributeError:
	pass # does not exist, probably ignored

class Handle_ShapeAnalysis_Wire(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeAnalysis_Wire self)

        Nullify the handle


        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeAnalysis_Wire self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeAnalysis_Wire self, ShapeAnalysis_Wire thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeAnalysis_Wire self, Handle_ShapeAnalysis_Wire theHandle) -> Handle_ShapeAnalysis_Wire
        assign(Handle_ShapeAnalysis_Wire self, ShapeAnalysis_Wire thePtr) -> Handle_ShapeAnalysis_Wire
        assign(Handle_ShapeAnalysis_Wire self, Handle_ShapeAnalysis_Wire theHandle) -> Handle_ShapeAnalysis_Wire

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeAnalysis_Wire self) -> ShapeAnalysis_Wire

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeAnalysis_Wire self) -> ShapeAnalysis_Wire

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeAnalysis_Wire self) -> ShapeAnalysis_Wire

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire___ref__(self, *args)


    def __hash__(self):
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeAnalysis.Handle_ShapeAnalysis_Wire___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeAnalysis.new_Handle_ShapeAnalysis_Wire(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeAnalysis.Handle_ShapeAnalysis_Wire_DownCast)
    __swig_destroy__ = _ShapeAnalysis.delete_Handle_ShapeAnalysis_Wire

    def Init(self, *args):
        """
        Init(Handle_ShapeAnalysis_Wire self, TopoDS_Wire wire, TopoDS_Face face, Standard_Real const precision)
        Init(Handle_ShapeAnalysis_Wire self, Handle_ShapeExtend_WireData sbwd, TopoDS_Face face, Standard_Real const precision)

        Initializes the object with WireData object, face
        and precision

        :type sbwd: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_WireData
        :type face: OCC.wrapper.TopoDS.TopoDS_Face
        :type precision: float

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_Init(self, *args)


    def Load(self, *args):
        """
        Load(Handle_ShapeAnalysis_Wire self, TopoDS_Wire wire)
        Load(Handle_ShapeAnalysis_Wire self, Handle_ShapeExtend_WireData sbwd)

        Loads the object with WireData object

        :type sbwd: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_WireData

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_Load(self, *args)


    def SetFace(self, *args):
        """
        SetFace(Handle_ShapeAnalysis_Wire self, TopoDS_Face face)

        Loads the face the wire lies on

        :type face: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_SetFace(self, *args)


    def SetSurface(self, *args):
        """
        SetSurface(Handle_ShapeAnalysis_Wire self, Handle_Geom_Surface surface)
        SetSurface(Handle_ShapeAnalysis_Wire self, Handle_Geom_Surface surface, TopLoc_Location location)

        Loads the surface the wire lies on

        :type surface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type location: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_SetSurface(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(Handle_ShapeAnalysis_Wire self, Standard_Real const precision)

        :type precision: float

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_SetPrecision(self, *args)


    def ClearStatuses(self, *args):
        """
        ClearStatuses(Handle_ShapeAnalysis_Wire self)

        Unsets all the status and distance fields
        wire, face and precision are not cleared


        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_ClearStatuses(self, *args)


    def IsLoaded(self, *args):
        """
        IsLoaded(Handle_ShapeAnalysis_Wire self) -> Standard_Boolean

        Returns True if wire is loaded and has number of edges >0

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_IsLoaded(self, *args)


    def IsReady(self, *args):
        """
        IsReady(Handle_ShapeAnalysis_Wire self) -> Standard_Boolean

        Returns True if IsLoaded and underlying face is not null

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_IsReady(self, *args)


    def Precision(self, *args):
        """
        Precision(Handle_ShapeAnalysis_Wire self) -> Standard_Real

        Returns the value of precision

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_Precision(self, *args)


    def WireData(self, *args):
        """
        Returns wire object being analyzed

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_WireData

        """
        res = _ShapeAnalysis.Handle_ShapeAnalysis_Wire_WireData(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbEdges(self, *args):
        """
        NbEdges(Handle_ShapeAnalysis_Wire self) -> Standard_Integer

        Returns the number of edges in the wire, or 0 if it is not loaded

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_NbEdges(self, *args)


    def Face(self, *args):
        """
        Returns the working face

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _ShapeAnalysis.Handle_ShapeAnalysis_Wire_Face(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface(self, *args):
        """
        Returns the working surface

        :rtype: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_Surface

        """
        res = _ShapeAnalysis.Handle_ShapeAnalysis_Wire_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Perform(self, *args):
        """
        Perform(Handle_ShapeAnalysis_Wire self) -> Standard_Boolean

        Performs all the checks in the following order :
        CheckOrder, CheckSmall, CheckConected, CheckEdgeCurves,
        CheckDegenerated, CheckSelfIntersection, CheckLacking,
        CheckClosed
        Returns: True if at least one method returned True;
        For deeper analysis use Status...(status) methods

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_Perform(self, *args)


    def CheckOrder(self, *args):
        """
        CheckOrder(Handle_ShapeAnalysis_Wire self, Standard_Boolean const isClosed, Standard_Boolean const mode3d) -> Standard_Boolean
        CheckOrder(Handle_ShapeAnalysis_Wire self, ShapeAnalysis_WireOrder sawo, Standard_Boolean const isClosed, Standard_Boolean const mode3d) -> Standard_Boolean

        Analyzes the order of the edges in the wire,
        uses class WireOrder for that purpose.
        Flag <isClosed> defines if the wire is closed or not
        Flag <mode3d> defines which mode is used (3d or 2d)
        Returns False if wire is already ordered (tail-to-head),
        True otherwise.
        Use returned WireOrder object for deeper analysis.
        Status:
        OK   : the same edges orientation, the same edges sequence
        DONE1: the same edges orientation, not the same edges sequence
        DONE2: as DONE1 and gaps more than myPrecision
        DONE3: not the same edges orientation (some need to be reversed)
        DONE4: as DONE3 and gaps more than myPrecision
        FAIL : algorithm failed (could not detect order)

        :type sawo: OCC.wrapper.ShapeAnalysis.ShapeAnalysis_WireOrder
        :type isClosed: bool
        :type mode3d: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_CheckOrder(self, *args)


    def CheckConnected(self, *args):
        """
        CheckConnected(Handle_ShapeAnalysis_Wire self, Standard_Real const prec=0.0) -> Standard_Boolean
        CheckConnected(Handle_ShapeAnalysis_Wire self, Standard_Integer const num, Standard_Real const prec=0.0) -> Standard_Boolean

        Checks connected edges (num-th and preceeding).
        Tests with starting preci from <SBWD> or  with <prec> if
        it is greater.
        Considers Vertices.
        Returns: False if edges are connected by the common vertex, else True
        Status  :
        OK    : Vertices (end of num-1 th edge and start on num-th one)
        are already the same
        DONE1 : Absolutely confused (gp::Resolution)
        DONE2 : Confused at starting <preci> from <SBWD>
        DONE3 : Confused at <prec> but not <preci>
        FAIL1 : Not confused
        FAIL2 : Not confused but confused with <preci> if reverse num-th edge

        :type num: int
        :type prec: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_CheckConnected(self, *args)


    def CheckSmall(self, *args):
        """
        CheckSmall(Handle_ShapeAnalysis_Wire self, Standard_Real const precsmall=0.0) -> Standard_Boolean
        CheckSmall(Handle_ShapeAnalysis_Wire self, Standard_Integer const num, Standard_Real const precsmall=0.0) -> Standard_Boolean

        Checks if an edge has a length not greater than myPreci or
        precsmall (if it is smaller)
        Returns: False if its length is greater than precision
        Status:
        OK   : edge is not small or degenerated
        DONE1: edge is small, vertices are the same
        DONE2: edge is small, vertices are not the same
        FAIL : no 3d curve and pcurve

        :type num: int
        :type precsmall: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_CheckSmall(self, *args)


    def CheckEdgeCurves(self, *args):
        """
        CheckEdgeCurves(Handle_ShapeAnalysis_Wire self) -> Standard_Boolean

        Checks edges geometry (consitency of 2d and 3d senses, adjasment
        of curves to the vertices, etc.).
        The order of the checks :
        Call ShapeAnalysis_Wire to check:
        ShapeAnalysis_Edge::CheckCurve3dWithPCurve  (1),
        ShapeAnalysis_Edge::CheckVertcesWithPCurve  (2),
        ShapeAnalysis_Edge::CheckVertcesWithCurve3d (3),
        CheckSeam                                   (4)
        Additional:
        CheckGap3d                                  (5),
        CheckGap2d                                  (6),
        ShapeAnalysis_Edge::CheckSameParameter      (7)
        Returns: True if at least one check returned True
        Remark:  The numbers in brackets show with what DONEi or FAILi
        the status can be queried

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_CheckEdgeCurves(self, *args)


    def CheckDegenerated(self, *args):
        """
        CheckDegenerated(Handle_ShapeAnalysis_Wire self) -> Standard_Boolean
        CheckDegenerated(Handle_ShapeAnalysis_Wire self, Standard_Integer const num, gp_Pnt2d dgnr1, gp_Pnt2d dgnr2) -> Standard_Boolean
        CheckDegenerated(Handle_ShapeAnalysis_Wire self, Standard_Integer const num) -> Standard_Boolean

        Checks for degenerated edge between two adjacent ones.
        Remark : Calls previous function
        Status : See the function above for details

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_CheckDegenerated(self, *args)


    def CheckClosed(self, *args):
        """
        CheckClosed(Handle_ShapeAnalysis_Wire self, Standard_Real const prec=0.0) -> Standard_Boolean

        Checks if wire is closed, performs CheckConnected,
        CheckDegenerated and CheckLacking for the first and the last edges
        Returns: True if at least one check returned True
        Status:
        FAIL1 or DONE1: see CheckConnected
        FAIL2 or DONE2: see CheckDegenerated

        :type prec: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_CheckClosed(self, *args)


    def CheckSelfIntersection(self, *args):
        """
        CheckSelfIntersection(Handle_ShapeAnalysis_Wire self) -> Standard_Boolean

        Checks self-intersection of the wire (considering pcurves)
        Looks for self-intersecting edges and each pair of intersecting
        edges.
        Warning: It does not check each edge with any other one (only each two
        adjacent edges)
        The order of the checks :
        CheckSelfIntersectingEdge, CheckIntersectingEdges
        Returns: True if at least one check returned True
        Status:  FAIL1 or DONE1 - see CheckSelfIntersectingEdge
        FAIL2 or DONE2 - see CheckIntersectingEdges

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_CheckSelfIntersection(self, *args)


    def CheckLacking(self, *args):
        """
        CheckLacking(Handle_ShapeAnalysis_Wire self) -> Standard_Boolean
        CheckLacking(Handle_ShapeAnalysis_Wire self, Standard_Integer const num, Standard_Real const Tolerance, gp_Pnt2d p2d1, gp_Pnt2d p2d2) -> Standard_Boolean
        CheckLacking(Handle_ShapeAnalysis_Wire self, Standard_Integer const num, Standard_Real const Tolerance=0.0) -> Standard_Boolean

        Checks if there is a gap in 2D between edges and not comprised by vertex tolerance
        The value of SBWD.thepreci is used.
        Returns: False if no edge should be inserted
        Status:
        OK    : No edge is lacking (3d and 2d connection)
        DONE1 : The vertex tolerance should be increased only (2d gap is
        small)
        DONE2 : Edge can be inserted (3d and 2d gaps are large enough)

        :type num: int
        :type Tolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_CheckLacking(self, *args)


    def CheckGaps3d(self, *args):
        """
        CheckGaps3d(Handle_ShapeAnalysis_Wire self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_CheckGaps3d(self, *args)


    def CheckGaps2d(self, *args):
        """
        CheckGaps2d(Handle_ShapeAnalysis_Wire self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_CheckGaps2d(self, *args)


    def CheckCurveGaps(self, *args):
        """
        CheckCurveGaps(Handle_ShapeAnalysis_Wire self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_CheckCurveGaps(self, *args)


    def CheckSeam(self, *args):
        """
        CheckSeam(Handle_ShapeAnalysis_Wire self, Standard_Integer const num, Handle_Geom2d_Curve C1, Handle_Geom2d_Curve C2) -> Standard_Boolean
        CheckSeam(Handle_ShapeAnalysis_Wire self, Standard_Integer const num) -> Standard_Boolean

        Checks if a seam pcurves are correct oriented
        See previous functions for details

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_CheckSeam(self, *args)


    def CheckGap3d(self, *args):
        """
        CheckGap3d(Handle_ShapeAnalysis_Wire self, Standard_Integer const num=0) -> Standard_Boolean

        Checks gap between edges in 3D (3d curves).
        Checks the distance between ends of 3d curves of the num-th
        and preceeding edge.
        The distance can be queried by MinDistance3d.

        Returns: True if status is DONE
        Status:
        OK   : Gap is less than myPrecision
        DONE : Gap is greater than myPrecision
        FAIL : No 3d curve(s) on the edge(s)

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_CheckGap3d(self, *args)


    def CheckGap2d(self, *args):
        """
        CheckGap2d(Handle_ShapeAnalysis_Wire self, Standard_Integer const num=0) -> Standard_Boolean

        Checks gap between edges in 2D (pcurves).
        Checks the distance between ends of pcurves of the num-th
        and preceeding edge.
        The distance can be queried by MinDistance2d.

        Returns: True if status is DONE
        Status:
        OK   : Gap is less than parametric precision out of myPrecision
        DONE : Gap is greater than parametric precision out of myPrecision
        FAIL : No pcurve(s) on the edge(s)

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_CheckGap2d(self, *args)


    def CheckCurveGap(self, *args):
        """
        CheckCurveGap(Handle_ShapeAnalysis_Wire self, Standard_Integer const num=0) -> Standard_Boolean

        Checks gap between points on 3D curve and points on surface
        generated by pcurve of the num-th edge.
        The distance can be queried by MinDistance3d.

        Returns: True if status is DONE
        Status:
        OK   : Gap is less than myPrecision
        DONE : Gap is greater than myPrecision
        FAIL : No 3d curve(s) on the edge(s)

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_CheckCurveGap(self, *args)


    def CheckSelfIntersectingEdge(self, *args):
        """
        CheckSelfIntersectingEdge(Handle_ShapeAnalysis_Wire self, Standard_Integer const num, NCollection_Sequence_IntRes2d_IntersectionPoint points2d, NCollection_Sequence_gp_Pnt points3d) -> Standard_Boolean
        CheckSelfIntersectingEdge(Handle_ShapeAnalysis_Wire self, Standard_Integer const num) -> Standard_Boolean

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_CheckSelfIntersectingEdge(self, *args)


    def CheckIntersectingEdges(self, *args):
        """
        CheckIntersectingEdges(Handle_ShapeAnalysis_Wire self, Standard_Integer const num, NCollection_Sequence_IntRes2d_IntersectionPoint points2d, NCollection_Sequence_gp_Pnt points3d, NCollection_Sequence_Standard_Real errors) -> Standard_Boolean
        CheckIntersectingEdges(Handle_ShapeAnalysis_Wire self, Standard_Integer const num) -> Standard_Boolean
        CheckIntersectingEdges(Handle_ShapeAnalysis_Wire self, Standard_Integer const num1, Standard_Integer const num2, NCollection_Sequence_IntRes2d_IntersectionPoint points2d, NCollection_Sequence_gp_Pnt points3d, NCollection_Sequence_Standard_Real errors) -> Standard_Boolean
        CheckIntersectingEdges(Handle_ShapeAnalysis_Wire self, Standard_Integer const num1, Standard_Integer const num2) -> Standard_Boolean

        Checks i-th and j-th edges for intersecting.
        Remark : Calls  previous method.
        Status : See the function above for details

        :type num1: int
        :type num2: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_CheckIntersectingEdges(self, *args)


    def CheckOuterBound(self, *args):
        """
        CheckOuterBound(Handle_ShapeAnalysis_Wire self, Standard_Boolean const APIMake) -> Standard_Boolean

        Checks if wire defines an outer bound on the face
        Uses ShapeAnalysis::IsOuterBound for analysis
        If <APIMake> is True uses BRepAPI_MakeWire to build the
        wire, if False (to be used only when edges share common
        vertices) uses BRep_Builder to build the wire

        :type APIMake: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_CheckOuterBound(self, *args)


    def CheckNotchedEdges(self, *args):
        """
        CheckNotchedEdges(Handle_ShapeAnalysis_Wire self, Standard_Integer const num, Standard_Real const Tolerance=0.0) -> Standard_Boolean

        Detects a notch

        :type num: int
        :type shortNum: int
        :type param: float
        :type Tolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_CheckNotchedEdges(self, *args)


    def CheckSmallArea(self, *args):
        """
        CheckSmallArea(Handle_ShapeAnalysis_Wire self, TopoDS_Wire theWire) -> Standard_Boolean

        Checks if wire has parametric area less than precision.

        :type theWire: OCC.wrapper.TopoDS.TopoDS_Wire
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_CheckSmallArea(self, *args)


    def CheckShapeConnect(self, *args):
        """
        CheckShapeConnect(Handle_ShapeAnalysis_Wire self, TopoDS_Shape shape, Standard_Real const prec=0.0) -> Standard_Boolean
        CheckShapeConnect(Handle_ShapeAnalysis_Wire self, TopoDS_Shape shape, Standard_Real const prec=0.0) -> Standard_Boolean

        The same as previous CheckShapeConnect but is more advanced.
        It returns the distances between each end of <sbwd> and each
        end of <shape>. For example, <tailhead> stores distance
        between tail of <sbwd> and head of <shape>
        Remark:  First method CheckShapeConnect calls this one

        :type tailhead: float
        :type tailtail: float
        :type headtail: float
        :type headhead: float
        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type prec: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_CheckShapeConnect(self, *args)


    def CheckLoop(self, *args):
        """
        CheckLoop(Handle_ShapeAnalysis_Wire self, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher aMapLoopVertices, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher aMapVertexEdges, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher aMapSmallEdges, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher aMapSeemEdges) -> Standard_Boolean

        Checks existance of loop on wire and return vertices wich are loop vertices
        (vertices belonging to a few pairs of edges)

        :type aMapLoopVertices: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape
        :type aMapVertexEdges: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
        :type aMapSmallEdges: OCC.wrapper.TopTools.TopTools_MapOfShape
        :type aMapSeemEdges: OCC.wrapper.TopTools.TopTools_MapOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_CheckLoop(self, *args)


    def CheckTail(self, *args):
        """
        CheckTail(Handle_ShapeAnalysis_Wire self, TopoDS_Edge theEdge1, TopoDS_Edge theEdge2, Standard_Real const theMaxSine, Standard_Real const theMaxWidth, Standard_Real const theMaxTolerance, TopoDS_Edge theEdge11, TopoDS_Edge theEdge12, TopoDS_Edge theEdge21, TopoDS_Edge theEdge22) -> Standard_Boolean

        :type theEdge1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theEdge2: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theMaxSine: float
        :type theMaxWidth: float
        :type theMaxTolerance: float
        :type theEdge11: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theEdge12: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theEdge21: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theEdge22: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_CheckTail(self, *args)


    def StatusOrder(self, *args):
        """
        StatusOrder(Handle_ShapeAnalysis_Wire self, ShapeExtend_Status const Status) -> Standard_Boolean

        :type Status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_StatusOrder(self, *args)


    def StatusConnected(self, *args):
        """
        StatusConnected(Handle_ShapeAnalysis_Wire self, ShapeExtend_Status const Status) -> Standard_Boolean

        :type Status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_StatusConnected(self, *args)


    def StatusEdgeCurves(self, *args):
        """
        StatusEdgeCurves(Handle_ShapeAnalysis_Wire self, ShapeExtend_Status const Status) -> Standard_Boolean

        :type Status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_StatusEdgeCurves(self, *args)


    def StatusDegenerated(self, *args):
        """
        StatusDegenerated(Handle_ShapeAnalysis_Wire self, ShapeExtend_Status const Status) -> Standard_Boolean

        :type Status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_StatusDegenerated(self, *args)


    def StatusClosed(self, *args):
        """
        StatusClosed(Handle_ShapeAnalysis_Wire self, ShapeExtend_Status const Status) -> Standard_Boolean

        :type Status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_StatusClosed(self, *args)


    def StatusSmall(self, *args):
        """
        StatusSmall(Handle_ShapeAnalysis_Wire self, ShapeExtend_Status const Status) -> Standard_Boolean

        :type Status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_StatusSmall(self, *args)


    def StatusSelfIntersection(self, *args):
        """
        StatusSelfIntersection(Handle_ShapeAnalysis_Wire self, ShapeExtend_Status const Status) -> Standard_Boolean

        :type Status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_StatusSelfIntersection(self, *args)


    def StatusLacking(self, *args):
        """
        StatusLacking(Handle_ShapeAnalysis_Wire self, ShapeExtend_Status const Status) -> Standard_Boolean

        :type Status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_StatusLacking(self, *args)


    def StatusGaps3d(self, *args):
        """
        StatusGaps3d(Handle_ShapeAnalysis_Wire self, ShapeExtend_Status const Status) -> Standard_Boolean

        :type Status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_StatusGaps3d(self, *args)


    def StatusGaps2d(self, *args):
        """
        StatusGaps2d(Handle_ShapeAnalysis_Wire self, ShapeExtend_Status const Status) -> Standard_Boolean

        :type Status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_StatusGaps2d(self, *args)


    def StatusCurveGaps(self, *args):
        """
        StatusCurveGaps(Handle_ShapeAnalysis_Wire self, ShapeExtend_Status const Status) -> Standard_Boolean

        :type Status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_StatusCurveGaps(self, *args)


    def StatusLoop(self, *args):
        """
        StatusLoop(Handle_ShapeAnalysis_Wire self, ShapeExtend_Status const Status) -> Standard_Boolean

        :type Status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_StatusLoop(self, *args)


    def LastCheckStatus(self, *args):
        """
        LastCheckStatus(Handle_ShapeAnalysis_Wire self, ShapeExtend_Status const Status) -> Standard_Boolean

        Querying the status of the LAST perfomed 'Advanced' checking procedure

        :type Status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_LastCheckStatus(self, *args)


    def MinDistance3d(self, *args):
        """
        MinDistance3d(Handle_ShapeAnalysis_Wire self) -> Standard_Real

        Returns the last lowest distance in 3D computed by
        CheckOrientation, CheckConnected, CheckContinuity3d,
        CheckVertex, CheckNewVertex

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_MinDistance3d(self, *args)


    def MinDistance2d(self, *args):
        """
        MinDistance2d(Handle_ShapeAnalysis_Wire self) -> Standard_Real

        Returns the last lowest distance in 2D-UV computed by
        CheckContinuity2d

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_MinDistance2d(self, *args)


    def MaxDistance3d(self, *args):
        """
        MaxDistance3d(Handle_ShapeAnalysis_Wire self) -> Standard_Real

        Returns the last maximal distance in 3D computed by
        CheckOrientation, CheckConnected, CheckContinuity3d,
        CheckVertex, CheckNewVertex, CheckSameParameter

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_MaxDistance3d(self, *args)


    def MaxDistance2d(self, *args):
        """
        MaxDistance2d(Handle_ShapeAnalysis_Wire self) -> Standard_Real

        Returns the last maximal distance in 2D-UV computed by
        CheckContinuity2d

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_MaxDistance2d(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeAnalysis_Wire self) -> char const *

        :rtype: const char *

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeAnalysis.Handle_ShapeAnalysis_Wire_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeAnalysis.Handle_ShapeAnalysis_Wire_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ShapeAnalysis_Wire self)

        Memory deallocator for transient classes


        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeAnalysis_Wire self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeAnalysis_Wire self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeAnalysis_Wire self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeAnalysis_Wire self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeAnalysis_Wire self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeAnalysis_Wire self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeAnalysis_Wire self)

        Increments the reference counter of this object


        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeAnalysis_Wire self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_DecrementRefCounter(self, *args)

Handle_ShapeAnalysis_Wire_swigregister = _ShapeAnalysis.Handle_ShapeAnalysis_Wire_swigregister
Handle_ShapeAnalysis_Wire_swigregister(Handle_ShapeAnalysis_Wire)

def Handle_ShapeAnalysis_Wire_DownCast(thing):
    return _ShapeAnalysis.Handle_ShapeAnalysis_Wire_DownCast(thing)
Handle_ShapeAnalysis_Wire_DownCast = _ShapeAnalysis.Handle_ShapeAnalysis_Wire_DownCast

class ShapeAnalysis_WireVertex(object):
    """
    Analyzes and records status of vertices in a Wire

    The Wire has formerly been loaded in a ShapeExtend_WireData
    For each Vertex, a status and some data can be attached
    (case found, position and parameters)
    Then, these informations can be used to fix problems
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeAnalysis_WireVertex self) -> ShapeAnalysis_WireVertex

        Empty constructor


        """
        this = _ShapeAnalysis.new_ShapeAnalysis_WireVertex(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(ShapeAnalysis_WireVertex self, TopoDS_Wire wire, Standard_Real const preci)
        Init(ShapeAnalysis_WireVertex self, Handle_ShapeExtend_WireData swbd, Standard_Real const preci)

        :type swbd: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_WireData
        :type preci: float

        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_Init(self, *args)


    def Load(self, *args):
        """
        Load(ShapeAnalysis_WireVertex self, TopoDS_Wire wire)
        Load(ShapeAnalysis_WireVertex self, Handle_ShapeExtend_WireData sbwd)

        :type sbwd: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_WireData

        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_Load(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(ShapeAnalysis_WireVertex self, Standard_Real const preci)

        Sets the precision for work
        Analysing: for each Vertex, comparison between the end of the
        preceeding edge and the start of the following edge
        Each Vertex rank corresponds to the End Vertex of the Edge of
        same rank, in the ShapeExtend_WireData. I.E. for Vertex <num>,
        Edge <num> is the preceeding one, <num+1> is the following one

        :type preci: float

        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_SetPrecision(self, *args)


    def Analyze(self, *args):
        """Analyze(ShapeAnalysis_WireVertex self)"""
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_Analyze(self, *args)


    def SetSameVertex(self, *args):
        """
        SetSameVertex(ShapeAnalysis_WireVertex self, Standard_Integer const num)

        Records status "Same Vertex" (logically) on Vertex <num>

        :type num: int

        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_SetSameVertex(self, *args)


    def SetSameCoords(self, *args):
        """
        SetSameCoords(ShapeAnalysis_WireVertex self, Standard_Integer const num)

        Records status "Same Coords" (at the Vertices Tolerances)

        :type num: int

        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_SetSameCoords(self, *args)


    def SetClose(self, *args):
        """
        SetClose(ShapeAnalysis_WireVertex self, Standard_Integer const num)

        Records status "Close Coords" (at the Precision of <me>)

        :type num: int

        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_SetClose(self, *args)


    def SetEnd(self, *args):
        """
        SetEnd(ShapeAnalysis_WireVertex self, Standard_Integer const num, gp_XYZ pos, Standard_Real const ufol)

        <num> is the End of preceeding Edge, and its projection on the
        following one lies on it at the Precision of <me>
        <ufol> gives the parameter on the following edge

        :type num: int
        :type pos: OCC.wrapper.gp.gp_XYZ
        :type ufol: float

        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_SetEnd(self, *args)


    def SetStart(self, *args):
        """
        SetStart(ShapeAnalysis_WireVertex self, Standard_Integer const num, gp_XYZ pos, Standard_Real const upre)

        <num> is the Start of following Edge, its projection on the
        preceeding one lies on it at the Precision of <me>
        <upre> gives the parameter on the preceeding edge

        :type num: int
        :type pos: OCC.wrapper.gp.gp_XYZ
        :type upre: float

        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_SetStart(self, *args)


    def SetInters(self, *args):
        """
        SetInters(ShapeAnalysis_WireVertex self, Standard_Integer const num, gp_XYZ pos, Standard_Real const upre, Standard_Real const ufol)

        <num> is the Intersection of both Edges
        <upre> is the parameter on preceeding edge, <ufol> on
        following edge

        :type num: int
        :type pos: OCC.wrapper.gp.gp_XYZ
        :type upre: float
        :type ufol: float

        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_SetInters(self, *args)


    def SetDisjoined(self, *args):
        """
        SetDisjoined(ShapeAnalysis_WireVertex self, Standard_Integer const num)

        <num> cannot be said as same vertex

        :type num: int

        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_SetDisjoined(self, *args)


    def IsDone(self, *args):
        """
        IsDone(ShapeAnalysis_WireVertex self) -> Standard_Boolean

        Returns True if analysis was performed, else returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_IsDone(self, *args)


    def Precision(self, *args):
        """
        Precision(ShapeAnalysis_WireVertex self) -> Standard_Real

        Returns precision value used in analysis

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_Precision(self, *args)


    def NbEdges(self, *args):
        """
        NbEdges(ShapeAnalysis_WireVertex self) -> Standard_Integer

        Returns the number of edges in analyzed wire (i.e. the
        length of all arrays)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_NbEdges(self, *args)


    def WireData(self, *args):
        """
        Returns analyzed wire

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_WireData

        """
        res = _ShapeAnalysis.ShapeAnalysis_WireVertex_WireData(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Status(self, *args):
        """
        Status(ShapeAnalysis_WireVertex self, Standard_Integer const num) -> Standard_Integer

        Returns the recorded status for a vertex
        More detail by method Data

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_Status(self, *args)


    def Position(self, *args):
        """
        Position(ShapeAnalysis_WireVertex self, Standard_Integer const num) -> gp_XYZ

        :type num: int
        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_Position(self, *args)


    def UPrevious(self, *args):
        """
        UPrevious(ShapeAnalysis_WireVertex self, Standard_Integer const num) -> Standard_Real

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_UPrevious(self, *args)


    def UFollowing(self, *args):
        """
        UFollowing(ShapeAnalysis_WireVertex self, Standard_Integer const num) -> Standard_Real

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_UFollowing(self, *args)


    def Data(self, *args):
        """
        Data(ShapeAnalysis_WireVertex self, Standard_Integer const num, gp_XYZ pos) -> Standard_Integer

        Returns the recorded status for a vertex
        With its recorded position and parameters on both edges
        These values are relevant regarding the status:
        Status  Meaning   Position  Preceeding  Following
        0       Same       no        no          no
        1       SameCoord  no        no          no
        2       Close      no        no          no
        3       End        yes       no          yes
        4       Start      yes       yes         no
        5       Inters     yes       yes         yes
        -1       Disjoined  no        no          no

        :type num: int
        :type pos: OCC.wrapper.gp.gp_XYZ
        :type upre: float
        :type ufol: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_Data(self, *args)


    def NextStatus(self, *args):
        """
        NextStatus(ShapeAnalysis_WireVertex self, Standard_Integer const stat, Standard_Integer const num=0) -> Standard_Integer

        For a given status, returns the rank of the vertex which
        follows <num> and has the same status. 0 if no more
        Acts as an iterator, starts on the first one

        :type stat: int
        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_NextStatus(self, *args)


    def NextCriter(self, *args):
        """
        NextCriter(ShapeAnalysis_WireVertex self, Standard_Integer const crit, Standard_Integer const num=0) -> Standard_Integer

        For a given criter, returns the rank of the vertex which
        follows <num> and has the same status. 0 if no more
        Acts as an iterator, starts on the first one
        Criters are:
        0: same vertex (status 0)
        1: a solution exists (status >= 0)
        2: same coords (i.e. same params) (status 0 1 2)
        3: same coods but not same vertex (status 1 2)
        4: redefined coords (status 3 4 5)
        -1: no solution (status -1)

        :type crit: int
        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeAnalysis.ShapeAnalysis_WireVertex_NextCriter(self, *args)

    __swig_destroy__ = _ShapeAnalysis.delete_ShapeAnalysis_WireVertex
ShapeAnalysis_WireVertex_swigregister = _ShapeAnalysis.ShapeAnalysis_WireVertex_swigregister
ShapeAnalysis_WireVertex_swigregister(ShapeAnalysis_WireVertex)




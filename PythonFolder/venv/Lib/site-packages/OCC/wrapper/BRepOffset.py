# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BRepOffset')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BRepOffset')
    _BRepOffset = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRepOffset', [dirname(__file__)])
        except ImportError:
            import _BRepOffset
            return _BRepOffset
        try:
            _mod = imp.load_module('_BRepOffset', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BRepOffset = swig_import_helper()
    del swig_import_helper
else:
    import _BRepOffset
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepOffset.delete_SwigPyIterator

    def value(self):
        return _BRepOffset.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BRepOffset.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BRepOffset.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BRepOffset.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BRepOffset.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BRepOffset.SwigPyIterator_copy(self)

    def next(self):
        return _BRepOffset.SwigPyIterator_next(self)

    def __next__(self):
        return _BRepOffset.SwigPyIterator___next__(self)

    def previous(self):
        return _BRepOffset.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BRepOffset.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BRepOffset.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BRepOffset.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BRepOffset.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BRepOffset.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BRepOffset.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BRepOffset.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BRepOffset.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepOffset.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BRepOffset.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepOffset.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepOffset.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepOffset.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BRepOffset.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BRepOffset.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BRepOffset.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepOffset.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BRepOffset.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepOffset.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepOffset.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepOffset.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BRepOffset.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BRepOffset.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BRepOffset.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BRepOffset.ptr_to_number(item)
ptr_to_number = _BRepOffset.ptr_to_number

def HashCode(*args):
    return _BRepOffset.HashCode(*args)
HashCode = _BRepOffset.HashCode

def ptr_equal(a, b):
    return _BRepOffset.ptr_equal(a, b)
ptr_equal = _BRepOffset.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepTools
else:
    import BRepTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRep
else:
    import BRep
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAlgo
else:
    import BRepAlgo
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopOpeBRepDS
else:
    import TopOpeBRepDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopOpeBRepTool
else:
    import TopOpeBRepTool
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopExp
else:
    import TopExp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepClass3d
else:
    import BRepClass3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurveSurface
else:
    import IntCurveSurface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Intf
else:
    import Intf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntAna
else:
    import IntAna
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntSurf
else:
    import IntSurf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurvesFace
else:
    import IntCurvesFace
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepBuilderAPI
else:
    import BRepBuilderAPI
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopOpeBRepBuild
else:
    import TopOpeBRepBuild
del _swig_python_version_info
BRepOffset_Good = _BRepOffset.BRepOffset_Good
BRepOffset_Reversed = _BRepOffset.BRepOffset_Reversed
BRepOffset_Degenerated = _BRepOffset.BRepOffset_Degenerated
BRepOffset_Unknown = _BRepOffset.BRepOffset_Unknown
BRepOffset_Concave = _BRepOffset.BRepOffset_Concave
BRepOffset_Convex = _BRepOffset.BRepOffset_Convex
BRepOffset_Tangent = _BRepOffset.BRepOffset_Tangent
BRepOffset_FreeBoundary = _BRepOffset.BRepOffset_FreeBoundary
BRepOffset_Other = _BRepOffset.BRepOffset_Other
BRepOffset_NoError = _BRepOffset.BRepOffset_NoError
BRepOffset_UnknownError = _BRepOffset.BRepOffset_UnknownError
BRepOffset_BadNormalsOnGeometry = _BRepOffset.BRepOffset_BadNormalsOnGeometry
BRepOffset_C0Geometry = _BRepOffset.BRepOffset_C0Geometry
BRepOffset_NullOffset = _BRepOffset.BRepOffset_NullOffset
BRepOffset_NotConnectedShell = _BRepOffset.BRepOffset_NotConnectedShell
BRepOffset_Skin = _BRepOffset.BRepOffset_Skin
BRepOffset_Pipe = _BRepOffset.BRepOffset_Pipe
BRepOffset_RectoVerso = _BRepOffset.BRepOffset_RectoVerso
BRepOffsetSimple_OK = _BRepOffset.BRepOffsetSimple_OK
BRepOffsetSimple_NullInputShape = _BRepOffset.BRepOffsetSimple_NullInputShape
BRepOffsetSimple_ErrorOffsetComputation = _BRepOffset.BRepOffsetSimple_ErrorOffsetComputation
BRepOffsetSimple_ErrorWallFaceComputation = _BRepOffset.BRepOffsetSimple_ErrorWallFaceComputation
BRepOffsetSimple_ErrorInvalidNbShells = _BRepOffset.BRepOffsetSimple_ErrorInvalidNbShells
BRepOffsetSimple_ErrorNonClosedShell = _BRepOffset.BRepOffsetSimple_ErrorNonClosedShell
class BRepOffset_Interval(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepOffset_Interval self) -> BRepOffset_Interval
        __init__(BRepOffset_Interval self, Standard_Real const U1, Standard_Real const U2, BRepOffset_Type const Type) -> BRepOffset_Interval

        :type U1: float
        :type U2: float
        :type Type: OCC.wrapper.BRepOffset.BRepOffset_Type

        """
        this = _BRepOffset.new_BRepOffset_Interval(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def First(self, *args):
        """
        First(BRepOffset_Interval self, Standard_Real const U)
        First(BRepOffset_Interval self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepOffset.BRepOffset_Interval_First(self, *args)


    def Last(self, *args):
        """
        Last(BRepOffset_Interval self, Standard_Real const U)
        Last(BRepOffset_Interval self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepOffset.BRepOffset_Interval_Last(self, *args)


    def Type(self, *args):
        """
        Type(BRepOffset_Interval self, BRepOffset_Type const T)
        Type(BRepOffset_Interval self) -> BRepOffset_Type

        :rtype: OCC.wrapper.BRepOffset.BRepOffset_Type

        """
        return _BRepOffset.BRepOffset_Interval_Type(self, *args)

    __swig_destroy__ = _BRepOffset.delete_BRepOffset_Interval
BRepOffset_Interval_swigregister = _BRepOffset.BRepOffset_Interval_swigregister
BRepOffset_Interval_swigregister(BRepOffset_Interval)

class BRepOffset_SimpleOffset(BRepTools.BRepTools_Modification):
    """
    This class represents mechanism of simple offset algorithm i. e.
    topology-preserve offset construction without intersection.

    The list below shows mapping scheme:
    - Each surface is mapped to its geometric offset surface.
    - For each edge, pcurves are mapped to the same pcurves on offset surfaces.
    - For each edge, 3d curve is constructed by re-approximation of pcurve on the first offset face.
    - Position of each vertex in a result shell is computed as average point of all ends of edges shared by that vertex.
    - Tolerances are updated according to the resulting geometry.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepOffset_SimpleOffset
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepOffset_SimpleOffset(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepOffset.BRepOffset_SimpleOffset_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepOffset.BRepOffset_SimpleOffset_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepOffset.BRepOffset_SimpleOffset_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(BRepOffset_SimpleOffset self, TopoDS_Shape theInputShape, Standard_Real const theOffsetValue, Standard_Real const theTolerance) -> BRepOffset_SimpleOffset

        Constructor.
        @param theInputShape shape to be offset
        @param theOffsetValue offset distance (signed)
        @param theTolerance tolerance for handling singular points

        :type theInputShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theOffsetValue: float
        :type theTolerance: float

        """
        this = _BRepOffset.new_BRepOffset_SimpleOffset(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewSurface(self, *args):
        """
        NewSurface(BRepOffset_SimpleOffset self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True  if  the face  <F> has  been
        modified.  In this  case, <S> is the new geometric
        support of  the  face, <L> the  new location,<Tol>
        the new  tolerance.<RevWires> has  to  be set   to
        Standard_True   when the modification reverses the
        normal of  the   surface.(the wires   have  to  be
        reversed).   <RevFace>   has   to   be   set    to
        Standard_True if  the orientation  of the modified
        face changes in the  shells which contain  it.  --
        Here, <RevFace>  will  return Standard_True if the
        -- gp_Trsf is negative.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :type RevWires: bool
        :type RevFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.BRepOffset_SimpleOffset_NewSurface(self, *args)


    def NewCurve(self, *args):
        """
        NewCurve(BRepOffset_SimpleOffset self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True  if  the edge  <E> has  been
        modified.  In this case,  <C> is the new geometric
        support of the  edge, <L> the  new location, <Tol>
        the         new    tolerance.   Otherwise, returns
        Standard_False,    and  <C>,  <L>,   <Tol> are not
        significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.BRepOffset_SimpleOffset_NewCurve(self, *args)


    def NewPoint(self, *args):
        """
        NewPoint(BRepOffset_SimpleOffset self, TopoDS_Vertex V, gp_Pnt P) -> Standard_Boolean

        Returns  Standard_True if the  vertex <V> has been
        modified.  In this  case, <P> is the new geometric
        support of the vertex,   <Tol> the new  tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.BRepOffset_SimpleOffset_NewPoint(self, *args)


    def NewCurve2d(self, *args):
        """
        NewCurve2d(BRepOffset_SimpleOffset self, TopoDS_Edge E, TopoDS_Face F, TopoDS_Edge NewE, TopoDS_Face NewF, Handle_Geom2d_Curve C) -> Standard_Boolean

        Returns Standard_True if  the edge  <E> has a  new
        curve on surface on the face <F>.In this case, <C>
        is the new geometric support of  the edge, <L> the
        new location, <Tol> the new tolerance.
        Otherwise, returns  Standard_False, and <C>,  <L>,
        <Tol> are not significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF: OCC.wrapper.TopoDS.TopoDS_Face
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.BRepOffset_SimpleOffset_NewCurve2d(self, *args)


    def NewParameter(self, *args):
        """
        NewParameter(BRepOffset_SimpleOffset self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        Returns Standard_True if the Vertex  <V> has a new
        parameter on the  edge <E>. In  this case,  <P> is
        the parameter,    <Tol>  the     new    tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.BRepOffset_SimpleOffset_NewParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(BRepOffset_SimpleOffset self, TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, TopoDS_Edge NewE, TopoDS_Face NewF1, TopoDS_Face NewF2) -> GeomAbs_Shape

        Returns the  continuity of  <NewE> between <NewF1>
        and <NewF2>.

        <NewE> is the new  edge created from <E>.  <NewF1>
        (resp. <NewF2>) is the new  face created from <F1>
        (resp. <F2>).

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewF2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepOffset.BRepOffset_SimpleOffset_Continuity(self, *args)

    __swig_destroy__ = _BRepOffset.delete_BRepOffset_SimpleOffset
BRepOffset_SimpleOffset_swigregister = _BRepOffset.BRepOffset_SimpleOffset_swigregister
BRepOffset_SimpleOffset_swigregister(BRepOffset_SimpleOffset)

def BRepOffset_SimpleOffset_get_type_name(*args):
    """
    BRepOffset_SimpleOffset_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepOffset.BRepOffset_SimpleOffset_get_type_name(*args)

def BRepOffset_SimpleOffset_get_type_descriptor(*args):
    """
    BRepOffset_SimpleOffset_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepOffset.BRepOffset_SimpleOffset_get_type_descriptor(*args)

class BRepOffset_Offset(object):
    """
    This class compute elemenary offset surface.
    Evaluate the offset generated :
    1 - from a face.
    2 - from an edge.
    3 - from a vertex.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepOffset_Offset self) -> BRepOffset_Offset
        __init__(BRepOffset_Offset self, TopoDS_Face Face, Standard_Real const Offset, Standard_Boolean const OffsetOutside, GeomAbs_JoinType const JoinType=GeomAbs_Arc) -> BRepOffset_Offset
        __init__(BRepOffset_Offset self, TopoDS_Face Face, Standard_Real const Offset, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher Created, Standard_Boolean const OffsetOutside, GeomAbs_JoinType const JoinType=GeomAbs_Arc) -> BRepOffset_Offset
        __init__(BRepOffset_Offset self, TopoDS_Edge Path, TopoDS_Edge Edge1, TopoDS_Edge Edge2, Standard_Real const Offset, Standard_Boolean const Polynomial, Standard_Real const Tol=1.0e-4, GeomAbs_Shape const Conti=GeomAbs_C1) -> BRepOffset_Offset
        __init__(BRepOffset_Offset self, TopoDS_Edge Path, TopoDS_Edge Edge1, TopoDS_Edge Edge2, Standard_Real const Offset, TopoDS_Edge FirstEdge, TopoDS_Edge LastEdge, Standard_Boolean const Polynomial, Standard_Real const Tol=1.0e-4, GeomAbs_Shape const Conti=GeomAbs_C1) -> BRepOffset_Offset
        __init__(BRepOffset_Offset self, TopoDS_Vertex Vertex, NCollection_List_TopoDS_Shape LEdge, Standard_Real const Offset, Standard_Boolean const Polynomial, Standard_Real const Tol=1.0e-4, GeomAbs_Shape const Conti=GeomAbs_C1) -> BRepOffset_Offset

        Tol and Conti are only used if Polynomial is True
        (Used to perfrom the approximation)

        :type Vertex: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type LEdge: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type Offset: float
        :type Polynomial: bool
        :type Tol: float
        :type Conti: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        this = _BRepOffset.new_BRepOffset_Offset(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepOffset_Offset self, TopoDS_Face Face, Standard_Real const Offset, Standard_Boolean const OffsetOutside, GeomAbs_JoinType const JoinType=GeomAbs_Arc)
        Init(BRepOffset_Offset self, TopoDS_Face Face, Standard_Real const Offset, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher Created, Standard_Boolean const OffsetOutside, GeomAbs_JoinType const JoinType=GeomAbs_Arc)
        Init(BRepOffset_Offset self, TopoDS_Edge Path, TopoDS_Edge Edge1, TopoDS_Edge Edge2, Standard_Real const Offset, Standard_Boolean const Polynomial, Standard_Real const Tol=1.0e-4, GeomAbs_Shape const Conti=GeomAbs_C1)
        Init(BRepOffset_Offset self, TopoDS_Edge Path, TopoDS_Edge Edge1, TopoDS_Edge Edge2, Standard_Real const Offset, TopoDS_Edge FirstEdge, TopoDS_Edge LastEdge, Standard_Boolean const Polynomial, Standard_Real const Tol=1.0e-4, GeomAbs_Shape const Conti=GeomAbs_C1)
        Init(BRepOffset_Offset self, TopoDS_Vertex Vertex, NCollection_List_TopoDS_Shape LEdge, Standard_Real const Offset, Standard_Boolean const Polynomial, Standard_Real const Tol=1.0e-4, GeomAbs_Shape const Conti=GeomAbs_C1)
        Init(BRepOffset_Offset self, TopoDS_Edge Edge, Standard_Real const Offset)

        Only used in Rolling Ball. Pipe on Free Boundary

        :type Edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Offset: float

        """
        return _BRepOffset.BRepOffset_Offset_Init(self, *args)


    def InitialShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepOffset.BRepOffset_Offset_InitialShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Face(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _BRepOffset.BRepOffset_Offset_Face(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Generated(self, *args):
        """
        Generated(BRepOffset_Offset self, TopoDS_Shape Shape) -> TopoDS_Shape

        :type Shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepOffset.BRepOffset_Offset_Generated(self, *args)


    def Status(self, *args):
        """
        Status(BRepOffset_Offset self) -> BRepOffset_Status

        :rtype: OCC.wrapper.BRepOffset.BRepOffset_Status

        """
        return _BRepOffset.BRepOffset_Offset_Status(self, *args)

    __swig_destroy__ = _BRepOffset.delete_BRepOffset_Offset
BRepOffset_Offset_swigregister = _BRepOffset.BRepOffset_Offset_swigregister
BRepOffset_Offset_swigregister(BRepOffset_Offset)

class NCollection_List_BRepOffset_Interval_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepOffset.new_NCollection_List_BRepOffset_Interval_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepOffset.delete_NCollection_List_BRepOffset_Interval_IteratorHelper

    def __next__(self):
        return _BRepOffset.NCollection_List_BRepOffset_Interval_IteratorHelper___next__(self)
NCollection_List_BRepOffset_Interval_IteratorHelper_swigregister = _BRepOffset.NCollection_List_BRepOffset_Interval_IteratorHelper_swigregister
NCollection_List_BRepOffset_Interval_IteratorHelper_swigregister(NCollection_List_BRepOffset_Interval_IteratorHelper)


try:
	BRepOffset_ListOfInterval = NCollection_List_BRepOffset_Interval
except NameError:
	pass # does not exist, probably ignored

class BRepOffset_Analyse(object):
    """
    Analyse of a shape consit to
    Find the part of edges convex concave tangent.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepOffset_Analyse self) -> BRepOffset_Analyse
        __init__(BRepOffset_Analyse self, TopoDS_Shape S, Standard_Real const Angle) -> BRepOffset_Analyse

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Angle: float

        """
        this = _BRepOffset.new_BRepOffset_Analyse(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(BRepOffset_Analyse self, TopoDS_Shape S, Standard_Real const Angle)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Angle: float

        """
        return _BRepOffset.BRepOffset_Analyse_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepOffset_Analyse self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.BRepOffset_Analyse_IsDone(self, *args)


    def Clear(self, *args):
        """Clear(BRepOffset_Analyse self)"""
        return _BRepOffset.BRepOffset_Analyse_Clear(self, *args)


    def Type(self, *args):
        """
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.BRepOffset.BRepOffset_ListOfInterval

        """
        res = _BRepOffset.BRepOffset_Analyse_Type(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Edges(self, *args):
        """
        Edges(BRepOffset_Analyse self, TopoDS_Vertex V, BRepOffset_Type const T, NCollection_List_TopoDS_Shape L)
        Edges(BRepOffset_Analyse self, TopoDS_Face F, BRepOffset_Type const T, NCollection_List_TopoDS_Shape L)

        Stores in <L> all the edges of Type <T>
        on the face <F>.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type T: OCC.wrapper.BRepOffset.BRepOffset_Type
        :type L: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepOffset.BRepOffset_Analyse_Edges(self, *args)


    def TangentEdges(self, *args):
        """
        TangentEdges(BRepOffset_Analyse self, TopoDS_Edge Edge, TopoDS_Vertex Vertex, NCollection_List_TopoDS_Shape Edges)

        set in <Edges> all  the Edges of <Shape> which are
        tangent to <Edge> at the vertex <Vertex>.

        :type Edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Vertex: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type Edges: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepOffset.BRepOffset_Analyse_TangentEdges(self, *args)


    def HasAncestor(self, *args):
        """
        HasAncestor(BRepOffset_Analyse self, TopoDS_Shape S) -> Standard_Boolean

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.BRepOffset_Analyse_HasAncestor(self, *args)


    def Ancestors(self, *args):
        """
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepOffset.BRepOffset_Analyse_Ancestors(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Explode(self, *args):
        """
        Explode(BRepOffset_Analyse self, NCollection_List_TopoDS_Shape L, BRepOffset_Type const Type)
        Explode(BRepOffset_Analyse self, NCollection_List_TopoDS_Shape L, BRepOffset_Type const Type1, BRepOffset_Type const Type2)

        Explode in compounds of faces where
        all the connex edges are of type <Side1> or <Side2>

        :type L: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type Type1: OCC.wrapper.BRepOffset.BRepOffset_Type
        :type Type2: OCC.wrapper.BRepOffset.BRepOffset_Type

        """
        return _BRepOffset.BRepOffset_Analyse_Explode(self, *args)


    def AddFaces(self, *args):
        """
        AddFaces(BRepOffset_Analyse self, TopoDS_Face Face, TopoDS_Compound Co, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher Map, BRepOffset_Type const Type)
        AddFaces(BRepOffset_Analyse self, TopoDS_Face Face, TopoDS_Compound Co, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher Map, BRepOffset_Type const Type1, BRepOffset_Type const Type2)

        Add in <CO> the faces of the shell containing <Face>
        where all the connex edges are of type <Side1> or <Side2>.

        :type Face: OCC.wrapper.TopoDS.TopoDS_Face
        :type Co: OCC.wrapper.TopoDS.TopoDS_Compound
        :type Map: OCC.wrapper.TopTools.TopTools_MapOfShape
        :type Type1: OCC.wrapper.BRepOffset.BRepOffset_Type
        :type Type2: OCC.wrapper.BRepOffset.BRepOffset_Type

        """
        return _BRepOffset.BRepOffset_Analyse_AddFaces(self, *args)

    __swig_destroy__ = _BRepOffset.delete_BRepOffset_Analyse
BRepOffset_Analyse_swigregister = _BRepOffset.BRepOffset_Analyse_swigregister
BRepOffset_Analyse_swigregister(BRepOffset_Analyse)

class BRepOffset_Inter2d(object):
    """
    Computes the intersections betwwen edges on a face
    stores result is SD as AsDes from BRepOffset.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Compute(*args):
        """
        Compute(Handle_BRepAlgo_AsDes AsDes, TopoDS_Face F, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher NewEdges, Standard_Real const Tol, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theDMVV)

        Computes the intersections between the edges stored
        is AsDes as descendants of <F> . Intersections is computed
        between two edges if one of them is bound in NewEdges.
        When all faces of the shape are treated the intersection
        vertices have to be fused using the FuseVertices method.
        theDMVV contains the vertices that should be fused

        :type AsDes: OCC.wrapper.BRepAlgo.Handle_BRepAlgo_AsDes
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewEdges: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape
        :type Tol: float
        :type theDMVV: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeListOfShape

        """
        return _BRepOffset.BRepOffset_Inter2d_Compute(*args)

    Compute = staticmethod(Compute)

    def ConnexIntByInt(*args):
        """
        ConnexIntByInt(TopoDS_Face FI, BRepOffset_Offset OFI, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher MES, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher Build, Handle_BRepAlgo_AsDes AsDes2d, Standard_Real const Offset, Standard_Real const Tol, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher FacesWithVerts, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theDMVV)

        Computes the intersection between the offset edges of the <FI>.
        All intersection vertices will be stored in AsDes2d.
        When all faces of the shape are treated the intersection vertices
        have to be fused using the FuseVertices method.
        theDMVV contains the vertices that should be fused.

        :type FI: OCC.wrapper.TopoDS.TopoDS_Face
        :type OFI: OCC.wrapper.BRepOffset.BRepOffset_Offset
        :type MES: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape
        :type Build: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape
        :type AsDes2d: OCC.wrapper.BRepAlgo.Handle_BRepAlgo_AsDes
        :type Offset: float
        :type Tol: float
        :type FacesWithVerts: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape
        :type theDMVV: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeListOfShape

        """
        return _BRepOffset.BRepOffset_Inter2d_ConnexIntByInt(*args)

    ConnexIntByInt = staticmethod(ConnexIntByInt)

    def ConnexIntByIntInVert(*args):
        """
        ConnexIntByIntInVert(TopoDS_Face FI, BRepOffset_Offset OFI, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher MES, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher Build, Handle_BRepAlgo_AsDes AsDes, Handle_BRepAlgo_AsDes AsDes2d, Standard_Real const Tol, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theDMVV)

        Computes the intersection between the offset edges generated
        from vertices and stored into AsDes as descendants of the <FI>.
        All intersection vertices will be stored in AsDes2d.
        When all faces of the shape are treated the intersection vertices
        have to be fused using the FuseVertices method.
        theDMVV contains the vertices that should be fused.

        :type FI: OCC.wrapper.TopoDS.TopoDS_Face
        :type OFI: OCC.wrapper.BRepOffset.BRepOffset_Offset
        :type MES: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape
        :type Build: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape
        :type AsDes: OCC.wrapper.BRepAlgo.Handle_BRepAlgo_AsDes
        :type AsDes2d: OCC.wrapper.BRepAlgo.Handle_BRepAlgo_AsDes
        :type Tol: float
        :type theDMVV: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeListOfShape

        """
        return _BRepOffset.BRepOffset_Inter2d_ConnexIntByIntInVert(*args)

    ConnexIntByIntInVert = staticmethod(ConnexIntByIntInVert)

    def FuseVertices(*args):
        """
        FuseVertices(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theDMVV, Handle_BRepAlgo_AsDes theAsDes)

        Fuses the chains of vertices in the theDMVV
        and updates AsDes by replacing the old vertices
        with the new ones.

        :type theDMVV: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeListOfShape
        :type theAsDes: OCC.wrapper.BRepAlgo.Handle_BRepAlgo_AsDes

        """
        return _BRepOffset.BRepOffset_Inter2d_FuseVertices(*args)

    FuseVertices = staticmethod(FuseVertices)

    def ExtentEdge(*args):
        """
        ExtentEdge(TopoDS_Edge E, TopoDS_Edge NE, Standard_Real const theOffset)

        extents the edge

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theOffset: float

        """
        return _BRepOffset.BRepOffset_Inter2d_ExtentEdge(*args)

    ExtentEdge = staticmethod(ExtentEdge)

    def __init__(self):
        """
        Computes the intersections betwwen edges on a face
        stores result is SD as AsDes from BRepOffset.
        """
        this = _BRepOffset.new_BRepOffset_Inter2d()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepOffset.delete_BRepOffset_Inter2d
BRepOffset_Inter2d_swigregister = _BRepOffset.BRepOffset_Inter2d_swigregister
BRepOffset_Inter2d_swigregister(BRepOffset_Inter2d)

def BRepOffset_Inter2d_Compute(*args):
    """
    BRepOffset_Inter2d_Compute(Handle_BRepAlgo_AsDes AsDes, TopoDS_Face F, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher NewEdges, Standard_Real const Tol, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theDMVV)

    Computes the intersections between the edges stored
    is AsDes as descendants of <F> . Intersections is computed
    between two edges if one of them is bound in NewEdges.
    When all faces of the shape are treated the intersection
    vertices have to be fused using the FuseVertices method.
    theDMVV contains the vertices that should be fused

    :type AsDes: OCC.wrapper.BRepAlgo.Handle_BRepAlgo_AsDes
    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type NewEdges: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape
    :type Tol: float
    :type theDMVV: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeListOfShape

    """
    return _BRepOffset.BRepOffset_Inter2d_Compute(*args)

def BRepOffset_Inter2d_ConnexIntByInt(*args):
    """
    BRepOffset_Inter2d_ConnexIntByInt(TopoDS_Face FI, BRepOffset_Offset OFI, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher MES, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher Build, Handle_BRepAlgo_AsDes AsDes2d, Standard_Real const Offset, Standard_Real const Tol, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher FacesWithVerts, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theDMVV)

    Computes the intersection between the offset edges of the <FI>.
    All intersection vertices will be stored in AsDes2d.
    When all faces of the shape are treated the intersection vertices
    have to be fused using the FuseVertices method.
    theDMVV contains the vertices that should be fused.

    :type FI: OCC.wrapper.TopoDS.TopoDS_Face
    :type OFI: OCC.wrapper.BRepOffset.BRepOffset_Offset
    :type MES: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape
    :type Build: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape
    :type AsDes2d: OCC.wrapper.BRepAlgo.Handle_BRepAlgo_AsDes
    :type Offset: float
    :type Tol: float
    :type FacesWithVerts: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape
    :type theDMVV: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeListOfShape

    """
    return _BRepOffset.BRepOffset_Inter2d_ConnexIntByInt(*args)

def BRepOffset_Inter2d_ConnexIntByIntInVert(*args):
    """
    BRepOffset_Inter2d_ConnexIntByIntInVert(TopoDS_Face FI, BRepOffset_Offset OFI, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher MES, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher Build, Handle_BRepAlgo_AsDes AsDes, Handle_BRepAlgo_AsDes AsDes2d, Standard_Real const Tol, NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theDMVV)

    Computes the intersection between the offset edges generated
    from vertices and stored into AsDes as descendants of the <FI>.
    All intersection vertices will be stored in AsDes2d.
    When all faces of the shape are treated the intersection vertices
    have to be fused using the FuseVertices method.
    theDMVV contains the vertices that should be fused.

    :type FI: OCC.wrapper.TopoDS.TopoDS_Face
    :type OFI: OCC.wrapper.BRepOffset.BRepOffset_Offset
    :type MES: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape
    :type Build: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape
    :type AsDes: OCC.wrapper.BRepAlgo.Handle_BRepAlgo_AsDes
    :type AsDes2d: OCC.wrapper.BRepAlgo.Handle_BRepAlgo_AsDes
    :type Tol: float
    :type theDMVV: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeListOfShape

    """
    return _BRepOffset.BRepOffset_Inter2d_ConnexIntByIntInVert(*args)

def BRepOffset_Inter2d_FuseVertices(*args):
    """
    BRepOffset_Inter2d_FuseVertices(NCollection_IndexedDataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theDMVV, Handle_BRepAlgo_AsDes theAsDes)

    Fuses the chains of vertices in the theDMVV
    and updates AsDes by replacing the old vertices
    with the new ones.

    :type theDMVV: OCC.wrapper.TopTools.TopTools_IndexedDataMapOfShapeListOfShape
    :type theAsDes: OCC.wrapper.BRepAlgo.Handle_BRepAlgo_AsDes

    """
    return _BRepOffset.BRepOffset_Inter2d_FuseVertices(*args)

def BRepOffset_Inter2d_ExtentEdge(*args):
    """
    BRepOffset_Inter2d_ExtentEdge(TopoDS_Edge E, TopoDS_Edge NE, Standard_Real const theOffset)

    extents the edge

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type NE: OCC.wrapper.TopoDS.TopoDS_Edge
    :type theOffset: float

    """
    return _BRepOffset.BRepOffset_Inter2d_ExtentEdge(*args)

class NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,BRepOffset_ListOfInterval,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,BRepOffset_ListOfInterval,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,BRepOffset_ListOfInterval,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,BRepOffset_ListOfInterval,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _BRepOffset.new_NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_List< BRepOffset_Interval > const & theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_List< BRepOffset_Interval > const & theItem) -> NCollection_List< BRepOffset_Interval > *

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_List< BRepOffset_Interval > const *

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_List< BRepOffset_Interval > *

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_List< BRepOffset_Interval > &

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _BRepOffset.delete_NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_swigregister = _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepOffset.new_NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepOffset.delete_NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher_IteratorHelper)


try:
	BRepOffset_DataMapOfShapeListOfInterval = NCollection_DataMap_TopoDS_Shape_BRepOffset_ListOfInterval_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class BRepOffset_Inter3d(object):
    """
    Computes the intersection face face in a set of faces
    Store the result in a SD as AsDes.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepOffset_Inter3d self, Handle_BRepAlgo_AsDes AsDes, TopAbs_State const Side, Standard_Real const Tol) -> BRepOffset_Inter3d

        :type AsDes: OCC.wrapper.BRepAlgo.Handle_BRepAlgo_AsDes
        :type Side: OCC.wrapper.TopAbs.TopAbs_State
        :type Tol: float

        """
        this = _BRepOffset.new_BRepOffset_Inter3d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CompletInt(self, *args):
        """
        CompletInt(BRepOffset_Inter3d self, NCollection_List_TopoDS_Shape SetOfFaces, BRepAlgo_Image InitOffsetFace)

        :type SetOfFaces: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type InitOffsetFace: OCC.wrapper.BRepAlgo.BRepAlgo_Image

        """
        return _BRepOffset.BRepOffset_Inter3d_CompletInt(self, *args)


    def FaceInter(self, *args):
        """
        FaceInter(BRepOffset_Inter3d self, TopoDS_Face F1, TopoDS_Face F2, BRepAlgo_Image InitOffsetFace)

        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type InitOffsetFace: OCC.wrapper.BRepAlgo.BRepAlgo_Image

        """
        return _BRepOffset.BRepOffset_Inter3d_FaceInter(self, *args)


    def ConnexIntByArc(self, *args):
        """
        ConnexIntByArc(BRepOffset_Inter3d self, NCollection_List_TopoDS_Shape SetOfFaces, TopoDS_Shape ShapeInit, BRepOffset_Analyse Analyse, BRepAlgo_Image InitOffsetFace)

        :type SetOfFaces: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type ShapeInit: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Analyse: OCC.wrapper.BRepOffset.BRepOffset_Analyse
        :type InitOffsetFace: OCC.wrapper.BRepAlgo.BRepAlgo_Image

        """
        return _BRepOffset.BRepOffset_Inter3d_ConnexIntByArc(self, *args)


    def ConnexIntByInt(self, *args):
        """
        ConnexIntByInt(BRepOffset_Inter3d self, TopoDS_Shape SI, NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher MapSF, BRepOffset_Analyse A, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher MES, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher Build, NCollection_List_TopoDS_Shape Failed, Standard_Boolean const bIsPlanar)

        :type SI: OCC.wrapper.TopoDS.TopoDS_Shape
        :type MapSF: OCC.wrapper.BRepOffset.BRepOffset_DataMapOfShapeOffset
        :type A: OCC.wrapper.BRepOffset.BRepOffset_Analyse
        :type MES: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape
        :type Build: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape
        :type Failed: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type bIsPlanar: bool

        """
        return _BRepOffset.BRepOffset_Inter3d_ConnexIntByInt(self, *args)


    def ContextIntByInt(self, *args):
        """
        ContextIntByInt(BRepOffset_Inter3d self, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher ContextFaces, Standard_Boolean const ExtentContext, NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher MapSF, BRepOffset_Analyse A, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher MES, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher Build, NCollection_List_TopoDS_Shape Failed, Standard_Boolean const bIsPlanar)

        :type ContextFaces: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape
        :type ExtentContext: bool
        :type MapSF: OCC.wrapper.BRepOffset.BRepOffset_DataMapOfShapeOffset
        :type A: OCC.wrapper.BRepOffset.BRepOffset_Analyse
        :type MES: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape
        :type Build: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape
        :type Failed: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type bIsPlanar: bool

        """
        return _BRepOffset.BRepOffset_Inter3d_ContextIntByInt(self, *args)


    def ContextIntByArc(self, *args):
        """
        ContextIntByArc(BRepOffset_Inter3d self, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher ContextFaces, Standard_Boolean const ExtentContext, BRepOffset_Analyse Analyse, BRepAlgo_Image InitOffsetFace, BRepAlgo_Image InitOffsetEdge)

        :type ContextFaces: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape
        :type ExtentContext: bool
        :type Analyse: OCC.wrapper.BRepOffset.BRepOffset_Analyse
        :type InitOffsetFace: OCC.wrapper.BRepAlgo.BRepAlgo_Image
        :type InitOffsetEdge: OCC.wrapper.BRepAlgo.BRepAlgo_Image

        """
        return _BRepOffset.BRepOffset_Inter3d_ContextIntByArc(self, *args)


    def AddCommonEdges(self, *args):
        """
        AddCommonEdges(BRepOffset_Inter3d self, NCollection_List_TopoDS_Shape SetOfFaces)

        :type SetOfFaces: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepOffset.BRepOffset_Inter3d_AddCommonEdges(self, *args)


    def SetDone(self, *args):
        """
        SetDone(BRepOffset_Inter3d self, TopoDS_Face F1, TopoDS_Face F2)

        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepOffset.BRepOffset_Inter3d_SetDone(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepOffset_Inter3d self, TopoDS_Face F1, TopoDS_Face F2) -> Standard_Boolean

        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.BRepOffset_Inter3d_IsDone(self, *args)


    def TouchedFaces(self, *args):
        """
        TouchedFaces(BRepOffset_Inter3d self) -> NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher

        :rtype: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape

        """
        return _BRepOffset.BRepOffset_Inter3d_TouchedFaces(self, *args)


    def AsDes(self, *args):
        """
        AsDes(BRepOffset_Inter3d self) -> Handle_BRepAlgo_AsDes

        :rtype: OCC.wrapper.BRepAlgo.Handle_BRepAlgo_AsDes

        """
        return _BRepOffset.BRepOffset_Inter3d_AsDes(self, *args)


    def NewEdges(self, *args):
        """
        NewEdges(BRepOffset_Inter3d self) -> NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher

        :rtype: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape

        """
        return _BRepOffset.BRepOffset_Inter3d_NewEdges(self, *args)

    __swig_destroy__ = _BRepOffset.delete_BRepOffset_Inter3d
BRepOffset_Inter3d_swigregister = _BRepOffset.BRepOffset_Inter3d_swigregister
BRepOffset_Inter3d_swigregister(BRepOffset_Inter3d)

class BRepOffset_MakeOffset(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepOffset_MakeOffset self) -> BRepOffset_MakeOffset
        __init__(BRepOffset_MakeOffset self, TopoDS_Shape S, Standard_Real const Offset, Standard_Real const Tol, BRepOffset_Mode const Mode=BRepOffset_Skin, Standard_Boolean const Intersection, Standard_Boolean const SelfInter, GeomAbs_JoinType const Join=GeomAbs_Arc, Standard_Boolean const Thickening, Standard_Boolean const RemoveIntEdges) -> BRepOffset_MakeOffset

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Offset: float
        :type Tol: float
        :type Mode: OCC.wrapper.BRepOffset.BRepOffset_Mode
        :type Intersection: bool
        :type SelfInter: bool
        :type Join: OCC.wrapper.GeomAbs.GeomAbs_JoinType
        :type Thickening: bool
        :type RemoveIntEdges: bool

        """
        this = _BRepOffset.new_BRepOffset_MakeOffset(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(BRepOffset_MakeOffset self, TopoDS_Shape S, Standard_Real const Offset, Standard_Real const Tol, BRepOffset_Mode const Mode=BRepOffset_Skin, Standard_Boolean const Intersection, Standard_Boolean const SelfInter, GeomAbs_JoinType const Join=GeomAbs_Arc, Standard_Boolean const Thickening, Standard_Boolean const RemoveIntEdges)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Offset: float
        :type Tol: float
        :type Mode: OCC.wrapper.BRepOffset.BRepOffset_Mode
        :type Intersection: bool
        :type SelfInter: bool
        :type Join: OCC.wrapper.GeomAbs.GeomAbs_JoinType
        :type Thickening: bool
        :type RemoveIntEdges: bool

        """
        return _BRepOffset.BRepOffset_MakeOffset_Initialize(self, *args)


    def Clear(self, *args):
        """Clear(BRepOffset_MakeOffset self)"""
        return _BRepOffset.BRepOffset_MakeOffset_Clear(self, *args)


    def AddFace(self, *args):
        """
        AddFace(BRepOffset_MakeOffset self, TopoDS_Face F)

        Add Closing Faces,  <F>  has to be  in  the initial
        shape S.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepOffset.BRepOffset_MakeOffset_AddFace(self, *args)


    def SetOffsetOnFace(self, *args):
        """
        SetOffsetOnFace(BRepOffset_MakeOffset self, TopoDS_Face F, Standard_Real const Off)

        set the offset <Off> on the Face <F>

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type Off: float

        """
        return _BRepOffset.BRepOffset_MakeOffset_SetOffsetOnFace(self, *args)


    def MakeOffsetShape(self, *args):
        """MakeOffsetShape(BRepOffset_MakeOffset self)"""
        return _BRepOffset.BRepOffset_MakeOffset_MakeOffsetShape(self, *args)


    def MakeThickSolid(self, *args):
        """MakeThickSolid(BRepOffset_MakeOffset self)"""
        return _BRepOffset.BRepOffset_MakeOffset_MakeThickSolid(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepOffset_MakeOffset self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.BRepOffset_MakeOffset_IsDone(self, *args)


    def Shape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepOffset.BRepOffset_MakeOffset_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(BRepOffset_MakeOffset self) -> BRepOffset_Error

        returns information about offset state.

        :rtype: OCC.wrapper.BRepOffset.BRepOffset_Error

        """
        return _BRepOffset.BRepOffset_MakeOffset_Error(self, *args)


    def OffsetFacesFromShapes(self, *args):
        """
        Returns <Image> containing links between initials
        shapes and offset faces.

        :rtype: OCC.wrapper.BRepAlgo.BRepAlgo_Image

        """
        res = _BRepOffset.BRepOffset_MakeOffset_OffsetFacesFromShapes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetJoinType(self, *args):
        """
        GetJoinType(BRepOffset_MakeOffset self) -> GeomAbs_JoinType

        Returns myJoin.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_JoinType

        """
        return _BRepOffset.BRepOffset_MakeOffset_GetJoinType(self, *args)


    def OffsetEdgesFromShapes(self, *args):
        """
        Returns <Image> containing links between initials
        shapes and offset edges.

        :rtype: OCC.wrapper.BRepAlgo.BRepAlgo_Image

        """
        res = _BRepOffset.BRepOffset_MakeOffset_OffsetEdgesFromShapes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ClosingFaces(self, *args):
        """
        Returns the list of closing faces stores by AddFace

        :rtype: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape

        """
        res = _BRepOffset.BRepOffset_MakeOffset_ClosingFaces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CheckInputData(self, *args):
        """
        CheckInputData(BRepOffset_MakeOffset self) -> Standard_Boolean

        Makes pre analysis of possibility offset perform. Use method Error() to get more information.
        Finds first error. List of checks:
        1) Check for existence object with non-null offset.
        2) Check for connectivity in offset shell.
        3) Check continuity of input surfaces.
        4) Check for normals existence on grid.
        @return True if possible make computations and false otherwise.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.BRepOffset_MakeOffset_CheckInputData(self, *args)


    def GetBadShape(self, *args):
        """
        Return bad shape, which obtained in CheckInputData.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepOffset.BRepOffset_MakeOffset_GetBadShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepOffset.delete_BRepOffset_MakeOffset
BRepOffset_MakeOffset_swigregister = _BRepOffset.BRepOffset_MakeOffset_swigregister
BRepOffset_MakeOffset_swigregister(BRepOffset_MakeOffset)

class BRepOffset_(object):
    """Auxiliary tools for offset algorithms"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Surface(*args):
        """
        Surface(Handle_Geom_Surface Surface, Standard_Real const Offset, Standard_Boolean allowC0) -> Handle_Geom_Surface

        returns   the  Offset  surface  computed from  the
        surface <Surface> at an OffsetDistance <Offset>.

        If possible, this method returns  the real type of
        the surface ( e.g. An Offset of a plane is a plane).

        If  no particular  case  is detected, the returned
        surface will have the Type Geom_OffsetSurface.
        Parameter allowC0 is then passed as last argument to 
        constructor of Geom_OffsetSurface.

        :type Surface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type Offset: float
        :type theStatus: OCC.wrapper.BRepOffset.BRepOffset_Status
        :type allowC0: bool
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _BRepOffset.BRepOffset__Surface(*args)

    Surface = staticmethod(Surface)

    def CollapseSingularities(*args):
        """
        CollapseSingularities(Handle_Geom_Surface theSurface, TopoDS_Face theFace, Standard_Real thePrecision) -> Handle_Geom_Surface

        Preprocess surface to be offset (bspline, bezier, or revolution based on
        bspline or bezier curve), by collapsing each singular side to single point.

        This is to avoid possible flipping of normal at the singularity 
        of the surface due to non-zero distance between the poles that
        logically should be in one point (singularity).

        The (parametric) side of the surface is considered to be singularity if face 
        has degenerated edge whose vertex encompasses (by its tolerance) all points on that side,
        or if all poles defining that side fit into sphere with radius thePrecision.

        Returns either original surface or its modified copy (if some poles have been moved).

        :type theSurface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type thePrecision: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _BRepOffset.BRepOffset__CollapseSingularities(*args)

    CollapseSingularities = staticmethod(CollapseSingularities)

    def __init__(self):
        """Auxiliary tools for offset algorithms"""
        this = _BRepOffset.new_BRepOffset_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepOffset.delete_BRepOffset_
BRepOffset__swigregister = _BRepOffset.BRepOffset__swigregister
BRepOffset__swigregister(BRepOffset_)

def BRepOffset__Surface(*args):
    """
    BRepOffset__Surface(Handle_Geom_Surface Surface, Standard_Real const Offset, Standard_Boolean allowC0) -> Handle_Geom_Surface

    returns   the  Offset  surface  computed from  the
    surface <Surface> at an OffsetDistance <Offset>.

    If possible, this method returns  the real type of
    the surface ( e.g. An Offset of a plane is a plane).

    If  no particular  case  is detected, the returned
    surface will have the Type Geom_OffsetSurface.
    Parameter allowC0 is then passed as last argument to 
    constructor of Geom_OffsetSurface.

    :type Surface: OCC.wrapper.Geom.Handle_Geom_Surface
    :type Offset: float
    :type theStatus: OCC.wrapper.BRepOffset.BRepOffset_Status
    :type allowC0: bool
    :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

    """
    return _BRepOffset.BRepOffset__Surface(*args)

def BRepOffset__CollapseSingularities(*args):
    """
    BRepOffset__CollapseSingularities(Handle_Geom_Surface theSurface, TopoDS_Face theFace, Standard_Real thePrecision) -> Handle_Geom_Surface

    Preprocess surface to be offset (bspline, bezier, or revolution based on
    bspline or bezier curve), by collapsing each singular side to single point.

    This is to avoid possible flipping of normal at the singularity 
    of the surface due to non-zero distance between the poles that
    logically should be in one point (singularity).

    The (parametric) side of the surface is considered to be singularity if face 
    has degenerated edge whose vertex encompasses (by its tolerance) all points on that side,
    or if all poles defining that side fit into sphere with radius thePrecision.

    Returns either original surface or its modified copy (if some poles have been moved).

    :type theSurface: OCC.wrapper.Geom.Handle_Geom_Surface
    :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type thePrecision: float
    :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

    """
    return _BRepOffset.BRepOffset__CollapseSingularities(*args)

class NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,BRepOffset_Offset,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,BRepOffset_Offset,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,BRepOffset_Offset,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,BRepOffset_Offset,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _BRepOffset.new_NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, BRepOffset_Offset theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, BRepOffset_Offset theItem) -> BRepOffset_Offset

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> BRepOffset_Offset

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> BRepOffset_Offset

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> BRepOffset_Offset

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _BRepOffset.delete_NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_swigregister = _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepOffset.new_NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepOffset.delete_NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _BRepOffset.NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher_IteratorHelper)


try:
	BRepOffset_DataMapOfShapeOffset = NCollection_DataMap_TopoDS_Shape_BRepOffset_Offset_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored


try:
	TopTools_MapOfShape = TopTools.NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher
except AttributeError:
	pass # does not exist, probably ignored

class BRepOffset_Tool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def EdgeVertices(*args):
        """
        EdgeVertices(TopoDS_Edge E, TopoDS_Vertex V1, TopoDS_Vertex V2)

        <V1> is the FirstVertex ,<V2> is the Last Vertex of <Edge>
        taking account the orientation of Edge.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type V1: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type V2: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _BRepOffset.BRepOffset_Tool_EdgeVertices(*args)

    EdgeVertices = staticmethod(EdgeVertices)

    def OriEdgeInFace(*args):
        """
        OriEdgeInFace(TopoDS_Edge E, TopoDS_Face F) -> TopAbs_Orientation

        returns the cumul  of the orientation  of <Edge>
        and thc containing wire in <Face>

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _BRepOffset.BRepOffset_Tool_OriEdgeInFace(*args)

    OriEdgeInFace = staticmethod(OriEdgeInFace)

    def OrientSection(*args):
        """
        OrientSection(TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2)

        <E> is a section  between <F1> and <F2>.  Computes
        <O1> the orientation of <E> in <F1> influenced by <F2>.
        idem for <O2>.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type O1: OCC.wrapper.TopAbs.TopAbs_Orientation
        :type O2: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _BRepOffset.BRepOffset_Tool_OrientSection(*args)

    OrientSection = staticmethod(OrientSection)

    def FindCommonShapes(*args):
        """
        FindCommonShapes(TopoDS_Face theF1, TopoDS_Face theF2, NCollection_List_TopoDS_Shape theLE, NCollection_List_TopoDS_Shape theLV) -> Standard_Boolean
        FindCommonShapes(TopoDS_Shape theS1, TopoDS_Shape theS2, TopAbs_ShapeEnum const theType, NCollection_List_TopoDS_Shape theLSC) -> Standard_Boolean

        Looks for the common shapes of type <theType> between shapes <theS1> and <theS2>.<br>
        Returns TRUE if common shapes have been found.<br>
        <theLSC> will contain the found common shapes.

        :type theS1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theS2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type theLSC: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.BRepOffset_Tool_FindCommonShapes(*args)

    FindCommonShapes = staticmethod(FindCommonShapes)

    def Inter3D(*args):
        """
        Inter3D(TopoDS_Face F1, TopoDS_Face F2, NCollection_List_TopoDS_Shape LInt1, NCollection_List_TopoDS_Shape LInt2, TopAbs_State const Side, TopoDS_Edge RefEdge, Standard_Boolean const IsRefEdgeDefined)

        Computes the   Section betwwen  <F1> and  <F2> the
        edges solution   are  stored in <LInt1>  with  the
        orientation on <F1>, the sames edges are stored in
        <Lint2> with the orientation on <F2>.

        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type LInt1: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type LInt2: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type Side: OCC.wrapper.TopAbs.TopAbs_State
        :type RefEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type IsRefEdgeDefined: bool

        """
        return _BRepOffset.BRepOffset_Tool_Inter3D(*args)

    Inter3D = staticmethod(Inter3D)

    def TryProject(*args):
        """
        TryProject(TopoDS_Face F1, TopoDS_Face F2, NCollection_List_TopoDS_Shape Edges, NCollection_List_TopoDS_Shape LInt1, NCollection_List_TopoDS_Shape LInt2, TopAbs_State const Side, Standard_Real const TolConf) -> Standard_Boolean

        Find if the edges <Edges> of the face <F2> are on
        the face <F1>.
        Set in <LInt1> <LInt2> the updated edges.
        If all the edges are computed, returns true.

        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type Edges: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type LInt1: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type LInt2: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type Side: OCC.wrapper.TopAbs.TopAbs_State
        :type TolConf: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.BRepOffset_Tool_TryProject(*args)

    TryProject = staticmethod(TryProject)

    def PipeInter(*args):
        """
        PipeInter(TopoDS_Face F1, TopoDS_Face F2, NCollection_List_TopoDS_Shape LInt1, NCollection_List_TopoDS_Shape LInt2, TopAbs_State const Side)

        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type LInt1: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type LInt2: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type Side: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _BRepOffset.BRepOffset_Tool_PipeInter(*args)

    PipeInter = staticmethod(PipeInter)

    def Inter2d(*args):
        """
        Inter2d(TopoDS_Face F, TopoDS_Edge E1, TopoDS_Edge E2, NCollection_List_TopoDS_Shape LV, Standard_Real const Tol)

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
        :type LV: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type Tol: float

        """
        return _BRepOffset.BRepOffset_Tool_Inter2d(*args)

    Inter2d = staticmethod(Inter2d)

    def InterOrExtent(*args):
        """
        InterOrExtent(TopoDS_Face F1, TopoDS_Face F2, NCollection_List_TopoDS_Shape LInt1, NCollection_List_TopoDS_Shape LInt2, TopAbs_State const Side)

        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type LInt1: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type LInt2: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type Side: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _BRepOffset.BRepOffset_Tool_InterOrExtent(*args)

    InterOrExtent = staticmethod(InterOrExtent)

    def CheckBounds(*args):
        """
        CheckBounds(TopoDS_Face F, BRepOffset_Analyse Analyse)

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type Analyse: OCC.wrapper.BRepOffset.BRepOffset_Analyse
        :type enlargeU: bool
        :type enlargeVfirst: bool
        :type enlargeVlast: bool

        """
        return _BRepOffset.BRepOffset_Tool_CheckBounds(*args)

    CheckBounds = staticmethod(CheckBounds)

    def EnLargeFace(*args):
        """
        EnLargeFace(TopoDS_Face F, TopoDS_Face NF, Standard_Boolean const ChangeGeom, Standard_Boolean const UpDatePCurve, Standard_Boolean const enlargeU, Standard_Boolean const enlargeVfirst, Standard_Boolean const enlargeVlast, Standard_Integer const ExtensionMode=1) -> Standard_Boolean

        if <ChangeGeom> is TRUE  ,   the surface  can  be
        changed .
        if <UpdatePCurve>  is  TRUE, update the  pcurves of the
        edges of <F> on   the new surface.if the surface has  been changed,
        Returns  True if The Surface of  <NF> has changed.
        <ExtensionMode> is a mode of extension of the surface of the face:
        if <ExtensionMode> equals 1, potentially infinite surfaces are extended by maximum value,
        and limited surfaces are extended by 25%.
        if <ExtensionMode> equals 2, potentially infinite surfaces are extended by
        10*(correspondent size of face),
        and limited surfaces are extended by 100%.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NF: OCC.wrapper.TopoDS.TopoDS_Face
        :type ChangeGeom: bool
        :type UpDatePCurve: bool
        :type enlargeU: bool
        :type enlargeVfirst: bool
        :type enlargeVlast: bool
        :type ExtensionMode: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.BRepOffset_Tool_EnLargeFace(*args)

    EnLargeFace = staticmethod(EnLargeFace)

    def ExtentFace(*args):
        """
        ExtentFace(TopoDS_Face F, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher ConstShapes, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher ToBuild, TopAbs_State const Side, Standard_Real const TolConf, TopoDS_Face NF)

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type ConstShapes: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape
        :type ToBuild: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape
        :type Side: OCC.wrapper.TopAbs.TopAbs_State
        :type TolConf: float
        :type NF: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepOffset.BRepOffset_Tool_ExtentFace(*args)

    ExtentFace = staticmethod(ExtentFace)

    def BuildNeighbour(*args):
        """
        BuildNeighbour(TopoDS_Wire W, TopoDS_Face F, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher NOnV1, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher NOnV2)

        Via the wire explorer store in <NOnV1> for
        an Edge <E> of <W> his Edge neighbour on the first
        vertex <V1> of <E>.
        Store in NOnV2 the Neighbour of <E>on the last
        vertex <V2> of <E>.

        :type W: OCC.wrapper.TopoDS.TopoDS_Wire
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NOnV1: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape
        :type NOnV2: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape

        """
        return _BRepOffset.BRepOffset_Tool_BuildNeighbour(*args)

    BuildNeighbour = staticmethod(BuildNeighbour)

    def MapVertexEdges(*args):
        """
        MapVertexEdges(TopoDS_Shape S, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher MVE)

        Store in MVE for a vertex <V>  in <S> the incident
        edges <E> in <S>.
        An Edge is Store only one Time for a vertex.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type MVE: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape

        """
        return _BRepOffset.BRepOffset_Tool_MapVertexEdges(*args)

    MapVertexEdges = staticmethod(MapVertexEdges)

    def Deboucle3D(*args):
        """
        Deboucle3D(TopoDS_Shape S, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher Boundary) -> TopoDS_Shape

        Remove the non valid   part of an offsetshape
        1 - Remove all the free boundary  and the faces
        connex to such edges.
        2 - Remove all the shapes not  valid in the result
        (according to the side of offseting)
        in this verion only the first point is implemented.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Boundary: OCC.wrapper.TopTools.TopTools_MapOfShape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepOffset.BRepOffset_Tool_Deboucle3D(*args)

    Deboucle3D = staticmethod(Deboucle3D)

    def CorrectOrientation(*args):
        """
        CorrectOrientation(TopoDS_Shape SI, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher NewEdges, Handle_BRepAlgo_AsDes AsDes, BRepAlgo_Image InitOffset, Standard_Real const Offset)

        :type SI: OCC.wrapper.TopoDS.TopoDS_Shape
        :type NewEdges: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape
        :type AsDes: OCC.wrapper.BRepAlgo.Handle_BRepAlgo_AsDes
        :type InitOffset: OCC.wrapper.BRepAlgo.BRepAlgo_Image
        :type Offset: float

        """
        return _BRepOffset.BRepOffset_Tool_CorrectOrientation(*args)

    CorrectOrientation = staticmethod(CorrectOrientation)

    def Gabarit(*args):
        """
        Gabarit(Handle_Geom_Curve aCurve) -> Standard_Real

        :type aCurve: OCC.wrapper.Geom.Handle_Geom_Curve
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepOffset.BRepOffset_Tool_Gabarit(*args)

    Gabarit = staticmethod(Gabarit)

    def CheckPlanesNormals(*args):
        """
        CheckPlanesNormals(TopoDS_Face theFace1, TopoDS_Face theFace2, Standard_Real const theTolAng=1.e-8) -> Standard_Boolean

        Compares the normal directions of the planar faces and returns
        TRUE if the directions are the same with the given precision.<br>

        :type theFace1: OCC.wrapper.TopoDS.TopoDS_Face
        :type theFace2: OCC.wrapper.TopoDS.TopoDS_Face
        :type theTolAng: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.BRepOffset_Tool_CheckPlanesNormals(*args)

    CheckPlanesNormals = staticmethod(CheckPlanesNormals)

    def __init__(self):
        this = _BRepOffset.new_BRepOffset_Tool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepOffset.delete_BRepOffset_Tool
BRepOffset_Tool_swigregister = _BRepOffset.BRepOffset_Tool_swigregister
BRepOffset_Tool_swigregister(BRepOffset_Tool)

def BRepOffset_Tool_EdgeVertices(*args):
    """
    BRepOffset_Tool_EdgeVertices(TopoDS_Edge E, TopoDS_Vertex V1, TopoDS_Vertex V2)

    <V1> is the FirstVertex ,<V2> is the Last Vertex of <Edge>
    taking account the orientation of Edge.

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type V1: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type V2: OCC.wrapper.TopoDS.TopoDS_Vertex

    """
    return _BRepOffset.BRepOffset_Tool_EdgeVertices(*args)

def BRepOffset_Tool_OriEdgeInFace(*args):
    """
    BRepOffset_Tool_OriEdgeInFace(TopoDS_Edge E, TopoDS_Face F) -> TopAbs_Orientation

    returns the cumul  of the orientation  of <Edge>
    and thc containing wire in <Face>

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

    """
    return _BRepOffset.BRepOffset_Tool_OriEdgeInFace(*args)

def BRepOffset_Tool_OrientSection(*args):
    """
    BRepOffset_Tool_OrientSection(TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2)

    <E> is a section  between <F1> and <F2>.  Computes
    <O1> the orientation of <E> in <F1> influenced by <F2>.
    idem for <O2>.

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type F1: OCC.wrapper.TopoDS.TopoDS_Face
    :type F2: OCC.wrapper.TopoDS.TopoDS_Face
    :type O1: OCC.wrapper.TopAbs.TopAbs_Orientation
    :type O2: OCC.wrapper.TopAbs.TopAbs_Orientation

    """
    return _BRepOffset.BRepOffset_Tool_OrientSection(*args)

def BRepOffset_Tool_FindCommonShapes(*args):
    """
    FindCommonShapes(TopoDS_Face theF1, TopoDS_Face theF2, NCollection_List_TopoDS_Shape theLE, NCollection_List_TopoDS_Shape theLV) -> Standard_Boolean
    BRepOffset_Tool_FindCommonShapes(TopoDS_Shape theS1, TopoDS_Shape theS2, TopAbs_ShapeEnum const theType, NCollection_List_TopoDS_Shape theLSC) -> Standard_Boolean

    Looks for the common shapes of type <theType> between shapes <theS1> and <theS2>.<br>
    Returns TRUE if common shapes have been found.<br>
    <theLSC> will contain the found common shapes.

    :type theS1: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theS2: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
    :type theLSC: OCC.wrapper.TopTools.TopTools_ListOfShape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepOffset.BRepOffset_Tool_FindCommonShapes(*args)

def BRepOffset_Tool_Inter3D(*args):
    """
    BRepOffset_Tool_Inter3D(TopoDS_Face F1, TopoDS_Face F2, NCollection_List_TopoDS_Shape LInt1, NCollection_List_TopoDS_Shape LInt2, TopAbs_State const Side, TopoDS_Edge RefEdge, Standard_Boolean const IsRefEdgeDefined)

    Computes the   Section betwwen  <F1> and  <F2> the
    edges solution   are  stored in <LInt1>  with  the
    orientation on <F1>, the sames edges are stored in
    <Lint2> with the orientation on <F2>.

    :type F1: OCC.wrapper.TopoDS.TopoDS_Face
    :type F2: OCC.wrapper.TopoDS.TopoDS_Face
    :type LInt1: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type LInt2: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type Side: OCC.wrapper.TopAbs.TopAbs_State
    :type RefEdge: OCC.wrapper.TopoDS.TopoDS_Edge
    :type IsRefEdgeDefined: bool

    """
    return _BRepOffset.BRepOffset_Tool_Inter3D(*args)

def BRepOffset_Tool_TryProject(*args):
    """
    BRepOffset_Tool_TryProject(TopoDS_Face F1, TopoDS_Face F2, NCollection_List_TopoDS_Shape Edges, NCollection_List_TopoDS_Shape LInt1, NCollection_List_TopoDS_Shape LInt2, TopAbs_State const Side, Standard_Real const TolConf) -> Standard_Boolean

    Find if the edges <Edges> of the face <F2> are on
    the face <F1>.
    Set in <LInt1> <LInt2> the updated edges.
    If all the edges are computed, returns true.

    :type F1: OCC.wrapper.TopoDS.TopoDS_Face
    :type F2: OCC.wrapper.TopoDS.TopoDS_Face
    :type Edges: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type LInt1: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type LInt2: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type Side: OCC.wrapper.TopAbs.TopAbs_State
    :type TolConf: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepOffset.BRepOffset_Tool_TryProject(*args)

def BRepOffset_Tool_PipeInter(*args):
    """
    BRepOffset_Tool_PipeInter(TopoDS_Face F1, TopoDS_Face F2, NCollection_List_TopoDS_Shape LInt1, NCollection_List_TopoDS_Shape LInt2, TopAbs_State const Side)

    :type F1: OCC.wrapper.TopoDS.TopoDS_Face
    :type F2: OCC.wrapper.TopoDS.TopoDS_Face
    :type LInt1: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type LInt2: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type Side: OCC.wrapper.TopAbs.TopAbs_State

    """
    return _BRepOffset.BRepOffset_Tool_PipeInter(*args)

def BRepOffset_Tool_Inter2d(*args):
    """
    BRepOffset_Tool_Inter2d(TopoDS_Face F, TopoDS_Edge E1, TopoDS_Edge E2, NCollection_List_TopoDS_Shape LV, Standard_Real const Tol)

    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
    :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
    :type LV: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type Tol: float

    """
    return _BRepOffset.BRepOffset_Tool_Inter2d(*args)

def BRepOffset_Tool_InterOrExtent(*args):
    """
    BRepOffset_Tool_InterOrExtent(TopoDS_Face F1, TopoDS_Face F2, NCollection_List_TopoDS_Shape LInt1, NCollection_List_TopoDS_Shape LInt2, TopAbs_State const Side)

    :type F1: OCC.wrapper.TopoDS.TopoDS_Face
    :type F2: OCC.wrapper.TopoDS.TopoDS_Face
    :type LInt1: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type LInt2: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type Side: OCC.wrapper.TopAbs.TopAbs_State

    """
    return _BRepOffset.BRepOffset_Tool_InterOrExtent(*args)

def BRepOffset_Tool_CheckBounds(*args):
    """
    BRepOffset_Tool_CheckBounds(TopoDS_Face F, BRepOffset_Analyse Analyse)

    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type Analyse: OCC.wrapper.BRepOffset.BRepOffset_Analyse
    :type enlargeU: bool
    :type enlargeVfirst: bool
    :type enlargeVlast: bool

    """
    return _BRepOffset.BRepOffset_Tool_CheckBounds(*args)

def BRepOffset_Tool_EnLargeFace(*args):
    """
    BRepOffset_Tool_EnLargeFace(TopoDS_Face F, TopoDS_Face NF, Standard_Boolean const ChangeGeom, Standard_Boolean const UpDatePCurve, Standard_Boolean const enlargeU, Standard_Boolean const enlargeVfirst, Standard_Boolean const enlargeVlast, Standard_Integer const ExtensionMode=1) -> Standard_Boolean

    if <ChangeGeom> is TRUE  ,   the surface  can  be
    changed .
    if <UpdatePCurve>  is  TRUE, update the  pcurves of the
    edges of <F> on   the new surface.if the surface has  been changed,
    Returns  True if The Surface of  <NF> has changed.
    <ExtensionMode> is a mode of extension of the surface of the face:
    if <ExtensionMode> equals 1, potentially infinite surfaces are extended by maximum value,
    and limited surfaces are extended by 25%.
    if <ExtensionMode> equals 2, potentially infinite surfaces are extended by
    10*(correspondent size of face),
    and limited surfaces are extended by 100%.

    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type NF: OCC.wrapper.TopoDS.TopoDS_Face
    :type ChangeGeom: bool
    :type UpDatePCurve: bool
    :type enlargeU: bool
    :type enlargeVfirst: bool
    :type enlargeVlast: bool
    :type ExtensionMode: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepOffset.BRepOffset_Tool_EnLargeFace(*args)

def BRepOffset_Tool_ExtentFace(*args):
    """
    BRepOffset_Tool_ExtentFace(TopoDS_Face F, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher ConstShapes, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher ToBuild, TopAbs_State const Side, Standard_Real const TolConf, TopoDS_Face NF)

    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type ConstShapes: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape
    :type ToBuild: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape
    :type Side: OCC.wrapper.TopAbs.TopAbs_State
    :type TolConf: float
    :type NF: OCC.wrapper.TopoDS.TopoDS_Face

    """
    return _BRepOffset.BRepOffset_Tool_ExtentFace(*args)

def BRepOffset_Tool_BuildNeighbour(*args):
    """
    BRepOffset_Tool_BuildNeighbour(TopoDS_Wire W, TopoDS_Face F, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher NOnV1, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher NOnV2)

    Via the wire explorer store in <NOnV1> for
    an Edge <E> of <W> his Edge neighbour on the first
    vertex <V1> of <E>.
    Store in NOnV2 the Neighbour of <E>on the last
    vertex <V2> of <E>.

    :type W: OCC.wrapper.TopoDS.TopoDS_Wire
    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type NOnV1: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape
    :type NOnV2: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape

    """
    return _BRepOffset.BRepOffset_Tool_BuildNeighbour(*args)

def BRepOffset_Tool_MapVertexEdges(*args):
    """
    BRepOffset_Tool_MapVertexEdges(TopoDS_Shape S, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher MVE)

    Store in MVE for a vertex <V>  in <S> the incident
    edges <E> in <S>.
    An Edge is Store only one Time for a vertex.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type MVE: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape

    """
    return _BRepOffset.BRepOffset_Tool_MapVertexEdges(*args)

def BRepOffset_Tool_Deboucle3D(*args):
    """
    BRepOffset_Tool_Deboucle3D(TopoDS_Shape S, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher Boundary) -> TopoDS_Shape

    Remove the non valid   part of an offsetshape
    1 - Remove all the free boundary  and the faces
    connex to such edges.
    2 - Remove all the shapes not  valid in the result
    (according to the side of offseting)
    in this verion only the first point is implemented.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type Boundary: OCC.wrapper.TopTools.TopTools_MapOfShape
    :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _BRepOffset.BRepOffset_Tool_Deboucle3D(*args)

def BRepOffset_Tool_CorrectOrientation(*args):
    """
    BRepOffset_Tool_CorrectOrientation(TopoDS_Shape SI, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher NewEdges, Handle_BRepAlgo_AsDes AsDes, BRepAlgo_Image InitOffset, Standard_Real const Offset)

    :type SI: OCC.wrapper.TopoDS.TopoDS_Shape
    :type NewEdges: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape
    :type AsDes: OCC.wrapper.BRepAlgo.Handle_BRepAlgo_AsDes
    :type InitOffset: OCC.wrapper.BRepAlgo.BRepAlgo_Image
    :type Offset: float

    """
    return _BRepOffset.BRepOffset_Tool_CorrectOrientation(*args)

def BRepOffset_Tool_Gabarit(*args):
    """
    BRepOffset_Tool_Gabarit(Handle_Geom_Curve aCurve) -> Standard_Real

    :type aCurve: OCC.wrapper.Geom.Handle_Geom_Curve
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepOffset.BRepOffset_Tool_Gabarit(*args)

def BRepOffset_Tool_CheckPlanesNormals(*args):
    """
    BRepOffset_Tool_CheckPlanesNormals(TopoDS_Face theFace1, TopoDS_Face theFace2, Standard_Real const theTolAng=1.e-8) -> Standard_Boolean

    Compares the normal directions of the planar faces and returns
    TRUE if the directions are the same with the given precision.<br>

    :type theFace1: OCC.wrapper.TopoDS.TopoDS_Face
    :type theFace2: OCC.wrapper.TopoDS.TopoDS_Face
    :type theTolAng: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepOffset.BRepOffset_Tool_CheckPlanesNormals(*args)

class Handle_BRepOffset_SimpleOffset(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepOffset_SimpleOffset self)

        Nullify the handle


        """
        return _BRepOffset.Handle_BRepOffset_SimpleOffset_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepOffset_SimpleOffset self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepOffset.Handle_BRepOffset_SimpleOffset_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepOffset_SimpleOffset self, BRepOffset_SimpleOffset thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepOffset.Handle_BRepOffset_SimpleOffset_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepOffset_SimpleOffset self, Handle_BRepOffset_SimpleOffset theHandle) -> Handle_BRepOffset_SimpleOffset
        assign(Handle_BRepOffset_SimpleOffset self, BRepOffset_SimpleOffset thePtr) -> Handle_BRepOffset_SimpleOffset
        assign(Handle_BRepOffset_SimpleOffset self, Handle_BRepOffset_SimpleOffset theHandle) -> Handle_BRepOffset_SimpleOffset

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepOffset.Handle_BRepOffset_SimpleOffset_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepOffset_SimpleOffset self) -> BRepOffset_SimpleOffset

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepOffset.Handle_BRepOffset_SimpleOffset_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepOffset_SimpleOffset self) -> BRepOffset_SimpleOffset

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepOffset.Handle_BRepOffset_SimpleOffset___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepOffset_SimpleOffset self) -> BRepOffset_SimpleOffset

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepOffset.Handle_BRepOffset_SimpleOffset___ref__(self, *args)


    def __hash__(self):
        return _BRepOffset.Handle_BRepOffset_SimpleOffset___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepOffset.Handle_BRepOffset_SimpleOffset___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepOffset.new_Handle_BRepOffset_SimpleOffset(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepOffset.Handle_BRepOffset_SimpleOffset_DownCast)
    __swig_destroy__ = _BRepOffset.delete_Handle_BRepOffset_SimpleOffset

    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepOffset_SimpleOffset self) -> char const *

        :rtype: const char *

        """
        return _BRepOffset.Handle_BRepOffset_SimpleOffset_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepOffset.Handle_BRepOffset_SimpleOffset_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepOffset.Handle_BRepOffset_SimpleOffset_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NewSurface(self, *args):
        """
        NewSurface(Handle_BRepOffset_SimpleOffset self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True  if  the face  <F> has  been
        modified.  In this  case, <S> is the new geometric
        support of  the  face, <L> the  new location,<Tol>
        the new  tolerance.<RevWires> has  to  be set   to
        Standard_True   when the modification reverses the
        normal of  the   surface.(the wires   have  to  be
        reversed).   <RevFace>   has   to   be   set    to
        Standard_True if  the orientation  of the modified
        face changes in the  shells which contain  it.  --
        Here, <RevFace>  will  return Standard_True if the
        -- gp_Trsf is negative.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :type RevWires: bool
        :type RevFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.Handle_BRepOffset_SimpleOffset_NewSurface(self, *args)


    def NewCurve(self, *args):
        """
        NewCurve(Handle_BRepOffset_SimpleOffset self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True  if  the edge  <E> has  been
        modified.  In this case,  <C> is the new geometric
        support of the  edge, <L> the  new location, <Tol>
        the         new    tolerance.   Otherwise, returns
        Standard_False,    and  <C>,  <L>,   <Tol> are not
        significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.Handle_BRepOffset_SimpleOffset_NewCurve(self, *args)


    def NewPoint(self, *args):
        """
        NewPoint(Handle_BRepOffset_SimpleOffset self, TopoDS_Vertex V, gp_Pnt P) -> Standard_Boolean

        Returns  Standard_True if the  vertex <V> has been
        modified.  In this  case, <P> is the new geometric
        support of the vertex,   <Tol> the new  tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.Handle_BRepOffset_SimpleOffset_NewPoint(self, *args)


    def NewCurve2d(self, *args):
        """
        NewCurve2d(Handle_BRepOffset_SimpleOffset self, TopoDS_Edge E, TopoDS_Face F, TopoDS_Edge NewE, TopoDS_Face NewF, Handle_Geom2d_Curve C) -> Standard_Boolean

        Returns Standard_True if  the edge  <E> has a  new
        curve on surface on the face <F>.In this case, <C>
        is the new geometric support of  the edge, <L> the
        new location, <Tol> the new tolerance.
        Otherwise, returns  Standard_False, and <C>,  <L>,
        <Tol> are not significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF: OCC.wrapper.TopoDS.TopoDS_Face
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.Handle_BRepOffset_SimpleOffset_NewCurve2d(self, *args)


    def NewParameter(self, *args):
        """
        NewParameter(Handle_BRepOffset_SimpleOffset self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        Returns Standard_True if the Vertex  <V> has a new
        parameter on the  edge <E>. In  this case,  <P> is
        the parameter,    <Tol>  the     new    tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.Handle_BRepOffset_SimpleOffset_NewParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_BRepOffset_SimpleOffset self, TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, TopoDS_Edge NewE, TopoDS_Face NewF1, TopoDS_Face NewF2) -> GeomAbs_Shape

        Returns the  continuity of  <NewE> between <NewF1>
        and <NewF2>.

        <NewE> is the new  edge created from <E>.  <NewF1>
        (resp. <NewF2>) is the new  face created from <F1>
        (resp. <F2>).

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewF2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _BRepOffset.Handle_BRepOffset_SimpleOffset_Continuity(self, *args)


    def NewTriangulation(self, *args):
        """
        NewTriangulation(Handle_BRepOffset_SimpleOffset self, TopoDS_Face F, Handle_Poly_Triangulation T) -> Standard_Boolean

        Returns true if the face has been modified according to changed triangulation.
        If the face has been modified:
        - T is a new triangulation on the face

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.Handle_BRepOffset_SimpleOffset_NewTriangulation(self, *args)


    def NewPolygon(self, *args):
        """
        NewPolygon(Handle_BRepOffset_SimpleOffset self, TopoDS_Edge E, Handle_Poly_Polygon3D P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon.
        If the edge has been modified:
        - P is a new polygon

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: OCC.wrapper.Poly.Handle_Poly_Polygon3D
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.Handle_BRepOffset_SimpleOffset_NewPolygon(self, *args)


    def NewPolygonOnTriangulation(self, *args):
        """
        NewPolygonOnTriangulation(Handle_BRepOffset_SimpleOffset self, TopoDS_Edge E, TopoDS_Face F, Handle_Poly_PolygonOnTriangulation P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon on triangulation.
        If the edge has been modified:
        - P is a new polygon on triangulation

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type P: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.Handle_BRepOffset_SimpleOffset_NewPolygonOnTriangulation(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRepOffset_SimpleOffset self)

        Memory deallocator for transient classes


        """
        return _BRepOffset.Handle_BRepOffset_SimpleOffset_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepOffset_SimpleOffset self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepOffset_SimpleOffset self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.Handle_BRepOffset_SimpleOffset_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepOffset_SimpleOffset self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepOffset_SimpleOffset self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.Handle_BRepOffset_SimpleOffset_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepOffset_SimpleOffset self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepOffset.Handle_BRepOffset_SimpleOffset_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepOffset_SimpleOffset self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepOffset.Handle_BRepOffset_SimpleOffset_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepOffset_SimpleOffset self)

        Increments the reference counter of this object


        """
        return _BRepOffset.Handle_BRepOffset_SimpleOffset_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepOffset_SimpleOffset self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepOffset.Handle_BRepOffset_SimpleOffset_DecrementRefCounter(self, *args)

Handle_BRepOffset_SimpleOffset_swigregister = _BRepOffset.Handle_BRepOffset_SimpleOffset_swigregister
Handle_BRepOffset_SimpleOffset_swigregister(Handle_BRepOffset_SimpleOffset)

def Handle_BRepOffset_SimpleOffset_DownCast(thing):
    return _BRepOffset.Handle_BRepOffset_SimpleOffset_DownCast(thing)
Handle_BRepOffset_SimpleOffset_DownCast = _BRepOffset.Handle_BRepOffset_SimpleOffset_DownCast

class BRepOffset_MakeLoops(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(BRepOffset_MakeLoops self) -> BRepOffset_MakeLoops"""
        this = _BRepOffset.new_BRepOffset_MakeLoops(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Build(self, *args):
        """
        Build(BRepOffset_MakeLoops self, NCollection_List_TopoDS_Shape LF, Handle_BRepAlgo_AsDes AsDes, BRepAlgo_Image Image)

        :type LF: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type AsDes: OCC.wrapper.BRepAlgo.Handle_BRepAlgo_AsDes
        :type Image: OCC.wrapper.BRepAlgo.BRepAlgo_Image

        """
        return _BRepOffset.BRepOffset_MakeLoops_Build(self, *args)


    def BuildOnContext(self, *args):
        """
        BuildOnContext(BRepOffset_MakeLoops self, NCollection_List_TopoDS_Shape LContext, BRepOffset_Analyse Analyse, Handle_BRepAlgo_AsDes AsDes, BRepAlgo_Image Image, Standard_Boolean const InSide)

        :type LContext: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type Analyse: OCC.wrapper.BRepOffset.BRepOffset_Analyse
        :type AsDes: OCC.wrapper.BRepAlgo.Handle_BRepAlgo_AsDes
        :type Image: OCC.wrapper.BRepAlgo.BRepAlgo_Image
        :type InSide: bool

        """
        return _BRepOffset.BRepOffset_MakeLoops_BuildOnContext(self, *args)


    def BuildFaces(self, *args):
        """
        BuildFaces(BRepOffset_MakeLoops self, NCollection_List_TopoDS_Shape LF, Handle_BRepAlgo_AsDes AsDes, BRepAlgo_Image Image)

        :type LF: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type AsDes: OCC.wrapper.BRepAlgo.Handle_BRepAlgo_AsDes
        :type Image: OCC.wrapper.BRepAlgo.BRepAlgo_Image

        """
        return _BRepOffset.BRepOffset_MakeLoops_BuildFaces(self, *args)

    __swig_destroy__ = _BRepOffset.delete_BRepOffset_MakeLoops
BRepOffset_MakeLoops_swigregister = _BRepOffset.BRepOffset_MakeLoops_swigregister
BRepOffset_MakeLoops_swigregister(BRepOffset_MakeLoops)

class NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopTools_MapOfShape,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopTools_MapOfShape,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopTools_MapOfShape,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopTools_MapOfShape,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _BRepOffset.new_NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theItem) -> NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepOffset.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepOffset.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _BRepOffset.delete_NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_swigregister = _BRepOffset.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepOffset.new_NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepOffset.delete_NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _BRepOffset.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _BRepOffset.NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher_IteratorHelper)


try:
	BRepOffset_DataMapOfShapeMapOfShape = NCollection_DataMap_TopoDS_Shape_TopTools_MapOfShape_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class BRepOffset_MakeSimpleOffset(object):
    """
    Limitations:
    According to the algorithm nature result depends on the smoothness of input data. Smooth (G1-continuity) input shape
    will lead to the good result.

    The possible drawback of the simple algorithm is that it leads, in general case, to tolerance increasing.
    The tolerances have to grow in order to cover the gaps between the neighbor faces in the output.
    It should be noted that the actual tolerance growth depends on the offset distance and the quality of 
    joints between the input faces. Anyway the good input shell (smooth connections between adjacent faces)
    will lead to good result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepOffset_MakeSimpleOffset self) -> BRepOffset_MakeSimpleOffset
        __init__(BRepOffset_MakeSimpleOffset self, TopoDS_Shape theInputShape, Standard_Real const theOffsetValue) -> BRepOffset_MakeSimpleOffset

        Constructor.

        :type theInputShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theOffsetValue: float

        """
        this = _BRepOffset.new_BRepOffset_MakeSimpleOffset(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(BRepOffset_MakeSimpleOffset self, TopoDS_Shape theInputShape, Standard_Real const theOffsetValue)

        Initialies shape for modifications.

        :type theInputShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theOffsetValue: float

        """
        return _BRepOffset.BRepOffset_MakeSimpleOffset_Initialize(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepOffset_MakeSimpleOffset self)

        Computes offset shape.


        """
        return _BRepOffset.BRepOffset_MakeSimpleOffset_Perform(self, *args)


    def GetErrorMessage(self, *args):
        """
        GetErrorMessage(BRepOffset_MakeSimpleOffset self) -> TCollection_AsciiString

        Gets error message.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _BRepOffset.BRepOffset_MakeSimpleOffset_GetErrorMessage(self, *args)


    def GetError(self, *args):
        """
        GetError(BRepOffset_MakeSimpleOffset self) -> BRepOffsetSimple_Status

        Gets error code.

        :rtype: BRepOffsetSimple_Status

        """
        return _BRepOffset.BRepOffset_MakeSimpleOffset_GetError(self, *args)


    def GetBuildSolidFlag(self, *args):
        """
        GetBuildSolidFlag(BRepOffset_MakeSimpleOffset self) -> Standard_Boolean

        Gets solid building flag.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.BRepOffset_MakeSimpleOffset_GetBuildSolidFlag(self, *args)


    def SetBuildSolidFlag(self, *args):
        """
        SetBuildSolidFlag(BRepOffset_MakeSimpleOffset self, Standard_Boolean const theBuildFlag)

        Sets solid building flag.

        :type theBuildFlag: bool

        """
        return _BRepOffset.BRepOffset_MakeSimpleOffset_SetBuildSolidFlag(self, *args)


    def GetOffsetValue(self, *args):
        """
        GetOffsetValue(BRepOffset_MakeSimpleOffset self) -> Standard_Real

        Gets offset value.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepOffset.BRepOffset_MakeSimpleOffset_GetOffsetValue(self, *args)


    def SetOffsetValue(self, *args):
        """
        SetOffsetValue(BRepOffset_MakeSimpleOffset self, Standard_Real const theOffsetValue)

        Sets offset value.

        :type theOffsetValue: float

        """
        return _BRepOffset.BRepOffset_MakeSimpleOffset_SetOffsetValue(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(BRepOffset_MakeSimpleOffset self) -> Standard_Real

        Gets tolerance (used for handling singularities).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepOffset.BRepOffset_MakeSimpleOffset_GetTolerance(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(BRepOffset_MakeSimpleOffset self, Standard_Real const theValue)

        Sets tolerance (used for handling singularities).

        :type theValue: float

        """
        return _BRepOffset.BRepOffset_MakeSimpleOffset_SetTolerance(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepOffset_MakeSimpleOffset self) -> Standard_Boolean

        Gets done state.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepOffset.BRepOffset_MakeSimpleOffset_IsDone(self, *args)


    def GetResultShape(self, *args):
        """
        Returns result shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepOffset.BRepOffset_MakeSimpleOffset_GetResultShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Generated(self, *args):
        """
        Generated(BRepOffset_MakeSimpleOffset self, TopoDS_Shape theShape) -> TopoDS_Shape

        Returnes result shape for the given one (if exists).

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepOffset.BRepOffset_MakeSimpleOffset_Generated(self, *args)


    def Modified(self, *args):
        """
        Modified(BRepOffset_MakeSimpleOffset self, TopoDS_Shape theShape) -> TopoDS_Shape

        Returnes modified shape for the given one (if exists).

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepOffset.BRepOffset_MakeSimpleOffset_Modified(self, *args)

    __swig_destroy__ = _BRepOffset.delete_BRepOffset_MakeSimpleOffset
BRepOffset_MakeSimpleOffset_swigregister = _BRepOffset.BRepOffset_MakeSimpleOffset_swigregister
BRepOffset_MakeSimpleOffset_swigregister(BRepOffset_MakeSimpleOffset)




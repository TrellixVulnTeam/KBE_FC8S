# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BSplSLib')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BSplSLib')
    _BSplSLib = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BSplSLib', [dirname(__file__)])
        except ImportError:
            import _BSplSLib
            return _BSplSLib
        try:
            _mod = imp.load_module('_BSplSLib', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BSplSLib = swig_import_helper()
    del swig_import_helper
else:
    import _BSplSLib
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BSplSLib.delete_SwigPyIterator

    def value(self):
        return _BSplSLib.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BSplSLib.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BSplSLib.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BSplSLib.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BSplSLib.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BSplSLib.SwigPyIterator_copy(self)

    def next(self):
        return _BSplSLib.SwigPyIterator_next(self)

    def __next__(self):
        return _BSplSLib.SwigPyIterator___next__(self)

    def previous(self):
        return _BSplSLib.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BSplSLib.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BSplSLib.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BSplSLib.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BSplSLib.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BSplSLib.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BSplSLib.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BSplSLib.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BSplSLib.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BSplSLib.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BSplSLib.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BSplSLib.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BSplSLib.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BSplSLib.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BSplSLib.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BSplSLib.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BSplSLib.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BSplSLib.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BSplSLib.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BSplSLib.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BSplSLib.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BSplSLib.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BSplSLib.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BSplSLib.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BSplSLib.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BSplSLib.ptr_to_number(item)
ptr_to_number = _BSplSLib.ptr_to_number

def HashCode(*args):
    return _BSplSLib.HashCode(*args)
HashCode = _BSplSLib.HashCode

def ptr_equal(a, b):
    return _BSplSLib.ptr_equal(a, b)
ptr_equal = _BSplSLib.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
class BSplSLib_(object):
    """
    BSplSLib   B-spline surface Library
    This  package provides   an  implementation  of  geometric
    functions for rational and non rational, periodic  and non
    periodic B-spline surface computation.

    this package uses   the  multi-dimensions splines  methods
    provided in the package BSplCLib.

    In this package the B-spline surface is defined with :
    . its control points :  Array2OfPnt     Poles
    . its weights        :  Array2OfReal    Weights
    . its knots and their multiplicity in the two parametric
    direction U and V  :  Array1OfReal    UKnots, VKnots and
    Array1OfInteger UMults, VMults.
    . the degree of the normalized Spline functions :
    UDegree, VDegree

    . the Booleans URational, VRational to know if the weights
    are constant in the U or V direction.

    . the Booleans UPeriodic,   VRational  to know if the  the
    surface is periodic in the U or V direction.

    Warnings : The  bounds of UKnots  and UMults should be the
    same, the bounds of VKnots and VMults should be  the same,
    the bounds of Poles and Weights shoud be the same.

    The Control points representation is :
    Poles(Uorigin,Vorigin) ...................Poles(Uorigin,Vend)
    .                                     .
    .                                     .
    Poles(Uend, Vorigin) .....................Poles(Uend, Vend)

    For  the double array  the row indice   corresponds to the
    parametric U direction  and the columns indice corresponds
    to the parametric V direction.

    Note: weight and multiplicity arrays can be passed by pointer for
    some functions so that NULL pointer is valid.
    That means no weights/no multiplicities passed.

    KeyWords :
    B-spline surface, Functions, Library

    References :
    . A survey of curve and surface methods in CADG Wolfgang BOHM
    CAGD 1 (1984)
    . On de Boor-like algorithms and blossoming Wolfgang BOEHM
    cagd 5 (1988)
    . Blossoming and knot insertion algorithms for B-spline curves
    Ronald N. GOLDMAN
    . Modelisation des surfaces en CAO, Henri GIAUME Peugeot SA
    . Curves and Surfaces for Computer Aided Geometric Design,
    a practical guide Gerald Farin
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def RationalDerivative(*args):
        """
        RationalDerivative(Standard_Integer const UDeg, Standard_Integer const VDeg, Standard_Integer const N, Standard_Integer const M, Standard_Boolean const All)

        this is a one dimensional function
        typedef  void (*EvaluatorFunction)  (
        Standard_Integer     // Derivative Request
        Standard_Real    *   // StartEnd[2][2]
        //  [0] = U
        //  [1] = V
        //        [0] = start
        //        [1] = end
        Standard_Real        // UParameter
        Standard_Real        // VParamerer
        Standard_Real    &   // Result
        Standard_Integer &) ;// Error Code
        serves to multiply a given vectorial BSpline by a function
        Computes  the     derivatives   of  a    ratio  of
        two-variables functions  x(u,v) / w(u,v) at orders
        <N,M>,    x(u,v)    is   a  vector in    dimension
        <3>.

        <Ders> is  an array  containing the values  of the
        input derivatives from 0  to Min(<N>,<UDeg>), 0 to
        Min(<M>,<VDeg>).    For orders    higher      than
        <UDeg,VDeg>  the  input derivatives are assumed to
        be 0.

        The <Ders> is a 2d array and the  dimension of the
        lines is always (<VDeg>+1) * (<3>+1), even
        if   <N> is smaller  than  <Udeg> (the derivatives
        higher than <N> are not used).

        Content of <Ders> :

        x(i,j)[k] means :  the composant  k of x derivated
        (i) times in u and (j) times in v.

        ... First line ...

        x[1],x[2],...,x[3],w
        x(0,1)[1],...,x(0,1)[3],w(1,0)
        ...
        x(0,VDeg)[1],...,x(0,VDeg)[3],w(0,VDeg)

        ... Then second line ...

        x(1,0)[1],...,x(1,0)[3],w(1,0)
        x(1,1)[1],...,x(1,1)[3],w(1,1)
        ...
        x(1,VDeg)[1],...,x(1,VDeg)[3],w(1,VDeg)

        ...

        ... Last line ...

        x(UDeg,0)[1],...,x(UDeg,0)[3],w(UDeg,0)
        x(UDeg,1)[1],...,x(UDeg,1)[3],w(UDeg,1)
        ...
        x(Udeg,VDeg)[1],...,x(UDeg,VDeg)[3],w(Udeg,VDeg)

        If <All>  is false, only  the derivative  at order
        <N,M> is computed.  <RDers> is an  array of length
        3 which will contain the result :

        x(1)/w , x(2)/w ,  ... derivated <N> <M> times

        If   <All>    is  true  multiples  derivatives are
        computed. All the  derivatives (i,j) with 0 <= i+j
        <= Max(N,M) are  computed.  <RDers> is an array of
        length 3 *  (<N>+1)  * (<M>+1) which  will
        contains :

        x(1)/w , x(2)/w ,  ...
        x(1)/w , x(2)/w ,  ... derivated <0,1> times
        x(1)/w , x(2)/w ,  ... derivated <0,2> times
        ...
        x(1)/w , x(2)/w ,  ... derivated <0,N> times

        x(1)/w , x(2)/w ,  ... derivated <1,0> times
        x(1)/w , x(2)/w ,  ... derivated <1,1> times
        ...
        x(1)/w , x(2)/w ,  ... derivated <1,N> times

        x(1)/w , x(2)/w ,  ... derivated <N,0> times
        ....
        Warning: <RDers> must be dimensionned properly.

        :type UDeg: int
        :type VDeg: int
        :type N: int
        :type M: int
        :type Ders: float
        :type RDers: float
        :type All: bool

        """
        return _BSplSLib.BSplSLib__RationalDerivative(*args)

    RationalDerivative = staticmethod(RationalDerivative)

    def D0(*args):
        """
        D0(Standard_Real const U, Standard_Real const V, Standard_Integer const UIndex, Standard_Integer const VIndex, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real UKnots, NCollection_Array1_Standard_Real VKnots, NCollection_Array1_Standard_Integer UMults, NCollection_Array1_Standard_Integer VMults, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Boolean const URat, Standard_Boolean const VRat, Standard_Boolean const UPer, Standard_Boolean const VPer, gp_Pnt P)

        :type U: float
        :type V: float
        :type UIndex: int
        :type VIndex: int
        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type UKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type VKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type UMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type VMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type UDegree: int
        :type VDegree: int
        :type URat: bool
        :type VRat: bool
        :type UPer: bool
        :type VPer: bool
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _BSplSLib.BSplSLib__D0(*args)

    D0 = staticmethod(D0)

    def D1(*args):
        """
        D1(Standard_Real const U, Standard_Real const V, Standard_Integer const UIndex, Standard_Integer const VIndex, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real UKnots, NCollection_Array1_Standard_Real VKnots, NCollection_Array1_Standard_Integer UMults, NCollection_Array1_Standard_Integer VMults, Standard_Integer const Degree, Standard_Integer const VDegree, Standard_Boolean const URat, Standard_Boolean const VRat, Standard_Boolean const UPer, Standard_Boolean const VPer, gp_Pnt P, gp_Vec Vu, gp_Vec Vv)

        :type U: float
        :type V: float
        :type UIndex: int
        :type VIndex: int
        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type UKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type VKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type UMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type VMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type Degree: int
        :type VDegree: int
        :type URat: bool
        :type VRat: bool
        :type UPer: bool
        :type VPer: bool
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Vu: OCC.wrapper.gp.gp_Vec
        :type Vv: OCC.wrapper.gp.gp_Vec

        """
        return _BSplSLib.BSplSLib__D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        D2(Standard_Real const U, Standard_Real const V, Standard_Integer const UIndex, Standard_Integer const VIndex, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real UKnots, NCollection_Array1_Standard_Real VKnots, NCollection_Array1_Standard_Integer UMults, NCollection_Array1_Standard_Integer VMults, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Boolean const URat, Standard_Boolean const VRat, Standard_Boolean const UPer, Standard_Boolean const VPer, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv)

        :type U: float
        :type V: float
        :type UIndex: int
        :type VIndex: int
        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type UKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type VKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type UMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type VMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type UDegree: int
        :type VDegree: int
        :type URat: bool
        :type VRat: bool
        :type UPer: bool
        :type VPer: bool
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Vu: OCC.wrapper.gp.gp_Vec
        :type Vv: OCC.wrapper.gp.gp_Vec
        :type Vuu: OCC.wrapper.gp.gp_Vec
        :type Vvv: OCC.wrapper.gp.gp_Vec
        :type Vuv: OCC.wrapper.gp.gp_Vec

        """
        return _BSplSLib.BSplSLib__D2(*args)

    D2 = staticmethod(D2)

    def D3(*args):
        """
        D3(Standard_Real const U, Standard_Real const V, Standard_Integer const UIndex, Standard_Integer const VIndex, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real UKnots, NCollection_Array1_Standard_Real VKnots, NCollection_Array1_Standard_Integer UMults, NCollection_Array1_Standard_Integer VMults, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Boolean const URat, Standard_Boolean const VRat, Standard_Boolean const UPer, Standard_Boolean const VPer, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv, gp_Vec Vuuu, gp_Vec Vvvv, gp_Vec Vuuv, gp_Vec Vuvv)

        :type U: float
        :type V: float
        :type UIndex: int
        :type VIndex: int
        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type UKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type VKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type UMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type VMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type UDegree: int
        :type VDegree: int
        :type URat: bool
        :type VRat: bool
        :type UPer: bool
        :type VPer: bool
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Vu: OCC.wrapper.gp.gp_Vec
        :type Vv: OCC.wrapper.gp.gp_Vec
        :type Vuu: OCC.wrapper.gp.gp_Vec
        :type Vvv: OCC.wrapper.gp.gp_Vec
        :type Vuv: OCC.wrapper.gp.gp_Vec
        :type Vuuu: OCC.wrapper.gp.gp_Vec
        :type Vvvv: OCC.wrapper.gp.gp_Vec
        :type Vuuv: OCC.wrapper.gp.gp_Vec
        :type Vuvv: OCC.wrapper.gp.gp_Vec

        """
        return _BSplSLib.BSplSLib__D3(*args)

    D3 = staticmethod(D3)

    def DN(*args):
        """
        DN(Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv, Standard_Integer const UIndex, Standard_Integer const VIndex, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real UKnots, NCollection_Array1_Standard_Real VKnots, NCollection_Array1_Standard_Integer UMults, NCollection_Array1_Standard_Integer VMults, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Boolean const URat, Standard_Boolean const VRat, Standard_Boolean const UPer, Standard_Boolean const VPer, gp_Vec Vn)

        :type U: float
        :type V: float
        :type Nu: int
        :type Nv: int
        :type UIndex: int
        :type VIndex: int
        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type UKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type VKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type UMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type VMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type UDegree: int
        :type VDegree: int
        :type URat: bool
        :type VRat: bool
        :type UPer: bool
        :type VPer: bool
        :type Vn: OCC.wrapper.gp.gp_Vec

        """
        return _BSplSLib.BSplSLib__DN(*args)

    DN = staticmethod(DN)

    def Iso(*args):
        """
        Iso(Standard_Real const Param, Standard_Boolean const IsU, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt CPoles, NCollection_Array1_Standard_Real CWeights)

        Computes the  poles and weights of an isoparametric
        curve at parameter  <Param> (UIso if <IsU> is True,
        VIso  else).

        :type Param: float
        :type IsU: bool
        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type Degree: int
        :type Periodic: bool
        :type CPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type CWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _BSplSLib.BSplSLib__Iso(*args)

    Iso = staticmethod(Iso)

    def HomogeneousD0(*args):
        """
        HomogeneousD0(Standard_Real const U, Standard_Real const V, Standard_Integer const UIndex, Standard_Integer const VIndex, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real UKnots, NCollection_Array1_Standard_Real VKnots, NCollection_Array1_Standard_Integer UMults, NCollection_Array1_Standard_Integer VMults, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Boolean const URat, Standard_Boolean const VRat, Standard_Boolean const UPer, Standard_Boolean const VPer, gp_Pnt P)

        Makes an homogeneous  evaluation of Poles and Weights
        any and returns in P the Numerator value and
        in W the Denominator value if Weights are present
        otherwise returns 1.0e0

        :type U: float
        :type V: float
        :type UIndex: int
        :type VIndex: int
        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type UKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type VKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type UMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type VMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type UDegree: int
        :type VDegree: int
        :type URat: bool
        :type VRat: bool
        :type UPer: bool
        :type VPer: bool
        :type W: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _BSplSLib.BSplSLib__HomogeneousD0(*args)

    HomogeneousD0 = staticmethod(HomogeneousD0)

    def HomogeneousD1(*args):
        """
        HomogeneousD1(Standard_Real const U, Standard_Real const V, Standard_Integer const UIndex, Standard_Integer const VIndex, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real UKnots, NCollection_Array1_Standard_Real VKnots, NCollection_Array1_Standard_Integer UMults, NCollection_Array1_Standard_Integer VMults, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Boolean const URat, Standard_Boolean const VRat, Standard_Boolean const UPer, Standard_Boolean const VPer, gp_Pnt N, gp_Vec Nu, gp_Vec Nv)

        Makes an homogeneous  evaluation of Poles and Weights
        any and returns in P the Numerator value and
        in W the Denominator value if Weights are present
        otherwise returns 1.0e0

        :type U: float
        :type V: float
        :type UIndex: int
        :type VIndex: int
        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type UKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type VKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type UMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type VMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type UDegree: int
        :type VDegree: int
        :type URat: bool
        :type VRat: bool
        :type UPer: bool
        :type VPer: bool
        :type N: OCC.wrapper.gp.gp_Pnt
        :type Nu: OCC.wrapper.gp.gp_Vec
        :type Nv: OCC.wrapper.gp.gp_Vec
        :type D: float
        :type Du: float
        :type Dv: float

        """
        return _BSplSLib.BSplSLib__HomogeneousD1(*args)

    HomogeneousD1 = staticmethod(HomogeneousD1)

    def Reverse(*args):
        """
        Reverse(NCollection_Array2_gp_Pnt Poles, Standard_Integer const Last, Standard_Boolean const UDirection)
        Reverse(NCollection_Array2_Standard_Real Weights, Standard_Integer const Last, Standard_Boolean const UDirection)

        Reverses the array of weights.

        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type Last: int
        :type UDirection: bool

        """
        return _BSplSLib.BSplSLib__Reverse(*args)

    Reverse = staticmethod(Reverse)

    def IsRational(*args):
        """
        IsRational(NCollection_Array2_Standard_Real Weights, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const J1, Standard_Integer const J2, Standard_Real const Epsilon=0.0) -> Standard_Boolean

        Returns False if all the weights  of the  array <Weights>
        in the area [I1,I2] * [J1,J2] are  identic.
        Epsilon  is used for comparing  weights.
        If Epsilon  is 0. the  Epsilon of the first weight is used.

        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type I1: int
        :type I2: int
        :type J1: int
        :type J2: int
        :type Epsilon: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BSplSLib.BSplSLib__IsRational(*args)

    IsRational = staticmethod(IsRational)

    def SetPoles(*args):
        """
        SetPoles(NCollection_Array2_gp_Pnt Poles, NCollection_Array1_Standard_Real FP, Standard_Boolean const UDirection)
        SetPoles(NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real FP, Standard_Boolean const UDirection)

        Copy in FP the coordinates of the poles.

        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type FP: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type UDirection: bool

        """
        return _BSplSLib.BSplSLib__SetPoles(*args)

    SetPoles = staticmethod(SetPoles)

    def GetPoles(*args):
        """
        GetPoles(NCollection_Array1_Standard_Real FP, NCollection_Array2_gp_Pnt Poles, Standard_Boolean const UDirection)
        GetPoles(NCollection_Array1_Standard_Real FP, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, Standard_Boolean const UDirection)

        Get from FP the coordinates of the poles.

        :type FP: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type UDirection: bool

        """
        return _BSplSLib.BSplSLib__GetPoles(*args)

    GetPoles = staticmethod(GetPoles)

    def MovePoint(*args):
        """
        MovePoint(Standard_Real const U, Standard_Real const V, gp_Vec Displ, Standard_Integer const UIndex1, Standard_Integer const UIndex2, Standard_Integer const VIndex1, Standard_Integer const VIndex2, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Boolean const Rational, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real UFlatKnots, NCollection_Array1_Standard_Real VFlatKnots, NCollection_Array2_gp_Pnt NewPoles)

        Find the new poles which allows an old point (with a
        given u,v  as parameters)  to  reach a  new position
        UIndex1,UIndex2 indicate the  range of poles we can
        move for U
        (1, UNbPoles-1) or (2, UNbPoles) -> no constraint
        for one side in U
        (2, UNbPoles-1)   -> the ends are enforced for U
        don't enter (1,NbPoles) and (1,VNbPoles)
        -> error: rigid move
        if problem in BSplineBasis calculation, no change
        for the curve  and
        UFirstIndex, VLastIndex = 0
        VFirstIndex, VLastIndex = 0

        :type U: float
        :type V: float
        :type Displ: OCC.wrapper.gp.gp_Vec
        :type UIndex1: int
        :type UIndex2: int
        :type VIndex1: int
        :type VIndex2: int
        :type UDegree: int
        :type VDegree: int
        :type Rational: bool
        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type UFlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type VFlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type UFirstIndex: int
        :type ULastIndex: int
        :type VFirstIndex: int
        :type VLastIndex: int
        :type NewPoles: OCC.wrapper.TColgp.TColgp_Array2OfPnt

        """
        return _BSplSLib.BSplSLib__MovePoint(*args)

    MovePoint = staticmethod(MovePoint)

    def InsertKnots(*args):
        """
        InsertKnots(Standard_Boolean const UDirection, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_Standard_Real AddKnots, NCollection_Array1_Standard_Integer AddMults, NCollection_Array2_gp_Pnt NewPoles, NCollection_Array2_Standard_Real NewWeights, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults, Standard_Real const Epsilon, Standard_Boolean const Add)

        :type UDirection: bool
        :type Degree: int
        :type Periodic: bool
        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type AddKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type AddMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type NewPoles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type NewWeights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type NewKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NewMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type Epsilon: float
        :type Add: bool

        """
        return _BSplSLib.BSplSLib__InsertKnots(*args)

    InsertKnots = staticmethod(InsertKnots)

    def RemoveKnot(*args):
        """
        RemoveKnot(Standard_Boolean const UDirection, Standard_Integer const Index, Standard_Integer const Mult, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array2_gp_Pnt NewPoles, NCollection_Array2_Standard_Real NewWeights, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults, Standard_Real const Tolerance) -> Standard_Boolean

        :type UDirection: bool
        :type Index: int
        :type Mult: int
        :type Degree: int
        :type Periodic: bool
        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type NewPoles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type NewWeights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type NewKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NewMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type Tolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BSplSLib.BSplSLib__RemoveKnot(*args)

    RemoveKnot = staticmethod(RemoveKnot)

    def IncreaseDegree(*args):
        """
        IncreaseDegree(Standard_Boolean const UDirection, Standard_Integer const Degree, Standard_Integer const NewDegree, Standard_Boolean const Periodic, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array2_gp_Pnt NewPoles, NCollection_Array2_Standard_Real NewWeights, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults)

        :type UDirection: bool
        :type Degree: int
        :type NewDegree: int
        :type Periodic: bool
        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type NewPoles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type NewWeights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type NewKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NewMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _BSplSLib.BSplSLib__IncreaseDegree(*args)

    IncreaseDegree = staticmethod(IncreaseDegree)

    def Unperiodize(*args):
        """
        Unperiodize(Standard_Boolean const UDirection, Standard_Integer const Degree, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_Standard_Real Knots, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Integer NewMults, NCollection_Array1_Standard_Real NewKnots, NCollection_Array2_gp_Pnt NewPoles, NCollection_Array2_Standard_Real NewWeights)

        :type UDirection: bool
        :type Degree: int
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type NewMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type NewKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NewPoles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type NewWeights: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        return _BSplSLib.BSplSLib__Unperiodize(*args)

    Unperiodize = staticmethod(Unperiodize)

    def NoWeights(*args):
        """
        NoWeights() -> NCollection_Array2_Standard_Real

        Used as argument for a non rational curve.

        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        return _BSplSLib.BSplSLib__NoWeights(*args)

    NoWeights = staticmethod(NoWeights)

    def BuildCache(*args):
        """
        BuildCache(Standard_Real const U, Standard_Real const V, Standard_Real const USpanDomain, Standard_Real const VSpanDomain, Standard_Boolean const UPeriodicFlag, Standard_Boolean const VPeriodicFlag, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Integer const UIndex, Standard_Integer const VIndex, NCollection_Array1_Standard_Real UFlatKnots, NCollection_Array1_Standard_Real VFlatKnots, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array2_gp_Pnt CachePoles, NCollection_Array2_Standard_Real CacheWeights)
        BuildCache(Standard_Real const theU, Standard_Real const theV, Standard_Real const theUSpanDomain, Standard_Real const theVSpanDomain, Standard_Boolean const theUPeriodic, Standard_Boolean const theVPeriodic, Standard_Integer const theUDegree, Standard_Integer const theVDegree, Standard_Integer const theUIndex, Standard_Integer const theVIndex, NCollection_Array1_Standard_Real theUFlatKnots, NCollection_Array1_Standard_Real theVFlatKnots, NCollection_Array2_gp_Pnt thePoles, NCollection_Array2_Standard_Real theWeights, NCollection_Array2_Standard_Real theCacheArray)

        Perform the evaluation of the Taylor expansion
        of the Bspline normalized between 0 and 1.
        Structure of result optimized for BSplSLib_Cache.

        :type theU: float
        :type theV: float
        :type theUSpanDomain: float
        :type theVSpanDomain: float
        :type theUPeriodic: bool
        :type theVPeriodic: bool
        :type theUDegree: int
        :type theVDegree: int
        :type theUIndex: int
        :type theVIndex: int
        :type theUFlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type theVFlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type thePoles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type theWeights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type theCacheArray: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        return _BSplSLib.BSplSLib__BuildCache(*args)

    BuildCache = staticmethod(BuildCache)

    def CacheD0(*args):
        """
        CacheD0(Standard_Real const U, Standard_Real const V, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Real const UCacheParameter, Standard_Real const VCacheParameter, Standard_Real const USpanLenght, Standard_Real const VSpanLength, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, gp_Pnt Point)

        Perform the evaluation of the of the cache
        the parameter must be normalized between
        the 0 and 1 for the span.
        The Cache must be valid when calling this
        routine. Geom Package will insure that.
        and then multiplies by the weights
        this just evaluates the current point
        the CacheParameter is where the Cache was
        constructed the SpanLength is to normalize
        the polynomial in the cache to avoid bad conditioning
        effects

        :type U: float
        :type V: float
        :type UDegree: int
        :type VDegree: int
        :type UCacheParameter: float
        :type VCacheParameter: float
        :type USpanLenght: float
        :type VSpanLength: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type Point: OCC.wrapper.gp.gp_Pnt

        """
        return _BSplSLib.BSplSLib__CacheD0(*args)

    CacheD0 = staticmethod(CacheD0)

    def CoefsD0(*args):
        """
        CoefsD0(Standard_Real const U, Standard_Real const V, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, gp_Pnt Point)

        Calls CacheD0 for Bezier Surfaces Arrays computed with
        the method PolesCoefficients.
        Warning: To be used for BezierSurfaces ONLY!!!

        :type U: float
        :type V: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type Point: OCC.wrapper.gp.gp_Pnt

        """
        return _BSplSLib.BSplSLib__CoefsD0(*args)

    CoefsD0 = staticmethod(CoefsD0)

    def CacheD1(*args):
        """
        CacheD1(Standard_Real const U, Standard_Real const V, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Real const UCacheParameter, Standard_Real const VCacheParameter, Standard_Real const USpanLenght, Standard_Real const VSpanLength, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, gp_Pnt Point, gp_Vec VecU, gp_Vec VecV)

        Perform the evaluation of the of the cache
        the parameter must be normalized between
        the 0 and 1 for the span.
        The Cache must be valid when calling this
        routine. Geom Package will insure that.
        and then multiplies by the weights
        this just evaluates the current point
        the CacheParameter is where the Cache was
        constructed the SpanLength is to normalize
        the polynomial in the cache to avoid bad conditioning
        effects

        :type U: float
        :type V: float
        :type UDegree: int
        :type VDegree: int
        :type UCacheParameter: float
        :type VCacheParameter: float
        :type USpanLenght: float
        :type VSpanLength: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type Point: OCC.wrapper.gp.gp_Pnt
        :type VecU: OCC.wrapper.gp.gp_Vec
        :type VecV: OCC.wrapper.gp.gp_Vec

        """
        return _BSplSLib.BSplSLib__CacheD1(*args)

    CacheD1 = staticmethod(CacheD1)

    def CoefsD1(*args):
        """
        CoefsD1(Standard_Real const U, Standard_Real const V, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, gp_Pnt Point, gp_Vec VecU, gp_Vec VecV)

        Calls CacheD0 for Bezier Surfaces Arrays computed with
        the method PolesCoefficients.
        Warning: To be used for BezierSurfaces ONLY!!!

        :type U: float
        :type V: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type Point: OCC.wrapper.gp.gp_Pnt
        :type VecU: OCC.wrapper.gp.gp_Vec
        :type VecV: OCC.wrapper.gp.gp_Vec

        """
        return _BSplSLib.BSplSLib__CoefsD1(*args)

    CoefsD1 = staticmethod(CoefsD1)

    def CacheD2(*args):
        """
        CacheD2(Standard_Real const U, Standard_Real const V, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Real const UCacheParameter, Standard_Real const VCacheParameter, Standard_Real const USpanLenght, Standard_Real const VSpanLength, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, gp_Pnt Point, gp_Vec VecU, gp_Vec VecV, gp_Vec VecUU, gp_Vec VecUV, gp_Vec VecVV)

        Perform the evaluation of the of the cache
        the parameter must be normalized between
        the 0 and 1 for the span.
        The Cache must be valid when calling this
        routine. Geom Package will insure that.
        and then multiplies by the weights
        this just evaluates the current point
        the CacheParameter is where the Cache was
        constructed the SpanLength is to normalize
        the polynomial in the cache to avoid bad conditioning
        effects

        :type U: float
        :type V: float
        :type UDegree: int
        :type VDegree: int
        :type UCacheParameter: float
        :type VCacheParameter: float
        :type USpanLenght: float
        :type VSpanLength: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type Point: OCC.wrapper.gp.gp_Pnt
        :type VecU: OCC.wrapper.gp.gp_Vec
        :type VecV: OCC.wrapper.gp.gp_Vec
        :type VecUU: OCC.wrapper.gp.gp_Vec
        :type VecUV: OCC.wrapper.gp.gp_Vec
        :type VecVV: OCC.wrapper.gp.gp_Vec

        """
        return _BSplSLib.BSplSLib__CacheD2(*args)

    CacheD2 = staticmethod(CacheD2)

    def CoefsD2(*args):
        """
        CoefsD2(Standard_Real const U, Standard_Real const V, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, gp_Pnt Point, gp_Vec VecU, gp_Vec VecV, gp_Vec VecUU, gp_Vec VecUV, gp_Vec VecVV)

        Calls CacheD0 for Bezier Surfaces Arrays computed with
        the method PolesCoefficients.
        Warning: To be used for BezierSurfaces ONLY!!!

        :type U: float
        :type V: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type Point: OCC.wrapper.gp.gp_Pnt
        :type VecU: OCC.wrapper.gp.gp_Vec
        :type VecV: OCC.wrapper.gp.gp_Vec
        :type VecUU: OCC.wrapper.gp.gp_Vec
        :type VecUV: OCC.wrapper.gp.gp_Vec
        :type VecVV: OCC.wrapper.gp.gp_Vec

        """
        return _BSplSLib.BSplSLib__CoefsD2(*args)

    CoefsD2 = staticmethod(CoefsD2)

    def PolesCoefficients(*args):
        """
        PolesCoefficients(NCollection_Array2_gp_Pnt Poles, NCollection_Array2_gp_Pnt CachePoles)
        PolesCoefficients(NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array2_gp_Pnt CachePoles, NCollection_Array2_Standard_Real CacheWeights)

        Encapsulation   of  BuildCache    to   perform   the
        evaluation  of the Taylor expansion for beziersurfaces
        at parameters 0.,0.;
        Warning: To be used for BezierSurfaces ONLY!!!

        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type CachePoles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type CacheWeights: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        return _BSplSLib.BSplSLib__PolesCoefficients(*args)

    PolesCoefficients = staticmethod(PolesCoefficients)

    def Resolution(*args):
        """
        Resolution(NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real UKnots, NCollection_Array1_Standard_Real VKnots, NCollection_Array1_Standard_Integer UMults, NCollection_Array1_Standard_Integer VMults, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Boolean const URat, Standard_Boolean const VRat, Standard_Boolean const UPer, Standard_Boolean const VPer, Standard_Real const Tolerance3D)

        Given a tolerance in 3D space returns two
        tolerances, one in U one in V such that for
        all (u1,v1) and (u0,v0) in the domain of
        the surface f(u,v)  we have :
        | u1 - u0 | < UTolerance and
        | v1 - v0 | < VTolerance
        we have |f (u1,v1) - f (u0,v0)| < Tolerance3D

        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type UKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type VKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type UMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type VMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type UDegree: int
        :type VDegree: int
        :type URat: bool
        :type VRat: bool
        :type UPer: bool
        :type VPer: bool
        :type Tolerance3D: float
        :type UTolerance: float
        :type VTolerance: float

        """
        return _BSplSLib.BSplSLib__Resolution(*args)

    Resolution = staticmethod(Resolution)

    def Interpolate(*args):
        """
        Interpolate(Standard_Integer const UDegree, Standard_Integer const VDegree, NCollection_Array1_Standard_Real UFlatKnots, NCollection_Array1_Standard_Real VFlatKnots, NCollection_Array1_Standard_Real UParameters, NCollection_Array1_Standard_Real VParameters, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights)
        Interpolate(Standard_Integer const UDegree, Standard_Integer const VDegree, NCollection_Array1_Standard_Real UFlatKnots, NCollection_Array1_Standard_Real VFlatKnots, NCollection_Array1_Standard_Real UParameters, NCollection_Array1_Standard_Real VParameters, NCollection_Array2_gp_Pnt Poles)

        Performs the interpolation of the data points given in
        the  Poles array.
        The  ColLength CL and the Length of UParameters must be
        the  same. The length of VFlatKnots is VDegree + CL + 1.

        The  RowLength RL and the Length of VParameters must be
        the  same. The length of VFlatKnots is Degree + RL + 1.

        Warning: the method used  to do that  interpolation
        is gauss  elimination  WITHOUT pivoting.  Thus if  the
        diagonal is not  dominant  there is no guarantee  that
        the   algorithm will    work.  Nevertheless  for Cubic
        interpolation  at knots or interpolation at Scheonberg
        points  the method   will work.  The  InversionProblem
        will  report 0 if there   was no problem  else it will
        give the index of the faulty pivot

        :type UDegree: int
        :type VDegree: int
        :type UFlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type VFlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type UParameters: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type VParameters: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type InversionProblem: int

        """
        return _BSplSLib.BSplSLib__Interpolate(*args)

    Interpolate = staticmethod(Interpolate)

    def FunctionMultiply(*args):
        """
        FunctionMultiply(BSplSLib_EvaluatorFunction Function, Standard_Integer const UBSplineDegree, Standard_Integer const VBSplineDegree, NCollection_Array1_Standard_Real UBSplineKnots, NCollection_Array1_Standard_Real VBSplineKnots, NCollection_Array1_Standard_Integer UMults, NCollection_Array1_Standard_Integer VMults, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real UFlatKnots, NCollection_Array1_Standard_Real VFlatKnots, Standard_Integer const UNewDegree, Standard_Integer const VNewDegree, NCollection_Array2_gp_Pnt NewNumerator, NCollection_Array2_Standard_Real NewDenominator)

        this will multiply  a given BSpline numerator  N(u,v)
        and    denominator    D(u,v)  defined     by   its
        U/VBSplineDegree   and    U/VBSplineKnots,     and
        U/VMults. Its Poles  and Weights are arrays which are
        coded   as      array2      of      the    form
        [1..UNumPoles][1..VNumPoles]  by  a function a(u,v)
        which  is assumed  to satisfy    the following :  1.
        a(u,v)  * N(u,v) and a(u,v) *  D(u,v)  is a polynomial
        BSpline that can be expressed exactly as a BSpline of
        degree U/VNewDegree  on  the knots U/VFlatKnots 2. the range
        of a(u,v) is   the   same as  the range   of  N(u,v)
        or D(u,v)
        ---Warning:  it is   the caller's  responsability  to
        insure that conditions 1. and  2. above are satisfied
        : no  check  whatsoever is made   in  this method  --
        theStatus will  return 0 if  OK else it will return  the
        pivot index -- of the   matrix that was inverted to
        compute the multiplied -- BSpline  : the method used
        is  interpolation   at Schoenenberg   --  points  of
        a(u,v)* N(u,v) and a(u,v) * D(u,v)
        theStatus will return 0 if OK else it will return the pivot index
        of the matrix that was inverted to compute the multiplied
        BSpline : the method used is interpolation at Schoenenberg
        points of a(u,v)*F(u,v)
        --

        :type Function: OCC.wrapper.BSplSLib.BSplSLib_EvaluatorFunction
        :type UBSplineDegree: int
        :type VBSplineDegree: int
        :type UBSplineKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type VBSplineKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type UMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type VMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type UFlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type VFlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type UNewDegree: int
        :type VNewDegree: int
        :type NewNumerator: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type NewDenominator: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type theStatus: int

        """
        return _BSplSLib.BSplSLib__FunctionMultiply(*args)

    FunctionMultiply = staticmethod(FunctionMultiply)

    def __init__(self):
        """
        BSplSLib   B-spline surface Library
        This  package provides   an  implementation  of  geometric
        functions for rational and non rational, periodic  and non
        periodic B-spline surface computation.

        this package uses   the  multi-dimensions splines  methods
        provided in the package BSplCLib.

        In this package the B-spline surface is defined with :
        . its control points :  Array2OfPnt     Poles
        . its weights        :  Array2OfReal    Weights
        . its knots and their multiplicity in the two parametric
        direction U and V  :  Array1OfReal    UKnots, VKnots and
        Array1OfInteger UMults, VMults.
        . the degree of the normalized Spline functions :
        UDegree, VDegree

        . the Booleans URational, VRational to know if the weights
        are constant in the U or V direction.

        . the Booleans UPeriodic,   VRational  to know if the  the
        surface is periodic in the U or V direction.

        Warnings : The  bounds of UKnots  and UMults should be the
        same, the bounds of VKnots and VMults should be  the same,
        the bounds of Poles and Weights shoud be the same.

        The Control points representation is :
        Poles(Uorigin,Vorigin) ...................Poles(Uorigin,Vend)
        .                                     .
        .                                     .
        Poles(Uend, Vorigin) .....................Poles(Uend, Vend)

        For  the double array  the row indice   corresponds to the
        parametric U direction  and the columns indice corresponds
        to the parametric V direction.

        Note: weight and multiplicity arrays can be passed by pointer for
        some functions so that NULL pointer is valid.
        That means no weights/no multiplicities passed.

        KeyWords :
        B-spline surface, Functions, Library

        References :
        . A survey of curve and surface methods in CADG Wolfgang BOHM
        CAGD 1 (1984)
        . On de Boor-like algorithms and blossoming Wolfgang BOEHM
        cagd 5 (1988)
        . Blossoming and knot insertion algorithms for B-spline curves
        Ronald N. GOLDMAN
        . Modelisation des surfaces en CAO, Henri GIAUME Peugeot SA
        . Curves and Surfaces for Computer Aided Geometric Design,
        a practical guide Gerald Farin
        """
        this = _BSplSLib.new_BSplSLib_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BSplSLib.delete_BSplSLib_
BSplSLib__swigregister = _BSplSLib.BSplSLib__swigregister
BSplSLib__swigregister(BSplSLib_)

def BSplSLib__RationalDerivative(*args):
    """
    BSplSLib__RationalDerivative(Standard_Integer const UDeg, Standard_Integer const VDeg, Standard_Integer const N, Standard_Integer const M, Standard_Boolean const All)

    this is a one dimensional function
    typedef  void (*EvaluatorFunction)  (
    Standard_Integer     // Derivative Request
    Standard_Real    *   // StartEnd[2][2]
    //  [0] = U
    //  [1] = V
    //        [0] = start
    //        [1] = end
    Standard_Real        // UParameter
    Standard_Real        // VParamerer
    Standard_Real    &   // Result
    Standard_Integer &) ;// Error Code
    serves to multiply a given vectorial BSpline by a function
    Computes  the     derivatives   of  a    ratio  of
    two-variables functions  x(u,v) / w(u,v) at orders
    <N,M>,    x(u,v)    is   a  vector in    dimension
    <3>.

    <Ders> is  an array  containing the values  of the
    input derivatives from 0  to Min(<N>,<UDeg>), 0 to
    Min(<M>,<VDeg>).    For orders    higher      than
    <UDeg,VDeg>  the  input derivatives are assumed to
    be 0.

    The <Ders> is a 2d array and the  dimension of the
    lines is always (<VDeg>+1) * (<3>+1), even
    if   <N> is smaller  than  <Udeg> (the derivatives
    higher than <N> are not used).

    Content of <Ders> :

    x(i,j)[k] means :  the composant  k of x derivated
    (i) times in u and (j) times in v.

    ... First line ...

    x[1],x[2],...,x[3],w
    x(0,1)[1],...,x(0,1)[3],w(1,0)
    ...
    x(0,VDeg)[1],...,x(0,VDeg)[3],w(0,VDeg)

    ... Then second line ...

    x(1,0)[1],...,x(1,0)[3],w(1,0)
    x(1,1)[1],...,x(1,1)[3],w(1,1)
    ...
    x(1,VDeg)[1],...,x(1,VDeg)[3],w(1,VDeg)

    ...

    ... Last line ...

    x(UDeg,0)[1],...,x(UDeg,0)[3],w(UDeg,0)
    x(UDeg,1)[1],...,x(UDeg,1)[3],w(UDeg,1)
    ...
    x(Udeg,VDeg)[1],...,x(UDeg,VDeg)[3],w(Udeg,VDeg)

    If <All>  is false, only  the derivative  at order
    <N,M> is computed.  <RDers> is an  array of length
    3 which will contain the result :

    x(1)/w , x(2)/w ,  ... derivated <N> <M> times

    If   <All>    is  true  multiples  derivatives are
    computed. All the  derivatives (i,j) with 0 <= i+j
    <= Max(N,M) are  computed.  <RDers> is an array of
    length 3 *  (<N>+1)  * (<M>+1) which  will
    contains :

    x(1)/w , x(2)/w ,  ...
    x(1)/w , x(2)/w ,  ... derivated <0,1> times
    x(1)/w , x(2)/w ,  ... derivated <0,2> times
    ...
    x(1)/w , x(2)/w ,  ... derivated <0,N> times

    x(1)/w , x(2)/w ,  ... derivated <1,0> times
    x(1)/w , x(2)/w ,  ... derivated <1,1> times
    ...
    x(1)/w , x(2)/w ,  ... derivated <1,N> times

    x(1)/w , x(2)/w ,  ... derivated <N,0> times
    ....
    Warning: <RDers> must be dimensionned properly.

    :type UDeg: int
    :type VDeg: int
    :type N: int
    :type M: int
    :type Ders: float
    :type RDers: float
    :type All: bool

    """
    return _BSplSLib.BSplSLib__RationalDerivative(*args)

def BSplSLib__D0(*args):
    """
    BSplSLib__D0(Standard_Real const U, Standard_Real const V, Standard_Integer const UIndex, Standard_Integer const VIndex, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real UKnots, NCollection_Array1_Standard_Real VKnots, NCollection_Array1_Standard_Integer UMults, NCollection_Array1_Standard_Integer VMults, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Boolean const URat, Standard_Boolean const VRat, Standard_Boolean const UPer, Standard_Boolean const VPer, gp_Pnt P)

    :type U: float
    :type V: float
    :type UIndex: int
    :type VIndex: int
    :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type UKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type VKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type UMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type VMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type UDegree: int
    :type VDegree: int
    :type URat: bool
    :type VRat: bool
    :type UPer: bool
    :type VPer: bool
    :type P: OCC.wrapper.gp.gp_Pnt

    """
    return _BSplSLib.BSplSLib__D0(*args)

def BSplSLib__D1(*args):
    """
    BSplSLib__D1(Standard_Real const U, Standard_Real const V, Standard_Integer const UIndex, Standard_Integer const VIndex, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real UKnots, NCollection_Array1_Standard_Real VKnots, NCollection_Array1_Standard_Integer UMults, NCollection_Array1_Standard_Integer VMults, Standard_Integer const Degree, Standard_Integer const VDegree, Standard_Boolean const URat, Standard_Boolean const VRat, Standard_Boolean const UPer, Standard_Boolean const VPer, gp_Pnt P, gp_Vec Vu, gp_Vec Vv)

    :type U: float
    :type V: float
    :type UIndex: int
    :type VIndex: int
    :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type UKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type VKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type UMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type VMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type Degree: int
    :type VDegree: int
    :type URat: bool
    :type VRat: bool
    :type UPer: bool
    :type VPer: bool
    :type P: OCC.wrapper.gp.gp_Pnt
    :type Vu: OCC.wrapper.gp.gp_Vec
    :type Vv: OCC.wrapper.gp.gp_Vec

    """
    return _BSplSLib.BSplSLib__D1(*args)

def BSplSLib__D2(*args):
    """
    BSplSLib__D2(Standard_Real const U, Standard_Real const V, Standard_Integer const UIndex, Standard_Integer const VIndex, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real UKnots, NCollection_Array1_Standard_Real VKnots, NCollection_Array1_Standard_Integer UMults, NCollection_Array1_Standard_Integer VMults, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Boolean const URat, Standard_Boolean const VRat, Standard_Boolean const UPer, Standard_Boolean const VPer, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv)

    :type U: float
    :type V: float
    :type UIndex: int
    :type VIndex: int
    :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type UKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type VKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type UMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type VMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type UDegree: int
    :type VDegree: int
    :type URat: bool
    :type VRat: bool
    :type UPer: bool
    :type VPer: bool
    :type P: OCC.wrapper.gp.gp_Pnt
    :type Vu: OCC.wrapper.gp.gp_Vec
    :type Vv: OCC.wrapper.gp.gp_Vec
    :type Vuu: OCC.wrapper.gp.gp_Vec
    :type Vvv: OCC.wrapper.gp.gp_Vec
    :type Vuv: OCC.wrapper.gp.gp_Vec

    """
    return _BSplSLib.BSplSLib__D2(*args)

def BSplSLib__D3(*args):
    """
    BSplSLib__D3(Standard_Real const U, Standard_Real const V, Standard_Integer const UIndex, Standard_Integer const VIndex, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real UKnots, NCollection_Array1_Standard_Real VKnots, NCollection_Array1_Standard_Integer UMults, NCollection_Array1_Standard_Integer VMults, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Boolean const URat, Standard_Boolean const VRat, Standard_Boolean const UPer, Standard_Boolean const VPer, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv, gp_Vec Vuuu, gp_Vec Vvvv, gp_Vec Vuuv, gp_Vec Vuvv)

    :type U: float
    :type V: float
    :type UIndex: int
    :type VIndex: int
    :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type UKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type VKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type UMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type VMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type UDegree: int
    :type VDegree: int
    :type URat: bool
    :type VRat: bool
    :type UPer: bool
    :type VPer: bool
    :type P: OCC.wrapper.gp.gp_Pnt
    :type Vu: OCC.wrapper.gp.gp_Vec
    :type Vv: OCC.wrapper.gp.gp_Vec
    :type Vuu: OCC.wrapper.gp.gp_Vec
    :type Vvv: OCC.wrapper.gp.gp_Vec
    :type Vuv: OCC.wrapper.gp.gp_Vec
    :type Vuuu: OCC.wrapper.gp.gp_Vec
    :type Vvvv: OCC.wrapper.gp.gp_Vec
    :type Vuuv: OCC.wrapper.gp.gp_Vec
    :type Vuvv: OCC.wrapper.gp.gp_Vec

    """
    return _BSplSLib.BSplSLib__D3(*args)

def BSplSLib__DN(*args):
    """
    BSplSLib__DN(Standard_Real const U, Standard_Real const V, Standard_Integer const Nu, Standard_Integer const Nv, Standard_Integer const UIndex, Standard_Integer const VIndex, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real UKnots, NCollection_Array1_Standard_Real VKnots, NCollection_Array1_Standard_Integer UMults, NCollection_Array1_Standard_Integer VMults, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Boolean const URat, Standard_Boolean const VRat, Standard_Boolean const UPer, Standard_Boolean const VPer, gp_Vec Vn)

    :type U: float
    :type V: float
    :type Nu: int
    :type Nv: int
    :type UIndex: int
    :type VIndex: int
    :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type UKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type VKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type UMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type VMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type UDegree: int
    :type VDegree: int
    :type URat: bool
    :type VRat: bool
    :type UPer: bool
    :type VPer: bool
    :type Vn: OCC.wrapper.gp.gp_Vec

    """
    return _BSplSLib.BSplSLib__DN(*args)

def BSplSLib__Iso(*args):
    """
    BSplSLib__Iso(Standard_Real const Param, Standard_Boolean const IsU, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array1_gp_Pnt CPoles, NCollection_Array1_Standard_Real CWeights)

    Computes the  poles and weights of an isoparametric
    curve at parameter  <Param> (UIso if <IsU> is True,
    VIso  else).

    :type Param: float
    :type IsU: bool
    :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type Degree: int
    :type Periodic: bool
    :type CPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
    :type CWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal

    """
    return _BSplSLib.BSplSLib__Iso(*args)

def BSplSLib__HomogeneousD0(*args):
    """
    BSplSLib__HomogeneousD0(Standard_Real const U, Standard_Real const V, Standard_Integer const UIndex, Standard_Integer const VIndex, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real UKnots, NCollection_Array1_Standard_Real VKnots, NCollection_Array1_Standard_Integer UMults, NCollection_Array1_Standard_Integer VMults, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Boolean const URat, Standard_Boolean const VRat, Standard_Boolean const UPer, Standard_Boolean const VPer, gp_Pnt P)

    Makes an homogeneous  evaluation of Poles and Weights
    any and returns in P the Numerator value and
    in W the Denominator value if Weights are present
    otherwise returns 1.0e0

    :type U: float
    :type V: float
    :type UIndex: int
    :type VIndex: int
    :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type UKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type VKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type UMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type VMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type UDegree: int
    :type VDegree: int
    :type URat: bool
    :type VRat: bool
    :type UPer: bool
    :type VPer: bool
    :type W: float
    :type P: OCC.wrapper.gp.gp_Pnt

    """
    return _BSplSLib.BSplSLib__HomogeneousD0(*args)

def BSplSLib__HomogeneousD1(*args):
    """
    BSplSLib__HomogeneousD1(Standard_Real const U, Standard_Real const V, Standard_Integer const UIndex, Standard_Integer const VIndex, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real UKnots, NCollection_Array1_Standard_Real VKnots, NCollection_Array1_Standard_Integer UMults, NCollection_Array1_Standard_Integer VMults, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Boolean const URat, Standard_Boolean const VRat, Standard_Boolean const UPer, Standard_Boolean const VPer, gp_Pnt N, gp_Vec Nu, gp_Vec Nv)

    Makes an homogeneous  evaluation of Poles and Weights
    any and returns in P the Numerator value and
    in W the Denominator value if Weights are present
    otherwise returns 1.0e0

    :type U: float
    :type V: float
    :type UIndex: int
    :type VIndex: int
    :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type UKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type VKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type UMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type VMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type UDegree: int
    :type VDegree: int
    :type URat: bool
    :type VRat: bool
    :type UPer: bool
    :type VPer: bool
    :type N: OCC.wrapper.gp.gp_Pnt
    :type Nu: OCC.wrapper.gp.gp_Vec
    :type Nv: OCC.wrapper.gp.gp_Vec
    :type D: float
    :type Du: float
    :type Dv: float

    """
    return _BSplSLib.BSplSLib__HomogeneousD1(*args)

def BSplSLib__Reverse(*args):
    """
    Reverse(NCollection_Array2_gp_Pnt Poles, Standard_Integer const Last, Standard_Boolean const UDirection)
    BSplSLib__Reverse(NCollection_Array2_Standard_Real Weights, Standard_Integer const Last, Standard_Boolean const UDirection)

    Reverses the array of weights.

    :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type Last: int
    :type UDirection: bool

    """
    return _BSplSLib.BSplSLib__Reverse(*args)

def BSplSLib__IsRational(*args):
    """
    BSplSLib__IsRational(NCollection_Array2_Standard_Real Weights, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const J1, Standard_Integer const J2, Standard_Real const Epsilon=0.0) -> Standard_Boolean

    Returns False if all the weights  of the  array <Weights>
    in the area [I1,I2] * [J1,J2] are  identic.
    Epsilon  is used for comparing  weights.
    If Epsilon  is 0. the  Epsilon of the first weight is used.

    :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type I1: int
    :type I2: int
    :type J1: int
    :type J2: int
    :type Epsilon: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BSplSLib.BSplSLib__IsRational(*args)

def BSplSLib__SetPoles(*args):
    """
    SetPoles(NCollection_Array2_gp_Pnt Poles, NCollection_Array1_Standard_Real FP, Standard_Boolean const UDirection)
    BSplSLib__SetPoles(NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real FP, Standard_Boolean const UDirection)

    Copy in FP the coordinates of the poles.

    :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type FP: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type UDirection: bool

    """
    return _BSplSLib.BSplSLib__SetPoles(*args)

def BSplSLib__GetPoles(*args):
    """
    GetPoles(NCollection_Array1_Standard_Real FP, NCollection_Array2_gp_Pnt Poles, Standard_Boolean const UDirection)
    BSplSLib__GetPoles(NCollection_Array1_Standard_Real FP, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, Standard_Boolean const UDirection)

    Get from FP the coordinates of the poles.

    :type FP: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type UDirection: bool

    """
    return _BSplSLib.BSplSLib__GetPoles(*args)

def BSplSLib__MovePoint(*args):
    """
    BSplSLib__MovePoint(Standard_Real const U, Standard_Real const V, gp_Vec Displ, Standard_Integer const UIndex1, Standard_Integer const UIndex2, Standard_Integer const VIndex1, Standard_Integer const VIndex2, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Boolean const Rational, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real UFlatKnots, NCollection_Array1_Standard_Real VFlatKnots, NCollection_Array2_gp_Pnt NewPoles)

    Find the new poles which allows an old point (with a
    given u,v  as parameters)  to  reach a  new position
    UIndex1,UIndex2 indicate the  range of poles we can
    move for U
    (1, UNbPoles-1) or (2, UNbPoles) -> no constraint
    for one side in U
    (2, UNbPoles-1)   -> the ends are enforced for U
    don't enter (1,NbPoles) and (1,VNbPoles)
    -> error: rigid move
    if problem in BSplineBasis calculation, no change
    for the curve  and
    UFirstIndex, VLastIndex = 0
    VFirstIndex, VLastIndex = 0

    :type U: float
    :type V: float
    :type Displ: OCC.wrapper.gp.gp_Vec
    :type UIndex1: int
    :type UIndex2: int
    :type VIndex1: int
    :type VIndex2: int
    :type UDegree: int
    :type VDegree: int
    :type Rational: bool
    :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type UFlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type VFlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type UFirstIndex: int
    :type ULastIndex: int
    :type VFirstIndex: int
    :type VLastIndex: int
    :type NewPoles: OCC.wrapper.TColgp.TColgp_Array2OfPnt

    """
    return _BSplSLib.BSplSLib__MovePoint(*args)

def BSplSLib__InsertKnots(*args):
    """
    BSplSLib__InsertKnots(Standard_Boolean const UDirection, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_Standard_Real AddKnots, NCollection_Array1_Standard_Integer AddMults, NCollection_Array2_gp_Pnt NewPoles, NCollection_Array2_Standard_Real NewWeights, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults, Standard_Real const Epsilon, Standard_Boolean const Add)

    :type UDirection: bool
    :type Degree: int
    :type Periodic: bool
    :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type AddKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type AddMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type NewPoles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type NewWeights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type NewKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type NewMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type Epsilon: float
    :type Add: bool

    """
    return _BSplSLib.BSplSLib__InsertKnots(*args)

def BSplSLib__RemoveKnot(*args):
    """
    BSplSLib__RemoveKnot(Standard_Boolean const UDirection, Standard_Integer const Index, Standard_Integer const Mult, Standard_Integer const Degree, Standard_Boolean const Periodic, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array2_gp_Pnt NewPoles, NCollection_Array2_Standard_Real NewWeights, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults, Standard_Real const Tolerance) -> Standard_Boolean

    :type UDirection: bool
    :type Index: int
    :type Mult: int
    :type Degree: int
    :type Periodic: bool
    :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type NewPoles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type NewWeights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type NewKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type NewMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type Tolerance: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BSplSLib.BSplSLib__RemoveKnot(*args)

def BSplSLib__IncreaseDegree(*args):
    """
    BSplSLib__IncreaseDegree(Standard_Boolean const UDirection, Standard_Integer const Degree, Standard_Integer const NewDegree, Standard_Boolean const Periodic, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, NCollection_Array2_gp_Pnt NewPoles, NCollection_Array2_Standard_Real NewWeights, NCollection_Array1_Standard_Real NewKnots, NCollection_Array1_Standard_Integer NewMults)

    :type UDirection: bool
    :type Degree: int
    :type NewDegree: int
    :type Periodic: bool
    :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type NewPoles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type NewWeights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type NewKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type NewMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

    """
    return _BSplSLib.BSplSLib__IncreaseDegree(*args)

def BSplSLib__Unperiodize(*args):
    """
    BSplSLib__Unperiodize(Standard_Boolean const UDirection, Standard_Integer const Degree, NCollection_Array1_Standard_Integer Mults, NCollection_Array1_Standard_Real Knots, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Integer NewMults, NCollection_Array1_Standard_Real NewKnots, NCollection_Array2_gp_Pnt NewPoles, NCollection_Array2_Standard_Real NewWeights)

    :type UDirection: bool
    :type Degree: int
    :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type NewMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type NewKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type NewPoles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type NewWeights: OCC.wrapper.TColStd.TColStd_Array2OfReal

    """
    return _BSplSLib.BSplSLib__Unperiodize(*args)

def BSplSLib__NoWeights(*args):
    """
    BSplSLib__NoWeights() -> NCollection_Array2_Standard_Real

    Used as argument for a non rational curve.

    :rtype: OCC.wrapper.TColStd.TColStd_Array2OfReal

    """
    return _BSplSLib.BSplSLib__NoWeights(*args)

def BSplSLib__BuildCache(*args):
    """
    BuildCache(Standard_Real const U, Standard_Real const V, Standard_Real const USpanDomain, Standard_Real const VSpanDomain, Standard_Boolean const UPeriodicFlag, Standard_Boolean const VPeriodicFlag, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Integer const UIndex, Standard_Integer const VIndex, NCollection_Array1_Standard_Real UFlatKnots, NCollection_Array1_Standard_Real VFlatKnots, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array2_gp_Pnt CachePoles, NCollection_Array2_Standard_Real CacheWeights)
    BSplSLib__BuildCache(Standard_Real const theU, Standard_Real const theV, Standard_Real const theUSpanDomain, Standard_Real const theVSpanDomain, Standard_Boolean const theUPeriodic, Standard_Boolean const theVPeriodic, Standard_Integer const theUDegree, Standard_Integer const theVDegree, Standard_Integer const theUIndex, Standard_Integer const theVIndex, NCollection_Array1_Standard_Real theUFlatKnots, NCollection_Array1_Standard_Real theVFlatKnots, NCollection_Array2_gp_Pnt thePoles, NCollection_Array2_Standard_Real theWeights, NCollection_Array2_Standard_Real theCacheArray)

    Perform the evaluation of the Taylor expansion
    of the Bspline normalized between 0 and 1.
    Structure of result optimized for BSplSLib_Cache.

    :type theU: float
    :type theV: float
    :type theUSpanDomain: float
    :type theVSpanDomain: float
    :type theUPeriodic: bool
    :type theVPeriodic: bool
    :type theUDegree: int
    :type theVDegree: int
    :type theUIndex: int
    :type theVIndex: int
    :type theUFlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type theVFlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type thePoles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type theWeights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type theCacheArray: OCC.wrapper.TColStd.TColStd_Array2OfReal

    """
    return _BSplSLib.BSplSLib__BuildCache(*args)

def BSplSLib__CacheD0(*args):
    """
    BSplSLib__CacheD0(Standard_Real const U, Standard_Real const V, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Real const UCacheParameter, Standard_Real const VCacheParameter, Standard_Real const USpanLenght, Standard_Real const VSpanLength, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, gp_Pnt Point)

    Perform the evaluation of the of the cache
    the parameter must be normalized between
    the 0 and 1 for the span.
    The Cache must be valid when calling this
    routine. Geom Package will insure that.
    and then multiplies by the weights
    this just evaluates the current point
    the CacheParameter is where the Cache was
    constructed the SpanLength is to normalize
    the polynomial in the cache to avoid bad conditioning
    effects

    :type U: float
    :type V: float
    :type UDegree: int
    :type VDegree: int
    :type UCacheParameter: float
    :type VCacheParameter: float
    :type USpanLenght: float
    :type VSpanLength: float
    :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type Point: OCC.wrapper.gp.gp_Pnt

    """
    return _BSplSLib.BSplSLib__CacheD0(*args)

def BSplSLib__CoefsD0(*args):
    """
    BSplSLib__CoefsD0(Standard_Real const U, Standard_Real const V, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, gp_Pnt Point)

    Calls CacheD0 for Bezier Surfaces Arrays computed with
    the method PolesCoefficients.
    Warning: To be used for BezierSurfaces ONLY!!!

    :type U: float
    :type V: float
    :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type Point: OCC.wrapper.gp.gp_Pnt

    """
    return _BSplSLib.BSplSLib__CoefsD0(*args)

def BSplSLib__CacheD1(*args):
    """
    BSplSLib__CacheD1(Standard_Real const U, Standard_Real const V, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Real const UCacheParameter, Standard_Real const VCacheParameter, Standard_Real const USpanLenght, Standard_Real const VSpanLength, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, gp_Pnt Point, gp_Vec VecU, gp_Vec VecV)

    Perform the evaluation of the of the cache
    the parameter must be normalized between
    the 0 and 1 for the span.
    The Cache must be valid when calling this
    routine. Geom Package will insure that.
    and then multiplies by the weights
    this just evaluates the current point
    the CacheParameter is where the Cache was
    constructed the SpanLength is to normalize
    the polynomial in the cache to avoid bad conditioning
    effects

    :type U: float
    :type V: float
    :type UDegree: int
    :type VDegree: int
    :type UCacheParameter: float
    :type VCacheParameter: float
    :type USpanLenght: float
    :type VSpanLength: float
    :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type Point: OCC.wrapper.gp.gp_Pnt
    :type VecU: OCC.wrapper.gp.gp_Vec
    :type VecV: OCC.wrapper.gp.gp_Vec

    """
    return _BSplSLib.BSplSLib__CacheD1(*args)

def BSplSLib__CoefsD1(*args):
    """
    BSplSLib__CoefsD1(Standard_Real const U, Standard_Real const V, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, gp_Pnt Point, gp_Vec VecU, gp_Vec VecV)

    Calls CacheD0 for Bezier Surfaces Arrays computed with
    the method PolesCoefficients.
    Warning: To be used for BezierSurfaces ONLY!!!

    :type U: float
    :type V: float
    :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type Point: OCC.wrapper.gp.gp_Pnt
    :type VecU: OCC.wrapper.gp.gp_Vec
    :type VecV: OCC.wrapper.gp.gp_Vec

    """
    return _BSplSLib.BSplSLib__CoefsD1(*args)

def BSplSLib__CacheD2(*args):
    """
    BSplSLib__CacheD2(Standard_Real const U, Standard_Real const V, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Real const UCacheParameter, Standard_Real const VCacheParameter, Standard_Real const USpanLenght, Standard_Real const VSpanLength, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, gp_Pnt Point, gp_Vec VecU, gp_Vec VecV, gp_Vec VecUU, gp_Vec VecUV, gp_Vec VecVV)

    Perform the evaluation of the of the cache
    the parameter must be normalized between
    the 0 and 1 for the span.
    The Cache must be valid when calling this
    routine. Geom Package will insure that.
    and then multiplies by the weights
    this just evaluates the current point
    the CacheParameter is where the Cache was
    constructed the SpanLength is to normalize
    the polynomial in the cache to avoid bad conditioning
    effects

    :type U: float
    :type V: float
    :type UDegree: int
    :type VDegree: int
    :type UCacheParameter: float
    :type VCacheParameter: float
    :type USpanLenght: float
    :type VSpanLength: float
    :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type Point: OCC.wrapper.gp.gp_Pnt
    :type VecU: OCC.wrapper.gp.gp_Vec
    :type VecV: OCC.wrapper.gp.gp_Vec
    :type VecUU: OCC.wrapper.gp.gp_Vec
    :type VecUV: OCC.wrapper.gp.gp_Vec
    :type VecVV: OCC.wrapper.gp.gp_Vec

    """
    return _BSplSLib.BSplSLib__CacheD2(*args)

def BSplSLib__CoefsD2(*args):
    """
    BSplSLib__CoefsD2(Standard_Real const U, Standard_Real const V, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, gp_Pnt Point, gp_Vec VecU, gp_Vec VecV, gp_Vec VecUU, gp_Vec VecUV, gp_Vec VecVV)

    Calls CacheD0 for Bezier Surfaces Arrays computed with
    the method PolesCoefficients.
    Warning: To be used for BezierSurfaces ONLY!!!

    :type U: float
    :type V: float
    :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type Point: OCC.wrapper.gp.gp_Pnt
    :type VecU: OCC.wrapper.gp.gp_Vec
    :type VecV: OCC.wrapper.gp.gp_Vec
    :type VecUU: OCC.wrapper.gp.gp_Vec
    :type VecUV: OCC.wrapper.gp.gp_Vec
    :type VecVV: OCC.wrapper.gp.gp_Vec

    """
    return _BSplSLib.BSplSLib__CoefsD2(*args)

def BSplSLib__PolesCoefficients(*args):
    """
    PolesCoefficients(NCollection_Array2_gp_Pnt Poles, NCollection_Array2_gp_Pnt CachePoles)
    BSplSLib__PolesCoefficients(NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array2_gp_Pnt CachePoles, NCollection_Array2_Standard_Real CacheWeights)

    Encapsulation   of  BuildCache    to   perform   the
    evaluation  of the Taylor expansion for beziersurfaces
    at parameters 0.,0.;
    Warning: To be used for BezierSurfaces ONLY!!!

    :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type CachePoles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type CacheWeights: OCC.wrapper.TColStd.TColStd_Array2OfReal

    """
    return _BSplSLib.BSplSLib__PolesCoefficients(*args)

def BSplSLib__Resolution(*args):
    """
    BSplSLib__Resolution(NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real UKnots, NCollection_Array1_Standard_Real VKnots, NCollection_Array1_Standard_Integer UMults, NCollection_Array1_Standard_Integer VMults, Standard_Integer const UDegree, Standard_Integer const VDegree, Standard_Boolean const URat, Standard_Boolean const VRat, Standard_Boolean const UPer, Standard_Boolean const VPer, Standard_Real const Tolerance3D)

    Given a tolerance in 3D space returns two
    tolerances, one in U one in V such that for
    all (u1,v1) and (u0,v0) in the domain of
    the surface f(u,v)  we have :
    | u1 - u0 | < UTolerance and
    | v1 - v0 | < VTolerance
    we have |f (u1,v1) - f (u0,v0)| < Tolerance3D

    :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type UKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type VKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type UMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type VMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type UDegree: int
    :type VDegree: int
    :type URat: bool
    :type VRat: bool
    :type UPer: bool
    :type VPer: bool
    :type Tolerance3D: float
    :type UTolerance: float
    :type VTolerance: float

    """
    return _BSplSLib.BSplSLib__Resolution(*args)

def BSplSLib__Interpolate(*args):
    """
    Interpolate(Standard_Integer const UDegree, Standard_Integer const VDegree, NCollection_Array1_Standard_Real UFlatKnots, NCollection_Array1_Standard_Real VFlatKnots, NCollection_Array1_Standard_Real UParameters, NCollection_Array1_Standard_Real VParameters, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights)
    BSplSLib__Interpolate(Standard_Integer const UDegree, Standard_Integer const VDegree, NCollection_Array1_Standard_Real UFlatKnots, NCollection_Array1_Standard_Real VFlatKnots, NCollection_Array1_Standard_Real UParameters, NCollection_Array1_Standard_Real VParameters, NCollection_Array2_gp_Pnt Poles)

    Performs the interpolation of the data points given in
    the  Poles array.
    The  ColLength CL and the Length of UParameters must be
    the  same. The length of VFlatKnots is VDegree + CL + 1.

    The  RowLength RL and the Length of VParameters must be
    the  same. The length of VFlatKnots is Degree + RL + 1.

    Warning: the method used  to do that  interpolation
    is gauss  elimination  WITHOUT pivoting.  Thus if  the
    diagonal is not  dominant  there is no guarantee  that
    the   algorithm will    work.  Nevertheless  for Cubic
    interpolation  at knots or interpolation at Scheonberg
    points  the method   will work.  The  InversionProblem
    will  report 0 if there   was no problem  else it will
    give the index of the faulty pivot

    :type UDegree: int
    :type VDegree: int
    :type UFlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type VFlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type UParameters: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type VParameters: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type InversionProblem: int

    """
    return _BSplSLib.BSplSLib__Interpolate(*args)

def BSplSLib__FunctionMultiply(*args):
    """
    BSplSLib__FunctionMultiply(BSplSLib_EvaluatorFunction Function, Standard_Integer const UBSplineDegree, Standard_Integer const VBSplineDegree, NCollection_Array1_Standard_Real UBSplineKnots, NCollection_Array1_Standard_Real VBSplineKnots, NCollection_Array1_Standard_Integer UMults, NCollection_Array1_Standard_Integer VMults, NCollection_Array2_gp_Pnt Poles, NCollection_Array2_Standard_Real Weights, NCollection_Array1_Standard_Real UFlatKnots, NCollection_Array1_Standard_Real VFlatKnots, Standard_Integer const UNewDegree, Standard_Integer const VNewDegree, NCollection_Array2_gp_Pnt NewNumerator, NCollection_Array2_Standard_Real NewDenominator)

    this will multiply  a given BSpline numerator  N(u,v)
    and    denominator    D(u,v)  defined     by   its
    U/VBSplineDegree   and    U/VBSplineKnots,     and
    U/VMults. Its Poles  and Weights are arrays which are
    coded   as      array2      of      the    form
    [1..UNumPoles][1..VNumPoles]  by  a function a(u,v)
    which  is assumed  to satisfy    the following :  1.
    a(u,v)  * N(u,v) and a(u,v) *  D(u,v)  is a polynomial
    BSpline that can be expressed exactly as a BSpline of
    degree U/VNewDegree  on  the knots U/VFlatKnots 2. the range
    of a(u,v) is   the   same as  the range   of  N(u,v)
    or D(u,v)
    ---Warning:  it is   the caller's  responsability  to
    insure that conditions 1. and  2. above are satisfied
    : no  check  whatsoever is made   in  this method  --
    theStatus will  return 0 if  OK else it will return  the
    pivot index -- of the   matrix that was inverted to
    compute the multiplied -- BSpline  : the method used
    is  interpolation   at Schoenenberg   --  points  of
    a(u,v)* N(u,v) and a(u,v) * D(u,v)
    theStatus will return 0 if OK else it will return the pivot index
    of the matrix that was inverted to compute the multiplied
    BSpline : the method used is interpolation at Schoenenberg
    points of a(u,v)*F(u,v)
    --

    :type Function: OCC.wrapper.BSplSLib.BSplSLib_EvaluatorFunction
    :type UBSplineDegree: int
    :type VBSplineDegree: int
    :type UBSplineKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type VBSplineKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type UMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type VMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
    :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type UFlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type VFlatKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type UNewDegree: int
    :type VNewDegree: int
    :type NewNumerator: OCC.wrapper.TColgp.TColgp_Array2OfPnt
    :type NewDenominator: OCC.wrapper.TColStd.TColStd_Array2OfReal
    :type theStatus: int

    """
    return _BSplSLib.BSplSLib__FunctionMultiply(*args)

class BSplSLib_Cache(Standard.Standard_Transient):
    """
    rief A cache class for Bezier and B-spline surfaces.

    Defines all data, that can be cached on a span of the surface.
    The data should be recalculated in going from span to span.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BSplSLib_Cache
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BSplSLib_Cache(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BSplSLib_Cache self) -> BSplSLib_Cache
        __init__(BSplSLib_Cache self, Standard_Integer const & theDegreeU, Standard_Boolean const & thePeriodicU, NCollection_Array1_Standard_Real theFlatKnotsU, Standard_Integer const & theDegreeV, Standard_Boolean const & thePeriodicV, NCollection_Array1_Standard_Real theFlatKnotsV, NCollection_Array2_gp_Pnt thePoles, NCollection_Array2_Standard_Real theWeights=None) -> BSplSLib_Cache

        Constructor for caching of the span for the surface
        \param theDegreeU    degree along the first parameter (U) of the surface
        \param thePeriodicU  identify the surface is periodical along U axis
        \param theFlatKnotsU knots of the surface (with repetition) along U axis
        \param theDegreeV    degree alogn the second parameter (V) of the surface
        \param thePeriodicV  identify the surface is periodical along V axis
        \param theFlatKnotsV knots of the surface (with repetition) along V axis
        \param thePoles      array of poles of the surface
        \param theWeights    array of weights of corresponding poles

        :type theDegreeU: int
        :type thePeriodicU: bool
        :type theFlatKnotsU: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type theDegreeV: int
        :type thePeriodicV: bool
        :type theFlatKnotsV: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type thePoles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type theWeights: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        this = _BSplSLib.new_BSplSLib_Cache(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsCacheValid(self, *args):
        """
        IsCacheValid(BSplSLib_Cache self, Standard_Real theParameterU, Standard_Real theParameterV) -> Standard_Boolean

        Verifies validity of the cache using parameters of the point
        \param theParameterU  first parameter of the point placed in the span
        \param theParameterV  second parameter of the point placed in the span

        :type theParameterU: float
        :type theParameterV: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BSplSLib.BSplSLib_Cache_IsCacheValid(self, *args)


    def BuildCache(self, *args):
        """
        BuildCache(BSplSLib_Cache self, Standard_Real const & theParameterU, Standard_Real const & theParameterV, Standard_Integer const & theDegreeU, Standard_Boolean const & thePeriodicU, NCollection_Array1_Standard_Real theFlatKnotsU, Standard_Integer const & theDegreeV, Standard_Boolean const & thePeriodicV, NCollection_Array1_Standard_Real theFlatKnotsV, NCollection_Array2_gp_Pnt thePoles, NCollection_Array2_Standard_Real theWeights=None)

        Recomputes the cache data. Does not verify validity of the cache
        \param theParameterU  the parametric value on the U axis to identify the span
        \param theParameterV  the parametric value on the V axis to identify the span
        \param theDegreeU     degree along U axis
        \param thePeriodicU   identify whether the surface is periodic along U axis
        \param theFlatKnotsU  flat knots of the surface along U axis
        \param theDegreeV     degree along V axis
        \param thePeriodicV   identify whether the surface is periodic along V axis
        \param theFlatKnotsV  flat knots of the surface along V axis
        \param thePoles       array of poles of the surface
        \param theWeights     array of weights of corresponding poles

        :type theParameterU: float
        :type theParameterV: float
        :type theDegreeU: int
        :type thePeriodicU: bool
        :type theFlatKnotsU: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type theDegreeV: int
        :type thePeriodicV: bool
        :type theFlatKnotsV: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type thePoles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type theWeights: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        return _BSplSLib.BSplSLib_Cache_BuildCache(self, *args)


    def D0(self, *args):
        """
        D0(BSplSLib_Cache self, Standard_Real const & theU, Standard_Real const & theV, gp_Pnt thePoint)

        Calculates the point on the surface for specified parameters
        \param[in]  theU      first parameter for calculation of the value
        \param[in]  theV      second parameter for calculation of the value
        \param[out] thePoint  the result of calculation (the point on the surface)

        :type theU: float
        :type theV: float
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _BSplSLib.BSplSLib_Cache_D0(self, *args)


    def D1(self, *args):
        """
        D1(BSplSLib_Cache self, Standard_Real const & theU, Standard_Real const & theV, gp_Pnt thePoint, gp_Vec theTangentU, gp_Vec theTangentV)

        Calculates the point on the surface and its first derivative
        \param[in]  theU         first parameter of calculation of the value
        \param[in]  theV         second parameter of calculation of the value
        \param[out] thePoint     the result of calculation (the point on the surface)
        \param[out] theTangentU  tangent vector along U axis in the calculated point
        \param[out] theTangentV  tangent vector along V axis in the calculated point

        :type theU: float
        :type theV: float
        :type thePoint: OCC.wrapper.gp.gp_Pnt
        :type theTangentU: OCC.wrapper.gp.gp_Vec
        :type theTangentV: OCC.wrapper.gp.gp_Vec

        """
        return _BSplSLib.BSplSLib_Cache_D1(self, *args)


    def D2(self, *args):
        """
        D2(BSplSLib_Cache self, Standard_Real const & theU, Standard_Real const & theV, gp_Pnt thePoint, gp_Vec theTangentU, gp_Vec theTangentV, gp_Vec theCurvatureU, gp_Vec theCurvatureV, gp_Vec theCurvatureUV)

        Calculates the point on the surface and derivatives till second order
        \param[in]  theU            first parameter of calculation of the value
        \param[in]  theV            second parameter of calculation of the value
        \param[out] thePoint        the result of calculation (the point on the surface)
        \param[out] theTangentU     tangent vector along U axis in the calculated point
        \param[out] theTangentV     tangent vector along V axis in the calculated point
        \param[out] theCurvatureU   curvature vector (2nd derivative on U) along U axis
        \param[out] theCurvatureV   curvature vector (2nd derivative on V) along V axis
        \param[out] theCurvatureUV  2nd mixed derivative on U anv V

        :type theU: float
        :type theV: float
        :type thePoint: OCC.wrapper.gp.gp_Pnt
        :type theTangentU: OCC.wrapper.gp.gp_Vec
        :type theTangentV: OCC.wrapper.gp.gp_Vec
        :type theCurvatureU: OCC.wrapper.gp.gp_Vec
        :type theCurvatureV: OCC.wrapper.gp.gp_Vec
        :type theCurvatureUV: OCC.wrapper.gp.gp_Vec

        """
        return _BSplSLib.BSplSLib_Cache_D2(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BSplSLib.BSplSLib_Cache_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BSplSLib.BSplSLib_Cache_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BSplSLib.BSplSLib_Cache_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BSplSLib.delete_BSplSLib_Cache
BSplSLib_Cache_swigregister = _BSplSLib.BSplSLib_Cache_swigregister
BSplSLib_Cache_swigregister(BSplSLib_Cache)

def BSplSLib_Cache_get_type_name(*args):
    """
    BSplSLib_Cache_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BSplSLib.BSplSLib_Cache_get_type_name(*args)

def BSplSLib_Cache_get_type_descriptor(*args):
    """
    BSplSLib_Cache_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BSplSLib.BSplSLib_Cache_get_type_descriptor(*args)

class Handle_BSplSLib_Cache(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BSplSLib_Cache self)

        Nullify the handle


        """
        return _BSplSLib.Handle_BSplSLib_Cache_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BSplSLib_Cache self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BSplSLib.Handle_BSplSLib_Cache_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BSplSLib_Cache self, BSplSLib_Cache thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BSplSLib.Handle_BSplSLib_Cache_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BSplSLib_Cache self, Handle_BSplSLib_Cache theHandle) -> Handle_BSplSLib_Cache
        assign(Handle_BSplSLib_Cache self, BSplSLib_Cache thePtr) -> Handle_BSplSLib_Cache
        assign(Handle_BSplSLib_Cache self, Handle_BSplSLib_Cache theHandle) -> Handle_BSplSLib_Cache

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BSplSLib.Handle_BSplSLib_Cache_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BSplSLib_Cache self) -> BSplSLib_Cache

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BSplSLib.Handle_BSplSLib_Cache_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BSplSLib_Cache self) -> BSplSLib_Cache

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BSplSLib.Handle_BSplSLib_Cache___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BSplSLib_Cache self) -> BSplSLib_Cache

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BSplSLib.Handle_BSplSLib_Cache___ref__(self, *args)


    def __hash__(self):
        return _BSplSLib.Handle_BSplSLib_Cache___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BSplSLib.Handle_BSplSLib_Cache___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BSplSLib.new_Handle_BSplSLib_Cache(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BSplSLib.Handle_BSplSLib_Cache_DownCast)
    __swig_destroy__ = _BSplSLib.delete_Handle_BSplSLib_Cache

    def IsCacheValid(self, *args):
        """
        IsCacheValid(Handle_BSplSLib_Cache self, Standard_Real theParameterU, Standard_Real theParameterV) -> Standard_Boolean

        Verifies validity of the cache using parameters of the point
        \param theParameterU  first parameter of the point placed in the span
        \param theParameterV  second parameter of the point placed in the span

        :type theParameterU: float
        :type theParameterV: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BSplSLib.Handle_BSplSLib_Cache_IsCacheValid(self, *args)


    def BuildCache(self, *args):
        """
        BuildCache(Handle_BSplSLib_Cache self, Standard_Real const & theParameterU, Standard_Real const & theParameterV, Standard_Integer const & theDegreeU, Standard_Boolean const & thePeriodicU, NCollection_Array1_Standard_Real theFlatKnotsU, Standard_Integer const & theDegreeV, Standard_Boolean const & thePeriodicV, NCollection_Array1_Standard_Real theFlatKnotsV, NCollection_Array2_gp_Pnt thePoles, NCollection_Array2_Standard_Real theWeights=None)

        Recomputes the cache data. Does not verify validity of the cache
        \param theParameterU  the parametric value on the U axis to identify the span
        \param theParameterV  the parametric value on the V axis to identify the span
        \param theDegreeU     degree along U axis
        \param thePeriodicU   identify whether the surface is periodic along U axis
        \param theFlatKnotsU  flat knots of the surface along U axis
        \param theDegreeV     degree along V axis
        \param thePeriodicV   identify whether the surface is periodic along V axis
        \param theFlatKnotsV  flat knots of the surface along V axis
        \param thePoles       array of poles of the surface
        \param theWeights     array of weights of corresponding poles

        :type theParameterU: float
        :type theParameterV: float
        :type theDegreeU: int
        :type thePeriodicU: bool
        :type theFlatKnotsU: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type theDegreeV: int
        :type thePeriodicV: bool
        :type theFlatKnotsV: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type thePoles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type theWeights: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        return _BSplSLib.Handle_BSplSLib_Cache_BuildCache(self, *args)


    def D0(self, *args):
        """
        D0(Handle_BSplSLib_Cache self, Standard_Real const & theU, Standard_Real const & theV, gp_Pnt thePoint)

        Calculates the point on the surface for specified parameters
        \param[in]  theU      first parameter for calculation of the value
        \param[in]  theV      second parameter for calculation of the value
        \param[out] thePoint  the result of calculation (the point on the surface)

        :type theU: float
        :type theV: float
        :type thePoint: OCC.wrapper.gp.gp_Pnt

        """
        return _BSplSLib.Handle_BSplSLib_Cache_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_BSplSLib_Cache self, Standard_Real const & theU, Standard_Real const & theV, gp_Pnt thePoint, gp_Vec theTangentU, gp_Vec theTangentV)

        Calculates the point on the surface and its first derivative
        \param[in]  theU         first parameter of calculation of the value
        \param[in]  theV         second parameter of calculation of the value
        \param[out] thePoint     the result of calculation (the point on the surface)
        \param[out] theTangentU  tangent vector along U axis in the calculated point
        \param[out] theTangentV  tangent vector along V axis in the calculated point

        :type theU: float
        :type theV: float
        :type thePoint: OCC.wrapper.gp.gp_Pnt
        :type theTangentU: OCC.wrapper.gp.gp_Vec
        :type theTangentV: OCC.wrapper.gp.gp_Vec

        """
        return _BSplSLib.Handle_BSplSLib_Cache_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_BSplSLib_Cache self, Standard_Real const & theU, Standard_Real const & theV, gp_Pnt thePoint, gp_Vec theTangentU, gp_Vec theTangentV, gp_Vec theCurvatureU, gp_Vec theCurvatureV, gp_Vec theCurvatureUV)

        Calculates the point on the surface and derivatives till second order
        \param[in]  theU            first parameter of calculation of the value
        \param[in]  theV            second parameter of calculation of the value
        \param[out] thePoint        the result of calculation (the point on the surface)
        \param[out] theTangentU     tangent vector along U axis in the calculated point
        \param[out] theTangentV     tangent vector along V axis in the calculated point
        \param[out] theCurvatureU   curvature vector (2nd derivative on U) along U axis
        \param[out] theCurvatureV   curvature vector (2nd derivative on V) along V axis
        \param[out] theCurvatureUV  2nd mixed derivative on U anv V

        :type theU: float
        :type theV: float
        :type thePoint: OCC.wrapper.gp.gp_Pnt
        :type theTangentU: OCC.wrapper.gp.gp_Vec
        :type theTangentV: OCC.wrapper.gp.gp_Vec
        :type theCurvatureU: OCC.wrapper.gp.gp_Vec
        :type theCurvatureV: OCC.wrapper.gp.gp_Vec
        :type theCurvatureUV: OCC.wrapper.gp.gp_Vec

        """
        return _BSplSLib.Handle_BSplSLib_Cache_D2(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BSplSLib_Cache self) -> char const *

        :rtype: const char *

        """
        return _BSplSLib.Handle_BSplSLib_Cache_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BSplSLib.Handle_BSplSLib_Cache_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BSplSLib.Handle_BSplSLib_Cache_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BSplSLib_Cache self)

        Memory deallocator for transient classes


        """
        return _BSplSLib.Handle_BSplSLib_Cache_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BSplSLib_Cache self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BSplSLib_Cache self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BSplSLib.Handle_BSplSLib_Cache_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BSplSLib_Cache self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BSplSLib_Cache self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BSplSLib.Handle_BSplSLib_Cache_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BSplSLib_Cache self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BSplSLib.Handle_BSplSLib_Cache_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BSplSLib_Cache self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BSplSLib.Handle_BSplSLib_Cache_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BSplSLib_Cache self)

        Increments the reference counter of this object


        """
        return _BSplSLib.Handle_BSplSLib_Cache_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BSplSLib_Cache self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BSplSLib.Handle_BSplSLib_Cache_DecrementRefCounter(self, *args)

Handle_BSplSLib_Cache_swigregister = _BSplSLib.Handle_BSplSLib_Cache_swigregister
Handle_BSplSLib_Cache_swigregister(Handle_BSplSLib_Cache)

def Handle_BSplSLib_Cache_DownCast(thing):
    return _BSplSLib.Handle_BSplSLib_Cache_DownCast(thing)
Handle_BSplSLib_Cache_DownCast = _BSplSLib.Handle_BSplSLib_Cache_DownCast

class BSplSLib_EvaluatorFunction(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Evaluate(self, *args):
        """
        Evaluate(BSplSLib_EvaluatorFunction self, Standard_Integer const theDerivativeRequest, Standard_Real const theUParameter, Standard_Real const theVParameter)

        Function evaluation method to be defined by descendant

        :type theDerivativeRequest: int
        :type theUParameter: float
        :type theVParameter: float
        :type theResult: float
        :type theErrorCode: int

        """
        return _BSplSLib.BSplSLib_EvaluatorFunction_Evaluate(self, *args)


    def __call__(self, *args):
        """
        __call__(BSplSLib_EvaluatorFunction self, Standard_Integer const theDerivativeRequest, Standard_Real const theUParameter, Standard_Real const theVParameter)

        Shortcut for function-call style usage

        :type theDerivativeRequest: int
        :type theUParameter: float
        :type theVParameter: float
        :type theResult: float
        :type theErrorCode: int

        """
        return _BSplSLib.BSplSLib_EvaluatorFunction___call__(self, *args)

    __swig_destroy__ = _BSplSLib.delete_BSplSLib_EvaluatorFunction
BSplSLib_EvaluatorFunction_swigregister = _BSplSLib.BSplSLib_EvaluatorFunction_swigregister
BSplSLib_EvaluatorFunction_swigregister(BSplSLib_EvaluatorFunction)




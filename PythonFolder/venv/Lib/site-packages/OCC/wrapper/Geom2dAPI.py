# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Geom2dAPI')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Geom2dAPI')
    _Geom2dAPI = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Geom2dAPI', [dirname(__file__)])
        except ImportError:
            import _Geom2dAPI
            return _Geom2dAPI
        try:
            _mod = imp.load_module('_Geom2dAPI', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Geom2dAPI = swig_import_helper()
    del swig_import_helper
else:
    import _Geom2dAPI
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Geom2dAPI.delete_SwigPyIterator

    def value(self):
        return _Geom2dAPI.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Geom2dAPI.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Geom2dAPI.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Geom2dAPI.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Geom2dAPI.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Geom2dAPI.SwigPyIterator_copy(self)

    def next(self):
        return _Geom2dAPI.SwigPyIterator_next(self)

    def __next__(self):
        return _Geom2dAPI.SwigPyIterator___next__(self)

    def previous(self):
        return _Geom2dAPI.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Geom2dAPI.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Geom2dAPI.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Geom2dAPI.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Geom2dAPI.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Geom2dAPI.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Geom2dAPI.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Geom2dAPI.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Geom2dAPI.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Geom2dAPI.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Geom2dAPI.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Geom2dAPI.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Geom2dAPI.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Geom2dAPI.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Geom2dAPI.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Geom2dAPI.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Geom2dAPI.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Geom2dAPI.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Geom2dAPI.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Geom2dAPI.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Geom2dAPI.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Geom2dAPI.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Geom2dAPI.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Geom2dAPI.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Geom2dAPI.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Geom2dAPI.ptr_to_number(item)
ptr_to_number = _Geom2dAPI.ptr_to_number

def HashCode(*args):
    return _Geom2dAPI.HashCode(*args)
HashCode = _Geom2dAPI.HashCode

def ptr_equal(a, b):
    return _Geom2dAPI.ptr_equal(a, b)
ptr_equal = _Geom2dAPI.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Approx
else:
    import Approx
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppCont
else:
    import AppCont
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppParCurves
else:
    import AppParCurves
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AdvApprox
else:
    import AdvApprox
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PLib
else:
    import PLib
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dInt
else:
    import Geom2dInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Intf
else:
    import Intf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurve
else:
    import IntCurve
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntRes2d
else:
    import IntRes2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Extrema
else:
    import Extrema
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
class Geom2dAPI_PointsToBSpline(object):
    """
    This  class  is  used  to  approximate a  BsplineCurve
    passing  through an  array  of points,  with  a  given
    Continuity.
    Describes functions for building a 2D BSpline
    curve which approximates a set of points.
    A PointsToBSpline object provides a framework for:
    -   defining the data of the BSpline curve to be built,
    -   implementing the approximation algorithm, and
    -   consulting the results
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dAPI_PointsToBSpline self) -> Geom2dAPI_PointsToBSpline
        __init__(Geom2dAPI_PointsToBSpline self, NCollection_Array1_gp_Pnt2d Points, Standard_Integer const DegMin=3, Standard_Integer const DegMax=8, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Real const Tol2D=1.0e-6) -> Geom2dAPI_PointsToBSpline
        __init__(Geom2dAPI_PointsToBSpline self, NCollection_Array1_Standard_Real YValues, Standard_Real const X0, Standard_Real const DX, Standard_Integer const DegMin=3, Standard_Integer const DegMax=8, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Real const Tol2D=1.0e-6) -> Geom2dAPI_PointsToBSpline
        __init__(Geom2dAPI_PointsToBSpline self, NCollection_Array1_gp_Pnt2d Points, Approx_ParametrizationType const ParType, Standard_Integer const DegMin=3, Standard_Integer const DegMax=8, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Real const Tol2D=1.0e-3) -> Geom2dAPI_PointsToBSpline
        __init__(Geom2dAPI_PointsToBSpline self, NCollection_Array1_gp_Pnt2d Points, NCollection_Array1_Standard_Real Parameters, Standard_Integer const DegMin=3, Standard_Integer const DegMax=8, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Real const Tol2D=1.0e-3) -> Geom2dAPI_PointsToBSpline
        __init__(Geom2dAPI_PointsToBSpline self, NCollection_Array1_gp_Pnt2d Points, Standard_Real const Weight1, Standard_Real const Weight2, Standard_Real const Weight3, Standard_Integer const DegMax=8, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Real const Tol3D=1.0e-3) -> Geom2dAPI_PointsToBSpline

        Approximate a BSpline Curve  passing through an
        array of Point using variational smoothing algorithm,
        which tries to minimize additional criterium:
        Weight1*CurveLength + Weight2*Curvature + Weight3*Torsion

        :type Points: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weight1: float
        :type Weight2: float
        :type Weight3: float
        :type DegMax: int
        :type Continuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type Tol3D: float

        """
        this = _Geom2dAPI.new_Geom2dAPI_PointsToBSpline(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(Geom2dAPI_PointsToBSpline self, NCollection_Array1_gp_Pnt2d Points, Standard_Integer const DegMin=3, Standard_Integer const DegMax=8, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Real const Tol2D=1.0e-6)
        Init(Geom2dAPI_PointsToBSpline self, NCollection_Array1_Standard_Real YValues, Standard_Real const X0, Standard_Real const DX, Standard_Integer const DegMin=3, Standard_Integer const DegMax=8, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Real const Tol2D=1.0e-6)
        Init(Geom2dAPI_PointsToBSpline self, NCollection_Array1_gp_Pnt2d Points, Approx_ParametrizationType const ParType, Standard_Integer const DegMin=3, Standard_Integer const DegMax=8, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Real const Tol2D=1.0e-3)
        Init(Geom2dAPI_PointsToBSpline self, NCollection_Array1_gp_Pnt2d Points, NCollection_Array1_Standard_Real Parameters, Standard_Integer const DegMin=3, Standard_Integer const DegMax=8, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Real const Tol2D=1.0e-3)
        Init(Geom2dAPI_PointsToBSpline self, NCollection_Array1_gp_Pnt2d Points, Standard_Real const Weight1, Standard_Real const Weight2, Standard_Real const Weight3, Standard_Integer const DegMax=8, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Real const Tol2D=1.0e-3)

        Approximate a BSpline Curve  passing through an
        array of Point using variational smoothing algorithm,
        which tries to minimize additional criterium:
        Weight1*CurveLength + Weight2*Curvature + Weight3*Torsion

        :type Points: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weight1: float
        :type Weight2: float
        :type Weight3: float
        :type DegMax: int
        :type Continuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type Tol2D: float

        """
        return _Geom2dAPI.Geom2dAPI_PointsToBSpline_Init(self, *args)


    def Curve(self, *args):
        """
        Returns the approximate BSpline Curve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        res = _Geom2dAPI.Geom2dAPI_PointsToBSpline_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDone(self, *args):
        """
        IsDone(Geom2dAPI_PointsToBSpline self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dAPI.Geom2dAPI_PointsToBSpline_IsDone(self, *args)

    __swig_destroy__ = _Geom2dAPI.delete_Geom2dAPI_PointsToBSpline
Geom2dAPI_PointsToBSpline_swigregister = _Geom2dAPI.Geom2dAPI_PointsToBSpline_swigregister
Geom2dAPI_PointsToBSpline_swigregister(Geom2dAPI_PointsToBSpline)

class Geom2dAPI_Interpolate(object):
    """
    This  class  is  used  to  interpolate a  BsplineCurve
    passing   through  an  array  of  points,  with  a  C2
    Continuity if tangency is not requested at the point.
    If tangency is requested at the point the continuity will
    be C1.  If Perodicity is requested the curve will be closed
    and the junction will be the first point given. The curve will than be only C1
    The curve is defined by a table of points through which it passes, and if required
    by a parallel table of reals which gives the value of the parameter of each point through
    which the resulting BSpline curve passes, and by vectors tangential to these points.
    An Interpolate object provides a framework for: defining the constraints of the BSpline curve,
    -   implementing the interpolation algorithm, and consulting the results.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dAPI_Interpolate self, Handle_TColgp_HArray1OfPnt2d Points, Standard_Boolean const PeriodicFlag, Standard_Real const Tolerance) -> Geom2dAPI_Interpolate
        __init__(Geom2dAPI_Interpolate self, Handle_TColgp_HArray1OfPnt2d Points, Handle_TColStd_HArray1OfReal Parameters, Standard_Boolean const PeriodicFlag, Standard_Real const Tolerance) -> Geom2dAPI_Interpolate

        if PeriodicFlag is True then the curve will be periodic
        Warning:
        There should be as many parameters as there are points
        except if PeriodicFlag is True : then there should be one more
        parameter to close the curve

        :type Points: OCC.wrapper.TColgp.Handle_TColgp_HArray1OfPnt2d
        :type Parameters: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :type PeriodicFlag: bool
        :type Tolerance: float

        """
        this = _Geom2dAPI.new_Geom2dAPI_Interpolate(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Load(self, *args):
        """
        Load(Geom2dAPI_Interpolate self, gp_Vec2d InitialTangent, gp_Vec2d FinalTangent, Standard_Boolean const Scale)
        Load(Geom2dAPI_Interpolate self, NCollection_Array1_gp_Vec2d Tangents, Handle_TColStd_HArray1OfBoolean TangentFlags, Standard_Boolean const Scale)

        Assigns this constrained BSpline curve to be
        tangential to vectors defined in the table Tangents,
        which is parallel to the table of points
        through which the curve passes, as
        defined at the time of initialization. Vectors
        in the table Tangents are defined only if
        the flag given in the parallel table
        TangentFlags is true: only these vectors
        are set as tangency constraints.
        <Scale> - boolean flag defining whether tangent vectors are to
        be scaled according to derivatives of lagrange interpolation.

        :type Tangents: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type TangentFlags: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfBoolean
        :type Scale: bool

        """
        return _Geom2dAPI.Geom2dAPI_Interpolate_Load(self, *args)


    def Perform(self, *args):
        """
        Perform(Geom2dAPI_Interpolate self)

        Computes the constrained BSpline curve. Use the function IsDone to verify that the
        computation is successful, and then the function Curve to obtain the result.


        """
        return _Geom2dAPI.Geom2dAPI_Interpolate_Perform(self, *args)


    def Curve(self, *args):
        """
        Returns the computed BSpline curve. Raises  StdFail_NotDone if the interpolation fails.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        res = _Geom2dAPI.Geom2dAPI_Interpolate_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDone(self, *args):
        """
        IsDone(Geom2dAPI_Interpolate self) -> Standard_Boolean

        Returns true if the constrained BSpline curve is successfully constructed.
        Note: in this case, the result is given by the function Curve.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dAPI.Geom2dAPI_Interpolate_IsDone(self, *args)

    __swig_destroy__ = _Geom2dAPI.delete_Geom2dAPI_Interpolate
Geom2dAPI_Interpolate_swigregister = _Geom2dAPI.Geom2dAPI_Interpolate_swigregister
Geom2dAPI_Interpolate_swigregister(Geom2dAPI_Interpolate)

class Geom2dAPI_ExtremaCurveCurve(object):
    """
    Describes functions for computing all the extrema
    between two 2D curves.
    An ExtremaCurveCurve algorithm minimizes or
    maximizes the distance between a point on the first
    curve and a point on the second curve. Thus, it
    computes the start point and end point of
    perpendiculars common to the two curves (an
    intersection point is not an extremum except where
    the two curves are tangential at this point).
    Solutions consist of pairs of points, and an extremum
    is considered to be a segment joining the two points of a solution.
    An ExtremaCurveCurve object provides a framework for:
    -   defining the construction of the extrema,
    -   implementing the construction algorithm, and
    -   consulting the results.
    Warning
    In some cases, the nearest points between two
    curves do not correspond to one of the computed
    extrema. Instead, they may be given by:
    -   a limit point of one curve and one of the following:
    -   its orthogonal projection on the other curve,
    -   a limit point of the other curve; or
    -   an intersection point between the two curves.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dAPI_ExtremaCurveCurve self, Handle_Geom2d_Curve C1, Handle_Geom2d_Curve C2, Standard_Real const U1min, Standard_Real const U1max, Standard_Real const U2min, Standard_Real const U2max) -> Geom2dAPI_ExtremaCurveCurve

        Computes the extrema between
        -   the portion of the curve C1 limited by the two
        points of parameter (U1min,U1max), and
        -   the portion of the curve C2 limited by the two
        points of parameter (U2min,U2max).
        Warning
        Use the function NbExtrema to obtain the number
        of solutions. If this algorithm fails, NbExtrema returns 0.

        :type C1: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type C2: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type U1min: float
        :type U1max: float
        :type U2min: float
        :type U2max: float

        """
        this = _Geom2dAPI.new_Geom2dAPI_ExtremaCurveCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbExtrema(self, *args):
        """
        NbExtrema(Geom2dAPI_ExtremaCurveCurve self) -> Standard_Integer

        Returns the number of extrema computed by this algorithm.
        Note: if this algorithm fails, NbExtrema returns 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_NbExtrema(self, *args)


    def Points(self, *args):
        """
        Points(Geom2dAPI_ExtremaCurveCurve self, Standard_Integer const Index, gp_Pnt2d P1, gp_Pnt2d P2)

        Returns the points P1 on the first curve and P2 on
        the second curve, which are the ends of the
        extremum of index Index computed by this algorithm.
        Exceptions
        Standard_OutOfRange if Index is not in the range [
        1,NbExtrema ], where NbExtrema is the
        number of extrema computed by this algorithm.

        :type Index: int
        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_Points(self, *args)


    def Parameters(self, *args):
        """
        Parameters(Geom2dAPI_ExtremaCurveCurve self, Standard_Integer const Index)

        Returns the parameters U1 of the point on the first
        curve and U2 of the point on the second curve, which
        are the ends of the extremum of index Index
        computed by this algorithm.
        Exceptions
        Standard_OutOfRange if Index is not in the range [
        1,NbExtrema ], where NbExtrema is the
        number of extrema computed by this algorithm.

        :type Index: int
        :type U1: float
        :type U2: float

        """
        return _Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_Parameters(self, *args)


    def Distance(self, *args):
        """
        Distance(Geom2dAPI_ExtremaCurveCurve self, Standard_Integer const Index) -> Standard_Real

        Computes the distance between the end points of the
        extremum of index Index computed by this algorithm.
        Exceptions
        Standard_OutOfRange if Index is not in the range [
        1,NbExtrema ], where NbExtrema is the
        number of extrema computed by this algorithm.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_Distance(self, *args)


    def NearestPoints(self, *args):
        """
        NearestPoints(Geom2dAPI_ExtremaCurveCurve self, gp_Pnt2d P1, gp_Pnt2d P2)

        Returns the points P1 on the first curve and P2 on
        the second curve, which are the ends of the shortest
        extremum computed by this algorithm.
        Exceptions StdFail_NotDone if this algorithm fails.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_NearestPoints(self, *args)


    def LowerDistanceParameters(self, *args):
        """
        LowerDistanceParameters(Geom2dAPI_ExtremaCurveCurve self)

        Returns the parameters U1 of the point on the first
        curve and U2 of the point on the second curve, which
        are the ends of the shortest extremum computed by this algorithm.
        Exceptions
        StdFail_NotDone if this algorithm fails.

        :type U1: float
        :type U2: float

        """
        return _Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_LowerDistanceParameters(self, *args)


    def LowerDistance(self, *args):
        """
        LowerDistance(Geom2dAPI_ExtremaCurveCurve self) -> Standard_Real

        Computes the distance between the end points of the
        shortest extremum computed by this algorithm.
        Exceptions - StdFail_NotDone if this algorithm fails.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_LowerDistance(self, *args)


    def Extrema(self, *args):
        """
        :rtype: OCC.wrapper.Extrema.Extrema_ExtCC2d

        """
        res = _Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_Extrema(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2dAPI.delete_Geom2dAPI_ExtremaCurveCurve
Geom2dAPI_ExtremaCurveCurve_swigregister = _Geom2dAPI.Geom2dAPI_ExtremaCurveCurve_swigregister
Geom2dAPI_ExtremaCurveCurve_swigregister(Geom2dAPI_ExtremaCurveCurve)

class Geom2dAPI_ProjectPointOnCurve(object):
    """
    This class implements methods for computing all the orthogonal
    projections of a 2D point onto a 2D curve.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dAPI_ProjectPointOnCurve self) -> Geom2dAPI_ProjectPointOnCurve
        __init__(Geom2dAPI_ProjectPointOnCurve self, gp_Pnt2d P, Handle_Geom2d_Curve Curve) -> Geom2dAPI_ProjectPointOnCurve
        __init__(Geom2dAPI_ProjectPointOnCurve self, gp_Pnt2d P, Handle_Geom2d_Curve Curve, Standard_Real const Umin, Standard_Real const Usup) -> Geom2dAPI_ProjectPointOnCurve

        Create  the projection  of a point <P>  on a curve
        <Curve> limited by the two   points of parameter Umin and Usup.
        Warning
        Use the function NbPoints to obtain the number of solutions. If
        projection fails, NbPoints returns 0.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Curve: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Umin: float
        :type Usup: float

        """
        this = _Geom2dAPI.new_Geom2dAPI_ProjectPointOnCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(Geom2dAPI_ProjectPointOnCurve self, gp_Pnt2d P, Handle_Geom2d_Curve Curve)
        Init(Geom2dAPI_ProjectPointOnCurve self, gp_Pnt2d P, Handle_Geom2d_Curve Curve, Standard_Real const Umin, Standard_Real const Usup)

        Initializes this algorithm with the given arguments, and
        computes the orthogonal projections of the point P onto the portion
        of the curve Curve limited by the two points of parameter Umin and Usup.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Curve: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Umin: float
        :type Usup: float

        """
        return _Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_Init(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(Geom2dAPI_ProjectPointOnCurve self) -> Standard_Integer

        return the number of of computed
        orthogonal projectionn points.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_NbPoints(self, *args)


    def Point(self, *args):
        """
        Point(Geom2dAPI_ProjectPointOnCurve self, Standard_Integer const Index) -> gp_Pnt2d

        Returns the orthogonal projection
        on the curve. Index is a number of a computed point.
        Exceptions
        Standard_OutOfRange if Index is not in the range [ 1,NbPoints ], where
        NbPoints is the number of solution points.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_Point(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Geom2dAPI_ProjectPointOnCurve self, Standard_Integer const Index) -> Standard_Real
        Parameter(Geom2dAPI_ProjectPointOnCurve self, Standard_Integer const Index)

        Returns the parameter on the curve
        of a point which is the orthogonal projection. Index is a number of a
        computed projected point.
        Exceptions
        Standard_OutOfRange if Index is not in the range [ 1,NbPoints ], where
        NbPoints is the number of solution points

        :type Index: int
        :type U: float

        """
        return _Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_Parameter(self, *args)


    def Distance(self, *args):
        """
        Distance(Geom2dAPI_ProjectPointOnCurve self, Standard_Integer const Index) -> Standard_Real

        Computes the distance between the
        point and its computed orthogonal projection on the curve. Index is a
        number of computed projected point.
        Exceptions
        Standard_OutOfRange if Index is not in the range [ 1,NbPoints ], where
        NbPoints is the number of solution points.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_Distance(self, *args)


    def NearestPoint(self, *args):
        """
        NearestPoint(Geom2dAPI_ProjectPointOnCurve self) -> gp_Pnt2d

        Returns the nearest orthogonal projection of the point on the curve.
        Exceptions
        StdFail_NotDone if this algorithm fails.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_NearestPoint(self, *args)


    def LowerDistanceParameter(self, *args):
        """
        LowerDistanceParameter(Geom2dAPI_ProjectPointOnCurve self) -> Standard_Real

        Returns the parameter on the curve
        of the nearest orthogonal projection of the point.
        Exceptions
        StdFail_NotDone if this algorithm fails.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_LowerDistanceParameter(self, *args)


    def LowerDistance(self, *args):
        """
        LowerDistance(Geom2dAPI_ProjectPointOnCurve self) -> Standard_Real

        Computes the distance between the
        point and its nearest orthogonal projection on the curve.
        Exceptions
        StdFail_NotDone if this algorithm fails.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_LowerDistance(self, *args)


    def Extrema(self, *args):
        """
        return the algorithmic object from Extrema

        :rtype: OCC.wrapper.Extrema.Extrema_ExtPC2d

        """
        res = _Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_Extrema(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2dAPI.delete_Geom2dAPI_ProjectPointOnCurve
Geom2dAPI_ProjectPointOnCurve_swigregister = _Geom2dAPI.Geom2dAPI_ProjectPointOnCurve_swigregister
Geom2dAPI_ProjectPointOnCurve_swigregister(Geom2dAPI_ProjectPointOnCurve)

class Geom2dAPI_InterCurveCurve(object):
    """
    This class implements methods for computing
    -       the intersections between  two 2D curves,
    -       the self-intersections of a  2D curve.
    Using the InterCurveCurve algorithm allows to get the following results:
    -      intersection points in the  case of cross intersections,
    -      intersection segments in the case of tangential intersections,
    -       nothing in the case of no intersections.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dAPI_InterCurveCurve self) -> Geom2dAPI_InterCurveCurve
        __init__(Geom2dAPI_InterCurveCurve self, Handle_Geom2d_Curve C1, Handle_Geom2d_Curve C2, Standard_Real const Tol=1.0e-6) -> Geom2dAPI_InterCurveCurve
        __init__(Geom2dAPI_InterCurveCurve self, Handle_Geom2d_Curve C1, Standard_Real const Tol=1.0e-6) -> Geom2dAPI_InterCurveCurve

        Creates an object and computes self-intersections of the curve C1.
        Tolerance value Tol, defaulted to 1.0e-6, defines the precision of
        computing the intersection points.
        In case of a tangential intersection, Tol also defines the
        size of intersection segments (limited portions of the curves)
        where the distance between all points from two curves (or a curve
        in case of self-intersection) is less than Tol.
        Warning
        Use functions NbPoints and NbSegments to obtain the number of
        solutions. If the algorithm finds no intersections NbPoints and
        NbSegments return 0.

        :type C1: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float

        """
        this = _Geom2dAPI.new_Geom2dAPI_InterCurveCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(Geom2dAPI_InterCurveCurve self, Handle_Geom2d_Curve C1, Handle_Geom2d_Curve C2, Standard_Real const Tol=1.0e-6)
        Init(Geom2dAPI_InterCurveCurve self, Handle_Geom2d_Curve C1, Standard_Real const Tol=1.0e-6)

        Initializes an algorithm with the
        given arguments and computes the self-intersections of the curve C1.
        Tolerance value Tol, defaulted to 1.0e-6, defines the precision of
        computing the intersection points. In case of a tangential
        intersection, Tol also defines the size of intersection segments
        (limited portions of the curves) where the distance between all
        points from two curves (or a curve in case of self-intersection) is less than Tol.
        Warning
        Use functions NbPoints and NbSegments to obtain the number
        of solutions. If the algorithm finds no intersections NbPoints
        and NbSegments return 0.

        :type C1: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float

        """
        return _Geom2dAPI.Geom2dAPI_InterCurveCurve_Init(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(Geom2dAPI_InterCurveCurve self) -> Standard_Integer

        Returns the number of intersection-points in case of cross intersections.
        NbPoints returns 0 if no intersections were found.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dAPI.Geom2dAPI_InterCurveCurve_NbPoints(self, *args)


    def Point(self, *args):
        """
        Point(Geom2dAPI_InterCurveCurve self, Standard_Integer const Index) -> gp_Pnt2d

        Returns the intersection point of index Index.
        Intersection points are computed in case of cross intersections with a
        precision equal to the tolerance value assigned at the time of
        construction or in the function Init (this value is defaulted to 1.0e-6).
        Exceptions
        Standard_OutOfRange if index is not in the range [ 1,NbPoints ], where
        NbPoints is the number of computed intersection points

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Geom2dAPI.Geom2dAPI_InterCurveCurve_Point(self, *args)


    def NbSegments(self, *args):
        """
        NbSegments(Geom2dAPI_InterCurveCurve self) -> Standard_Integer

        Returns the number of tangential intersections.
        NbSegments returns 0 if no intersections were found

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dAPI.Geom2dAPI_InterCurveCurve_NbSegments(self, *args)


    def Segment(self, *args):
        """
        Segment(Geom2dAPI_InterCurveCurve self, Standard_Integer const Index, Handle_Geom2d_Curve Curve1, Handle_Geom2d_Curve Curve2)

        Use this syntax only to get
        solutions of tangential intersection between two curves.
        Output values Curve1 and Curve2 are the intersection segments on the
        first curve and on the second curve accordingly. Parameter Index
        defines a number of computed solution.
        An intersection segment is a portion of an initial curve limited
        by two points. The distance from each point of this segment to the
        other curve is less or equal to the tolerance value assigned at the
        time of construction or in function Init (this value is defaulted to 1.0e-6).
        Exceptions
        Standard_OutOfRange if Index is not in the range [ 1,NbSegments ],
        where NbSegments is the number of computed tangential intersections.
        Standard_NullObject if the algorithm is initialized for the
        computing of self-intersections on a curve.

        :type Index: int
        :type Curve1: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Curve2: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _Geom2dAPI.Geom2dAPI_InterCurveCurve_Segment(self, *args)


    def Intersector(self, *args):
        """
        return the algorithmic object from Intersection.

        :rtype: OCC.wrapper.Geom2dInt.Geom2dInt_GInter

        """
        res = _Geom2dAPI.Geom2dAPI_InterCurveCurve_Intersector(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Geom2dAPI.delete_Geom2dAPI_InterCurveCurve
Geom2dAPI_InterCurveCurve_swigregister = _Geom2dAPI.Geom2dAPI_InterCurveCurve_swigregister
Geom2dAPI_InterCurveCurve_swigregister(Geom2dAPI_InterCurveCurve)




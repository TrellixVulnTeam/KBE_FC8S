# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_CPnts')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_CPnts')
    _CPnts = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_CPnts', [dirname(__file__)])
        except ImportError:
            import _CPnts
            return _CPnts
        try:
            _mod = imp.load_module('_CPnts', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _CPnts = swig_import_helper()
    del swig_import_helper
else:
    import _CPnts
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _CPnts.delete_SwigPyIterator

    def value(self):
        return _CPnts.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _CPnts.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _CPnts.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _CPnts.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _CPnts.SwigPyIterator_equal(self, x)

    def copy(self):
        return _CPnts.SwigPyIterator_copy(self)

    def next(self):
        return _CPnts.SwigPyIterator_next(self)

    def __next__(self):
        return _CPnts.SwigPyIterator___next__(self)

    def previous(self):
        return _CPnts.SwigPyIterator_previous(self)

    def advance(self, n):
        return _CPnts.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _CPnts.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _CPnts.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _CPnts.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _CPnts.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _CPnts.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _CPnts.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _CPnts.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _CPnts.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_CPnts.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _CPnts.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _CPnts.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _CPnts.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _CPnts.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _CPnts.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _CPnts.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _CPnts.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_CPnts.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _CPnts.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _CPnts.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _CPnts.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _CPnts.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _CPnts.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _CPnts.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _CPnts.ptr_to_number(item)
ptr_to_number = _CPnts.ptr_to_number

def HashCode(*args):
    return _CPnts.HashCode(*args)
HashCode = _CPnts.HashCode

def ptr_equal(a, b):
    return _CPnts.ptr_equal(a, b)
ptr_equal = _CPnts.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
class CPnts_MyRootFunction(math.math_FunctionWithDerivative):
    """
    Implements a function for the Newton algorithm to find the
    solution of Integral(F) = L
    (compute Length  and Derivative of the curve for Newton)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CPnts_MyRootFunction self) -> CPnts_MyRootFunction

        Implements a function for the Newton algorithm to find the
        solution of Integral(F) = L
        (compute Length  and Derivative of the curve for Newton)
        """
        this = _CPnts.new_CPnts_MyRootFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(CPnts_MyRootFunction self, CPnts_RealFunction const & F, Standard_Address const D, Standard_Integer const Order)
        Init(CPnts_MyRootFunction self, Standard_Real const X0, Standard_Real const L)
        Init(CPnts_MyRootFunction self, Standard_Real const X0, Standard_Real const L, Standard_Real const Tol)

        We want to solve Integral(X0,X,F(X,D)) = L
        with given tolerance

        :type X0: float
        :type L: float
        :type Tol: float

        """
        return _CPnts.CPnts_MyRootFunction_Init(self, *args)


    def Value(self, *args):
        """
        Value(CPnts_MyRootFunction self, Standard_Real const X) -> Standard_Boolean

        This is Integral(X0,X,F(X,D)) - L

        :type X: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CPnts.CPnts_MyRootFunction_Value(self, *args)


    def Derivative(self, *args):
        """
        Derivative(CPnts_MyRootFunction self, Standard_Real const X) -> Standard_Boolean

        This is F(X,D)

        :type X: float
        :type Df: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CPnts.CPnts_MyRootFunction_Derivative(self, *args)


    def Values(self, *args):
        """
        Values(CPnts_MyRootFunction self, Standard_Real const X) -> Standard_Boolean

        :type X: float
        :type F: float
        :type Df: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CPnts.CPnts_MyRootFunction_Values(self, *args)

    __swig_destroy__ = _CPnts.delete_CPnts_MyRootFunction
CPnts_MyRootFunction_swigregister = _CPnts.CPnts_MyRootFunction_swigregister
CPnts_MyRootFunction_swigregister(CPnts_MyRootFunction)

class CPnts_AbscissaPoint(object):
    """
    the algorithm computes a point on a curve at a given
    distance from another point on the curve

    We can instantiates with
    Curve from Adaptor3d, Pnt from gp, Vec from gp

    or
    Curve2d from Adaptor2d, Pnt2d from gp, Vec2d from gp
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Length(*args):
        """
        Length(Adaptor3d_Curve C) -> Standard_Real
        Length(Adaptor2d_Curve2d C) -> Standard_Real
        Length(Adaptor3d_Curve C, Standard_Real const Tol) -> Standard_Real
        Length(Adaptor2d_Curve2d C, Standard_Real const Tol) -> Standard_Real
        Length(Adaptor3d_Curve C, Standard_Real const U1, Standard_Real const U2) -> Standard_Real
        Length(Adaptor2d_Curve2d C, Standard_Real const U1, Standard_Real const U2) -> Standard_Real
        Length(Adaptor3d_Curve C, Standard_Real const U1, Standard_Real const U2, Standard_Real const Tol) -> Standard_Real
        Length(Adaptor2d_Curve2d C, Standard_Real const U1, Standard_Real const U2, Standard_Real const Tol) -> Standard_Real

        Computes the length of the Curve <C> between <U1> and <U2> with the given tolerance.
        creation of a indefinite AbscissaPoint.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type U1: float
        :type U2: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _CPnts.CPnts_AbscissaPoint_Length(*args)

    Length = staticmethod(Length)

    def __init__(self, *args):
        """
        __init__(CPnts_AbscissaPoint self) -> CPnts_AbscissaPoint
        __init__(CPnts_AbscissaPoint self, Adaptor3d_Curve C, Standard_Real const Abscissa, Standard_Real const U0, Standard_Real const Resolution) -> CPnts_AbscissaPoint
        __init__(CPnts_AbscissaPoint self, Adaptor2d_Curve2d C, Standard_Real const Abscissa, Standard_Real const U0, Standard_Real const Resolution) -> CPnts_AbscissaPoint
        __init__(CPnts_AbscissaPoint self, Adaptor3d_Curve C, Standard_Real const Abscissa, Standard_Real const U0, Standard_Real const Ui, Standard_Real const Resolution) -> CPnts_AbscissaPoint
        __init__(CPnts_AbscissaPoint self, Adaptor2d_Curve2d C, Standard_Real const Abscissa, Standard_Real const U0, Standard_Real const Ui, Standard_Real const Resolution) -> CPnts_AbscissaPoint

        the algorithm computes a point on a curve <Curve> at the
        distance <Abscissa> from the point of parameter <U0>.
        <Ui> is the starting value used in the iterative process
        which find the solution, it must be closed to the final
        solution
        <Resolution> is the error allowed in the computation.
        The computed point can be outside of the curve 's bounds.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type Abscissa: float
        :type U0: float
        :type Ui: float
        :type Resolution: float

        """
        this = _CPnts.new_CPnts_AbscissaPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(CPnts_AbscissaPoint self, Adaptor3d_Curve C)
        Init(CPnts_AbscissaPoint self, Adaptor2d_Curve2d C)
        Init(CPnts_AbscissaPoint self, Adaptor3d_Curve C, Standard_Real const Tol)
        Init(CPnts_AbscissaPoint self, Adaptor2d_Curve2d C, Standard_Real const Tol)
        Init(CPnts_AbscissaPoint self, Adaptor3d_Curve C, Standard_Real const U1, Standard_Real const U2)
        Init(CPnts_AbscissaPoint self, Adaptor2d_Curve2d C, Standard_Real const U1, Standard_Real const U2)
        Init(CPnts_AbscissaPoint self, Adaptor3d_Curve C, Standard_Real const U1, Standard_Real const U2, Standard_Real const Tol)
        Init(CPnts_AbscissaPoint self, Adaptor2d_Curve2d C, Standard_Real const U1, Standard_Real const U2, Standard_Real const Tol)

        Initializes the resolution function with <C>
        between U1 and U2.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type U1: float
        :type U2: float
        :type Tol: float

        """
        return _CPnts.CPnts_AbscissaPoint_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(CPnts_AbscissaPoint self, Standard_Real const Abscissa, Standard_Real const U0, Standard_Real const Resolution)
        Perform(CPnts_AbscissaPoint self, Standard_Real const Abscissa, Standard_Real const U0, Standard_Real const Ui, Standard_Real const Resolution)

        Computes the point at the distance <Abscissa> of
        the curve.
        U0 is the parameter of the point from which the distance
        is measured and Ui is the starting value for the iterative
        process (should be close to the final solution).

        :type Abscissa: float
        :type U0: float
        :type Ui: float
        :type Resolution: float

        """
        return _CPnts.CPnts_AbscissaPoint_Perform(self, *args)


    def AdvPerform(self, *args):
        """
        AdvPerform(CPnts_AbscissaPoint self, Standard_Real const Abscissa, Standard_Real const U0, Standard_Real const Ui, Standard_Real const Resolution)

        Computes the point at the distance <Abscissa> of
        the curve; performs more appropriate tolerance managment;
        to use this method in right way it is necessary to call
        empty consructor. then call method Init with
        Tolerance = Resolution, then call AdvPermorm.
        U0 is the parameter of the point from which the distance
        is measured and Ui is the starting value for the iterative
        process (should be close to the final solution).

        :type Abscissa: float
        :type U0: float
        :type Ui: float
        :type Resolution: float

        """
        return _CPnts.CPnts_AbscissaPoint_AdvPerform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(CPnts_AbscissaPoint self) -> Standard_Boolean

        True if the computation was successful, False otherwise.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CPnts.CPnts_AbscissaPoint_IsDone(self, *args)


    def Parameter(self, *args):
        """
        Parameter(CPnts_AbscissaPoint self) -> Standard_Real

        Returns the parameter of the solution.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _CPnts.CPnts_AbscissaPoint_Parameter(self, *args)


    def SetParameter(self, *args):
        """
        SetParameter(CPnts_AbscissaPoint self, Standard_Real const P)

        Enforce the solution, used by GCPnts.

        :type P: float

        """
        return _CPnts.CPnts_AbscissaPoint_SetParameter(self, *args)

    __swig_destroy__ = _CPnts.delete_CPnts_AbscissaPoint
CPnts_AbscissaPoint_swigregister = _CPnts.CPnts_AbscissaPoint_swigregister
CPnts_AbscissaPoint_swigregister(CPnts_AbscissaPoint)

def CPnts_AbscissaPoint_Length(*args):
    """
    Length(Adaptor3d_Curve C) -> Standard_Real
    Length(Adaptor2d_Curve2d C) -> Standard_Real
    Length(Adaptor3d_Curve C, Standard_Real const Tol) -> Standard_Real
    Length(Adaptor2d_Curve2d C, Standard_Real const Tol) -> Standard_Real
    Length(Adaptor3d_Curve C, Standard_Real const U1, Standard_Real const U2) -> Standard_Real
    Length(Adaptor2d_Curve2d C, Standard_Real const U1, Standard_Real const U2) -> Standard_Real
    Length(Adaptor3d_Curve C, Standard_Real const U1, Standard_Real const U2, Standard_Real const Tol) -> Standard_Real
    CPnts_AbscissaPoint_Length(Adaptor2d_Curve2d C, Standard_Real const U1, Standard_Real const U2, Standard_Real const Tol) -> Standard_Real

    Computes the length of the Curve <C> between <U1> and <U2> with the given tolerance.
    creation of a indefinite AbscissaPoint.

    :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
    :type U1: float
    :type U2: float
    :type Tol: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _CPnts.CPnts_AbscissaPoint_Length(*args)

class CPnts_UniformDeflection(object):
    """
    This class defines an algorithm to create a set of points
    (with a given chordal deviation) at the
    positions of constant deflection of a given parametrized curve or a trimmed
    circle.
    The continuity of the curve must be at least C2.

    the usage of the is the following.

    class myUniformDFeflection instantiates
    UniformDeflection(Curve, Tool);

    Curve C; // Curve inherits from Curve or Curve2d from Adaptor2d
    myUniformDeflection Iter1;
    DefPntOfmyUniformDeflection P;

    for(Iter1.Initialize(C, Deflection, EPSILON, True);
    Iter1.More();
    Iter1.Next()) {
    P = Iter1.Value();
    ... make something with P
    }
    if(!Iter1.IsAllDone()) {
    ... something wrong happened
    }
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CPnts_UniformDeflection self) -> CPnts_UniformDeflection
        __init__(CPnts_UniformDeflection self, Adaptor3d_Curve C, Standard_Real const Deflection, Standard_Real const Resolution, Standard_Boolean const WithControl) -> CPnts_UniformDeflection
        __init__(CPnts_UniformDeflection self, Adaptor2d_Curve2d C, Standard_Real const Deflection, Standard_Real const Resolution, Standard_Boolean const WithControl) -> CPnts_UniformDeflection
        __init__(CPnts_UniformDeflection self, Adaptor3d_Curve C, Standard_Real const Deflection, Standard_Real const U1, Standard_Real const U2, Standard_Real const Resolution, Standard_Boolean const WithControl) -> CPnts_UniformDeflection
        __init__(CPnts_UniformDeflection self, Adaptor2d_Curve2d C, Standard_Real const Deflection, Standard_Real const U1, Standard_Real const U2, Standard_Real const Resolution, Standard_Boolean const WithControl) -> CPnts_UniformDeflection

        As above with 2d curve

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type Deflection: float
        :type U1: float
        :type U2: float
        :type Resolution: float
        :type WithControl: bool

        """
        this = _CPnts.new_CPnts_UniformDeflection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(CPnts_UniformDeflection self, Adaptor3d_Curve C, Standard_Real const Deflection, Standard_Real const Resolution, Standard_Boolean const WithControl)
        Initialize(CPnts_UniformDeflection self, Adaptor2d_Curve2d C, Standard_Real const Deflection, Standard_Real const Resolution, Standard_Boolean const WithControl)
        Initialize(CPnts_UniformDeflection self, Adaptor3d_Curve C, Standard_Real const Deflection, Standard_Real const U1, Standard_Real const U2, Standard_Real const Resolution, Standard_Boolean const WithControl)
        Initialize(CPnts_UniformDeflection self, Adaptor2d_Curve2d C, Standard_Real const Deflection, Standard_Real const U1, Standard_Real const U2, Standard_Real const Resolution, Standard_Boolean const WithControl)

        Initialize the algoritms with <C>, <Deflection>, <UStep>,
        <U1>, <U2> and <WithControl>

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d
        :type Deflection: float
        :type U1: float
        :type U2: float
        :type Resolution: float
        :type WithControl: bool

        """
        return _CPnts.CPnts_UniformDeflection_Initialize(self, *args)


    def IsAllDone(self, *args):
        """
        IsAllDone(CPnts_UniformDeflection self) -> Standard_Boolean

        To know if all the calculus were done successfully
        (ie all the points have been computed). The calculus can fail if
        the Curve is not C1 in the considered domain.
        Returns True if the calculus was successful.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CPnts.CPnts_UniformDeflection_IsAllDone(self, *args)


    def Next(self, *args):
        """
        Next(CPnts_UniformDeflection self)

        go to the next Point.


        """
        return _CPnts.CPnts_UniformDeflection_Next(self, *args)


    def More(self, *args):
        """
        More(CPnts_UniformDeflection self) -> Standard_Boolean

        returns True if it exists a next Point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CPnts.CPnts_UniformDeflection_More(self, *args)


    def Value(self, *args):
        """
        Value(CPnts_UniformDeflection self) -> Standard_Real

        return the computed parameter

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _CPnts.CPnts_UniformDeflection_Value(self, *args)


    def Point(self, *args):
        """
        Point(CPnts_UniformDeflection self) -> gp_Pnt

        return the computed parameter

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _CPnts.CPnts_UniformDeflection_Point(self, *args)

    __swig_destroy__ = _CPnts.delete_CPnts_UniformDeflection
CPnts_UniformDeflection_swigregister = _CPnts.CPnts_UniformDeflection_swigregister
CPnts_UniformDeflection_swigregister(CPnts_UniformDeflection)

class CPnts_MyGaussFunction(math.math_Function):
    """for implementation, compute values for Gauss"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CPnts_MyGaussFunction self) -> CPnts_MyGaussFunction

        for implementation, compute values for Gauss
        """
        this = _CPnts.new_CPnts_MyGaussFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(CPnts_MyGaussFunction self, CPnts_RealFunction const & F, Standard_Address const D)

        F  is a pointer on a  function  D is a client data

        Each value is computed with F(D)

        :type F: OCC.wrapper.CPnts.CPnts_RealFunction
        :type D: OCC.wrapper.Standard.Standard_Address

        """
        return _CPnts.CPnts_MyGaussFunction_Init(self, *args)


    def Value(self, *args):
        """
        Value(CPnts_MyGaussFunction self, Standard_Real const X) -> Standard_Boolean

        :type X: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CPnts.CPnts_MyGaussFunction_Value(self, *args)

    __swig_destroy__ = _CPnts.delete_CPnts_MyGaussFunction
CPnts_MyGaussFunction_swigregister = _CPnts.CPnts_MyGaussFunction_swigregister
CPnts_MyGaussFunction_swigregister(CPnts_MyGaussFunction)




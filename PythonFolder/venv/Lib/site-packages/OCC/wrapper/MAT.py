# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_MAT')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_MAT')
    _MAT = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_MAT', [dirname(__file__)])
        except ImportError:
            import _MAT
            return _MAT
        try:
            _mod = imp.load_module('_MAT', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _MAT = swig_import_helper()
    del swig_import_helper
else:
    import _MAT
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _MAT.delete_SwigPyIterator

    def value(self):
        return _MAT.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _MAT.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _MAT.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _MAT.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _MAT.SwigPyIterator_equal(self, x)

    def copy(self):
        return _MAT.SwigPyIterator_copy(self)

    def next(self):
        return _MAT.SwigPyIterator_next(self)

    def __next__(self):
        return _MAT.SwigPyIterator___next__(self)

    def previous(self):
        return _MAT.SwigPyIterator_previous(self)

    def advance(self, n):
        return _MAT.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _MAT.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _MAT.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _MAT.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _MAT.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _MAT.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _MAT.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _MAT.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _MAT.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_MAT.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _MAT.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _MAT.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MAT.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _MAT.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _MAT.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _MAT.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _MAT.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_MAT.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _MAT.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _MAT.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MAT.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _MAT.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _MAT.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _MAT.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _MAT.ptr_to_number(item)
ptr_to_number = _MAT.ptr_to_number

def HashCode(*args):
    return _MAT.HashCode(*args)
HashCode = _MAT.HashCode

def ptr_equal(a, b):
    return _MAT.ptr_equal(a, b)
ptr_equal = _MAT.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
MAT_Left = _MAT.MAT_Left
MAT_Right = _MAT.MAT_Right
class MAT_Bisector(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MAT_Bisector
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MAT_Bisector(self) 
            return h


    def __init__(self, *args):
        """__init__(MAT_Bisector self) -> MAT_Bisector"""
        this = _MAT.new_MAT_Bisector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def AddBisector(self, *args):
        """
        AddBisector(MAT_Bisector self, Handle_MAT_Bisector abisector)

        :type abisector: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.MAT_Bisector_AddBisector(self, *args)


    def List(self, *args):
        """
        List(MAT_Bisector self) -> Handle_MAT_ListOfBisector

        :rtype: OCC.wrapper.MAT.Handle_MAT_ListOfBisector

        """
        return _MAT.MAT_Bisector_List(self, *args)


    def FirstBisector(self, *args):
        """
        FirstBisector(MAT_Bisector self) -> Handle_MAT_Bisector

        :rtype: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.MAT_Bisector_FirstBisector(self, *args)


    def LastBisector(self, *args):
        """
        LastBisector(MAT_Bisector self) -> Handle_MAT_Bisector

        :rtype: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.MAT_Bisector_LastBisector(self, *args)


    def BisectorNumber(self, *args):
        """
        BisectorNumber(MAT_Bisector self, Standard_Integer const anumber)
        BisectorNumber(MAT_Bisector self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.MAT_Bisector_BisectorNumber(self, *args)


    def IndexNumber(self, *args):
        """
        IndexNumber(MAT_Bisector self, Standard_Integer const anumber)
        IndexNumber(MAT_Bisector self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.MAT_Bisector_IndexNumber(self, *args)


    def FirstEdge(self, *args):
        """
        FirstEdge(MAT_Bisector self, Handle_MAT_Edge anedge)
        FirstEdge(MAT_Bisector self) -> Handle_MAT_Edge

        :rtype: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.MAT_Bisector_FirstEdge(self, *args)


    def SecondEdge(self, *args):
        """
        SecondEdge(MAT_Bisector self, Handle_MAT_Edge anedge)
        SecondEdge(MAT_Bisector self) -> Handle_MAT_Edge

        :rtype: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.MAT_Bisector_SecondEdge(self, *args)


    def IssuePoint(self, *args):
        """
        IssuePoint(MAT_Bisector self, Standard_Integer const apoint)
        IssuePoint(MAT_Bisector self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.MAT_Bisector_IssuePoint(self, *args)


    def EndPoint(self, *args):
        """
        EndPoint(MAT_Bisector self, Standard_Integer const apoint)
        EndPoint(MAT_Bisector self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.MAT_Bisector_EndPoint(self, *args)


    def DistIssuePoint(self, *args):
        """
        DistIssuePoint(MAT_Bisector self, Standard_Real const areal)
        DistIssuePoint(MAT_Bisector self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MAT.MAT_Bisector_DistIssuePoint(self, *args)


    def FirstVector(self, *args):
        """
        FirstVector(MAT_Bisector self, Standard_Integer const avector)
        FirstVector(MAT_Bisector self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.MAT_Bisector_FirstVector(self, *args)


    def SecondVector(self, *args):
        """
        SecondVector(MAT_Bisector self, Standard_Integer const avector)
        SecondVector(MAT_Bisector self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.MAT_Bisector_SecondVector(self, *args)


    def Sense(self, *args):
        """
        Sense(MAT_Bisector self, Standard_Real const asense)
        Sense(MAT_Bisector self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MAT.MAT_Bisector_Sense(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(MAT_Bisector self, Standard_Real const aparameter)
        FirstParameter(MAT_Bisector self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MAT.MAT_Bisector_FirstParameter(self, *args)


    def SecondParameter(self, *args):
        """
        SecondParameter(MAT_Bisector self, Standard_Real const aparameter)
        SecondParameter(MAT_Bisector self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MAT.MAT_Bisector_SecondParameter(self, *args)


    def Dump(self, *args):
        """
        Dump(MAT_Bisector self, Standard_Integer const ashift, Standard_Integer const alevel)

        :type ashift: int
        :type alevel: int

        """
        return _MAT.MAT_Bisector_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MAT.MAT_Bisector_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MAT.MAT_Bisector_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.MAT_Bisector_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MAT.delete_MAT_Bisector
MAT_Bisector_swigregister = _MAT.MAT_Bisector_swigregister
MAT_Bisector_swigregister(MAT_Bisector)

def MAT_Bisector_get_type_name(*args):
    """
    MAT_Bisector_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MAT.MAT_Bisector_get_type_name(*args)

def MAT_Bisector_get_type_descriptor(*args):
    """
    MAT_Bisector_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MAT.MAT_Bisector_get_type_descriptor(*args)

class MAT_Graph(Standard.Standard_Transient):
    """
    The Class Graph permits the exploration of the
    Bisector Locus.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MAT_Graph
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MAT_Graph(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MAT_Graph self) -> MAT_Graph

        Empty constructor.


        """
        this = _MAT.new_MAT_Graph(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Perform(self, *args):
        """
        Perform(MAT_Graph self, Standard_Boolean const SemiInfinite, Handle_MAT_ListOfBisector TheRoots, Standard_Integer const NbBasicElts, Standard_Integer const NbArcs)

        Construct <me> from the result of the method
        <CreateMat> of the class <MAT> from <MAT>.

        <SemiInfinite> : if some bisector are infinites.
        <TheRoots>     : Set of the bisectors.
        <NbBasicElts>  : Number of Basic Elements.
        <NbArcs>       : Number of Arcs = Number of Bisectors.

        :type SemiInfinite: bool
        :type TheRoots: OCC.wrapper.MAT.Handle_MAT_ListOfBisector
        :type NbBasicElts: int
        :type NbArcs: int

        """
        return _MAT.MAT_Graph_Perform(self, *args)


    def Arc(self, *args):
        """
        Arc(MAT_Graph self, Standard_Integer const Index) -> Handle_MAT_Arc

        Return the Arc of index <Index> in <theArcs>.

        :type Index: int
        :rtype: OCC.wrapper.MAT.Handle_MAT_Arc

        """
        return _MAT.MAT_Graph_Arc(self, *args)


    def BasicElt(self, *args):
        """
        BasicElt(MAT_Graph self, Standard_Integer const Index) -> Handle_MAT_BasicElt

        Return the BasicElt of index <Index> in <theBasicElts>.

        :type Index: int
        :rtype: OCC.wrapper.MAT.Handle_MAT_BasicElt

        """
        return _MAT.MAT_Graph_BasicElt(self, *args)


    def Node(self, *args):
        """
        Node(MAT_Graph self, Standard_Integer const Index) -> Handle_MAT_Node

        Return the Node of index <Index> in <theNodes>.

        :type Index: int
        :rtype: OCC.wrapper.MAT.Handle_MAT_Node

        """
        return _MAT.MAT_Graph_Node(self, *args)


    def NumberOfArcs(self, *args):
        """
        NumberOfArcs(MAT_Graph self) -> Standard_Integer

        Return the number of arcs of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.MAT_Graph_NumberOfArcs(self, *args)


    def NumberOfNodes(self, *args):
        """
        NumberOfNodes(MAT_Graph self) -> Standard_Integer

        Return the number of nodes of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.MAT_Graph_NumberOfNodes(self, *args)


    def NumberOfBasicElts(self, *args):
        """
        NumberOfBasicElts(MAT_Graph self) -> Standard_Integer

        Return the number of basic elements of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.MAT_Graph_NumberOfBasicElts(self, *args)


    def NumberOfInfiniteNodes(self, *args):
        """
        NumberOfInfiniteNodes(MAT_Graph self) -> Standard_Integer

        Return the number of infinites nodes of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.MAT_Graph_NumberOfInfiniteNodes(self, *args)


    def FusionOfBasicElts(self, *args):
        """
        FusionOfBasicElts(MAT_Graph self, Standard_Integer const IndexElt1, Standard_Integer const IndexElt2)

        Merge two BasicElts.  The End of the BasicElt Elt1
        of  IndexElt1 becomes The End of the BasicElt Elt2
        of  IndexElt2.   Elt2 is replaced in  the  arcs  by
        Elt1, Elt2 is eliminated.

        <MergeArc1> is True  if the fusion  of the BasicElts  =>
        a fusion  of two Arcs which separated  the same  elements.
        In this case <GeomIndexArc1> and  <GeomIndexArc2>  are the
        Geometric  Index of this  arcs.

        If the  BasicElt corresponds to a close line ,
        the StartArc and the EndArc of Elt1 can separate the same
        elements .
        In this case there is a fusion of this arcs, <MergeArc2>
        is true and <GeomIndexArc3> and  <GeomIndexArc4>  are the
        Geometric  Index of this  arcs.

        :type IndexElt1: int
        :type IndexElt2: int
        :type MergeArc1: bool
        :type GeomIndexArc1: int
        :type GeomIndexArc2: int
        :type MergeArc2: bool
        :type GeomIndexArc3: int
        :type GeomIndexArc4: int

        """
        return _MAT.MAT_Graph_FusionOfBasicElts(self, *args)


    def CompactArcs(self, *args):
        """CompactArcs(MAT_Graph self)"""
        return _MAT.MAT_Graph_CompactArcs(self, *args)


    def CompactNodes(self, *args):
        """CompactNodes(MAT_Graph self)"""
        return _MAT.MAT_Graph_CompactNodes(self, *args)


    def ChangeBasicElts(self, *args):
        """
        ChangeBasicElts(MAT_Graph self, NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher NewMap)

        :type NewMap: OCC.wrapper.MAT.MAT_DataMapOfIntegerBasicElt

        """
        return _MAT.MAT_Graph_ChangeBasicElts(self, *args)


    def ChangeBasicElt(self, *args):
        """
        ChangeBasicElt(MAT_Graph self, Standard_Integer const Index) -> Handle_MAT_BasicElt

        :type Index: int
        :rtype: OCC.wrapper.MAT.Handle_MAT_BasicElt

        """
        return _MAT.MAT_Graph_ChangeBasicElt(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MAT.MAT_Graph_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MAT.MAT_Graph_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.MAT_Graph_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MAT.delete_MAT_Graph
MAT_Graph_swigregister = _MAT.MAT_Graph_swigregister
MAT_Graph_swigregister(MAT_Graph)

def MAT_Graph_get_type_name(*args):
    """
    MAT_Graph_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MAT.MAT_Graph_get_type_name(*args)

def MAT_Graph_get_type_descriptor(*args):
    """
    MAT_Graph_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MAT.MAT_Graph_get_type_descriptor(*args)

class MAT_TListNodeOfListOfBisector(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MAT_TListNodeOfListOfBisector
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MAT_TListNodeOfListOfBisector(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MAT_TListNodeOfListOfBisector self) -> MAT_TListNodeOfListOfBisector
        __init__(MAT_TListNodeOfListOfBisector self, Handle_MAT_Bisector anitem) -> MAT_TListNodeOfListOfBisector

        :type anitem: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        this = _MAT.new_MAT_TListNodeOfListOfBisector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetItem(self, *args):
        """
        GetItem(MAT_TListNodeOfListOfBisector self) -> Handle_MAT_Bisector

        :rtype: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.MAT_TListNodeOfListOfBisector_GetItem(self, *args)


    def SetItem(self, *args):
        """
        SetItem(MAT_TListNodeOfListOfBisector self, Handle_MAT_Bisector anitem)

        :type anitem: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.MAT_TListNodeOfListOfBisector_SetItem(self, *args)


    def Next(self, *args):
        """
        Next(MAT_TListNodeOfListOfBisector self) -> Handle_MAT_TListNodeOfListOfBisector
        Next(MAT_TListNodeOfListOfBisector self, Handle_MAT_TListNodeOfListOfBisector atlistnode)

        :type atlistnode: OCC.wrapper.MAT.Handle_MAT_TListNodeOfListOfBisector

        """
        return _MAT.MAT_TListNodeOfListOfBisector_Next(self, *args)


    def Previous(self, *args):
        """
        Previous(MAT_TListNodeOfListOfBisector self) -> Handle_MAT_TListNodeOfListOfBisector
        Previous(MAT_TListNodeOfListOfBisector self, Handle_MAT_TListNodeOfListOfBisector atlistnode)

        :type atlistnode: OCC.wrapper.MAT.Handle_MAT_TListNodeOfListOfBisector

        """
        return _MAT.MAT_TListNodeOfListOfBisector_Previous(self, *args)


    def Dummy(self, *args):
        """Dummy(MAT_TListNodeOfListOfBisector self)"""
        return _MAT.MAT_TListNodeOfListOfBisector_Dummy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MAT.MAT_TListNodeOfListOfBisector_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MAT.MAT_TListNodeOfListOfBisector_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.MAT_TListNodeOfListOfBisector_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MAT.delete_MAT_TListNodeOfListOfBisector
MAT_TListNodeOfListOfBisector_swigregister = _MAT.MAT_TListNodeOfListOfBisector_swigregister
MAT_TListNodeOfListOfBisector_swigregister(MAT_TListNodeOfListOfBisector)

def MAT_TListNodeOfListOfBisector_get_type_name(*args):
    """
    MAT_TListNodeOfListOfBisector_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MAT.MAT_TListNodeOfListOfBisector_get_type_name(*args)

def MAT_TListNodeOfListOfBisector_get_type_descriptor(*args):
    """
    MAT_TListNodeOfListOfBisector_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MAT.MAT_TListNodeOfListOfBisector_get_type_descriptor(*args)

class MAT_ListOfEdge(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MAT_ListOfEdge
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MAT_ListOfEdge(self) 
            return h


    def __init__(self, *args):
        """__init__(MAT_ListOfEdge self) -> MAT_ListOfEdge"""
        this = _MAT.new_MAT_ListOfEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def First(self, *args):
        """First(MAT_ListOfEdge self)"""
        return _MAT.MAT_ListOfEdge_First(self, *args)


    def Last(self, *args):
        """Last(MAT_ListOfEdge self)"""
        return _MAT.MAT_ListOfEdge_Last(self, *args)


    def Init(self, *args):
        """
        Init(MAT_ListOfEdge self, Handle_MAT_Edge aniten)

        :type aniten: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.MAT_ListOfEdge_Init(self, *args)


    def Next(self, *args):
        """Next(MAT_ListOfEdge self)"""
        return _MAT.MAT_ListOfEdge_Next(self, *args)


    def Previous(self, *args):
        """Previous(MAT_ListOfEdge self)"""
        return _MAT.MAT_ListOfEdge_Previous(self, *args)


    def More(self, *args):
        """
        More(MAT_ListOfEdge self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.MAT_ListOfEdge_More(self, *args)


    def Current(self, *args):
        """
        Current(MAT_ListOfEdge self) -> Handle_MAT_Edge
        Current(MAT_ListOfEdge self, Handle_MAT_Edge anitem)

        :type anitem: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.MAT_ListOfEdge_Current(self, *args)


    def FirstItem(self, *args):
        """
        FirstItem(MAT_ListOfEdge self) -> Handle_MAT_Edge

        :rtype: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.MAT_ListOfEdge_FirstItem(self, *args)


    def LastItem(self, *args):
        """
        LastItem(MAT_ListOfEdge self) -> Handle_MAT_Edge

        :rtype: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.MAT_ListOfEdge_LastItem(self, *args)


    def PreviousItem(self, *args):
        """
        PreviousItem(MAT_ListOfEdge self) -> Handle_MAT_Edge

        :rtype: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.MAT_ListOfEdge_PreviousItem(self, *args)


    def NextItem(self, *args):
        """
        NextItem(MAT_ListOfEdge self) -> Handle_MAT_Edge

        :rtype: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.MAT_ListOfEdge_NextItem(self, *args)


    def Number(self, *args):
        """
        Number(MAT_ListOfEdge self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.MAT_ListOfEdge_Number(self, *args)


    def Index(self, *args):
        """
        Index(MAT_ListOfEdge self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.MAT_ListOfEdge_Index(self, *args)


    def Brackets(self, *args):
        """
        Brackets(MAT_ListOfEdge self, Standard_Integer const anindex) -> Handle_MAT_Edge

        :type anindex: int
        :rtype: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.MAT_ListOfEdge_Brackets(self, *args)


    def __call__(self, *args):
        """
        __call__(MAT_ListOfEdge self, Standard_Integer const anindex) -> Handle_MAT_Edge

        :type anindex: int
        :rtype: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.MAT_ListOfEdge___call__(self, *args)


    def Unlink(self, *args):
        """Unlink(MAT_ListOfEdge self)"""
        return _MAT.MAT_ListOfEdge_Unlink(self, *args)


    def LinkBefore(self, *args):
        """
        LinkBefore(MAT_ListOfEdge self, Handle_MAT_Edge anitem)

        :type anitem: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.MAT_ListOfEdge_LinkBefore(self, *args)


    def LinkAfter(self, *args):
        """
        LinkAfter(MAT_ListOfEdge self, Handle_MAT_Edge anitem)

        :type anitem: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.MAT_ListOfEdge_LinkAfter(self, *args)


    def FrontAdd(self, *args):
        """
        FrontAdd(MAT_ListOfEdge self, Handle_MAT_Edge anitem)

        :type anitem: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.MAT_ListOfEdge_FrontAdd(self, *args)


    def BackAdd(self, *args):
        """
        BackAdd(MAT_ListOfEdge self, Handle_MAT_Edge anitem)

        :type anitem: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.MAT_ListOfEdge_BackAdd(self, *args)


    def Permute(self, *args):
        """Permute(MAT_ListOfEdge self)"""
        return _MAT.MAT_ListOfEdge_Permute(self, *args)


    def Loop(self, *args):
        """Loop(MAT_ListOfEdge self)"""
        return _MAT.MAT_ListOfEdge_Loop(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(MAT_ListOfEdge self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.MAT_ListOfEdge_IsEmpty(self, *args)


    def Dump(self, *args):
        """
        Dump(MAT_ListOfEdge self, Standard_Integer const ashift, Standard_Integer const alevel)

        :type ashift: int
        :type alevel: int

        """
        return _MAT.MAT_ListOfEdge_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MAT.MAT_ListOfEdge_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MAT.MAT_ListOfEdge_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.MAT_ListOfEdge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MAT.delete_MAT_ListOfEdge
MAT_ListOfEdge_swigregister = _MAT.MAT_ListOfEdge_swigregister
MAT_ListOfEdge_swigregister(MAT_ListOfEdge)

def MAT_ListOfEdge_get_type_name(*args):
    """
    MAT_ListOfEdge_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MAT.MAT_ListOfEdge_get_type_name(*args)

def MAT_ListOfEdge_get_type_descriptor(*args):
    """
    MAT_ListOfEdge_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MAT.MAT_ListOfEdge_get_type_descriptor(*args)

class Handle_MAT_Bisector(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MAT_Bisector self)

        Nullify the handle


        """
        return _MAT.Handle_MAT_Bisector_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MAT_Bisector self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MAT.Handle_MAT_Bisector_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MAT_Bisector self, MAT_Bisector thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MAT.Handle_MAT_Bisector_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MAT_Bisector self, Handle_MAT_Bisector theHandle) -> Handle_MAT_Bisector
        assign(Handle_MAT_Bisector self, MAT_Bisector thePtr) -> Handle_MAT_Bisector
        assign(Handle_MAT_Bisector self, Handle_MAT_Bisector theHandle) -> Handle_MAT_Bisector

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MAT.Handle_MAT_Bisector_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MAT_Bisector self) -> MAT_Bisector

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MAT.Handle_MAT_Bisector_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MAT_Bisector self) -> MAT_Bisector

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MAT.Handle_MAT_Bisector___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MAT_Bisector self) -> MAT_Bisector

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MAT.Handle_MAT_Bisector___ref__(self, *args)


    def __hash__(self):
        return _MAT.Handle_MAT_Bisector___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MAT.Handle_MAT_Bisector___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MAT.new_Handle_MAT_Bisector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MAT.Handle_MAT_Bisector_DownCast)
    __swig_destroy__ = _MAT.delete_Handle_MAT_Bisector

    def AddBisector(self, *args):
        """
        AddBisector(Handle_MAT_Bisector self, Handle_MAT_Bisector abisector)

        :type abisector: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.Handle_MAT_Bisector_AddBisector(self, *args)


    def List(self, *args):
        """
        List(Handle_MAT_Bisector self) -> Handle_MAT_ListOfBisector

        :rtype: OCC.wrapper.MAT.Handle_MAT_ListOfBisector

        """
        return _MAT.Handle_MAT_Bisector_List(self, *args)


    def FirstBisector(self, *args):
        """
        FirstBisector(Handle_MAT_Bisector self) -> Handle_MAT_Bisector

        :rtype: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.Handle_MAT_Bisector_FirstBisector(self, *args)


    def LastBisector(self, *args):
        """
        LastBisector(Handle_MAT_Bisector self) -> Handle_MAT_Bisector

        :rtype: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.Handle_MAT_Bisector_LastBisector(self, *args)


    def BisectorNumber(self, *args):
        """
        BisectorNumber(Handle_MAT_Bisector self, Standard_Integer const anumber)
        BisectorNumber(Handle_MAT_Bisector self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Bisector_BisectorNumber(self, *args)


    def IndexNumber(self, *args):
        """
        IndexNumber(Handle_MAT_Bisector self, Standard_Integer const anumber)
        IndexNumber(Handle_MAT_Bisector self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Bisector_IndexNumber(self, *args)


    def FirstEdge(self, *args):
        """
        FirstEdge(Handle_MAT_Bisector self, Handle_MAT_Edge anedge)
        FirstEdge(Handle_MAT_Bisector self) -> Handle_MAT_Edge

        :rtype: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.Handle_MAT_Bisector_FirstEdge(self, *args)


    def SecondEdge(self, *args):
        """
        SecondEdge(Handle_MAT_Bisector self, Handle_MAT_Edge anedge)
        SecondEdge(Handle_MAT_Bisector self) -> Handle_MAT_Edge

        :rtype: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.Handle_MAT_Bisector_SecondEdge(self, *args)


    def IssuePoint(self, *args):
        """
        IssuePoint(Handle_MAT_Bisector self, Standard_Integer const apoint)
        IssuePoint(Handle_MAT_Bisector self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Bisector_IssuePoint(self, *args)


    def EndPoint(self, *args):
        """
        EndPoint(Handle_MAT_Bisector self, Standard_Integer const apoint)
        EndPoint(Handle_MAT_Bisector self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Bisector_EndPoint(self, *args)


    def DistIssuePoint(self, *args):
        """
        DistIssuePoint(Handle_MAT_Bisector self, Standard_Real const areal)
        DistIssuePoint(Handle_MAT_Bisector self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MAT.Handle_MAT_Bisector_DistIssuePoint(self, *args)


    def FirstVector(self, *args):
        """
        FirstVector(Handle_MAT_Bisector self, Standard_Integer const avector)
        FirstVector(Handle_MAT_Bisector self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Bisector_FirstVector(self, *args)


    def SecondVector(self, *args):
        """
        SecondVector(Handle_MAT_Bisector self, Standard_Integer const avector)
        SecondVector(Handle_MAT_Bisector self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Bisector_SecondVector(self, *args)


    def Sense(self, *args):
        """
        Sense(Handle_MAT_Bisector self, Standard_Real const asense)
        Sense(Handle_MAT_Bisector self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MAT.Handle_MAT_Bisector_Sense(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_MAT_Bisector self, Standard_Real const aparameter)
        FirstParameter(Handle_MAT_Bisector self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MAT.Handle_MAT_Bisector_FirstParameter(self, *args)


    def SecondParameter(self, *args):
        """
        SecondParameter(Handle_MAT_Bisector self, Standard_Real const aparameter)
        SecondParameter(Handle_MAT_Bisector self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MAT.Handle_MAT_Bisector_SecondParameter(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_MAT_Bisector self, Standard_Integer const ashift, Standard_Integer const alevel)

        :type ashift: int
        :type alevel: int

        """
        return _MAT.Handle_MAT_Bisector_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MAT_Bisector self) -> char const *

        :rtype: const char *

        """
        return _MAT.Handle_MAT_Bisector_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.Handle_MAT_Bisector_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.Handle_MAT_Bisector_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_MAT_Bisector self)

        Memory deallocator for transient classes


        """
        return _MAT.Handle_MAT_Bisector_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MAT_Bisector self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MAT_Bisector self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_Bisector_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MAT_Bisector self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MAT_Bisector self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_Bisector_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MAT_Bisector self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MAT.Handle_MAT_Bisector_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MAT_Bisector self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Bisector_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MAT_Bisector self)

        Increments the reference counter of this object


        """
        return _MAT.Handle_MAT_Bisector_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MAT_Bisector self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Bisector_DecrementRefCounter(self, *args)

Handle_MAT_Bisector_swigregister = _MAT.Handle_MAT_Bisector_swigregister
Handle_MAT_Bisector_swigregister(Handle_MAT_Bisector)

def Handle_MAT_Bisector_DownCast(thing):
    return _MAT.Handle_MAT_Bisector_DownCast(thing)
Handle_MAT_Bisector_DownCast = _MAT.Handle_MAT_Bisector_DownCast

class MAT_BasicElt(Standard.Standard_Transient):
    """
    A    BasicELt  is  associated   to  each  elemtary
    constituant of  the figure.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MAT_BasicElt
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MAT_BasicElt(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MAT_BasicElt self, Standard_Integer const anInteger) -> MAT_BasicElt

        Constructor, <anInteger> is the <index> of <me>.

        :type anInteger: int

        """
        this = _MAT.new_MAT_BasicElt(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def StartArc(self, *args):
        """
        StartArc(MAT_BasicElt self) -> Handle_MAT_Arc

        Return <startArcLeft> or <startArcRight> corresponding
        to <aSide>.

        :rtype: OCC.wrapper.MAT.Handle_MAT_Arc

        """
        return _MAT.MAT_BasicElt_StartArc(self, *args)


    def EndArc(self, *args):
        """
        EndArc(MAT_BasicElt self) -> Handle_MAT_Arc

        Return <endArcLeft> or <endArcRight> corresponding
        to <aSide>.

        :rtype: OCC.wrapper.MAT.Handle_MAT_Arc

        """
        return _MAT.MAT_BasicElt_EndArc(self, *args)


    def Index(self, *args):
        """
        Index(MAT_BasicElt self) -> Standard_Integer

        Return the <index> of <me> in Graph.TheBasicElts.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.MAT_BasicElt_Index(self, *args)


    def GeomIndex(self, *args):
        """
        GeomIndex(MAT_BasicElt self) -> Standard_Integer

        Return the <GeomIndex> of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.MAT_BasicElt_GeomIndex(self, *args)


    def SetStartArc(self, *args):
        """
        SetStartArc(MAT_BasicElt self, Handle_MAT_Arc anArc)

        :type anArc: OCC.wrapper.MAT.Handle_MAT_Arc

        """
        return _MAT.MAT_BasicElt_SetStartArc(self, *args)


    def SetEndArc(self, *args):
        """
        SetEndArc(MAT_BasicElt self, Handle_MAT_Arc anArc)

        :type anArc: OCC.wrapper.MAT.Handle_MAT_Arc

        """
        return _MAT.MAT_BasicElt_SetEndArc(self, *args)


    def SetIndex(self, *args):
        """
        SetIndex(MAT_BasicElt self, Standard_Integer const anInteger)

        :type anInteger: int

        """
        return _MAT.MAT_BasicElt_SetIndex(self, *args)


    def SetGeomIndex(self, *args):
        """
        SetGeomIndex(MAT_BasicElt self, Standard_Integer const anInteger)

        :type anInteger: int

        """
        return _MAT.MAT_BasicElt_SetGeomIndex(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MAT.MAT_BasicElt_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MAT.MAT_BasicElt_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.MAT_BasicElt_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MAT.delete_MAT_BasicElt
MAT_BasicElt_swigregister = _MAT.MAT_BasicElt_swigregister
MAT_BasicElt_swigregister(MAT_BasicElt)

def MAT_BasicElt_get_type_name(*args):
    """
    MAT_BasicElt_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MAT.MAT_BasicElt_get_type_name(*args)

def MAT_BasicElt_get_type_descriptor(*args):
    """
    MAT_BasicElt_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MAT.MAT_BasicElt_get_type_descriptor(*args)

class Handle_MAT_TListNodeOfListOfBisector(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MAT_TListNodeOfListOfBisector self)

        Nullify the handle


        """
        return _MAT.Handle_MAT_TListNodeOfListOfBisector_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MAT_TListNodeOfListOfBisector self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MAT.Handle_MAT_TListNodeOfListOfBisector_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MAT_TListNodeOfListOfBisector self, MAT_TListNodeOfListOfBisector thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MAT.Handle_MAT_TListNodeOfListOfBisector_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MAT_TListNodeOfListOfBisector self, Handle_MAT_TListNodeOfListOfBisector theHandle) -> Handle_MAT_TListNodeOfListOfBisector
        assign(Handle_MAT_TListNodeOfListOfBisector self, MAT_TListNodeOfListOfBisector thePtr) -> Handle_MAT_TListNodeOfListOfBisector
        assign(Handle_MAT_TListNodeOfListOfBisector self, Handle_MAT_TListNodeOfListOfBisector theHandle) -> Handle_MAT_TListNodeOfListOfBisector

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MAT.Handle_MAT_TListNodeOfListOfBisector_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MAT_TListNodeOfListOfBisector self) -> MAT_TListNodeOfListOfBisector

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MAT.Handle_MAT_TListNodeOfListOfBisector_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MAT_TListNodeOfListOfBisector self) -> MAT_TListNodeOfListOfBisector

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MAT.Handle_MAT_TListNodeOfListOfBisector___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MAT_TListNodeOfListOfBisector self) -> MAT_TListNodeOfListOfBisector

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MAT.Handle_MAT_TListNodeOfListOfBisector___ref__(self, *args)


    def __hash__(self):
        return _MAT.Handle_MAT_TListNodeOfListOfBisector___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MAT.Handle_MAT_TListNodeOfListOfBisector___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MAT.new_Handle_MAT_TListNodeOfListOfBisector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MAT.Handle_MAT_TListNodeOfListOfBisector_DownCast)
    __swig_destroy__ = _MAT.delete_Handle_MAT_TListNodeOfListOfBisector

    def GetItem(self, *args):
        """
        GetItem(Handle_MAT_TListNodeOfListOfBisector self) -> Handle_MAT_Bisector

        :rtype: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.Handle_MAT_TListNodeOfListOfBisector_GetItem(self, *args)


    def Next(self, *args):
        """
        Next(Handle_MAT_TListNodeOfListOfBisector self) -> Handle_MAT_TListNodeOfListOfBisector
        Next(Handle_MAT_TListNodeOfListOfBisector self, Handle_MAT_TListNodeOfListOfBisector atlistnode)

        :type atlistnode: OCC.wrapper.MAT.Handle_MAT_TListNodeOfListOfBisector

        """
        return _MAT.Handle_MAT_TListNodeOfListOfBisector_Next(self, *args)


    def Previous(self, *args):
        """
        Previous(Handle_MAT_TListNodeOfListOfBisector self) -> Handle_MAT_TListNodeOfListOfBisector
        Previous(Handle_MAT_TListNodeOfListOfBisector self, Handle_MAT_TListNodeOfListOfBisector atlistnode)

        :type atlistnode: OCC.wrapper.MAT.Handle_MAT_TListNodeOfListOfBisector

        """
        return _MAT.Handle_MAT_TListNodeOfListOfBisector_Previous(self, *args)


    def SetItem(self, *args):
        """
        SetItem(Handle_MAT_TListNodeOfListOfBisector self, Handle_MAT_Bisector anitem)

        :type anitem: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.Handle_MAT_TListNodeOfListOfBisector_SetItem(self, *args)


    def Dummy(self, *args):
        """Dummy(Handle_MAT_TListNodeOfListOfBisector self)"""
        return _MAT.Handle_MAT_TListNodeOfListOfBisector_Dummy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MAT_TListNodeOfListOfBisector self) -> char const *

        :rtype: const char *

        """
        return _MAT.Handle_MAT_TListNodeOfListOfBisector_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.Handle_MAT_TListNodeOfListOfBisector_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.Handle_MAT_TListNodeOfListOfBisector_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_MAT_TListNodeOfListOfBisector self)

        Memory deallocator for transient classes


        """
        return _MAT.Handle_MAT_TListNodeOfListOfBisector_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MAT_TListNodeOfListOfBisector self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MAT_TListNodeOfListOfBisector self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_TListNodeOfListOfBisector_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MAT_TListNodeOfListOfBisector self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MAT_TListNodeOfListOfBisector self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_TListNodeOfListOfBisector_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MAT_TListNodeOfListOfBisector self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MAT.Handle_MAT_TListNodeOfListOfBisector_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MAT_TListNodeOfListOfBisector self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_TListNodeOfListOfBisector_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MAT_TListNodeOfListOfBisector self)

        Increments the reference counter of this object


        """
        return _MAT.Handle_MAT_TListNodeOfListOfBisector_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MAT_TListNodeOfListOfBisector self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_TListNodeOfListOfBisector_DecrementRefCounter(self, *args)

Handle_MAT_TListNodeOfListOfBisector_swigregister = _MAT.Handle_MAT_TListNodeOfListOfBisector_swigregister
Handle_MAT_TListNodeOfListOfBisector_swigregister(Handle_MAT_TListNodeOfListOfBisector)

def Handle_MAT_TListNodeOfListOfBisector_DownCast(thing):
    return _MAT.Handle_MAT_TListNodeOfListOfBisector_DownCast(thing)
Handle_MAT_TListNodeOfListOfBisector_DownCast = _MAT.Handle_MAT_TListNodeOfListOfBisector_DownCast

class Handle_MAT_ListOfEdge(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MAT_ListOfEdge self)

        Nullify the handle


        """
        return _MAT.Handle_MAT_ListOfEdge_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MAT_ListOfEdge self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MAT.Handle_MAT_ListOfEdge_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MAT_ListOfEdge self, MAT_ListOfEdge thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MAT.Handle_MAT_ListOfEdge_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MAT_ListOfEdge self, Handle_MAT_ListOfEdge theHandle) -> Handle_MAT_ListOfEdge
        assign(Handle_MAT_ListOfEdge self, MAT_ListOfEdge thePtr) -> Handle_MAT_ListOfEdge
        assign(Handle_MAT_ListOfEdge self, Handle_MAT_ListOfEdge theHandle) -> Handle_MAT_ListOfEdge

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MAT.Handle_MAT_ListOfEdge_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MAT_ListOfEdge self) -> MAT_ListOfEdge

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MAT.Handle_MAT_ListOfEdge_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MAT_ListOfEdge self) -> MAT_ListOfEdge

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MAT.Handle_MAT_ListOfEdge___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MAT_ListOfEdge self) -> MAT_ListOfEdge

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MAT.Handle_MAT_ListOfEdge___ref__(self, *args)


    def __hash__(self):
        return _MAT.Handle_MAT_ListOfEdge___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MAT.Handle_MAT_ListOfEdge___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MAT.new_Handle_MAT_ListOfEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MAT.Handle_MAT_ListOfEdge_DownCast)
    __swig_destroy__ = _MAT.delete_Handle_MAT_ListOfEdge

    def First(self, *args):
        """First(Handle_MAT_ListOfEdge self)"""
        return _MAT.Handle_MAT_ListOfEdge_First(self, *args)


    def Last(self, *args):
        """Last(Handle_MAT_ListOfEdge self)"""
        return _MAT.Handle_MAT_ListOfEdge_Last(self, *args)


    def Init(self, *args):
        """
        Init(Handle_MAT_ListOfEdge self, Handle_MAT_Edge aniten)

        :type aniten: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.Handle_MAT_ListOfEdge_Init(self, *args)


    def Next(self, *args):
        """Next(Handle_MAT_ListOfEdge self)"""
        return _MAT.Handle_MAT_ListOfEdge_Next(self, *args)


    def Previous(self, *args):
        """Previous(Handle_MAT_ListOfEdge self)"""
        return _MAT.Handle_MAT_ListOfEdge_Previous(self, *args)


    def More(self, *args):
        """
        More(Handle_MAT_ListOfEdge self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_ListOfEdge_More(self, *args)


    def Current(self, *args):
        """
        Current(Handle_MAT_ListOfEdge self) -> Handle_MAT_Edge
        Current(Handle_MAT_ListOfEdge self, Handle_MAT_Edge anitem)

        :type anitem: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.Handle_MAT_ListOfEdge_Current(self, *args)


    def FirstItem(self, *args):
        """
        FirstItem(Handle_MAT_ListOfEdge self) -> Handle_MAT_Edge

        :rtype: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.Handle_MAT_ListOfEdge_FirstItem(self, *args)


    def LastItem(self, *args):
        """
        LastItem(Handle_MAT_ListOfEdge self) -> Handle_MAT_Edge

        :rtype: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.Handle_MAT_ListOfEdge_LastItem(self, *args)


    def PreviousItem(self, *args):
        """
        PreviousItem(Handle_MAT_ListOfEdge self) -> Handle_MAT_Edge

        :rtype: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.Handle_MAT_ListOfEdge_PreviousItem(self, *args)


    def NextItem(self, *args):
        """
        NextItem(Handle_MAT_ListOfEdge self) -> Handle_MAT_Edge

        :rtype: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.Handle_MAT_ListOfEdge_NextItem(self, *args)


    def Number(self, *args):
        """
        Number(Handle_MAT_ListOfEdge self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_ListOfEdge_Number(self, *args)


    def Index(self, *args):
        """
        Index(Handle_MAT_ListOfEdge self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_ListOfEdge_Index(self, *args)


    def Brackets(self, *args):
        """
        Brackets(Handle_MAT_ListOfEdge self, Standard_Integer const anindex) -> Handle_MAT_Edge

        :type anindex: int
        :rtype: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.Handle_MAT_ListOfEdge_Brackets(self, *args)


    def __call__(self, *args):
        """
        __call__(Handle_MAT_ListOfEdge self, Standard_Integer const anindex) -> Handle_MAT_Edge

        :type anindex: int
        :rtype: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.Handle_MAT_ListOfEdge___call__(self, *args)


    def Unlink(self, *args):
        """Unlink(Handle_MAT_ListOfEdge self)"""
        return _MAT.Handle_MAT_ListOfEdge_Unlink(self, *args)


    def LinkBefore(self, *args):
        """
        LinkBefore(Handle_MAT_ListOfEdge self, Handle_MAT_Edge anitem)

        :type anitem: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.Handle_MAT_ListOfEdge_LinkBefore(self, *args)


    def LinkAfter(self, *args):
        """
        LinkAfter(Handle_MAT_ListOfEdge self, Handle_MAT_Edge anitem)

        :type anitem: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.Handle_MAT_ListOfEdge_LinkAfter(self, *args)


    def FrontAdd(self, *args):
        """
        FrontAdd(Handle_MAT_ListOfEdge self, Handle_MAT_Edge anitem)

        :type anitem: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.Handle_MAT_ListOfEdge_FrontAdd(self, *args)


    def BackAdd(self, *args):
        """
        BackAdd(Handle_MAT_ListOfEdge self, Handle_MAT_Edge anitem)

        :type anitem: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.Handle_MAT_ListOfEdge_BackAdd(self, *args)


    def Permute(self, *args):
        """Permute(Handle_MAT_ListOfEdge self)"""
        return _MAT.Handle_MAT_ListOfEdge_Permute(self, *args)


    def Loop(self, *args):
        """Loop(Handle_MAT_ListOfEdge self)"""
        return _MAT.Handle_MAT_ListOfEdge_Loop(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_MAT_ListOfEdge self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_ListOfEdge_IsEmpty(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_MAT_ListOfEdge self, Standard_Integer const ashift, Standard_Integer const alevel)

        :type ashift: int
        :type alevel: int

        """
        return _MAT.Handle_MAT_ListOfEdge_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MAT_ListOfEdge self) -> char const *

        :rtype: const char *

        """
        return _MAT.Handle_MAT_ListOfEdge_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.Handle_MAT_ListOfEdge_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.Handle_MAT_ListOfEdge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_MAT_ListOfEdge self)

        Memory deallocator for transient classes


        """
        return _MAT.Handle_MAT_ListOfEdge_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MAT_ListOfEdge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MAT_ListOfEdge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_ListOfEdge_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MAT_ListOfEdge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MAT_ListOfEdge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_ListOfEdge_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MAT_ListOfEdge self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MAT.Handle_MAT_ListOfEdge_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MAT_ListOfEdge self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_ListOfEdge_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MAT_ListOfEdge self)

        Increments the reference counter of this object


        """
        return _MAT.Handle_MAT_ListOfEdge_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MAT_ListOfEdge self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_ListOfEdge_DecrementRefCounter(self, *args)

Handle_MAT_ListOfEdge_swigregister = _MAT.Handle_MAT_ListOfEdge_swigregister
Handle_MAT_ListOfEdge_swigregister(Handle_MAT_ListOfEdge)

def Handle_MAT_ListOfEdge_DownCast(thing):
    return _MAT.Handle_MAT_ListOfEdge_DownCast(thing)
Handle_MAT_ListOfEdge_DownCast = _MAT.Handle_MAT_ListOfEdge_DownCast

class MAT_ListOfBisector(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MAT_ListOfBisector
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MAT_ListOfBisector(self) 
            return h


    def __init__(self, *args):
        """__init__(MAT_ListOfBisector self) -> MAT_ListOfBisector"""
        this = _MAT.new_MAT_ListOfBisector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def First(self, *args):
        """First(MAT_ListOfBisector self)"""
        return _MAT.MAT_ListOfBisector_First(self, *args)


    def Last(self, *args):
        """Last(MAT_ListOfBisector self)"""
        return _MAT.MAT_ListOfBisector_Last(self, *args)


    def Init(self, *args):
        """
        Init(MAT_ListOfBisector self, Handle_MAT_Bisector aniten)

        :type aniten: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.MAT_ListOfBisector_Init(self, *args)


    def Next(self, *args):
        """Next(MAT_ListOfBisector self)"""
        return _MAT.MAT_ListOfBisector_Next(self, *args)


    def Previous(self, *args):
        """Previous(MAT_ListOfBisector self)"""
        return _MAT.MAT_ListOfBisector_Previous(self, *args)


    def More(self, *args):
        """
        More(MAT_ListOfBisector self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.MAT_ListOfBisector_More(self, *args)


    def Current(self, *args):
        """
        Current(MAT_ListOfBisector self) -> Handle_MAT_Bisector
        Current(MAT_ListOfBisector self, Handle_MAT_Bisector anitem)

        :type anitem: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.MAT_ListOfBisector_Current(self, *args)


    def FirstItem(self, *args):
        """
        FirstItem(MAT_ListOfBisector self) -> Handle_MAT_Bisector

        :rtype: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.MAT_ListOfBisector_FirstItem(self, *args)


    def LastItem(self, *args):
        """
        LastItem(MAT_ListOfBisector self) -> Handle_MAT_Bisector

        :rtype: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.MAT_ListOfBisector_LastItem(self, *args)


    def PreviousItem(self, *args):
        """
        PreviousItem(MAT_ListOfBisector self) -> Handle_MAT_Bisector

        :rtype: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.MAT_ListOfBisector_PreviousItem(self, *args)


    def NextItem(self, *args):
        """
        NextItem(MAT_ListOfBisector self) -> Handle_MAT_Bisector

        :rtype: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.MAT_ListOfBisector_NextItem(self, *args)


    def Number(self, *args):
        """
        Number(MAT_ListOfBisector self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.MAT_ListOfBisector_Number(self, *args)


    def Index(self, *args):
        """
        Index(MAT_ListOfBisector self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.MAT_ListOfBisector_Index(self, *args)


    def Brackets(self, *args):
        """
        Brackets(MAT_ListOfBisector self, Standard_Integer const anindex) -> Handle_MAT_Bisector

        :type anindex: int
        :rtype: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.MAT_ListOfBisector_Brackets(self, *args)


    def __call__(self, *args):
        """
        __call__(MAT_ListOfBisector self, Standard_Integer const anindex) -> Handle_MAT_Bisector

        :type anindex: int
        :rtype: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.MAT_ListOfBisector___call__(self, *args)


    def Unlink(self, *args):
        """Unlink(MAT_ListOfBisector self)"""
        return _MAT.MAT_ListOfBisector_Unlink(self, *args)


    def LinkBefore(self, *args):
        """
        LinkBefore(MAT_ListOfBisector self, Handle_MAT_Bisector anitem)

        :type anitem: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.MAT_ListOfBisector_LinkBefore(self, *args)


    def LinkAfter(self, *args):
        """
        LinkAfter(MAT_ListOfBisector self, Handle_MAT_Bisector anitem)

        :type anitem: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.MAT_ListOfBisector_LinkAfter(self, *args)


    def FrontAdd(self, *args):
        """
        FrontAdd(MAT_ListOfBisector self, Handle_MAT_Bisector anitem)

        :type anitem: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.MAT_ListOfBisector_FrontAdd(self, *args)


    def BackAdd(self, *args):
        """
        BackAdd(MAT_ListOfBisector self, Handle_MAT_Bisector anitem)

        :type anitem: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.MAT_ListOfBisector_BackAdd(self, *args)


    def Permute(self, *args):
        """Permute(MAT_ListOfBisector self)"""
        return _MAT.MAT_ListOfBisector_Permute(self, *args)


    def Loop(self, *args):
        """Loop(MAT_ListOfBisector self)"""
        return _MAT.MAT_ListOfBisector_Loop(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(MAT_ListOfBisector self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.MAT_ListOfBisector_IsEmpty(self, *args)


    def Dump(self, *args):
        """
        Dump(MAT_ListOfBisector self, Standard_Integer const ashift, Standard_Integer const alevel)

        :type ashift: int
        :type alevel: int

        """
        return _MAT.MAT_ListOfBisector_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MAT.MAT_ListOfBisector_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MAT.MAT_ListOfBisector_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.MAT_ListOfBisector_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MAT.delete_MAT_ListOfBisector
MAT_ListOfBisector_swigregister = _MAT.MAT_ListOfBisector_swigregister
MAT_ListOfBisector_swigregister(MAT_ListOfBisector)

def MAT_ListOfBisector_get_type_name(*args):
    """
    MAT_ListOfBisector_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MAT.MAT_ListOfBisector_get_type_name(*args)

def MAT_ListOfBisector_get_type_descriptor(*args):
    """
    MAT_ListOfBisector_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MAT.MAT_ListOfBisector_get_type_descriptor(*args)

class MAT_Zone(Standard.Standard_Transient):
    """
    Definition of Zone of Proximity of a BasicElt :
    ----------------------------------------------
    A Zone of proximity is the set of the points which are
    more near from the BasicElt than any other.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MAT_Zone
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MAT_Zone(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MAT_Zone self) -> MAT_Zone
        __init__(MAT_Zone self, Handle_MAT_BasicElt aBasicElt) -> MAT_Zone

        Compute the frontier of the Zone of proximity.

        :type aBasicElt: OCC.wrapper.MAT.Handle_MAT_BasicElt

        """
        this = _MAT.new_MAT_Zone(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Perform(self, *args):
        """
        Perform(MAT_Zone self, Handle_MAT_BasicElt aBasicElt)

        Compute the frontier of the Zone of proximity.

        :type aBasicElt: OCC.wrapper.MAT.Handle_MAT_BasicElt

        """
        return _MAT.MAT_Zone_Perform(self, *args)


    def NumberOfArcs(self, *args):
        """
        NumberOfArcs(MAT_Zone self) -> Standard_Integer

        Return the number Of Arcs On the frontier of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.MAT_Zone_NumberOfArcs(self, *args)


    def ArcOnFrontier(self, *args):
        """
        ArcOnFrontier(MAT_Zone self, Standard_Integer const Index) -> Handle_MAT_Arc

        Return the  Arc number <Index>  on the frontier.
        of  <me>.

        :type Index: int
        :rtype: OCC.wrapper.MAT.Handle_MAT_Arc

        """
        return _MAT.MAT_Zone_ArcOnFrontier(self, *args)


    def NoEmptyZone(self, *args):
        """
        NoEmptyZone(MAT_Zone self) -> Standard_Boolean

        Return TRUE if <me> is not empty .

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.MAT_Zone_NoEmptyZone(self, *args)


    def Limited(self, *args):
        """
        Limited(MAT_Zone self) -> Standard_Boolean

        Return TRUE if <me> is Limited.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.MAT_Zone_Limited(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MAT.MAT_Zone_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MAT.MAT_Zone_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.MAT_Zone_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MAT.delete_MAT_Zone
MAT_Zone_swigregister = _MAT.MAT_Zone_swigregister
MAT_Zone_swigregister(MAT_Zone)

def MAT_Zone_get_type_name(*args):
    """
    MAT_Zone_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MAT.MAT_Zone_get_type_name(*args)

def MAT_Zone_get_type_descriptor(*args):
    """
    MAT_Zone_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MAT.MAT_Zone_get_type_descriptor(*args)

class MAT_TListNodeOfListOfEdge(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MAT_TListNodeOfListOfEdge
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MAT_TListNodeOfListOfEdge(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MAT_TListNodeOfListOfEdge self) -> MAT_TListNodeOfListOfEdge
        __init__(MAT_TListNodeOfListOfEdge self, Handle_MAT_Edge anitem) -> MAT_TListNodeOfListOfEdge

        :type anitem: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        this = _MAT.new_MAT_TListNodeOfListOfEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetItem(self, *args):
        """
        GetItem(MAT_TListNodeOfListOfEdge self) -> Handle_MAT_Edge

        :rtype: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.MAT_TListNodeOfListOfEdge_GetItem(self, *args)


    def SetItem(self, *args):
        """
        SetItem(MAT_TListNodeOfListOfEdge self, Handle_MAT_Edge anitem)

        :type anitem: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.MAT_TListNodeOfListOfEdge_SetItem(self, *args)


    def Next(self, *args):
        """
        Next(MAT_TListNodeOfListOfEdge self) -> Handle_MAT_TListNodeOfListOfEdge
        Next(MAT_TListNodeOfListOfEdge self, Handle_MAT_TListNodeOfListOfEdge atlistnode)

        :type atlistnode: OCC.wrapper.MAT.Handle_MAT_TListNodeOfListOfEdge

        """
        return _MAT.MAT_TListNodeOfListOfEdge_Next(self, *args)


    def Previous(self, *args):
        """
        Previous(MAT_TListNodeOfListOfEdge self) -> Handle_MAT_TListNodeOfListOfEdge
        Previous(MAT_TListNodeOfListOfEdge self, Handle_MAT_TListNodeOfListOfEdge atlistnode)

        :type atlistnode: OCC.wrapper.MAT.Handle_MAT_TListNodeOfListOfEdge

        """
        return _MAT.MAT_TListNodeOfListOfEdge_Previous(self, *args)


    def Dummy(self, *args):
        """Dummy(MAT_TListNodeOfListOfEdge self)"""
        return _MAT.MAT_TListNodeOfListOfEdge_Dummy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MAT.MAT_TListNodeOfListOfEdge_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MAT.MAT_TListNodeOfListOfEdge_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.MAT_TListNodeOfListOfEdge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MAT.delete_MAT_TListNodeOfListOfEdge
MAT_TListNodeOfListOfEdge_swigregister = _MAT.MAT_TListNodeOfListOfEdge_swigregister
MAT_TListNodeOfListOfEdge_swigregister(MAT_TListNodeOfListOfEdge)

def MAT_TListNodeOfListOfEdge_get_type_name(*args):
    """
    MAT_TListNodeOfListOfEdge_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MAT.MAT_TListNodeOfListOfEdge_get_type_name(*args)

def MAT_TListNodeOfListOfEdge_get_type_descriptor(*args):
    """
    MAT_TListNodeOfListOfEdge_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MAT.MAT_TListNodeOfListOfEdge_get_type_descriptor(*args)

class Handle_MAT_Graph(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MAT_Graph self)

        Nullify the handle


        """
        return _MAT.Handle_MAT_Graph_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MAT_Graph self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MAT.Handle_MAT_Graph_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MAT_Graph self, MAT_Graph thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MAT.Handle_MAT_Graph_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MAT_Graph self, Handle_MAT_Graph theHandle) -> Handle_MAT_Graph
        assign(Handle_MAT_Graph self, MAT_Graph thePtr) -> Handle_MAT_Graph
        assign(Handle_MAT_Graph self, Handle_MAT_Graph theHandle) -> Handle_MAT_Graph

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MAT.Handle_MAT_Graph_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MAT_Graph self) -> MAT_Graph

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MAT.Handle_MAT_Graph_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MAT_Graph self) -> MAT_Graph

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MAT.Handle_MAT_Graph___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MAT_Graph self) -> MAT_Graph

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MAT.Handle_MAT_Graph___ref__(self, *args)


    def __hash__(self):
        return _MAT.Handle_MAT_Graph___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MAT.Handle_MAT_Graph___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MAT.new_Handle_MAT_Graph(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MAT.Handle_MAT_Graph_DownCast)
    __swig_destroy__ = _MAT.delete_Handle_MAT_Graph

    def Perform(self, *args):
        """
        Perform(Handle_MAT_Graph self, Standard_Boolean const SemiInfinite, Handle_MAT_ListOfBisector TheRoots, Standard_Integer const NbBasicElts, Standard_Integer const NbArcs)

        Construct <me> from the result of the method
        <CreateMat> of the class <MAT> from <MAT>.

        <SemiInfinite> : if some bisector are infinites.
        <TheRoots>     : Set of the bisectors.
        <NbBasicElts>  : Number of Basic Elements.
        <NbArcs>       : Number of Arcs = Number of Bisectors.

        :type SemiInfinite: bool
        :type TheRoots: OCC.wrapper.MAT.Handle_MAT_ListOfBisector
        :type NbBasicElts: int
        :type NbArcs: int

        """
        return _MAT.Handle_MAT_Graph_Perform(self, *args)


    def Arc(self, *args):
        """
        Arc(Handle_MAT_Graph self, Standard_Integer const Index) -> Handle_MAT_Arc

        Return the Arc of index <Index> in <theArcs>.

        :type Index: int
        :rtype: OCC.wrapper.MAT.Handle_MAT_Arc

        """
        return _MAT.Handle_MAT_Graph_Arc(self, *args)


    def BasicElt(self, *args):
        """
        BasicElt(Handle_MAT_Graph self, Standard_Integer const Index) -> Handle_MAT_BasicElt

        Return the BasicElt of index <Index> in <theBasicElts>.

        :type Index: int
        :rtype: OCC.wrapper.MAT.Handle_MAT_BasicElt

        """
        return _MAT.Handle_MAT_Graph_BasicElt(self, *args)


    def Node(self, *args):
        """
        Node(Handle_MAT_Graph self, Standard_Integer const Index) -> Handle_MAT_Node

        Return the Node of index <Index> in <theNodes>.

        :type Index: int
        :rtype: OCC.wrapper.MAT.Handle_MAT_Node

        """
        return _MAT.Handle_MAT_Graph_Node(self, *args)


    def NumberOfArcs(self, *args):
        """
        NumberOfArcs(Handle_MAT_Graph self) -> Standard_Integer

        Return the number of arcs of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Graph_NumberOfArcs(self, *args)


    def NumberOfNodes(self, *args):
        """
        NumberOfNodes(Handle_MAT_Graph self) -> Standard_Integer

        Return the number of nodes of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Graph_NumberOfNodes(self, *args)


    def NumberOfBasicElts(self, *args):
        """
        NumberOfBasicElts(Handle_MAT_Graph self) -> Standard_Integer

        Return the number of basic elements of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Graph_NumberOfBasicElts(self, *args)


    def NumberOfInfiniteNodes(self, *args):
        """
        NumberOfInfiniteNodes(Handle_MAT_Graph self) -> Standard_Integer

        Return the number of infinites nodes of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Graph_NumberOfInfiniteNodes(self, *args)


    def FusionOfBasicElts(self, *args):
        """
        FusionOfBasicElts(Handle_MAT_Graph self, Standard_Integer const IndexElt1, Standard_Integer const IndexElt2)

        Merge two BasicElts.  The End of the BasicElt Elt1
        of  IndexElt1 becomes The End of the BasicElt Elt2
        of  IndexElt2.   Elt2 is replaced in  the  arcs  by
        Elt1, Elt2 is eliminated.

        <MergeArc1> is True  if the fusion  of the BasicElts  =>
        a fusion  of two Arcs which separated  the same  elements.
        In this case <GeomIndexArc1> and  <GeomIndexArc2>  are the
        Geometric  Index of this  arcs.

        If the  BasicElt corresponds to a close line ,
        the StartArc and the EndArc of Elt1 can separate the same
        elements .
        In this case there is a fusion of this arcs, <MergeArc2>
        is true and <GeomIndexArc3> and  <GeomIndexArc4>  are the
        Geometric  Index of this  arcs.

        :type IndexElt1: int
        :type IndexElt2: int
        :type MergeArc1: bool
        :type GeomIndexArc1: int
        :type GeomIndexArc2: int
        :type MergeArc2: bool
        :type GeomIndexArc3: int
        :type GeomIndexArc4: int

        """
        return _MAT.Handle_MAT_Graph_FusionOfBasicElts(self, *args)


    def CompactArcs(self, *args):
        """CompactArcs(Handle_MAT_Graph self)"""
        return _MAT.Handle_MAT_Graph_CompactArcs(self, *args)


    def CompactNodes(self, *args):
        """CompactNodes(Handle_MAT_Graph self)"""
        return _MAT.Handle_MAT_Graph_CompactNodes(self, *args)


    def ChangeBasicElts(self, *args):
        """
        ChangeBasicElts(Handle_MAT_Graph self, NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher NewMap)

        :type NewMap: OCC.wrapper.MAT.MAT_DataMapOfIntegerBasicElt

        """
        return _MAT.Handle_MAT_Graph_ChangeBasicElts(self, *args)


    def ChangeBasicElt(self, *args):
        """
        ChangeBasicElt(Handle_MAT_Graph self, Standard_Integer const Index) -> Handle_MAT_BasicElt

        :type Index: int
        :rtype: OCC.wrapper.MAT.Handle_MAT_BasicElt

        """
        return _MAT.Handle_MAT_Graph_ChangeBasicElt(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MAT_Graph self) -> char const *

        :rtype: const char *

        """
        return _MAT.Handle_MAT_Graph_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.Handle_MAT_Graph_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.Handle_MAT_Graph_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_MAT_Graph self)

        Memory deallocator for transient classes


        """
        return _MAT.Handle_MAT_Graph_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MAT_Graph self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MAT_Graph self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_Graph_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MAT_Graph self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MAT_Graph self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_Graph_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MAT_Graph self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MAT.Handle_MAT_Graph_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MAT_Graph self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Graph_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MAT_Graph self)

        Increments the reference counter of this object


        """
        return _MAT.Handle_MAT_Graph_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MAT_Graph self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Graph_DecrementRefCounter(self, *args)

Handle_MAT_Graph_swigregister = _MAT.Handle_MAT_Graph_swigregister
Handle_MAT_Graph_swigregister(Handle_MAT_Graph)

def Handle_MAT_Graph_DownCast(thing):
    return _MAT.Handle_MAT_Graph_DownCast(thing)
Handle_MAT_Graph_DownCast = _MAT.Handle_MAT_Graph_DownCast

class Handle_MAT_Zone(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MAT_Zone self)

        Nullify the handle


        """
        return _MAT.Handle_MAT_Zone_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MAT_Zone self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MAT.Handle_MAT_Zone_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MAT_Zone self, MAT_Zone thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MAT.Handle_MAT_Zone_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MAT_Zone self, Handle_MAT_Zone theHandle) -> Handle_MAT_Zone
        assign(Handle_MAT_Zone self, MAT_Zone thePtr) -> Handle_MAT_Zone
        assign(Handle_MAT_Zone self, Handle_MAT_Zone theHandle) -> Handle_MAT_Zone

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MAT.Handle_MAT_Zone_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MAT_Zone self) -> MAT_Zone

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MAT.Handle_MAT_Zone_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MAT_Zone self) -> MAT_Zone

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MAT.Handle_MAT_Zone___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MAT_Zone self) -> MAT_Zone

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MAT.Handle_MAT_Zone___ref__(self, *args)


    def __hash__(self):
        return _MAT.Handle_MAT_Zone___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MAT.Handle_MAT_Zone___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MAT.new_Handle_MAT_Zone(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MAT.Handle_MAT_Zone_DownCast)
    __swig_destroy__ = _MAT.delete_Handle_MAT_Zone

    def Perform(self, *args):
        """
        Perform(Handle_MAT_Zone self, Handle_MAT_BasicElt aBasicElt)

        Compute the frontier of the Zone of proximity.

        :type aBasicElt: OCC.wrapper.MAT.Handle_MAT_BasicElt

        """
        return _MAT.Handle_MAT_Zone_Perform(self, *args)


    def NumberOfArcs(self, *args):
        """
        NumberOfArcs(Handle_MAT_Zone self) -> Standard_Integer

        Return the number Of Arcs On the frontier of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Zone_NumberOfArcs(self, *args)


    def ArcOnFrontier(self, *args):
        """
        ArcOnFrontier(Handle_MAT_Zone self, Standard_Integer const Index) -> Handle_MAT_Arc

        Return the  Arc number <Index>  on the frontier.
        of  <me>.

        :type Index: int
        :rtype: OCC.wrapper.MAT.Handle_MAT_Arc

        """
        return _MAT.Handle_MAT_Zone_ArcOnFrontier(self, *args)


    def NoEmptyZone(self, *args):
        """
        NoEmptyZone(Handle_MAT_Zone self) -> Standard_Boolean

        Return TRUE if <me> is not empty .

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_Zone_NoEmptyZone(self, *args)


    def Limited(self, *args):
        """
        Limited(Handle_MAT_Zone self) -> Standard_Boolean

        Return TRUE if <me> is Limited.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_Zone_Limited(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MAT_Zone self) -> char const *

        :rtype: const char *

        """
        return _MAT.Handle_MAT_Zone_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.Handle_MAT_Zone_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.Handle_MAT_Zone_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_MAT_Zone self)

        Memory deallocator for transient classes


        """
        return _MAT.Handle_MAT_Zone_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MAT_Zone self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MAT_Zone self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_Zone_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MAT_Zone self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MAT_Zone self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_Zone_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MAT_Zone self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MAT.Handle_MAT_Zone_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MAT_Zone self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Zone_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MAT_Zone self)

        Increments the reference counter of this object


        """
        return _MAT.Handle_MAT_Zone_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MAT_Zone self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Zone_DecrementRefCounter(self, *args)

Handle_MAT_Zone_swigregister = _MAT.Handle_MAT_Zone_swigregister
Handle_MAT_Zone_swigregister(Handle_MAT_Zone)

def Handle_MAT_Zone_DownCast(thing):
    return _MAT.Handle_MAT_Zone_DownCast(thing)
Handle_MAT_Zone_DownCast = _MAT.Handle_MAT_Zone_DownCast

class Handle_MAT_BasicElt(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MAT_BasicElt self)

        Nullify the handle


        """
        return _MAT.Handle_MAT_BasicElt_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MAT_BasicElt self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MAT.Handle_MAT_BasicElt_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MAT_BasicElt self, MAT_BasicElt thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MAT.Handle_MAT_BasicElt_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MAT_BasicElt self, Handle_MAT_BasicElt theHandle) -> Handle_MAT_BasicElt
        assign(Handle_MAT_BasicElt self, MAT_BasicElt thePtr) -> Handle_MAT_BasicElt
        assign(Handle_MAT_BasicElt self, Handle_MAT_BasicElt theHandle) -> Handle_MAT_BasicElt

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MAT.Handle_MAT_BasicElt_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MAT_BasicElt self) -> MAT_BasicElt

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MAT.Handle_MAT_BasicElt_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MAT_BasicElt self) -> MAT_BasicElt

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MAT.Handle_MAT_BasicElt___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MAT_BasicElt self) -> MAT_BasicElt

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MAT.Handle_MAT_BasicElt___ref__(self, *args)


    def __hash__(self):
        return _MAT.Handle_MAT_BasicElt___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MAT.Handle_MAT_BasicElt___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MAT.new_Handle_MAT_BasicElt(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MAT.Handle_MAT_BasicElt_DownCast)
    __swig_destroy__ = _MAT.delete_Handle_MAT_BasicElt

    def StartArc(self, *args):
        """
        StartArc(Handle_MAT_BasicElt self) -> Handle_MAT_Arc

        Return <startArcLeft> or <startArcRight> corresponding
        to <aSide>.

        :rtype: OCC.wrapper.MAT.Handle_MAT_Arc

        """
        return _MAT.Handle_MAT_BasicElt_StartArc(self, *args)


    def EndArc(self, *args):
        """
        EndArc(Handle_MAT_BasicElt self) -> Handle_MAT_Arc

        Return <endArcLeft> or <endArcRight> corresponding
        to <aSide>.

        :rtype: OCC.wrapper.MAT.Handle_MAT_Arc

        """
        return _MAT.Handle_MAT_BasicElt_EndArc(self, *args)


    def Index(self, *args):
        """
        Index(Handle_MAT_BasicElt self) -> Standard_Integer

        Return the <index> of <me> in Graph.TheBasicElts.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_BasicElt_Index(self, *args)


    def GeomIndex(self, *args):
        """
        GeomIndex(Handle_MAT_BasicElt self) -> Standard_Integer

        Return the <GeomIndex> of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_BasicElt_GeomIndex(self, *args)


    def SetStartArc(self, *args):
        """
        SetStartArc(Handle_MAT_BasicElt self, Handle_MAT_Arc anArc)

        :type anArc: OCC.wrapper.MAT.Handle_MAT_Arc

        """
        return _MAT.Handle_MAT_BasicElt_SetStartArc(self, *args)


    def SetEndArc(self, *args):
        """
        SetEndArc(Handle_MAT_BasicElt self, Handle_MAT_Arc anArc)

        :type anArc: OCC.wrapper.MAT.Handle_MAT_Arc

        """
        return _MAT.Handle_MAT_BasicElt_SetEndArc(self, *args)


    def SetIndex(self, *args):
        """
        SetIndex(Handle_MAT_BasicElt self, Standard_Integer const anInteger)

        :type anInteger: int

        """
        return _MAT.Handle_MAT_BasicElt_SetIndex(self, *args)


    def SetGeomIndex(self, *args):
        """
        SetGeomIndex(Handle_MAT_BasicElt self, Standard_Integer const anInteger)

        :type anInteger: int

        """
        return _MAT.Handle_MAT_BasicElt_SetGeomIndex(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MAT_BasicElt self) -> char const *

        :rtype: const char *

        """
        return _MAT.Handle_MAT_BasicElt_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.Handle_MAT_BasicElt_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.Handle_MAT_BasicElt_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_MAT_BasicElt self)

        Memory deallocator for transient classes


        """
        return _MAT.Handle_MAT_BasicElt_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MAT_BasicElt self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MAT_BasicElt self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_BasicElt_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MAT_BasicElt self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MAT_BasicElt self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_BasicElt_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MAT_BasicElt self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MAT.Handle_MAT_BasicElt_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MAT_BasicElt self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_BasicElt_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MAT_BasicElt self)

        Increments the reference counter of this object


        """
        return _MAT.Handle_MAT_BasicElt_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MAT_BasicElt self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_BasicElt_DecrementRefCounter(self, *args)

Handle_MAT_BasicElt_swigregister = _MAT.Handle_MAT_BasicElt_swigregister
Handle_MAT_BasicElt_swigregister(Handle_MAT_BasicElt)

def Handle_MAT_BasicElt_DownCast(thing):
    return _MAT.Handle_MAT_BasicElt_DownCast(thing)
Handle_MAT_BasicElt_DownCast = _MAT.Handle_MAT_BasicElt_DownCast

class MAT_Arc(Standard.Standard_Transient):
    """An Arc is associated to each Bisecting of the mat."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MAT_Arc
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MAT_Arc(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MAT_Arc self, Standard_Integer const ArcIndex, Standard_Integer const GeomIndex, Handle_MAT_BasicElt FirstElement, Handle_MAT_BasicElt SecondElement) -> MAT_Arc

        :type ArcIndex: int
        :type GeomIndex: int
        :type FirstElement: OCC.wrapper.MAT.Handle_MAT_BasicElt
        :type SecondElement: OCC.wrapper.MAT.Handle_MAT_BasicElt

        """
        this = _MAT.new_MAT_Arc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Index(self, *args):
        """
        Index(MAT_Arc self) -> Standard_Integer

        Returns the index of <me> in Graph.theArcs.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.MAT_Arc_Index(self, *args)


    def GeomIndex(self, *args):
        """
        GeomIndex(MAT_Arc self) -> Standard_Integer

        Returns  the index associated  of the  geometric
        representation of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.MAT_Arc_GeomIndex(self, *args)


    def FirstElement(self, *args):
        """
        FirstElement(MAT_Arc self) -> Handle_MAT_BasicElt

        Returns one of the BasicElt equidistant from <me>.

        :rtype: OCC.wrapper.MAT.Handle_MAT_BasicElt

        """
        return _MAT.MAT_Arc_FirstElement(self, *args)


    def SecondElement(self, *args):
        """
        SecondElement(MAT_Arc self) -> Handle_MAT_BasicElt

        Returns the other BasicElt equidistant from <me>.

        :rtype: OCC.wrapper.MAT.Handle_MAT_BasicElt

        """
        return _MAT.MAT_Arc_SecondElement(self, *args)


    def FirstNode(self, *args):
        """
        FirstNode(MAT_Arc self) -> Handle_MAT_Node

        Returns one Node extremity of <me>.

        :rtype: OCC.wrapper.MAT.Handle_MAT_Node

        """
        return _MAT.MAT_Arc_FirstNode(self, *args)


    def SecondNode(self, *args):
        """
        SecondNode(MAT_Arc self) -> Handle_MAT_Node

        Returns the other Node extremity of <me>.

        :rtype: OCC.wrapper.MAT.Handle_MAT_Node

        """
        return _MAT.MAT_Arc_SecondNode(self, *args)


    def TheOtherNode(self, *args):
        """
        TheOtherNode(MAT_Arc self, Handle_MAT_Node aNode) -> Handle_MAT_Node

        an Arc has two Node, if <aNode> egal one
        Returns the other.

        if <aNode> is not oh <me>

        :type aNode: OCC.wrapper.MAT.Handle_MAT_Node
        :rtype: OCC.wrapper.MAT.Handle_MAT_Node

        """
        return _MAT.MAT_Arc_TheOtherNode(self, *args)


    def HasNeighbour(self, *args):
        """
        HasNeighbour(MAT_Arc self, Handle_MAT_Node aNode, MAT_Side const aSide) -> Standard_Boolean

        Returnst True is there is an arc linked to
        the Node <aNode> located on the side <aSide> of <me>;
        if <aNode> is not on <me>

        :type aNode: OCC.wrapper.MAT.Handle_MAT_Node
        :type aSide: OCC.wrapper.MAT.MAT_Side
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.MAT_Arc_HasNeighbour(self, *args)


    def Neighbour(self, *args):
        """
        Neighbour(MAT_Arc self, Handle_MAT_Node aNode, MAT_Side const aSide) -> Handle_MAT_Arc

        Returns the first arc linked to the Node <aNode>
        located on the side <aSide> of <me>;
        if HasNeighbour() returns FALSE.

        :type aNode: OCC.wrapper.MAT.Handle_MAT_Node
        :type aSide: OCC.wrapper.MAT.MAT_Side
        :rtype: OCC.wrapper.MAT.Handle_MAT_Arc

        """
        return _MAT.MAT_Arc_Neighbour(self, *args)


    def SetIndex(self, *args):
        """
        SetIndex(MAT_Arc self, Standard_Integer const anInteger)

        :type anInteger: int

        """
        return _MAT.MAT_Arc_SetIndex(self, *args)


    def SetGeomIndex(self, *args):
        """
        SetGeomIndex(MAT_Arc self, Standard_Integer const anInteger)

        :type anInteger: int

        """
        return _MAT.MAT_Arc_SetGeomIndex(self, *args)


    def SetFirstElement(self, *args):
        """
        SetFirstElement(MAT_Arc self, Handle_MAT_BasicElt aBasicElt)

        :type aBasicElt: OCC.wrapper.MAT.Handle_MAT_BasicElt

        """
        return _MAT.MAT_Arc_SetFirstElement(self, *args)


    def SetSecondElement(self, *args):
        """
        SetSecondElement(MAT_Arc self, Handle_MAT_BasicElt aBasicElt)

        :type aBasicElt: OCC.wrapper.MAT.Handle_MAT_BasicElt

        """
        return _MAT.MAT_Arc_SetSecondElement(self, *args)


    def SetFirstNode(self, *args):
        """
        SetFirstNode(MAT_Arc self, Handle_MAT_Node aNode)

        :type aNode: OCC.wrapper.MAT.Handle_MAT_Node

        """
        return _MAT.MAT_Arc_SetFirstNode(self, *args)


    def SetSecondNode(self, *args):
        """
        SetSecondNode(MAT_Arc self, Handle_MAT_Node aNode)

        :type aNode: OCC.wrapper.MAT.Handle_MAT_Node

        """
        return _MAT.MAT_Arc_SetSecondNode(self, *args)


    def SetFirstArc(self, *args):
        """
        SetFirstArc(MAT_Arc self, MAT_Side const aSide, Handle_MAT_Arc anArc)

        :type aSide: OCC.wrapper.MAT.MAT_Side
        :type anArc: OCC.wrapper.MAT.Handle_MAT_Arc

        """
        return _MAT.MAT_Arc_SetFirstArc(self, *args)


    def SetSecondArc(self, *args):
        """
        SetSecondArc(MAT_Arc self, MAT_Side const aSide, Handle_MAT_Arc anArc)

        :type aSide: OCC.wrapper.MAT.MAT_Side
        :type anArc: OCC.wrapper.MAT.Handle_MAT_Arc

        """
        return _MAT.MAT_Arc_SetSecondArc(self, *args)


    def SetNeighbour(self, *args):
        """
        SetNeighbour(MAT_Arc self, MAT_Side const aSide, Handle_MAT_Node aNode, Handle_MAT_Arc anArc)

        :type aSide: OCC.wrapper.MAT.MAT_Side
        :type aNode: OCC.wrapper.MAT.Handle_MAT_Node
        :type anArc: OCC.wrapper.MAT.Handle_MAT_Arc

        """
        return _MAT.MAT_Arc_SetNeighbour(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MAT.MAT_Arc_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MAT.MAT_Arc_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.MAT_Arc_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MAT.delete_MAT_Arc
MAT_Arc_swigregister = _MAT.MAT_Arc_swigregister
MAT_Arc_swigregister(MAT_Arc)

def MAT_Arc_get_type_name(*args):
    """
    MAT_Arc_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MAT.MAT_Arc_get_type_name(*args)

def MAT_Arc_get_type_descriptor(*args):
    """
    MAT_Arc_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MAT.MAT_Arc_get_type_descriptor(*args)

class Handle_MAT_ListOfBisector(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MAT_ListOfBisector self)

        Nullify the handle


        """
        return _MAT.Handle_MAT_ListOfBisector_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MAT_ListOfBisector self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MAT.Handle_MAT_ListOfBisector_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MAT_ListOfBisector self, MAT_ListOfBisector thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MAT.Handle_MAT_ListOfBisector_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MAT_ListOfBisector self, Handle_MAT_ListOfBisector theHandle) -> Handle_MAT_ListOfBisector
        assign(Handle_MAT_ListOfBisector self, MAT_ListOfBisector thePtr) -> Handle_MAT_ListOfBisector
        assign(Handle_MAT_ListOfBisector self, Handle_MAT_ListOfBisector theHandle) -> Handle_MAT_ListOfBisector

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MAT.Handle_MAT_ListOfBisector_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MAT_ListOfBisector self) -> MAT_ListOfBisector

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MAT.Handle_MAT_ListOfBisector_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MAT_ListOfBisector self) -> MAT_ListOfBisector

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MAT.Handle_MAT_ListOfBisector___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MAT_ListOfBisector self) -> MAT_ListOfBisector

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MAT.Handle_MAT_ListOfBisector___ref__(self, *args)


    def __hash__(self):
        return _MAT.Handle_MAT_ListOfBisector___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MAT.Handle_MAT_ListOfBisector___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MAT.new_Handle_MAT_ListOfBisector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MAT.Handle_MAT_ListOfBisector_DownCast)
    __swig_destroy__ = _MAT.delete_Handle_MAT_ListOfBisector

    def First(self, *args):
        """First(Handle_MAT_ListOfBisector self)"""
        return _MAT.Handle_MAT_ListOfBisector_First(self, *args)


    def Last(self, *args):
        """Last(Handle_MAT_ListOfBisector self)"""
        return _MAT.Handle_MAT_ListOfBisector_Last(self, *args)


    def Init(self, *args):
        """
        Init(Handle_MAT_ListOfBisector self, Handle_MAT_Bisector aniten)

        :type aniten: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.Handle_MAT_ListOfBisector_Init(self, *args)


    def Next(self, *args):
        """Next(Handle_MAT_ListOfBisector self)"""
        return _MAT.Handle_MAT_ListOfBisector_Next(self, *args)


    def Previous(self, *args):
        """Previous(Handle_MAT_ListOfBisector self)"""
        return _MAT.Handle_MAT_ListOfBisector_Previous(self, *args)


    def More(self, *args):
        """
        More(Handle_MAT_ListOfBisector self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_ListOfBisector_More(self, *args)


    def Current(self, *args):
        """
        Current(Handle_MAT_ListOfBisector self) -> Handle_MAT_Bisector
        Current(Handle_MAT_ListOfBisector self, Handle_MAT_Bisector anitem)

        :type anitem: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.Handle_MAT_ListOfBisector_Current(self, *args)


    def FirstItem(self, *args):
        """
        FirstItem(Handle_MAT_ListOfBisector self) -> Handle_MAT_Bisector

        :rtype: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.Handle_MAT_ListOfBisector_FirstItem(self, *args)


    def LastItem(self, *args):
        """
        LastItem(Handle_MAT_ListOfBisector self) -> Handle_MAT_Bisector

        :rtype: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.Handle_MAT_ListOfBisector_LastItem(self, *args)


    def PreviousItem(self, *args):
        """
        PreviousItem(Handle_MAT_ListOfBisector self) -> Handle_MAT_Bisector

        :rtype: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.Handle_MAT_ListOfBisector_PreviousItem(self, *args)


    def NextItem(self, *args):
        """
        NextItem(Handle_MAT_ListOfBisector self) -> Handle_MAT_Bisector

        :rtype: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.Handle_MAT_ListOfBisector_NextItem(self, *args)


    def Number(self, *args):
        """
        Number(Handle_MAT_ListOfBisector self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_ListOfBisector_Number(self, *args)


    def Index(self, *args):
        """
        Index(Handle_MAT_ListOfBisector self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_ListOfBisector_Index(self, *args)


    def Brackets(self, *args):
        """
        Brackets(Handle_MAT_ListOfBisector self, Standard_Integer const anindex) -> Handle_MAT_Bisector

        :type anindex: int
        :rtype: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.Handle_MAT_ListOfBisector_Brackets(self, *args)


    def __call__(self, *args):
        """
        __call__(Handle_MAT_ListOfBisector self, Standard_Integer const anindex) -> Handle_MAT_Bisector

        :type anindex: int
        :rtype: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.Handle_MAT_ListOfBisector___call__(self, *args)


    def Unlink(self, *args):
        """Unlink(Handle_MAT_ListOfBisector self)"""
        return _MAT.Handle_MAT_ListOfBisector_Unlink(self, *args)


    def LinkBefore(self, *args):
        """
        LinkBefore(Handle_MAT_ListOfBisector self, Handle_MAT_Bisector anitem)

        :type anitem: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.Handle_MAT_ListOfBisector_LinkBefore(self, *args)


    def LinkAfter(self, *args):
        """
        LinkAfter(Handle_MAT_ListOfBisector self, Handle_MAT_Bisector anitem)

        :type anitem: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.Handle_MAT_ListOfBisector_LinkAfter(self, *args)


    def FrontAdd(self, *args):
        """
        FrontAdd(Handle_MAT_ListOfBisector self, Handle_MAT_Bisector anitem)

        :type anitem: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.Handle_MAT_ListOfBisector_FrontAdd(self, *args)


    def BackAdd(self, *args):
        """
        BackAdd(Handle_MAT_ListOfBisector self, Handle_MAT_Bisector anitem)

        :type anitem: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.Handle_MAT_ListOfBisector_BackAdd(self, *args)


    def Permute(self, *args):
        """Permute(Handle_MAT_ListOfBisector self)"""
        return _MAT.Handle_MAT_ListOfBisector_Permute(self, *args)


    def Loop(self, *args):
        """Loop(Handle_MAT_ListOfBisector self)"""
        return _MAT.Handle_MAT_ListOfBisector_Loop(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_MAT_ListOfBisector self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_ListOfBisector_IsEmpty(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_MAT_ListOfBisector self, Standard_Integer const ashift, Standard_Integer const alevel)

        :type ashift: int
        :type alevel: int

        """
        return _MAT.Handle_MAT_ListOfBisector_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MAT_ListOfBisector self) -> char const *

        :rtype: const char *

        """
        return _MAT.Handle_MAT_ListOfBisector_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.Handle_MAT_ListOfBisector_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.Handle_MAT_ListOfBisector_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_MAT_ListOfBisector self)

        Memory deallocator for transient classes


        """
        return _MAT.Handle_MAT_ListOfBisector_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MAT_ListOfBisector self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MAT_ListOfBisector self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_ListOfBisector_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MAT_ListOfBisector self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MAT_ListOfBisector self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_ListOfBisector_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MAT_ListOfBisector self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MAT.Handle_MAT_ListOfBisector_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MAT_ListOfBisector self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_ListOfBisector_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MAT_ListOfBisector self)

        Increments the reference counter of this object


        """
        return _MAT.Handle_MAT_ListOfBisector_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MAT_ListOfBisector self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_ListOfBisector_DecrementRefCounter(self, *args)

Handle_MAT_ListOfBisector_swigregister = _MAT.Handle_MAT_ListOfBisector_swigregister
Handle_MAT_ListOfBisector_swigregister(Handle_MAT_ListOfBisector)

def Handle_MAT_ListOfBisector_DownCast(thing):
    return _MAT.Handle_MAT_ListOfBisector_DownCast(thing)
Handle_MAT_ListOfBisector_DownCast = _MAT.Handle_MAT_ListOfBisector_DownCast

class NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< MAT_BasicElt >,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< MAT_BasicElt >,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< MAT_BasicElt >,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< MAT_BasicElt >,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _MAT.new_NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher self, int const & theKey, Handle_MAT_BasicElt theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher self, int const & theKey, Handle_MAT_BasicElt theItem) -> Handle_MAT_BasicElt

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_MAT_BasicElt

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_MAT_BasicElt

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_MAT_BasicElt

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _MAT.delete_NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_swigregister = _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _MAT.new_NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MAT.delete_NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher_IteratorHelper)


try:
	MAT_DataMapOfIntegerBasicElt = NCollection_DataMap_Standard_Integer_Handle_MAT_BasicElt_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_MAT_Arc(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MAT_Arc self)

        Nullify the handle


        """
        return _MAT.Handle_MAT_Arc_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MAT_Arc self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MAT.Handle_MAT_Arc_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MAT_Arc self, MAT_Arc thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MAT.Handle_MAT_Arc_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MAT_Arc self, Handle_MAT_Arc theHandle) -> Handle_MAT_Arc
        assign(Handle_MAT_Arc self, MAT_Arc thePtr) -> Handle_MAT_Arc
        assign(Handle_MAT_Arc self, Handle_MAT_Arc theHandle) -> Handle_MAT_Arc

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MAT.Handle_MAT_Arc_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MAT_Arc self) -> MAT_Arc

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MAT.Handle_MAT_Arc_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MAT_Arc self) -> MAT_Arc

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MAT.Handle_MAT_Arc___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MAT_Arc self) -> MAT_Arc

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MAT.Handle_MAT_Arc___ref__(self, *args)


    def __hash__(self):
        return _MAT.Handle_MAT_Arc___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MAT.Handle_MAT_Arc___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MAT.new_Handle_MAT_Arc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MAT.Handle_MAT_Arc_DownCast)
    __swig_destroy__ = _MAT.delete_Handle_MAT_Arc

    def Index(self, *args):
        """
        Index(Handle_MAT_Arc self) -> Standard_Integer

        Returns the index of <me> in Graph.theArcs.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Arc_Index(self, *args)


    def GeomIndex(self, *args):
        """
        GeomIndex(Handle_MAT_Arc self) -> Standard_Integer

        Returns  the index associated  of the  geometric
        representation of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Arc_GeomIndex(self, *args)


    def FirstElement(self, *args):
        """
        FirstElement(Handle_MAT_Arc self) -> Handle_MAT_BasicElt

        Returns one of the BasicElt equidistant from <me>.

        :rtype: OCC.wrapper.MAT.Handle_MAT_BasicElt

        """
        return _MAT.Handle_MAT_Arc_FirstElement(self, *args)


    def SecondElement(self, *args):
        """
        SecondElement(Handle_MAT_Arc self) -> Handle_MAT_BasicElt

        Returns the other BasicElt equidistant from <me>.

        :rtype: OCC.wrapper.MAT.Handle_MAT_BasicElt

        """
        return _MAT.Handle_MAT_Arc_SecondElement(self, *args)


    def FirstNode(self, *args):
        """
        FirstNode(Handle_MAT_Arc self) -> Handle_MAT_Node

        Returns one Node extremity of <me>.

        :rtype: OCC.wrapper.MAT.Handle_MAT_Node

        """
        return _MAT.Handle_MAT_Arc_FirstNode(self, *args)


    def SecondNode(self, *args):
        """
        SecondNode(Handle_MAT_Arc self) -> Handle_MAT_Node

        Returns the other Node extremity of <me>.

        :rtype: OCC.wrapper.MAT.Handle_MAT_Node

        """
        return _MAT.Handle_MAT_Arc_SecondNode(self, *args)


    def TheOtherNode(self, *args):
        """
        TheOtherNode(Handle_MAT_Arc self, Handle_MAT_Node aNode) -> Handle_MAT_Node

        an Arc has two Node, if <aNode> egal one
        Returns the other.

        if <aNode> is not oh <me>

        :type aNode: OCC.wrapper.MAT.Handle_MAT_Node
        :rtype: OCC.wrapper.MAT.Handle_MAT_Node

        """
        return _MAT.Handle_MAT_Arc_TheOtherNode(self, *args)


    def HasNeighbour(self, *args):
        """
        HasNeighbour(Handle_MAT_Arc self, Handle_MAT_Node aNode, MAT_Side const aSide) -> Standard_Boolean

        Returnst True is there is an arc linked to
        the Node <aNode> located on the side <aSide> of <me>;
        if <aNode> is not on <me>

        :type aNode: OCC.wrapper.MAT.Handle_MAT_Node
        :type aSide: OCC.wrapper.MAT.MAT_Side
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_Arc_HasNeighbour(self, *args)


    def Neighbour(self, *args):
        """
        Neighbour(Handle_MAT_Arc self, Handle_MAT_Node aNode, MAT_Side const aSide) -> Handle_MAT_Arc

        Returns the first arc linked to the Node <aNode>
        located on the side <aSide> of <me>;
        if HasNeighbour() returns FALSE.

        :type aNode: OCC.wrapper.MAT.Handle_MAT_Node
        :type aSide: OCC.wrapper.MAT.MAT_Side
        :rtype: OCC.wrapper.MAT.Handle_MAT_Arc

        """
        return _MAT.Handle_MAT_Arc_Neighbour(self, *args)


    def SetIndex(self, *args):
        """
        SetIndex(Handle_MAT_Arc self, Standard_Integer const anInteger)

        :type anInteger: int

        """
        return _MAT.Handle_MAT_Arc_SetIndex(self, *args)


    def SetGeomIndex(self, *args):
        """
        SetGeomIndex(Handle_MAT_Arc self, Standard_Integer const anInteger)

        :type anInteger: int

        """
        return _MAT.Handle_MAT_Arc_SetGeomIndex(self, *args)


    def SetFirstElement(self, *args):
        """
        SetFirstElement(Handle_MAT_Arc self, Handle_MAT_BasicElt aBasicElt)

        :type aBasicElt: OCC.wrapper.MAT.Handle_MAT_BasicElt

        """
        return _MAT.Handle_MAT_Arc_SetFirstElement(self, *args)


    def SetSecondElement(self, *args):
        """
        SetSecondElement(Handle_MAT_Arc self, Handle_MAT_BasicElt aBasicElt)

        :type aBasicElt: OCC.wrapper.MAT.Handle_MAT_BasicElt

        """
        return _MAT.Handle_MAT_Arc_SetSecondElement(self, *args)


    def SetFirstNode(self, *args):
        """
        SetFirstNode(Handle_MAT_Arc self, Handle_MAT_Node aNode)

        :type aNode: OCC.wrapper.MAT.Handle_MAT_Node

        """
        return _MAT.Handle_MAT_Arc_SetFirstNode(self, *args)


    def SetSecondNode(self, *args):
        """
        SetSecondNode(Handle_MAT_Arc self, Handle_MAT_Node aNode)

        :type aNode: OCC.wrapper.MAT.Handle_MAT_Node

        """
        return _MAT.Handle_MAT_Arc_SetSecondNode(self, *args)


    def SetFirstArc(self, *args):
        """
        SetFirstArc(Handle_MAT_Arc self, MAT_Side const aSide, Handle_MAT_Arc anArc)

        :type aSide: OCC.wrapper.MAT.MAT_Side
        :type anArc: OCC.wrapper.MAT.Handle_MAT_Arc

        """
        return _MAT.Handle_MAT_Arc_SetFirstArc(self, *args)


    def SetSecondArc(self, *args):
        """
        SetSecondArc(Handle_MAT_Arc self, MAT_Side const aSide, Handle_MAT_Arc anArc)

        :type aSide: OCC.wrapper.MAT.MAT_Side
        :type anArc: OCC.wrapper.MAT.Handle_MAT_Arc

        """
        return _MAT.Handle_MAT_Arc_SetSecondArc(self, *args)


    def SetNeighbour(self, *args):
        """
        SetNeighbour(Handle_MAT_Arc self, MAT_Side const aSide, Handle_MAT_Node aNode, Handle_MAT_Arc anArc)

        :type aSide: OCC.wrapper.MAT.MAT_Side
        :type aNode: OCC.wrapper.MAT.Handle_MAT_Node
        :type anArc: OCC.wrapper.MAT.Handle_MAT_Arc

        """
        return _MAT.Handle_MAT_Arc_SetNeighbour(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MAT_Arc self) -> char const *

        :rtype: const char *

        """
        return _MAT.Handle_MAT_Arc_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.Handle_MAT_Arc_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.Handle_MAT_Arc_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_MAT_Arc self)

        Memory deallocator for transient classes


        """
        return _MAT.Handle_MAT_Arc_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MAT_Arc self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MAT_Arc self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_Arc_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MAT_Arc self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MAT_Arc self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_Arc_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MAT_Arc self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MAT.Handle_MAT_Arc_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MAT_Arc self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Arc_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MAT_Arc self)

        Increments the reference counter of this object


        """
        return _MAT.Handle_MAT_Arc_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MAT_Arc self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Arc_DecrementRefCounter(self, *args)

Handle_MAT_Arc_swigregister = _MAT.Handle_MAT_Arc_swigregister
Handle_MAT_Arc_swigregister(Handle_MAT_Arc)

def Handle_MAT_Arc_DownCast(thing):
    return _MAT.Handle_MAT_Arc_DownCast(thing)
Handle_MAT_Arc_DownCast = _MAT.Handle_MAT_Arc_DownCast

class Handle_MAT_TListNodeOfListOfEdge(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MAT_TListNodeOfListOfEdge self)

        Nullify the handle


        """
        return _MAT.Handle_MAT_TListNodeOfListOfEdge_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MAT_TListNodeOfListOfEdge self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MAT.Handle_MAT_TListNodeOfListOfEdge_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MAT_TListNodeOfListOfEdge self, MAT_TListNodeOfListOfEdge thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MAT.Handle_MAT_TListNodeOfListOfEdge_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MAT_TListNodeOfListOfEdge self, Handle_MAT_TListNodeOfListOfEdge theHandle) -> Handle_MAT_TListNodeOfListOfEdge
        assign(Handle_MAT_TListNodeOfListOfEdge self, MAT_TListNodeOfListOfEdge thePtr) -> Handle_MAT_TListNodeOfListOfEdge
        assign(Handle_MAT_TListNodeOfListOfEdge self, Handle_MAT_TListNodeOfListOfEdge theHandle) -> Handle_MAT_TListNodeOfListOfEdge

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MAT.Handle_MAT_TListNodeOfListOfEdge_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MAT_TListNodeOfListOfEdge self) -> MAT_TListNodeOfListOfEdge

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MAT.Handle_MAT_TListNodeOfListOfEdge_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MAT_TListNodeOfListOfEdge self) -> MAT_TListNodeOfListOfEdge

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MAT.Handle_MAT_TListNodeOfListOfEdge___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MAT_TListNodeOfListOfEdge self) -> MAT_TListNodeOfListOfEdge

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MAT.Handle_MAT_TListNodeOfListOfEdge___ref__(self, *args)


    def __hash__(self):
        return _MAT.Handle_MAT_TListNodeOfListOfEdge___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MAT.Handle_MAT_TListNodeOfListOfEdge___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MAT.new_Handle_MAT_TListNodeOfListOfEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MAT.Handle_MAT_TListNodeOfListOfEdge_DownCast)
    __swig_destroy__ = _MAT.delete_Handle_MAT_TListNodeOfListOfEdge

    def GetItem(self, *args):
        """
        GetItem(Handle_MAT_TListNodeOfListOfEdge self) -> Handle_MAT_Edge

        :rtype: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.Handle_MAT_TListNodeOfListOfEdge_GetItem(self, *args)


    def Next(self, *args):
        """
        Next(Handle_MAT_TListNodeOfListOfEdge self) -> Handle_MAT_TListNodeOfListOfEdge
        Next(Handle_MAT_TListNodeOfListOfEdge self, Handle_MAT_TListNodeOfListOfEdge atlistnode)

        :type atlistnode: OCC.wrapper.MAT.Handle_MAT_TListNodeOfListOfEdge

        """
        return _MAT.Handle_MAT_TListNodeOfListOfEdge_Next(self, *args)


    def Previous(self, *args):
        """
        Previous(Handle_MAT_TListNodeOfListOfEdge self) -> Handle_MAT_TListNodeOfListOfEdge
        Previous(Handle_MAT_TListNodeOfListOfEdge self, Handle_MAT_TListNodeOfListOfEdge atlistnode)

        :type atlistnode: OCC.wrapper.MAT.Handle_MAT_TListNodeOfListOfEdge

        """
        return _MAT.Handle_MAT_TListNodeOfListOfEdge_Previous(self, *args)


    def SetItem(self, *args):
        """
        SetItem(Handle_MAT_TListNodeOfListOfEdge self, Handle_MAT_Edge anitem)

        :type anitem: OCC.wrapper.MAT.Handle_MAT_Edge

        """
        return _MAT.Handle_MAT_TListNodeOfListOfEdge_SetItem(self, *args)


    def Dummy(self, *args):
        """Dummy(Handle_MAT_TListNodeOfListOfEdge self)"""
        return _MAT.Handle_MAT_TListNodeOfListOfEdge_Dummy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MAT_TListNodeOfListOfEdge self) -> char const *

        :rtype: const char *

        """
        return _MAT.Handle_MAT_TListNodeOfListOfEdge_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.Handle_MAT_TListNodeOfListOfEdge_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.Handle_MAT_TListNodeOfListOfEdge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_MAT_TListNodeOfListOfEdge self)

        Memory deallocator for transient classes


        """
        return _MAT.Handle_MAT_TListNodeOfListOfEdge_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MAT_TListNodeOfListOfEdge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MAT_TListNodeOfListOfEdge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_TListNodeOfListOfEdge_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MAT_TListNodeOfListOfEdge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MAT_TListNodeOfListOfEdge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_TListNodeOfListOfEdge_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MAT_TListNodeOfListOfEdge self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MAT.Handle_MAT_TListNodeOfListOfEdge_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MAT_TListNodeOfListOfEdge self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_TListNodeOfListOfEdge_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MAT_TListNodeOfListOfEdge self)

        Increments the reference counter of this object


        """
        return _MAT.Handle_MAT_TListNodeOfListOfEdge_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MAT_TListNodeOfListOfEdge self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_TListNodeOfListOfEdge_DecrementRefCounter(self, *args)

Handle_MAT_TListNodeOfListOfEdge_swigregister = _MAT.Handle_MAT_TListNodeOfListOfEdge_swigregister
Handle_MAT_TListNodeOfListOfEdge_swigregister(Handle_MAT_TListNodeOfListOfEdge)

def Handle_MAT_TListNodeOfListOfEdge_DownCast(thing):
    return _MAT.Handle_MAT_TListNodeOfListOfEdge_DownCast(thing)
Handle_MAT_TListNodeOfListOfEdge_DownCast = _MAT.Handle_MAT_TListNodeOfListOfEdge_DownCast

class MAT_Node(Standard.Standard_Transient):
    """Node of Graph."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MAT_Node
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MAT_Node(self) 
            return h


    def __init__(self, *args):
        """
        __init__(MAT_Node self, Standard_Integer const GeomIndex, Handle_MAT_Arc LinkedArc, Standard_Real const Distance) -> MAT_Node

        :type GeomIndex: int
        :type LinkedArc: OCC.wrapper.MAT.Handle_MAT_Arc
        :type Distance: float

        """
        this = _MAT.new_MAT_Node(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GeomIndex(self, *args):
        """
        GeomIndex(MAT_Node self) -> Standard_Integer

        Returns the index associated of the geometric
        representation of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.MAT_Node_GeomIndex(self, *args)


    def Index(self, *args):
        """
        Index(MAT_Node self) -> Standard_Integer

        Returns the index associated of the node

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.MAT_Node_Index(self, *args)


    def LinkedArcs(self, *args):
        """
        LinkedArcs(MAT_Node self, NCollection_Sequence_Handle_MAT_Arc S)

        Returns in <S> the Arcs linked to <me>.

        :type S: OCC.wrapper.MAT.MAT_SequenceOfArc

        """
        return _MAT.MAT_Node_LinkedArcs(self, *args)


    def NearElts(self, *args):
        """
        NearElts(MAT_Node self, NCollection_Sequence_Handle_MAT_BasicElt S)

        Returns  in <S> the BasicElts equidistant
        to <me>.

        :type S: OCC.wrapper.MAT.MAT_SequenceOfBasicElt

        """
        return _MAT.MAT_Node_NearElts(self, *args)


    def Distance(self, *args):
        """
        Distance(MAT_Node self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MAT.MAT_Node_Distance(self, *args)


    def PendingNode(self, *args):
        """
        PendingNode(MAT_Node self) -> Standard_Boolean

        Returns True if <me> is a pending Node.
        (ie : the number of Arc Linked = 1)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.MAT_Node_PendingNode(self, *args)


    def OnBasicElt(self, *args):
        """
        OnBasicElt(MAT_Node self) -> Standard_Boolean

        Returns True if <me> belongs to the figure.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.MAT_Node_OnBasicElt(self, *args)


    def Infinite(self, *args):
        """
        Infinite(MAT_Node self) -> Standard_Boolean

        Returns True if the distance of <me> is Infinite

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.MAT_Node_Infinite(self, *args)


    def SetIndex(self, *args):
        """
        SetIndex(MAT_Node self, Standard_Integer const anIndex)

        Set the index associated of the node

        :type anIndex: int

        """
        return _MAT.MAT_Node_SetIndex(self, *args)


    def SetLinkedArc(self, *args):
        """
        SetLinkedArc(MAT_Node self, Handle_MAT_Arc anArc)

        :type anArc: OCC.wrapper.MAT.Handle_MAT_Arc

        """
        return _MAT.MAT_Node_SetLinkedArc(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MAT.MAT_Node_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MAT.MAT_Node_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.MAT_Node_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MAT.delete_MAT_Node
MAT_Node_swigregister = _MAT.MAT_Node_swigregister
MAT_Node_swigregister(MAT_Node)

def MAT_Node_get_type_name(*args):
    """
    MAT_Node_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MAT.MAT_Node_get_type_name(*args)

def MAT_Node_get_type_descriptor(*args):
    """
    MAT_Node_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MAT.MAT_Node_get_type_descriptor(*args)

class MAT_Edge(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_MAT_Edge
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_MAT_Edge(self) 
            return h


    def __init__(self, *args):
        """__init__(MAT_Edge self) -> MAT_Edge"""
        this = _MAT.new_MAT_Edge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def EdgeNumber(self, *args):
        """
        EdgeNumber(MAT_Edge self, Standard_Integer const anumber)
        EdgeNumber(MAT_Edge self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.MAT_Edge_EdgeNumber(self, *args)


    def FirstBisector(self, *args):
        """
        FirstBisector(MAT_Edge self, Handle_MAT_Bisector abisector)
        FirstBisector(MAT_Edge self) -> Handle_MAT_Bisector

        :rtype: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.MAT_Edge_FirstBisector(self, *args)


    def SecondBisector(self, *args):
        """
        SecondBisector(MAT_Edge self, Handle_MAT_Bisector abisector)
        SecondBisector(MAT_Edge self) -> Handle_MAT_Bisector

        :rtype: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.MAT_Edge_SecondBisector(self, *args)


    def Distance(self, *args):
        """
        Distance(MAT_Edge self, Standard_Real const adistance)
        Distance(MAT_Edge self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MAT.MAT_Edge_Distance(self, *args)


    def IntersectionPoint(self, *args):
        """
        IntersectionPoint(MAT_Edge self, Standard_Integer const apoint)
        IntersectionPoint(MAT_Edge self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.MAT_Edge_IntersectionPoint(self, *args)


    def Dump(self, *args):
        """
        Dump(MAT_Edge self, Standard_Integer const ashift, Standard_Integer const alevel)

        :type ashift: int
        :type alevel: int

        """
        return _MAT.MAT_Edge_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _MAT.MAT_Edge_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _MAT.MAT_Edge_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.MAT_Edge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _MAT.delete_MAT_Edge
MAT_Edge_swigregister = _MAT.MAT_Edge_swigregister
MAT_Edge_swigregister(MAT_Edge)

def MAT_Edge_get_type_name(*args):
    """
    MAT_Edge_get_type_name() -> char const *

    :rtype: const char *

    """
    return _MAT.MAT_Edge_get_type_name(*args)

def MAT_Edge_get_type_descriptor(*args):
    """
    MAT_Edge_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _MAT.MAT_Edge_get_type_descriptor(*args)

class Handle_MAT_Edge(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MAT_Edge self)

        Nullify the handle


        """
        return _MAT.Handle_MAT_Edge_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MAT_Edge self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MAT.Handle_MAT_Edge_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MAT_Edge self, MAT_Edge thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MAT.Handle_MAT_Edge_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MAT_Edge self, Handle_MAT_Edge theHandle) -> Handle_MAT_Edge
        assign(Handle_MAT_Edge self, MAT_Edge thePtr) -> Handle_MAT_Edge
        assign(Handle_MAT_Edge self, Handle_MAT_Edge theHandle) -> Handle_MAT_Edge

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MAT.Handle_MAT_Edge_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MAT_Edge self) -> MAT_Edge

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MAT.Handle_MAT_Edge_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MAT_Edge self) -> MAT_Edge

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MAT.Handle_MAT_Edge___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MAT_Edge self) -> MAT_Edge

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MAT.Handle_MAT_Edge___ref__(self, *args)


    def __hash__(self):
        return _MAT.Handle_MAT_Edge___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MAT.Handle_MAT_Edge___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MAT.new_Handle_MAT_Edge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MAT.Handle_MAT_Edge_DownCast)
    __swig_destroy__ = _MAT.delete_Handle_MAT_Edge

    def EdgeNumber(self, *args):
        """
        EdgeNumber(Handle_MAT_Edge self, Standard_Integer const anumber)
        EdgeNumber(Handle_MAT_Edge self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Edge_EdgeNumber(self, *args)


    def FirstBisector(self, *args):
        """
        FirstBisector(Handle_MAT_Edge self, Handle_MAT_Bisector abisector)
        FirstBisector(Handle_MAT_Edge self) -> Handle_MAT_Bisector

        :rtype: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.Handle_MAT_Edge_FirstBisector(self, *args)


    def SecondBisector(self, *args):
        """
        SecondBisector(Handle_MAT_Edge self, Handle_MAT_Bisector abisector)
        SecondBisector(Handle_MAT_Edge self) -> Handle_MAT_Bisector

        :rtype: OCC.wrapper.MAT.Handle_MAT_Bisector

        """
        return _MAT.Handle_MAT_Edge_SecondBisector(self, *args)


    def Distance(self, *args):
        """
        Distance(Handle_MAT_Edge self, Standard_Real const adistance)
        Distance(Handle_MAT_Edge self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MAT.Handle_MAT_Edge_Distance(self, *args)


    def IntersectionPoint(self, *args):
        """
        IntersectionPoint(Handle_MAT_Edge self, Standard_Integer const apoint)
        IntersectionPoint(Handle_MAT_Edge self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Edge_IntersectionPoint(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_MAT_Edge self, Standard_Integer const ashift, Standard_Integer const alevel)

        :type ashift: int
        :type alevel: int

        """
        return _MAT.Handle_MAT_Edge_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MAT_Edge self) -> char const *

        :rtype: const char *

        """
        return _MAT.Handle_MAT_Edge_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.Handle_MAT_Edge_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.Handle_MAT_Edge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_MAT_Edge self)

        Memory deallocator for transient classes


        """
        return _MAT.Handle_MAT_Edge_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MAT_Edge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MAT_Edge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_Edge_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MAT_Edge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MAT_Edge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_Edge_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MAT_Edge self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MAT.Handle_MAT_Edge_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MAT_Edge self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Edge_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MAT_Edge self)

        Increments the reference counter of this object


        """
        return _MAT.Handle_MAT_Edge_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MAT_Edge self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Edge_DecrementRefCounter(self, *args)

Handle_MAT_Edge_swigregister = _MAT.Handle_MAT_Edge_swigregister
Handle_MAT_Edge_swigregister(Handle_MAT_Edge)

def Handle_MAT_Edge_DownCast(thing):
    return _MAT.Handle_MAT_Edge_DownCast(thing)
Handle_MAT_Edge_DownCast = _MAT.Handle_MAT_Edge_DownCast

class NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< MAT_Bisector >,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< MAT_Bisector >,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< MAT_Bisector >,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< MAT_Bisector >,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _MAT.new_NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher self, int const & theKey, Handle_MAT_Bisector theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher self, int const & theKey, Handle_MAT_Bisector theItem) -> Handle_MAT_Bisector

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_MAT_Bisector

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_MAT_Bisector

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_MAT_Bisector

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _MAT.delete_NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_swigregister = _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _MAT.new_NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MAT.delete_NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher_IteratorHelper)


try:
	MAT_DataMapOfIntegerBisector = NCollection_DataMap_Standard_Integer_Handle_MAT_Bisector_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< MAT_Node >,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< MAT_Node >,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< MAT_Node >,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< MAT_Node >,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _MAT.new_NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher self, int const & theKey, Handle_MAT_Node theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher self, int const & theKey, Handle_MAT_Node theItem) -> Handle_MAT_Node

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_MAT_Node

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_MAT_Node

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_MAT_Node

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _MAT.delete_NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_swigregister = _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _MAT.new_NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MAT.delete_NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher_IteratorHelper)


try:
	MAT_DataMapOfIntegerNode = NCollection_DataMap_Standard_Integer_Handle_MAT_Node_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_MAT_Node(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_MAT_Node self)

        Nullify the handle


        """
        return _MAT.Handle_MAT_Node_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_MAT_Node self) -> bool

        Check for being null

        :rtype: bool

        """
        return _MAT.Handle_MAT_Node_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_MAT_Node self, MAT_Node thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _MAT.Handle_MAT_Node_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_MAT_Node self, Handle_MAT_Node theHandle) -> Handle_MAT_Node
        assign(Handle_MAT_Node self, MAT_Node thePtr) -> Handle_MAT_Node
        assign(Handle_MAT_Node self, Handle_MAT_Node theHandle) -> Handle_MAT_Node

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _MAT.Handle_MAT_Node_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_MAT_Node self) -> MAT_Node

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _MAT.Handle_MAT_Node_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_MAT_Node self) -> MAT_Node

        Member access operator (note non-const)

        :rtype: T *

        """
        return _MAT.Handle_MAT_Node___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_MAT_Node self) -> MAT_Node

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _MAT.Handle_MAT_Node___ref__(self, *args)


    def __hash__(self):
        return _MAT.Handle_MAT_Node___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _MAT.Handle_MAT_Node___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _MAT.new_Handle_MAT_Node(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_MAT.Handle_MAT_Node_DownCast)
    __swig_destroy__ = _MAT.delete_Handle_MAT_Node

    def GeomIndex(self, *args):
        """
        GeomIndex(Handle_MAT_Node self) -> Standard_Integer

        Returns the index associated of the geometric
        representation of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Node_GeomIndex(self, *args)


    def Index(self, *args):
        """
        Index(Handle_MAT_Node self) -> Standard_Integer

        Returns the index associated of the node

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Node_Index(self, *args)


    def LinkedArcs(self, *args):
        """
        LinkedArcs(Handle_MAT_Node self, NCollection_Sequence_Handle_MAT_Arc S)

        Returns in <S> the Arcs linked to <me>.

        :type S: OCC.wrapper.MAT.MAT_SequenceOfArc

        """
        return _MAT.Handle_MAT_Node_LinkedArcs(self, *args)


    def NearElts(self, *args):
        """
        NearElts(Handle_MAT_Node self, NCollection_Sequence_Handle_MAT_BasicElt S)

        Returns  in <S> the BasicElts equidistant
        to <me>.

        :type S: OCC.wrapper.MAT.MAT_SequenceOfBasicElt

        """
        return _MAT.Handle_MAT_Node_NearElts(self, *args)


    def Distance(self, *args):
        """
        Distance(Handle_MAT_Node self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _MAT.Handle_MAT_Node_Distance(self, *args)


    def PendingNode(self, *args):
        """
        PendingNode(Handle_MAT_Node self) -> Standard_Boolean

        Returns True if <me> is a pending Node.
        (ie : the number of Arc Linked = 1)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_Node_PendingNode(self, *args)


    def OnBasicElt(self, *args):
        """
        OnBasicElt(Handle_MAT_Node self) -> Standard_Boolean

        Returns True if <me> belongs to the figure.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_Node_OnBasicElt(self, *args)


    def Infinite(self, *args):
        """
        Infinite(Handle_MAT_Node self) -> Standard_Boolean

        Returns True if the distance of <me> is Infinite

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_Node_Infinite(self, *args)


    def SetIndex(self, *args):
        """
        SetIndex(Handle_MAT_Node self, Standard_Integer const anIndex)

        Set the index associated of the node

        :type anIndex: int

        """
        return _MAT.Handle_MAT_Node_SetIndex(self, *args)


    def SetLinkedArc(self, *args):
        """
        SetLinkedArc(Handle_MAT_Node self, Handle_MAT_Arc anArc)

        :type anArc: OCC.wrapper.MAT.Handle_MAT_Arc

        """
        return _MAT.Handle_MAT_Node_SetLinkedArc(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_MAT_Node self) -> char const *

        :rtype: const char *

        """
        return _MAT.Handle_MAT_Node_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.Handle_MAT_Node_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _MAT.Handle_MAT_Node_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_MAT_Node self)

        Memory deallocator for transient classes


        """
        return _MAT.Handle_MAT_Node_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_MAT_Node self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_MAT_Node self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_Node_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_MAT_Node self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_MAT_Node self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.Handle_MAT_Node_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_MAT_Node self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _MAT.Handle_MAT_Node_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_MAT_Node self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Node_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_MAT_Node self)

        Increments the reference counter of this object


        """
        return _MAT.Handle_MAT_Node_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_MAT_Node self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.Handle_MAT_Node_DecrementRefCounter(self, *args)

Handle_MAT_Node_swigregister = _MAT.Handle_MAT_Node_swigregister
Handle_MAT_Node_swigregister(Handle_MAT_Node)

def Handle_MAT_Node_DownCast(thing):
    return _MAT.Handle_MAT_Node_DownCast(thing)
Handle_MAT_Node_DownCast = _MAT.Handle_MAT_Node_DownCast

class NCollection_Sequence_Handle_MAT_BasicElt(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_MAT_BasicElt self) -> NCollection_Sequence< opencascade::handle< MAT_BasicElt > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_MAT_BasicElt self) -> NCollection_Sequence< opencascade::handle< MAT_BasicElt > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_MAT_BasicElt self) -> NCollection_Sequence< opencascade::handle< MAT_BasicElt > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_MAT_BasicElt self) -> NCollection_Sequence< opencascade::handle< MAT_BasicElt > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _MAT.new_NCollection_Sequence_Handle_MAT_BasicElt(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_MAT_BasicElt self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_MAT_BasicElt self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_MAT_BasicElt self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_MAT_BasicElt self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_MAT_BasicElt self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_MAT_BasicElt self)

        Reverse sequence


        """
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_MAT_BasicElt self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_MAT_BasicElt self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_MAT_BasicElt self, NCollection_Sequence_Handle_MAT_BasicElt theOther) -> NCollection_Sequence_Handle_MAT_BasicElt

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_MAT_BasicElt self, NCollection_Sequence_Handle_MAT_BasicElt theOther) -> NCollection_Sequence_Handle_MAT_BasicElt

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_MAT_BasicElt self, NCollection_Sequence< opencascade::handle< MAT_BasicElt > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_MAT_BasicElt self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_MAT_BasicElt self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_MAT_BasicElt self, Handle_MAT_BasicElt theItem)
        Append(NCollection_Sequence_Handle_MAT_BasicElt self, NCollection_Sequence_Handle_MAT_BasicElt theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_MAT_BasicElt self, Handle_MAT_BasicElt theItem)
        Prepend(NCollection_Sequence_Handle_MAT_BasicElt self, NCollection_Sequence_Handle_MAT_BasicElt theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_MAT_BasicElt self, Standard_Integer const theIndex, Handle_MAT_BasicElt theItem)
        InsertBefore(NCollection_Sequence_Handle_MAT_BasicElt self, Standard_Integer const theIndex, NCollection_Sequence_Handle_MAT_BasicElt theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_MAT_BasicElt self, NCollection_Sequence< opencascade::handle< MAT_BasicElt > >::Iterator & thePosition, Handle_MAT_BasicElt theItem)
        InsertAfter(NCollection_Sequence_Handle_MAT_BasicElt self, Standard_Integer const theIndex, NCollection_Sequence_Handle_MAT_BasicElt theSeq)
        InsertAfter(NCollection_Sequence_Handle_MAT_BasicElt self, Standard_Integer const theIndex, Handle_MAT_BasicElt theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_MAT_BasicElt self, Standard_Integer const theIndex, NCollection_Sequence_Handle_MAT_BasicElt theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _MAT.NCollection_Sequence_Handle_MAT_BasicElt_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_MAT_BasicElt self) -> Handle_MAT_BasicElt

        First item access

        :rtype: TheItemType &

        """
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _MAT.NCollection_Sequence_Handle_MAT_BasicElt_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_MAT_BasicElt self) -> Handle_MAT_BasicElt

        Last item access

        :rtype: TheItemType &

        """
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _MAT.NCollection_Sequence_Handle_MAT_BasicElt_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_MAT_BasicElt self, Standard_Integer const theIndex) -> Handle_MAT_BasicElt

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _MAT.NCollection_Sequence_Handle_MAT_BasicElt___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_MAT_BasicElt self, Standard_Integer const theIndex, Handle_MAT_BasicElt theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_SetValue(self, *args)


    def __iter__(self):
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt___iter__(self)
    __swig_destroy__ = _MAT.delete_NCollection_Sequence_Handle_MAT_BasicElt
NCollection_Sequence_Handle_MAT_BasicElt_swigregister = _MAT.NCollection_Sequence_Handle_MAT_BasicElt_swigregister
NCollection_Sequence_Handle_MAT_BasicElt_swigregister(NCollection_Sequence_Handle_MAT_BasicElt)

def NCollection_Sequence_Handle_MAT_BasicElt_delNode(*args):
    """
    NCollection_Sequence_Handle_MAT_BasicElt_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_delNode(*args)

class NCollection_Sequence_Handle_MAT_BasicElt_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _MAT.new_NCollection_Sequence_Handle_MAT_BasicElt_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MAT.delete_NCollection_Sequence_Handle_MAT_BasicElt_IteratorHelper

    def __next__(self):
        return _MAT.NCollection_Sequence_Handle_MAT_BasicElt_IteratorHelper___next__(self)
NCollection_Sequence_Handle_MAT_BasicElt_IteratorHelper_swigregister = _MAT.NCollection_Sequence_Handle_MAT_BasicElt_IteratorHelper_swigregister
NCollection_Sequence_Handle_MAT_BasicElt_IteratorHelper_swigregister(NCollection_Sequence_Handle_MAT_BasicElt_IteratorHelper)


try:
	MAT_SequenceOfBasicElt = NCollection_Sequence_Handle_MAT_BasicElt
except NameError:
	pass # does not exist, probably ignored

class NCollection_Sequence_Handle_MAT_Arc(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_MAT_Arc self) -> NCollection_Sequence< opencascade::handle< MAT_Arc > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _MAT.NCollection_Sequence_Handle_MAT_Arc_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_MAT_Arc self) -> NCollection_Sequence< opencascade::handle< MAT_Arc > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _MAT.NCollection_Sequence_Handle_MAT_Arc_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_MAT_Arc self) -> NCollection_Sequence< opencascade::handle< MAT_Arc > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _MAT.NCollection_Sequence_Handle_MAT_Arc_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_MAT_Arc self) -> NCollection_Sequence< opencascade::handle< MAT_Arc > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _MAT.NCollection_Sequence_Handle_MAT_Arc_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _MAT.new_NCollection_Sequence_Handle_MAT_Arc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_MAT_Arc self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.NCollection_Sequence_Handle_MAT_Arc_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_MAT_Arc self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.NCollection_Sequence_Handle_MAT_Arc_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_MAT_Arc self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.NCollection_Sequence_Handle_MAT_Arc_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_MAT_Arc self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.NCollection_Sequence_Handle_MAT_Arc_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_MAT_Arc self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.NCollection_Sequence_Handle_MAT_Arc_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_MAT_Arc self)

        Reverse sequence


        """
        return _MAT.NCollection_Sequence_Handle_MAT_Arc_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_MAT_Arc self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _MAT.NCollection_Sequence_Handle_MAT_Arc_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _MAT.NCollection_Sequence_Handle_MAT_Arc_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_MAT_Arc self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _MAT.NCollection_Sequence_Handle_MAT_Arc_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_MAT_Arc self, NCollection_Sequence_Handle_MAT_Arc theOther) -> NCollection_Sequence_Handle_MAT_Arc

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _MAT.NCollection_Sequence_Handle_MAT_Arc_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_MAT_Arc self, NCollection_Sequence_Handle_MAT_Arc theOther) -> NCollection_Sequence_Handle_MAT_Arc

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _MAT.NCollection_Sequence_Handle_MAT_Arc_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_MAT_Arc self, NCollection_Sequence< opencascade::handle< MAT_Arc > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_MAT_Arc self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_MAT_Arc self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _MAT.NCollection_Sequence_Handle_MAT_Arc_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_MAT_Arc self, Handle_MAT_Arc theItem)
        Append(NCollection_Sequence_Handle_MAT_Arc self, NCollection_Sequence_Handle_MAT_Arc theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _MAT.NCollection_Sequence_Handle_MAT_Arc_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_MAT_Arc self, Handle_MAT_Arc theItem)
        Prepend(NCollection_Sequence_Handle_MAT_Arc self, NCollection_Sequence_Handle_MAT_Arc theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _MAT.NCollection_Sequence_Handle_MAT_Arc_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_MAT_Arc self, Standard_Integer const theIndex, Handle_MAT_Arc theItem)
        InsertBefore(NCollection_Sequence_Handle_MAT_Arc self, Standard_Integer const theIndex, NCollection_Sequence_Handle_MAT_Arc theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _MAT.NCollection_Sequence_Handle_MAT_Arc_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_MAT_Arc self, NCollection_Sequence< opencascade::handle< MAT_Arc > >::Iterator & thePosition, Handle_MAT_Arc theItem)
        InsertAfter(NCollection_Sequence_Handle_MAT_Arc self, Standard_Integer const theIndex, NCollection_Sequence_Handle_MAT_Arc theSeq)
        InsertAfter(NCollection_Sequence_Handle_MAT_Arc self, Standard_Integer const theIndex, Handle_MAT_Arc theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _MAT.NCollection_Sequence_Handle_MAT_Arc_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_MAT_Arc self, Standard_Integer const theIndex, NCollection_Sequence_Handle_MAT_Arc theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _MAT.NCollection_Sequence_Handle_MAT_Arc_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _MAT.NCollection_Sequence_Handle_MAT_Arc_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_MAT_Arc self) -> Handle_MAT_Arc

        First item access

        :rtype: TheItemType &

        """
        return _MAT.NCollection_Sequence_Handle_MAT_Arc_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _MAT.NCollection_Sequence_Handle_MAT_Arc_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_MAT_Arc self) -> Handle_MAT_Arc

        Last item access

        :rtype: TheItemType &

        """
        return _MAT.NCollection_Sequence_Handle_MAT_Arc_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _MAT.NCollection_Sequence_Handle_MAT_Arc_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_MAT_Arc self, Standard_Integer const theIndex) -> Handle_MAT_Arc

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _MAT.NCollection_Sequence_Handle_MAT_Arc_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _MAT.NCollection_Sequence_Handle_MAT_Arc___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_MAT_Arc self, Standard_Integer const theIndex, Handle_MAT_Arc theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _MAT.NCollection_Sequence_Handle_MAT_Arc_SetValue(self, *args)


    def __iter__(self):
        return _MAT.NCollection_Sequence_Handle_MAT_Arc___iter__(self)
    __swig_destroy__ = _MAT.delete_NCollection_Sequence_Handle_MAT_Arc
NCollection_Sequence_Handle_MAT_Arc_swigregister = _MAT.NCollection_Sequence_Handle_MAT_Arc_swigregister
NCollection_Sequence_Handle_MAT_Arc_swigregister(NCollection_Sequence_Handle_MAT_Arc)

def NCollection_Sequence_Handle_MAT_Arc_delNode(*args):
    """
    NCollection_Sequence_Handle_MAT_Arc_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _MAT.NCollection_Sequence_Handle_MAT_Arc_delNode(*args)

class NCollection_Sequence_Handle_MAT_Arc_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _MAT.new_NCollection_Sequence_Handle_MAT_Arc_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MAT.delete_NCollection_Sequence_Handle_MAT_Arc_IteratorHelper

    def __next__(self):
        return _MAT.NCollection_Sequence_Handle_MAT_Arc_IteratorHelper___next__(self)
NCollection_Sequence_Handle_MAT_Arc_IteratorHelper_swigregister = _MAT.NCollection_Sequence_Handle_MAT_Arc_IteratorHelper_swigregister
NCollection_Sequence_Handle_MAT_Arc_IteratorHelper_swigregister(NCollection_Sequence_Handle_MAT_Arc_IteratorHelper)


try:
	MAT_SequenceOfArc = NCollection_Sequence_Handle_MAT_Arc
except NameError:
	pass # does not exist, probably ignored


try:
	TColStd_MapIntegerHasher = TColStd.NCollection_DefaultHasher_Standard_Integer
except AttributeError:
	pass # does not exist, probably ignored

class NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< MAT_Arc >,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< MAT_Arc >,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< MAT_Arc >,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< MAT_Arc >,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _MAT.new_NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher self, int const & theKey, Handle_MAT_Arc theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher self, int const & theKey, Handle_MAT_Arc theItem) -> Handle_MAT_Arc

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_MAT_Arc

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_MAT_Arc

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_MAT_Arc

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _MAT.delete_NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_swigregister = _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _MAT.new_NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _MAT.delete_NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _MAT.NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher_IteratorHelper)


try:
	MAT_DataMapOfIntegerArc = NCollection_DataMap_Standard_Integer_Handle_MAT_Arc_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored




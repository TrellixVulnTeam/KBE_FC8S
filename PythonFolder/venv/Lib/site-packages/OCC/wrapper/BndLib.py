# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BndLib')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BndLib')
    _BndLib = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BndLib', [dirname(__file__)])
        except ImportError:
            import _BndLib
            return _BndLib
        try:
            _mod = imp.load_module('_BndLib', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BndLib = swig_import_helper()
    del swig_import_helper
else:
    import _BndLib
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BndLib.delete_SwigPyIterator

    def value(self):
        return _BndLib.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BndLib.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BndLib.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BndLib.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BndLib.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BndLib.SwigPyIterator_copy(self)

    def next(self):
        return _BndLib.SwigPyIterator_next(self)

    def __next__(self):
        return _BndLib.SwigPyIterator___next__(self)

    def previous(self):
        return _BndLib.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BndLib.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BndLib.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BndLib.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BndLib.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BndLib.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BndLib.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BndLib.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BndLib.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BndLib.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BndLib.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BndLib.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BndLib.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BndLib.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BndLib.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BndLib.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BndLib.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BndLib.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BndLib.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BndLib.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BndLib.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BndLib.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BndLib.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BndLib.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BndLib.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BndLib.ptr_to_number(item)
ptr_to_number = _BndLib.ptr_to_number

def HashCode(*args):
    return _BndLib.HashCode(*args)
HashCode = _BndLib.HashCode

def ptr_equal(a, b):
    return _BndLib.ptr_equal(a, b)
ptr_equal = _BndLib.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
class BndLib_Add2dCurve(object):
    """
    Computes the bounding box for a curve in 2d .
    Functions to add a 2D curve to a bounding box.
    The 2D curve is defined from a Geom2d curve.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(Adaptor2d_Curve2d C, Standard_Real const Tol, Bnd_Box2d B)
        Add(Adaptor2d_Curve2d C, Standard_Real const U1, Standard_Real const U2, Standard_Real const Tol, Bnd_Box2d B)
        Add(Handle_Geom2d_Curve C, Standard_Real const Tol, Bnd_Box2d Box)
        Add(Handle_Geom2d_Curve C, Standard_Real const U1, Standard_Real const U2, Standard_Real const Tol, Bnd_Box2d B)

        Adds to the bounding box B the part of curve C
        B is then enlarged by the tolerance value Tol.
        U1, U2 - the parametric range to comute the bounding box;
        Note: depending on the type of curve, one of the following
        representations of the curve C is used to include it in the bounding box B:
        -   an exact representation if C is built from a line, a circle or a conic curve,
        -   the poles of the curve if C is built from a Bezier curve or a BSpline curve,
        -   if not, the points of an approximation of the curve C.

        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type U1: float
        :type U2: float
        :type Tol: float
        :type B: OCC.wrapper.Bnd.Bnd_Box2d

        """
        return _BndLib.BndLib_Add2dCurve_Add(*args)

    Add = staticmethod(Add)

    def AddOptimal(*args):
        """
        AddOptimal(Handle_Geom2d_Curve C, Standard_Real const U1, Standard_Real const U2, Standard_Real const Tol, Bnd_Box2d B)

        Adds to the bounding box B the part of curve C
        B is then enlarged by the tolerance value Tol.
        U1, U2 - the parametric range to comute the bounding box;
        Note: depending on the type of curve, one of the following
        algorithms  is used to include it in the bounding box B:
        -   an exact analytical if C is built from a line, a circle or a conic curve,
        -   numerical calculation of bounding box sizes, based on minimization algorithm,  for other types of curve
        If Tol = < Precision::PConfusion(), Precision::PConfusion is used as tolerance for calculation

        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type U1: float
        :type U2: float
        :type Tol: float
        :type B: OCC.wrapper.Bnd.Bnd_Box2d

        """
        return _BndLib.BndLib_Add2dCurve_AddOptimal(*args)

    AddOptimal = staticmethod(AddOptimal)

    def __init__(self):
        """
        Computes the bounding box for a curve in 2d .
        Functions to add a 2D curve to a bounding box.
        The 2D curve is defined from a Geom2d curve.
        """
        this = _BndLib.new_BndLib_Add2dCurve()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BndLib.delete_BndLib_Add2dCurve
BndLib_Add2dCurve_swigregister = _BndLib.BndLib_Add2dCurve_swigregister
BndLib_Add2dCurve_swigregister(BndLib_Add2dCurve)

def BndLib_Add2dCurve_Add(*args):
    """
    Add(Adaptor2d_Curve2d C, Standard_Real const Tol, Bnd_Box2d B)
    Add(Adaptor2d_Curve2d C, Standard_Real const U1, Standard_Real const U2, Standard_Real const Tol, Bnd_Box2d B)
    Add(Handle_Geom2d_Curve C, Standard_Real const Tol, Bnd_Box2d Box)
    BndLib_Add2dCurve_Add(Handle_Geom2d_Curve C, Standard_Real const U1, Standard_Real const U2, Standard_Real const Tol, Bnd_Box2d B)

    Adds to the bounding box B the part of curve C
    B is then enlarged by the tolerance value Tol.
    U1, U2 - the parametric range to comute the bounding box;
    Note: depending on the type of curve, one of the following
    representations of the curve C is used to include it in the bounding box B:
    -   an exact representation if C is built from a line, a circle or a conic curve,
    -   the poles of the curve if C is built from a Bezier curve or a BSpline curve,
    -   if not, the points of an approximation of the curve C.

    :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type U1: float
    :type U2: float
    :type Tol: float
    :type B: OCC.wrapper.Bnd.Bnd_Box2d

    """
    return _BndLib.BndLib_Add2dCurve_Add(*args)

def BndLib_Add2dCurve_AddOptimal(*args):
    """
    BndLib_Add2dCurve_AddOptimal(Handle_Geom2d_Curve C, Standard_Real const U1, Standard_Real const U2, Standard_Real const Tol, Bnd_Box2d B)

    Adds to the bounding box B the part of curve C
    B is then enlarged by the tolerance value Tol.
    U1, U2 - the parametric range to comute the bounding box;
    Note: depending on the type of curve, one of the following
    algorithms  is used to include it in the bounding box B:
    -   an exact analytical if C is built from a line, a circle or a conic curve,
    -   numerical calculation of bounding box sizes, based on minimization algorithm,  for other types of curve
    If Tol = < Precision::PConfusion(), Precision::PConfusion is used as tolerance for calculation

    :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type U1: float
    :type U2: float
    :type Tol: float
    :type B: OCC.wrapper.Bnd.Bnd_Box2d

    """
    return _BndLib.BndLib_Add2dCurve_AddOptimal(*args)

class BndLib_AddSurface(object):
    """
    computes the box from a surface
    Functions to add a surface to a bounding box.
    The surface is defined from a Geom surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(Adaptor3d_Surface S, Standard_Real const Tol, Bnd_Box B)
        Add(Adaptor3d_Surface S, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax, Standard_Real const Tol, Bnd_Box B)

        Adds to the bounding box B the surface S
        the patch of the surface S limited in the u parametric
        direction by the two parameter values UMin, UMax, and
        in the v parametric direction by the two parameter
        values VMin, VMax.
        Note: depending on the type of curve, one of the following
        representations of the surface S is used to include it in the bounding box B:
        -   an exact representation if S is built from a plane, a
        cylinder, a cone, a sphere or a torus,
        -   the poles of the surface if S is built from a Bezier
        surface or a BSpline surface,
        -   the points of an approximation of the surface S in
        cases other than offset surfaces;
        -   in the case of an offset surface, the basis surface is first
        included according to the previous rules; then the
        bounding box is enlarged by the offset value.
        Warning
        Do not use these functions to add a non-finite surface to
        the bounding box B.
        If UMin, UMax, VMin or VMax is an infinite value B will become WholeSpace.
        S is an adapted surface, that is, an object which is an interface between:
        -   the services provided by a surface from the package Geom
        -   and those required of the surface by the computation algorithm.
        The adapted surface is created in the following way:
        Handle(Geom_Surface) mysurface = ... ;
        GeomAdaptor_Surface S(mysurface);
        The bounding box B is then enlarged by adding this surface:
        Bnd_Box B;
        // ...
        Standard_Real Tol = ... ;
        AddSurface::Add ( S, Tol, B );

        :type S: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type UMin: float
        :type UMax: float
        :type VMin: float
        :type VMax: float
        :type Tol: float
        :type B: OCC.wrapper.Bnd.Bnd_Box

        """
        return _BndLib.BndLib_AddSurface_Add(*args)

    Add = staticmethod(Add)

    def AddOptimal(*args):
        """
        AddOptimal(Adaptor3d_Surface S, Standard_Real const Tol, Bnd_Box B)
        AddOptimal(Adaptor3d_Surface S, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax, Standard_Real const Tol, Bnd_Box B)

        :type S: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type UMin: float
        :type UMax: float
        :type VMin: float
        :type VMax: float
        :type Tol: float
        :type B: OCC.wrapper.Bnd.Bnd_Box

        """
        return _BndLib.BndLib_AddSurface_AddOptimal(*args)

    AddOptimal = staticmethod(AddOptimal)

    def AddGenSurf(*args):
        """
        AddGenSurf(Adaptor3d_Surface S, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax, Standard_Real const Tol, Bnd_Box B)

        Adds to the bounding box B the surface S
        using numerical minimization algorithms
        This method is used in AddOptimal for not analytical surfaces and torus.
        if Tol < Precision::Confusion(), Precision::Confusion is used as computation tolerance

        :type S: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type UMin: float
        :type UMax: float
        :type VMin: float
        :type VMax: float
        :type Tol: float
        :type B: OCC.wrapper.Bnd.Bnd_Box

        """
        return _BndLib.BndLib_AddSurface_AddGenSurf(*args)

    AddGenSurf = staticmethod(AddGenSurf)

    def __init__(self):
        """
        computes the box from a surface
        Functions to add a surface to a bounding box.
        The surface is defined from a Geom surface.
        """
        this = _BndLib.new_BndLib_AddSurface()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BndLib.delete_BndLib_AddSurface
BndLib_AddSurface_swigregister = _BndLib.BndLib_AddSurface_swigregister
BndLib_AddSurface_swigregister(BndLib_AddSurface)

def BndLib_AddSurface_Add(*args):
    """
    Add(Adaptor3d_Surface S, Standard_Real const Tol, Bnd_Box B)
    BndLib_AddSurface_Add(Adaptor3d_Surface S, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax, Standard_Real const Tol, Bnd_Box B)

    Adds to the bounding box B the surface S
    the patch of the surface S limited in the u parametric
    direction by the two parameter values UMin, UMax, and
    in the v parametric direction by the two parameter
    values VMin, VMax.
    Note: depending on the type of curve, one of the following
    representations of the surface S is used to include it in the bounding box B:
    -   an exact representation if S is built from a plane, a
    cylinder, a cone, a sphere or a torus,
    -   the poles of the surface if S is built from a Bezier
    surface or a BSpline surface,
    -   the points of an approximation of the surface S in
    cases other than offset surfaces;
    -   in the case of an offset surface, the basis surface is first
    included according to the previous rules; then the
    bounding box is enlarged by the offset value.
    Warning
    Do not use these functions to add a non-finite surface to
    the bounding box B.
    If UMin, UMax, VMin or VMax is an infinite value B will become WholeSpace.
    S is an adapted surface, that is, an object which is an interface between:
    -   the services provided by a surface from the package Geom
    -   and those required of the surface by the computation algorithm.
    The adapted surface is created in the following way:
    Handle(Geom_Surface) mysurface = ... ;
    GeomAdaptor_Surface S(mysurface);
    The bounding box B is then enlarged by adding this surface:
    Bnd_Box B;
    // ...
    Standard_Real Tol = ... ;
    AddSurface::Add ( S, Tol, B );

    :type S: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
    :type UMin: float
    :type UMax: float
    :type VMin: float
    :type VMax: float
    :type Tol: float
    :type B: OCC.wrapper.Bnd.Bnd_Box

    """
    return _BndLib.BndLib_AddSurface_Add(*args)

def BndLib_AddSurface_AddOptimal(*args):
    """
    AddOptimal(Adaptor3d_Surface S, Standard_Real const Tol, Bnd_Box B)
    BndLib_AddSurface_AddOptimal(Adaptor3d_Surface S, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax, Standard_Real const Tol, Bnd_Box B)

    :type S: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
    :type UMin: float
    :type UMax: float
    :type VMin: float
    :type VMax: float
    :type Tol: float
    :type B: OCC.wrapper.Bnd.Bnd_Box

    """
    return _BndLib.BndLib_AddSurface_AddOptimal(*args)

def BndLib_AddSurface_AddGenSurf(*args):
    """
    BndLib_AddSurface_AddGenSurf(Adaptor3d_Surface S, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax, Standard_Real const Tol, Bnd_Box B)

    Adds to the bounding box B the surface S
    using numerical minimization algorithms
    This method is used in AddOptimal for not analytical surfaces and torus.
    if Tol < Precision::Confusion(), Precision::Confusion is used as computation tolerance

    :type S: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
    :type UMin: float
    :type UMax: float
    :type VMin: float
    :type VMax: float
    :type Tol: float
    :type B: OCC.wrapper.Bnd.Bnd_Box

    """
    return _BndLib.BndLib_AddSurface_AddGenSurf(*args)

class BndLib_(object):
    """
    The BndLib package provides functions to add a geometric primitive to a bounding box.
    Note: these functions work with gp objects, optionally
    limited by parameter values. If the curves and surfaces
    provided by the gp package are not explicitly
    parameterized, they still have an implicit parameterization,
    similar to that which they infer for the equivalent Geom or Geom2d objects.
    Add : Package to compute the bounding boxes for elementary
    objects from gp in 2d and 3d .

    AddCurve2d : A class to compute the bounding box for a curve
    in 2d dimensions ;the curve is defined by a tool

    AddCurve : A class to compute the bounding box for a curve
    in 3d dimensions ;the curve is defined by a tool

    AddSurface : A class to compute the bounding box for a surface.
    The surface is defined by a tool for the geometry and another
    tool for the topology (only the edges in 2d dimensions)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(gp_Lin L, Standard_Real const P1, Standard_Real const P2, Standard_Real const Tol, Bnd_Box B)
        Add(gp_Lin2d L, Standard_Real const P1, Standard_Real const P2, Standard_Real const Tol, Bnd_Box2d B)
        Add(gp_Circ C, Standard_Real const Tol, Bnd_Box B)
        Add(gp_Circ C, Standard_Real const P1, Standard_Real const P2, Standard_Real const Tol, Bnd_Box B)
        Add(gp_Circ2d C, Standard_Real const Tol, Bnd_Box2d B)
        Add(gp_Circ2d C, Standard_Real const P1, Standard_Real const P2, Standard_Real const Tol, Bnd_Box2d B)
        Add(gp_Elips C, Standard_Real const Tol, Bnd_Box B)
        Add(gp_Elips C, Standard_Real const P1, Standard_Real const P2, Standard_Real const Tol, Bnd_Box B)
        Add(gp_Elips2d C, Standard_Real const Tol, Bnd_Box2d B)
        Add(gp_Elips2d C, Standard_Real const P1, Standard_Real const P2, Standard_Real const Tol, Bnd_Box2d B)
        Add(gp_Parab P, Standard_Real const P1, Standard_Real const P2, Standard_Real const Tol, Bnd_Box B)
        Add(gp_Parab2d P, Standard_Real const P1, Standard_Real const P2, Standard_Real const Tol, Bnd_Box2d B)
        Add(gp_Hypr H, Standard_Real const P1, Standard_Real const P2, Standard_Real const Tol, Bnd_Box B)
        Add(gp_Hypr2d H, Standard_Real const P1, Standard_Real const P2, Standard_Real const Tol, Bnd_Box2d B)
        Add(gp_Cylinder S, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax, Standard_Real const Tol, Bnd_Box B)
        Add(gp_Cylinder S, Standard_Real const VMin, Standard_Real const VMax, Standard_Real const Tol, Bnd_Box B)
        Add(gp_Cone S, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax, Standard_Real const Tol, Bnd_Box B)
        Add(gp_Cone S, Standard_Real const VMin, Standard_Real const VMax, Standard_Real const Tol, Bnd_Box B)
        Add(gp_Sphere S, Standard_Real const Tol, Bnd_Box B)
        Add(gp_Sphere S, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax, Standard_Real const Tol, Bnd_Box B)
        Add(gp_Torus P, Standard_Real const Tol, Bnd_Box B)
        Add(gp_Torus P, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax, Standard_Real const Tol, Bnd_Box B)

        Adds to the bounding box B
        -   the torus S, or
        -   the patch of the torus S, limited in the u parametric
        direction, by the two parameter values UMin and UMax,
        and in the v parametric direction, by the two parameter
        values VMin and VMax.
        B is then enlarged by the tolerance value Tol.
        UMax-UMin can be in [0,2*pi],
        VMin,VMax can be [-pi/2,pi/2]

        :type P: OCC.wrapper.gp.gp_Torus
        :type UMin: float
        :type UMax: float
        :type VMin: float
        :type VMax: float
        :type Tol: float
        :type B: OCC.wrapper.Bnd.Bnd_Box

        """
        return _BndLib.BndLib__Add(*args)

    Add = staticmethod(Add)

    def __init__(self):
        """
        The BndLib package provides functions to add a geometric primitive to a bounding box.
        Note: these functions work with gp objects, optionally
        limited by parameter values. If the curves and surfaces
        provided by the gp package are not explicitly
        parameterized, they still have an implicit parameterization,
        similar to that which they infer for the equivalent Geom or Geom2d objects.
        Add : Package to compute the bounding boxes for elementary
        objects from gp in 2d and 3d .

        AddCurve2d : A class to compute the bounding box for a curve
        in 2d dimensions ;the curve is defined by a tool

        AddCurve : A class to compute the bounding box for a curve
        in 3d dimensions ;the curve is defined by a tool

        AddSurface : A class to compute the bounding box for a surface.
        The surface is defined by a tool for the geometry and another
        tool for the topology (only the edges in 2d dimensions)
        """
        this = _BndLib.new_BndLib_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BndLib.delete_BndLib_
BndLib__swigregister = _BndLib.BndLib__swigregister
BndLib__swigregister(BndLib_)

def BndLib__Add(*args):
    """
    Add(gp_Lin L, Standard_Real const P1, Standard_Real const P2, Standard_Real const Tol, Bnd_Box B)
    Add(gp_Lin2d L, Standard_Real const P1, Standard_Real const P2, Standard_Real const Tol, Bnd_Box2d B)
    Add(gp_Circ C, Standard_Real const Tol, Bnd_Box B)
    Add(gp_Circ C, Standard_Real const P1, Standard_Real const P2, Standard_Real const Tol, Bnd_Box B)
    Add(gp_Circ2d C, Standard_Real const Tol, Bnd_Box2d B)
    Add(gp_Circ2d C, Standard_Real const P1, Standard_Real const P2, Standard_Real const Tol, Bnd_Box2d B)
    Add(gp_Elips C, Standard_Real const Tol, Bnd_Box B)
    Add(gp_Elips C, Standard_Real const P1, Standard_Real const P2, Standard_Real const Tol, Bnd_Box B)
    Add(gp_Elips2d C, Standard_Real const Tol, Bnd_Box2d B)
    Add(gp_Elips2d C, Standard_Real const P1, Standard_Real const P2, Standard_Real const Tol, Bnd_Box2d B)
    Add(gp_Parab P, Standard_Real const P1, Standard_Real const P2, Standard_Real const Tol, Bnd_Box B)
    Add(gp_Parab2d P, Standard_Real const P1, Standard_Real const P2, Standard_Real const Tol, Bnd_Box2d B)
    Add(gp_Hypr H, Standard_Real const P1, Standard_Real const P2, Standard_Real const Tol, Bnd_Box B)
    Add(gp_Hypr2d H, Standard_Real const P1, Standard_Real const P2, Standard_Real const Tol, Bnd_Box2d B)
    Add(gp_Cylinder S, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax, Standard_Real const Tol, Bnd_Box B)
    Add(gp_Cylinder S, Standard_Real const VMin, Standard_Real const VMax, Standard_Real const Tol, Bnd_Box B)
    Add(gp_Cone S, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax, Standard_Real const Tol, Bnd_Box B)
    Add(gp_Cone S, Standard_Real const VMin, Standard_Real const VMax, Standard_Real const Tol, Bnd_Box B)
    Add(gp_Sphere S, Standard_Real const Tol, Bnd_Box B)
    Add(gp_Sphere S, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax, Standard_Real const Tol, Bnd_Box B)
    Add(gp_Torus P, Standard_Real const Tol, Bnd_Box B)
    BndLib__Add(gp_Torus P, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax, Standard_Real const Tol, Bnd_Box B)

    Adds to the bounding box B
    -   the torus S, or
    -   the patch of the torus S, limited in the u parametric
    direction, by the two parameter values UMin and UMax,
    and in the v parametric direction, by the two parameter
    values VMin and VMax.
    B is then enlarged by the tolerance value Tol.
    UMax-UMin can be in [0,2*pi],
    VMin,VMax can be [-pi/2,pi/2]

    :type P: OCC.wrapper.gp.gp_Torus
    :type UMin: float
    :type UMax: float
    :type VMin: float
    :type VMax: float
    :type Tol: float
    :type B: OCC.wrapper.Bnd.Bnd_Box

    """
    return _BndLib.BndLib__Add(*args)

class BndLib_Add3dCurve(object):
    """
    Computes the bounding box for a curve in 3d.
    Functions to add a 3D curve to a bounding box.
    The 3D curve is defined from a Geom curve.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(Adaptor3d_Curve C, Standard_Real const Tol, Bnd_Box B)
        Add(Adaptor3d_Curve C, Standard_Real const U1, Standard_Real const U2, Standard_Real const Tol, Bnd_Box B)

        Adds to the bounding box B the curve C
        the arc of the curve C limited by the two parameter values P1 and P2.
        Note: depending on the type of curve, one of the following
        representations of the curve C is used to include it in the bounding box B:
        -   an exact representation if C is built from a line, a circle   or a conic curve,
        -   the poles of the curve if C is built from a Bezier curve or   a BSpline curve,
        if not, the points of an approximation of the curve C.
        Warning
        C is an adapted curve, that is, an object which is an interface between:
        -   the services provided by a 3D curve from the package   Geom
        -   and those required of the curve by the computation algorithm.
        The adapted curve is created in the following way:
        Handle(Geom_Curve) mycurve = ... ;
        GeomAdaptor_Curve C(mycurve);
        The bounding box B is then enlarged by adding it:
        Bnd_Box B;
        // ...
        Standard_Real Tol = ... ;
        Add3dCurve::Add ( C, Tol, B );
        Exceptions
        Standard_Failure if the curve is built from:
        -   a Geom_Line, or
        -   a Geom_Parabola, or
        -   a Geom_Hyperbola,
        and P1 and P2 are either two negative infinite real
        numbers, or two positive infinite real numbers.

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type U1: float
        :type U2: float
        :type Tol: float
        :type B: OCC.wrapper.Bnd.Bnd_Box

        """
        return _BndLib.BndLib_Add3dCurve_Add(*args)

    Add = staticmethod(Add)

    def AddOptimal(*args):
        """
        AddOptimal(Adaptor3d_Curve C, Standard_Real const Tol, Bnd_Box B)
        AddOptimal(Adaptor3d_Curve C, Standard_Real const U1, Standard_Real const U2, Standard_Real const Tol, Bnd_Box B)

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type U1: float
        :type U2: float
        :type Tol: float
        :type B: OCC.wrapper.Bnd.Bnd_Box

        """
        return _BndLib.BndLib_Add3dCurve_AddOptimal(*args)

    AddOptimal = staticmethod(AddOptimal)

    def AddGenCurv(*args):
        """
        AddGenCurv(Adaptor3d_Curve C, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const Tol, Bnd_Box B)

        Adds to the bounding box B the curve C
        using numerical minimization algorithms
        This method is used in AddOptimal for not analytical curves.
        if Tol < Precision::Confusion(), Precision:;Confusion is used as computation tolerance

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type UMin: float
        :type UMax: float
        :type Tol: float
        :type B: OCC.wrapper.Bnd.Bnd_Box

        """
        return _BndLib.BndLib_Add3dCurve_AddGenCurv(*args)

    AddGenCurv = staticmethod(AddGenCurv)

    def __init__(self):
        """
        Computes the bounding box for a curve in 3d.
        Functions to add a 3D curve to a bounding box.
        The 3D curve is defined from a Geom curve.
        """
        this = _BndLib.new_BndLib_Add3dCurve()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BndLib.delete_BndLib_Add3dCurve
BndLib_Add3dCurve_swigregister = _BndLib.BndLib_Add3dCurve_swigregister
BndLib_Add3dCurve_swigregister(BndLib_Add3dCurve)

def BndLib_Add3dCurve_Add(*args):
    """
    Add(Adaptor3d_Curve C, Standard_Real const Tol, Bnd_Box B)
    BndLib_Add3dCurve_Add(Adaptor3d_Curve C, Standard_Real const U1, Standard_Real const U2, Standard_Real const Tol, Bnd_Box B)

    Adds to the bounding box B the curve C
    the arc of the curve C limited by the two parameter values P1 and P2.
    Note: depending on the type of curve, one of the following
    representations of the curve C is used to include it in the bounding box B:
    -   an exact representation if C is built from a line, a circle   or a conic curve,
    -   the poles of the curve if C is built from a Bezier curve or   a BSpline curve,
    if not, the points of an approximation of the curve C.
    Warning
    C is an adapted curve, that is, an object which is an interface between:
    -   the services provided by a 3D curve from the package   Geom
    -   and those required of the curve by the computation algorithm.
    The adapted curve is created in the following way:
    Handle(Geom_Curve) mycurve = ... ;
    GeomAdaptor_Curve C(mycurve);
    The bounding box B is then enlarged by adding it:
    Bnd_Box B;
    // ...
    Standard_Real Tol = ... ;
    Add3dCurve::Add ( C, Tol, B );
    Exceptions
    Standard_Failure if the curve is built from:
    -   a Geom_Line, or
    -   a Geom_Parabola, or
    -   a Geom_Hyperbola,
    and P1 and P2 are either two negative infinite real
    numbers, or two positive infinite real numbers.

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type U1: float
    :type U2: float
    :type Tol: float
    :type B: OCC.wrapper.Bnd.Bnd_Box

    """
    return _BndLib.BndLib_Add3dCurve_Add(*args)

def BndLib_Add3dCurve_AddOptimal(*args):
    """
    AddOptimal(Adaptor3d_Curve C, Standard_Real const Tol, Bnd_Box B)
    BndLib_Add3dCurve_AddOptimal(Adaptor3d_Curve C, Standard_Real const U1, Standard_Real const U2, Standard_Real const Tol, Bnd_Box B)

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type U1: float
    :type U2: float
    :type Tol: float
    :type B: OCC.wrapper.Bnd.Bnd_Box

    """
    return _BndLib.BndLib_Add3dCurve_AddOptimal(*args)

def BndLib_Add3dCurve_AddGenCurv(*args):
    """
    BndLib_Add3dCurve_AddGenCurv(Adaptor3d_Curve C, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const Tol, Bnd_Box B)

    Adds to the bounding box B the curve C
    using numerical minimization algorithms
    This method is used in AddOptimal for not analytical curves.
    if Tol < Precision::Confusion(), Precision:;Confusion is used as computation tolerance

    :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type UMin: float
    :type UMax: float
    :type Tol: float
    :type B: OCC.wrapper.Bnd.Bnd_Box

    """
    return _BndLib.BndLib_Add3dCurve_AddGenCurv(*args)




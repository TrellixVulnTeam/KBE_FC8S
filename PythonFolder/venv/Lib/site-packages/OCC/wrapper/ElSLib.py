# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_ElSLib')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_ElSLib')
    _ElSLib = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ElSLib', [dirname(__file__)])
        except ImportError:
            import _ElSLib
            return _ElSLib
        try:
            _mod = imp.load_module('_ElSLib', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _ElSLib = swig_import_helper()
    del swig_import_helper
else:
    import _ElSLib
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ElSLib.delete_SwigPyIterator

    def value(self):
        return _ElSLib.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _ElSLib.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _ElSLib.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _ElSLib.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _ElSLib.SwigPyIterator_equal(self, x)

    def copy(self):
        return _ElSLib.SwigPyIterator_copy(self)

    def next(self):
        return _ElSLib.SwigPyIterator_next(self)

    def __next__(self):
        return _ElSLib.SwigPyIterator___next__(self)

    def previous(self):
        return _ElSLib.SwigPyIterator_previous(self)

    def advance(self, n):
        return _ElSLib.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _ElSLib.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _ElSLib.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _ElSLib.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _ElSLib.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _ElSLib.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _ElSLib.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _ElSLib.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _ElSLib.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_ElSLib.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _ElSLib.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _ElSLib.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ElSLib.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _ElSLib.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _ElSLib.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _ElSLib.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _ElSLib.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_ElSLib.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _ElSLib.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _ElSLib.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ElSLib.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _ElSLib.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _ElSLib.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _ElSLib.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _ElSLib.ptr_to_number(item)
ptr_to_number = _ElSLib.ptr_to_number

def HashCode(*args):
    return _ElSLib.HashCode(*args)
HashCode = _ElSLib.HashCode

def ptr_equal(a, b):
    return _ElSLib.ptr_equal(a, b)
ptr_equal = _ElSLib.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
class ElSLib_(object):
    """
    Provides functions for basic geometric computation on
    elementary surfaces.
    This includes:
    -   calculation of a point or derived vector on a surface
    where the surface is provided by the gp package, or
    defined in canonical form (as in the gp package), and
    the point is defined with a parameter,
    -   evaluation of the parameters corresponding to a
    point on an elementary surface from gp,
    -   calculation of isoparametric curves on an elementary
    surface defined in canonical form (as in the gp package).
    Notes:
    -   ElSLib stands for Elementary Surfaces Library.
    -   If the surfaces provided by the gp package are not
    explicitly parameterized, they still have an implicit
    parameterization, similar to that which they infer on
    the equivalent Geom surfaces.
    Note: ElSLib stands for Elementary Surfaces Library.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Value(*args):
        """
        Value(Standard_Real const U, Standard_Real const V, gp_Pln Pl) -> gp_Pnt
        Value(Standard_Real const U, Standard_Real const V, gp_Cone C) -> gp_Pnt
        Value(Standard_Real const U, Standard_Real const V, gp_Cylinder C) -> gp_Pnt
        Value(Standard_Real const U, Standard_Real const V, gp_Sphere S) -> gp_Pnt
        Value(Standard_Real const U, Standard_Real const V, gp_Torus T) -> gp_Pnt

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Torus
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _ElSLib.ElSLib__Value(*args)

    Value = staticmethod(Value)

    def DN(*args):
        """
        DN(Standard_Real const U, Standard_Real const V, gp_Pln Pl, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec
        DN(Standard_Real const U, Standard_Real const V, gp_Cone C, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec
        DN(Standard_Real const U, Standard_Real const V, gp_Cylinder C, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec
        DN(Standard_Real const U, Standard_Real const V, gp_Sphere S, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec
        DN(Standard_Real const U, Standard_Real const V, gp_Torus T, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Torus
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _ElSLib.ElSLib__DN(*args)

    DN = staticmethod(DN)

    def D0(*args):
        """
        D0(Standard_Real const U, Standard_Real const V, gp_Pln Pl, gp_Pnt P)
        D0(Standard_Real const U, Standard_Real const V, gp_Cone C, gp_Pnt P)
        D0(Standard_Real const U, Standard_Real const V, gp_Cylinder C, gp_Pnt P)
        D0(Standard_Real const U, Standard_Real const V, gp_Sphere S, gp_Pnt P)
        D0(Standard_Real const U, Standard_Real const V, gp_Torus T, gp_Pnt P)

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Torus
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _ElSLib.ElSLib__D0(*args)

    D0 = staticmethod(D0)

    def D1(*args):
        """
        D1(Standard_Real const U, Standard_Real const V, gp_Pln Pl, gp_Pnt P, gp_Vec Vu, gp_Vec Vv)
        D1(Standard_Real const U, Standard_Real const V, gp_Cone C, gp_Pnt P, gp_Vec Vu, gp_Vec Vv)
        D1(Standard_Real const U, Standard_Real const V, gp_Cylinder C, gp_Pnt P, gp_Vec Vu, gp_Vec Vv)
        D1(Standard_Real const U, Standard_Real const V, gp_Sphere S, gp_Pnt P, gp_Vec Vu, gp_Vec Vv)
        D1(Standard_Real const U, Standard_Real const V, gp_Torus T, gp_Pnt P, gp_Vec Vu, gp_Vec Vv)

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Torus
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Vu: OCC.wrapper.gp.gp_Vec
        :type Vv: OCC.wrapper.gp.gp_Vec

        """
        return _ElSLib.ElSLib__D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        D2(Standard_Real const U, Standard_Real const V, gp_Cone C, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv)
        D2(Standard_Real const U, Standard_Real const V, gp_Cylinder C, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv)
        D2(Standard_Real const U, Standard_Real const V, gp_Sphere S, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv)
        D2(Standard_Real const U, Standard_Real const V, gp_Torus T, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv)

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Torus
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Vu: OCC.wrapper.gp.gp_Vec
        :type Vv: OCC.wrapper.gp.gp_Vec
        :type Vuu: OCC.wrapper.gp.gp_Vec
        :type Vvv: OCC.wrapper.gp.gp_Vec
        :type Vuv: OCC.wrapper.gp.gp_Vec

        """
        return _ElSLib.ElSLib__D2(*args)

    D2 = staticmethod(D2)

    def D3(*args):
        """
        D3(Standard_Real const U, Standard_Real const V, gp_Cone C, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv, gp_Vec Vuuu, gp_Vec Vvvv, gp_Vec Vuuv, gp_Vec Vuvv)
        D3(Standard_Real const U, Standard_Real const V, gp_Cylinder C, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv, gp_Vec Vuuu, gp_Vec Vvvv, gp_Vec Vuuv, gp_Vec Vuvv)
        D3(Standard_Real const U, Standard_Real const V, gp_Sphere S, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv, gp_Vec Vuuu, gp_Vec Vvvv, gp_Vec Vuuv, gp_Vec Vuvv)
        D3(Standard_Real const U, Standard_Real const V, gp_Torus T, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv, gp_Vec Vuuu, gp_Vec Vvvv, gp_Vec Vuuv, gp_Vec Vuvv)

        Surface evaluation
        The following functions compute the point and the
        derivatives on elementary surfaces defined with their
        geometric characterisitics.
        You don't need to create the surface to use these functions.
        These functions are called by the previous  ones.
        Example :
        A cylinder is defined with its position and its radius.

        :type U: float
        :type V: float
        :type T: OCC.wrapper.gp.gp_Torus
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Vu: OCC.wrapper.gp.gp_Vec
        :type Vv: OCC.wrapper.gp.gp_Vec
        :type Vuu: OCC.wrapper.gp.gp_Vec
        :type Vvv: OCC.wrapper.gp.gp_Vec
        :type Vuv: OCC.wrapper.gp.gp_Vec
        :type Vuuu: OCC.wrapper.gp.gp_Vec
        :type Vvvv: OCC.wrapper.gp.gp_Vec
        :type Vuuv: OCC.wrapper.gp.gp_Vec
        :type Vuvv: OCC.wrapper.gp.gp_Vec

        """
        return _ElSLib.ElSLib__D3(*args)

    D3 = staticmethod(D3)

    def PlaneValue(*args):
        """
        PlaneValue(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos) -> gp_Pnt

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _ElSLib.ElSLib__PlaneValue(*args)

    PlaneValue = staticmethod(PlaneValue)

    def CylinderValue(*args):
        """
        CylinderValue(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius) -> gp_Pnt

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _ElSLib.ElSLib__CylinderValue(*args)

    CylinderValue = staticmethod(CylinderValue)

    def ConeValue(*args):
        """
        ConeValue(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, Standard_Real const SAngle) -> gp_Pnt

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :type SAngle: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _ElSLib.ElSLib__ConeValue(*args)

    ConeValue = staticmethod(ConeValue)

    def SphereValue(*args):
        """
        SphereValue(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius) -> gp_Pnt

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _ElSLib.ElSLib__SphereValue(*args)

    SphereValue = staticmethod(SphereValue)

    def TorusValue(*args):
        """
        TorusValue(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> gp_Pnt

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type MajorRadius: float
        :type MinorRadius: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _ElSLib.ElSLib__TorusValue(*args)

    TorusValue = staticmethod(TorusValue)

    def PlaneDN(*args):
        """
        PlaneDN(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _ElSLib.ElSLib__PlaneDN(*args)

    PlaneDN = staticmethod(PlaneDN)

    def CylinderDN(*args):
        """
        CylinderDN(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _ElSLib.ElSLib__CylinderDN(*args)

    CylinderDN = staticmethod(CylinderDN)

    def ConeDN(*args):
        """
        ConeDN(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, Standard_Real const SAngle, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :type SAngle: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _ElSLib.ElSLib__ConeDN(*args)

    ConeDN = staticmethod(ConeDN)

    def SphereDN(*args):
        """
        SphereDN(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _ElSLib.ElSLib__SphereDN(*args)

    SphereDN = staticmethod(SphereDN)

    def TorusDN(*args):
        """
        TorusDN(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type MajorRadius: float
        :type MinorRadius: float
        :type Nu: int
        :type Nv: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _ElSLib.ElSLib__TorusDN(*args)

    TorusDN = staticmethod(TorusDN)

    def PlaneD0(*args):
        """
        PlaneD0(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, gp_Pnt P)

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _ElSLib.ElSLib__PlaneD0(*args)

    PlaneD0 = staticmethod(PlaneD0)

    def ConeD0(*args):
        """
        ConeD0(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, Standard_Real const SAngle, gp_Pnt P)

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :type SAngle: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _ElSLib.ElSLib__ConeD0(*args)

    ConeD0 = staticmethod(ConeD0)

    def CylinderD0(*args):
        """
        CylinderD0(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, gp_Pnt P)

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _ElSLib.ElSLib__CylinderD0(*args)

    CylinderD0 = staticmethod(CylinderD0)

    def SphereD0(*args):
        """
        SphereD0(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, gp_Pnt P)

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _ElSLib.ElSLib__SphereD0(*args)

    SphereD0 = staticmethod(SphereD0)

    def TorusD0(*args):
        """
        TorusD0(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt P)

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type MajorRadius: float
        :type MinorRadius: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _ElSLib.ElSLib__TorusD0(*args)

    TorusD0 = staticmethod(TorusD0)

    def PlaneD1(*args):
        """
        PlaneD1(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, gp_Pnt P, gp_Vec Vu, gp_Vec Vv)

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Vu: OCC.wrapper.gp.gp_Vec
        :type Vv: OCC.wrapper.gp.gp_Vec

        """
        return _ElSLib.ElSLib__PlaneD1(*args)

    PlaneD1 = staticmethod(PlaneD1)

    def ConeD1(*args):
        """
        ConeD1(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, Standard_Real const SAngle, gp_Pnt P, gp_Vec Vu, gp_Vec Vv)

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :type SAngle: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Vu: OCC.wrapper.gp.gp_Vec
        :type Vv: OCC.wrapper.gp.gp_Vec

        """
        return _ElSLib.ElSLib__ConeD1(*args)

    ConeD1 = staticmethod(ConeD1)

    def CylinderD1(*args):
        """
        CylinderD1(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, gp_Pnt P, gp_Vec Vu, gp_Vec Vv)

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Vu: OCC.wrapper.gp.gp_Vec
        :type Vv: OCC.wrapper.gp.gp_Vec

        """
        return _ElSLib.ElSLib__CylinderD1(*args)

    CylinderD1 = staticmethod(CylinderD1)

    def SphereD1(*args):
        """
        SphereD1(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, gp_Pnt P, gp_Vec Vu, gp_Vec Vv)

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Vu: OCC.wrapper.gp.gp_Vec
        :type Vv: OCC.wrapper.gp.gp_Vec

        """
        return _ElSLib.ElSLib__SphereD1(*args)

    SphereD1 = staticmethod(SphereD1)

    def TorusD1(*args):
        """
        TorusD1(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt P, gp_Vec Vu, gp_Vec Vv)

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type MajorRadius: float
        :type MinorRadius: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Vu: OCC.wrapper.gp.gp_Vec
        :type Vv: OCC.wrapper.gp.gp_Vec

        """
        return _ElSLib.ElSLib__TorusD1(*args)

    TorusD1 = staticmethod(TorusD1)

    def ConeD2(*args):
        """
        ConeD2(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, Standard_Real const SAngle, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv)

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :type SAngle: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Vu: OCC.wrapper.gp.gp_Vec
        :type Vv: OCC.wrapper.gp.gp_Vec
        :type Vuu: OCC.wrapper.gp.gp_Vec
        :type Vvv: OCC.wrapper.gp.gp_Vec
        :type Vuv: OCC.wrapper.gp.gp_Vec

        """
        return _ElSLib.ElSLib__ConeD2(*args)

    ConeD2 = staticmethod(ConeD2)

    def CylinderD2(*args):
        """
        CylinderD2(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv)

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Vu: OCC.wrapper.gp.gp_Vec
        :type Vv: OCC.wrapper.gp.gp_Vec
        :type Vuu: OCC.wrapper.gp.gp_Vec
        :type Vvv: OCC.wrapper.gp.gp_Vec
        :type Vuv: OCC.wrapper.gp.gp_Vec

        """
        return _ElSLib.ElSLib__CylinderD2(*args)

    CylinderD2 = staticmethod(CylinderD2)

    def SphereD2(*args):
        """
        SphereD2(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv)

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Vu: OCC.wrapper.gp.gp_Vec
        :type Vv: OCC.wrapper.gp.gp_Vec
        :type Vuu: OCC.wrapper.gp.gp_Vec
        :type Vvv: OCC.wrapper.gp.gp_Vec
        :type Vuv: OCC.wrapper.gp.gp_Vec

        """
        return _ElSLib.ElSLib__SphereD2(*args)

    SphereD2 = staticmethod(SphereD2)

    def TorusD2(*args):
        """
        TorusD2(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv)

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type MajorRadius: float
        :type MinorRadius: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Vu: OCC.wrapper.gp.gp_Vec
        :type Vv: OCC.wrapper.gp.gp_Vec
        :type Vuu: OCC.wrapper.gp.gp_Vec
        :type Vvv: OCC.wrapper.gp.gp_Vec
        :type Vuv: OCC.wrapper.gp.gp_Vec

        """
        return _ElSLib.ElSLib__TorusD2(*args)

    TorusD2 = staticmethod(TorusD2)

    def ConeD3(*args):
        """
        ConeD3(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, Standard_Real const SAngle, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv, gp_Vec Vuuu, gp_Vec Vvvv, gp_Vec Vuuv, gp_Vec Vuvv)

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :type SAngle: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Vu: OCC.wrapper.gp.gp_Vec
        :type Vv: OCC.wrapper.gp.gp_Vec
        :type Vuu: OCC.wrapper.gp.gp_Vec
        :type Vvv: OCC.wrapper.gp.gp_Vec
        :type Vuv: OCC.wrapper.gp.gp_Vec
        :type Vuuu: OCC.wrapper.gp.gp_Vec
        :type Vvvv: OCC.wrapper.gp.gp_Vec
        :type Vuuv: OCC.wrapper.gp.gp_Vec
        :type Vuvv: OCC.wrapper.gp.gp_Vec

        """
        return _ElSLib.ElSLib__ConeD3(*args)

    ConeD3 = staticmethod(ConeD3)

    def CylinderD3(*args):
        """
        CylinderD3(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv, gp_Vec Vuuu, gp_Vec Vvvv, gp_Vec Vuuv, gp_Vec Vuvv)

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Vu: OCC.wrapper.gp.gp_Vec
        :type Vv: OCC.wrapper.gp.gp_Vec
        :type Vuu: OCC.wrapper.gp.gp_Vec
        :type Vvv: OCC.wrapper.gp.gp_Vec
        :type Vuv: OCC.wrapper.gp.gp_Vec
        :type Vuuu: OCC.wrapper.gp.gp_Vec
        :type Vvvv: OCC.wrapper.gp.gp_Vec
        :type Vuuv: OCC.wrapper.gp.gp_Vec
        :type Vuvv: OCC.wrapper.gp.gp_Vec

        """
        return _ElSLib.ElSLib__CylinderD3(*args)

    CylinderD3 = staticmethod(CylinderD3)

    def SphereD3(*args):
        """
        SphereD3(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv, gp_Vec Vuuu, gp_Vec Vvvv, gp_Vec Vuuv, gp_Vec Vuvv)

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Vu: OCC.wrapper.gp.gp_Vec
        :type Vv: OCC.wrapper.gp.gp_Vec
        :type Vuu: OCC.wrapper.gp.gp_Vec
        :type Vvv: OCC.wrapper.gp.gp_Vec
        :type Vuv: OCC.wrapper.gp.gp_Vec
        :type Vuuu: OCC.wrapper.gp.gp_Vec
        :type Vvvv: OCC.wrapper.gp.gp_Vec
        :type Vuuv: OCC.wrapper.gp.gp_Vec
        :type Vuvv: OCC.wrapper.gp.gp_Vec

        """
        return _ElSLib.ElSLib__SphereD3(*args)

    SphereD3 = staticmethod(SphereD3)

    def TorusD3(*args):
        """
        TorusD3(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv, gp_Vec Vuuu, gp_Vec Vvvv, gp_Vec Vuuv, gp_Vec Vuvv)

        The following functions compute the parametric values
        corresponding to a given point on a elementary surface.
        The point should be on the surface.

        :type U: float
        :type V: float
        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type MajorRadius: float
        :type MinorRadius: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Vu: OCC.wrapper.gp.gp_Vec
        :type Vv: OCC.wrapper.gp.gp_Vec
        :type Vuu: OCC.wrapper.gp.gp_Vec
        :type Vvv: OCC.wrapper.gp.gp_Vec
        :type Vuv: OCC.wrapper.gp.gp_Vec
        :type Vuuu: OCC.wrapper.gp.gp_Vec
        :type Vvvv: OCC.wrapper.gp.gp_Vec
        :type Vuuv: OCC.wrapper.gp.gp_Vec
        :type Vuvv: OCC.wrapper.gp.gp_Vec

        """
        return _ElSLib.ElSLib__TorusD3(*args)

    TorusD3 = staticmethod(TorusD3)

    def Parameters(*args):
        """
        Parameters(gp_Pln Pl, gp_Pnt P)
        Parameters(gp_Cylinder C, gp_Pnt P)
        Parameters(gp_Cone C, gp_Pnt P)
        Parameters(gp_Sphere S, gp_Pnt P)
        Parameters(gp_Torus T, gp_Pnt P)

        parametrization
        P (U, V) = Location +
        (MajorRadius + MinorRadius * Cos(U)) *
        (Cos(V) * XDirection - Sin(V) * YDirection) +
        MinorRadius * Sin(U) * ZDirection

        :type T: OCC.wrapper.gp.gp_Torus
        :type P: OCC.wrapper.gp.gp_Pnt
        :type U: float
        :type V: float

        """
        return _ElSLib.ElSLib__Parameters(*args)

    Parameters = staticmethod(Parameters)

    def PlaneParameters(*args):
        """
        PlaneParameters(gp_Ax3 Pos, gp_Pnt P)

        parametrization
        P (U, V) =
        Pl.Location() + U * Pl.XDirection() + V * Pl.YDirection()

        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type P: OCC.wrapper.gp.gp_Pnt
        :type U: float
        :type V: float

        """
        return _ElSLib.ElSLib__PlaneParameters(*args)

    PlaneParameters = staticmethod(PlaneParameters)

    def CylinderParameters(*args):
        """
        CylinderParameters(gp_Ax3 Pos, Standard_Real const Radius, gp_Pnt P)

        parametrization
        P (U, V) = Location + V * ZDirection +
        Radius * (Cos(U) * XDirection + Sin (U) * YDirection)

        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type U: float
        :type V: float

        """
        return _ElSLib.ElSLib__CylinderParameters(*args)

    CylinderParameters = staticmethod(CylinderParameters)

    def ConeParameters(*args):
        """
        ConeParameters(gp_Ax3 Pos, Standard_Real const Radius, Standard_Real const SAngle, gp_Pnt P)

        parametrization
        P (U, V) =  Location + V * ZDirection +
        (Radius + V * Tan (SemiAngle)) *
        (Cos(U) * XDirection + Sin(U) * YDirection)

        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :type SAngle: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type U: float
        :type V: float

        """
        return _ElSLib.ElSLib__ConeParameters(*args)

    ConeParameters = staticmethod(ConeParameters)

    def SphereParameters(*args):
        """
        SphereParameters(gp_Ax3 Pos, Standard_Real const Radius, gp_Pnt P)

        parametrization
        P (U, V) = Location +
        Radius * Cos (V) * (Cos (U) * XDirection + Sin (U) * YDirection) +
        Radius * Sin (V) * ZDirection

        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type U: float
        :type V: float

        """
        return _ElSLib.ElSLib__SphereParameters(*args)

    SphereParameters = staticmethod(SphereParameters)

    def TorusParameters(*args):
        """
        TorusParameters(gp_Ax3 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt P)

        parametrization
        P (U, V) = Location +
        (MajorRadius + MinorRadius * Cos(U)) *
        (Cos(V) * XDirection - Sin(V) * YDirection) +
        MinorRadius * Sin(U) * ZDirection

        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type MajorRadius: float
        :type MinorRadius: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type U: float
        :type V: float

        """
        return _ElSLib.ElSLib__TorusParameters(*args)

    TorusParameters = staticmethod(TorusParameters)

    def PlaneUIso(*args):
        """
        PlaneUIso(gp_Ax3 Pos, Standard_Real const U) -> gp_Lin

        compute the U Isoparametric gp_Lin of the plane.

        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type U: float
        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _ElSLib.ElSLib__PlaneUIso(*args)

    PlaneUIso = staticmethod(PlaneUIso)

    def CylinderUIso(*args):
        """
        CylinderUIso(gp_Ax3 Pos, Standard_Real const Radius, Standard_Real const U) -> gp_Lin

        compute the U Isoparametric gp_Lin of the cylinder.

        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :type U: float
        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _ElSLib.ElSLib__CylinderUIso(*args)

    CylinderUIso = staticmethod(CylinderUIso)

    def ConeUIso(*args):
        """
        ConeUIso(gp_Ax3 Pos, Standard_Real const Radius, Standard_Real const SAngle, Standard_Real const U) -> gp_Lin

        compute the U Isoparametric gp_Lin of the cone.

        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :type SAngle: float
        :type U: float
        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _ElSLib.ElSLib__ConeUIso(*args)

    ConeUIso = staticmethod(ConeUIso)

    def SphereUIso(*args):
        """
        SphereUIso(gp_Ax3 Pos, Standard_Real const Radius, Standard_Real const U) -> gp_Circ

        compute the U Isoparametric gp_Circ of the sphere,
        (the meridian is not trimmed).

        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :type U: float
        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _ElSLib.ElSLib__SphereUIso(*args)

    SphereUIso = staticmethod(SphereUIso)

    def TorusUIso(*args):
        """
        TorusUIso(gp_Ax3 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, Standard_Real const U) -> gp_Circ

        compute the U Isoparametric gp_Circ of the torus.

        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type MajorRadius: float
        :type MinorRadius: float
        :type U: float
        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _ElSLib.ElSLib__TorusUIso(*args)

    TorusUIso = staticmethod(TorusUIso)

    def PlaneVIso(*args):
        """
        PlaneVIso(gp_Ax3 Pos, Standard_Real const V) -> gp_Lin

        compute the V Isoparametric gp_Lin of the plane.

        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _ElSLib.ElSLib__PlaneVIso(*args)

    PlaneVIso = staticmethod(PlaneVIso)

    def CylinderVIso(*args):
        """
        CylinderVIso(gp_Ax3 Pos, Standard_Real const Radius, Standard_Real const V) -> gp_Circ

        compute the V Isoparametric gp_Circ of the cylinder.

        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _ElSLib.ElSLib__CylinderVIso(*args)

    CylinderVIso = staticmethod(CylinderVIso)

    def ConeVIso(*args):
        """
        ConeVIso(gp_Ax3 Pos, Standard_Real const Radius, Standard_Real const SAngle, Standard_Real const V) -> gp_Circ

        compute the V Isoparametric gp_Circ of the cone.

        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :type SAngle: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _ElSLib.ElSLib__ConeVIso(*args)

    ConeVIso = staticmethod(ConeVIso)

    def SphereVIso(*args):
        """
        SphereVIso(gp_Ax3 Pos, Standard_Real const Radius, Standard_Real const V) -> gp_Circ

        compute the V Isoparametric gp_Circ of the sphere,
        (the meridian is not trimmed).

        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type Radius: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _ElSLib.ElSLib__SphereVIso(*args)

    SphereVIso = staticmethod(SphereVIso)

    def TorusVIso(*args):
        """
        TorusVIso(gp_Ax3 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, Standard_Real const V) -> gp_Circ

        compute the V Isoparametric gp_Circ of the torus.

        :type Pos: OCC.wrapper.gp.gp_Ax3
        :type MajorRadius: float
        :type MinorRadius: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _ElSLib.ElSLib__TorusVIso(*args)

    TorusVIso = staticmethod(TorusVIso)

    def __init__(self):
        """
        Provides functions for basic geometric computation on
        elementary surfaces.
        This includes:
        -   calculation of a point or derived vector on a surface
        where the surface is provided by the gp package, or
        defined in canonical form (as in the gp package), and
        the point is defined with a parameter,
        -   evaluation of the parameters corresponding to a
        point on an elementary surface from gp,
        -   calculation of isoparametric curves on an elementary
        surface defined in canonical form (as in the gp package).
        Notes:
        -   ElSLib stands for Elementary Surfaces Library.
        -   If the surfaces provided by the gp package are not
        explicitly parameterized, they still have an implicit
        parameterization, similar to that which they infer on
        the equivalent Geom surfaces.
        Note: ElSLib stands for Elementary Surfaces Library.
        """
        this = _ElSLib.new_ElSLib_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ElSLib.delete_ElSLib_
ElSLib__swigregister = _ElSLib.ElSLib__swigregister
ElSLib__swigregister(ElSLib_)

def ElSLib__Value(*args):
    """
    Value(Standard_Real const U, Standard_Real const V, gp_Pln Pl) -> gp_Pnt
    Value(Standard_Real const U, Standard_Real const V, gp_Cone C) -> gp_Pnt
    Value(Standard_Real const U, Standard_Real const V, gp_Cylinder C) -> gp_Pnt
    Value(Standard_Real const U, Standard_Real const V, gp_Sphere S) -> gp_Pnt
    ElSLib__Value(Standard_Real const U, Standard_Real const V, gp_Torus T) -> gp_Pnt

    :type U: float
    :type V: float
    :type T: OCC.wrapper.gp.gp_Torus
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _ElSLib.ElSLib__Value(*args)

def ElSLib__DN(*args):
    """
    DN(Standard_Real const U, Standard_Real const V, gp_Pln Pl, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec
    DN(Standard_Real const U, Standard_Real const V, gp_Cone C, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec
    DN(Standard_Real const U, Standard_Real const V, gp_Cylinder C, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec
    DN(Standard_Real const U, Standard_Real const V, gp_Sphere S, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec
    ElSLib__DN(Standard_Real const U, Standard_Real const V, gp_Torus T, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

    :type U: float
    :type V: float
    :type T: OCC.wrapper.gp.gp_Torus
    :type Nu: int
    :type Nv: int
    :rtype: OCC.wrapper.gp.gp_Vec

    """
    return _ElSLib.ElSLib__DN(*args)

def ElSLib__D0(*args):
    """
    D0(Standard_Real const U, Standard_Real const V, gp_Pln Pl, gp_Pnt P)
    D0(Standard_Real const U, Standard_Real const V, gp_Cone C, gp_Pnt P)
    D0(Standard_Real const U, Standard_Real const V, gp_Cylinder C, gp_Pnt P)
    D0(Standard_Real const U, Standard_Real const V, gp_Sphere S, gp_Pnt P)
    ElSLib__D0(Standard_Real const U, Standard_Real const V, gp_Torus T, gp_Pnt P)

    :type U: float
    :type V: float
    :type T: OCC.wrapper.gp.gp_Torus
    :type P: OCC.wrapper.gp.gp_Pnt

    """
    return _ElSLib.ElSLib__D0(*args)

def ElSLib__D1(*args):
    """
    D1(Standard_Real const U, Standard_Real const V, gp_Pln Pl, gp_Pnt P, gp_Vec Vu, gp_Vec Vv)
    D1(Standard_Real const U, Standard_Real const V, gp_Cone C, gp_Pnt P, gp_Vec Vu, gp_Vec Vv)
    D1(Standard_Real const U, Standard_Real const V, gp_Cylinder C, gp_Pnt P, gp_Vec Vu, gp_Vec Vv)
    D1(Standard_Real const U, Standard_Real const V, gp_Sphere S, gp_Pnt P, gp_Vec Vu, gp_Vec Vv)
    ElSLib__D1(Standard_Real const U, Standard_Real const V, gp_Torus T, gp_Pnt P, gp_Vec Vu, gp_Vec Vv)

    :type U: float
    :type V: float
    :type T: OCC.wrapper.gp.gp_Torus
    :type P: OCC.wrapper.gp.gp_Pnt
    :type Vu: OCC.wrapper.gp.gp_Vec
    :type Vv: OCC.wrapper.gp.gp_Vec

    """
    return _ElSLib.ElSLib__D1(*args)

def ElSLib__D2(*args):
    """
    D2(Standard_Real const U, Standard_Real const V, gp_Cone C, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv)
    D2(Standard_Real const U, Standard_Real const V, gp_Cylinder C, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv)
    D2(Standard_Real const U, Standard_Real const V, gp_Sphere S, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv)
    ElSLib__D2(Standard_Real const U, Standard_Real const V, gp_Torus T, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv)

    :type U: float
    :type V: float
    :type T: OCC.wrapper.gp.gp_Torus
    :type P: OCC.wrapper.gp.gp_Pnt
    :type Vu: OCC.wrapper.gp.gp_Vec
    :type Vv: OCC.wrapper.gp.gp_Vec
    :type Vuu: OCC.wrapper.gp.gp_Vec
    :type Vvv: OCC.wrapper.gp.gp_Vec
    :type Vuv: OCC.wrapper.gp.gp_Vec

    """
    return _ElSLib.ElSLib__D2(*args)

def ElSLib__D3(*args):
    """
    D3(Standard_Real const U, Standard_Real const V, gp_Cone C, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv, gp_Vec Vuuu, gp_Vec Vvvv, gp_Vec Vuuv, gp_Vec Vuvv)
    D3(Standard_Real const U, Standard_Real const V, gp_Cylinder C, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv, gp_Vec Vuuu, gp_Vec Vvvv, gp_Vec Vuuv, gp_Vec Vuvv)
    D3(Standard_Real const U, Standard_Real const V, gp_Sphere S, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv, gp_Vec Vuuu, gp_Vec Vvvv, gp_Vec Vuuv, gp_Vec Vuvv)
    ElSLib__D3(Standard_Real const U, Standard_Real const V, gp_Torus T, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv, gp_Vec Vuuu, gp_Vec Vvvv, gp_Vec Vuuv, gp_Vec Vuvv)

    Surface evaluation
    The following functions compute the point and the
    derivatives on elementary surfaces defined with their
    geometric characterisitics.
    You don't need to create the surface to use these functions.
    These functions are called by the previous  ones.
    Example :
    A cylinder is defined with its position and its radius.

    :type U: float
    :type V: float
    :type T: OCC.wrapper.gp.gp_Torus
    :type P: OCC.wrapper.gp.gp_Pnt
    :type Vu: OCC.wrapper.gp.gp_Vec
    :type Vv: OCC.wrapper.gp.gp_Vec
    :type Vuu: OCC.wrapper.gp.gp_Vec
    :type Vvv: OCC.wrapper.gp.gp_Vec
    :type Vuv: OCC.wrapper.gp.gp_Vec
    :type Vuuu: OCC.wrapper.gp.gp_Vec
    :type Vvvv: OCC.wrapper.gp.gp_Vec
    :type Vuuv: OCC.wrapper.gp.gp_Vec
    :type Vuvv: OCC.wrapper.gp.gp_Vec

    """
    return _ElSLib.ElSLib__D3(*args)

def ElSLib__PlaneValue(*args):
    """
    ElSLib__PlaneValue(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos) -> gp_Pnt

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _ElSLib.ElSLib__PlaneValue(*args)

def ElSLib__CylinderValue(*args):
    """
    ElSLib__CylinderValue(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius) -> gp_Pnt

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _ElSLib.ElSLib__CylinderValue(*args)

def ElSLib__ConeValue(*args):
    """
    ElSLib__ConeValue(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, Standard_Real const SAngle) -> gp_Pnt

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :type SAngle: float
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _ElSLib.ElSLib__ConeValue(*args)

def ElSLib__SphereValue(*args):
    """
    ElSLib__SphereValue(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius) -> gp_Pnt

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _ElSLib.ElSLib__SphereValue(*args)

def ElSLib__TorusValue(*args):
    """
    ElSLib__TorusValue(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> gp_Pnt

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type MajorRadius: float
    :type MinorRadius: float
    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _ElSLib.ElSLib__TorusValue(*args)

def ElSLib__PlaneDN(*args):
    """
    ElSLib__PlaneDN(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Nu: int
    :type Nv: int
    :rtype: OCC.wrapper.gp.gp_Vec

    """
    return _ElSLib.ElSLib__PlaneDN(*args)

def ElSLib__CylinderDN(*args):
    """
    ElSLib__CylinderDN(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :type Nu: int
    :type Nv: int
    :rtype: OCC.wrapper.gp.gp_Vec

    """
    return _ElSLib.ElSLib__CylinderDN(*args)

def ElSLib__ConeDN(*args):
    """
    ElSLib__ConeDN(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, Standard_Real const SAngle, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :type SAngle: float
    :type Nu: int
    :type Nv: int
    :rtype: OCC.wrapper.gp.gp_Vec

    """
    return _ElSLib.ElSLib__ConeDN(*args)

def ElSLib__SphereDN(*args):
    """
    ElSLib__SphereDN(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :type Nu: int
    :type Nv: int
    :rtype: OCC.wrapper.gp.gp_Vec

    """
    return _ElSLib.ElSLib__SphereDN(*args)

def ElSLib__TorusDN(*args):
    """
    ElSLib__TorusDN(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, Standard_Integer const Nu, Standard_Integer const Nv) -> gp_Vec

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type MajorRadius: float
    :type MinorRadius: float
    :type Nu: int
    :type Nv: int
    :rtype: OCC.wrapper.gp.gp_Vec

    """
    return _ElSLib.ElSLib__TorusDN(*args)

def ElSLib__PlaneD0(*args):
    """
    ElSLib__PlaneD0(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, gp_Pnt P)

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type P: OCC.wrapper.gp.gp_Pnt

    """
    return _ElSLib.ElSLib__PlaneD0(*args)

def ElSLib__ConeD0(*args):
    """
    ElSLib__ConeD0(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, Standard_Real const SAngle, gp_Pnt P)

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :type SAngle: float
    :type P: OCC.wrapper.gp.gp_Pnt

    """
    return _ElSLib.ElSLib__ConeD0(*args)

def ElSLib__CylinderD0(*args):
    """
    ElSLib__CylinderD0(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, gp_Pnt P)

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :type P: OCC.wrapper.gp.gp_Pnt

    """
    return _ElSLib.ElSLib__CylinderD0(*args)

def ElSLib__SphereD0(*args):
    """
    ElSLib__SphereD0(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, gp_Pnt P)

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :type P: OCC.wrapper.gp.gp_Pnt

    """
    return _ElSLib.ElSLib__SphereD0(*args)

def ElSLib__TorusD0(*args):
    """
    ElSLib__TorusD0(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt P)

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type MajorRadius: float
    :type MinorRadius: float
    :type P: OCC.wrapper.gp.gp_Pnt

    """
    return _ElSLib.ElSLib__TorusD0(*args)

def ElSLib__PlaneD1(*args):
    """
    ElSLib__PlaneD1(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, gp_Pnt P, gp_Vec Vu, gp_Vec Vv)

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type P: OCC.wrapper.gp.gp_Pnt
    :type Vu: OCC.wrapper.gp.gp_Vec
    :type Vv: OCC.wrapper.gp.gp_Vec

    """
    return _ElSLib.ElSLib__PlaneD1(*args)

def ElSLib__ConeD1(*args):
    """
    ElSLib__ConeD1(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, Standard_Real const SAngle, gp_Pnt P, gp_Vec Vu, gp_Vec Vv)

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :type SAngle: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type Vu: OCC.wrapper.gp.gp_Vec
    :type Vv: OCC.wrapper.gp.gp_Vec

    """
    return _ElSLib.ElSLib__ConeD1(*args)

def ElSLib__CylinderD1(*args):
    """
    ElSLib__CylinderD1(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, gp_Pnt P, gp_Vec Vu, gp_Vec Vv)

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type Vu: OCC.wrapper.gp.gp_Vec
    :type Vv: OCC.wrapper.gp.gp_Vec

    """
    return _ElSLib.ElSLib__CylinderD1(*args)

def ElSLib__SphereD1(*args):
    """
    ElSLib__SphereD1(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, gp_Pnt P, gp_Vec Vu, gp_Vec Vv)

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type Vu: OCC.wrapper.gp.gp_Vec
    :type Vv: OCC.wrapper.gp.gp_Vec

    """
    return _ElSLib.ElSLib__SphereD1(*args)

def ElSLib__TorusD1(*args):
    """
    ElSLib__TorusD1(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt P, gp_Vec Vu, gp_Vec Vv)

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type MajorRadius: float
    :type MinorRadius: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type Vu: OCC.wrapper.gp.gp_Vec
    :type Vv: OCC.wrapper.gp.gp_Vec

    """
    return _ElSLib.ElSLib__TorusD1(*args)

def ElSLib__ConeD2(*args):
    """
    ElSLib__ConeD2(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, Standard_Real const SAngle, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv)

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :type SAngle: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type Vu: OCC.wrapper.gp.gp_Vec
    :type Vv: OCC.wrapper.gp.gp_Vec
    :type Vuu: OCC.wrapper.gp.gp_Vec
    :type Vvv: OCC.wrapper.gp.gp_Vec
    :type Vuv: OCC.wrapper.gp.gp_Vec

    """
    return _ElSLib.ElSLib__ConeD2(*args)

def ElSLib__CylinderD2(*args):
    """
    ElSLib__CylinderD2(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv)

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type Vu: OCC.wrapper.gp.gp_Vec
    :type Vv: OCC.wrapper.gp.gp_Vec
    :type Vuu: OCC.wrapper.gp.gp_Vec
    :type Vvv: OCC.wrapper.gp.gp_Vec
    :type Vuv: OCC.wrapper.gp.gp_Vec

    """
    return _ElSLib.ElSLib__CylinderD2(*args)

def ElSLib__SphereD2(*args):
    """
    ElSLib__SphereD2(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv)

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type Vu: OCC.wrapper.gp.gp_Vec
    :type Vv: OCC.wrapper.gp.gp_Vec
    :type Vuu: OCC.wrapper.gp.gp_Vec
    :type Vvv: OCC.wrapper.gp.gp_Vec
    :type Vuv: OCC.wrapper.gp.gp_Vec

    """
    return _ElSLib.ElSLib__SphereD2(*args)

def ElSLib__TorusD2(*args):
    """
    ElSLib__TorusD2(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv)

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type MajorRadius: float
    :type MinorRadius: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type Vu: OCC.wrapper.gp.gp_Vec
    :type Vv: OCC.wrapper.gp.gp_Vec
    :type Vuu: OCC.wrapper.gp.gp_Vec
    :type Vvv: OCC.wrapper.gp.gp_Vec
    :type Vuv: OCC.wrapper.gp.gp_Vec

    """
    return _ElSLib.ElSLib__TorusD2(*args)

def ElSLib__ConeD3(*args):
    """
    ElSLib__ConeD3(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, Standard_Real const SAngle, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv, gp_Vec Vuuu, gp_Vec Vvvv, gp_Vec Vuuv, gp_Vec Vuvv)

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :type SAngle: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type Vu: OCC.wrapper.gp.gp_Vec
    :type Vv: OCC.wrapper.gp.gp_Vec
    :type Vuu: OCC.wrapper.gp.gp_Vec
    :type Vvv: OCC.wrapper.gp.gp_Vec
    :type Vuv: OCC.wrapper.gp.gp_Vec
    :type Vuuu: OCC.wrapper.gp.gp_Vec
    :type Vvvv: OCC.wrapper.gp.gp_Vec
    :type Vuuv: OCC.wrapper.gp.gp_Vec
    :type Vuvv: OCC.wrapper.gp.gp_Vec

    """
    return _ElSLib.ElSLib__ConeD3(*args)

def ElSLib__CylinderD3(*args):
    """
    ElSLib__CylinderD3(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv, gp_Vec Vuuu, gp_Vec Vvvv, gp_Vec Vuuv, gp_Vec Vuvv)

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type Vu: OCC.wrapper.gp.gp_Vec
    :type Vv: OCC.wrapper.gp.gp_Vec
    :type Vuu: OCC.wrapper.gp.gp_Vec
    :type Vvv: OCC.wrapper.gp.gp_Vec
    :type Vuv: OCC.wrapper.gp.gp_Vec
    :type Vuuu: OCC.wrapper.gp.gp_Vec
    :type Vvvv: OCC.wrapper.gp.gp_Vec
    :type Vuuv: OCC.wrapper.gp.gp_Vec
    :type Vuvv: OCC.wrapper.gp.gp_Vec

    """
    return _ElSLib.ElSLib__CylinderD3(*args)

def ElSLib__SphereD3(*args):
    """
    ElSLib__SphereD3(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const Radius, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv, gp_Vec Vuuu, gp_Vec Vvvv, gp_Vec Vuuv, gp_Vec Vuvv)

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type Vu: OCC.wrapper.gp.gp_Vec
    :type Vv: OCC.wrapper.gp.gp_Vec
    :type Vuu: OCC.wrapper.gp.gp_Vec
    :type Vvv: OCC.wrapper.gp.gp_Vec
    :type Vuv: OCC.wrapper.gp.gp_Vec
    :type Vuuu: OCC.wrapper.gp.gp_Vec
    :type Vvvv: OCC.wrapper.gp.gp_Vec
    :type Vuuv: OCC.wrapper.gp.gp_Vec
    :type Vuvv: OCC.wrapper.gp.gp_Vec

    """
    return _ElSLib.ElSLib__SphereD3(*args)

def ElSLib__TorusD3(*args):
    """
    ElSLib__TorusD3(Standard_Real const U, Standard_Real const V, gp_Ax3 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt P, gp_Vec Vu, gp_Vec Vv, gp_Vec Vuu, gp_Vec Vvv, gp_Vec Vuv, gp_Vec Vuuu, gp_Vec Vvvv, gp_Vec Vuuv, gp_Vec Vuvv)

    The following functions compute the parametric values
    corresponding to a given point on a elementary surface.
    The point should be on the surface.

    :type U: float
    :type V: float
    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type MajorRadius: float
    :type MinorRadius: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type Vu: OCC.wrapper.gp.gp_Vec
    :type Vv: OCC.wrapper.gp.gp_Vec
    :type Vuu: OCC.wrapper.gp.gp_Vec
    :type Vvv: OCC.wrapper.gp.gp_Vec
    :type Vuv: OCC.wrapper.gp.gp_Vec
    :type Vuuu: OCC.wrapper.gp.gp_Vec
    :type Vvvv: OCC.wrapper.gp.gp_Vec
    :type Vuuv: OCC.wrapper.gp.gp_Vec
    :type Vuvv: OCC.wrapper.gp.gp_Vec

    """
    return _ElSLib.ElSLib__TorusD3(*args)

def ElSLib__Parameters(*args):
    """
    Parameters(gp_Pln Pl, gp_Pnt P)
    Parameters(gp_Cylinder C, gp_Pnt P)
    Parameters(gp_Cone C, gp_Pnt P)
    Parameters(gp_Sphere S, gp_Pnt P)
    ElSLib__Parameters(gp_Torus T, gp_Pnt P)

    parametrization
    P (U, V) = Location +
    (MajorRadius + MinorRadius * Cos(U)) *
    (Cos(V) * XDirection - Sin(V) * YDirection) +
    MinorRadius * Sin(U) * ZDirection

    :type T: OCC.wrapper.gp.gp_Torus
    :type P: OCC.wrapper.gp.gp_Pnt
    :type U: float
    :type V: float

    """
    return _ElSLib.ElSLib__Parameters(*args)

def ElSLib__PlaneParameters(*args):
    """
    ElSLib__PlaneParameters(gp_Ax3 Pos, gp_Pnt P)

    parametrization
    P (U, V) =
    Pl.Location() + U * Pl.XDirection() + V * Pl.YDirection()

    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type P: OCC.wrapper.gp.gp_Pnt
    :type U: float
    :type V: float

    """
    return _ElSLib.ElSLib__PlaneParameters(*args)

def ElSLib__CylinderParameters(*args):
    """
    ElSLib__CylinderParameters(gp_Ax3 Pos, Standard_Real const Radius, gp_Pnt P)

    parametrization
    P (U, V) = Location + V * ZDirection +
    Radius * (Cos(U) * XDirection + Sin (U) * YDirection)

    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type U: float
    :type V: float

    """
    return _ElSLib.ElSLib__CylinderParameters(*args)

def ElSLib__ConeParameters(*args):
    """
    ElSLib__ConeParameters(gp_Ax3 Pos, Standard_Real const Radius, Standard_Real const SAngle, gp_Pnt P)

    parametrization
    P (U, V) =  Location + V * ZDirection +
    (Radius + V * Tan (SemiAngle)) *
    (Cos(U) * XDirection + Sin(U) * YDirection)

    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :type SAngle: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type U: float
    :type V: float

    """
    return _ElSLib.ElSLib__ConeParameters(*args)

def ElSLib__SphereParameters(*args):
    """
    ElSLib__SphereParameters(gp_Ax3 Pos, Standard_Real const Radius, gp_Pnt P)

    parametrization
    P (U, V) = Location +
    Radius * Cos (V) * (Cos (U) * XDirection + Sin (U) * YDirection) +
    Radius * Sin (V) * ZDirection

    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type U: float
    :type V: float

    """
    return _ElSLib.ElSLib__SphereParameters(*args)

def ElSLib__TorusParameters(*args):
    """
    ElSLib__TorusParameters(gp_Ax3 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, gp_Pnt P)

    parametrization
    P (U, V) = Location +
    (MajorRadius + MinorRadius * Cos(U)) *
    (Cos(V) * XDirection - Sin(V) * YDirection) +
    MinorRadius * Sin(U) * ZDirection

    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type MajorRadius: float
    :type MinorRadius: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type U: float
    :type V: float

    """
    return _ElSLib.ElSLib__TorusParameters(*args)

def ElSLib__PlaneUIso(*args):
    """
    ElSLib__PlaneUIso(gp_Ax3 Pos, Standard_Real const U) -> gp_Lin

    compute the U Isoparametric gp_Lin of the plane.

    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type U: float
    :rtype: OCC.wrapper.gp.gp_Lin

    """
    return _ElSLib.ElSLib__PlaneUIso(*args)

def ElSLib__CylinderUIso(*args):
    """
    ElSLib__CylinderUIso(gp_Ax3 Pos, Standard_Real const Radius, Standard_Real const U) -> gp_Lin

    compute the U Isoparametric gp_Lin of the cylinder.

    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :type U: float
    :rtype: OCC.wrapper.gp.gp_Lin

    """
    return _ElSLib.ElSLib__CylinderUIso(*args)

def ElSLib__ConeUIso(*args):
    """
    ElSLib__ConeUIso(gp_Ax3 Pos, Standard_Real const Radius, Standard_Real const SAngle, Standard_Real const U) -> gp_Lin

    compute the U Isoparametric gp_Lin of the cone.

    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :type SAngle: float
    :type U: float
    :rtype: OCC.wrapper.gp.gp_Lin

    """
    return _ElSLib.ElSLib__ConeUIso(*args)

def ElSLib__SphereUIso(*args):
    """
    ElSLib__SphereUIso(gp_Ax3 Pos, Standard_Real const Radius, Standard_Real const U) -> gp_Circ

    compute the U Isoparametric gp_Circ of the sphere,
    (the meridian is not trimmed).

    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :type U: float
    :rtype: OCC.wrapper.gp.gp_Circ

    """
    return _ElSLib.ElSLib__SphereUIso(*args)

def ElSLib__TorusUIso(*args):
    """
    ElSLib__TorusUIso(gp_Ax3 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, Standard_Real const U) -> gp_Circ

    compute the U Isoparametric gp_Circ of the torus.

    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type MajorRadius: float
    :type MinorRadius: float
    :type U: float
    :rtype: OCC.wrapper.gp.gp_Circ

    """
    return _ElSLib.ElSLib__TorusUIso(*args)

def ElSLib__PlaneVIso(*args):
    """
    ElSLib__PlaneVIso(gp_Ax3 Pos, Standard_Real const V) -> gp_Lin

    compute the V Isoparametric gp_Lin of the plane.

    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type V: float
    :rtype: OCC.wrapper.gp.gp_Lin

    """
    return _ElSLib.ElSLib__PlaneVIso(*args)

def ElSLib__CylinderVIso(*args):
    """
    ElSLib__CylinderVIso(gp_Ax3 Pos, Standard_Real const Radius, Standard_Real const V) -> gp_Circ

    compute the V Isoparametric gp_Circ of the cylinder.

    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :type V: float
    :rtype: OCC.wrapper.gp.gp_Circ

    """
    return _ElSLib.ElSLib__CylinderVIso(*args)

def ElSLib__ConeVIso(*args):
    """
    ElSLib__ConeVIso(gp_Ax3 Pos, Standard_Real const Radius, Standard_Real const SAngle, Standard_Real const V) -> gp_Circ

    compute the V Isoparametric gp_Circ of the cone.

    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :type SAngle: float
    :type V: float
    :rtype: OCC.wrapper.gp.gp_Circ

    """
    return _ElSLib.ElSLib__ConeVIso(*args)

def ElSLib__SphereVIso(*args):
    """
    ElSLib__SphereVIso(gp_Ax3 Pos, Standard_Real const Radius, Standard_Real const V) -> gp_Circ

    compute the V Isoparametric gp_Circ of the sphere,
    (the meridian is not trimmed).

    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type Radius: float
    :type V: float
    :rtype: OCC.wrapper.gp.gp_Circ

    """
    return _ElSLib.ElSLib__SphereVIso(*args)

def ElSLib__TorusVIso(*args):
    """
    ElSLib__TorusVIso(gp_Ax3 Pos, Standard_Real const MajorRadius, Standard_Real const MinorRadius, Standard_Real const V) -> gp_Circ

    compute the V Isoparametric gp_Circ of the torus.

    :type Pos: OCC.wrapper.gp.gp_Ax3
    :type MajorRadius: float
    :type MinorRadius: float
    :type V: float
    :rtype: OCC.wrapper.gp.gp_Circ

    """
    return _ElSLib.ElSLib__TorusVIso(*args)




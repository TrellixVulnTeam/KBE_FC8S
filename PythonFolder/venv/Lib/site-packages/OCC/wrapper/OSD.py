# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_OSD')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_OSD')
    _OSD = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_OSD', [dirname(__file__)])
        except ImportError:
            import _OSD
            return _OSD
        try:
            _mod = imp.load_module('_OSD', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _OSD = swig_import_helper()
    del swig_import_helper
else:
    import _OSD
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _OSD.delete_SwigPyIterator

    def value(self):
        return _OSD.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _OSD.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _OSD.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _OSD.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _OSD.SwigPyIterator_equal(self, x)

    def copy(self):
        return _OSD.SwigPyIterator_copy(self)

    def next(self):
        return _OSD.SwigPyIterator_next(self)

    def __next__(self):
        return _OSD.SwigPyIterator___next__(self)

    def previous(self):
        return _OSD.SwigPyIterator_previous(self)

    def advance(self, n):
        return _OSD.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _OSD.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _OSD.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _OSD.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _OSD.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _OSD.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _OSD.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _OSD.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _OSD.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_OSD.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _OSD.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _OSD.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OSD.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _OSD.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _OSD.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _OSD.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _OSD.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_OSD.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _OSD.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _OSD.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OSD.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _OSD.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _OSD.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _OSD.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _OSD.ptr_to_number(item)
ptr_to_number = _OSD.ptr_to_number

def HashCode(*args):
    return _OSD.HashCode(*args)
HashCode = _OSD.HashCode

def ptr_equal(a, b):
    return _OSD.ptr_equal(a, b)
ptr_equal = _OSD.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
OSD_Unknown = _OSD.OSD_Unknown
OSD_Default = _OSD.OSD_Default
OSD_UnixBSD = _OSD.OSD_UnixBSD
OSD_UnixSystemV = _OSD.OSD_UnixSystemV
OSD_VMS = _OSD.OSD_VMS
OSD_OS2 = _OSD.OSD_OS2
OSD_OSF = _OSD.OSD_OSF
OSD_MacOs = _OSD.OSD_MacOs
OSD_Taligent = _OSD.OSD_Taligent
OSD_WindowsNT = _OSD.OSD_WindowsNT
OSD_LinuxREDHAT = _OSD.OSD_LinuxREDHAT
OSD_Aix = _OSD.OSD_Aix
OSD_WDirectory = _OSD.OSD_WDirectory
OSD_WDirectoryIterator = _OSD.OSD_WDirectoryIterator
OSD_WEnvironment = _OSD.OSD_WEnvironment
OSD_WFile = _OSD.OSD_WFile
OSD_WFileNode = _OSD.OSD_WFileNode
OSD_WFileIterator = _OSD.OSD_WFileIterator
OSD_WPath = _OSD.OSD_WPath
OSD_WProcess = _OSD.OSD_WProcess
OSD_WProtection = _OSD.OSD_WProtection
OSD_WHost = _OSD.OSD_WHost
OSD_WDisk = _OSD.OSD_WDisk
OSD_WChronometer = _OSD.OSD_WChronometer
OSD_WTimer = _OSD.OSD_WTimer
OSD_WPackage = _OSD.OSD_WPackage
OSD_WEnvironmentIterator = _OSD.OSD_WEnvironmentIterator
OSD_FromBeginning = _OSD.OSD_FromBeginning
OSD_FromHere = _OSD.OSD_FromHere
OSD_FromEnd = _OSD.OSD_FromEnd
OSD_FILE = _OSD.OSD_FILE
OSD_DIRECTORY = _OSD.OSD_DIRECTORY
OSD_LINK = _OSD.OSD_LINK
OSD_SOCKET = _OSD.OSD_SOCKET
OSD_UNKNOWN = _OSD.OSD_UNKNOWN
OSD_NoLock = _OSD.OSD_NoLock
OSD_ReadLock = _OSD.OSD_ReadLock
OSD_WriteLock = _OSD.OSD_WriteLock
OSD_ExclusiveLock = _OSD.OSD_ExclusiveLock
OSD_ReadOnly = _OSD.OSD_ReadOnly
OSD_WriteOnly = _OSD.OSD_WriteOnly
OSD_ReadWrite = _OSD.OSD_ReadWrite
OSD_Unavailable = _OSD.OSD_Unavailable
OSD_SUN = _OSD.OSD_SUN
OSD_DEC = _OSD.OSD_DEC
OSD_SGI = _OSD.OSD_SGI
OSD_NEC = _OSD.OSD_NEC
OSD_MAC = _OSD.OSD_MAC
OSD_PC = _OSD.OSD_PC
OSD_HP = _OSD.OSD_HP
OSD_IBM = _OSD.OSD_IBM
OSD_VAX = _OSD.OSD_VAX
OSD_LIN = _OSD.OSD_LIN
OSD_AIX = _OSD.OSD_AIX
OSD_RTLD_LAZY = _OSD.OSD_RTLD_LAZY
OSD_RTLD_NOW = _OSD.OSD_RTLD_NOW
OSD_None = _OSD.OSD_None
OSD_R = _OSD.OSD_R
OSD_W = _OSD.OSD_W
OSD_RW = _OSD.OSD_RW
OSD_X = _OSD.OSD_X
OSD_RX = _OSD.OSD_RX
OSD_WX = _OSD.OSD_WX
OSD_RWX = _OSD.OSD_RWX
OSD_D = _OSD.OSD_D
OSD_RD = _OSD.OSD_RD
OSD_WD = _OSD.OSD_WD
OSD_RWD = _OSD.OSD_RWD
OSD_XD = _OSD.OSD_XD
OSD_RXD = _OSD.OSD_RXD
OSD_WXD = _OSD.OSD_WXD
OSD_RWXD = _OSD.OSD_RWXD
class OSD_Signal(Standard.Standard_Failure):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_Signal
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_Signal(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_Signal self) -> OSD_Signal
        __init__(OSD_Signal self, Standard_CString const theMessage) -> OSD_Signal

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_Signal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_Signal

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Signal

        """
        return _OSD.OSD_Signal_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_Signal_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_Signal_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_Signal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_Signal
OSD_Signal_swigregister = _OSD.OSD_Signal_swigregister
OSD_Signal_swigregister(OSD_Signal)

def OSD_Signal_NewInstance(*args):
    """
    OSD_Signal_NewInstance(Standard_CString const theMessage) -> Handle_OSD_Signal

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_Signal

    """
    return _OSD.OSD_Signal_NewInstance(*args)

def OSD_Signal_get_type_name(*args):
    """
    OSD_Signal_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_Signal_get_type_name(*args)

def OSD_Signal_get_type_descriptor(*args):
    """
    OSD_Signal_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_Signal_get_type_descriptor(*args)

class OSD_Exception(Standard.Standard_Failure):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_Exception
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_Exception(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_Exception self) -> OSD_Exception
        __init__(OSD_Exception self, Standard_CString const theMessage) -> OSD_Exception

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_Exception(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception

        """
        return _OSD.OSD_Exception_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_Exception_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_Exception_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_Exception_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_Exception
OSD_Exception_swigregister = _OSD.OSD_Exception_swigregister
OSD_Exception_swigregister(OSD_Exception)

def OSD_Exception_NewInstance(*args):
    """
    OSD_Exception_NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_Exception

    """
    return _OSD.OSD_Exception_NewInstance(*args)

def OSD_Exception_get_type_name(*args):
    """
    OSD_Exception_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_Exception_get_type_name(*args)

def OSD_Exception_get_type_descriptor(*args):
    """
    OSD_Exception_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_Exception_get_type_descriptor(*args)

class OSD_SIGSEGV(OSD_Signal):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_SIGSEGV
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_SIGSEGV(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_SIGSEGV self) -> OSD_SIGSEGV
        __init__(OSD_SIGSEGV self, Standard_CString const theMessage) -> OSD_SIGSEGV

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_SIGSEGV(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_SIGSEGV

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_SIGSEGV

        """
        return _OSD.OSD_SIGSEGV_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_SIGSEGV_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_SIGSEGV_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_SIGSEGV_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_SIGSEGV
OSD_SIGSEGV_swigregister = _OSD.OSD_SIGSEGV_swigregister
OSD_SIGSEGV_swigregister(OSD_SIGSEGV)

def OSD_SIGSEGV_NewInstance(*args):
    """
    OSD_SIGSEGV_NewInstance(Standard_CString const theMessage) -> Handle_OSD_SIGSEGV

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_SIGSEGV

    """
    return _OSD.OSD_SIGSEGV_NewInstance(*args)

def OSD_SIGSEGV_get_type_name(*args):
    """
    OSD_SIGSEGV_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_SIGSEGV_get_type_name(*args)

def OSD_SIGSEGV_get_type_descriptor(*args):
    """
    OSD_SIGSEGV_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_SIGSEGV_get_type_descriptor(*args)

class OSD_FileNode(object):
    """
    A class for 'File' and 'Directory' grouping common
    methods (file/directory manipulation tools).
    The "file oriented" name means files or directories which are
    in fact hard coded as files.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Path(self, *args):
        """
        Path(OSD_FileNode self, OSD_Path Name)

        Gets file name and path.

        :type Name: OCC.wrapper.OSD.OSD_Path

        """
        return _OSD.OSD_FileNode_Path(self, *args)


    def SetPath(self, *args):
        """
        SetPath(OSD_FileNode self, OSD_Path Name)

        Sets file name and path.
        If a name is not found, it raises a program error.

        :type Name: OCC.wrapper.OSD.OSD_Path

        """
        return _OSD.OSD_FileNode_SetPath(self, *args)


    def Exists(self, *args):
        """
        Exists(OSD_FileNode self) -> Standard_Boolean

        Returns TRUE if <me> exists.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.OSD_FileNode_Exists(self, *args)


    def Remove(self, *args):
        """
        Remove(OSD_FileNode self)

        Erases the FileNode from directory


        """
        return _OSD.OSD_FileNode_Remove(self, *args)


    def Move(self, *args):
        """
        Move(OSD_FileNode self, OSD_Path NewPath)

        Moves <me> into another directory

        :type NewPath: OCC.wrapper.OSD.OSD_Path

        """
        return _OSD.OSD_FileNode_Move(self, *args)


    def Copy(self, *args):
        """
        Copy(OSD_FileNode self, OSD_Path ToPath)

        Copies <me> to another FileNode

        :type ToPath: OCC.wrapper.OSD.OSD_Path

        """
        return _OSD.OSD_FileNode_Copy(self, *args)


    def Protection(self, *args):
        """
        Protection(OSD_FileNode self) -> OSD_Protection

        Returns access mode of <me>.

        :rtype: OCC.wrapper.OSD.OSD_Protection

        """
        return _OSD.OSD_FileNode_Protection(self, *args)


    def SetProtection(self, *args):
        """
        SetProtection(OSD_FileNode self, OSD_Protection Prot)

        Changes protection of the FileNode

        :type Prot: OCC.wrapper.OSD.OSD_Protection

        """
        return _OSD.OSD_FileNode_SetProtection(self, *args)


    def AccessMoment(self, *args):
        """
        AccessMoment(OSD_FileNode self) -> Quantity_Date

        Returns last write access.
        On UNIX, AccessMoment and CreationMoment return the
        same value.

        :rtype: OCC.wrapper.Quantity.Quantity_Date

        """
        return _OSD.OSD_FileNode_AccessMoment(self, *args)


    def CreationMoment(self, *args):
        """
        CreationMoment(OSD_FileNode self) -> Quantity_Date

        Returns creation date.
        On UNIX, AccessMoment and CreationMoment return the
        same value.

        :rtype: OCC.wrapper.Quantity.Quantity_Date

        """
        return _OSD.OSD_FileNode_CreationMoment(self, *args)


    def Failed(self, *args):
        """
        Failed(OSD_FileNode self) -> Standard_Boolean

        Returns TRUE if an error occurs

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.OSD_FileNode_Failed(self, *args)


    def Reset(self, *args):
        """
        Reset(OSD_FileNode self)

        Resets error counter to zero


        """
        return _OSD.OSD_FileNode_Reset(self, *args)


    def Perror(self, *args):
        """
        Perror(OSD_FileNode self)

        Raises OSD_Error


        """
        return _OSD.OSD_FileNode_Perror(self, *args)


    def Error(self, *args):
        """
        Error(OSD_FileNode self) -> Standard_Integer

        Returns error number if 'Failed' is TRUE.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.OSD_FileNode_Error(self, *args)

OSD_FileNode_swigregister = _OSD.OSD_FileNode_swigregister
OSD_FileNode_swigregister(OSD_FileNode)

class OSD_SIGHUP(OSD_Signal):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_SIGHUP
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_SIGHUP(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_SIGHUP self) -> OSD_SIGHUP
        __init__(OSD_SIGHUP self, Standard_CString const theMessage) -> OSD_SIGHUP

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_SIGHUP(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_SIGHUP

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_SIGHUP

        """
        return _OSD.OSD_SIGHUP_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_SIGHUP_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_SIGHUP_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_SIGHUP_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_SIGHUP
OSD_SIGHUP_swigregister = _OSD.OSD_SIGHUP_swigregister
OSD_SIGHUP_swigregister(OSD_SIGHUP)

def OSD_SIGHUP_NewInstance(*args):
    """
    OSD_SIGHUP_NewInstance(Standard_CString const theMessage) -> Handle_OSD_SIGHUP

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_SIGHUP

    """
    return _OSD.OSD_SIGHUP_NewInstance(*args)

def OSD_SIGHUP_get_type_name(*args):
    """
    OSD_SIGHUP_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_SIGHUP_get_type_name(*args)

def OSD_SIGHUP_get_type_descriptor(*args):
    """
    OSD_SIGHUP_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_SIGHUP_get_type_descriptor(*args)

class OSD_Exception_STACK_OVERFLOW(OSD_Exception):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_Exception_STACK_OVERFLOW
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_Exception_STACK_OVERFLOW(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_Exception_STACK_OVERFLOW self) -> OSD_Exception_STACK_OVERFLOW
        __init__(OSD_Exception_STACK_OVERFLOW self, Standard_CString const theMessage) -> OSD_Exception_STACK_OVERFLOW

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_Exception_STACK_OVERFLOW(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_STACK_OVERFLOW

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_STACK_OVERFLOW

        """
        return _OSD.OSD_Exception_STACK_OVERFLOW_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_Exception_STACK_OVERFLOW_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_Exception_STACK_OVERFLOW_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_Exception_STACK_OVERFLOW_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_Exception_STACK_OVERFLOW
OSD_Exception_STACK_OVERFLOW_swigregister = _OSD.OSD_Exception_STACK_OVERFLOW_swigregister
OSD_Exception_STACK_OVERFLOW_swigregister(OSD_Exception_STACK_OVERFLOW)

def OSD_Exception_STACK_OVERFLOW_NewInstance(*args):
    """
    OSD_Exception_STACK_OVERFLOW_NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_STACK_OVERFLOW

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_STACK_OVERFLOW

    """
    return _OSD.OSD_Exception_STACK_OVERFLOW_NewInstance(*args)

def OSD_Exception_STACK_OVERFLOW_get_type_name(*args):
    """
    OSD_Exception_STACK_OVERFLOW_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_Exception_STACK_OVERFLOW_get_type_name(*args)

def OSD_Exception_STACK_OVERFLOW_get_type_descriptor(*args):
    """
    OSD_Exception_STACK_OVERFLOW_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_Exception_STACK_OVERFLOW_get_type_descriptor(*args)

class OSD_SIGINT(OSD_Signal):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_SIGINT
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_SIGINT(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_SIGINT self) -> OSD_SIGINT
        __init__(OSD_SIGINT self, Standard_CString const theMessage) -> OSD_SIGINT

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_SIGINT(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_SIGINT

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_SIGINT

        """
        return _OSD.OSD_SIGINT_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_SIGINT_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_SIGINT_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_SIGINT_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_SIGINT
OSD_SIGINT_swigregister = _OSD.OSD_SIGINT_swigregister
OSD_SIGINT_swigregister(OSD_SIGINT)

def OSD_SIGINT_NewInstance(*args):
    """
    OSD_SIGINT_NewInstance(Standard_CString const theMessage) -> Handle_OSD_SIGINT

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_SIGINT

    """
    return _OSD.OSD_SIGINT_NewInstance(*args)

def OSD_SIGINT_get_type_name(*args):
    """
    OSD_SIGINT_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_SIGINT_get_type_name(*args)

def OSD_SIGINT_get_type_descriptor(*args):
    """
    OSD_SIGINT_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_SIGINT_get_type_descriptor(*args)

class OSD_SIGBUS(OSD_Signal):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_SIGBUS
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_SIGBUS(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_SIGBUS self) -> OSD_SIGBUS
        __init__(OSD_SIGBUS self, Standard_CString const theMessage) -> OSD_SIGBUS

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_SIGBUS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_SIGBUS

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_SIGBUS

        """
        return _OSD.OSD_SIGBUS_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_SIGBUS_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_SIGBUS_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_SIGBUS_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_SIGBUS
OSD_SIGBUS_swigregister = _OSD.OSD_SIGBUS_swigregister
OSD_SIGBUS_swigregister(OSD_SIGBUS)

def OSD_SIGBUS_NewInstance(*args):
    """
    OSD_SIGBUS_NewInstance(Standard_CString const theMessage) -> Handle_OSD_SIGBUS

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_SIGBUS

    """
    return _OSD.OSD_SIGBUS_NewInstance(*args)

def OSD_SIGBUS_get_type_name(*args):
    """
    OSD_SIGBUS_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_SIGBUS_get_type_name(*args)

def OSD_SIGBUS_get_type_descriptor(*args):
    """
    OSD_SIGBUS_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_SIGBUS_get_type_descriptor(*args)

class OSD_Exception_INT_OVERFLOW(OSD_Exception):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_Exception_INT_OVERFLOW
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_Exception_INT_OVERFLOW(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_Exception_INT_OVERFLOW self) -> OSD_Exception_INT_OVERFLOW
        __init__(OSD_Exception_INT_OVERFLOW self, Standard_CString const theMessage) -> OSD_Exception_INT_OVERFLOW

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_Exception_INT_OVERFLOW(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_INT_OVERFLOW

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_INT_OVERFLOW

        """
        return _OSD.OSD_Exception_INT_OVERFLOW_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_Exception_INT_OVERFLOW_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_Exception_INT_OVERFLOW_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_Exception_INT_OVERFLOW_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_Exception_INT_OVERFLOW
OSD_Exception_INT_OVERFLOW_swigregister = _OSD.OSD_Exception_INT_OVERFLOW_swigregister
OSD_Exception_INT_OVERFLOW_swigregister(OSD_Exception_INT_OVERFLOW)

def OSD_Exception_INT_OVERFLOW_NewInstance(*args):
    """
    OSD_Exception_INT_OVERFLOW_NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_INT_OVERFLOW

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_INT_OVERFLOW

    """
    return _OSD.OSD_Exception_INT_OVERFLOW_NewInstance(*args)

def OSD_Exception_INT_OVERFLOW_get_type_name(*args):
    """
    OSD_Exception_INT_OVERFLOW_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_Exception_INT_OVERFLOW_get_type_name(*args)

def OSD_Exception_INT_OVERFLOW_get_type_descriptor(*args):
    """
    OSD_Exception_INT_OVERFLOW_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_Exception_INT_OVERFLOW_get_type_descriptor(*args)

class OSD_Exception_INVALID_DISPOSITION(OSD_Exception):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_Exception_INVALID_DISPOSITION
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_Exception_INVALID_DISPOSITION(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_Exception_INVALID_DISPOSITION self) -> OSD_Exception_INVALID_DISPOSITION
        __init__(OSD_Exception_INVALID_DISPOSITION self, Standard_CString const theMessage) -> OSD_Exception_INVALID_DISPOSITION

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_Exception_INVALID_DISPOSITION(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_INVALID_DISPOSITION

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_INVALID_DISPOSITION

        """
        return _OSD.OSD_Exception_INVALID_DISPOSITION_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_Exception_INVALID_DISPOSITION_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_Exception_INVALID_DISPOSITION_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_Exception_INVALID_DISPOSITION_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_Exception_INVALID_DISPOSITION
OSD_Exception_INVALID_DISPOSITION_swigregister = _OSD.OSD_Exception_INVALID_DISPOSITION_swigregister
OSD_Exception_INVALID_DISPOSITION_swigregister(OSD_Exception_INVALID_DISPOSITION)

def OSD_Exception_INVALID_DISPOSITION_NewInstance(*args):
    """
    OSD_Exception_INVALID_DISPOSITION_NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_INVALID_DISPOSITION

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_INVALID_DISPOSITION

    """
    return _OSD.OSD_Exception_INVALID_DISPOSITION_NewInstance(*args)

def OSD_Exception_INVALID_DISPOSITION_get_type_name(*args):
    """
    OSD_Exception_INVALID_DISPOSITION_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_Exception_INVALID_DISPOSITION_get_type_name(*args)

def OSD_Exception_INVALID_DISPOSITION_get_type_descriptor(*args):
    """
    OSD_Exception_INVALID_DISPOSITION_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_Exception_INVALID_DISPOSITION_get_type_descriptor(*args)

class OSD_Exception_FLT_STACK_CHECK(OSD_Exception):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_Exception_FLT_STACK_CHECK
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_Exception_FLT_STACK_CHECK(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_Exception_FLT_STACK_CHECK self) -> OSD_Exception_FLT_STACK_CHECK
        __init__(OSD_Exception_FLT_STACK_CHECK self, Standard_CString const theMessage) -> OSD_Exception_FLT_STACK_CHECK

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_Exception_FLT_STACK_CHECK(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_FLT_STACK_CHECK

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_FLT_STACK_CHECK

        """
        return _OSD.OSD_Exception_FLT_STACK_CHECK_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_Exception_FLT_STACK_CHECK_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_Exception_FLT_STACK_CHECK_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_Exception_FLT_STACK_CHECK_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_Exception_FLT_STACK_CHECK
OSD_Exception_FLT_STACK_CHECK_swigregister = _OSD.OSD_Exception_FLT_STACK_CHECK_swigregister
OSD_Exception_FLT_STACK_CHECK_swigregister(OSD_Exception_FLT_STACK_CHECK)

def OSD_Exception_FLT_STACK_CHECK_NewInstance(*args):
    """
    OSD_Exception_FLT_STACK_CHECK_NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_FLT_STACK_CHECK

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_FLT_STACK_CHECK

    """
    return _OSD.OSD_Exception_FLT_STACK_CHECK_NewInstance(*args)

def OSD_Exception_FLT_STACK_CHECK_get_type_name(*args):
    """
    OSD_Exception_FLT_STACK_CHECK_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_Exception_FLT_STACK_CHECK_get_type_name(*args)

def OSD_Exception_FLT_STACK_CHECK_get_type_descriptor(*args):
    """
    OSD_Exception_FLT_STACK_CHECK_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_Exception_FLT_STACK_CHECK_get_type_descriptor(*args)

class OSD_Exception_FLT_DENORMAL_OPERAND(OSD_Exception):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_Exception_FLT_DENORMAL_OPERAND
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_Exception_FLT_DENORMAL_OPERAND(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_Exception_FLT_DENORMAL_OPERAND self) -> OSD_Exception_FLT_DENORMAL_OPERAND
        __init__(OSD_Exception_FLT_DENORMAL_OPERAND self, Standard_CString const theMessage) -> OSD_Exception_FLT_DENORMAL_OPERAND

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_Exception_FLT_DENORMAL_OPERAND(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_FLT_DENORMAL_OPERAND

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND

        """
        return _OSD.OSD_Exception_FLT_DENORMAL_OPERAND_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_Exception_FLT_DENORMAL_OPERAND_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_Exception_FLT_DENORMAL_OPERAND_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_Exception_FLT_DENORMAL_OPERAND_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_Exception_FLT_DENORMAL_OPERAND
OSD_Exception_FLT_DENORMAL_OPERAND_swigregister = _OSD.OSD_Exception_FLT_DENORMAL_OPERAND_swigregister
OSD_Exception_FLT_DENORMAL_OPERAND_swigregister(OSD_Exception_FLT_DENORMAL_OPERAND)

def OSD_Exception_FLT_DENORMAL_OPERAND_NewInstance(*args):
    """
    OSD_Exception_FLT_DENORMAL_OPERAND_NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_FLT_DENORMAL_OPERAND

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND

    """
    return _OSD.OSD_Exception_FLT_DENORMAL_OPERAND_NewInstance(*args)

def OSD_Exception_FLT_DENORMAL_OPERAND_get_type_name(*args):
    """
    OSD_Exception_FLT_DENORMAL_OPERAND_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_Exception_FLT_DENORMAL_OPERAND_get_type_name(*args)

def OSD_Exception_FLT_DENORMAL_OPERAND_get_type_descriptor(*args):
    """
    OSD_Exception_FLT_DENORMAL_OPERAND_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_Exception_FLT_DENORMAL_OPERAND_get_type_descriptor(*args)

class OSD_Exception_FLT_UNDERFLOW(OSD_Exception):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_Exception_FLT_UNDERFLOW
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_Exception_FLT_UNDERFLOW(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_Exception_FLT_UNDERFLOW self) -> OSD_Exception_FLT_UNDERFLOW
        __init__(OSD_Exception_FLT_UNDERFLOW self, Standard_CString const theMessage) -> OSD_Exception_FLT_UNDERFLOW

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_Exception_FLT_UNDERFLOW(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_FLT_UNDERFLOW

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_FLT_UNDERFLOW

        """
        return _OSD.OSD_Exception_FLT_UNDERFLOW_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_Exception_FLT_UNDERFLOW_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_Exception_FLT_UNDERFLOW_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_Exception_FLT_UNDERFLOW_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_Exception_FLT_UNDERFLOW
OSD_Exception_FLT_UNDERFLOW_swigregister = _OSD.OSD_Exception_FLT_UNDERFLOW_swigregister
OSD_Exception_FLT_UNDERFLOW_swigregister(OSD_Exception_FLT_UNDERFLOW)

def OSD_Exception_FLT_UNDERFLOW_NewInstance(*args):
    """
    OSD_Exception_FLT_UNDERFLOW_NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_FLT_UNDERFLOW

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_FLT_UNDERFLOW

    """
    return _OSD.OSD_Exception_FLT_UNDERFLOW_NewInstance(*args)

def OSD_Exception_FLT_UNDERFLOW_get_type_name(*args):
    """
    OSD_Exception_FLT_UNDERFLOW_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_Exception_FLT_UNDERFLOW_get_type_name(*args)

def OSD_Exception_FLT_UNDERFLOW_get_type_descriptor(*args):
    """
    OSD_Exception_FLT_UNDERFLOW_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_Exception_FLT_UNDERFLOW_get_type_descriptor(*args)

class OSD_SIGKILL(OSD_Signal):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_SIGKILL
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_SIGKILL(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_SIGKILL self) -> OSD_SIGKILL
        __init__(OSD_SIGKILL self, Standard_CString const theMessage) -> OSD_SIGKILL

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_SIGKILL(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_SIGKILL

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_SIGKILL

        """
        return _OSD.OSD_SIGKILL_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_SIGKILL_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_SIGKILL_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_SIGKILL_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_SIGKILL
OSD_SIGKILL_swigregister = _OSD.OSD_SIGKILL_swigregister
OSD_SIGKILL_swigregister(OSD_SIGKILL)

def OSD_SIGKILL_NewInstance(*args):
    """
    OSD_SIGKILL_NewInstance(Standard_CString const theMessage) -> Handle_OSD_SIGKILL

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_SIGKILL

    """
    return _OSD.OSD_SIGKILL_NewInstance(*args)

def OSD_SIGKILL_get_type_name(*args):
    """
    OSD_SIGKILL_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_SIGKILL_get_type_name(*args)

def OSD_SIGKILL_get_type_descriptor(*args):
    """
    OSD_SIGKILL_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_SIGKILL_get_type_descriptor(*args)

class OSD_Exception_ACCESS_VIOLATION(OSD_Exception):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_Exception_ACCESS_VIOLATION
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_Exception_ACCESS_VIOLATION(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_Exception_ACCESS_VIOLATION self) -> OSD_Exception_ACCESS_VIOLATION
        __init__(OSD_Exception_ACCESS_VIOLATION self, Standard_CString const theMessage) -> OSD_Exception_ACCESS_VIOLATION

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_Exception_ACCESS_VIOLATION(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_ACCESS_VIOLATION

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_ACCESS_VIOLATION

        """
        return _OSD.OSD_Exception_ACCESS_VIOLATION_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_Exception_ACCESS_VIOLATION_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_Exception_ACCESS_VIOLATION_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_Exception_ACCESS_VIOLATION_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_Exception_ACCESS_VIOLATION
OSD_Exception_ACCESS_VIOLATION_swigregister = _OSD.OSD_Exception_ACCESS_VIOLATION_swigregister
OSD_Exception_ACCESS_VIOLATION_swigregister(OSD_Exception_ACCESS_VIOLATION)

def OSD_Exception_ACCESS_VIOLATION_NewInstance(*args):
    """
    OSD_Exception_ACCESS_VIOLATION_NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_ACCESS_VIOLATION

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_ACCESS_VIOLATION

    """
    return _OSD.OSD_Exception_ACCESS_VIOLATION_NewInstance(*args)

def OSD_Exception_ACCESS_VIOLATION_get_type_name(*args):
    """
    OSD_Exception_ACCESS_VIOLATION_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_Exception_ACCESS_VIOLATION_get_type_name(*args)

def OSD_Exception_ACCESS_VIOLATION_get_type_descriptor(*args):
    """
    OSD_Exception_ACCESS_VIOLATION_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_Exception_ACCESS_VIOLATION_get_type_descriptor(*args)

class OSD_Exception_ILLEGAL_INSTRUCTION(OSD_Exception):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_Exception_ILLEGAL_INSTRUCTION
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_Exception_ILLEGAL_INSTRUCTION(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_Exception_ILLEGAL_INSTRUCTION self) -> OSD_Exception_ILLEGAL_INSTRUCTION
        __init__(OSD_Exception_ILLEGAL_INSTRUCTION self, Standard_CString const theMessage) -> OSD_Exception_ILLEGAL_INSTRUCTION

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_Exception_ILLEGAL_INSTRUCTION(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_ILLEGAL_INSTRUCTION

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION

        """
        return _OSD.OSD_Exception_ILLEGAL_INSTRUCTION_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_Exception_ILLEGAL_INSTRUCTION_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_Exception_ILLEGAL_INSTRUCTION_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_Exception_ILLEGAL_INSTRUCTION_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_Exception_ILLEGAL_INSTRUCTION
OSD_Exception_ILLEGAL_INSTRUCTION_swigregister = _OSD.OSD_Exception_ILLEGAL_INSTRUCTION_swigregister
OSD_Exception_ILLEGAL_INSTRUCTION_swigregister(OSD_Exception_ILLEGAL_INSTRUCTION)

def OSD_Exception_ILLEGAL_INSTRUCTION_NewInstance(*args):
    """
    OSD_Exception_ILLEGAL_INSTRUCTION_NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_ILLEGAL_INSTRUCTION

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION

    """
    return _OSD.OSD_Exception_ILLEGAL_INSTRUCTION_NewInstance(*args)

def OSD_Exception_ILLEGAL_INSTRUCTION_get_type_name(*args):
    """
    OSD_Exception_ILLEGAL_INSTRUCTION_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_Exception_ILLEGAL_INSTRUCTION_get_type_name(*args)

def OSD_Exception_ILLEGAL_INSTRUCTION_get_type_descriptor(*args):
    """
    OSD_Exception_ILLEGAL_INSTRUCTION_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_Exception_ILLEGAL_INSTRUCTION_get_type_descriptor(*args)

class OSD_Exception_STATUS_NO_MEMORY(OSD_Exception):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_Exception_STATUS_NO_MEMORY
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_Exception_STATUS_NO_MEMORY(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_Exception_STATUS_NO_MEMORY self) -> OSD_Exception_STATUS_NO_MEMORY
        __init__(OSD_Exception_STATUS_NO_MEMORY self, Standard_CString const theMessage) -> OSD_Exception_STATUS_NO_MEMORY

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_Exception_STATUS_NO_MEMORY(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_STATUS_NO_MEMORY

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_STATUS_NO_MEMORY

        """
        return _OSD.OSD_Exception_STATUS_NO_MEMORY_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_Exception_STATUS_NO_MEMORY_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_Exception_STATUS_NO_MEMORY_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_Exception_STATUS_NO_MEMORY_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_Exception_STATUS_NO_MEMORY
OSD_Exception_STATUS_NO_MEMORY_swigregister = _OSD.OSD_Exception_STATUS_NO_MEMORY_swigregister
OSD_Exception_STATUS_NO_MEMORY_swigregister(OSD_Exception_STATUS_NO_MEMORY)

def OSD_Exception_STATUS_NO_MEMORY_NewInstance(*args):
    """
    OSD_Exception_STATUS_NO_MEMORY_NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_STATUS_NO_MEMORY

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_STATUS_NO_MEMORY

    """
    return _OSD.OSD_Exception_STATUS_NO_MEMORY_NewInstance(*args)

def OSD_Exception_STATUS_NO_MEMORY_get_type_name(*args):
    """
    OSD_Exception_STATUS_NO_MEMORY_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_Exception_STATUS_NO_MEMORY_get_type_name(*args)

def OSD_Exception_STATUS_NO_MEMORY_get_type_descriptor(*args):
    """
    OSD_Exception_STATUS_NO_MEMORY_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_Exception_STATUS_NO_MEMORY_get_type_descriptor(*args)

class OSD_Exception_FLT_INVALID_OPERATION(OSD_Exception):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_Exception_FLT_INVALID_OPERATION
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_Exception_FLT_INVALID_OPERATION(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_Exception_FLT_INVALID_OPERATION self) -> OSD_Exception_FLT_INVALID_OPERATION
        __init__(OSD_Exception_FLT_INVALID_OPERATION self, Standard_CString const theMessage) -> OSD_Exception_FLT_INVALID_OPERATION

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_Exception_FLT_INVALID_OPERATION(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_FLT_INVALID_OPERATION

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION

        """
        return _OSD.OSD_Exception_FLT_INVALID_OPERATION_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_Exception_FLT_INVALID_OPERATION_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_Exception_FLT_INVALID_OPERATION_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_Exception_FLT_INVALID_OPERATION_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_Exception_FLT_INVALID_OPERATION
OSD_Exception_FLT_INVALID_OPERATION_swigregister = _OSD.OSD_Exception_FLT_INVALID_OPERATION_swigregister
OSD_Exception_FLT_INVALID_OPERATION_swigregister(OSD_Exception_FLT_INVALID_OPERATION)

def OSD_Exception_FLT_INVALID_OPERATION_NewInstance(*args):
    """
    OSD_Exception_FLT_INVALID_OPERATION_NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_FLT_INVALID_OPERATION

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION

    """
    return _OSD.OSD_Exception_FLT_INVALID_OPERATION_NewInstance(*args)

def OSD_Exception_FLT_INVALID_OPERATION_get_type_name(*args):
    """
    OSD_Exception_FLT_INVALID_OPERATION_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_Exception_FLT_INVALID_OPERATION_get_type_name(*args)

def OSD_Exception_FLT_INVALID_OPERATION_get_type_descriptor(*args):
    """
    OSD_Exception_FLT_INVALID_OPERATION_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_Exception_FLT_INVALID_OPERATION_get_type_descriptor(*args)

class OSD_OSDError(Standard.Standard_Failure):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_OSDError
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_OSDError(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_OSDError self) -> OSD_OSDError
        __init__(OSD_OSDError self, Standard_CString const theMessage) -> OSD_OSDError

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_OSDError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_OSDError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_OSDError

        """
        return _OSD.OSD_OSDError_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_OSDError_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_OSDError_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_OSDError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_OSDError
OSD_OSDError_swigregister = _OSD.OSD_OSDError_swigregister
OSD_OSDError_swigregister(OSD_OSDError)

def OSD_OSDError_NewInstance(*args):
    """
    OSD_OSDError_NewInstance(Standard_CString const theMessage) -> Handle_OSD_OSDError

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_OSDError

    """
    return _OSD.OSD_OSDError_NewInstance(*args)

def OSD_OSDError_get_type_name(*args):
    """
    OSD_OSDError_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_OSDError_get_type_name(*args)

def OSD_OSDError_get_type_descriptor(*args):
    """
    OSD_OSDError_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_OSDError_get_type_descriptor(*args)

class OSD_Chronometer(object):
    """
    This class measures CPU time (both user and system) consumed
    by current process or thread. The chronometer can be started
    and stopped multiple times, and measures cumulative time.

    If only the thread is measured, calls to Stop() and Show()
    must occur from the same thread where Start() was called
    (unless chronometer is stopped); otherwise measurement will
    yield false values.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OSD_Chronometer self, Standard_Boolean theThisThreadOnly) -> OSD_Chronometer

        Initializes a stopped Chronometer.

        If ThisThreadOnly is True, measured CPU time will account
        time of the current thread only; otherwise CPU of the
        process (all threads, and completed children) is measured.

        :type theThisThreadOnly: bool

        """
        this = _OSD.new_OSD_Chronometer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsStarted(self, *args):
        """
        IsStarted(OSD_Chronometer self) -> Standard_Boolean

        Return true if timer has been started.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.OSD_Chronometer_IsStarted(self, *args)


    def Reset(self, *args):
        """
        Reset(OSD_Chronometer self)

        Stops and Reinitializes the Chronometer.


        """
        return _OSD.OSD_Chronometer_Reset(self, *args)


    def Restart(self, *args):
        """
        Restart(OSD_Chronometer self)

        Restarts the Chronometer.


        """
        return _OSD.OSD_Chronometer_Restart(self, *args)


    def Stop(self, *args):
        """
        Stop(OSD_Chronometer self)

        Stops the Chronometer.


        """
        return _OSD.OSD_Chronometer_Stop(self, *args)


    def Start(self, *args):
        """
        Start(OSD_Chronometer self)

        Starts (after Create or Reset) or restarts (after Stop)
        the chronometer.


        """
        return _OSD.OSD_Chronometer_Start(self, *args)


    def UserTimeCPU(self, *args):
        """
        UserTimeCPU(OSD_Chronometer self) -> Standard_Real

        Returns the current CPU user time in seconds.
        The chronometer can be running (laps Time) or stopped.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _OSD.OSD_Chronometer_UserTimeCPU(self, *args)


    def SystemTimeCPU(self, *args):
        """
        SystemTimeCPU(OSD_Chronometer self) -> Standard_Real

        Returns the current CPU system time in seconds.
        The chronometer can be running (laps Time) or stopped.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _OSD.OSD_Chronometer_SystemTimeCPU(self, *args)


    def Show(self, *args):
        """
        Show(OSD_Chronometer self)
        Show(OSD_Chronometer self, Standard_OStream & theOStream)
        Show(OSD_Chronometer self)
        Show(OSD_Chronometer self)

        Returns the current CPU user and system time in variables.
        The chronometer can be running (laps Time) or stopped.

        :type theUserSec: float
        :type theSystemSec: float

        """
        return _OSD.OSD_Chronometer_Show(self, *args)


    def GetProcessCPU(*args):
        """
        GetProcessCPU()

        Returns CPU time (user and system) consumed by the current
        process since its start, in seconds. The actual precision of
        the measurement depends on granularity provided by the system,
        and is platform-specific.

        :type UserSeconds: float
        :type SystemSeconds: float

        """
        return _OSD.OSD_Chronometer_GetProcessCPU(*args)

    GetProcessCPU = staticmethod(GetProcessCPU)

    def GetThreadCPU(*args):
        """
        GetThreadCPU()

        Returns CPU time (user and system) consumed by the current
        thread since its start. Note that this measurement is
        platform-specific, as threads are implemented and managed
        differently on different platforms and CPUs.

        :type UserSeconds: float
        :type SystemSeconds: float

        """
        return _OSD.OSD_Chronometer_GetThreadCPU(*args)

    GetThreadCPU = staticmethod(GetThreadCPU)
    __swig_destroy__ = _OSD.delete_OSD_Chronometer
OSD_Chronometer_swigregister = _OSD.OSD_Chronometer_swigregister
OSD_Chronometer_swigregister(OSD_Chronometer)

def OSD_Chronometer_GetProcessCPU(*args):
    """
    OSD_Chronometer_GetProcessCPU()

    Returns CPU time (user and system) consumed by the current
    process since its start, in seconds. The actual precision of
    the measurement depends on granularity provided by the system,
    and is platform-specific.

    :type UserSeconds: float
    :type SystemSeconds: float

    """
    return _OSD.OSD_Chronometer_GetProcessCPU(*args)

def OSD_Chronometer_GetThreadCPU(*args):
    """
    OSD_Chronometer_GetThreadCPU()

    Returns CPU time (user and system) consumed by the current
    thread since its start. Note that this measurement is
    platform-specific, as threads are implemented and managed
    differently on different platforms and CPUs.

    :type UserSeconds: float
    :type SystemSeconds: float

    """
    return _OSD.OSD_Chronometer_GetThreadCPU(*args)

class OSD_SIGQUIT(OSD_Signal):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_SIGQUIT
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_SIGQUIT(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_SIGQUIT self) -> OSD_SIGQUIT
        __init__(OSD_SIGQUIT self, Standard_CString const theMessage) -> OSD_SIGQUIT

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_SIGQUIT(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_SIGQUIT

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_SIGQUIT

        """
        return _OSD.OSD_SIGQUIT_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_SIGQUIT_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_SIGQUIT_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_SIGQUIT_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_SIGQUIT
OSD_SIGQUIT_swigregister = _OSD.OSD_SIGQUIT_swigregister
OSD_SIGQUIT_swigregister(OSD_SIGQUIT)

def OSD_SIGQUIT_NewInstance(*args):
    """
    OSD_SIGQUIT_NewInstance(Standard_CString const theMessage) -> Handle_OSD_SIGQUIT

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_SIGQUIT

    """
    return _OSD.OSD_SIGQUIT_NewInstance(*args)

def OSD_SIGQUIT_get_type_name(*args):
    """
    OSD_SIGQUIT_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_SIGQUIT_get_type_name(*args)

def OSD_SIGQUIT_get_type_descriptor(*args):
    """
    OSD_SIGQUIT_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_SIGQUIT_get_type_descriptor(*args)

class OSD_Exception_ARRAY_BOUNDS_EXCEEDED(OSD_Exception):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_Exception_ARRAY_BOUNDS_EXCEEDED self) -> OSD_Exception_ARRAY_BOUNDS_EXCEEDED
        __init__(OSD_Exception_ARRAY_BOUNDS_EXCEEDED self, Standard_CString const theMessage) -> OSD_Exception_ARRAY_BOUNDS_EXCEEDED

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_Exception_ARRAY_BOUNDS_EXCEEDED(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED

        """
        return _OSD.OSD_Exception_ARRAY_BOUNDS_EXCEEDED_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_Exception_ARRAY_BOUNDS_EXCEEDED_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_Exception_ARRAY_BOUNDS_EXCEEDED_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_Exception_ARRAY_BOUNDS_EXCEEDED_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_Exception_ARRAY_BOUNDS_EXCEEDED
OSD_Exception_ARRAY_BOUNDS_EXCEEDED_swigregister = _OSD.OSD_Exception_ARRAY_BOUNDS_EXCEEDED_swigregister
OSD_Exception_ARRAY_BOUNDS_EXCEEDED_swigregister(OSD_Exception_ARRAY_BOUNDS_EXCEEDED)

def OSD_Exception_ARRAY_BOUNDS_EXCEEDED_NewInstance(*args):
    """
    OSD_Exception_ARRAY_BOUNDS_EXCEEDED_NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED

    """
    return _OSD.OSD_Exception_ARRAY_BOUNDS_EXCEEDED_NewInstance(*args)

def OSD_Exception_ARRAY_BOUNDS_EXCEEDED_get_type_name(*args):
    """
    OSD_Exception_ARRAY_BOUNDS_EXCEEDED_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_Exception_ARRAY_BOUNDS_EXCEEDED_get_type_name(*args)

def OSD_Exception_ARRAY_BOUNDS_EXCEEDED_get_type_descriptor(*args):
    """
    OSD_Exception_ARRAY_BOUNDS_EXCEEDED_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_Exception_ARRAY_BOUNDS_EXCEEDED_get_type_descriptor(*args)

class OSD_(object):
    """
    Set of Operating Sytem Dependent Tools
    (O)perating (S)ystem (D)ependent
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def SetSignal(*args):
        """
        SetSignal(Standard_Boolean const theFloatingSignal)

        Sets signal and exception handlers.

        ### Windows-specific notes

        Compiled with MS VC++ sets 3 main handlers:
        @li Signal handlers (via ::signal() functions) that translate system signals
        (SIGSEGV, SIGFPE, SIGILL) into C++ exceptions (classes inheriting
        Standard_Failure). They only be called if user calls ::raise() function
        with one of supported signal type set.
        @li Exception handler OSD::WntHandler() (via ::SetUnhandledExceptionFilter())
        that will be used when user's code is compiled with /EHs option.
        @li Structured exception (SE) translator (via _set_se_translator()) that
        translates SE exceptions (aka asynchronous exceptions) into the
        C++ exceptions inheriting Standard_Failure. This translator will be
        used when user's code is compiled with /EHa option.

        This approach ensures that regardless of the option the user chooses to
        compile his code with (/EHs or /EHa), signals (or SE exceptions) will be
        translated into Open CASCADE C++ exceptions.

        If @a theFloatingSignal is TRUE then floating point exceptions will be
        generated in accordance with the mask
        <tt>_EM_INVALID | _EM_DENORMAL | _EM_ZERODIVIDE | _EM_OVERFLOW</tt> that is
        used to call ::_controlfp() system function. If @a theFloatingSignal is FALSE
        corresponding operations (e.g. division by zero) will gracefully complete
        without an exception.

        ### Unix-specific notes

        OSD::SetSignal() sets handlers (via ::sigaction()) for multiple signals
        (SIGFPE, SIGSEGV, etc). Currently the number of handled signals is much
        greater than for Windows, in the future this may change to provide better
        consistency with Windows.

        @a theFloatingSignal is recognized on Sun Solaris, Linux, and SGI Irix to
        generate floating-point exception according to the mask
        <tt>FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW</tt> (in Linux conventions).<br>
        When compiled with OBJS macro defined, already set signal handlers (e.g.
        by Data Base Managers) are not redefined.

        ### Common notes

        If OSD::SetSignal() method is used in at least one thread, it must also be
        called in any other thread where Open CASCADE will be used, to ensure
        consistency of behavior. Its @a aFloatingSignal argument must be consistent
        across threads.

        Keep in mind that whether the C++ exception will really be thrown (i.e.
        ::throw() will be called) is regulated by the
        OCC_CONVERT_SIGNALS macro used during compilation of Open CASCADE and
        user's code. Refer to Foundation Classes User's Guide for further details.


        :type theFloatingSignal: bool

        """
        return _OSD.OSD__SetSignal(*args)

    SetSignal = staticmethod(SetSignal)

    def SecSleep(*args):
        """
        SecSleep(Standard_Integer const aDelay)

        Commands the process to sleep for a number of seconds.

        :type aDelay: int

        """
        return _OSD.OSD__SecSleep(*args)

    SecSleep = staticmethod(SecSleep)

    def MilliSecSleep(*args):
        """
        MilliSecSleep(Standard_Integer const aDelay)

        Commands the process to sleep for a number of milliseconds

        :type aDelay: int

        """
        return _OSD.OSD__MilliSecSleep(*args)

    MilliSecSleep = staticmethod(MilliSecSleep)

    def CStringToReal(*args):
        """
        CStringToReal(Standard_CString const aString) -> Standard_Boolean

        Converts aCstring representing a real with a period as
        decimal point, no thousand separator and no grouping of digits
        into aReal .
        The conversion is independant from the current locale.

        :type aString: OCC.wrapper.Standard.Standard_CString
        :type aReal: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.OSD__CStringToReal(*args)

    CStringToReal = staticmethod(CStringToReal)

    def ControlBreak(*args):
        """
        ControlBreak()

        since Windows NT does not support 'SIGINT' signal like UNIX,
        then this method checks whether Ctrl-Break keystroke was or
        not. If yes then raises Exception_CTRL_BREAK.


        """
        return _OSD.OSD__ControlBreak(*args)

    ControlBreak = staticmethod(ControlBreak)

    def RealToCString(self, a, b):
        return _OSD.OSD__RealToCString(self, a, b)

    def __init__(self):
        """
        Set of Operating Sytem Dependent Tools
        (O)perating (S)ystem (D)ependent
        """
        this = _OSD.new_OSD_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OSD.delete_OSD_
OSD__swigregister = _OSD.OSD__swigregister
OSD__swigregister(OSD_)

def OSD__SetSignal(*args):
    """
    OSD__SetSignal(Standard_Boolean const theFloatingSignal)

    Sets signal and exception handlers.

    ### Windows-specific notes

    Compiled with MS VC++ sets 3 main handlers:
    @li Signal handlers (via ::signal() functions) that translate system signals
    (SIGSEGV, SIGFPE, SIGILL) into C++ exceptions (classes inheriting
    Standard_Failure). They only be called if user calls ::raise() function
    with one of supported signal type set.
    @li Exception handler OSD::WntHandler() (via ::SetUnhandledExceptionFilter())
    that will be used when user's code is compiled with /EHs option.
    @li Structured exception (SE) translator (via _set_se_translator()) that
    translates SE exceptions (aka asynchronous exceptions) into the
    C++ exceptions inheriting Standard_Failure. This translator will be
    used when user's code is compiled with /EHa option.

    This approach ensures that regardless of the option the user chooses to
    compile his code with (/EHs or /EHa), signals (or SE exceptions) will be
    translated into Open CASCADE C++ exceptions.

    If @a theFloatingSignal is TRUE then floating point exceptions will be
    generated in accordance with the mask
    <tt>_EM_INVALID | _EM_DENORMAL | _EM_ZERODIVIDE | _EM_OVERFLOW</tt> that is
    used to call ::_controlfp() system function. If @a theFloatingSignal is FALSE
    corresponding operations (e.g. division by zero) will gracefully complete
    without an exception.

    ### Unix-specific notes

    OSD::SetSignal() sets handlers (via ::sigaction()) for multiple signals
    (SIGFPE, SIGSEGV, etc). Currently the number of handled signals is much
    greater than for Windows, in the future this may change to provide better
    consistency with Windows.

    @a theFloatingSignal is recognized on Sun Solaris, Linux, and SGI Irix to
    generate floating-point exception according to the mask
    <tt>FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW</tt> (in Linux conventions).<br>
    When compiled with OBJS macro defined, already set signal handlers (e.g.
    by Data Base Managers) are not redefined.

    ### Common notes

    If OSD::SetSignal() method is used in at least one thread, it must also be
    called in any other thread where Open CASCADE will be used, to ensure
    consistency of behavior. Its @a aFloatingSignal argument must be consistent
    across threads.

    Keep in mind that whether the C++ exception will really be thrown (i.e.
    ::throw() will be called) is regulated by the
    OCC_CONVERT_SIGNALS macro used during compilation of Open CASCADE and
    user's code. Refer to Foundation Classes User's Guide for further details.


    :type theFloatingSignal: bool

    """
    return _OSD.OSD__SetSignal(*args)

def OSD__SecSleep(*args):
    """
    OSD__SecSleep(Standard_Integer const aDelay)

    Commands the process to sleep for a number of seconds.

    :type aDelay: int

    """
    return _OSD.OSD__SecSleep(*args)

def OSD__MilliSecSleep(*args):
    """
    OSD__MilliSecSleep(Standard_Integer const aDelay)

    Commands the process to sleep for a number of milliseconds

    :type aDelay: int

    """
    return _OSD.OSD__MilliSecSleep(*args)

def OSD__CStringToReal(*args):
    """
    OSD__CStringToReal(Standard_CString const aString) -> Standard_Boolean

    Converts aCstring representing a real with a period as
    decimal point, no thousand separator and no grouping of digits
    into aReal .
    The conversion is independant from the current locale.

    :type aString: OCC.wrapper.Standard.Standard_CString
    :type aReal: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _OSD.OSD__CStringToReal(*args)

def OSD__ControlBreak(*args):
    """
    OSD__ControlBreak()

    since Windows NT does not support 'SIGINT' signal like UNIX,
    then this method checks whether Ctrl-Break keystroke was or
    not. If yes then raises Exception_CTRL_BREAK.


    """
    return _OSD.OSD__ControlBreak(*args)

class Handle_OSD_Signal(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_Signal self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_Signal_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_Signal self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_Signal_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_Signal self, OSD_Signal thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_Signal_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_Signal self, Handle_OSD_Signal theHandle) -> Handle_OSD_Signal
        assign(Handle_OSD_Signal self, OSD_Signal thePtr) -> Handle_OSD_Signal
        assign(Handle_OSD_Signal self, Handle_OSD_Signal theHandle) -> Handle_OSD_Signal

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_Signal_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_Signal self) -> OSD_Signal

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_Signal_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_Signal self) -> OSD_Signal

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_Signal___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_Signal self) -> OSD_Signal

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_Signal___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_Signal___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_Signal___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_Signal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_Signal_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_Signal

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_Signal self, Standard_CString const theMessage) -> Handle_OSD_Signal

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Signal

        """
        return _OSD.Handle_OSD_Signal_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_Signal self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_Signal_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Signal_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Signal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_Signal self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_Signal_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_Signal self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Signal_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_Signal self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Signal_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_Signal self)
        Reraise(Handle_OSD_Signal self, Standard_CString const aMessage)
        Reraise(Handle_OSD_Signal self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_Signal_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_Signal self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_Signal_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_Signal self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_Signal_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_Signal self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_Signal_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_Signal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_Signal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Signal_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_Signal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_Signal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Signal_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_Signal self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_Signal_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_Signal self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Signal_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_Signal self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_Signal_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_Signal self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Signal_DecrementRefCounter(self, *args)

Handle_OSD_Signal_swigregister = _OSD.Handle_OSD_Signal_swigregister
Handle_OSD_Signal_swigregister(Handle_OSD_Signal)

def Handle_OSD_Signal_DownCast(thing):
    return _OSD.Handle_OSD_Signal_DownCast(thing)
Handle_OSD_Signal_DownCast = _OSD.Handle_OSD_Signal_DownCast

class OSD_Exception_CTRL_BREAK(OSD_Exception):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_Exception_CTRL_BREAK
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_Exception_CTRL_BREAK(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_Exception_CTRL_BREAK self) -> OSD_Exception_CTRL_BREAK
        __init__(OSD_Exception_CTRL_BREAK self, Standard_CString const theMessage) -> OSD_Exception_CTRL_BREAK

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_Exception_CTRL_BREAK(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_CTRL_BREAK

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_CTRL_BREAK

        """
        return _OSD.OSD_Exception_CTRL_BREAK_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_Exception_CTRL_BREAK_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_Exception_CTRL_BREAK_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_Exception_CTRL_BREAK_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_Exception_CTRL_BREAK
OSD_Exception_CTRL_BREAK_swigregister = _OSD.OSD_Exception_CTRL_BREAK_swigregister
OSD_Exception_CTRL_BREAK_swigregister(OSD_Exception_CTRL_BREAK)

def OSD_Exception_CTRL_BREAK_NewInstance(*args):
    """
    OSD_Exception_CTRL_BREAK_NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_CTRL_BREAK

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_CTRL_BREAK

    """
    return _OSD.OSD_Exception_CTRL_BREAK_NewInstance(*args)

def OSD_Exception_CTRL_BREAK_get_type_name(*args):
    """
    OSD_Exception_CTRL_BREAK_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_Exception_CTRL_BREAK_get_type_name(*args)

def OSD_Exception_CTRL_BREAK_get_type_descriptor(*args):
    """
    OSD_Exception_CTRL_BREAK_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_Exception_CTRL_BREAK_get_type_descriptor(*args)

class Handle_OSD_SIGQUIT(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_SIGQUIT self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_SIGQUIT_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_SIGQUIT self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_SIGQUIT_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_SIGQUIT self, OSD_SIGQUIT thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_SIGQUIT_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_SIGQUIT self, Handle_OSD_SIGQUIT theHandle) -> Handle_OSD_SIGQUIT
        assign(Handle_OSD_SIGQUIT self, OSD_SIGQUIT thePtr) -> Handle_OSD_SIGQUIT
        assign(Handle_OSD_SIGQUIT self, Handle_OSD_SIGQUIT theHandle) -> Handle_OSD_SIGQUIT

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_SIGQUIT_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_SIGQUIT self) -> OSD_SIGQUIT

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_SIGQUIT_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_SIGQUIT self) -> OSD_SIGQUIT

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_SIGQUIT___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_SIGQUIT self) -> OSD_SIGQUIT

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_SIGQUIT___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_SIGQUIT___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_SIGQUIT___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_SIGQUIT(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_SIGQUIT_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_SIGQUIT

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_SIGQUIT self, Standard_CString const theMessage) -> Handle_OSD_SIGQUIT

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_SIGQUIT

        """
        return _OSD.Handle_OSD_SIGQUIT_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_SIGQUIT self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_SIGQUIT_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_SIGQUIT_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_SIGQUIT_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_SIGQUIT self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_SIGQUIT_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_SIGQUIT self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_SIGQUIT_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_SIGQUIT self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_SIGQUIT_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_SIGQUIT self)
        Reraise(Handle_OSD_SIGQUIT self, Standard_CString const aMessage)
        Reraise(Handle_OSD_SIGQUIT self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_SIGQUIT_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_SIGQUIT self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_SIGQUIT_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_SIGQUIT self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_SIGQUIT_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_SIGQUIT self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_SIGQUIT_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_SIGQUIT self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_SIGQUIT self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_SIGQUIT_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_SIGQUIT self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_SIGQUIT self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_SIGQUIT_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_SIGQUIT self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_SIGQUIT_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_SIGQUIT self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_SIGQUIT_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_SIGQUIT self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_SIGQUIT_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_SIGQUIT self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_SIGQUIT_DecrementRefCounter(self, *args)

Handle_OSD_SIGQUIT_swigregister = _OSD.Handle_OSD_SIGQUIT_swigregister
Handle_OSD_SIGQUIT_swigregister(Handle_OSD_SIGQUIT)

def Handle_OSD_SIGQUIT_DownCast(thing):
    return _OSD.Handle_OSD_SIGQUIT_DownCast(thing)
Handle_OSD_SIGQUIT_DownCast = _OSD.Handle_OSD_SIGQUIT_DownCast

class Handle_OSD_Exception_INVALID_DISPOSITION(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_Exception_INVALID_DISPOSITION self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_Exception_INVALID_DISPOSITION_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_Exception_INVALID_DISPOSITION self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_Exception_INVALID_DISPOSITION_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_Exception_INVALID_DISPOSITION self, OSD_Exception_INVALID_DISPOSITION thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_Exception_INVALID_DISPOSITION_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_Exception_INVALID_DISPOSITION self, Handle_OSD_Exception_INVALID_DISPOSITION theHandle) -> Handle_OSD_Exception_INVALID_DISPOSITION
        assign(Handle_OSD_Exception_INVALID_DISPOSITION self, OSD_Exception_INVALID_DISPOSITION thePtr) -> Handle_OSD_Exception_INVALID_DISPOSITION
        assign(Handle_OSD_Exception_INVALID_DISPOSITION self, Handle_OSD_Exception_INVALID_DISPOSITION theHandle) -> Handle_OSD_Exception_INVALID_DISPOSITION

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_Exception_INVALID_DISPOSITION_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_Exception_INVALID_DISPOSITION self) -> OSD_Exception_INVALID_DISPOSITION

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_INVALID_DISPOSITION_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_Exception_INVALID_DISPOSITION self) -> OSD_Exception_INVALID_DISPOSITION

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_INVALID_DISPOSITION___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_Exception_INVALID_DISPOSITION self) -> OSD_Exception_INVALID_DISPOSITION

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_Exception_INVALID_DISPOSITION___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_Exception_INVALID_DISPOSITION___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_Exception_INVALID_DISPOSITION___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_Exception_INVALID_DISPOSITION(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_Exception_INVALID_DISPOSITION_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_Exception_INVALID_DISPOSITION

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_Exception_INVALID_DISPOSITION self, Standard_CString const theMessage) -> Handle_OSD_Exception_INVALID_DISPOSITION

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_INVALID_DISPOSITION

        """
        return _OSD.Handle_OSD_Exception_INVALID_DISPOSITION_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_Exception_INVALID_DISPOSITION self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_Exception_INVALID_DISPOSITION_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_INVALID_DISPOSITION_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_INVALID_DISPOSITION_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_Exception_INVALID_DISPOSITION self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_Exception_INVALID_DISPOSITION_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_Exception_INVALID_DISPOSITION self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_INVALID_DISPOSITION_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_Exception_INVALID_DISPOSITION self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_INVALID_DISPOSITION_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_Exception_INVALID_DISPOSITION self)
        Reraise(Handle_OSD_Exception_INVALID_DISPOSITION self, Standard_CString const aMessage)
        Reraise(Handle_OSD_Exception_INVALID_DISPOSITION self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_Exception_INVALID_DISPOSITION_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_Exception_INVALID_DISPOSITION self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_Exception_INVALID_DISPOSITION_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_Exception_INVALID_DISPOSITION self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_Exception_INVALID_DISPOSITION_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_Exception_INVALID_DISPOSITION self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_Exception_INVALID_DISPOSITION_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_Exception_INVALID_DISPOSITION self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_Exception_INVALID_DISPOSITION self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_INVALID_DISPOSITION_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_Exception_INVALID_DISPOSITION self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_Exception_INVALID_DISPOSITION self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_INVALID_DISPOSITION_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_Exception_INVALID_DISPOSITION self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_Exception_INVALID_DISPOSITION_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_Exception_INVALID_DISPOSITION self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_INVALID_DISPOSITION_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_Exception_INVALID_DISPOSITION self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_Exception_INVALID_DISPOSITION_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_Exception_INVALID_DISPOSITION self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_INVALID_DISPOSITION_DecrementRefCounter(self, *args)

Handle_OSD_Exception_INVALID_DISPOSITION_swigregister = _OSD.Handle_OSD_Exception_INVALID_DISPOSITION_swigregister
Handle_OSD_Exception_INVALID_DISPOSITION_swigregister(Handle_OSD_Exception_INVALID_DISPOSITION)

def Handle_OSD_Exception_INVALID_DISPOSITION_DownCast(thing):
    return _OSD.Handle_OSD_Exception_INVALID_DISPOSITION_DownCast(thing)
Handle_OSD_Exception_INVALID_DISPOSITION_DownCast = _OSD.Handle_OSD_Exception_INVALID_DISPOSITION_DownCast

class Handle_OSD_Exception_FLT_UNDERFLOW(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_Exception_FLT_UNDERFLOW self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_Exception_FLT_UNDERFLOW_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_Exception_FLT_UNDERFLOW self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_Exception_FLT_UNDERFLOW_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_Exception_FLT_UNDERFLOW self, OSD_Exception_FLT_UNDERFLOW thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_Exception_FLT_UNDERFLOW_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_Exception_FLT_UNDERFLOW self, Handle_OSD_Exception_FLT_UNDERFLOW theHandle) -> Handle_OSD_Exception_FLT_UNDERFLOW
        assign(Handle_OSD_Exception_FLT_UNDERFLOW self, OSD_Exception_FLT_UNDERFLOW thePtr) -> Handle_OSD_Exception_FLT_UNDERFLOW
        assign(Handle_OSD_Exception_FLT_UNDERFLOW self, Handle_OSD_Exception_FLT_UNDERFLOW theHandle) -> Handle_OSD_Exception_FLT_UNDERFLOW

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_Exception_FLT_UNDERFLOW_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_Exception_FLT_UNDERFLOW self) -> OSD_Exception_FLT_UNDERFLOW

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_FLT_UNDERFLOW_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_Exception_FLT_UNDERFLOW self) -> OSD_Exception_FLT_UNDERFLOW

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_FLT_UNDERFLOW___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_Exception_FLT_UNDERFLOW self) -> OSD_Exception_FLT_UNDERFLOW

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_Exception_FLT_UNDERFLOW___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_Exception_FLT_UNDERFLOW___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_Exception_FLT_UNDERFLOW___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_Exception_FLT_UNDERFLOW(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_Exception_FLT_UNDERFLOW_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_Exception_FLT_UNDERFLOW

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_Exception_FLT_UNDERFLOW self, Standard_CString const theMessage) -> Handle_OSD_Exception_FLT_UNDERFLOW

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_FLT_UNDERFLOW

        """
        return _OSD.Handle_OSD_Exception_FLT_UNDERFLOW_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_Exception_FLT_UNDERFLOW self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_Exception_FLT_UNDERFLOW_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_FLT_UNDERFLOW_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_FLT_UNDERFLOW_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_Exception_FLT_UNDERFLOW self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_Exception_FLT_UNDERFLOW_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_Exception_FLT_UNDERFLOW self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_FLT_UNDERFLOW_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_Exception_FLT_UNDERFLOW self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_FLT_UNDERFLOW_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_Exception_FLT_UNDERFLOW self)
        Reraise(Handle_OSD_Exception_FLT_UNDERFLOW self, Standard_CString const aMessage)
        Reraise(Handle_OSD_Exception_FLT_UNDERFLOW self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_Exception_FLT_UNDERFLOW_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_Exception_FLT_UNDERFLOW self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_Exception_FLT_UNDERFLOW_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_Exception_FLT_UNDERFLOW self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_Exception_FLT_UNDERFLOW_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_Exception_FLT_UNDERFLOW self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_Exception_FLT_UNDERFLOW_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_Exception_FLT_UNDERFLOW self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_Exception_FLT_UNDERFLOW self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_FLT_UNDERFLOW_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_Exception_FLT_UNDERFLOW self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_Exception_FLT_UNDERFLOW self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_FLT_UNDERFLOW_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_Exception_FLT_UNDERFLOW self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_Exception_FLT_UNDERFLOW_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_Exception_FLT_UNDERFLOW self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_FLT_UNDERFLOW_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_Exception_FLT_UNDERFLOW self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_Exception_FLT_UNDERFLOW_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_Exception_FLT_UNDERFLOW self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_FLT_UNDERFLOW_DecrementRefCounter(self, *args)

Handle_OSD_Exception_FLT_UNDERFLOW_swigregister = _OSD.Handle_OSD_Exception_FLT_UNDERFLOW_swigregister
Handle_OSD_Exception_FLT_UNDERFLOW_swigregister(Handle_OSD_Exception_FLT_UNDERFLOW)

def Handle_OSD_Exception_FLT_UNDERFLOW_DownCast(thing):
    return _OSD.Handle_OSD_Exception_FLT_UNDERFLOW_DownCast(thing)
Handle_OSD_Exception_FLT_UNDERFLOW_DownCast = _OSD.Handle_OSD_Exception_FLT_UNDERFLOW_DownCast

class Handle_OSD_SIGSEGV(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_SIGSEGV self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_SIGSEGV_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_SIGSEGV self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_SIGSEGV_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_SIGSEGV self, OSD_SIGSEGV thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_SIGSEGV_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_SIGSEGV self, Handle_OSD_SIGSEGV theHandle) -> Handle_OSD_SIGSEGV
        assign(Handle_OSD_SIGSEGV self, OSD_SIGSEGV thePtr) -> Handle_OSD_SIGSEGV
        assign(Handle_OSD_SIGSEGV self, Handle_OSD_SIGSEGV theHandle) -> Handle_OSD_SIGSEGV

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_SIGSEGV_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_SIGSEGV self) -> OSD_SIGSEGV

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_SIGSEGV_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_SIGSEGV self) -> OSD_SIGSEGV

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_SIGSEGV___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_SIGSEGV self) -> OSD_SIGSEGV

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_SIGSEGV___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_SIGSEGV___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_SIGSEGV___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_SIGSEGV(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_SIGSEGV_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_SIGSEGV

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_SIGSEGV self, Standard_CString const theMessage) -> Handle_OSD_SIGSEGV

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_SIGSEGV

        """
        return _OSD.Handle_OSD_SIGSEGV_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_SIGSEGV self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_SIGSEGV_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_SIGSEGV_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_SIGSEGV_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_SIGSEGV self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_SIGSEGV_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_SIGSEGV self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_SIGSEGV_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_SIGSEGV self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_SIGSEGV_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_SIGSEGV self)
        Reraise(Handle_OSD_SIGSEGV self, Standard_CString const aMessage)
        Reraise(Handle_OSD_SIGSEGV self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_SIGSEGV_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_SIGSEGV self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_SIGSEGV_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_SIGSEGV self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_SIGSEGV_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_SIGSEGV self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_SIGSEGV_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_SIGSEGV self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_SIGSEGV self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_SIGSEGV_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_SIGSEGV self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_SIGSEGV self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_SIGSEGV_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_SIGSEGV self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_SIGSEGV_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_SIGSEGV self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_SIGSEGV_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_SIGSEGV self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_SIGSEGV_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_SIGSEGV self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_SIGSEGV_DecrementRefCounter(self, *args)

Handle_OSD_SIGSEGV_swigregister = _OSD.Handle_OSD_SIGSEGV_swigregister
Handle_OSD_SIGSEGV_swigregister(Handle_OSD_SIGSEGV)

def Handle_OSD_SIGSEGV_DownCast(thing):
    return _OSD.Handle_OSD_SIGSEGV_DownCast(thing)
Handle_OSD_SIGSEGV_DownCast = _OSD.Handle_OSD_SIGSEGV_DownCast

class Handle_OSD_Exception_STACK_OVERFLOW(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_Exception_STACK_OVERFLOW self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_Exception_STACK_OVERFLOW_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_Exception_STACK_OVERFLOW self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_Exception_STACK_OVERFLOW_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_Exception_STACK_OVERFLOW self, OSD_Exception_STACK_OVERFLOW thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_Exception_STACK_OVERFLOW_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_Exception_STACK_OVERFLOW self, Handle_OSD_Exception_STACK_OVERFLOW theHandle) -> Handle_OSD_Exception_STACK_OVERFLOW
        assign(Handle_OSD_Exception_STACK_OVERFLOW self, OSD_Exception_STACK_OVERFLOW thePtr) -> Handle_OSD_Exception_STACK_OVERFLOW
        assign(Handle_OSD_Exception_STACK_OVERFLOW self, Handle_OSD_Exception_STACK_OVERFLOW theHandle) -> Handle_OSD_Exception_STACK_OVERFLOW

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_Exception_STACK_OVERFLOW_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_Exception_STACK_OVERFLOW self) -> OSD_Exception_STACK_OVERFLOW

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_STACK_OVERFLOW_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_Exception_STACK_OVERFLOW self) -> OSD_Exception_STACK_OVERFLOW

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_STACK_OVERFLOW___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_Exception_STACK_OVERFLOW self) -> OSD_Exception_STACK_OVERFLOW

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_Exception_STACK_OVERFLOW___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_Exception_STACK_OVERFLOW___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_Exception_STACK_OVERFLOW___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_Exception_STACK_OVERFLOW(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_Exception_STACK_OVERFLOW_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_Exception_STACK_OVERFLOW

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_Exception_STACK_OVERFLOW self, Standard_CString const theMessage) -> Handle_OSD_Exception_STACK_OVERFLOW

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_STACK_OVERFLOW

        """
        return _OSD.Handle_OSD_Exception_STACK_OVERFLOW_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_Exception_STACK_OVERFLOW self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_Exception_STACK_OVERFLOW_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_STACK_OVERFLOW_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_STACK_OVERFLOW_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_Exception_STACK_OVERFLOW self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_Exception_STACK_OVERFLOW_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_Exception_STACK_OVERFLOW self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_STACK_OVERFLOW_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_Exception_STACK_OVERFLOW self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_STACK_OVERFLOW_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_Exception_STACK_OVERFLOW self)
        Reraise(Handle_OSD_Exception_STACK_OVERFLOW self, Standard_CString const aMessage)
        Reraise(Handle_OSD_Exception_STACK_OVERFLOW self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_Exception_STACK_OVERFLOW_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_Exception_STACK_OVERFLOW self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_Exception_STACK_OVERFLOW_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_Exception_STACK_OVERFLOW self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_Exception_STACK_OVERFLOW_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_Exception_STACK_OVERFLOW self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_Exception_STACK_OVERFLOW_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_Exception_STACK_OVERFLOW self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_Exception_STACK_OVERFLOW self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_STACK_OVERFLOW_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_Exception_STACK_OVERFLOW self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_Exception_STACK_OVERFLOW self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_STACK_OVERFLOW_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_Exception_STACK_OVERFLOW self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_Exception_STACK_OVERFLOW_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_Exception_STACK_OVERFLOW self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_STACK_OVERFLOW_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_Exception_STACK_OVERFLOW self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_Exception_STACK_OVERFLOW_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_Exception_STACK_OVERFLOW self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_STACK_OVERFLOW_DecrementRefCounter(self, *args)

Handle_OSD_Exception_STACK_OVERFLOW_swigregister = _OSD.Handle_OSD_Exception_STACK_OVERFLOW_swigregister
Handle_OSD_Exception_STACK_OVERFLOW_swigregister(Handle_OSD_Exception_STACK_OVERFLOW)

def Handle_OSD_Exception_STACK_OVERFLOW_DownCast(thing):
    return _OSD.Handle_OSD_Exception_STACK_OVERFLOW_DownCast(thing)
Handle_OSD_Exception_STACK_OVERFLOW_DownCast = _OSD.Handle_OSD_Exception_STACK_OVERFLOW_DownCast

class OSD_Directory(OSD_FileNode):
    """Management of directories (a set of directory oriented tools)"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def BuildTemporary(*args):
        """
        BuildTemporary() -> OSD_Directory

        Creates a temporary Directory in current directory.
        This directory is automatically removed when object dies.

        :rtype: OCC.wrapper.OSD.OSD_Directory

        """
        return _OSD.OSD_Directory_BuildTemporary(*args)

    BuildTemporary = staticmethod(BuildTemporary)

    def __init__(self, *args):
        """
        __init__(OSD_Directory self) -> OSD_Directory
        __init__(OSD_Directory self, OSD_Path theName) -> OSD_Directory

        Creates Directory object initialized with theName.

        :type theName: OCC.wrapper.OSD.OSD_Path

        """
        this = _OSD.new_OSD_Directory(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Build(self, *args):
        """
        Build(OSD_Directory self, OSD_Protection Protect)

        Creates (physically) a directory.
        When a directory of the same name already exists, no error is
        returned, and only <Protect> is applied to the existing directory.

        If Build is used and <me> is instantiated without a name,
        OSDError is raised.

        :type Protect: OCC.wrapper.OSD.OSD_Protection

        """
        return _OSD.OSD_Directory_Build(self, *args)

    __swig_destroy__ = _OSD.delete_OSD_Directory
OSD_Directory_swigregister = _OSD.OSD_Directory_swigregister
OSD_Directory_swigregister(OSD_Directory)

def OSD_Directory_BuildTemporary(*args):
    """
    OSD_Directory_BuildTemporary() -> OSD_Directory

    Creates a temporary Directory in current directory.
    This directory is automatically removed when object dies.

    :rtype: OCC.wrapper.OSD.OSD_Directory

    """
    return _OSD.OSD_Directory_BuildTemporary(*args)

class Handle_OSD_SIGINT(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_SIGINT self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_SIGINT_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_SIGINT self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_SIGINT_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_SIGINT self, OSD_SIGINT thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_SIGINT_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_SIGINT self, Handle_OSD_SIGINT theHandle) -> Handle_OSD_SIGINT
        assign(Handle_OSD_SIGINT self, OSD_SIGINT thePtr) -> Handle_OSD_SIGINT
        assign(Handle_OSD_SIGINT self, Handle_OSD_SIGINT theHandle) -> Handle_OSD_SIGINT

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_SIGINT_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_SIGINT self) -> OSD_SIGINT

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_SIGINT_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_SIGINT self) -> OSD_SIGINT

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_SIGINT___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_SIGINT self) -> OSD_SIGINT

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_SIGINT___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_SIGINT___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_SIGINT___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_SIGINT(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_SIGINT_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_SIGINT

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_SIGINT self, Standard_CString const theMessage) -> Handle_OSD_SIGINT

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_SIGINT

        """
        return _OSD.Handle_OSD_SIGINT_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_SIGINT self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_SIGINT_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_SIGINT_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_SIGINT_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_SIGINT self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_SIGINT_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_SIGINT self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_SIGINT_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_SIGINT self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_SIGINT_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_SIGINT self)
        Reraise(Handle_OSD_SIGINT self, Standard_CString const aMessage)
        Reraise(Handle_OSD_SIGINT self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_SIGINT_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_SIGINT self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_SIGINT_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_SIGINT self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_SIGINT_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_SIGINT self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_SIGINT_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_SIGINT self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_SIGINT self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_SIGINT_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_SIGINT self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_SIGINT self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_SIGINT_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_SIGINT self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_SIGINT_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_SIGINT self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_SIGINT_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_SIGINT self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_SIGINT_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_SIGINT self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_SIGINT_DecrementRefCounter(self, *args)

Handle_OSD_SIGINT_swigregister = _OSD.Handle_OSD_SIGINT_swigregister
Handle_OSD_SIGINT_swigregister(Handle_OSD_SIGINT)

def Handle_OSD_SIGINT_DownCast(thing):
    return _OSD.Handle_OSD_SIGINT_DownCast(thing)
Handle_OSD_SIGINT_DownCast = _OSD.Handle_OSD_SIGINT_DownCast

class Handle_OSD_Exception_CTRL_BREAK(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_Exception_CTRL_BREAK self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_Exception_CTRL_BREAK_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_Exception_CTRL_BREAK self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_Exception_CTRL_BREAK_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_Exception_CTRL_BREAK self, OSD_Exception_CTRL_BREAK thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_Exception_CTRL_BREAK_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_Exception_CTRL_BREAK self, Handle_OSD_Exception_CTRL_BREAK theHandle) -> Handle_OSD_Exception_CTRL_BREAK
        assign(Handle_OSD_Exception_CTRL_BREAK self, OSD_Exception_CTRL_BREAK thePtr) -> Handle_OSD_Exception_CTRL_BREAK
        assign(Handle_OSD_Exception_CTRL_BREAK self, Handle_OSD_Exception_CTRL_BREAK theHandle) -> Handle_OSD_Exception_CTRL_BREAK

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_Exception_CTRL_BREAK_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_Exception_CTRL_BREAK self) -> OSD_Exception_CTRL_BREAK

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_CTRL_BREAK_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_Exception_CTRL_BREAK self) -> OSD_Exception_CTRL_BREAK

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_CTRL_BREAK___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_Exception_CTRL_BREAK self) -> OSD_Exception_CTRL_BREAK

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_Exception_CTRL_BREAK___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_Exception_CTRL_BREAK___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_Exception_CTRL_BREAK___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_Exception_CTRL_BREAK(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_Exception_CTRL_BREAK_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_Exception_CTRL_BREAK

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_Exception_CTRL_BREAK self, Standard_CString const theMessage) -> Handle_OSD_Exception_CTRL_BREAK

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_CTRL_BREAK

        """
        return _OSD.Handle_OSD_Exception_CTRL_BREAK_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_Exception_CTRL_BREAK self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_Exception_CTRL_BREAK_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_CTRL_BREAK_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_CTRL_BREAK_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_Exception_CTRL_BREAK self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_Exception_CTRL_BREAK_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_Exception_CTRL_BREAK self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_CTRL_BREAK_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_Exception_CTRL_BREAK self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_CTRL_BREAK_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_Exception_CTRL_BREAK self)
        Reraise(Handle_OSD_Exception_CTRL_BREAK self, Standard_CString const aMessage)
        Reraise(Handle_OSD_Exception_CTRL_BREAK self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_Exception_CTRL_BREAK_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_Exception_CTRL_BREAK self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_Exception_CTRL_BREAK_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_Exception_CTRL_BREAK self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_Exception_CTRL_BREAK_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_Exception_CTRL_BREAK self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_Exception_CTRL_BREAK_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_Exception_CTRL_BREAK self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_Exception_CTRL_BREAK self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_CTRL_BREAK_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_Exception_CTRL_BREAK self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_Exception_CTRL_BREAK self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_CTRL_BREAK_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_Exception_CTRL_BREAK self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_Exception_CTRL_BREAK_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_Exception_CTRL_BREAK self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_CTRL_BREAK_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_Exception_CTRL_BREAK self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_Exception_CTRL_BREAK_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_Exception_CTRL_BREAK self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_CTRL_BREAK_DecrementRefCounter(self, *args)

Handle_OSD_Exception_CTRL_BREAK_swigregister = _OSD.Handle_OSD_Exception_CTRL_BREAK_swigregister
Handle_OSD_Exception_CTRL_BREAK_swigregister(Handle_OSD_Exception_CTRL_BREAK)

def Handle_OSD_Exception_CTRL_BREAK_DownCast(thing):
    return _OSD.Handle_OSD_Exception_CTRL_BREAK_DownCast(thing)
Handle_OSD_Exception_CTRL_BREAK_DownCast = _OSD.Handle_OSD_Exception_CTRL_BREAK_DownCast

class OSD_DirectoryIterator(object):
    """
    Manages a breadth-only search for sub-directories in the specified
    Path.
    There is no specific order of results.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OSD_DirectoryIterator self) -> OSD_DirectoryIterator
        __init__(OSD_DirectoryIterator self, OSD_Path where, TCollection_AsciiString Mask) -> OSD_DirectoryIterator

        Instantiates Object as Iterator.
        Wild-card "*" can be used in Mask the same way it
        is used by unix shell for file names

        :type where: OCC.wrapper.OSD.OSD_Path
        :type Mask: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        this = _OSD.new_OSD_DirectoryIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Destroy(self, *args):
        """Destroy(OSD_DirectoryIterator self)"""
        return _OSD.OSD_DirectoryIterator_Destroy(self, *args)


    def Initialize(self, *args):
        """
        Initialize(OSD_DirectoryIterator self, OSD_Path where, TCollection_AsciiString Mask)

        Initializes the current File Directory

        :type where: OCC.wrapper.OSD.OSD_Path
        :type Mask: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_DirectoryIterator_Initialize(self, *args)


    def More(self, *args):
        """
        More(OSD_DirectoryIterator self) -> Standard_Boolean

        Returns TRUE if other items are found while
        using the 'Tree' method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.OSD_DirectoryIterator_More(self, *args)


    def Next(self, *args):
        """
        Next(OSD_DirectoryIterator self)

        Sets the iterator to the next item.
        Returns the item value corresponding to the current
        position of the iterator.


        """
        return _OSD.OSD_DirectoryIterator_Next(self, *args)


    def Values(self, *args):
        """
        Values(OSD_DirectoryIterator self) -> OSD_Directory

        Returns the next item found .

        :rtype: OCC.wrapper.OSD.OSD_Directory

        """
        return _OSD.OSD_DirectoryIterator_Values(self, *args)


    def Failed(self, *args):
        """
        Failed(OSD_DirectoryIterator self) -> Standard_Boolean

        Returns TRUE if an error occurs

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.OSD_DirectoryIterator_Failed(self, *args)


    def Reset(self, *args):
        """
        Reset(OSD_DirectoryIterator self)

        Resets error counter to zero


        """
        return _OSD.OSD_DirectoryIterator_Reset(self, *args)


    def Perror(self, *args):
        """
        Perror(OSD_DirectoryIterator self)

        Raises OSD_Error


        """
        return _OSD.OSD_DirectoryIterator_Perror(self, *args)


    def Error(self, *args):
        """
        Error(OSD_DirectoryIterator self) -> Standard_Integer

        Returns error number if 'Failed' is TRUE.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.OSD_DirectoryIterator_Error(self, *args)

    __swig_destroy__ = _OSD.delete_OSD_DirectoryIterator
OSD_DirectoryIterator_swigregister = _OSD.OSD_DirectoryIterator_swigregister
OSD_DirectoryIterator_swigregister(OSD_DirectoryIterator)

class Handle_OSD_SIGHUP(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_SIGHUP self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_SIGHUP_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_SIGHUP self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_SIGHUP_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_SIGHUP self, OSD_SIGHUP thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_SIGHUP_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_SIGHUP self, Handle_OSD_SIGHUP theHandle) -> Handle_OSD_SIGHUP
        assign(Handle_OSD_SIGHUP self, OSD_SIGHUP thePtr) -> Handle_OSD_SIGHUP
        assign(Handle_OSD_SIGHUP self, Handle_OSD_SIGHUP theHandle) -> Handle_OSD_SIGHUP

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_SIGHUP_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_SIGHUP self) -> OSD_SIGHUP

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_SIGHUP_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_SIGHUP self) -> OSD_SIGHUP

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_SIGHUP___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_SIGHUP self) -> OSD_SIGHUP

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_SIGHUP___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_SIGHUP___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_SIGHUP___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_SIGHUP(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_SIGHUP_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_SIGHUP

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_SIGHUP self, Standard_CString const theMessage) -> Handle_OSD_SIGHUP

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_SIGHUP

        """
        return _OSD.Handle_OSD_SIGHUP_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_SIGHUP self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_SIGHUP_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_SIGHUP_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_SIGHUP_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_SIGHUP self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_SIGHUP_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_SIGHUP self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_SIGHUP_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_SIGHUP self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_SIGHUP_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_SIGHUP self)
        Reraise(Handle_OSD_SIGHUP self, Standard_CString const aMessage)
        Reraise(Handle_OSD_SIGHUP self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_SIGHUP_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_SIGHUP self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_SIGHUP_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_SIGHUP self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_SIGHUP_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_SIGHUP self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_SIGHUP_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_SIGHUP self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_SIGHUP self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_SIGHUP_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_SIGHUP self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_SIGHUP self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_SIGHUP_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_SIGHUP self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_SIGHUP_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_SIGHUP self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_SIGHUP_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_SIGHUP self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_SIGHUP_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_SIGHUP self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_SIGHUP_DecrementRefCounter(self, *args)

Handle_OSD_SIGHUP_swigregister = _OSD.Handle_OSD_SIGHUP_swigregister
Handle_OSD_SIGHUP_swigregister(Handle_OSD_SIGHUP)

def Handle_OSD_SIGHUP_DownCast(thing):
    return _OSD.Handle_OSD_SIGHUP_DownCast(thing)
Handle_OSD_SIGHUP_DownCast = _OSD.Handle_OSD_SIGHUP_DownCast

class OSD_Exception_FLT_OVERFLOW(OSD_Exception):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_Exception_FLT_OVERFLOW
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_Exception_FLT_OVERFLOW(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_Exception_FLT_OVERFLOW self) -> OSD_Exception_FLT_OVERFLOW
        __init__(OSD_Exception_FLT_OVERFLOW self, Standard_CString const theMessage) -> OSD_Exception_FLT_OVERFLOW

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_Exception_FLT_OVERFLOW(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_FLT_OVERFLOW

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_FLT_OVERFLOW

        """
        return _OSD.OSD_Exception_FLT_OVERFLOW_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_Exception_FLT_OVERFLOW_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_Exception_FLT_OVERFLOW_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_Exception_FLT_OVERFLOW_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_Exception_FLT_OVERFLOW
OSD_Exception_FLT_OVERFLOW_swigregister = _OSD.OSD_Exception_FLT_OVERFLOW_swigregister
OSD_Exception_FLT_OVERFLOW_swigregister(OSD_Exception_FLT_OVERFLOW)

def OSD_Exception_FLT_OVERFLOW_NewInstance(*args):
    """
    OSD_Exception_FLT_OVERFLOW_NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_FLT_OVERFLOW

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_FLT_OVERFLOW

    """
    return _OSD.OSD_Exception_FLT_OVERFLOW_NewInstance(*args)

def OSD_Exception_FLT_OVERFLOW_get_type_name(*args):
    """
    OSD_Exception_FLT_OVERFLOW_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_Exception_FLT_OVERFLOW_get_type_name(*args)

def OSD_Exception_FLT_OVERFLOW_get_type_descriptor(*args):
    """
    OSD_Exception_FLT_OVERFLOW_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_Exception_FLT_OVERFLOW_get_type_descriptor(*args)

class Handle_OSD_Exception_FLT_STACK_CHECK(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_Exception_FLT_STACK_CHECK self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_Exception_FLT_STACK_CHECK_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_Exception_FLT_STACK_CHECK self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_Exception_FLT_STACK_CHECK_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_Exception_FLT_STACK_CHECK self, OSD_Exception_FLT_STACK_CHECK thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_Exception_FLT_STACK_CHECK_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_Exception_FLT_STACK_CHECK self, Handle_OSD_Exception_FLT_STACK_CHECK theHandle) -> Handle_OSD_Exception_FLT_STACK_CHECK
        assign(Handle_OSD_Exception_FLT_STACK_CHECK self, OSD_Exception_FLT_STACK_CHECK thePtr) -> Handle_OSD_Exception_FLT_STACK_CHECK
        assign(Handle_OSD_Exception_FLT_STACK_CHECK self, Handle_OSD_Exception_FLT_STACK_CHECK theHandle) -> Handle_OSD_Exception_FLT_STACK_CHECK

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_Exception_FLT_STACK_CHECK_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_Exception_FLT_STACK_CHECK self) -> OSD_Exception_FLT_STACK_CHECK

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_FLT_STACK_CHECK_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_Exception_FLT_STACK_CHECK self) -> OSD_Exception_FLT_STACK_CHECK

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_FLT_STACK_CHECK___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_Exception_FLT_STACK_CHECK self) -> OSD_Exception_FLT_STACK_CHECK

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_Exception_FLT_STACK_CHECK___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_Exception_FLT_STACK_CHECK___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_Exception_FLT_STACK_CHECK___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_Exception_FLT_STACK_CHECK(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_Exception_FLT_STACK_CHECK_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_Exception_FLT_STACK_CHECK

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_Exception_FLT_STACK_CHECK self, Standard_CString const theMessage) -> Handle_OSD_Exception_FLT_STACK_CHECK

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_FLT_STACK_CHECK

        """
        return _OSD.Handle_OSD_Exception_FLT_STACK_CHECK_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_Exception_FLT_STACK_CHECK self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_Exception_FLT_STACK_CHECK_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_FLT_STACK_CHECK_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_FLT_STACK_CHECK_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_Exception_FLT_STACK_CHECK self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_Exception_FLT_STACK_CHECK_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_Exception_FLT_STACK_CHECK self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_FLT_STACK_CHECK_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_Exception_FLT_STACK_CHECK self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_FLT_STACK_CHECK_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_Exception_FLT_STACK_CHECK self)
        Reraise(Handle_OSD_Exception_FLT_STACK_CHECK self, Standard_CString const aMessage)
        Reraise(Handle_OSD_Exception_FLT_STACK_CHECK self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_Exception_FLT_STACK_CHECK_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_Exception_FLT_STACK_CHECK self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_Exception_FLT_STACK_CHECK_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_Exception_FLT_STACK_CHECK self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_Exception_FLT_STACK_CHECK_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_Exception_FLT_STACK_CHECK self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_Exception_FLT_STACK_CHECK_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_Exception_FLT_STACK_CHECK self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_Exception_FLT_STACK_CHECK self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_FLT_STACK_CHECK_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_Exception_FLT_STACK_CHECK self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_Exception_FLT_STACK_CHECK self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_FLT_STACK_CHECK_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_Exception_FLT_STACK_CHECK self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_Exception_FLT_STACK_CHECK_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_Exception_FLT_STACK_CHECK self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_FLT_STACK_CHECK_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_Exception_FLT_STACK_CHECK self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_Exception_FLT_STACK_CHECK_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_Exception_FLT_STACK_CHECK self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_FLT_STACK_CHECK_DecrementRefCounter(self, *args)

Handle_OSD_Exception_FLT_STACK_CHECK_swigregister = _OSD.Handle_OSD_Exception_FLT_STACK_CHECK_swigregister
Handle_OSD_Exception_FLT_STACK_CHECK_swigregister(Handle_OSD_Exception_FLT_STACK_CHECK)

def Handle_OSD_Exception_FLT_STACK_CHECK_DownCast(thing):
    return _OSD.Handle_OSD_Exception_FLT_STACK_CHECK_DownCast(thing)
Handle_OSD_Exception_FLT_STACK_CHECK_DownCast = _OSD.Handle_OSD_Exception_FLT_STACK_CHECK_DownCast

class Handle_OSD_SIGKILL(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_SIGKILL self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_SIGKILL_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_SIGKILL self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_SIGKILL_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_SIGKILL self, OSD_SIGKILL thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_SIGKILL_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_SIGKILL self, Handle_OSD_SIGKILL theHandle) -> Handle_OSD_SIGKILL
        assign(Handle_OSD_SIGKILL self, OSD_SIGKILL thePtr) -> Handle_OSD_SIGKILL
        assign(Handle_OSD_SIGKILL self, Handle_OSD_SIGKILL theHandle) -> Handle_OSD_SIGKILL

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_SIGKILL_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_SIGKILL self) -> OSD_SIGKILL

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_SIGKILL_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_SIGKILL self) -> OSD_SIGKILL

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_SIGKILL___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_SIGKILL self) -> OSD_SIGKILL

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_SIGKILL___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_SIGKILL___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_SIGKILL___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_SIGKILL(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_SIGKILL_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_SIGKILL

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_SIGKILL self, Standard_CString const theMessage) -> Handle_OSD_SIGKILL

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_SIGKILL

        """
        return _OSD.Handle_OSD_SIGKILL_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_SIGKILL self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_SIGKILL_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_SIGKILL_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_SIGKILL_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_SIGKILL self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_SIGKILL_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_SIGKILL self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_SIGKILL_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_SIGKILL self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_SIGKILL_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_SIGKILL self)
        Reraise(Handle_OSD_SIGKILL self, Standard_CString const aMessage)
        Reraise(Handle_OSD_SIGKILL self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_SIGKILL_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_SIGKILL self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_SIGKILL_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_SIGKILL self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_SIGKILL_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_SIGKILL self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_SIGKILL_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_SIGKILL self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_SIGKILL self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_SIGKILL_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_SIGKILL self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_SIGKILL self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_SIGKILL_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_SIGKILL self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_SIGKILL_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_SIGKILL self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_SIGKILL_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_SIGKILL self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_SIGKILL_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_SIGKILL self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_SIGKILL_DecrementRefCounter(self, *args)

Handle_OSD_SIGKILL_swigregister = _OSD.Handle_OSD_SIGKILL_swigregister
Handle_OSD_SIGKILL_swigregister(Handle_OSD_SIGKILL)

def Handle_OSD_SIGKILL_DownCast(thing):
    return _OSD.Handle_OSD_SIGKILL_DownCast(thing)
Handle_OSD_SIGKILL_DownCast = _OSD.Handle_OSD_SIGKILL_DownCast

class OSD_Environment(object):
    """
    Management of system environment variables
    An environment variable is composed of a variable name
    and its value.

    To be portable among various systems, environment variables
    are local to a process.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OSD_Environment self) -> OSD_Environment
        __init__(OSD_Environment self, TCollection_AsciiString Name) -> OSD_Environment
        __init__(OSD_Environment self, TCollection_AsciiString Name, TCollection_AsciiString Value) -> OSD_Environment

        Creates an Environment variable initialized with Value.

        :type Name: OCC.wrapper.TCollection.TCollection_AsciiString
        :type Value: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        this = _OSD.new_OSD_Environment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetValue(self, *args):
        """
        SetValue(OSD_Environment self, TCollection_AsciiString Value)

        Changes environment variable value.
        Raises ConstructionError either if the string contains
        characters not in range of ' '...'~' or if the string
        contains the character '$' which is forbiden.

        :type Value: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Environment_SetValue(self, *args)


    def Value(self, *args):
        """
        Value(OSD_Environment self) -> TCollection_AsciiString

        Gets the value of an environment variable

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Environment_Value(self, *args)


    def SetName(self, *args):
        """
        SetName(OSD_Environment self, TCollection_AsciiString name)

        Changes environment variable name.
        Raises ConstructionError either if the string contains
        characters not in range of ' '...'~' or if the string
        contains the character '$' which is forbiden.

        :type name: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Environment_SetName(self, *args)


    def Name(self, *args):
        """
        Name(OSD_Environment self) -> TCollection_AsciiString

        Gets the name of <me>.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Environment_Name(self, *args)


    def Build(self, *args):
        """
        Build(OSD_Environment self)

        Sets the value of an environment variable
        into system (physically).


        """
        return _OSD.OSD_Environment_Build(self, *args)


    def Remove(self, *args):
        """
        Remove(OSD_Environment self)

        Removes (physically) an environment variable


        """
        return _OSD.OSD_Environment_Remove(self, *args)


    def Failed(self, *args):
        """
        Failed(OSD_Environment self) -> Standard_Boolean

        Returns TRUE if an error occurs

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.OSD_Environment_Failed(self, *args)


    def Reset(self, *args):
        """
        Reset(OSD_Environment self)

        Resets error counter to zero


        """
        return _OSD.OSD_Environment_Reset(self, *args)


    def Perror(self, *args):
        """
        Perror(OSD_Environment self)

        Raises OSD_Error


        """
        return _OSD.OSD_Environment_Perror(self, *args)


    def Error(self, *args):
        """
        Error(OSD_Environment self) -> Standard_Integer

        Returns error number if 'Failed' is TRUE.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.OSD_Environment_Error(self, *args)

    __swig_destroy__ = _OSD.delete_OSD_Environment
OSD_Environment_swigregister = _OSD.OSD_Environment_swigregister
OSD_Environment_swigregister(OSD_Environment)

class Handle_OSD_Exception_INT_OVERFLOW(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_Exception_INT_OVERFLOW self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_Exception_INT_OVERFLOW_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_Exception_INT_OVERFLOW self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_Exception_INT_OVERFLOW_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_Exception_INT_OVERFLOW self, OSD_Exception_INT_OVERFLOW thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_Exception_INT_OVERFLOW_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_Exception_INT_OVERFLOW self, Handle_OSD_Exception_INT_OVERFLOW theHandle) -> Handle_OSD_Exception_INT_OVERFLOW
        assign(Handle_OSD_Exception_INT_OVERFLOW self, OSD_Exception_INT_OVERFLOW thePtr) -> Handle_OSD_Exception_INT_OVERFLOW
        assign(Handle_OSD_Exception_INT_OVERFLOW self, Handle_OSD_Exception_INT_OVERFLOW theHandle) -> Handle_OSD_Exception_INT_OVERFLOW

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_Exception_INT_OVERFLOW_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_Exception_INT_OVERFLOW self) -> OSD_Exception_INT_OVERFLOW

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_INT_OVERFLOW_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_Exception_INT_OVERFLOW self) -> OSD_Exception_INT_OVERFLOW

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_INT_OVERFLOW___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_Exception_INT_OVERFLOW self) -> OSD_Exception_INT_OVERFLOW

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_Exception_INT_OVERFLOW___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_Exception_INT_OVERFLOW___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_Exception_INT_OVERFLOW___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_Exception_INT_OVERFLOW(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_Exception_INT_OVERFLOW_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_Exception_INT_OVERFLOW

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_Exception_INT_OVERFLOW self, Standard_CString const theMessage) -> Handle_OSD_Exception_INT_OVERFLOW

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_INT_OVERFLOW

        """
        return _OSD.Handle_OSD_Exception_INT_OVERFLOW_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_Exception_INT_OVERFLOW self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_Exception_INT_OVERFLOW_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_INT_OVERFLOW_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_INT_OVERFLOW_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_Exception_INT_OVERFLOW self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_Exception_INT_OVERFLOW_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_Exception_INT_OVERFLOW self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_INT_OVERFLOW_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_Exception_INT_OVERFLOW self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_INT_OVERFLOW_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_Exception_INT_OVERFLOW self)
        Reraise(Handle_OSD_Exception_INT_OVERFLOW self, Standard_CString const aMessage)
        Reraise(Handle_OSD_Exception_INT_OVERFLOW self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_Exception_INT_OVERFLOW_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_Exception_INT_OVERFLOW self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_Exception_INT_OVERFLOW_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_Exception_INT_OVERFLOW self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_Exception_INT_OVERFLOW_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_Exception_INT_OVERFLOW self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_Exception_INT_OVERFLOW_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_Exception_INT_OVERFLOW self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_Exception_INT_OVERFLOW self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_INT_OVERFLOW_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_Exception_INT_OVERFLOW self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_Exception_INT_OVERFLOW self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_INT_OVERFLOW_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_Exception_INT_OVERFLOW self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_Exception_INT_OVERFLOW_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_Exception_INT_OVERFLOW self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_INT_OVERFLOW_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_Exception_INT_OVERFLOW self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_Exception_INT_OVERFLOW_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_Exception_INT_OVERFLOW self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_INT_OVERFLOW_DecrementRefCounter(self, *args)

Handle_OSD_Exception_INT_OVERFLOW_swigregister = _OSD.Handle_OSD_Exception_INT_OVERFLOW_swigregister
Handle_OSD_Exception_INT_OVERFLOW_swigregister(Handle_OSD_Exception_INT_OVERFLOW)

def Handle_OSD_Exception_INT_OVERFLOW_DownCast(thing):
    return _OSD.Handle_OSD_Exception_INT_OVERFLOW_DownCast(thing)
Handle_OSD_Exception_INT_OVERFLOW_DownCast = _OSD.Handle_OSD_Exception_INT_OVERFLOW_DownCast

class OSD_Process(object):
    """A set of system process tools"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OSD_Process self) -> OSD_Process

        Initializes the object and prepare for a possible dump


        """
        this = _OSD.new_OSD_Process(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def TerminalType(self, *args):
        """
        TerminalType(OSD_Process self, TCollection_AsciiString Name)

        Returns the terminal used (vt100, vt200 ,sun-cmd ...)

        :type Name: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Process_TerminalType(self, *args)


    def SystemDate(self, *args):
        """
        SystemDate(OSD_Process self) -> Quantity_Date

        Gets system date.

        :rtype: OCC.wrapper.Quantity.Quantity_Date

        """
        return _OSD.OSD_Process_SystemDate(self, *args)


    def UserName(self, *args):
        """
        UserName(OSD_Process self) -> TCollection_AsciiString

        Returns the user name.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Process_UserName(self, *args)


    def IsSuperUser(self, *args):
        """
        IsSuperUser(OSD_Process self) -> Standard_Boolean

        Returns True if the process user is the super-user.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.OSD_Process_IsSuperUser(self, *args)


    def ProcessId(self, *args):
        """
        ProcessId(OSD_Process self) -> Standard_Integer

        Returns the 'Process Id'

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.OSD_Process_ProcessId(self, *args)


    def CurrentDirectory(self, *args):
        """
        CurrentDirectory(OSD_Process self) -> OSD_Path

        Returns the current path where the process is.

        :rtype: OCC.wrapper.OSD.OSD_Path

        """
        return _OSD.OSD_Process_CurrentDirectory(self, *args)


    def Failed(self, *args):
        """
        Failed(OSD_Process self) -> Standard_Boolean

        Returns TRUE if an error occurs

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.OSD_Process_Failed(self, *args)


    def Reset(self, *args):
        """
        Reset(OSD_Process self)

        Resets error counter to zero


        """
        return _OSD.OSD_Process_Reset(self, *args)


    def Perror(self, *args):
        """
        Perror(OSD_Process self)

        Raises OSD_Error


        """
        return _OSD.OSD_Process_Perror(self, *args)


    def Error(self, *args):
        """
        Error(OSD_Process self) -> Standard_Integer

        Returns error number if 'Failed' is TRUE.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.OSD_Process_Error(self, *args)

    __swig_destroy__ = _OSD.delete_OSD_Process
OSD_Process_swigregister = _OSD.OSD_Process_swigregister
OSD_Process_swigregister(OSD_Process)

class OSD_Exception_PRIV_INSTRUCTION(OSD_Exception):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_Exception_PRIV_INSTRUCTION
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_Exception_PRIV_INSTRUCTION(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_Exception_PRIV_INSTRUCTION self) -> OSD_Exception_PRIV_INSTRUCTION
        __init__(OSD_Exception_PRIV_INSTRUCTION self, Standard_CString const theMessage) -> OSD_Exception_PRIV_INSTRUCTION

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_Exception_PRIV_INSTRUCTION(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_PRIV_INSTRUCTION

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_PRIV_INSTRUCTION

        """
        return _OSD.OSD_Exception_PRIV_INSTRUCTION_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_Exception_PRIV_INSTRUCTION_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_Exception_PRIV_INSTRUCTION_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_Exception_PRIV_INSTRUCTION_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_Exception_PRIV_INSTRUCTION
OSD_Exception_PRIV_INSTRUCTION_swigregister = _OSD.OSD_Exception_PRIV_INSTRUCTION_swigregister
OSD_Exception_PRIV_INSTRUCTION_swigregister(OSD_Exception_PRIV_INSTRUCTION)

def OSD_Exception_PRIV_INSTRUCTION_NewInstance(*args):
    """
    OSD_Exception_PRIV_INSTRUCTION_NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_PRIV_INSTRUCTION

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_PRIV_INSTRUCTION

    """
    return _OSD.OSD_Exception_PRIV_INSTRUCTION_NewInstance(*args)

def OSD_Exception_PRIV_INSTRUCTION_get_type_name(*args):
    """
    OSD_Exception_PRIV_INSTRUCTION_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_Exception_PRIV_INSTRUCTION_get_type_name(*args)

def OSD_Exception_PRIV_INSTRUCTION_get_type_descriptor(*args):
    """
    OSD_Exception_PRIV_INSTRUCTION_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_Exception_PRIV_INSTRUCTION_get_type_descriptor(*args)

class OSD_SIGILL(OSD_Signal):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_SIGILL
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_SIGILL(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_SIGILL self) -> OSD_SIGILL
        __init__(OSD_SIGILL self, Standard_CString const theMessage) -> OSD_SIGILL

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_SIGILL(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_SIGILL

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_SIGILL

        """
        return _OSD.OSD_SIGILL_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_SIGILL_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_SIGILL_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_SIGILL_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_SIGILL
OSD_SIGILL_swigregister = _OSD.OSD_SIGILL_swigregister
OSD_SIGILL_swigregister(OSD_SIGILL)

def OSD_SIGILL_NewInstance(*args):
    """
    OSD_SIGILL_NewInstance(Standard_CString const theMessage) -> Handle_OSD_SIGILL

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_SIGILL

    """
    return _OSD.OSD_SIGILL_NewInstance(*args)

def OSD_SIGILL_get_type_name(*args):
    """
    OSD_SIGILL_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_SIGILL_get_type_name(*args)

def OSD_SIGILL_get_type_descriptor(*args):
    """
    OSD_SIGILL_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_SIGILL_get_type_descriptor(*args)

class OSD_FileIterator(object):
    """
    Manages a breadth-only search for files in the specified Path.
    There is no specific order of results.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OSD_FileIterator self) -> OSD_FileIterator
        __init__(OSD_FileIterator self, OSD_Path where, TCollection_AsciiString Mask) -> OSD_FileIterator

        Instantiates Object as Iterator;
        Wild-card "*" can be used in Mask the same way it
        is used by unix shell for file names

        :type where: OCC.wrapper.OSD.OSD_Path
        :type Mask: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        this = _OSD.new_OSD_FileIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Destroy(self, *args):
        """Destroy(OSD_FileIterator self)"""
        return _OSD.OSD_FileIterator_Destroy(self, *args)


    def Initialize(self, *args):
        """
        Initialize(OSD_FileIterator self, OSD_Path where, TCollection_AsciiString Mask)

        Initializes the current File Iterator

        :type where: OCC.wrapper.OSD.OSD_Path
        :type Mask: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_FileIterator_Initialize(self, *args)


    def More(self, *args):
        """
        More(OSD_FileIterator self) -> Standard_Boolean

        Returns TRUE if there are other items using the 'Tree'
        method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.OSD_FileIterator_More(self, *args)


    def Next(self, *args):
        """
        Next(OSD_FileIterator self)

        Sets the iterator to the next item.
        Returns the item value corresponding to the current
        position of the iterator.


        """
        return _OSD.OSD_FileIterator_Next(self, *args)


    def Values(self, *args):
        """
        Values(OSD_FileIterator self) -> OSD_File

        Returns the next file found .

        :rtype: OCC.wrapper.OSD.OSD_File

        """
        return _OSD.OSD_FileIterator_Values(self, *args)


    def Failed(self, *args):
        """
        Failed(OSD_FileIterator self) -> Standard_Boolean

        Returns TRUE if an error occurs

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.OSD_FileIterator_Failed(self, *args)


    def Reset(self, *args):
        """
        Reset(OSD_FileIterator self)

        Resets error counter to zero


        """
        return _OSD.OSD_FileIterator_Reset(self, *args)


    def Perror(self, *args):
        """
        Perror(OSD_FileIterator self)

        Raises OSD_Error


        """
        return _OSD.OSD_FileIterator_Perror(self, *args)


    def Error(self, *args):
        """
        Error(OSD_FileIterator self) -> Standard_Integer

        Returns error number if 'Failed' is TRUE.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.OSD_FileIterator_Error(self, *args)

    __swig_destroy__ = _OSD.delete_OSD_FileIterator
OSD_FileIterator_swigregister = _OSD.OSD_FileIterator_swigregister
OSD_FileIterator_swigregister(OSD_FileIterator)

class Handle_OSD_Exception_FLT_DENORMAL_OPERAND(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self, OSD_Exception_FLT_DENORMAL_OPERAND thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self, Handle_OSD_Exception_FLT_DENORMAL_OPERAND theHandle) -> Handle_OSD_Exception_FLT_DENORMAL_OPERAND
        assign(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self, OSD_Exception_FLT_DENORMAL_OPERAND thePtr) -> Handle_OSD_Exception_FLT_DENORMAL_OPERAND
        assign(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self, Handle_OSD_Exception_FLT_DENORMAL_OPERAND theHandle) -> Handle_OSD_Exception_FLT_DENORMAL_OPERAND

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self) -> OSD_Exception_FLT_DENORMAL_OPERAND

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self) -> OSD_Exception_FLT_DENORMAL_OPERAND

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self) -> OSD_Exception_FLT_DENORMAL_OPERAND

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_Exception_FLT_DENORMAL_OPERAND(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_Exception_FLT_DENORMAL_OPERAND

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self, Standard_CString const theMessage) -> Handle_OSD_Exception_FLT_DENORMAL_OPERAND

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND

        """
        return _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self)
        Reraise(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self, Standard_CString const aMessage)
        Reraise(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_Exception_FLT_DENORMAL_OPERAND self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND_DecrementRefCounter(self, *args)

Handle_OSD_Exception_FLT_DENORMAL_OPERAND_swigregister = _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND_swigregister
Handle_OSD_Exception_FLT_DENORMAL_OPERAND_swigregister(Handle_OSD_Exception_FLT_DENORMAL_OPERAND)

def Handle_OSD_Exception_FLT_DENORMAL_OPERAND_DownCast(thing):
    return _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND_DownCast(thing)
Handle_OSD_Exception_FLT_DENORMAL_OPERAND_DownCast = _OSD.Handle_OSD_Exception_FLT_DENORMAL_OPERAND_DownCast

class OSD_Exception_FLT_INEXACT_RESULT(OSD_Exception):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_Exception_FLT_INEXACT_RESULT
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_Exception_FLT_INEXACT_RESULT(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_Exception_FLT_INEXACT_RESULT self) -> OSD_Exception_FLT_INEXACT_RESULT
        __init__(OSD_Exception_FLT_INEXACT_RESULT self, Standard_CString const theMessage) -> OSD_Exception_FLT_INEXACT_RESULT

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_Exception_FLT_INEXACT_RESULT(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_FLT_INEXACT_RESULT

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT

        """
        return _OSD.OSD_Exception_FLT_INEXACT_RESULT_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_Exception_FLT_INEXACT_RESULT_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_Exception_FLT_INEXACT_RESULT_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_Exception_FLT_INEXACT_RESULT_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_Exception_FLT_INEXACT_RESULT
OSD_Exception_FLT_INEXACT_RESULT_swigregister = _OSD.OSD_Exception_FLT_INEXACT_RESULT_swigregister
OSD_Exception_FLT_INEXACT_RESULT_swigregister(OSD_Exception_FLT_INEXACT_RESULT)

def OSD_Exception_FLT_INEXACT_RESULT_NewInstance(*args):
    """
    OSD_Exception_FLT_INEXACT_RESULT_NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_FLT_INEXACT_RESULT

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT

    """
    return _OSD.OSD_Exception_FLT_INEXACT_RESULT_NewInstance(*args)

def OSD_Exception_FLT_INEXACT_RESULT_get_type_name(*args):
    """
    OSD_Exception_FLT_INEXACT_RESULT_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_Exception_FLT_INEXACT_RESULT_get_type_name(*args)

def OSD_Exception_FLT_INEXACT_RESULT_get_type_descriptor(*args):
    """
    OSD_Exception_FLT_INEXACT_RESULT_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_Exception_FLT_INEXACT_RESULT_get_type_descriptor(*args)

class Handle_OSD_SIGBUS(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_SIGBUS self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_SIGBUS_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_SIGBUS self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_SIGBUS_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_SIGBUS self, OSD_SIGBUS thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_SIGBUS_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_SIGBUS self, Handle_OSD_SIGBUS theHandle) -> Handle_OSD_SIGBUS
        assign(Handle_OSD_SIGBUS self, OSD_SIGBUS thePtr) -> Handle_OSD_SIGBUS
        assign(Handle_OSD_SIGBUS self, Handle_OSD_SIGBUS theHandle) -> Handle_OSD_SIGBUS

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_SIGBUS_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_SIGBUS self) -> OSD_SIGBUS

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_SIGBUS_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_SIGBUS self) -> OSD_SIGBUS

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_SIGBUS___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_SIGBUS self) -> OSD_SIGBUS

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_SIGBUS___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_SIGBUS___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_SIGBUS___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_SIGBUS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_SIGBUS_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_SIGBUS

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_SIGBUS self, Standard_CString const theMessage) -> Handle_OSD_SIGBUS

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_SIGBUS

        """
        return _OSD.Handle_OSD_SIGBUS_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_SIGBUS self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_SIGBUS_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_SIGBUS_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_SIGBUS_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_SIGBUS self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_SIGBUS_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_SIGBUS self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_SIGBUS_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_SIGBUS self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_SIGBUS_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_SIGBUS self)
        Reraise(Handle_OSD_SIGBUS self, Standard_CString const aMessage)
        Reraise(Handle_OSD_SIGBUS self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_SIGBUS_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_SIGBUS self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_SIGBUS_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_SIGBUS self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_SIGBUS_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_SIGBUS self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_SIGBUS_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_SIGBUS self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_SIGBUS self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_SIGBUS_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_SIGBUS self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_SIGBUS self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_SIGBUS_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_SIGBUS self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_SIGBUS_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_SIGBUS self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_SIGBUS_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_SIGBUS self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_SIGBUS_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_SIGBUS self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_SIGBUS_DecrementRefCounter(self, *args)

Handle_OSD_SIGBUS_swigregister = _OSD.Handle_OSD_SIGBUS_swigregister
Handle_OSD_SIGBUS_swigregister(Handle_OSD_SIGBUS)

def Handle_OSD_SIGBUS_DownCast(thing):
    return _OSD.Handle_OSD_SIGBUS_DownCast(thing)
Handle_OSD_SIGBUS_DownCast = _OSD.Handle_OSD_SIGBUS_DownCast

class Handle_OSD_OSDError(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_OSDError self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_OSDError_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_OSDError self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_OSDError_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_OSDError self, OSD_OSDError thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_OSDError_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_OSDError self, Handle_OSD_OSDError theHandle) -> Handle_OSD_OSDError
        assign(Handle_OSD_OSDError self, OSD_OSDError thePtr) -> Handle_OSD_OSDError
        assign(Handle_OSD_OSDError self, Handle_OSD_OSDError theHandle) -> Handle_OSD_OSDError

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_OSDError_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_OSDError self) -> OSD_OSDError

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_OSDError_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_OSDError self) -> OSD_OSDError

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_OSDError___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_OSDError self) -> OSD_OSDError

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_OSDError___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_OSDError___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_OSDError___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_OSDError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_OSDError_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_OSDError

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_OSDError self, Standard_CString const theMessage) -> Handle_OSD_OSDError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_OSDError

        """
        return _OSD.Handle_OSD_OSDError_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_OSDError self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_OSDError_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_OSDError_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_OSDError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_OSDError self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_OSDError_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_OSDError self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_OSDError_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_OSDError self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_OSDError_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_OSDError self)
        Reraise(Handle_OSD_OSDError self, Standard_CString const aMessage)
        Reraise(Handle_OSD_OSDError self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_OSDError_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_OSDError self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_OSDError_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_OSDError self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_OSDError_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_OSDError self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_OSDError_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_OSDError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_OSDError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_OSDError_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_OSDError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_OSDError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_OSDError_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_OSDError self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_OSDError_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_OSDError self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_OSDError_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_OSDError self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_OSDError_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_OSDError self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_OSDError_DecrementRefCounter(self, *args)

Handle_OSD_OSDError_swigregister = _OSD.Handle_OSD_OSDError_swigregister
Handle_OSD_OSDError_swigregister(Handle_OSD_OSDError)

def Handle_OSD_OSDError_DownCast(thing):
    return _OSD.Handle_OSD_OSDError_DownCast(thing)
Handle_OSD_OSDError_DownCast = _OSD.Handle_OSD_OSDError_DownCast

class OSD_Path(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OSD_Path self) -> OSD_Path
        __init__(OSD_Path self, TCollection_AsciiString aDependentName, OSD_SysType const aSysType=OSD_Default) -> OSD_Path
        __init__(OSD_Path self, TCollection_AsciiString aNode, TCollection_AsciiString aUsername, TCollection_AsciiString aPassword, TCollection_AsciiString aDisk, TCollection_AsciiString aTrek, TCollection_AsciiString aName, TCollection_AsciiString anExtension) -> OSD_Path

        Initializes a system independent path.
        By default , the Path conversion will be assumed using
        currently used system.
        A special syntax is used to specify a "aTrek" in an
        independent manner :
        a "|" represents directory separator
        a "^" means directory above (father)
        examples:
        "|usr|bin" - On UNIX -> "/usr/bin"
        - On VMS  -> "[usr.bin]"
        - On MSDOS-> "\\usrin"
        - On MacOs-> ": usr : bin"

        "^|rep"    - On UNIX -> "../rep"
        - On VMS  -> "[-.rep]"
        - On MSDOS -> "..ep"
        - On MacOS->  ":: rep"

        "subdir|" - On UNIX -> "subdir/"
        - On VMS  -> "[.subdir.]"

        :type aNode: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aUsername: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aPassword: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aDisk: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aTrek: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type anExtension: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        this = _OSD.new_OSD_Path(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Values(self, *args):
        """
        Values(OSD_Path self, TCollection_AsciiString aNode, TCollection_AsciiString aUsername, TCollection_AsciiString aPassword, TCollection_AsciiString aDisk, TCollection_AsciiString aTrek, TCollection_AsciiString aName, TCollection_AsciiString anExtension)

        Gets each component of a path.

        :type aNode: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aUsername: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aPassword: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aDisk: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aTrek: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type anExtension: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Path_Values(self, *args)


    def SetValues(self, *args):
        """
        SetValues(OSD_Path self, TCollection_AsciiString aNode, TCollection_AsciiString aUsername, TCollection_AsciiString aPassword, TCollection_AsciiString aDisk, TCollection_AsciiString aTrek, TCollection_AsciiString aName, TCollection_AsciiString anExtension)

        Sets each component of a path.

        :type aNode: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aUsername: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aPassword: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aDisk: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aTrek: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type anExtension: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Path_SetValues(self, *args)


    def SystemName(self, *args):
        """
        SystemName(OSD_Path self, TCollection_AsciiString FullName, OSD_SysType const aType=OSD_Default)

        Returns system dependent path
        <aType> is one among Unix,VMS ...
        This function is not private because you may need to
        display system dependent path on a front-end.
        It can be useful when communicating with another system.
        For instance when you want to communicate between VMS and Unix
        to transfer files, or to do a remote procedure call
        using files.
        example :
        OSD_Path myPath ("sparc4", "sga", "secret_passwd",
        "$5$dkb100","|users|examples");
        Internal ( Dependent_name );
        On UNIX  sga"secret_passwd"@sparc4:/users/examples
        On VMS   sparc4"sga secret_passwd"::$5$dkb100:[users.examples]
        Sets each component of a Path giving its system dependent name.

        :type FullName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aType: OCC.wrapper.OSD.OSD_SysType

        """
        return _OSD.OSD_Path_SystemName(self, *args)


    def ExpandedName(self, *args):
        """
        ExpandedName(OSD_Path self, TCollection_AsciiString aName)

        Returns system dependent path resolving logical symbols.

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Path_ExpandedName(self, *args)


    def IsValid(*args):
        """
        IsValid(TCollection_AsciiString theDependentName, OSD_SysType const theSysType=OSD_Default) -> Standard_Boolean

        Returns TRUE if <theDependentName> is valid for this SysType.

        :type theDependentName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type theSysType: OCC.wrapper.OSD.OSD_SysType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.OSD_Path_IsValid(*args)

    IsValid = staticmethod(IsValid)

    def UpTrek(self, *args):
        """
        UpTrek(OSD_Path self)

        This removes the last directory name in <aTrek>
        and returns result.
        ex:  me = "|usr|bin|todo.sh"
        me.UpTrek() gives me = "|usr|todo.sh"
        if <me> contains "|", me.UpTrek() will give again "|"
        without any error.


        """
        return _OSD.OSD_Path_UpTrek(self, *args)


    def DownTrek(self, *args):
        """
        DownTrek(OSD_Path self, TCollection_AsciiString aName)

        This appends a directory name into the Trek.
        ex: me = "|usr|todo.sh"
        me.DownTrek("bin") gives me = "|usr|bin|todo.sh".

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Path_DownTrek(self, *args)


    def TrekLength(self, *args):
        """
        TrekLength(OSD_Path self) -> Standard_Integer

        Returns number of components in Trek of <me>.
        ex: me = "|usr|sys|etc|bin"
        me.TrekLength() returns 4.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.OSD_Path_TrekLength(self, *args)


    def RemoveATrek(self, *args):
        """
        RemoveATrek(OSD_Path self, Standard_Integer const where)
        RemoveATrek(OSD_Path self, TCollection_AsciiString aName)

        This removes <aName> from <me> in Trek.
        No error is raised if <aName> is not in <me>.
        ex:  me = "|usr|sys|etc|doc"
        me.RemoveATrek("sys") gives me = "|usr|etc|doc".

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Path_RemoveATrek(self, *args)


    def TrekValue(self, *args):
        """
        TrekValue(OSD_Path self, Standard_Integer const where) -> TCollection_AsciiString

        Returns component of Trek in <me> at position <where>.
        ex:  me = "|usr|bin|sys|"
        me.TrekValue(2) returns "bin"

        :type where: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Path_TrekValue(self, *args)


    def InsertATrek(self, *args):
        """
        InsertATrek(OSD_Path self, TCollection_AsciiString aName, Standard_Integer const where)

        This inserts <aName> at position <where> into Trek of <me>.
        ex:  me = "|usr|etc|"
        me.InsertATrek("sys",2) gives me = "|usr|sys|etc"

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString
        :type where: int

        """
        return _OSD.OSD_Path_InsertATrek(self, *args)


    def Node(self, *args):
        """
        Node(OSD_Path self) -> TCollection_AsciiString

        Returns Node of <me>.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Path_Node(self, *args)


    def UserName(self, *args):
        """
        UserName(OSD_Path self) -> TCollection_AsciiString

        Returns UserName of <me>.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Path_UserName(self, *args)


    def Password(self, *args):
        """
        Password(OSD_Path self) -> TCollection_AsciiString

        Returns Password of <me>.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Path_Password(self, *args)


    def Disk(self, *args):
        """
        Disk(OSD_Path self) -> TCollection_AsciiString

        Returns Disk of <me>.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Path_Disk(self, *args)


    def Trek(self, *args):
        """
        Trek(OSD_Path self) -> TCollection_AsciiString

        Returns Trek of <me>.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Path_Trek(self, *args)


    def Name(self, *args):
        """
        Name(OSD_Path self) -> TCollection_AsciiString

        Returns file name of <me>.
        If <me> hasn't been initialized, it returns an empty AsciiString.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Path_Name(self, *args)


    def Extension(self, *args):
        """
        Extension(OSD_Path self) -> TCollection_AsciiString

        Returns my extension name.
        This returns an empty string if path contains no file name.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Path_Extension(self, *args)


    def SetNode(self, *args):
        """
        SetNode(OSD_Path self, TCollection_AsciiString aName)

        Sets Node of <me>.

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Path_SetNode(self, *args)


    def SetUserName(self, *args):
        """
        SetUserName(OSD_Path self, TCollection_AsciiString aName)

        Sets UserName of <me>.

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Path_SetUserName(self, *args)


    def SetPassword(self, *args):
        """
        SetPassword(OSD_Path self, TCollection_AsciiString aName)

        Sets Password of <me>.

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Path_SetPassword(self, *args)


    def SetDisk(self, *args):
        """
        SetDisk(OSD_Path self, TCollection_AsciiString aName)

        Sets Disk of <me>.

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Path_SetDisk(self, *args)


    def SetTrek(self, *args):
        """
        SetTrek(OSD_Path self, TCollection_AsciiString aName)

        Sets Trek of <me>.

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Path_SetTrek(self, *args)


    def SetName(self, *args):
        """
        SetName(OSD_Path self, TCollection_AsciiString aName)

        Sets file name of <me>.
        If <me> hasn't been initialized, it returns an empty AsciiString.

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Path_SetName(self, *args)


    def SetExtension(self, *args):
        """
        SetExtension(OSD_Path self, TCollection_AsciiString aName)

        Sets my extension name.

        :type aName: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Path_SetExtension(self, *args)


    def RelativePath(*args):
        """
        RelativePath(TCollection_AsciiString DirPath, TCollection_AsciiString AbsFilePath) -> TCollection_AsciiString

        Returns the relative file path between the absolute directory
        path <DirPath>  and the absolute file path <AbsFilePath>.
        If <DirPath> starts with "/", pathes are handled as
        on Unix, if it starts with a letter followed by ":", as on
        WNT. In particular on WNT directory names are not key sensitive.
        If handling fails, an empty string is returned.

        :type DirPath: OCC.wrapper.TCollection.TCollection_AsciiString
        :type AbsFilePath: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Path_RelativePath(*args)

    RelativePath = staticmethod(RelativePath)

    def AbsolutePath(*args):
        """
        AbsolutePath(TCollection_AsciiString DirPath, TCollection_AsciiString RelFilePath) -> TCollection_AsciiString

        Returns the absolute file path from the absolute directory path
        <DirPath> and the relative file path returned by RelativePath().
        If the RelFilePath is an absolute path, it is returned and the
        directory path is ignored.
        If handling fails, an empty string is returned.

        :type DirPath: OCC.wrapper.TCollection.TCollection_AsciiString
        :type RelFilePath: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Path_AbsolutePath(*args)

    AbsolutePath = staticmethod(AbsolutePath)
    __swig_destroy__ = _OSD.delete_OSD_Path
OSD_Path_swigregister = _OSD.OSD_Path_swigregister
OSD_Path_swigregister(OSD_Path)

def OSD_Path_IsValid(*args):
    """
    OSD_Path_IsValid(TCollection_AsciiString theDependentName, OSD_SysType const theSysType=OSD_Default) -> Standard_Boolean

    Returns TRUE if <theDependentName> is valid for this SysType.

    :type theDependentName: OCC.wrapper.TCollection.TCollection_AsciiString
    :type theSysType: OCC.wrapper.OSD.OSD_SysType
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _OSD.OSD_Path_IsValid(*args)

def OSD_Path_RelativePath(*args):
    """
    OSD_Path_RelativePath(TCollection_AsciiString DirPath, TCollection_AsciiString AbsFilePath) -> TCollection_AsciiString

    Returns the relative file path between the absolute directory
    path <DirPath>  and the absolute file path <AbsFilePath>.
    If <DirPath> starts with "/", pathes are handled as
    on Unix, if it starts with a letter followed by ":", as on
    WNT. In particular on WNT directory names are not key sensitive.
    If handling fails, an empty string is returned.

    :type DirPath: OCC.wrapper.TCollection.TCollection_AsciiString
    :type AbsFilePath: OCC.wrapper.TCollection.TCollection_AsciiString
    :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

    """
    return _OSD.OSD_Path_RelativePath(*args)

def OSD_Path_AbsolutePath(*args):
    """
    OSD_Path_AbsolutePath(TCollection_AsciiString DirPath, TCollection_AsciiString RelFilePath) -> TCollection_AsciiString

    Returns the absolute file path from the absolute directory path
    <DirPath> and the relative file path returned by RelativePath().
    If the RelFilePath is an absolute path, it is returned and the
    directory path is ignored.
    If handling fails, an empty string is returned.

    :type DirPath: OCC.wrapper.TCollection.TCollection_AsciiString
    :type RelFilePath: OCC.wrapper.TCollection.TCollection_AsciiString
    :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

    """
    return _OSD.OSD_Path_AbsolutePath(*args)

class OSD_Host(object):
    """
    Carries information about a Host
    System version ,host name, nodename ...
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OSD_Host self) -> OSD_Host

        Initializes current host by default.


        """
        this = _OSD.new_OSD_Host(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SystemVersion(self, *args):
        """
        SystemVersion(OSD_Host self) -> TCollection_AsciiString

        Returns system name and version

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Host_SystemVersion(self, *args)


    def SystemId(self, *args):
        """
        SystemId(OSD_Host self) -> OSD_SysType

        Returns the system type (UNIX System V, UNIX BSD, MS-DOS...)

        :rtype: OCC.wrapper.OSD.OSD_SysType

        """
        return _OSD.OSD_Host_SystemId(self, *args)


    def HostName(self, *args):
        """
        HostName(OSD_Host self) -> TCollection_AsciiString

        Returns host name.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Host_HostName(self, *args)


    def AvailableMemory(self, *args):
        """
        AvailableMemory(OSD_Host self) -> Standard_Integer

        Returns available memory in Kilobytes.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.OSD_Host_AvailableMemory(self, *args)


    def InternetAddress(self, *args):
        """
        InternetAddress(OSD_Host self) -> TCollection_AsciiString

        Returns Internet address of current host.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Host_InternetAddress(self, *args)


    def MachineType(self, *args):
        """
        MachineType(OSD_Host self) -> OSD_OEMType

        Returns type of current machine.

        :rtype: OCC.wrapper.OSD.OSD_OEMType

        """
        return _OSD.OSD_Host_MachineType(self, *args)


    def Failed(self, *args):
        """
        Failed(OSD_Host self) -> Standard_Boolean

        Returns TRUE if an error occurs

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.OSD_Host_Failed(self, *args)


    def Reset(self, *args):
        """
        Reset(OSD_Host self)

        Resets error counter to zero


        """
        return _OSD.OSD_Host_Reset(self, *args)


    def Perror(self, *args):
        """
        Perror(OSD_Host self)

        Raises OSD_Error


        """
        return _OSD.OSD_Host_Perror(self, *args)


    def Error(self, *args):
        """
        Error(OSD_Host self) -> Standard_Integer

        Returns error number if 'Failed' is TRUE.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.OSD_Host_Error(self, *args)

    __swig_destroy__ = _OSD.delete_OSD_Host
OSD_Host_swigregister = _OSD.OSD_Host_swigregister
OSD_Host_swigregister(OSD_Host)

class Handle_OSD_Exception_ILLEGAL_INSTRUCTION(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self, OSD_Exception_ILLEGAL_INSTRUCTION thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self, Handle_OSD_Exception_ILLEGAL_INSTRUCTION theHandle) -> Handle_OSD_Exception_ILLEGAL_INSTRUCTION
        assign(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self, OSD_Exception_ILLEGAL_INSTRUCTION thePtr) -> Handle_OSD_Exception_ILLEGAL_INSTRUCTION
        assign(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self, Handle_OSD_Exception_ILLEGAL_INSTRUCTION theHandle) -> Handle_OSD_Exception_ILLEGAL_INSTRUCTION

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self) -> OSD_Exception_ILLEGAL_INSTRUCTION

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self) -> OSD_Exception_ILLEGAL_INSTRUCTION

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self) -> OSD_Exception_ILLEGAL_INSTRUCTION

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_Exception_ILLEGAL_INSTRUCTION(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_Exception_ILLEGAL_INSTRUCTION

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self, Standard_CString const theMessage) -> Handle_OSD_Exception_ILLEGAL_INSTRUCTION

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION

        """
        return _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self)
        Reraise(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self, Standard_CString const aMessage)
        Reraise(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_Exception_ILLEGAL_INSTRUCTION self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION_DecrementRefCounter(self, *args)

Handle_OSD_Exception_ILLEGAL_INSTRUCTION_swigregister = _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION_swigregister
Handle_OSD_Exception_ILLEGAL_INSTRUCTION_swigregister(Handle_OSD_Exception_ILLEGAL_INSTRUCTION)

def Handle_OSD_Exception_ILLEGAL_INSTRUCTION_DownCast(thing):
    return _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION_DownCast(thing)
Handle_OSD_Exception_ILLEGAL_INSTRUCTION_DownCast = _OSD.Handle_OSD_Exception_ILLEGAL_INSTRUCTION_DownCast

class OSD_MAllocHook(object):
    """
    This class provides the possibility to set callback for memory
    allocation/deallocation.
    On MS Windows, it works only in Debug builds. It relies on the
    debug CRT function _CrtSetAllocHook (see MSDN for help).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def SetCallback(*args):
        """
        SetCallback(OSD_MAllocHook::Callback * theCB)

        :type theCB: OCC.wrapper.OSD.Callback

        """
        return _OSD.OSD_MAllocHook_SetCallback(*args)

    SetCallback = staticmethod(SetCallback)

    def GetCallback(*args):
        """
        GetCallback() -> OSD_MAllocHook::Callback *

        Get current handler of allocation/deallocation events

        :rtype: OCC.wrapper.OSD.Callback

        """
        return _OSD.OSD_MAllocHook_GetCallback(*args)

    GetCallback = staticmethod(GetCallback)

    def GetLogFileHandler(*args):
        """
        GetLogFileHandler() -> OSD_MAllocHook::LogFileHandler *

        Get static instance of LogFileHandler handler

        :rtype: OCC.wrapper.OSD.LogFileHandler

        """
        return _OSD.OSD_MAllocHook_GetLogFileHandler(*args)

    GetLogFileHandler = staticmethod(GetLogFileHandler)

    def GetCollectBySize(*args):
        """
        GetCollectBySize() -> OSD_MAllocHook::CollectBySize *

        Get static instance of CollectBySize handler

        :rtype: OCC.wrapper.OSD.CollectBySize

        """
        return _OSD.OSD_MAllocHook_GetCollectBySize(*args)

    GetCollectBySize = staticmethod(GetCollectBySize)

    def __init__(self):
        """
        This class provides the possibility to set callback for memory
        allocation/deallocation.
        On MS Windows, it works only in Debug builds. It relies on the
        debug CRT function _CrtSetAllocHook (see MSDN for help).
        """
        this = _OSD.new_OSD_MAllocHook()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OSD.delete_OSD_MAllocHook
OSD_MAllocHook_swigregister = _OSD.OSD_MAllocHook_swigregister
OSD_MAllocHook_swigregister(OSD_MAllocHook)

def OSD_MAllocHook_SetCallback(*args):
    """
    OSD_MAllocHook_SetCallback(OSD_MAllocHook::Callback * theCB)

    :type theCB: OCC.wrapper.OSD.Callback

    """
    return _OSD.OSD_MAllocHook_SetCallback(*args)

def OSD_MAllocHook_GetCallback(*args):
    """
    OSD_MAllocHook_GetCallback() -> OSD_MAllocHook::Callback *

    Get current handler of allocation/deallocation events

    :rtype: OCC.wrapper.OSD.Callback

    """
    return _OSD.OSD_MAllocHook_GetCallback(*args)

def OSD_MAllocHook_GetLogFileHandler(*args):
    """
    OSD_MAllocHook_GetLogFileHandler() -> OSD_MAllocHook::LogFileHandler *

    Get static instance of LogFileHandler handler

    :rtype: OCC.wrapper.OSD.LogFileHandler

    """
    return _OSD.OSD_MAllocHook_GetLogFileHandler(*args)

def OSD_MAllocHook_GetCollectBySize(*args):
    """
    OSD_MAllocHook_GetCollectBySize() -> OSD_MAllocHook::CollectBySize *

    Get static instance of CollectBySize handler

    :rtype: OCC.wrapper.OSD.CollectBySize

    """
    return _OSD.OSD_MAllocHook_GetCollectBySize(*args)

class Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self, OSD_Exception_ARRAY_BOUNDS_EXCEEDED thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self, Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED theHandle) -> Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED
        assign(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self, OSD_Exception_ARRAY_BOUNDS_EXCEEDED thePtr) -> Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED
        assign(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self, Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED theHandle) -> Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self) -> OSD_Exception_ARRAY_BOUNDS_EXCEEDED

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self) -> OSD_Exception_ARRAY_BOUNDS_EXCEEDED

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self) -> OSD_Exception_ARRAY_BOUNDS_EXCEEDED

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self, Standard_CString const theMessage) -> Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED

        """
        return _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self)
        Reraise(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self, Standard_CString const aMessage)
        Reraise(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_DecrementRefCounter(self, *args)

Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_swigregister = _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_swigregister
Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_swigregister(Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED)

def Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_DownCast(thing):
    return _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_DownCast(thing)
Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_DownCast = _OSD.Handle_OSD_Exception_ARRAY_BOUNDS_EXCEEDED_DownCast

class OSD_Error(object):
    """Accurate management of OSD specific errors."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OSD_Error self) -> OSD_Error

        Initializes Error to be without any Error.
        This is only used by OSD, not by programmer.


        """
        this = _OSD.new_OSD_Error(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perror(self, *args):
        """
        Perror(OSD_Error self)

        Raises OSD_Error with accurate error message.


        """
        return _OSD.OSD_Error_Perror(self, *args)


    def SetValue(self, *args):
        """
        SetValue(OSD_Error self, Standard_Integer const Errcode, Standard_Integer const From, TCollection_AsciiString Message)

        Instantiates error
        This is only used by OSD methods to instantiates an error code.
        No description is done for the programmer.

        :type Errcode: int
        :type From: int
        :type Message: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_Error_SetValue(self, *args)


    def Error(self, *args):
        """
        Error(OSD_Error self) -> Standard_Integer

        Returns an accurate error code.
        To test these values, you must include "OSD_ErrorList.hxx"

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.OSD_Error_Error(self, *args)


    def Failed(self, *args):
        """
        Failed(OSD_Error self) -> Standard_Boolean

        Returns TRUE if an error occurs
        This is a way to test if a system call succeeded or not.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.OSD_Error_Failed(self, *args)


    def Reset(self, *args):
        """
        Reset(OSD_Error self)

        Resets error counter to zero
        This allows the user to ignore an error (WARNING).


        """
        return _OSD.OSD_Error_Reset(self, *args)

    __swig_destroy__ = _OSD.delete_OSD_Error
OSD_Error_swigregister = _OSD.OSD_Error_swigregister
OSD_Error_swigregister(OSD_Error)

class Handle_OSD_Exception_STATUS_NO_MEMORY(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_Exception_STATUS_NO_MEMORY self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_Exception_STATUS_NO_MEMORY self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_Exception_STATUS_NO_MEMORY self, OSD_Exception_STATUS_NO_MEMORY thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_Exception_STATUS_NO_MEMORY self, Handle_OSD_Exception_STATUS_NO_MEMORY theHandle) -> Handle_OSD_Exception_STATUS_NO_MEMORY
        assign(Handle_OSD_Exception_STATUS_NO_MEMORY self, OSD_Exception_STATUS_NO_MEMORY thePtr) -> Handle_OSD_Exception_STATUS_NO_MEMORY
        assign(Handle_OSD_Exception_STATUS_NO_MEMORY self, Handle_OSD_Exception_STATUS_NO_MEMORY theHandle) -> Handle_OSD_Exception_STATUS_NO_MEMORY

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_Exception_STATUS_NO_MEMORY self) -> OSD_Exception_STATUS_NO_MEMORY

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_Exception_STATUS_NO_MEMORY self) -> OSD_Exception_STATUS_NO_MEMORY

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_Exception_STATUS_NO_MEMORY self) -> OSD_Exception_STATUS_NO_MEMORY

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_Exception_STATUS_NO_MEMORY(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_Exception_STATUS_NO_MEMORY_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_Exception_STATUS_NO_MEMORY

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_Exception_STATUS_NO_MEMORY self, Standard_CString const theMessage) -> Handle_OSD_Exception_STATUS_NO_MEMORY

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_STATUS_NO_MEMORY

        """
        return _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_Exception_STATUS_NO_MEMORY self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_Exception_STATUS_NO_MEMORY self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_Exception_STATUS_NO_MEMORY self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_Exception_STATUS_NO_MEMORY self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_Exception_STATUS_NO_MEMORY self)
        Reraise(Handle_OSD_Exception_STATUS_NO_MEMORY self, Standard_CString const aMessage)
        Reraise(Handle_OSD_Exception_STATUS_NO_MEMORY self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_Exception_STATUS_NO_MEMORY self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_Exception_STATUS_NO_MEMORY self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_Exception_STATUS_NO_MEMORY self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_Exception_STATUS_NO_MEMORY self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_Exception_STATUS_NO_MEMORY self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_Exception_STATUS_NO_MEMORY self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_Exception_STATUS_NO_MEMORY self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_Exception_STATUS_NO_MEMORY self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_Exception_STATUS_NO_MEMORY self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_Exception_STATUS_NO_MEMORY self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_Exception_STATUS_NO_MEMORY self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY_DecrementRefCounter(self, *args)

Handle_OSD_Exception_STATUS_NO_MEMORY_swigregister = _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY_swigregister
Handle_OSD_Exception_STATUS_NO_MEMORY_swigregister(Handle_OSD_Exception_STATUS_NO_MEMORY)

def Handle_OSD_Exception_STATUS_NO_MEMORY_DownCast(thing):
    return _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY_DownCast(thing)
Handle_OSD_Exception_STATUS_NO_MEMORY_DownCast = _OSD.Handle_OSD_Exception_STATUS_NO_MEMORY_DownCast

class OSD_File(OSD_FileNode):
    """
    Basic tools to manage files
    Warning: 'ProgramError' is raised when somebody wants to use the methods
    Read, Write, Seek, Close when File is not open.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OSD_File self) -> OSD_File
        __init__(OSD_File self, OSD_Path Name) -> OSD_File

        Instantiates the object file, storing its name

        :type Name: OCC.wrapper.OSD.OSD_Path

        """
        this = _OSD.new_OSD_File(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Build(self, *args):
        """
        Build(OSD_File self, OSD_OpenMode const Mode, OSD_Protection Protect)

        CREATES a file if it doesn't already exists or empties
        an existing file.
        After 'Build', the file is open.
        If no name was given, ProgramError is raised.

        :type Mode: OCC.wrapper.OSD.OSD_OpenMode
        :type Protect: OCC.wrapper.OSD.OSD_Protection

        """
        return _OSD.OSD_File_Build(self, *args)


    def Open(self, *args):
        """
        Open(OSD_File self, OSD_OpenMode const Mode, OSD_Protection Protect)

        Opens a File with specific attributes
        This works only on already existing file.
        If no name was given, ProgramError is raised.

        :type Mode: OCC.wrapper.OSD.OSD_OpenMode
        :type Protect: OCC.wrapper.OSD.OSD_Protection

        """
        return _OSD.OSD_File_Open(self, *args)


    def Append(self, *args):
        """
        Append(OSD_File self, OSD_OpenMode const Mode, OSD_Protection Protect)

        Appends data to an existing file.
        If file doesn't exist, creates it first.
        After 'Append', the file is open.
        If no name was given, ProgramError is raised.

        :type Mode: OCC.wrapper.OSD.OSD_OpenMode
        :type Protect: OCC.wrapper.OSD.OSD_Protection

        """
        return _OSD.OSD_File_Append(self, *args)


    def ReadLine(self, *args):
        """
        ReadLine(OSD_File self, TCollection_AsciiString Buffer, Standard_Integer const NByte)
        ReadLine(OSD_File self, TCollection_AsciiString Buffer, Standard_Integer const NByte) -> Standard_Integer

        Reads bytes from the data pointed to by the object file
        into the buffer <Buffer>.
        Data is read until <NByte-1> bytes have been read,
        until	a newline character is read and transferred into
        <Buffer>, or until an EOF (End-of-File) condition is
        encountered.
        Upon successful completion, Read returns the number of
        bytes actually read and placed into the Buffer <Buffer>.

        :type Buffer: OCC.wrapper.TCollection.TCollection_AsciiString
        :type NByte: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.OSD_File_ReadLine(self, *args)


    def Read(self, *args):
        """
        Read(OSD_File self, TCollection_AsciiString Buffer, Standard_Integer const Nbyte)
        Read(OSD_File self, Standard_Address const Buffer, Standard_Integer const Nbyte)

        Attempts to read Nbyte bytes from the files associated with
        the object File.
        Upon successful completion, Read returns the number of
        bytes actually read and placed in the Buffer. This number
        may be less than Nbyte if the number of bytes left in the file
        is less than Nbyte bytes. For this reason the output
        parameter Readbyte will contain the number of read bytes.

        :type Buffer: OCC.wrapper.Standard.Standard_Address
        :type Nbyte: int
        :type Readbyte: int

        """
        return _OSD.OSD_File_Read(self, *args)


    def Write(self, *args):
        """
        Write(OSD_File self, TCollection_AsciiString theBuffer, Standard_Integer const theNbBytes)
        Write(OSD_File self, Standard_Address const theBuffer, Standard_Integer const theNbBytes)

        Attempts to write theNbBytes bytes from the buffer pointed
        to by theBuffer to the file associated to the object File.

        :type theBuffer: OCC.wrapper.Standard.Standard_Address
        :type theNbBytes: int

        """
        return _OSD.OSD_File_Write(self, *args)


    def Seek(self, *args):
        """
        Seek(OSD_File self, Standard_Integer const Offset, OSD_FromWhere const Whence)

        Sets the seek pointer associated with the open file

        :type Offset: int
        :type Whence: OCC.wrapper.OSD.OSD_FromWhere

        """
        return _OSD.OSD_File_Seek(self, *args)


    def Close(self, *args):
        """
        Close(OSD_File self)

        Closes the file (and deletes a descriptor)


        """
        return _OSD.OSD_File_Close(self, *args)


    def IsAtEnd(self, *args):
        """
        IsAtEnd(OSD_File self) -> Standard_Boolean

        Returns TRUE if the seek pointer is at end of file.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.OSD_File_IsAtEnd(self, *args)


    def KindOfFile(self, *args):
        """
        KindOfFile(OSD_File self) -> OSD_KindFile

        Returns the kind of file. A file can be a
        file, a directory or a link.

        :rtype: OCC.wrapper.OSD.OSD_KindFile

        """
        return _OSD.OSD_File_KindOfFile(self, *args)


    def BuildTemporary(self, *args):
        """
        BuildTemporary(OSD_File self)

        Makes a temporary File
        This temporary file is already open !


        """
        return _OSD.OSD_File_BuildTemporary(self, *args)


    def SetLock(self, *args):
        """
        SetLock(OSD_File self, OSD_LockType const Lock)

        Locks current file

        :type Lock: OCC.wrapper.OSD.OSD_LockType

        """
        return _OSD.OSD_File_SetLock(self, *args)


    def UnLock(self, *args):
        """
        UnLock(OSD_File self)

        Unlocks current file


        """
        return _OSD.OSD_File_UnLock(self, *args)


    def GetLock(self, *args):
        """
        GetLock(OSD_File self) -> OSD_LockType

        Returns the current lock state

        :rtype: OCC.wrapper.OSD.OSD_LockType

        """
        return _OSD.OSD_File_GetLock(self, *args)


    def IsLocked(self, *args):
        """
        IsLocked(OSD_File self) -> Standard_Boolean

        Returns TRUE if this file is locked.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.OSD_File_IsLocked(self, *args)


    def Size(self, *args):
        """
        Size(OSD_File self) -> Standard_Size

        Returns actual number of bytes of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OSD.OSD_File_Size(self, *args)


    def IsOpen(self, *args):
        """
        IsOpen(OSD_File self) -> Standard_Boolean

        Returns TRUE if <me> is open.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.OSD_File_IsOpen(self, *args)


    def IsReadable(self, *args):
        """
        IsReadable(OSD_File self) -> Standard_Boolean

        returns TRUE if the file exists and if the user
        has the autorization to read it.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.OSD_File_IsReadable(self, *args)


    def IsWriteable(self, *args):
        """
        IsWriteable(OSD_File self) -> Standard_Boolean

        returns TRUE if the file can be read and overwritten.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.OSD_File_IsWriteable(self, *args)


    def IsExecutable(self, *args):
        """
        IsExecutable(OSD_File self) -> Standard_Boolean

        returns TRUE if the file can be executed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.OSD_File_IsExecutable(self, *args)


    def ReadLastLine(self, *args):
        """
        ReadLastLine(OSD_File self, TCollection_AsciiString aLine, Standard_Integer const aDelay, Standard_Integer const aNbTries) -> Standard_Boolean

        Enables to emulate unix "tail -f" command.
        If a line is available in the file <me> returns it.
        Otherwise attemps to read again aNbTries times in the file
        waiting aDelay seconds between each read.
        If meanwhile the file increases returns the next line, otherwise
        returns FALSE.

        :type aLine: OCC.wrapper.TCollection.TCollection_AsciiString
        :type aDelay: int
        :type aNbTries: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.OSD_File_ReadLastLine(self, *args)


    def Edit(self, *args):
        """
        Edit(OSD_File self) -> Standard_Boolean

        find an editor on the system and edit the given file

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.OSD_File_Edit(self, *args)


    def Rewind(self, *args):
        """
        Rewind(OSD_File self)

        Set file pointer position to the beginning of the file


        """
        return _OSD.OSD_File_Rewind(self, *args)


    def Capture(self, *args):
        """
        Capture(OSD_File self, int theDescr) -> int

        Redirect a standard handle (fileno(stdout), fileno(stdin) or 
        fileno(stderr) to this OSD_File and return the copy of the original
        standard handle.
        Example:
        OSD_File aTmp;
        aTmp.BuildTemporary();
        int stdfd = _fileno(stdout);

        int oldout = aTmp.Capture(stdfd);
        cout << "Some output to the file" << endl;
        cout << flush;
        fflush(stdout);

        _dup2(oldout, stdfd); // Restore standard output
        aTmp.Close();

        :type theDescr: int
        :rtype: int

        """
        return _OSD.OSD_File_Capture(self, *args)

    __swig_destroy__ = _OSD.delete_OSD_File
OSD_File_swigregister = _OSD.OSD_File_swigregister
OSD_File_swigregister(OSD_File)

class OSD_Exception_NONCONTINUABLE_EXCEPTION(OSD_Exception):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_Exception_NONCONTINUABLE_EXCEPTION self) -> OSD_Exception_NONCONTINUABLE_EXCEPTION
        __init__(OSD_Exception_NONCONTINUABLE_EXCEPTION self, Standard_CString const theMessage) -> OSD_Exception_NONCONTINUABLE_EXCEPTION

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_Exception_NONCONTINUABLE_EXCEPTION(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION

        """
        return _OSD.OSD_Exception_NONCONTINUABLE_EXCEPTION_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_Exception_NONCONTINUABLE_EXCEPTION_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_Exception_NONCONTINUABLE_EXCEPTION_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_Exception_NONCONTINUABLE_EXCEPTION_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_Exception_NONCONTINUABLE_EXCEPTION
OSD_Exception_NONCONTINUABLE_EXCEPTION_swigregister = _OSD.OSD_Exception_NONCONTINUABLE_EXCEPTION_swigregister
OSD_Exception_NONCONTINUABLE_EXCEPTION_swigregister(OSD_Exception_NONCONTINUABLE_EXCEPTION)

def OSD_Exception_NONCONTINUABLE_EXCEPTION_NewInstance(*args):
    """
    OSD_Exception_NONCONTINUABLE_EXCEPTION_NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION

    """
    return _OSD.OSD_Exception_NONCONTINUABLE_EXCEPTION_NewInstance(*args)

def OSD_Exception_NONCONTINUABLE_EXCEPTION_get_type_name(*args):
    """
    OSD_Exception_NONCONTINUABLE_EXCEPTION_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_Exception_NONCONTINUABLE_EXCEPTION_get_type_name(*args)

def OSD_Exception_NONCONTINUABLE_EXCEPTION_get_type_descriptor(*args):
    """
    OSD_Exception_NONCONTINUABLE_EXCEPTION_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_Exception_NONCONTINUABLE_EXCEPTION_get_type_descriptor(*args)

class Handle_OSD_Exception_FLT_INEXACT_RESULT(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_Exception_FLT_INEXACT_RESULT self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_Exception_FLT_INEXACT_RESULT self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_Exception_FLT_INEXACT_RESULT self, OSD_Exception_FLT_INEXACT_RESULT thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_Exception_FLT_INEXACT_RESULT self, Handle_OSD_Exception_FLT_INEXACT_RESULT theHandle) -> Handle_OSD_Exception_FLT_INEXACT_RESULT
        assign(Handle_OSD_Exception_FLT_INEXACT_RESULT self, OSD_Exception_FLT_INEXACT_RESULT thePtr) -> Handle_OSD_Exception_FLT_INEXACT_RESULT
        assign(Handle_OSD_Exception_FLT_INEXACT_RESULT self, Handle_OSD_Exception_FLT_INEXACT_RESULT theHandle) -> Handle_OSD_Exception_FLT_INEXACT_RESULT

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_Exception_FLT_INEXACT_RESULT self) -> OSD_Exception_FLT_INEXACT_RESULT

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_Exception_FLT_INEXACT_RESULT self) -> OSD_Exception_FLT_INEXACT_RESULT

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_Exception_FLT_INEXACT_RESULT self) -> OSD_Exception_FLT_INEXACT_RESULT

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_Exception_FLT_INEXACT_RESULT(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_Exception_FLT_INEXACT_RESULT

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_Exception_FLT_INEXACT_RESULT self, Standard_CString const theMessage) -> Handle_OSD_Exception_FLT_INEXACT_RESULT

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT

        """
        return _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_Exception_FLT_INEXACT_RESULT self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_Exception_FLT_INEXACT_RESULT self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_Exception_FLT_INEXACT_RESULT self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_Exception_FLT_INEXACT_RESULT self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_Exception_FLT_INEXACT_RESULT self)
        Reraise(Handle_OSD_Exception_FLT_INEXACT_RESULT self, Standard_CString const aMessage)
        Reraise(Handle_OSD_Exception_FLT_INEXACT_RESULT self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_Exception_FLT_INEXACT_RESULT self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_Exception_FLT_INEXACT_RESULT self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_Exception_FLT_INEXACT_RESULT self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_Exception_FLT_INEXACT_RESULT self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_Exception_FLT_INEXACT_RESULT self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_Exception_FLT_INEXACT_RESULT self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_Exception_FLT_INEXACT_RESULT self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_Exception_FLT_INEXACT_RESULT self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_Exception_FLT_INEXACT_RESULT self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_Exception_FLT_INEXACT_RESULT self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_Exception_FLT_INEXACT_RESULT self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT_DecrementRefCounter(self, *args)

Handle_OSD_Exception_FLT_INEXACT_RESULT_swigregister = _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT_swigregister
Handle_OSD_Exception_FLT_INEXACT_RESULT_swigregister(Handle_OSD_Exception_FLT_INEXACT_RESULT)

def Handle_OSD_Exception_FLT_INEXACT_RESULT_DownCast(thing):
    return _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT_DownCast(thing)
Handle_OSD_Exception_FLT_INEXACT_RESULT_DownCast = _OSD.Handle_OSD_Exception_FLT_INEXACT_RESULT_DownCast

class Handle_OSD_Exception_FLT_OVERFLOW(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_Exception_FLT_OVERFLOW self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_Exception_FLT_OVERFLOW_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_Exception_FLT_OVERFLOW self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_Exception_FLT_OVERFLOW_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_Exception_FLT_OVERFLOW self, OSD_Exception_FLT_OVERFLOW thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_Exception_FLT_OVERFLOW_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_Exception_FLT_OVERFLOW self, Handle_OSD_Exception_FLT_OVERFLOW theHandle) -> Handle_OSD_Exception_FLT_OVERFLOW
        assign(Handle_OSD_Exception_FLT_OVERFLOW self, OSD_Exception_FLT_OVERFLOW thePtr) -> Handle_OSD_Exception_FLT_OVERFLOW
        assign(Handle_OSD_Exception_FLT_OVERFLOW self, Handle_OSD_Exception_FLT_OVERFLOW theHandle) -> Handle_OSD_Exception_FLT_OVERFLOW

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_Exception_FLT_OVERFLOW_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_Exception_FLT_OVERFLOW self) -> OSD_Exception_FLT_OVERFLOW

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_FLT_OVERFLOW_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_Exception_FLT_OVERFLOW self) -> OSD_Exception_FLT_OVERFLOW

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_FLT_OVERFLOW___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_Exception_FLT_OVERFLOW self) -> OSD_Exception_FLT_OVERFLOW

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_Exception_FLT_OVERFLOW___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_Exception_FLT_OVERFLOW___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_Exception_FLT_OVERFLOW___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_Exception_FLT_OVERFLOW(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_Exception_FLT_OVERFLOW_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_Exception_FLT_OVERFLOW

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_Exception_FLT_OVERFLOW self, Standard_CString const theMessage) -> Handle_OSD_Exception_FLT_OVERFLOW

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_FLT_OVERFLOW

        """
        return _OSD.Handle_OSD_Exception_FLT_OVERFLOW_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_Exception_FLT_OVERFLOW self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_Exception_FLT_OVERFLOW_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_FLT_OVERFLOW_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_FLT_OVERFLOW_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_Exception_FLT_OVERFLOW self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_Exception_FLT_OVERFLOW_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_Exception_FLT_OVERFLOW self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_FLT_OVERFLOW_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_Exception_FLT_OVERFLOW self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_FLT_OVERFLOW_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_Exception_FLT_OVERFLOW self)
        Reraise(Handle_OSD_Exception_FLT_OVERFLOW self, Standard_CString const aMessage)
        Reraise(Handle_OSD_Exception_FLT_OVERFLOW self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_Exception_FLT_OVERFLOW_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_Exception_FLT_OVERFLOW self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_Exception_FLT_OVERFLOW_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_Exception_FLT_OVERFLOW self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_Exception_FLT_OVERFLOW_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_Exception_FLT_OVERFLOW self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_Exception_FLT_OVERFLOW_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_Exception_FLT_OVERFLOW self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_Exception_FLT_OVERFLOW self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_FLT_OVERFLOW_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_Exception_FLT_OVERFLOW self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_Exception_FLT_OVERFLOW self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_FLT_OVERFLOW_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_Exception_FLT_OVERFLOW self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_Exception_FLT_OVERFLOW_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_Exception_FLT_OVERFLOW self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_FLT_OVERFLOW_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_Exception_FLT_OVERFLOW self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_Exception_FLT_OVERFLOW_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_Exception_FLT_OVERFLOW self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_FLT_OVERFLOW_DecrementRefCounter(self, *args)

Handle_OSD_Exception_FLT_OVERFLOW_swigregister = _OSD.Handle_OSD_Exception_FLT_OVERFLOW_swigregister
Handle_OSD_Exception_FLT_OVERFLOW_swigregister(Handle_OSD_Exception_FLT_OVERFLOW)

def Handle_OSD_Exception_FLT_OVERFLOW_DownCast(thing):
    return _OSD.Handle_OSD_Exception_FLT_OVERFLOW_DownCast(thing)
Handle_OSD_Exception_FLT_OVERFLOW_DownCast = _OSD.Handle_OSD_Exception_FLT_OVERFLOW_DownCast

class OSD_Thread(object):
    """
    A simple platform-intependent interface to execute
    and control threads.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OSD_Thread self) -> OSD_Thread
        __init__(OSD_Thread self, OSD_ThreadFunction const & func) -> OSD_Thread
        __init__(OSD_Thread self, OSD_Thread other) -> OSD_Thread

        Copy constructor

        :type other: OCC.wrapper.OSD.OSD_Thread

        """
        this = _OSD.new_OSD_Thread(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Assign(self, *args):
        """
        Assign(OSD_Thread self, OSD_Thread other)

        Copy thread handle from other OSD_Thread object.

        :type other: OCC.wrapper.OSD.OSD_Thread

        """
        return _OSD.OSD_Thread_Assign(self, *args)


    def assign(self, *args):
        """
        assign(OSD_Thread self, OSD_Thread other)

        :type other: OCC.wrapper.OSD.OSD_Thread

        """
        return _OSD.OSD_Thread_assign(self, *args)


    def SetPriority(self, *args):
        """
        SetPriority(OSD_Thread self, Standard_Integer const thePriority)

        :type thePriority: int

        """
        return _OSD.OSD_Thread_SetPriority(self, *args)


    def SetFunction(self, *args):
        """
        SetFunction(OSD_Thread self, OSD_ThreadFunction const & func)

        Initialize the tool by the thread function.
        If the current thread handle is not null, nullifies it.

        Note: On Windows, you might have to take an address of the thread
        function explicitly to pass it to this method without compiler error

        :type func: OCC.wrapper.OSD.OSD_ThreadFunction

        """
        return _OSD.OSD_Thread_SetFunction(self, *args)


    def Run(self, *args):
        """
        Run(OSD_Thread self, Standard_Address const data=None, Standard_Integer const WNTStackSize=0) -> Standard_Boolean

        Starts a thread with thread function given in constructor,
        passing the specified input data (as void *) to it.
        The parameter  WNTStackSize (on Windows only)
        specifies size of the stack to be allocated for the thread
        (by default - the same as for the current executable).
        Returns True if thread started successfully

        :type data: OCC.wrapper.Standard.Standard_Address
        :type WNTStackSize: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.OSD_Thread_Run(self, *args)


    def Detach(self, *args):
        """
        Detach(OSD_Thread self)

        Detaches the execution thread from this Thread object,
        so that it cannot be waited.
        Note that mechanics of this operation is different on
        UNIX/Linux (the thread is put to detached state) and Windows
        (the handle is closed).
        However, the purpose is the same: to instruct the system to
        release all thread data upon its completion.


        """
        return _OSD.OSD_Thread_Detach(self, *args)


    def Wait(self, *args):
        """
        Wait(OSD_Thread self) -> Standard_Boolean
        Wait(OSD_Thread self, Standard_Address & theResult) -> Standard_Boolean
        Wait(OSD_Thread self, Standard_Integer const time, Standard_Address & theResult) -> Standard_Boolean

        Waits for some time and if the thread is finished,
        it returns the result.
        The function returns false if the thread is not finished yet.

        :type time: int
        :type theResult: OCC.wrapper.Standard.Standard_Address
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.OSD_Thread_Wait(self, *args)


    def GetId(self, *args):
        """
        GetId(OSD_Thread self) -> Standard_ThreadId

        Returns ID of the currently controlled thread ID,
        or 0 if no thread is run

        :rtype: OCC.wrapper.Standard.Standard_ThreadId

        """
        return _OSD.OSD_Thread_GetId(self, *args)


    def Current(*args):
        """
        Current() -> Standard_ThreadId

        Auxiliary: returns ID of the current thread

        :rtype: OCC.wrapper.Standard.Standard_ThreadId

        """
        return _OSD.OSD_Thread_Current(*args)

    Current = staticmethod(Current)
    __swig_destroy__ = _OSD.delete_OSD_Thread
OSD_Thread_swigregister = _OSD.OSD_Thread_swigregister
OSD_Thread_swigregister(OSD_Thread)

def OSD_Thread_Current(*args):
    """
    OSD_Thread_Current() -> Standard_ThreadId

    Auxiliary: returns ID of the current thread

    :rtype: OCC.wrapper.Standard.Standard_ThreadId

    """
    return _OSD.OSD_Thread_Current(*args)

class OSD_SharedLibrary(object):
    """
    Interface to dynamic library loader.
    Provides tools to load a shared library
    and retrieve the address of an entry point.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OSD_SharedLibrary self) -> OSD_SharedLibrary
        __init__(OSD_SharedLibrary self, Standard_CString const aFilename) -> OSD_SharedLibrary

        Creates a SharedLibrary object with name aFilename.

        :type aFilename: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_SharedLibrary(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetName(self, *args):
        """
        SetName(OSD_SharedLibrary self, Standard_CString const aName)

        Sets a name associated to the shared object.

        :type aName: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.OSD_SharedLibrary_SetName(self, *args)


    def Name(self, *args):
        """
        Name(OSD_SharedLibrary self) -> Standard_CString

        Returns the name associated to the shared object.

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.OSD_SharedLibrary_Name(self, *args)


    def DlOpen(self, *args):
        """
        DlOpen(OSD_SharedLibrary self, OSD_LoadMode const Mode) -> Standard_Boolean

        The DlOpen method provides an interface to the
        dynamic library loader to allow shared libraries
        to be loaded and called at runtime.  The DlOpen
        function attempts to load Filename, in the address
        space of the process, resolving symbols as appropriate.
        Any libraries that Filename depends upon are also loaded.
        If MODE is RTLD_LAZY, then the runtime loader
        does symbol resolution only as needed.
        Typically, this means that the first call to a function
        in the newly	loaded library will cause the resolution of
        the	address	of that	function to occur.
        If Mode is RTLD_NOW, then the runtime loader must do all
        symbol binding during the DlOpen call.
        The DlOpen method returns a	handle that is used by DlSym
        or DlClose.
        If there is an error, Standard_False is returned,
        Standard_True otherwise.
        If a NULL Filename is specified, DlOpen returns a handle
        for the main	executable, which allows access to dynamic
        symbols in the running program.

        :type Mode: OCC.wrapper.OSD.OSD_LoadMode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.OSD_SharedLibrary_DlOpen(self, *args)


    def DlSymb(self, *args):
        """
        DlSymb(OSD_SharedLibrary self, Standard_CString const Name) -> OSD_Function

        The dlsym function returns the address of the
        symbol name found in the shared library.
        If the symbol is not found, a NULL pointer is
        returned.

        :type Name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.OSD_Function

        """
        return _OSD.OSD_SharedLibrary_DlSymb(self, *args)


    def DlClose(self, *args):
        """
        DlClose(OSD_SharedLibrary self)

        Deallocates the address space for the library
        corresponding to the shared object.
        If any user function continues to call a symbol
        resolved in the address space of a library
        that has been since been deallocated by DlClose,
        the results are undefined.


        """
        return _OSD.OSD_SharedLibrary_DlClose(self, *args)


    def DlError(self, *args):
        """
        DlError(OSD_SharedLibrary self) -> Standard_CString

        The dlerror function returns a string describing
        the last error that occurred from
        a call to DlOpen, DlClose or DlSym.

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.OSD_SharedLibrary_DlError(self, *args)


    def Destroy(self, *args):
        """
        Destroy(OSD_SharedLibrary self)

        Frees memory allocated.


        """
        return _OSD.OSD_SharedLibrary_Destroy(self, *args)

    __swig_destroy__ = _OSD.delete_OSD_SharedLibrary
OSD_SharedLibrary_swigregister = _OSD.OSD_SharedLibrary_swigregister
OSD_SharedLibrary_swigregister(OSD_SharedLibrary)

class OSD_Exception_FLT_DIVIDE_BY_ZERO(OSD_Exception):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_Exception_FLT_DIVIDE_BY_ZERO self) -> OSD_Exception_FLT_DIVIDE_BY_ZERO
        __init__(OSD_Exception_FLT_DIVIDE_BY_ZERO self, Standard_CString const theMessage) -> OSD_Exception_FLT_DIVIDE_BY_ZERO

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_Exception_FLT_DIVIDE_BY_ZERO(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO

        """
        return _OSD.OSD_Exception_FLT_DIVIDE_BY_ZERO_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_Exception_FLT_DIVIDE_BY_ZERO_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_Exception_FLT_DIVIDE_BY_ZERO_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_Exception_FLT_DIVIDE_BY_ZERO_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_Exception_FLT_DIVIDE_BY_ZERO
OSD_Exception_FLT_DIVIDE_BY_ZERO_swigregister = _OSD.OSD_Exception_FLT_DIVIDE_BY_ZERO_swigregister
OSD_Exception_FLT_DIVIDE_BY_ZERO_swigregister(OSD_Exception_FLT_DIVIDE_BY_ZERO)

def OSD_Exception_FLT_DIVIDE_BY_ZERO_NewInstance(*args):
    """
    OSD_Exception_FLT_DIVIDE_BY_ZERO_NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO

    """
    return _OSD.OSD_Exception_FLT_DIVIDE_BY_ZERO_NewInstance(*args)

def OSD_Exception_FLT_DIVIDE_BY_ZERO_get_type_name(*args):
    """
    OSD_Exception_FLT_DIVIDE_BY_ZERO_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_Exception_FLT_DIVIDE_BY_ZERO_get_type_name(*args)

def OSD_Exception_FLT_DIVIDE_BY_ZERO_get_type_descriptor(*args):
    """
    OSD_Exception_FLT_DIVIDE_BY_ZERO_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_Exception_FLT_DIVIDE_BY_ZERO_get_type_descriptor(*args)

class OSD_Exception_IN_PAGE_ERROR(OSD_Exception):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_Exception_IN_PAGE_ERROR
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_Exception_IN_PAGE_ERROR(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_Exception_IN_PAGE_ERROR self) -> OSD_Exception_IN_PAGE_ERROR
        __init__(OSD_Exception_IN_PAGE_ERROR self, Standard_CString const theMessage) -> OSD_Exception_IN_PAGE_ERROR

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_Exception_IN_PAGE_ERROR(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_IN_PAGE_ERROR

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_IN_PAGE_ERROR

        """
        return _OSD.OSD_Exception_IN_PAGE_ERROR_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_Exception_IN_PAGE_ERROR_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_Exception_IN_PAGE_ERROR_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_Exception_IN_PAGE_ERROR_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_Exception_IN_PAGE_ERROR
OSD_Exception_IN_PAGE_ERROR_swigregister = _OSD.OSD_Exception_IN_PAGE_ERROR_swigregister
OSD_Exception_IN_PAGE_ERROR_swigregister(OSD_Exception_IN_PAGE_ERROR)

def OSD_Exception_IN_PAGE_ERROR_NewInstance(*args):
    """
    OSD_Exception_IN_PAGE_ERROR_NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_IN_PAGE_ERROR

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_IN_PAGE_ERROR

    """
    return _OSD.OSD_Exception_IN_PAGE_ERROR_NewInstance(*args)

def OSD_Exception_IN_PAGE_ERROR_get_type_name(*args):
    """
    OSD_Exception_IN_PAGE_ERROR_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_Exception_IN_PAGE_ERROR_get_type_name(*args)

def OSD_Exception_IN_PAGE_ERROR_get_type_descriptor(*args):
    """
    OSD_Exception_IN_PAGE_ERROR_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_Exception_IN_PAGE_ERROR_get_type_descriptor(*args)

class OSD_SIGSYS(OSD_Signal):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_SIGSYS
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_SIGSYS(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_SIGSYS self) -> OSD_SIGSYS
        __init__(OSD_SIGSYS self, Standard_CString const theMessage) -> OSD_SIGSYS

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_SIGSYS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_SIGSYS

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_SIGSYS

        """
        return _OSD.OSD_SIGSYS_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_SIGSYS_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_SIGSYS_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_SIGSYS_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_SIGSYS
OSD_SIGSYS_swigregister = _OSD.OSD_SIGSYS_swigregister
OSD_SIGSYS_swigregister(OSD_SIGSYS)

def OSD_SIGSYS_NewInstance(*args):
    """
    OSD_SIGSYS_NewInstance(Standard_CString const theMessage) -> Handle_OSD_SIGSYS

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_SIGSYS

    """
    return _OSD.OSD_SIGSYS_NewInstance(*args)

def OSD_SIGSYS_get_type_name(*args):
    """
    OSD_SIGSYS_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_SIGSYS_get_type_name(*args)

def OSD_SIGSYS_get_type_descriptor(*args):
    """
    OSD_SIGSYS_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_SIGSYS_get_type_descriptor(*args)

class OSD_Parallel(object):
    """
    @brief Simple tool for code parallelization.

    OSD_Parallel class provides simple interface for parallel processing of 
    tasks that can be formulated in terms of "for" or "foreach" loops.

    To use this tool it is necessary to:
    - organize the data to be processed in a collection accessible by
    iteration (usually array or vector);
    - implement a functor class providing operator () accepting iterator
    (or index in array) that does the job;
    - call either For() or ForEach() providing begin and end iterators and
    a functor object.

    Iterators should satisfy requirements of STL forward iterator.
    Functor 

    @code
    class Functor
    {
    public:
    void operator() ([proccesing instance]) const
    {
    //...
    }
    };
    @endcode

    The operator () should be implemented in a thread-safe way so that
    the same functor object can process different data items in parallel threads.

    Iteration by index (For) is expected to be more efficient than using iterators
    (ForEach).

    Implementation uses TBB if OCCT is built with support of TBB; otherwise it
    uses ad-hoc parallelization tool. In general, if TBB is available, it is
    more efficient to use it directly instead of using OSD_Parallel.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def NbLogicalProcessors(*args):
        """
        NbLogicalProcessors() -> Standard_Integer

        Returns number of logical proccesrs.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.OSD_Parallel_NbLogicalProcessors(*args)

    NbLogicalProcessors = staticmethod(NbLogicalProcessors)

    def __init__(self):
        """
        @brief Simple tool for code parallelization.

        OSD_Parallel class provides simple interface for parallel processing of 
        tasks that can be formulated in terms of "for" or "foreach" loops.

        To use this tool it is necessary to:
        - organize the data to be processed in a collection accessible by
        iteration (usually array or vector);
        - implement a functor class providing operator () accepting iterator
        (or index in array) that does the job;
        - call either For() or ForEach() providing begin and end iterators and
        a functor object.

        Iterators should satisfy requirements of STL forward iterator.
        Functor 

        @code
        class Functor
        {
        public:
        void operator() ([proccesing instance]) const
        {
        //...
        }
        };
        @endcode

        The operator () should be implemented in a thread-safe way so that
        the same functor object can process different data items in parallel threads.

        Iteration by index (For) is expected to be more efficient than using iterators
        (ForEach).

        Implementation uses TBB if OCCT is built with support of TBB; otherwise it
        uses ad-hoc parallelization tool. In general, if TBB is available, it is
        more efficient to use it directly instead of using OSD_Parallel.
        """
        this = _OSD.new_OSD_Parallel()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _OSD.delete_OSD_Parallel
OSD_Parallel_swigregister = _OSD.OSD_Parallel_swigregister
OSD_Parallel_swigregister(OSD_Parallel)

def OSD_Parallel_NbLogicalProcessors(*args):
    """
    OSD_Parallel_NbLogicalProcessors() -> Standard_Integer

    Returns number of logical proccesrs.

    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _OSD.OSD_Parallel_NbLogicalProcessors(*args)

class Handle_OSD_Exception_FLT_INVALID_OPERATION(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_Exception_FLT_INVALID_OPERATION self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_Exception_FLT_INVALID_OPERATION self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_Exception_FLT_INVALID_OPERATION self, OSD_Exception_FLT_INVALID_OPERATION thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_Exception_FLT_INVALID_OPERATION self, Handle_OSD_Exception_FLT_INVALID_OPERATION theHandle) -> Handle_OSD_Exception_FLT_INVALID_OPERATION
        assign(Handle_OSD_Exception_FLT_INVALID_OPERATION self, OSD_Exception_FLT_INVALID_OPERATION thePtr) -> Handle_OSD_Exception_FLT_INVALID_OPERATION
        assign(Handle_OSD_Exception_FLT_INVALID_OPERATION self, Handle_OSD_Exception_FLT_INVALID_OPERATION theHandle) -> Handle_OSD_Exception_FLT_INVALID_OPERATION

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_Exception_FLT_INVALID_OPERATION self) -> OSD_Exception_FLT_INVALID_OPERATION

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_Exception_FLT_INVALID_OPERATION self) -> OSD_Exception_FLT_INVALID_OPERATION

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_Exception_FLT_INVALID_OPERATION self) -> OSD_Exception_FLT_INVALID_OPERATION

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_Exception_FLT_INVALID_OPERATION(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_Exception_FLT_INVALID_OPERATION

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_Exception_FLT_INVALID_OPERATION self, Standard_CString const theMessage) -> Handle_OSD_Exception_FLT_INVALID_OPERATION

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION

        """
        return _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_Exception_FLT_INVALID_OPERATION self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_Exception_FLT_INVALID_OPERATION self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_Exception_FLT_INVALID_OPERATION self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_Exception_FLT_INVALID_OPERATION self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_Exception_FLT_INVALID_OPERATION self)
        Reraise(Handle_OSD_Exception_FLT_INVALID_OPERATION self, Standard_CString const aMessage)
        Reraise(Handle_OSD_Exception_FLT_INVALID_OPERATION self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_Exception_FLT_INVALID_OPERATION self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_Exception_FLT_INVALID_OPERATION self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_Exception_FLT_INVALID_OPERATION self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_Exception_FLT_INVALID_OPERATION self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_Exception_FLT_INVALID_OPERATION self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_Exception_FLT_INVALID_OPERATION self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_Exception_FLT_INVALID_OPERATION self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_Exception_FLT_INVALID_OPERATION self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_Exception_FLT_INVALID_OPERATION self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_Exception_FLT_INVALID_OPERATION self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_Exception_FLT_INVALID_OPERATION self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION_DecrementRefCounter(self, *args)

Handle_OSD_Exception_FLT_INVALID_OPERATION_swigregister = _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION_swigregister
Handle_OSD_Exception_FLT_INVALID_OPERATION_swigregister(Handle_OSD_Exception_FLT_INVALID_OPERATION)

def Handle_OSD_Exception_FLT_INVALID_OPERATION_DownCast(thing):
    return _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION_DownCast(thing)
Handle_OSD_Exception_FLT_INVALID_OPERATION_DownCast = _OSD.Handle_OSD_Exception_FLT_INVALID_OPERATION_DownCast

class OSD_PerfMeter(object):
    """
    This class enables measuring the CPU time between two points of code execution, regardless of the scope of these points of code.
    A meter is identified by its name (string). So multiple objects in various places of user code may point to the same meter.
    The results will be printed on stdout upon finish of the program.
    For details see OSD_PerfMeter.h
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OSD_PerfMeter self) -> OSD_PerfMeter
        __init__(OSD_PerfMeter self, char const * theMeter, bool const theToAutoStart=True) -> OSD_PerfMeter

        Constructs and starts (if autoStart is true) the named meter

        :type theMeter: const char *
        :type theToAutoStart: const bool

        """
        this = _OSD.new_OSD_PerfMeter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(OSD_PerfMeter self, char const * theMeter)

        Prepares the named meter

        :type theMeter: const char *

        """
        return _OSD.OSD_PerfMeter_Init(self, *args)


    def Start(self, *args):
        """
        Start(OSD_PerfMeter self)

        Starts the meter


        """
        return _OSD.OSD_PerfMeter_Start(self, *args)


    def Stop(self, *args):
        """
        Stop(OSD_PerfMeter self)

        Stops the meter


        """
        return _OSD.OSD_PerfMeter_Stop(self, *args)


    def Tick(self, *args):
        """
        Tick(OSD_PerfMeter self)

        Increments the counter w/o time measurement


        """
        return _OSD.OSD_PerfMeter_Tick(self, *args)


    def Flush(self, *args):
        """
        Flush(OSD_PerfMeter self)

        Outputs the meter data and resets it to initial state


        """
        return _OSD.OSD_PerfMeter_Flush(self, *args)

    __swig_destroy__ = _OSD.delete_OSD_PerfMeter
OSD_PerfMeter_swigregister = _OSD.OSD_PerfMeter_swigregister
OSD_PerfMeter_swigregister(OSD_PerfMeter)

class OSD_Exception_INT_DIVIDE_BY_ZERO(OSD_Exception):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_OSD_Exception_INT_DIVIDE_BY_ZERO
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_OSD_Exception_INT_DIVIDE_BY_ZERO(self) 
            return h


    def __init__(self, *args):
        """
        __init__(OSD_Exception_INT_DIVIDE_BY_ZERO self) -> OSD_Exception_INT_DIVIDE_BY_ZERO
        __init__(OSD_Exception_INT_DIVIDE_BY_ZERO self, Standard_CString const theMessage) -> OSD_Exception_INT_DIVIDE_BY_ZERO

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_Exception_INT_DIVIDE_BY_ZERO(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_INT_DIVIDE_BY_ZERO

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO

        """
        return _OSD.OSD_Exception_INT_DIVIDE_BY_ZERO_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _OSD.OSD_Exception_INT_DIVIDE_BY_ZERO_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _OSD.OSD_Exception_INT_DIVIDE_BY_ZERO_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.OSD_Exception_INT_DIVIDE_BY_ZERO_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _OSD.delete_OSD_Exception_INT_DIVIDE_BY_ZERO
OSD_Exception_INT_DIVIDE_BY_ZERO_swigregister = _OSD.OSD_Exception_INT_DIVIDE_BY_ZERO_swigregister
OSD_Exception_INT_DIVIDE_BY_ZERO_swigregister(OSD_Exception_INT_DIVIDE_BY_ZERO)

def OSD_Exception_INT_DIVIDE_BY_ZERO_NewInstance(*args):
    """
    OSD_Exception_INT_DIVIDE_BY_ZERO_NewInstance(Standard_CString const theMessage) -> Handle_OSD_Exception_INT_DIVIDE_BY_ZERO

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO

    """
    return _OSD.OSD_Exception_INT_DIVIDE_BY_ZERO_NewInstance(*args)

def OSD_Exception_INT_DIVIDE_BY_ZERO_get_type_name(*args):
    """
    OSD_Exception_INT_DIVIDE_BY_ZERO_get_type_name() -> char const *

    :rtype: const char *

    """
    return _OSD.OSD_Exception_INT_DIVIDE_BY_ZERO_get_type_name(*args)

def OSD_Exception_INT_DIVIDE_BY_ZERO_get_type_descriptor(*args):
    """
    OSD_Exception_INT_DIVIDE_BY_ZERO_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _OSD.OSD_Exception_INT_DIVIDE_BY_ZERO_get_type_descriptor(*args)

class Handle_OSD_Exception(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_Exception self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_Exception_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_Exception self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_Exception_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_Exception self, OSD_Exception thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_Exception_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_Exception self, Handle_OSD_Exception theHandle) -> Handle_OSD_Exception
        assign(Handle_OSD_Exception self, OSD_Exception thePtr) -> Handle_OSD_Exception
        assign(Handle_OSD_Exception self, Handle_OSD_Exception theHandle) -> Handle_OSD_Exception

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_Exception_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_Exception self) -> OSD_Exception

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_Exception self) -> OSD_Exception

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_Exception self) -> OSD_Exception

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_Exception___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_Exception___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_Exception___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_Exception(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_Exception_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_Exception

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_Exception self, Standard_CString const theMessage) -> Handle_OSD_Exception

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception

        """
        return _OSD.Handle_OSD_Exception_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_Exception self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_Exception_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_Exception self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_Exception_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_Exception self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_Exception self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_Exception self)
        Reraise(Handle_OSD_Exception self, Standard_CString const aMessage)
        Reraise(Handle_OSD_Exception self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_Exception_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_Exception self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_Exception_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_Exception self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_Exception_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_Exception self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_Exception_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_Exception self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_Exception self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_Exception self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_Exception self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_Exception self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_Exception_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_Exception self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_Exception self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_Exception_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_Exception self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_DecrementRefCounter(self, *args)

Handle_OSD_Exception_swigregister = _OSD.Handle_OSD_Exception_swigregister
Handle_OSD_Exception_swigregister(Handle_OSD_Exception)

def Handle_OSD_Exception_DownCast(thing):
    return _OSD.Handle_OSD_Exception_DownCast(thing)
Handle_OSD_Exception_DownCast = _OSD.Handle_OSD_Exception_DownCast

class Handle_OSD_Exception_ACCESS_VIOLATION(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_Exception_ACCESS_VIOLATION self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_Exception_ACCESS_VIOLATION_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_Exception_ACCESS_VIOLATION self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_Exception_ACCESS_VIOLATION_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_Exception_ACCESS_VIOLATION self, OSD_Exception_ACCESS_VIOLATION thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_Exception_ACCESS_VIOLATION_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_Exception_ACCESS_VIOLATION self, Handle_OSD_Exception_ACCESS_VIOLATION theHandle) -> Handle_OSD_Exception_ACCESS_VIOLATION
        assign(Handle_OSD_Exception_ACCESS_VIOLATION self, OSD_Exception_ACCESS_VIOLATION thePtr) -> Handle_OSD_Exception_ACCESS_VIOLATION
        assign(Handle_OSD_Exception_ACCESS_VIOLATION self, Handle_OSD_Exception_ACCESS_VIOLATION theHandle) -> Handle_OSD_Exception_ACCESS_VIOLATION

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_Exception_ACCESS_VIOLATION_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_Exception_ACCESS_VIOLATION self) -> OSD_Exception_ACCESS_VIOLATION

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_ACCESS_VIOLATION_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_Exception_ACCESS_VIOLATION self) -> OSD_Exception_ACCESS_VIOLATION

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_ACCESS_VIOLATION___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_Exception_ACCESS_VIOLATION self) -> OSD_Exception_ACCESS_VIOLATION

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_Exception_ACCESS_VIOLATION___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_Exception_ACCESS_VIOLATION___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_Exception_ACCESS_VIOLATION___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_Exception_ACCESS_VIOLATION(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_Exception_ACCESS_VIOLATION_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_Exception_ACCESS_VIOLATION

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_Exception_ACCESS_VIOLATION self, Standard_CString const theMessage) -> Handle_OSD_Exception_ACCESS_VIOLATION

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_ACCESS_VIOLATION

        """
        return _OSD.Handle_OSD_Exception_ACCESS_VIOLATION_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_Exception_ACCESS_VIOLATION self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_Exception_ACCESS_VIOLATION_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_ACCESS_VIOLATION_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_ACCESS_VIOLATION_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_Exception_ACCESS_VIOLATION self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_Exception_ACCESS_VIOLATION_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_Exception_ACCESS_VIOLATION self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_ACCESS_VIOLATION_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_Exception_ACCESS_VIOLATION self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_ACCESS_VIOLATION_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_Exception_ACCESS_VIOLATION self)
        Reraise(Handle_OSD_Exception_ACCESS_VIOLATION self, Standard_CString const aMessage)
        Reraise(Handle_OSD_Exception_ACCESS_VIOLATION self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_Exception_ACCESS_VIOLATION_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_Exception_ACCESS_VIOLATION self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_Exception_ACCESS_VIOLATION_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_Exception_ACCESS_VIOLATION self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_Exception_ACCESS_VIOLATION_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_Exception_ACCESS_VIOLATION self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_Exception_ACCESS_VIOLATION_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_Exception_ACCESS_VIOLATION self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_Exception_ACCESS_VIOLATION self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_ACCESS_VIOLATION_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_Exception_ACCESS_VIOLATION self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_Exception_ACCESS_VIOLATION self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_ACCESS_VIOLATION_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_Exception_ACCESS_VIOLATION self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_Exception_ACCESS_VIOLATION_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_Exception_ACCESS_VIOLATION self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_ACCESS_VIOLATION_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_Exception_ACCESS_VIOLATION self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_Exception_ACCESS_VIOLATION_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_Exception_ACCESS_VIOLATION self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_ACCESS_VIOLATION_DecrementRefCounter(self, *args)

Handle_OSD_Exception_ACCESS_VIOLATION_swigregister = _OSD.Handle_OSD_Exception_ACCESS_VIOLATION_swigregister
Handle_OSD_Exception_ACCESS_VIOLATION_swigregister(Handle_OSD_Exception_ACCESS_VIOLATION)

def Handle_OSD_Exception_ACCESS_VIOLATION_DownCast(thing):
    return _OSD.Handle_OSD_Exception_ACCESS_VIOLATION_DownCast(thing)
Handle_OSD_Exception_ACCESS_VIOLATION_DownCast = _OSD.Handle_OSD_Exception_ACCESS_VIOLATION_DownCast

class OSD_Protection(object):
    """
    This  class provides data to manage file protection
    Example:These rights are treated in a system dependent manner :
    On UNIX you have User,Group and Other rights
    On VMS  you have Owner,Group,World and System rights
    An automatic conversion is done between OSD and UNIX/VMS.

    OSD	VMS	UNIX
    User     Owner   User
    Group    Group   Group
    World    World   Other
    System   System  (combined with Other)

    When you use System protection on UNIX you must know that
    Other rights and System rights are inclusively "ORed".
    So Other with only READ access and System with WRITE access
    will produce on UNIX Other with READ and WRITE access.

    This choice comes from the fact that ROOT can't be considered
    as member of the group nor as user. So it is considered as Other.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OSD_Protection self) -> OSD_Protection
        __init__(OSD_Protection self, OSD_SingleProtection const System, OSD_SingleProtection const User, OSD_SingleProtection const Group, OSD_SingleProtection const World) -> OSD_Protection

        Sets values of fields

        :type System: OCC.wrapper.OSD.OSD_SingleProtection
        :type User: OCC.wrapper.OSD.OSD_SingleProtection
        :type Group: OCC.wrapper.OSD.OSD_SingleProtection
        :type World: OCC.wrapper.OSD.OSD_SingleProtection

        """
        this = _OSD.new_OSD_Protection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Values(self, *args):
        """
        Values(OSD_Protection self)

        Retrieves values of fields

        :type System: OCC.wrapper.OSD.OSD_SingleProtection
        :type User: OCC.wrapper.OSD.OSD_SingleProtection
        :type Group: OCC.wrapper.OSD.OSD_SingleProtection
        :type World: OCC.wrapper.OSD.OSD_SingleProtection

        """
        return _OSD.OSD_Protection_Values(self, *args)


    def SetValues(self, *args):
        """
        SetValues(OSD_Protection self, OSD_SingleProtection const System, OSD_SingleProtection const User, OSD_SingleProtection const Group, OSD_SingleProtection const World)

        Sets values of fields

        :type System: OCC.wrapper.OSD.OSD_SingleProtection
        :type User: OCC.wrapper.OSD.OSD_SingleProtection
        :type Group: OCC.wrapper.OSD.OSD_SingleProtection
        :type World: OCC.wrapper.OSD.OSD_SingleProtection

        """
        return _OSD.OSD_Protection_SetValues(self, *args)


    def SetSystem(self, *args):
        """
        SetSystem(OSD_Protection self, OSD_SingleProtection const priv)

        Sets protection of 'System'

        :type priv: OCC.wrapper.OSD.OSD_SingleProtection

        """
        return _OSD.OSD_Protection_SetSystem(self, *args)


    def SetUser(self, *args):
        """
        SetUser(OSD_Protection self, OSD_SingleProtection const priv)

        Sets protection of 'User'

        :type priv: OCC.wrapper.OSD.OSD_SingleProtection

        """
        return _OSD.OSD_Protection_SetUser(self, *args)


    def SetGroup(self, *args):
        """
        SetGroup(OSD_Protection self, OSD_SingleProtection const priv)

        Sets protection of 'Group'

        :type priv: OCC.wrapper.OSD.OSD_SingleProtection

        """
        return _OSD.OSD_Protection_SetGroup(self, *args)


    def SetWorld(self, *args):
        """
        SetWorld(OSD_Protection self, OSD_SingleProtection const priv)

        Sets protection of 'World'

        :type priv: OCC.wrapper.OSD.OSD_SingleProtection

        """
        return _OSD.OSD_Protection_SetWorld(self, *args)


    def System(self, *args):
        """
        System(OSD_Protection self) -> OSD_SingleProtection

        Gets protection of 'System'

        :rtype: OCC.wrapper.OSD.OSD_SingleProtection

        """
        return _OSD.OSD_Protection_System(self, *args)


    def User(self, *args):
        """
        User(OSD_Protection self) -> OSD_SingleProtection

        Gets protection of 'User'

        :rtype: OCC.wrapper.OSD.OSD_SingleProtection

        """
        return _OSD.OSD_Protection_User(self, *args)


    def Group(self, *args):
        """
        Group(OSD_Protection self) -> OSD_SingleProtection

        Gets protection of 'Group'

        :rtype: OCC.wrapper.OSD.OSD_SingleProtection

        """
        return _OSD.OSD_Protection_Group(self, *args)


    def World(self, *args):
        """
        World(OSD_Protection self) -> OSD_SingleProtection

        Gets protection of 'World'

        :rtype: OCC.wrapper.OSD.OSD_SingleProtection

        """
        return _OSD.OSD_Protection_World(self, *args)


    def Add(self, *args):
        """
        Add(OSD_Protection self, OSD_SingleProtection const aRight)

        Add a right to a single protection.
        ex: aProt = RWD
        me.Add(aProt,X)  ->  aProt = RWXD

        :type aProt: OCC.wrapper.OSD.OSD_SingleProtection
        :type aRight: OCC.wrapper.OSD.OSD_SingleProtection

        """
        return _OSD.OSD_Protection_Add(self, *args)


    def Sub(self, *args):
        """
        Sub(OSD_Protection self, OSD_SingleProtection const aRight)

        Subtract a right to a single protection.
        ex: aProt = RWD
        me.Sub(aProt,RW) ->  aProt = D
        But me.Sub(aProt,RWX) is also valid and gives same result.

        :type aProt: OCC.wrapper.OSD.OSD_SingleProtection
        :type aRight: OCC.wrapper.OSD.OSD_SingleProtection

        """
        return _OSD.OSD_Protection_Sub(self, *args)

    __swig_destroy__ = _OSD.delete_OSD_Protection
OSD_Protection_swigregister = _OSD.OSD_Protection_swigregister
OSD_Protection_swigregister(OSD_Protection)

class Handle_OSD_Exception_IN_PAGE_ERROR(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_Exception_IN_PAGE_ERROR self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_Exception_IN_PAGE_ERROR_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_Exception_IN_PAGE_ERROR self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_Exception_IN_PAGE_ERROR_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_Exception_IN_PAGE_ERROR self, OSD_Exception_IN_PAGE_ERROR thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_Exception_IN_PAGE_ERROR_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_Exception_IN_PAGE_ERROR self, Handle_OSD_Exception_IN_PAGE_ERROR theHandle) -> Handle_OSD_Exception_IN_PAGE_ERROR
        assign(Handle_OSD_Exception_IN_PAGE_ERROR self, OSD_Exception_IN_PAGE_ERROR thePtr) -> Handle_OSD_Exception_IN_PAGE_ERROR
        assign(Handle_OSD_Exception_IN_PAGE_ERROR self, Handle_OSD_Exception_IN_PAGE_ERROR theHandle) -> Handle_OSD_Exception_IN_PAGE_ERROR

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_Exception_IN_PAGE_ERROR_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_Exception_IN_PAGE_ERROR self) -> OSD_Exception_IN_PAGE_ERROR

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_IN_PAGE_ERROR_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_Exception_IN_PAGE_ERROR self) -> OSD_Exception_IN_PAGE_ERROR

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_IN_PAGE_ERROR___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_Exception_IN_PAGE_ERROR self) -> OSD_Exception_IN_PAGE_ERROR

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_Exception_IN_PAGE_ERROR___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_Exception_IN_PAGE_ERROR___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_Exception_IN_PAGE_ERROR___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_Exception_IN_PAGE_ERROR(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_Exception_IN_PAGE_ERROR_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_Exception_IN_PAGE_ERROR

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_Exception_IN_PAGE_ERROR self, Standard_CString const theMessage) -> Handle_OSD_Exception_IN_PAGE_ERROR

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_IN_PAGE_ERROR

        """
        return _OSD.Handle_OSD_Exception_IN_PAGE_ERROR_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_Exception_IN_PAGE_ERROR self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_Exception_IN_PAGE_ERROR_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_IN_PAGE_ERROR_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_IN_PAGE_ERROR_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_Exception_IN_PAGE_ERROR self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_Exception_IN_PAGE_ERROR_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_Exception_IN_PAGE_ERROR self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_IN_PAGE_ERROR_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_Exception_IN_PAGE_ERROR self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_IN_PAGE_ERROR_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_Exception_IN_PAGE_ERROR self)
        Reraise(Handle_OSD_Exception_IN_PAGE_ERROR self, Standard_CString const aMessage)
        Reraise(Handle_OSD_Exception_IN_PAGE_ERROR self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_Exception_IN_PAGE_ERROR_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_Exception_IN_PAGE_ERROR self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_Exception_IN_PAGE_ERROR_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_Exception_IN_PAGE_ERROR self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_Exception_IN_PAGE_ERROR_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_Exception_IN_PAGE_ERROR self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_Exception_IN_PAGE_ERROR_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_Exception_IN_PAGE_ERROR self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_Exception_IN_PAGE_ERROR self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_IN_PAGE_ERROR_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_Exception_IN_PAGE_ERROR self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_Exception_IN_PAGE_ERROR self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_IN_PAGE_ERROR_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_Exception_IN_PAGE_ERROR self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_Exception_IN_PAGE_ERROR_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_Exception_IN_PAGE_ERROR self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_IN_PAGE_ERROR_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_Exception_IN_PAGE_ERROR self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_Exception_IN_PAGE_ERROR_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_Exception_IN_PAGE_ERROR self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_IN_PAGE_ERROR_DecrementRefCounter(self, *args)

Handle_OSD_Exception_IN_PAGE_ERROR_swigregister = _OSD.Handle_OSD_Exception_IN_PAGE_ERROR_swigregister
Handle_OSD_Exception_IN_PAGE_ERROR_swigregister(Handle_OSD_Exception_IN_PAGE_ERROR)

def Handle_OSD_Exception_IN_PAGE_ERROR_DownCast(thing):
    return _OSD.Handle_OSD_Exception_IN_PAGE_ERROR_DownCast(thing)
Handle_OSD_Exception_IN_PAGE_ERROR_DownCast = _OSD.Handle_OSD_Exception_IN_PAGE_ERROR_DownCast

class Handle_OSD_Exception_PRIV_INSTRUCTION(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_Exception_PRIV_INSTRUCTION self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_Exception_PRIV_INSTRUCTION self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_Exception_PRIV_INSTRUCTION self, OSD_Exception_PRIV_INSTRUCTION thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_Exception_PRIV_INSTRUCTION self, Handle_OSD_Exception_PRIV_INSTRUCTION theHandle) -> Handle_OSD_Exception_PRIV_INSTRUCTION
        assign(Handle_OSD_Exception_PRIV_INSTRUCTION self, OSD_Exception_PRIV_INSTRUCTION thePtr) -> Handle_OSD_Exception_PRIV_INSTRUCTION
        assign(Handle_OSD_Exception_PRIV_INSTRUCTION self, Handle_OSD_Exception_PRIV_INSTRUCTION theHandle) -> Handle_OSD_Exception_PRIV_INSTRUCTION

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_Exception_PRIV_INSTRUCTION self) -> OSD_Exception_PRIV_INSTRUCTION

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_Exception_PRIV_INSTRUCTION self) -> OSD_Exception_PRIV_INSTRUCTION

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_Exception_PRIV_INSTRUCTION self) -> OSD_Exception_PRIV_INSTRUCTION

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_Exception_PRIV_INSTRUCTION(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_Exception_PRIV_INSTRUCTION_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_Exception_PRIV_INSTRUCTION

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_Exception_PRIV_INSTRUCTION self, Standard_CString const theMessage) -> Handle_OSD_Exception_PRIV_INSTRUCTION

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_PRIV_INSTRUCTION

        """
        return _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_Exception_PRIV_INSTRUCTION self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_Exception_PRIV_INSTRUCTION self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_Exception_PRIV_INSTRUCTION self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_Exception_PRIV_INSTRUCTION self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_Exception_PRIV_INSTRUCTION self)
        Reraise(Handle_OSD_Exception_PRIV_INSTRUCTION self, Standard_CString const aMessage)
        Reraise(Handle_OSD_Exception_PRIV_INSTRUCTION self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_Exception_PRIV_INSTRUCTION self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_Exception_PRIV_INSTRUCTION self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_Exception_PRIV_INSTRUCTION self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_Exception_PRIV_INSTRUCTION self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_Exception_PRIV_INSTRUCTION self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_Exception_PRIV_INSTRUCTION self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_Exception_PRIV_INSTRUCTION self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_Exception_PRIV_INSTRUCTION self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_Exception_PRIV_INSTRUCTION self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_Exception_PRIV_INSTRUCTION self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_Exception_PRIV_INSTRUCTION self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION_DecrementRefCounter(self, *args)

Handle_OSD_Exception_PRIV_INSTRUCTION_swigregister = _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION_swigregister
Handle_OSD_Exception_PRIV_INSTRUCTION_swigregister(Handle_OSD_Exception_PRIV_INSTRUCTION)

def Handle_OSD_Exception_PRIV_INSTRUCTION_DownCast(thing):
    return _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION_DownCast(thing)
Handle_OSD_Exception_PRIV_INSTRUCTION_DownCast = _OSD.Handle_OSD_Exception_PRIV_INSTRUCTION_DownCast

class Handle_OSD_Exception_INT_DIVIDE_BY_ZERO(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self, OSD_Exception_INT_DIVIDE_BY_ZERO thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self, Handle_OSD_Exception_INT_DIVIDE_BY_ZERO theHandle) -> Handle_OSD_Exception_INT_DIVIDE_BY_ZERO
        assign(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self, OSD_Exception_INT_DIVIDE_BY_ZERO thePtr) -> Handle_OSD_Exception_INT_DIVIDE_BY_ZERO
        assign(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self, Handle_OSD_Exception_INT_DIVIDE_BY_ZERO theHandle) -> Handle_OSD_Exception_INT_DIVIDE_BY_ZERO

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self) -> OSD_Exception_INT_DIVIDE_BY_ZERO

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self) -> OSD_Exception_INT_DIVIDE_BY_ZERO

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self) -> OSD_Exception_INT_DIVIDE_BY_ZERO

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_Exception_INT_DIVIDE_BY_ZERO(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_Exception_INT_DIVIDE_BY_ZERO

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self, Standard_CString const theMessage) -> Handle_OSD_Exception_INT_DIVIDE_BY_ZERO

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO

        """
        return _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self)
        Reraise(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self, Standard_CString const aMessage)
        Reraise(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_DecrementRefCounter(self, *args)

Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_swigregister = _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_swigregister
Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_swigregister(Handle_OSD_Exception_INT_DIVIDE_BY_ZERO)

def Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_DownCast(thing):
    return _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_DownCast(thing)
Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_DownCast = _OSD.Handle_OSD_Exception_INT_DIVIDE_BY_ZERO_DownCast

class OSD_Timer(OSD_Chronometer):
    """
    Working on heterogeneous platforms
    we need to use the system call gettimeofday.
    This function is portable and it measures ELAPSED
    time and CPU time in seconds and microseconds.
    Example: OSD_Timer aTimer;
    aTimer.Start();   // Start  the timers (t1).
    .....            // Do something.
    aTimer.Stop();    // Stop the timers (t2).
    aTimer.Show();    // Give the elapsed time between t1 and t2.
    // Give also the process CPU time between
    // t1 and t2.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OSD_Timer self, Standard_Boolean theThisThreadOnly) -> OSD_Timer

        Builds a Chronometer initialized and stopped.
        @param theThisThreadOnly when TRUE, measured CPU time will account time of the current thread only;
        otherwise CPU of the process (all threads, and completed children) is measured;
        this flag does NOT affect ElapsedTime() value, only values returned by OSD_Chronometer

        :type theThisThreadOnly: bool

        """
        this = _OSD.new_OSD_Timer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Reset(self, *args):
        """
        Reset(OSD_Timer self, Standard_Real const theTimeElapsedSec)
        Reset(OSD_Timer self)

        Stops and reinitializes the timer with zero elapsed time.


        """
        return _OSD.OSD_Timer_Reset(self, *args)


    def Restart(self, *args):
        """
        Restart(OSD_Timer self)

        Restarts the Timer.


        """
        return _OSD.OSD_Timer_Restart(self, *args)


    def Show(self, *args):
        """
        Show(OSD_Timer self)
        Show(OSD_Timer self, Standard_OStream & os)
        Show(OSD_Timer self)

        returns both the elapsed time(seconds,minutes,hours)
        and CPU  time.

        :type theSeconds: float
        :type theMinutes: int
        :type theHours: int
        :type theCPUtime: float

        """
        return _OSD.OSD_Timer_Show(self, *args)


    def Stop(self, *args):
        """
        Stop(OSD_Timer self)

        Stops the Timer.


        """
        return _OSD.OSD_Timer_Stop(self, *args)


    def Start(self, *args):
        """
        Start(OSD_Timer self)

        Starts (after Create or Reset) or restarts (after Stop)
        the Timer.


        """
        return _OSD.OSD_Timer_Start(self, *args)


    def ElapsedTime(self, *args):
        """
        ElapsedTime(OSD_Timer self) -> Standard_Real

        Returns elapsed time in seconds.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _OSD.OSD_Timer_ElapsedTime(self, *args)

    __swig_destroy__ = _OSD.delete_OSD_Timer
OSD_Timer_swigregister = _OSD.OSD_Timer_swigregister
OSD_Timer_swigregister(OSD_Timer)

class OSD_Disk(object):
    """Disk management (a set of disk oriented tools)"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(OSD_Disk self) -> OSD_Disk
        __init__(OSD_Disk self, OSD_Path Name) -> OSD_Disk
        __init__(OSD_Disk self, Standard_CString const PathName) -> OSD_Disk

        Initializes the object Disk with <PathName>.
        <PathName> specifies any file within the mounted
        file system.
        Example : OSD_Disk myDisk ("/tmp")
        Initializes a disk object with the mounted
        file associated to /tmp.

        :type PathName: OCC.wrapper.Standard.Standard_CString

        """
        this = _OSD.new_OSD_Disk(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Name(self, *args):
        """
        Name(OSD_Disk self) -> OSD_Path

        Returns disk name of <me>.

        :rtype: OCC.wrapper.OSD.OSD_Path

        """
        return _OSD.OSD_Disk_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(OSD_Disk self, OSD_Path Name)

        Instantiates <me> with <Name>.

        :type Name: OCC.wrapper.OSD.OSD_Path

        """
        return _OSD.OSD_Disk_SetName(self, *args)


    def DiskSize(self, *args):
        """
        DiskSize(OSD_Disk self) -> Standard_Integer

        Returns total disk capacity in 512 bytes blocks.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.OSD_Disk_DiskSize(self, *args)


    def DiskFree(self, *args):
        """
        DiskFree(OSD_Disk self) -> Standard_Integer

        Returns free available 512 bytes blocks on disk.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.OSD_Disk_DiskFree(self, *args)


    def Failed(self, *args):
        """
        Failed(OSD_Disk self) -> Standard_Boolean

        Returns TRUE if an error occurs

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.OSD_Disk_Failed(self, *args)


    def Reset(self, *args):
        """
        Reset(OSD_Disk self)

        Resets error counter to zero


        """
        return _OSD.OSD_Disk_Reset(self, *args)


    def Perror(self, *args):
        """
        Perror(OSD_Disk self)

        Raises OSD_Error


        """
        return _OSD.OSD_Disk_Perror(self, *args)


    def Error(self, *args):
        """
        Error(OSD_Disk self) -> Standard_Integer

        Returns error number if 'Failed' is TRUE.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.OSD_Disk_Error(self, *args)

    __swig_destroy__ = _OSD.delete_OSD_Disk
OSD_Disk_swigregister = _OSD.OSD_Disk_swigregister
OSD_Disk_swigregister(OSD_Disk)

class Handle_OSD_SIGILL(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_SIGILL self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_SIGILL_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_SIGILL self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_SIGILL_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_SIGILL self, OSD_SIGILL thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_SIGILL_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_SIGILL self, Handle_OSD_SIGILL theHandle) -> Handle_OSD_SIGILL
        assign(Handle_OSD_SIGILL self, OSD_SIGILL thePtr) -> Handle_OSD_SIGILL
        assign(Handle_OSD_SIGILL self, Handle_OSD_SIGILL theHandle) -> Handle_OSD_SIGILL

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_SIGILL_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_SIGILL self) -> OSD_SIGILL

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_SIGILL_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_SIGILL self) -> OSD_SIGILL

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_SIGILL___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_SIGILL self) -> OSD_SIGILL

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_SIGILL___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_SIGILL___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_SIGILL___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_SIGILL(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_SIGILL_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_SIGILL

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_SIGILL self, Standard_CString const theMessage) -> Handle_OSD_SIGILL

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_SIGILL

        """
        return _OSD.Handle_OSD_SIGILL_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_SIGILL self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_SIGILL_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_SIGILL_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_SIGILL_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_SIGILL self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_SIGILL_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_SIGILL self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_SIGILL_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_SIGILL self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_SIGILL_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_SIGILL self)
        Reraise(Handle_OSD_SIGILL self, Standard_CString const aMessage)
        Reraise(Handle_OSD_SIGILL self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_SIGILL_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_SIGILL self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_SIGILL_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_SIGILL self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_SIGILL_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_SIGILL self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_SIGILL_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_SIGILL self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_SIGILL self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_SIGILL_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_SIGILL self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_SIGILL self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_SIGILL_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_SIGILL self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_SIGILL_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_SIGILL self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_SIGILL_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_SIGILL self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_SIGILL_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_SIGILL self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_SIGILL_DecrementRefCounter(self, *args)

Handle_OSD_SIGILL_swigregister = _OSD.Handle_OSD_SIGILL_swigregister
Handle_OSD_SIGILL_swigregister(Handle_OSD_SIGILL)

def Handle_OSD_SIGILL_DownCast(thing):
    return _OSD.Handle_OSD_SIGILL_DownCast(thing)
Handle_OSD_SIGILL_DownCast = _OSD.Handle_OSD_SIGILL_DownCast

class OSD_MemInfo(object):
    """
    This class provide information about memory utilized by current process.
    This information includes:
    - Private Memory - synthetic value that tries to filter out the memory
    usage only by the process itself (allocated for data
    and stack), excluding dynamic libraries.
    These pages may be in RAM or in SWAP.
    - Virtual Memory - amount of reserved and committed memory in the
    user-mode portion of the virtual address space.
    Notice that this counter includes reserved memory
    (not yet in used) and shared between processes memory (libraries).
    - Working Set    - set of memory pages in the virtual address space of the process
    that are currently resident in physical memory (RAM).
    These pages are available for an application to use
    without triggering a page fault.
    - Pagefile Usage - space allocated for the pagefile, in bytes.
    Those pages may or may not be in memory (RAM)
    thus this counter couldn't be used to estimate
    how many active pages doesn't present in RAM.

    Notice that none of these counters can be used as absolute measure of
    application memory consumption!

    User should analyze all values in specific case to make correct decision
    about memory (over)usage. This is also prefferred to use specialized
    tools to detect memory leaks.

    This also means that these values should not be used for intellectual
    memory management by application itself.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    MemPrivate = _OSD.OSD_MemInfo_MemPrivate
    MemVirtual = _OSD.OSD_MemInfo_MemVirtual
    MemWorkingSet = _OSD.OSD_MemInfo_MemWorkingSet
    MemWorkingSetPeak = _OSD.OSD_MemInfo_MemWorkingSetPeak
    MemSwapUsage = _OSD.OSD_MemInfo_MemSwapUsage
    MemSwapUsagePeak = _OSD.OSD_MemInfo_MemSwapUsagePeak
    MemHeapUsage = _OSD.OSD_MemInfo_MemHeapUsage
    MemCounter_NB = _OSD.OSD_MemInfo_MemCounter_NB

    def __init__(self, *args):
        """
        __init__(OSD_MemInfo self) -> OSD_MemInfo

        Create and initialize


        """
        this = _OSD.new_OSD_MemInfo(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Update(self, *args):
        """
        Update(OSD_MemInfo self)

        Update counters


        """
        return _OSD.OSD_MemInfo_Update(self, *args)


    def ToString(self, *args):
        """
        ToString(OSD_MemInfo self) -> TCollection_AsciiString

        Return the string representation for all available counter.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_MemInfo_ToString(self, *args)


    def Value(self, *args):
        """
        Value(OSD_MemInfo self, OSD_MemInfo::Counter const theCounter) -> Standard_Size

        Return value or specified counter in bytes.
        Notice that NOT all counters are available on various systems.
        Standard_Size(-1) means invalid (unavailable) value.

        :type theCounter: Counter
        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OSD.OSD_MemInfo_Value(self, *args)


    def ValueMiB(self, *args):
        """
        ValueMiB(OSD_MemInfo self, OSD_MemInfo::Counter const theCounter) -> Standard_Size

        Return value or specified counter in MiB.
        Notice that NOT all counters are available on various systems.
        Standard_Size(-1) means invalid (unavailable) value.

        :type theCounter: Counter
        :rtype: OCC.wrapper.Standard.Standard_Size

        """
        return _OSD.OSD_MemInfo_ValueMiB(self, *args)


    def PrintInfo(*args):
        """
        PrintInfo() -> TCollection_AsciiString

        Return the string representation for all available counter.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _OSD.OSD_MemInfo_PrintInfo(*args)

    PrintInfo = staticmethod(PrintInfo)
    __swig_destroy__ = _OSD.delete_OSD_MemInfo
OSD_MemInfo_swigregister = _OSD.OSD_MemInfo_swigregister
OSD_MemInfo_swigregister(OSD_MemInfo)

def OSD_MemInfo_PrintInfo(*args):
    """
    OSD_MemInfo_PrintInfo() -> TCollection_AsciiString

    Return the string representation for all available counter.

    :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

    """
    return _OSD.OSD_MemInfo_PrintInfo(*args)

class Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self, OSD_Exception_NONCONTINUABLE_EXCEPTION thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self, Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION theHandle) -> Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION
        assign(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self, OSD_Exception_NONCONTINUABLE_EXCEPTION thePtr) -> Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION
        assign(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self, Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION theHandle) -> Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self) -> OSD_Exception_NONCONTINUABLE_EXCEPTION

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self) -> OSD_Exception_NONCONTINUABLE_EXCEPTION

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self) -> OSD_Exception_NONCONTINUABLE_EXCEPTION

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self, Standard_CString const theMessage) -> Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION

        """
        return _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self)
        Reraise(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self, Standard_CString const aMessage)
        Reraise(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_DecrementRefCounter(self, *args)

Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_swigregister = _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_swigregister
Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_swigregister(Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION)

def Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_DownCast(thing):
    return _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_DownCast(thing)
Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_DownCast = _OSD.Handle_OSD_Exception_NONCONTINUABLE_EXCEPTION_DownCast

class Handle_OSD_SIGSYS(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_SIGSYS self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_SIGSYS_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_SIGSYS self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_SIGSYS_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_SIGSYS self, OSD_SIGSYS thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_SIGSYS_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_SIGSYS self, Handle_OSD_SIGSYS theHandle) -> Handle_OSD_SIGSYS
        assign(Handle_OSD_SIGSYS self, OSD_SIGSYS thePtr) -> Handle_OSD_SIGSYS
        assign(Handle_OSD_SIGSYS self, Handle_OSD_SIGSYS theHandle) -> Handle_OSD_SIGSYS

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_SIGSYS_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_SIGSYS self) -> OSD_SIGSYS

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_SIGSYS_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_SIGSYS self) -> OSD_SIGSYS

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_SIGSYS___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_SIGSYS self) -> OSD_SIGSYS

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_SIGSYS___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_SIGSYS___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_SIGSYS___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_SIGSYS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_SIGSYS_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_SIGSYS

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_SIGSYS self, Standard_CString const theMessage) -> Handle_OSD_SIGSYS

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_SIGSYS

        """
        return _OSD.Handle_OSD_SIGSYS_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_SIGSYS self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_SIGSYS_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_SIGSYS_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_SIGSYS_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_SIGSYS self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_SIGSYS_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_SIGSYS self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_SIGSYS_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_SIGSYS self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_SIGSYS_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_SIGSYS self)
        Reraise(Handle_OSD_SIGSYS self, Standard_CString const aMessage)
        Reraise(Handle_OSD_SIGSYS self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_SIGSYS_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_SIGSYS self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_SIGSYS_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_SIGSYS self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_SIGSYS_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_SIGSYS self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_SIGSYS_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_SIGSYS self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_SIGSYS self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_SIGSYS_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_SIGSYS self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_SIGSYS self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_SIGSYS_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_SIGSYS self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_SIGSYS_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_SIGSYS self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_SIGSYS_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_SIGSYS self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_SIGSYS_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_SIGSYS self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_SIGSYS_DecrementRefCounter(self, *args)

Handle_OSD_SIGSYS_swigregister = _OSD.Handle_OSD_SIGSYS_swigregister
Handle_OSD_SIGSYS_swigregister(Handle_OSD_SIGSYS)

def Handle_OSD_SIGSYS_DownCast(thing):
    return _OSD.Handle_OSD_SIGSYS_DownCast(thing)
Handle_OSD_SIGSYS_DownCast = _OSD.Handle_OSD_SIGSYS_DownCast

class Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self)

        Nullify the handle


        """
        return _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self) -> bool

        Check for being null

        :rtype: bool

        """
        return _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self, OSD_Exception_FLT_DIVIDE_BY_ZERO thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self, Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO theHandle) -> Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO
        assign(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self, OSD_Exception_FLT_DIVIDE_BY_ZERO thePtr) -> Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO
        assign(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self, Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO theHandle) -> Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self) -> OSD_Exception_FLT_DIVIDE_BY_ZERO

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self) -> OSD_Exception_FLT_DIVIDE_BY_ZERO

        Member access operator (note non-const)

        :rtype: T *

        """
        return _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self) -> OSD_Exception_FLT_DIVIDE_BY_ZERO

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO___ref__(self, *args)


    def __hash__(self):
        return _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _OSD.new_Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_DownCast)
    __swig_destroy__ = _OSD.delete_Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO

    def NewInstance(self, *args):
        """
        NewInstance(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self, Standard_CString const theMessage) -> Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO

        """
        return _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self) -> char const *

        :rtype: const char *

        """
        return _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self)
        Reraise(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self, Standard_CString const aMessage)
        Reraise(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self)

        Memory deallocator for transient classes


        """
        return _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self)

        Increments the reference counter of this object


        """
        return _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_DecrementRefCounter(self, *args)

Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_swigregister = _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_swigregister
Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_swigregister(Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO)

def Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_DownCast(thing):
    return _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_DownCast(thing)
Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_DownCast = _OSD.Handle_OSD_Exception_FLT_DIVIDE_BY_ZERO_DownCast




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_StepData')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_StepData')
    _StepData = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_StepData', [dirname(__file__)])
        except ImportError:
            import _StepData
            return _StepData
        try:
            _mod = imp.load_module('_StepData', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _StepData = swig_import_helper()
    del swig_import_helper
else:
    import _StepData
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _StepData.delete_SwigPyIterator

    def value(self):
        return _StepData.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _StepData.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _StepData.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _StepData.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _StepData.SwigPyIterator_equal(self, x)

    def copy(self):
        return _StepData.SwigPyIterator_copy(self)

    def next(self):
        return _StepData.SwigPyIterator_next(self)

    def __next__(self):
        return _StepData.SwigPyIterator___next__(self)

    def previous(self):
        return _StepData.SwigPyIterator_previous(self)

    def advance(self, n):
        return _StepData.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _StepData.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _StepData.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _StepData.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _StepData.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _StepData.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _StepData.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _StepData.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _StepData.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_StepData.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _StepData.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _StepData.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepData.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _StepData.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _StepData.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _StepData.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _StepData.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_StepData.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _StepData.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _StepData.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepData.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _StepData.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _StepData.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _StepData.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _StepData.ptr_to_number(item)
ptr_to_number = _StepData.ptr_to_number

def HashCode(*args):
    return _StepData.HashCode(*args)
HashCode = _StepData.HashCode

def ptr_equal(a, b):
    return _StepData.ptr_equal(a, b)
ptr_equal = _StepData.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Interface
else:
    import Interface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import MoniTool
else:
    import MoniTool
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
StepData_LFalse = _StepData.StepData_LFalse
StepData_LTrue = _StepData.StepData_LTrue
StepData_LUnknown = _StepData.StepData_LUnknown
class StepData_Described(Standard.Standard_Transient):
    """
    General frame to describe entities with Description (Simple or
    Complex)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_Described
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_Described(self) 
            return h


    def Description(self, *args):
        """
        Description(StepData_Described self) -> Handle_StepData_EDescr

        Returns the Description used to define this entity

        :rtype: OCC.wrapper.StepData.Handle_StepData_EDescr

        """
        return _StepData.StepData_Described_Description(self, *args)


    def IsComplex(self, *args):
        """
        IsComplex(StepData_Described self) -> Standard_Boolean

        Tells if a described entity is complex

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_Described_IsComplex(self, *args)


    def Matches(self, *args):
        """
        Matches(StepData_Described self, Standard_CString const steptype) -> Standard_Boolean

        Tells if a step type is matched by <me>
        For a Simple Entity : own type or super type
        For a Complex Entity : one of the members

        :type steptype: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_Described_Matches(self, *args)


    def As(self, *args):
        """
        As(StepData_Described self, Standard_CString const steptype) -> Handle_StepData_Simple

        Returns a Simple Entity which matches with a Type in <me> :
        For a Simple Entity : me if it matches, else a null handle
        For a Complex Entity : the member which matches, else null

        :type steptype: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.StepData.Handle_StepData_Simple

        """
        return _StepData.StepData_Described_As(self, *args)


    def HasField(self, *args):
        """
        HasField(StepData_Described self, Standard_CString const name) -> Standard_Boolean

        Tells if a Field brings a given name

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_Described_HasField(self, *args)


    def Field(self, *args):
        """
        Returns a Field from its name; read-only

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        res = _StepData.StepData_Described_Field(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CField(self, *args):
        """
        CField(StepData_Described self, Standard_CString const name) -> StepData_Field

        Returns a Field from its name; read or write

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        return _StepData.StepData_Described_CField(self, *args)


    def Check(self, *args):
        """
        Check(StepData_Described self, Handle_Interface_Check ach)

        Fills a Check by using its Description

        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _StepData.StepData_Described_Check(self, *args)


    def Shared(self, *args):
        """
        Shared(StepData_Described self, Interface_EntityIterator list)

        Fills an EntityIterator with entities shared by <me>

        :type list: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.StepData_Described_Shared(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_Described_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_Described_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_Described_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_Described
StepData_Described_swigregister = _StepData.StepData_Described_swigregister
StepData_Described_swigregister(StepData_Described)

def StepData_Described_get_type_name(*args):
    """
    StepData_Described_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_Described_get_type_name(*args)

def StepData_Described_get_type_descriptor(*args):
    """
    StepData_Described_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_Described_get_type_descriptor(*args)

class StepData_GeneralModule(Interface.Interface_GeneralModule):
    """Specific features for General Services adapted to STEP"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_GeneralModule
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_GeneralModule(self) 
            return h


    def FillSharedCase(self, *args):
        """
        FillSharedCase(StepData_GeneralModule self, Standard_Integer const casenum, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        Specific filling of the list of Entities shared by an Entity
        <ent>. Can use the internal utility method Share, below

        :type casenum: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.StepData_GeneralModule_FillSharedCase(self, *args)


    def CheckCase(self, *args):
        """
        CheckCase(StepData_GeneralModule self, Standard_Integer const casenum, Handle_Standard_Transient ent, Interface_ShareTool shares, Handle_Interface_Check ach)

        Specific Checking of an Entity <ent>

        :type casenum: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type shares: OCC.wrapper.Interface.Interface_ShareTool
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _StepData.StepData_GeneralModule_CheckCase(self, *args)


    def CopyCase(self, *args):
        """
        CopyCase(StepData_GeneralModule self, Standard_Integer const casenum, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC)

        Specific Copy ("Deep") from <entfrom> to <entto> (same type)
        by using a TransferControl which provides its working Map.
        Use method Transferred from TransferControl to work
        Specific Copying of Implied References
        A Default is provided which does nothing (must current case !)
        Already copied references (by CopyFrom) must remain unchanged
        Use method Search from TransferControl to work

        :type casenum: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _StepData.StepData_GeneralModule_CopyCase(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_GeneralModule_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_GeneralModule_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_GeneralModule_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_GeneralModule
StepData_GeneralModule_swigregister = _StepData.StepData_GeneralModule_swigregister
StepData_GeneralModule_swigregister(StepData_GeneralModule)

def StepData_GeneralModule_get_type_name(*args):
    """
    StepData_GeneralModule_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_GeneralModule_get_type_name(*args)

def StepData_GeneralModule_get_type_descriptor(*args):
    """
    StepData_GeneralModule_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_GeneralModule_get_type_descriptor(*args)

class StepData_Protocol(Interface.Interface_Protocol):
    """
    Description of Basic Protocol for Step
    The class Protocol from StepData itself describes a default
    Protocol, which recognizes only UnknownEntities.
    Sub-classes will redefine CaseNumber and, if necessary,
    NbResources and Resources.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_Protocol
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_Protocol(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepData_Protocol self) -> StepData_Protocol

        Description of Basic Protocol for Step
        The class Protocol from StepData itself describes a default
        Protocol, which recognizes only UnknownEntities.
        Sub-classes will redefine CaseNumber and, if necessary,
        NbResources and Resources.
        """
        this = _StepData.new_StepData_Protocol(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NbResources(self, *args):
        """
        NbResources(StepData_Protocol self) -> Standard_Integer

        Gives the count of Protocols used as Resource (can be zero)
        Here, No resource

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_Protocol_NbResources(self, *args)


    def Resource(self, *args):
        """
        Resource(StepData_Protocol self, Standard_Integer const num) -> Handle_Interface_Protocol

        Returns a Resource, given a rank. Here, none

        :type num: int
        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _StepData.StepData_Protocol_Resource(self, *args)


    def CaseNumber(self, *args):
        """
        CaseNumber(StepData_Protocol self, Handle_Standard_Transient obj) -> Standard_Integer

        Returns a unique positive number for any recognized entity
        Redefined to work by calling both TypeNumber and, for a
        Described Entity (late binding) DescrNumber

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_Protocol_CaseNumber(self, *args)


    def TypeNumber(self, *args):
        """
        TypeNumber(StepData_Protocol self, Handle_Standard_Type atype) -> Standard_Integer

        Returns a Case Number, specific of each recognized Type
        Here, only Unknown Entity is recognized

        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_Protocol_TypeNumber(self, *args)


    def SchemaName(self, *args):
        """
        SchemaName(StepData_Protocol self) -> Standard_CString

        Returns the Schema Name attached to each class of Protocol
        To be redefined by each sub-class
        Here, SchemaName returns "(DEFAULT)"
        was C++ : return const

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_Protocol_SchemaName(self, *args)


    def NewModel(self, *args):
        """
        NewModel(StepData_Protocol self) -> Handle_Interface_InterfaceModel

        Creates an empty Model for Step Norm

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _StepData.StepData_Protocol_NewModel(self, *args)


    def IsSuitableModel(self, *args):
        """
        IsSuitableModel(StepData_Protocol self, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns True if <model> is a Model of Step Norm

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_Protocol_IsSuitableModel(self, *args)


    def UnknownEntity(self, *args):
        """
        UnknownEntity(StepData_Protocol self) -> Handle_Standard_Transient

        Creates a new Unknown Entity for Step (UndefinedEntity)

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.StepData_Protocol_UnknownEntity(self, *args)


    def IsUnknownEntity(self, *args):
        """
        IsUnknownEntity(StepData_Protocol self, Handle_Standard_Transient ent) -> Standard_Boolean

        Returns True if <ent> is an Unknown Entity for the Norm, i.e.
        Type UndefinedEntity, status Unknown

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_Protocol_IsUnknownEntity(self, *args)


    def DescrNumber(self, *args):
        """
        DescrNumber(StepData_Protocol self, Handle_StepData_EDescr adescr) -> Standard_Integer

        Returns a unique positive CaseNumber for types described by
        an EDescr (late binding)
        Warning : TypeNumber and DescrNumber must give together a unique
        positive case number for each distinct case, type or descr

        :type adescr: OCC.wrapper.StepData.Handle_StepData_EDescr
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_Protocol_DescrNumber(self, *args)


    def AddDescr(self, *args):
        """
        AddDescr(StepData_Protocol self, Handle_StepData_EDescr adescr, Standard_Integer const CN)

        Records an EDescr with its case number
        Also records its name for an ESDescr (simple type): an ESDescr
        is then used, for case number, or for type name

        :type adescr: OCC.wrapper.StepData.Handle_StepData_EDescr
        :type CN: int

        """
        return _StepData.StepData_Protocol_AddDescr(self, *args)


    def HasDescr(self, *args):
        """
        HasDescr(StepData_Protocol self) -> Standard_Boolean

        Tells if a Protocol brings at least one ESDescr, i.e. if it
        defines at least one entity description by ESDescr mechanism

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_Protocol_HasDescr(self, *args)


    def Descr(self, *args):
        """
        Descr(StepData_Protocol self, Standard_Integer const num) -> Handle_StepData_EDescr
        Descr(StepData_Protocol self, Standard_CString const name, Standard_Boolean const anylevel) -> Handle_StepData_EDescr

        Returns a description according to its name
        <anylevel> True (D) : for <me> and its resources
        <anylevel> False : for <me> only

        :type name: OCC.wrapper.Standard.Standard_CString
        :type anylevel: bool
        :rtype: OCC.wrapper.StepData.Handle_StepData_EDescr

        """
        return _StepData.StepData_Protocol_Descr(self, *args)


    def ESDescr(self, *args):
        """
        ESDescr(StepData_Protocol self, Standard_CString const name, Standard_Boolean const anylevel) -> Handle_StepData_ESDescr

        Idem as Descr but cast to simple description

        :type name: OCC.wrapper.Standard.Standard_CString
        :type anylevel: bool
        :rtype: OCC.wrapper.StepData.Handle_StepData_ESDescr

        """
        return _StepData.StepData_Protocol_ESDescr(self, *args)


    def ECDescr(self, *args):
        """
        ECDescr(StepData_Protocol self, NCollection_Sequence_TCollection_AsciiString names, Standard_Boolean const anylevel) -> Handle_StepData_ECDescr

        Returns a complex description according to list of names
        <anylevel> True (D) : for <me> and its resources
        <anylevel> False : for <me> only

        :type names: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString
        :type anylevel: bool
        :rtype: OCC.wrapper.StepData.Handle_StepData_ECDescr

        """
        return _StepData.StepData_Protocol_ECDescr(self, *args)


    def AddPDescr(self, *args):
        """
        AddPDescr(StepData_Protocol self, Handle_StepData_PDescr pdescr)

        Records an PDescr

        :type pdescr: OCC.wrapper.StepData.Handle_StepData_PDescr

        """
        return _StepData.StepData_Protocol_AddPDescr(self, *args)


    def PDescr(self, *args):
        """
        PDescr(StepData_Protocol self, Standard_CString const name, Standard_Boolean const anylevel) -> Handle_StepData_PDescr

        Returns a parameter description according to its name
        <anylevel> True (D) : for <me> and its resources
        <anylevel> False : for <me> only

        :type name: OCC.wrapper.Standard.Standard_CString
        :type anylevel: bool
        :rtype: OCC.wrapper.StepData.Handle_StepData_PDescr

        """
        return _StepData.StepData_Protocol_PDescr(self, *args)


    def AddBasicDescr(self, *args):
        """
        AddBasicDescr(StepData_Protocol self, Handle_StepData_ESDescr esdescr)

        Records an ESDescr, intended to build complex descriptions

        :type esdescr: OCC.wrapper.StepData.Handle_StepData_ESDescr

        """
        return _StepData.StepData_Protocol_AddBasicDescr(self, *args)


    def BasicDescr(self, *args):
        """
        BasicDescr(StepData_Protocol self, Standard_CString const name, Standard_Boolean const anylevel) -> Handle_StepData_EDescr

        Returns a basic description according to its name
        <anylevel> True (D) : for <me> and its resources
        <anylevel> False : for <me> only

        :type name: OCC.wrapper.Standard.Standard_CString
        :type anylevel: bool
        :rtype: OCC.wrapper.StepData.Handle_StepData_EDescr

        """
        return _StepData.StepData_Protocol_BasicDescr(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_Protocol_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_Protocol_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_Protocol_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_Protocol
StepData_Protocol_swigregister = _StepData.StepData_Protocol_swigregister
StepData_Protocol_swigregister(StepData_Protocol)

def StepData_Protocol_get_type_name(*args):
    """
    StepData_Protocol_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_Protocol_get_type_name(*args)

def StepData_Protocol_get_type_descriptor(*args):
    """
    StepData_Protocol_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_Protocol_get_type_descriptor(*args)

class StepData_SelectMember(Standard.Standard_Transient):
    """
    The general form for a Select Member. A Select Member can,
    either define a value of a basic type (such as an integer)
    with an additional information : a name or list of names
    which precise the meaning of this value
    or be an alternate value in a select, which also accepts an
    entity (in this case, the name is not mandatory)

    Several sub-types of SelectMember are defined for integer and
    real value, plus an "universal" one for any, and one more to
    describe a select with several names

    It is also possible to define a specific subtype by redefining
    virtual method, then give a better control

    Remark : this class itself could be deferred, because at least
    one of its virtual methods must be redefined to be usable
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_SelectMember
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_SelectMember(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepData_SelectMember self) -> StepData_SelectMember

        The general form for a Select Member. A Select Member can,
        either define a value of a basic type (such as an integer)
        with an additional information : a name or list of names
        which precise the meaning of this value
        or be an alternate value in a select, which also accepts an
        entity (in this case, the name is not mandatory)

        Several sub-types of SelectMember are defined for integer and
        real value, plus an "universal" one for any, and one more to
        describe a select with several names

        It is also possible to define a specific subtype by redefining
        virtual method, then give a better control

        Remark : this class itself could be deferred, because at least
        one of its virtual methods must be redefined to be usable
        """
        this = _StepData.new_StepData_SelectMember(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def HasName(self, *args):
        """
        HasName(StepData_SelectMember self) -> Standard_Boolean

        Tells if a SelectMember has a name. Default is False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_SelectMember_HasName(self, *args)


    def Name(self, *args):
        """
        Name(StepData_SelectMember self) -> Standard_CString

        Returns the name of a SelectMember. Default is empty

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_SelectMember_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepData_SelectMember self, Standard_CString const name) -> Standard_Boolean

        Sets the name of a SelectMember, returns True if done, False
        if no name is allowed
        Default does nothing and returns False

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_SelectMember_SetName(self, *args)


    def Matches(self, *args):
        """
        Matches(StepData_SelectMember self, Standard_CString const name) -> Standard_Boolean

        Tells if the name of a SelectMember matches a given one
        By default, compares the strings, can be redefined (optimised)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_SelectMember_Matches(self, *args)


    def Kind(self, *args):
        """
        Kind(StepData_SelectMember self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_SelectMember_Kind(self, *args)


    def SetKind(self, *args):
        """
        SetKind(StepData_SelectMember self, Standard_Integer const kind)

        :type kind: int

        """
        return _StepData.StepData_SelectMember_SetKind(self, *args)


    def ParamType(self, *args):
        """
        ParamType(StepData_SelectMember self) -> Interface_ParamType

        Returns the Kind of the SelectMember, under the form of an
        enum ParamType

        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _StepData.StepData_SelectMember_ParamType(self, *args)


    def Int(self, *args):
        """
        Int(StepData_SelectMember self) -> Standard_Integer

        This internal method gives access to a value implemented by an
        Integer (to read it)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_SelectMember_Int(self, *args)


    def SetInt(self, *args):
        """
        SetInt(StepData_SelectMember self, Standard_Integer const val)

        This internal method gives access to a value implemented by an
        Integer (to set it)

        :type val: int

        """
        return _StepData.StepData_SelectMember_SetInt(self, *args)


    def Integer(self, *args):
        """
        Integer(StepData_SelectMember self) -> Standard_Integer

        Gets the value as an Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_SelectMember_Integer(self, *args)


    def SetInteger(self, *args):
        """
        SetInteger(StepData_SelectMember self, Standard_Integer const val)

        :type val: int

        """
        return _StepData.StepData_SelectMember_SetInteger(self, *args)


    def Boolean(self, *args):
        """
        Boolean(StepData_SelectMember self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_SelectMember_Boolean(self, *args)


    def SetBoolean(self, *args):
        """
        SetBoolean(StepData_SelectMember self, Standard_Boolean const val)

        :type val: bool

        """
        return _StepData.StepData_SelectMember_SetBoolean(self, *args)


    def Logical(self, *args):
        """
        Logical(StepData_SelectMember self) -> StepData_Logical

        :rtype: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepData.StepData_SelectMember_Logical(self, *args)


    def SetLogical(self, *args):
        """
        SetLogical(StepData_SelectMember self, StepData_Logical const val)

        :type val: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepData.StepData_SelectMember_SetLogical(self, *args)


    def Real(self, *args):
        """
        Real(StepData_SelectMember self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepData.StepData_SelectMember_Real(self, *args)


    def SetReal(self, *args):
        """
        SetReal(StepData_SelectMember self, Standard_Real const val)

        :type val: float

        """
        return _StepData.StepData_SelectMember_SetReal(self, *args)


    def String(self, *args):
        """
        String(StepData_SelectMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_SelectMember_String(self, *args)


    def SetString(self, *args):
        """
        SetString(StepData_SelectMember self, Standard_CString const val)

        :type val: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_SelectMember_SetString(self, *args)


    def Enum(self, *args):
        """
        Enum(StepData_SelectMember self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_SelectMember_Enum(self, *args)


    def EnumText(self, *args):
        """
        EnumText(StepData_SelectMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_SelectMember_EnumText(self, *args)


    def SetEnum(self, *args):
        """
        SetEnum(StepData_SelectMember self, Standard_Integer const val, Standard_CString const text)

        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_SelectMember_SetEnum(self, *args)


    def SetEnumText(self, *args):
        """
        SetEnumText(StepData_SelectMember self, Standard_Integer const val, Standard_CString const text)

        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_SelectMember_SetEnumText(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_SelectMember_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_SelectMember_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_SelectMember_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_SelectMember
StepData_SelectMember_swigregister = _StepData.StepData_SelectMember_swigregister
StepData_SelectMember_swigregister(StepData_SelectMember)

def StepData_SelectMember_get_type_name(*args):
    """
    StepData_SelectMember_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_SelectMember_get_type_name(*args)

def StepData_SelectMember_get_type_descriptor(*args):
    """
    StepData_SelectMember_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_SelectMember_get_type_descriptor(*args)

class StepData_Simple(StepData_Described):
    """
    A Simple Entity is defined by a type (which can heve super
    types) and a list of parameters
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_Simple
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_Simple(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepData_Simple self, Handle_StepData_ESDescr descr) -> StepData_Simple

        Creates a Simple Entity

        :type descr: OCC.wrapper.StepData.Handle_StepData_ESDescr

        """
        this = _StepData.new_StepData_Simple(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ESDescr(self, *args):
        """
        ESDescr(StepData_Simple self) -> Handle_StepData_ESDescr

        Returns description, as for simple

        :rtype: OCC.wrapper.StepData.Handle_StepData_ESDescr

        """
        return _StepData.StepData_Simple_ESDescr(self, *args)


    def StepType(self, *args):
        """
        StepType(StepData_Simple self) -> Standard_CString

        Returns the recorded StepType (TypeName of its ESDescr)

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_Simple_StepType(self, *args)


    def IsComplex(self, *args):
        """
        IsComplex(StepData_Simple self) -> Standard_Boolean

        Returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_Simple_IsComplex(self, *args)


    def Matches(self, *args):
        """
        Matches(StepData_Simple self, Standard_CString const steptype) -> Standard_Boolean

        Tells if a step type is matched by <me>
        For a Simple Entity : own type or super type
        For a Complex Entity : one of the members

        :type steptype: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_Simple_Matches(self, *args)


    def As(self, *args):
        """
        As(StepData_Simple self, Standard_CString const steptype) -> Handle_StepData_Simple

        Returns a Simple Entity which matches with a Type in <me> :
        For a Simple Entity : me if it matches, else a null handle
        For a Complex Entity : the member which matches, else null

        :type steptype: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.StepData.Handle_StepData_Simple

        """
        return _StepData.StepData_Simple_As(self, *args)


    def HasField(self, *args):
        """
        HasField(StepData_Simple self, Standard_CString const name) -> Standard_Boolean

        Tells if a Field brings a given name

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_Simple_HasField(self, *args)


    def Field(self, *args):
        """
        Returns a Field from its name; read-only

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        res = _StepData.StepData_Simple_Field(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CField(self, *args):
        """
        CField(StepData_Simple self, Standard_CString const name) -> StepData_Field

        Returns a Field from its name; read or write

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        return _StepData.StepData_Simple_CField(self, *args)


    def NbFields(self, *args):
        """
        NbFields(StepData_Simple self) -> Standard_Integer

        Returns the count of fields

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_Simple_NbFields(self, *args)


    def FieldNum(self, *args):
        """
        Returns a field from its rank, for read-only use

        :type num: int
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        res = _StepData.StepData_Simple_FieldNum(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CFieldNum(self, *args):
        """
        CFieldNum(StepData_Simple self, Standard_Integer const num) -> StepData_Field

        Returns a field from its rank, in order to modify it

        :type num: int
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        return _StepData.StepData_Simple_CFieldNum(self, *args)


    def Fields(self, *args):
        """
        Returns the entire field list, read-only

        :rtype: OCC.wrapper.StepData.StepData_FieldListN

        """
        res = _StepData.StepData_Simple_Fields(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CFields(self, *args):
        """
        CFields(StepData_Simple self) -> StepData_FieldListN

        Returns the entire field list, read or write

        :rtype: OCC.wrapper.StepData.StepData_FieldListN

        """
        return _StepData.StepData_Simple_CFields(self, *args)


    def Check(self, *args):
        """
        Check(StepData_Simple self, Handle_Interface_Check ach)

        Fills a Check by using its Description

        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _StepData.StepData_Simple_Check(self, *args)


    def Shared(self, *args):
        """
        Shared(StepData_Simple self, Interface_EntityIterator list)

        Fills an EntityIterator with entities shared by <me>

        :type list: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.StepData_Simple_Shared(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_Simple_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_Simple_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_Simple_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_Simple
StepData_Simple_swigregister = _StepData.StepData_Simple_swigregister
StepData_Simple_swigregister(StepData_Simple)

def StepData_Simple_get_type_name(*args):
    """
    StepData_Simple_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_Simple_get_type_name(*args)

def StepData_Simple_get_type_descriptor(*args):
    """
    StepData_Simple_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_Simple_get_type_descriptor(*args)

class StepData_DescrGeneral(StepData_GeneralModule):
    """Works with a Protocol by considering its entity descriptions"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_DescrGeneral
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_DescrGeneral(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepData_DescrGeneral self, Handle_StepData_Protocol proto) -> StepData_DescrGeneral

        :type proto: OCC.wrapper.StepData.Handle_StepData_Protocol

        """
        this = _StepData.new_StepData_DescrGeneral(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def FillSharedCase(self, *args):
        """
        FillSharedCase(StepData_DescrGeneral self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.StepData_DescrGeneral_FillSharedCase(self, *args)


    def CheckCase(self, *args):
        """
        CheckCase(StepData_DescrGeneral self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_ShareTool shares, Handle_Interface_Check ach)

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type shares: OCC.wrapper.Interface.Interface_ShareTool
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _StepData.StepData_DescrGeneral_CheckCase(self, *args)


    def CopyCase(self, *args):
        """
        CopyCase(StepData_DescrGeneral self, Standard_Integer const CN, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC)

        :type CN: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _StepData.StepData_DescrGeneral_CopyCase(self, *args)


    def NewVoid(self, *args):
        """
        NewVoid(StepData_DescrGeneral self, Standard_Integer const CN, Handle_Standard_Transient ent) -> Standard_Boolean

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_DescrGeneral_NewVoid(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_DescrGeneral_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_DescrGeneral_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_DescrGeneral_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_DescrGeneral
StepData_DescrGeneral_swigregister = _StepData.StepData_DescrGeneral_swigregister
StepData_DescrGeneral_swigregister(StepData_DescrGeneral)

def StepData_DescrGeneral_get_type_name(*args):
    """
    StepData_DescrGeneral_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_DescrGeneral_get_type_name(*args)

def StepData_DescrGeneral_get_type_descriptor(*args):
    """
    StepData_DescrGeneral_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_DescrGeneral_get_type_descriptor(*args)

class StepData_FreeFormEntity(Standard.Standard_Transient):
    """
    A Free Form Entity allows to record any kind of STEP
    parameters, in any way of typing
    It is implemented with an array of fields
    A Complex entity can be defined, as a chain of FreeFormEntity
    (see Next and As)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_FreeFormEntity
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_FreeFormEntity(self) 
            return h


    def SetStepType(self, *args):
        """
        SetStepType(StepData_FreeFormEntity self, Standard_CString const typenam)

        Sets the type of an entity
        For a complex one, the type of this member

        :type typenam: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_FreeFormEntity_SetStepType(self, *args)


    def StepType(self, *args):
        """
        StepType(StepData_FreeFormEntity self) -> Standard_CString

        Returns the recorded StepType
        For a complex one, the type of this member

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_FreeFormEntity_StepType(self, *args)


    def SetNext(self, *args):
        """
        SetNext(StepData_FreeFormEntity self, Handle_StepData_FreeFormEntity next, Standard_Boolean const last)

        Sets a next member, in order to define or complete a Complex
        entity
        If <last> is True (D), this next will be set as last of list
        Else, it is inserted just as next of <me>
        If <next> is Null, Next is cleared

        :type next: OCC.wrapper.StepData.Handle_StepData_FreeFormEntity
        :type last: bool

        """
        return _StepData.StepData_FreeFormEntity_SetNext(self, *args)


    def Next(self, *args):
        """
        Next(StepData_FreeFormEntity self) -> Handle_StepData_FreeFormEntity

        Returns the next member of a Complex entity
        (remark : the last member has none)

        :rtype: OCC.wrapper.StepData.Handle_StepData_FreeFormEntity

        """
        return _StepData.StepData_FreeFormEntity_Next(self, *args)


    def IsComplex(self, *args):
        """
        IsComplex(StepData_FreeFormEntity self) -> Standard_Boolean

        Returns True if a FreeFormEntity is Complex (i.e. has Next)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_FreeFormEntity_IsComplex(self, *args)


    def Typed(self, *args):
        """
        Typed(StepData_FreeFormEntity self, Standard_CString const typenam) -> Handle_StepData_FreeFormEntity

        Returns the member of a FreeFormEntity of which the type name
        is given (exact match, no sub-type)

        :type typenam: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.StepData.Handle_StepData_FreeFormEntity

        """
        return _StepData.StepData_FreeFormEntity_Typed(self, *args)


    def TypeList(self, *args):
        """
        TypeList(StepData_FreeFormEntity self) -> Handle_TColStd_HSequenceOfAsciiString

        Returns the list of types (one type for a simple entity),
        as is (non reordered)

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _StepData.StepData_FreeFormEntity_TypeList(self, *args)


    def Reorder(*args):
        """
        Reorder(Handle_StepData_FreeFormEntity ent) -> Standard_Boolean

        Reorders a Complex entity if required, i.e. if member types
        are not in alphabetic order
        Returns False if nothing done (order was OK or simple entity),
        True plus modified <ent> if <ent> has been reordered

        :type ent: OCC.wrapper.StepData.Handle_StepData_FreeFormEntity
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_FreeFormEntity_Reorder(*args)

    Reorder = staticmethod(Reorder)

    def SetNbFields(self, *args):
        """
        SetNbFields(StepData_FreeFormEntity self, Standard_Integer const nb)

        Sets a count of Fields, from scratch

        :type nb: int

        """
        return _StepData.StepData_FreeFormEntity_SetNbFields(self, *args)


    def NbFields(self, *args):
        """
        NbFields(StepData_FreeFormEntity self) -> Standard_Integer

        Returns the count of fields

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_FreeFormEntity_NbFields(self, *args)


    def Field(self, *args):
        """
        Returns a field from its rank, for read-only use

        :type num: int
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        res = _StepData.StepData_FreeFormEntity_Field(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CField(self, *args):
        """
        CField(StepData_FreeFormEntity self, Standard_Integer const num) -> StepData_Field

        Returns a field from its rank, in order to modify it

        :type num: int
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        return _StepData.StepData_FreeFormEntity_CField(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_FreeFormEntity_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_FreeFormEntity_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_FreeFormEntity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_FreeFormEntity
StepData_FreeFormEntity_swigregister = _StepData.StepData_FreeFormEntity_swigregister
StepData_FreeFormEntity_swigregister(StepData_FreeFormEntity)

def StepData_FreeFormEntity_Reorder(*args):
    """
    StepData_FreeFormEntity_Reorder(Handle_StepData_FreeFormEntity ent) -> Standard_Boolean

    Reorders a Complex entity if required, i.e. if member types
    are not in alphabetic order
    Returns False if nothing done (order was OK or simple entity),
    True plus modified <ent> if <ent> has been reordered

    :type ent: OCC.wrapper.StepData.Handle_StepData_FreeFormEntity
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _StepData.StepData_FreeFormEntity_Reorder(*args)

def StepData_FreeFormEntity_get_type_name(*args):
    """
    StepData_FreeFormEntity_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_FreeFormEntity_get_type_name(*args)

def StepData_FreeFormEntity_get_type_descriptor(*args):
    """
    StepData_FreeFormEntity_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_FreeFormEntity_get_type_descriptor(*args)

class StepData_SelectNamed(StepData_SelectMember):
    """
    This select member can be of any kind, and be named
    But its takes more memory than some specialised ones
    This class allows one name for the instance
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_SelectNamed
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_SelectNamed(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepData_SelectNamed self) -> StepData_SelectNamed

        This select member can be of any kind, and be named
        But its takes more memory than some specialised ones
        This class allows one name for the instance
        """
        this = _StepData.new_StepData_SelectNamed(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def HasName(self, *args):
        """
        HasName(StepData_SelectNamed self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_SelectNamed_HasName(self, *args)


    def Name(self, *args):
        """
        Name(StepData_SelectNamed self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_SelectNamed_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepData_SelectNamed self, Standard_CString const name) -> Standard_Boolean

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_SelectNamed_SetName(self, *args)


    def Field(self, *args):
        """
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        res = _StepData.StepData_SelectNamed_Field(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CField(self, *args):
        """
        CField(StepData_SelectNamed self) -> StepData_Field

        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        return _StepData.StepData_SelectNamed_CField(self, *args)


    def Kind(self, *args):
        """
        Kind(StepData_SelectNamed self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_SelectNamed_Kind(self, *args)


    def SetKind(self, *args):
        """
        SetKind(StepData_SelectNamed self, Standard_Integer const kind)

        :type kind: int

        """
        return _StepData.StepData_SelectNamed_SetKind(self, *args)


    def Int(self, *args):
        """
        Int(StepData_SelectNamed self) -> Standard_Integer

        This internal method gives access to a value implemented by an
        Integer (to read it)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_SelectNamed_Int(self, *args)


    def SetInt(self, *args):
        """
        SetInt(StepData_SelectNamed self, Standard_Integer const val)

        This internal method gives access to a value implemented by an
        Integer (to set it)

        :type val: int

        """
        return _StepData.StepData_SelectNamed_SetInt(self, *args)


    def Real(self, *args):
        """
        Real(StepData_SelectNamed self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepData.StepData_SelectNamed_Real(self, *args)


    def SetReal(self, *args):
        """
        SetReal(StepData_SelectNamed self, Standard_Real const val)

        :type val: float

        """
        return _StepData.StepData_SelectNamed_SetReal(self, *args)


    def String(self, *args):
        """
        String(StepData_SelectNamed self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_SelectNamed_String(self, *args)


    def SetString(self, *args):
        """
        SetString(StepData_SelectNamed self, Standard_CString const val)

        :type val: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_SelectNamed_SetString(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_SelectNamed_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_SelectNamed_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_SelectNamed_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_SelectNamed
StepData_SelectNamed_swigregister = _StepData.StepData_SelectNamed_swigregister
StepData_SelectNamed_swigregister(StepData_SelectNamed)

def StepData_SelectNamed_get_type_name(*args):
    """
    StepData_SelectNamed_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_SelectNamed_get_type_name(*args)

def StepData_SelectNamed_get_type_descriptor(*args):
    """
    StepData_SelectNamed_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_SelectNamed_get_type_descriptor(*args)

class StepData_ReadWriteModule(Interface.Interface_ReaderModule):
    """
    Defines basic File Access Module (Recognize, Read, Write)
    That is : ReaderModule (Recognize & Read) + Write for
    StepWriter (for a more centralized description)
    Warning : A sub-class of ReadWriteModule, which belongs to a particular
    Protocol, must use the same definition for Case Numbers (give
    the same Value for a StepType defined as a String from a File
    as the Protocol does for the corresponding Entity)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_ReadWriteModule
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_ReadWriteModule(self) 
            return h


    def CaseNum(self, *args):
        """
        CaseNum(StepData_ReadWriteModule self, Handle_Interface_FileReaderData data, Standard_Integer const num) -> Standard_Integer

        Translate the Type of record <num> in <data> to a positive
        Case Number, or 0 if failed.
        Works with a StepReaderData, in which the Type of an Entity
        is defined as a String : Reads the RecordType <num> then calls
        CaseNum (this type)
        Warning : The methods CaseStep, StepType and Recognize,
        must be in phase (triplets CaseNum-StepType-Type of Object)

        :type data: OCC.wrapper.Interface.Handle_Interface_FileReaderData
        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_ReadWriteModule_CaseNum(self, *args)


    def CaseStep(self, *args):
        """
        CaseStep(StepData_ReadWriteModule self, TCollection_AsciiString atype) -> Standard_Integer
        CaseStep(StepData_ReadWriteModule self, NCollection_Sequence_TCollection_AsciiString types) -> Standard_Integer

        Same a above but for a Complex Type Entity ("Plex")
        The provided Default recognizes nothing

        :type types: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_ReadWriteModule_CaseStep(self, *args)


    def IsComplex(self, *args):
        """
        IsComplex(StepData_ReadWriteModule self, Standard_Integer const CN) -> Standard_Boolean

        Returns True if the Case Number corresponds to a Complex Type
        ("Plex"). Remember that all possible combinations must be
        aknowledged to be processed
        Default is False for all cases. For a Protocol which defines
        possible Plexes, this method must be redefined.

        :type CN: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_ReadWriteModule_IsComplex(self, *args)


    def StepType(self, *args):
        """
        Function specific to STEP, which delivers the StepType as it
        is recorded in and read from a File compliant with STEP.
        This method is symmetric to the method CaseStep.
        StepType can be different from Dynamic Type's name, but
        belongs to the same class of Object.
        Returns an empty String if <CN> is zero.
        Warning : For a Complex Type Entity, returns an Empty String
        (Complex Type must be managed by users)

        :type CN: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _StepData.StepData_ReadWriteModule_StepType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ShortType(self, *args):
        """
        ShortType(StepData_ReadWriteModule self, Standard_Integer const CN) -> TCollection_AsciiString

        Function specific to STEP. Some STEP Types have a short form
        This method can be redefined to fill it
        By default, returns an empty string, which is then interpreted
        to take normal form from StepType

        :type CN: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _StepData.StepData_ReadWriteModule_ShortType(self, *args)


    def ComplexType(self, *args):
        """
        ComplexType(StepData_ReadWriteModule self, Standard_Integer const CN, NCollection_Sequence_TCollection_AsciiString types) -> Standard_Boolean

        Function specific to STEP, which delivers the list of types
        which corresponds to a complex type. If <CN> is not for a
        complex type, this method returns False. Else it returns True
        and fills the list in alphabetic order.
        The default returns False. To be redefined as required.

        :type CN: int
        :type types: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_ReadWriteModule_ComplexType(self, *args)


    def Read(self, *args):
        """
        Read(StepData_ReadWriteModule self, Standard_Integer const CN, Handle_Interface_FileReaderData data, Standard_Integer const num, Handle_Interface_Check ach, Handle_Standard_Transient ent)

        General Read Function, calls ReadStep

        :type CN: int
        :type data: OCC.wrapper.Interface.Handle_Interface_FileReaderData
        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.StepData_ReadWriteModule_Read(self, *args)


    def ReadStep(self, *args):
        """
        ReadStep(StepData_ReadWriteModule self, Standard_Integer const CN, Handle_StepData_StepReaderData data, Standard_Integer const num, Handle_Interface_Check ach, Handle_Standard_Transient ent)

        Specific Read Function. Works with StepReaderData

        :type CN: int
        :type data: OCC.wrapper.StepData.Handle_StepData_StepReaderData
        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.StepData_ReadWriteModule_ReadStep(self, *args)


    def WriteStep(self, *args):
        """
        WriteStep(StepData_ReadWriteModule self, Standard_Integer const CN, StepData_StepWriter SW, Handle_Standard_Transient ent)

        Write Function, switched by CaseNum

        :type CN: int
        :type SW: OCC.wrapper.StepData.StepData_StepWriter
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.StepData_ReadWriteModule_WriteStep(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_ReadWriteModule_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_ReadWriteModule_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_ReadWriteModule_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_ReadWriteModule
StepData_ReadWriteModule_swigregister = _StepData.StepData_ReadWriteModule_swigregister
StepData_ReadWriteModule_swigregister(StepData_ReadWriteModule)

def StepData_ReadWriteModule_get_type_name(*args):
    """
    StepData_ReadWriteModule_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_ReadWriteModule_get_type_name(*args)

def StepData_ReadWriteModule_get_type_descriptor(*args):
    """
    StepData_ReadWriteModule_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_ReadWriteModule_get_type_descriptor(*args)

class StepData_Plex(StepData_Described):
    """
    A Plex (for Complex) Entity is defined as a list of Simple
    Members ("external mapping")
    The types of these members must be in alphabetic order
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_Plex
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_Plex(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepData_Plex self, Handle_StepData_ECDescr descr) -> StepData_Plex

        Creates a Plex (empty). The complete creation is made by the
        ECDescr itself, by calling Add

        :type descr: OCC.wrapper.StepData.Handle_StepData_ECDescr

        """
        this = _StepData.new_StepData_Plex(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Add(self, *args):
        """
        Add(StepData_Plex self, Handle_StepData_Simple member)

        Adds a member to <me>

        :type member: OCC.wrapper.StepData.Handle_StepData_Simple

        """
        return _StepData.StepData_Plex_Add(self, *args)


    def ECDescr(self, *args):
        """
        ECDescr(StepData_Plex self) -> Handle_StepData_ECDescr

        Returns the Description as for a Plex

        :rtype: OCC.wrapper.StepData.Handle_StepData_ECDescr

        """
        return _StepData.StepData_Plex_ECDescr(self, *args)


    def IsComplex(self, *args):
        """
        IsComplex(StepData_Plex self) -> Standard_Boolean

        Returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_Plex_IsComplex(self, *args)


    def Matches(self, *args):
        """
        Matches(StepData_Plex self, Standard_CString const steptype) -> Standard_Boolean

        Tells if a step type is matched by <me>
        For a Simple Entity : own type or super type
        For a Complex Entity : one of the members

        :type steptype: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_Plex_Matches(self, *args)


    def As(self, *args):
        """
        As(StepData_Plex self, Standard_CString const steptype) -> Handle_StepData_Simple

        Returns a Simple Entity which matches with a Type in <me> :
        For a Simple Entity : me if it matches, else a null handle
        For a Complex Entity : the member which matches, else null

        :type steptype: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.StepData.Handle_StepData_Simple

        """
        return _StepData.StepData_Plex_As(self, *args)


    def HasField(self, *args):
        """
        HasField(StepData_Plex self, Standard_CString const name) -> Standard_Boolean

        Tells if a Field brings a given name

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_Plex_HasField(self, *args)


    def Field(self, *args):
        """
        Returns a Field from its name; read-only

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        res = _StepData.StepData_Plex_Field(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CField(self, *args):
        """
        CField(StepData_Plex self, Standard_CString const name) -> StepData_Field

        Returns a Field from its name; read or write

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        return _StepData.StepData_Plex_CField(self, *args)


    def NbMembers(self, *args):
        """
        NbMembers(StepData_Plex self) -> Standard_Integer

        Returns the count of simple members

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_Plex_NbMembers(self, *args)


    def Member(self, *args):
        """
        Member(StepData_Plex self, Standard_Integer const num) -> Handle_StepData_Simple

        Returns a simple member from its rank

        :type num: int
        :rtype: OCC.wrapper.StepData.Handle_StepData_Simple

        """
        return _StepData.StepData_Plex_Member(self, *args)


    def TypeList(self, *args):
        """
        TypeList(StepData_Plex self) -> Handle_TColStd_HSequenceOfAsciiString

        Returns the actual list of members types

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _StepData.StepData_Plex_TypeList(self, *args)


    def Check(self, *args):
        """
        Check(StepData_Plex self, Handle_Interface_Check ach)

        Fills a Check by using its Description

        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _StepData.StepData_Plex_Check(self, *args)


    def Shared(self, *args):
        """
        Shared(StepData_Plex self, Interface_EntityIterator list)

        Fills an EntityIterator with entities shared by <me>

        :type list: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.StepData_Plex_Shared(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_Plex_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_Plex_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_Plex_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_Plex
StepData_Plex_swigregister = _StepData.StepData_Plex_swigregister
StepData_Plex_swigregister(StepData_Plex)

def StepData_Plex_get_type_name(*args):
    """
    StepData_Plex_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_Plex_get_type_name(*args)

def StepData_Plex_get_type_descriptor(*args):
    """
    StepData_Plex_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_Plex_get_type_descriptor(*args)

class StepData_Field(object):
    """
    Defines a generally defined Field for STEP data : can be used
    either in any kind of entity to implement it or in free format
    entities in a "late-binding" mode
    A field can have : no value (or derived), a single value of
    any kind, a list of value : single or double list

    When a field is set, this defines its new kind (Integer etc..)
    A single value is immediately set. A list of value is, firstly
    declared as for a kind (Integer String etc), then declared as
    a list with its initial size, after this its items are set
    Also it can be set in once if the HArray is ready
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepData_Field self) -> StepData_Field
        __init__(StepData_Field self, StepData_Field other, Standard_Boolean const copy) -> StepData_Field

        Creates a Field from another one. If <copy> is True, Handled
        data (Select,String,List, not entities) are copied

        :type other: OCC.wrapper.StepData.StepData_Field
        :type copy: bool

        """
        this = _StepData.new_StepData_Field(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CopyFrom(self, *args):
        """
        CopyFrom(StepData_Field self, StepData_Field other)

        Gets the copy of the values of another field

        :type other: OCC.wrapper.StepData.StepData_Field

        """
        return _StepData.StepData_Field_CopyFrom(self, *args)


    def Clear(self, *args):
        """
        Clear(StepData_Field self, Standard_Integer const kind=0)

        Clears the field, to set it as "no value defined"
        Just before SetList, predeclares it as "any"
        A Kind can be directly set here to declare a type

        :type kind: int

        """
        return _StepData.StepData_Field_Clear(self, *args)


    def SetDerived(self, *args):
        """
        SetDerived(StepData_Field self)

        Codes a Field as derived (no proper value)


        """
        return _StepData.StepData_Field_SetDerived(self, *args)


    def SetSelectMember(self, *args):
        """
        SetSelectMember(StepData_Field self, Handle_StepData_SelectMember val)

        Sets a SelectMember (for Integer,Boolean,Enum,Real,Logical)
        Hence, the value of the field is accessed through this member

        :type val: OCC.wrapper.StepData.Handle_StepData_SelectMember

        """
        return _StepData.StepData_Field_SetSelectMember(self, *args)


    def SetList(self, *args):
        """
        SetList(StepData_Field self, Standard_Integer const size, Standard_Integer const first=1)

        Declares a field as a list, with an initial size
        Initial lower is defaulted as 1, can be defined
        The list starts empty, typed by the last Set*
        If no Set* before, sets it as "any" (transient/select)

        :type size: int
        :type first: int

        """
        return _StepData.StepData_Field_SetList(self, *args)


    def SetList2(self, *args):
        """
        SetList2(StepData_Field self, Standard_Integer const siz1, Standard_Integer const siz2, Standard_Integer const f1=1, Standard_Integer const f2=1)

        Declares a field as an homogeneous square list, with initial
        sizes, and initial lowers

        :type siz1: int
        :type siz2: int
        :type f1: int
        :type f2: int

        """
        return _StepData.StepData_Field_SetList2(self, *args)


    def Set(self, *args):
        """
        Set(StepData_Field self, Handle_Standard_Transient val)

        Sets an undetermined value : can be String, SelectMember,
        HArray(1-2) ... else, an Entity
        In case of an HArray, determines and records its size(s)

        :type val: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.StepData_Field_Set(self, *args)


    def ClearItem(self, *args):
        """
        ClearItem(StepData_Field self, Standard_Integer const num)

        Declares an item of the list as undefined
        (ignored if list not defined as String,Entity or Any)

        :type num: int

        """
        return _StepData.StepData_Field_ClearItem(self, *args)


    def SetInt(self, *args):
        """
        SetInt(StepData_Field self, Standard_Integer const val)
        SetInt(StepData_Field self, Standard_Integer const num, Standard_Integer const val, Standard_Integer const kind)

        Internal access to an Integer Value for a list, plus its kind

        :type num: int
        :type val: int
        :type kind: int

        """
        return _StepData.StepData_Field_SetInt(self, *args)


    def SetInteger(self, *args):
        """
        SetInteger(StepData_Field self, Standard_Integer const val=0)
        SetInteger(StepData_Field self, Standard_Integer const num, Standard_Integer const val)

        Sets an Integer Value for a list (rank num)
        (recognizes a SelectMember)

        :type num: int
        :type val: int

        """
        return _StepData.StepData_Field_SetInteger(self, *args)


    def SetBoolean(self, *args):
        """
        SetBoolean(StepData_Field self, Standard_Boolean const val)
        SetBoolean(StepData_Field self, Standard_Integer const num, Standard_Boolean const val)

        :type num: int
        :type val: bool

        """
        return _StepData.StepData_Field_SetBoolean(self, *args)


    def SetLogical(self, *args):
        """
        SetLogical(StepData_Field self, StepData_Logical const val=StepData_LFalse)
        SetLogical(StepData_Field self, Standard_Integer const num, StepData_Logical const val)

        :type num: int
        :type val: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepData.StepData_Field_SetLogical(self, *args)


    def SetEnum(self, *args):
        """
        SetEnum(StepData_Field self, Standard_Integer const val=-1, Standard_CString const text)
        SetEnum(StepData_Field self, Standard_Integer const num, Standard_Integer const val, Standard_CString const text)

        Sets an Enum Value (Integer counterpart), also its text
        expression if known (if list has been set as "any")

        :type num: int
        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_Field_SetEnum(self, *args)


    def SetReal(self, *args):
        """
        SetReal(StepData_Field self, Standard_Real const val=0.0)
        SetReal(StepData_Field self, Standard_Integer const num, Standard_Real const val)

        :type num: int
        :type val: float

        """
        return _StepData.StepData_Field_SetReal(self, *args)


    def SetString(self, *args):
        """
        SetString(StepData_Field self, Standard_CString const val)
        SetString(StepData_Field self, Standard_Integer const num, Standard_CString const val)

        :type num: int
        :type val: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_Field_SetString(self, *args)


    def SetEntity(self, *args):
        """
        SetEntity(StepData_Field self, Handle_Standard_Transient val)
        SetEntity(StepData_Field self)
        SetEntity(StepData_Field self, Standard_Integer const num, Handle_Standard_Transient val)

        :type num: int
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.StepData_Field_SetEntity(self, *args)


    def IsSet(self, *args):
        """
        IsSet(StepData_Field self, Standard_Integer const n1=1, Standard_Integer const n2=1) -> Standard_Boolean

        :type n1: int
        :type n2: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_Field_IsSet(self, *args)


    def ItemKind(self, *args):
        """
        ItemKind(StepData_Field self, Standard_Integer const n1=1, Standard_Integer const n2=1) -> Standard_Integer

        Returns the kind of an item in a list or double list
        It is the kind of the list, except if it is "Any", in such a
        case the true kind is determined and returned

        :type n1: int
        :type n2: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_Field_ItemKind(self, *args)


    def Kind(self, *args):
        """
        Kind(StepData_Field self, Standard_Boolean const type) -> Standard_Integer

        Returns the kind of the field
        <type> True (D) : returns only the type itself
        else, returns the complete kind

        :type type: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_Field_Kind(self, *args)


    def Arity(self, *args):
        """
        Arity(StepData_Field self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_Field_Arity(self, *args)


    def Length(self, *args):
        """
        Length(StepData_Field self, Standard_Integer const index=1) -> Standard_Integer

        :type index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_Field_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(StepData_Field self, Standard_Integer const index=1) -> Standard_Integer

        :type index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_Field_Lower(self, *args)


    def Int(self, *args):
        """
        Int(StepData_Field self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_Field_Int(self, *args)


    def Integer(self, *args):
        """
        Integer(StepData_Field self, Standard_Integer const n1=1, Standard_Integer const n2=1) -> Standard_Integer

        :type n1: int
        :type n2: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_Field_Integer(self, *args)


    def Boolean(self, *args):
        """
        Boolean(StepData_Field self, Standard_Integer const n1=1, Standard_Integer const n2=1) -> Standard_Boolean

        :type n1: int
        :type n2: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_Field_Boolean(self, *args)


    def Logical(self, *args):
        """
        Logical(StepData_Field self, Standard_Integer const n1=1, Standard_Integer const n2=1) -> StepData_Logical

        :type n1: int
        :type n2: int
        :rtype: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepData.StepData_Field_Logical(self, *args)


    def Real(self, *args):
        """
        Real(StepData_Field self, Standard_Integer const n1=1, Standard_Integer const n2=1) -> Standard_Real

        :type n1: int
        :type n2: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepData.StepData_Field_Real(self, *args)


    def String(self, *args):
        """
        String(StepData_Field self, Standard_Integer const n1=1, Standard_Integer const n2=1) -> Standard_CString

        :type n1: int
        :type n2: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_Field_String(self, *args)


    def Enum(self, *args):
        """
        Enum(StepData_Field self, Standard_Integer const n1=1, Standard_Integer const n2=1) -> Standard_Integer

        :type n1: int
        :type n2: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_Field_Enum(self, *args)


    def EnumText(self, *args):
        """
        EnumText(StepData_Field self, Standard_Integer const n1=1, Standard_Integer const n2=1) -> Standard_CString

        :type n1: int
        :type n2: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_Field_EnumText(self, *args)


    def Entity(self, *args):
        """
        Entity(StepData_Field self, Standard_Integer const n1=1, Standard_Integer const n2=1) -> Handle_Standard_Transient

        :type n1: int
        :type n2: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.StepData_Field_Entity(self, *args)


    def Transient(self, *args):
        """
        Transient(StepData_Field self) -> Handle_Standard_Transient

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.StepData_Field_Transient(self, *args)

    __swig_destroy__ = _StepData.delete_StepData_Field
StepData_Field_swigregister = _StepData.StepData_Field_swigregister
StepData_Field_swigregister(StepData_Field)

class StepData_HArray1OfField(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_HArray1OfField
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_HArray1OfField(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepData_HArray1OfField self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepData_HArray1OfField
        __init__(StepData_HArray1OfField self, Standard_Integer const theLower, Standard_Integer const theUpper, StepData_Field theValue) -> StepData_HArray1OfField
        __init__(StepData_HArray1OfField self, NCollection_Array1_StepData_Field theOther) -> StepData_HArray1OfField

        :type theOther: OCC.wrapper.StepData.StepData_Array1OfField

        """
        this = _StepData.new_StepData_HArray1OfField(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepData.StepData_Array1OfField

        """
        res = _StepData.StepData_HArray1OfField_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepData_HArray1OfField self) -> NCollection_Array1_StepData_Field

        :rtype: OCC.wrapper.StepData.StepData_Array1OfField

        """
        return _StepData.StepData_HArray1OfField_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_HArray1OfField_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_HArray1OfField_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_HArray1OfField_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_HArray1OfField
StepData_HArray1OfField_swigregister = _StepData.StepData_HArray1OfField_swigregister
StepData_HArray1OfField_swigregister(StepData_HArray1OfField)

def StepData_HArray1OfField_get_type_name(*args):
    """
    StepData_HArray1OfField_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_HArray1OfField_get_type_name(*args)

def StepData_HArray1OfField_get_type_descriptor(*args):
    """
    StepData_HArray1OfField_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_HArray1OfField_get_type_descriptor(*args)

class StepData_FileProtocol(StepData_Protocol):
    """
    A FileProtocol is defined as the addition of several already
    existing Protocols. It corresponds to the definition of a
    SchemaName with several Names, each one being attached to a
    specific Protocol. Thus, a File defined with a compound Schema
    is processed as any other one, once built the equivalent
    compound Protocol, a FileProtocol
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_FileProtocol
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_FileProtocol(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepData_FileProtocol self) -> StepData_FileProtocol

        Creates an empty FileProtocol


        """
        this = _StepData.new_StepData_FileProtocol(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Add(self, *args):
        """
        Add(StepData_FileProtocol self, Handle_StepData_Protocol protocol)

        Adds a Protocol to the definition list of the FileProtocol
        But ensures that each class of Protocol is present only once
        in this list

        :type protocol: OCC.wrapper.StepData.Handle_StepData_Protocol

        """
        return _StepData.StepData_FileProtocol_Add(self, *args)


    def NbResources(self, *args):
        """
        NbResources(StepData_FileProtocol self) -> Standard_Integer

        Gives the count of Protocols used as Resource (can be zero)
        i.e. the count of Protocol recorded by calling the method Add

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_FileProtocol_NbResources(self, *args)


    def Resource(self, *args):
        """
        Resource(StepData_FileProtocol self, Standard_Integer const num) -> Handle_Interface_Protocol

        Returns a Resource, given a rank. Here, rank of calling Add

        :type num: int
        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _StepData.StepData_FileProtocol_Resource(self, *args)


    def TypeNumber(self, *args):
        """
        TypeNumber(StepData_FileProtocol self, Handle_Standard_Type atype) -> Standard_Integer

        Returns a Case Number, specific of each recognized Type
        Here, NO Type at all is recognized properly : all Types are
        recognized by the resources

        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_FileProtocol_TypeNumber(self, *args)


    def GlobalCheck(self, *args):
        """
        GlobalCheck(StepData_FileProtocol self, Interface_Graph G, Handle_Interface_Check ach) -> Standard_Boolean

        Calls GlobalCheck for each of its recorded ressources

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_FileProtocol_GlobalCheck(self, *args)


    def SchemaName(self, *args):
        """
        SchemaName(StepData_FileProtocol self) -> Standard_CString

        Returns the Schema Name attached to each class of Protocol
        To be redefined by each sub-class
        Here, SchemaName returns "" (empty String)
        was C++ : return const

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_FileProtocol_SchemaName(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_FileProtocol_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_FileProtocol_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_FileProtocol_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_FileProtocol
StepData_FileProtocol_swigregister = _StepData.StepData_FileProtocol_swigregister
StepData_FileProtocol_swigregister(StepData_FileProtocol)

def StepData_FileProtocol_get_type_name(*args):
    """
    StepData_FileProtocol_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_FileProtocol_get_type_name(*args)

def StepData_FileProtocol_get_type_descriptor(*args):
    """
    StepData_FileProtocol_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_FileProtocol_get_type_descriptor(*args)

class StepData_DescrReadWrite(StepData_ReadWriteModule):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_DescrReadWrite
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_DescrReadWrite(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepData_DescrReadWrite self, Handle_StepData_Protocol proto) -> StepData_DescrReadWrite

        :type proto: OCC.wrapper.StepData.Handle_StepData_Protocol

        """
        this = _StepData.new_StepData_DescrReadWrite(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def CaseStep(self, *args):
        """
        CaseStep(StepData_DescrReadWrite self, TCollection_AsciiString atype) -> Standard_Integer
        CaseStep(StepData_DescrReadWrite self, NCollection_Sequence_TCollection_AsciiString types) -> Standard_Integer

        :type types: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_DescrReadWrite_CaseStep(self, *args)


    def IsComplex(self, *args):
        """
        IsComplex(StepData_DescrReadWrite self, Standard_Integer const CN) -> Standard_Boolean

        :type CN: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_DescrReadWrite_IsComplex(self, *args)


    def StepType(self, *args):
        """
        :type CN: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _StepData.StepData_DescrReadWrite_StepType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ComplexType(self, *args):
        """
        ComplexType(StepData_DescrReadWrite self, Standard_Integer const CN, NCollection_Sequence_TCollection_AsciiString types) -> Standard_Boolean

        :type CN: int
        :type types: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_DescrReadWrite_ComplexType(self, *args)


    def ReadStep(self, *args):
        """
        ReadStep(StepData_DescrReadWrite self, Standard_Integer const CN, Handle_StepData_StepReaderData data, Standard_Integer const num, Handle_Interface_Check ach, Handle_Standard_Transient ent)

        :type CN: int
        :type data: OCC.wrapper.StepData.Handle_StepData_StepReaderData
        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.StepData_DescrReadWrite_ReadStep(self, *args)


    def WriteStep(self, *args):
        """
        WriteStep(StepData_DescrReadWrite self, Standard_Integer const CN, StepData_StepWriter SW, Handle_Standard_Transient ent)

        :type CN: int
        :type SW: OCC.wrapper.StepData.StepData_StepWriter
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.StepData_DescrReadWrite_WriteStep(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_DescrReadWrite_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_DescrReadWrite_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_DescrReadWrite_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_DescrReadWrite
StepData_DescrReadWrite_swigregister = _StepData.StepData_DescrReadWrite_swigregister
StepData_DescrReadWrite_swigregister(StepData_DescrReadWrite)

def StepData_DescrReadWrite_get_type_name(*args):
    """
    StepData_DescrReadWrite_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_DescrReadWrite_get_type_name(*args)

def StepData_DescrReadWrite_get_type_descriptor(*args):
    """
    StepData_DescrReadWrite_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_DescrReadWrite_get_type_descriptor(*args)

class StepData_GlobalNodeOfWriterLib(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_GlobalNodeOfWriterLib
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_GlobalNodeOfWriterLib(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepData_GlobalNodeOfWriterLib self) -> StepData_GlobalNodeOfWriterLib

        Creates an empty GlobalNode, with no Next


        """
        this = _StepData.new_StepData_GlobalNodeOfWriterLib(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Add(self, *args):
        """
        Add(StepData_GlobalNodeOfWriterLib self, Handle_StepData_ReadWriteModule amodule, Handle_StepData_Protocol aprotocol)

        Adds a Module bound with a Protocol to the list : does
        nothing if already in the list, THAT IS, Same Type (exact
        match) and Same State (that is, IsEqual is not required)
        Once added, stores its attached Protocol in correspondance

        :type amodule: OCC.wrapper.StepData.Handle_StepData_ReadWriteModule
        :type aprotocol: OCC.wrapper.StepData.Handle_StepData_Protocol

        """
        return _StepData.StepData_GlobalNodeOfWriterLib_Add(self, *args)


    def Module(self, *args):
        """
        Returns the Module stored in a given GlobalNode

        :rtype: OCC.wrapper.StepData.Handle_StepData_ReadWriteModule

        """
        res = _StepData.StepData_GlobalNodeOfWriterLib_Module(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Protocol(self, *args):
        """
        Returns the attached Protocol stored in a given GlobalNode

        :rtype: OCC.wrapper.StepData.Handle_StepData_Protocol

        """
        res = _StepData.StepData_GlobalNodeOfWriterLib_Protocol(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Next(self, *args):
        """
        Returns the Next GlobalNode. If none is defined, returned
        value is a Null Handle

        :rtype: OCC.wrapper.StepData.Handle_StepData_GlobalNodeOfWriterLib

        """
        res = _StepData.StepData_GlobalNodeOfWriterLib_Next(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_GlobalNodeOfWriterLib_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_GlobalNodeOfWriterLib_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_GlobalNodeOfWriterLib_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_GlobalNodeOfWriterLib
StepData_GlobalNodeOfWriterLib_swigregister = _StepData.StepData_GlobalNodeOfWriterLib_swigregister
StepData_GlobalNodeOfWriterLib_swigregister(StepData_GlobalNodeOfWriterLib)

def StepData_GlobalNodeOfWriterLib_get_type_name(*args):
    """
    StepData_GlobalNodeOfWriterLib_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_GlobalNodeOfWriterLib_get_type_name(*args)

def StepData_GlobalNodeOfWriterLib_get_type_descriptor(*args):
    """
    StepData_GlobalNodeOfWriterLib_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_GlobalNodeOfWriterLib_get_type_descriptor(*args)

class StepData_EDescr(Standard.Standard_Transient):
    """
    This class is intended to describe the authorized form for an
    entity, either Simple or Plex
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_EDescr
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_EDescr(self) 
            return h


    def Matches(self, *args):
        """
        Matches(StepData_EDescr self, Standard_CString const steptype) -> Standard_Boolean

        Tells if a ESDescr matches a step type : exact or super type

        :type steptype: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_EDescr_Matches(self, *args)


    def IsComplex(self, *args):
        """
        IsComplex(StepData_EDescr self) -> Standard_Boolean

        Tells if a EDescr is complex (ECDescr) or simple (ESDescr)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_EDescr_IsComplex(self, *args)


    def NewEntity(self, *args):
        """
        NewEntity(StepData_EDescr self) -> Handle_StepData_Described

        Creates a described entity (i.e. a simple one)

        :rtype: OCC.wrapper.StepData.Handle_StepData_Described

        """
        return _StepData.StepData_EDescr_NewEntity(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_EDescr_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_EDescr_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_EDescr_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_EDescr
StepData_EDescr_swigregister = _StepData.StepData_EDescr_swigregister
StepData_EDescr_swigregister(StepData_EDescr)

def StepData_EDescr_get_type_name(*args):
    """
    StepData_EDescr_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_EDescr_get_type_name(*args)

def StepData_EDescr_get_type_descriptor(*args):
    """
    StepData_EDescr_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_EDescr_get_type_descriptor(*args)

class StepData_ECDescr(StepData_EDescr):
    """Describes a Complex Entity (Plex) as a list of Simple ones"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_ECDescr
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_ECDescr(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepData_ECDescr self) -> StepData_ECDescr

        Creates an ECDescr, empty


        """
        this = _StepData.new_StepData_ECDescr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Add(self, *args):
        """
        Add(StepData_ECDescr self, Handle_StepData_ESDescr member)

        Adds a member
        Warning : members are added in alphabetic order

        :type member: OCC.wrapper.StepData.Handle_StepData_ESDescr

        """
        return _StepData.StepData_ECDescr_Add(self, *args)


    def NbMembers(self, *args):
        """
        NbMembers(StepData_ECDescr self) -> Standard_Integer

        Returns the count of members

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_ECDescr_NbMembers(self, *args)


    def Member(self, *args):
        """
        Member(StepData_ECDescr self, Standard_Integer const num) -> Handle_StepData_ESDescr

        Returns a Member from its rank

        :type num: int
        :rtype: OCC.wrapper.StepData.Handle_StepData_ESDescr

        """
        return _StepData.StepData_ECDescr_Member(self, *args)


    def TypeList(self, *args):
        """
        TypeList(StepData_ECDescr self) -> Handle_TColStd_HSequenceOfAsciiString

        Returns the ordered list of types

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _StepData.StepData_ECDescr_TypeList(self, *args)


    def Matches(self, *args):
        """
        Matches(StepData_ECDescr self, Standard_CString const steptype) -> Standard_Boolean

        Tells if a ESDescr matches a step type : exact or super type

        :type steptype: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_ECDescr_Matches(self, *args)


    def IsComplex(self, *args):
        """
        IsComplex(StepData_ECDescr self) -> Standard_Boolean

        Returns True

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_ECDescr_IsComplex(self, *args)


    def NewEntity(self, *args):
        """
        NewEntity(StepData_ECDescr self) -> Handle_StepData_Described

        Creates a described entity (i.e. a complex one, made of one
        simple entity per member)

        :rtype: OCC.wrapper.StepData.Handle_StepData_Described

        """
        return _StepData.StepData_ECDescr_NewEntity(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_ECDescr_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_ECDescr_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_ECDescr_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_ECDescr
StepData_ECDescr_swigregister = _StepData.StepData_ECDescr_swigregister
StepData_ECDescr_swigregister(StepData_ECDescr)

def StepData_ECDescr_get_type_name(*args):
    """
    StepData_ECDescr_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_ECDescr_get_type_name(*args)

def StepData_ECDescr_get_type_descriptor(*args):
    """
    StepData_ECDescr_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_ECDescr_get_type_descriptor(*args)

class StepData_FieldList(object):
    """
    Describes a list of fields, in a general way
    This basic class is for a null size list
    Subclasses are for 1, N (fixed) or Dynamic sizes
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepData_FieldList self) -> StepData_FieldList

        Creates a FieldList of 0 Field


        """
        this = _StepData.new_StepData_FieldList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbFields(self, *args):
        """
        NbFields(StepData_FieldList self) -> Standard_Integer

        Returns the count of fields. Here, returns 0

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_FieldList_NbFields(self, *args)


    def Field(self, *args):
        """
        Returns the field n0 <num> between 1 and NbFields (read only)

        :type num: int
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        res = _StepData.StepData_FieldList_Field(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CField(self, *args):
        """
        CField(StepData_FieldList self, Standard_Integer const num) -> StepData_Field

        Returns the field n0 <num> between 1 and NbFields, in order to
        modify its content

        :type num: int
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        return _StepData.StepData_FieldList_CField(self, *args)


    def FillShared(self, *args):
        """
        FillShared(StepData_FieldList self, Interface_EntityIterator iter)

        Fills an iterator with the entities shared by <me>

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.StepData_FieldList_FillShared(self, *args)

    __swig_destroy__ = _StepData.delete_StepData_FieldList
StepData_FieldList_swigregister = _StepData.StepData_FieldList_swigregister
StepData_FieldList_swigregister(StepData_FieldList)

class StepData_PDescr(Standard.Standard_Transient):
    """
    This class is intended to describe the authorized form for a
    parameter, as a type or a value for a field

    A PDescr firstly describes a type, which can be SELECT, i.e.
    have several members
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_PDescr
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_PDescr(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepData_PDescr self) -> StepData_PDescr

        This class is intended to describe the authorized form for a
        parameter, as a type or a value for a field

        A PDescr firstly describes a type, which can be SELECT, i.e.
        have several members
        """
        this = _StepData.new_StepData_PDescr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetName(self, *args):
        """
        SetName(StepData_PDescr self, Standard_CString const name)

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_PDescr_SetName(self, *args)


    def Name(self, *args):
        """
        Name(StepData_PDescr self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_PDescr_Name(self, *args)


    def SetSelect(self, *args):
        """
        SetSelect(StepData_PDescr self)

        Declares this PDescr to be a Select, hence to have members
        <me> itself can be the first member


        """
        return _StepData.StepData_PDescr_SetSelect(self, *args)


    def AddMember(self, *args):
        """
        AddMember(StepData_PDescr self, Handle_StepData_PDescr member)

        Adds a member to a SELECT description

        :type member: OCC.wrapper.StepData.Handle_StepData_PDescr

        """
        return _StepData.StepData_PDescr_AddMember(self, *args)


    def SetMemberName(self, *args):
        """
        SetMemberName(StepData_PDescr self, Standard_CString const memname)

        Sets a name for SELECT member. To be used if a member is for
        an immediate type

        :type memname: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_PDescr_SetMemberName(self, *args)


    def SetInteger(self, *args):
        """
        SetInteger(StepData_PDescr self)

        Sets <me> for an Integer value


        """
        return _StepData.StepData_PDescr_SetInteger(self, *args)


    def SetReal(self, *args):
        """
        SetReal(StepData_PDescr self)

        Sets <me> for a Real value


        """
        return _StepData.StepData_PDescr_SetReal(self, *args)


    def SetString(self, *args):
        """
        SetString(StepData_PDescr self)

        Sets <me> for a String value


        """
        return _StepData.StepData_PDescr_SetString(self, *args)


    def SetBoolean(self, *args):
        """
        SetBoolean(StepData_PDescr self)

        Sets <me> for a Boolean value (false,true)


        """
        return _StepData.StepData_PDescr_SetBoolean(self, *args)


    def SetLogical(self, *args):
        """
        SetLogical(StepData_PDescr self)

        Sets <me> for a Logical value (false,true,unknown)


        """
        return _StepData.StepData_PDescr_SetLogical(self, *args)


    def SetEnum(self, *args):
        """
        SetEnum(StepData_PDescr self)

        Sets <me> for an Enum value
        Then, call AddEnumDef ordered from the first one (value 0)


        """
        return _StepData.StepData_PDescr_SetEnum(self, *args)


    def AddEnumDef(self, *args):
        """
        AddEnumDef(StepData_PDescr self, Standard_CString const enumdef)

        Adds an enum value as a string

        :type enumdef: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_PDescr_AddEnumDef(self, *args)


    def SetType(self, *args):
        """
        SetType(StepData_PDescr self, Handle_Standard_Type atype)

        Sets <me> for an Entity which must match a Type (early-bound)

        :type atype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_PDescr_SetType(self, *args)


    def SetDescr(self, *args):
        """
        SetDescr(StepData_PDescr self, Standard_CString const dscnam)

        Sets <me> for a Described Entity, whose Description must match
        the type name  <dscnam>

        :type dscnam: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_PDescr_SetDescr(self, *args)


    def AddArity(self, *args):
        """
        AddArity(StepData_PDescr self, Standard_Integer const arity=1)

        Adds an arity count to <me>, by default 1
        1 : a simple field passes to a LIST/ARRAY etc
        or a LIST to a LIST OF LIST
        2 : a simple field passes to a LIST OF LIST

        :type arity: int

        """
        return _StepData.StepData_PDescr_AddArity(self, *args)


    def SetArity(self, *args):
        """
        SetArity(StepData_PDescr self, Standard_Integer const arity=1)

        Directly sets the arity count
        0 : simple field
        1 : LIST or ARRAY etc
        2 : LIST OF LIST

        :type arity: int

        """
        return _StepData.StepData_PDescr_SetArity(self, *args)


    def SetFrom(self, *args):
        """
        SetFrom(StepData_PDescr self, Handle_StepData_PDescr other)

        Sets <me> as <other> but duplicated
        Hence, some definition may be changed

        :type other: OCC.wrapper.StepData.Handle_StepData_PDescr

        """
        return _StepData.StepData_PDescr_SetFrom(self, *args)


    def SetOptional(self, *args):
        """
        SetOptional(StepData_PDescr self, Standard_Boolean const opt)

        Sets/Unsets <me> to accept undefined values

        :type opt: bool

        """
        return _StepData.StepData_PDescr_SetOptional(self, *args)


    def SetDerived(self, *args):
        """
        SetDerived(StepData_PDescr self, Standard_Boolean const der)

        Sets/Unsets <me> to be for a derived field

        :type der: bool

        """
        return _StepData.StepData_PDescr_SetDerived(self, *args)


    def SetField(self, *args):
        """
        SetField(StepData_PDescr self, Standard_CString const name, Standard_Integer const rank)

        Sets <me> to describe a field of an entity
        With a name and a rank

        :type name: OCC.wrapper.Standard.Standard_CString
        :type rank: int

        """
        return _StepData.StepData_PDescr_SetField(self, *args)


    def IsSelect(self, *args):
        """
        IsSelect(StepData_PDescr self) -> Standard_Boolean

        Tells if <me> is for a SELECT

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_PDescr_IsSelect(self, *args)


    def Member(self, *args):
        """
        Member(StepData_PDescr self, Standard_CString const name) -> Handle_StepData_PDescr

        For a SELECT, returns the member whose name matches <name>
        To this member, the following question can then be asked
        Null Handle if <name> not matched or <me> not a SELECT

        Remark : not to be asked for an entity type
        Hence, following IsInteger .. Enum* only apply on <me> and
        require Member
        While IsType applies on <me> and all Select Members

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.StepData.Handle_StepData_PDescr

        """
        return _StepData.StepData_PDescr_Member(self, *args)


    def IsInteger(self, *args):
        """
        IsInteger(StepData_PDescr self) -> Standard_Boolean

        Tells if <me> is for an Integer

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_PDescr_IsInteger(self, *args)


    def IsReal(self, *args):
        """
        IsReal(StepData_PDescr self) -> Standard_Boolean

        Tells if <me> is for a Real value

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_PDescr_IsReal(self, *args)


    def IsString(self, *args):
        """
        IsString(StepData_PDescr self) -> Standard_Boolean

        Tells if <me> is for a String value

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_PDescr_IsString(self, *args)


    def IsBoolean(self, *args):
        """
        IsBoolean(StepData_PDescr self) -> Standard_Boolean

        Tells if <me> is for a Boolean value (false,true)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_PDescr_IsBoolean(self, *args)


    def IsLogical(self, *args):
        """
        IsLogical(StepData_PDescr self) -> Standard_Boolean

        Tells if <me> is for a Logical value (false,true,unknown)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_PDescr_IsLogical(self, *args)


    def IsEnum(self, *args):
        """
        IsEnum(StepData_PDescr self) -> Standard_Boolean

        Tells if <me> is for an Enum value
        Then, call AddEnumDef ordered from the first one (value 0)
        Managed by an EnumTool

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_PDescr_IsEnum(self, *args)


    def EnumMax(self, *args):
        """
        EnumMax(StepData_PDescr self) -> Standard_Integer

        Returns the maximum integer for a suitable value (count - 1)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_PDescr_EnumMax(self, *args)


    def EnumValue(self, *args):
        """
        EnumValue(StepData_PDescr self, Standard_CString const name) -> Standard_Integer

        Returns the numeric value found for an enum text
        The text must be in capitals and limited by dots
        A non-suitable text gives a negative value to be returned

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_PDescr_EnumValue(self, *args)


    def EnumText(self, *args):
        """
        EnumText(StepData_PDescr self, Standard_Integer const val) -> Standard_CString

        Returns the text which corresponds to a numeric value,
        between 0 and EnumMax. It is limited by dots

        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_PDescr_EnumText(self, *args)


    def IsEntity(self, *args):
        """
        IsEntity(StepData_PDescr self) -> Standard_Boolean

        Tells if <me> is for an Entity, either Described or CDL Type

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_PDescr_IsEntity(self, *args)


    def IsType(self, *args):
        """
        IsType(StepData_PDescr self, Handle_Standard_Type atype) -> Standard_Boolean

        Tells if <me> is for an entity of a given CDL type (early-bnd)
        (works for <me> + nexts if <me> is a Select)

        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_PDescr_IsType(self, *args)


    def Type(self, *args):
        """
        Type(StepData_PDescr self) -> Handle_Standard_Type

        Returns the type to match (IsKind), for a CDL Entity
        (else, null handle)

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_PDescr_Type(self, *args)


    def IsDescr(self, *args):
        """
        IsDescr(StepData_PDescr self, Handle_StepData_EDescr descr) -> Standard_Boolean

        Tells if <me> is for a Described entity of a given EDescr
        (does this EDescr match description name ?). For late-bnd
        (works for <me> + nexts if <me> is a Select)

        :type descr: OCC.wrapper.StepData.Handle_StepData_EDescr
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_PDescr_IsDescr(self, *args)


    def DescrName(self, *args):
        """
        DescrName(StepData_PDescr self) -> Standard_CString

        Returns the description (type name) to match, for a Described
        (else, empty string)

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_PDescr_DescrName(self, *args)


    def Arity(self, *args):
        """
        Arity(StepData_PDescr self) -> Standard_Integer

        Returns the arity of <me>

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_PDescr_Arity(self, *args)


    def Simple(self, *args):
        """
        Simple(StepData_PDescr self) -> Handle_StepData_PDescr

        For a LIST or LIST OF LIST, Returns the PDescr for the simpler
        PDescr. Else, returns <me>
        This allows to have different attributes for Optional for
        instance, on a field, and on the parameter of a LIST :
        [OPTIONAL] LIST OF [OPTIONAL] ...

        :rtype: OCC.wrapper.StepData.Handle_StepData_PDescr

        """
        return _StepData.StepData_PDescr_Simple(self, *args)


    def IsOptional(self, *args):
        """
        IsOptional(StepData_PDescr self) -> Standard_Boolean

        Tells if <me> is Optional

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_PDescr_IsOptional(self, *args)


    def IsDerived(self, *args):
        """
        IsDerived(StepData_PDescr self) -> Standard_Boolean

        Tells if <me> is Derived

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_PDescr_IsDerived(self, *args)


    def IsField(self, *args):
        """
        IsField(StepData_PDescr self) -> Standard_Boolean

        Tells if <me> is a Field. Else it is a Type

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_PDescr_IsField(self, *args)


    def FieldName(self, *args):
        """
        FieldName(StepData_PDescr self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_PDescr_FieldName(self, *args)


    def FieldRank(self, *args):
        """
        FieldRank(StepData_PDescr self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_PDescr_FieldRank(self, *args)


    def Check(self, *args):
        """
        Check(StepData_PDescr self, StepData_Field afild, Handle_Interface_Check ach)

        Semantic Check of a Field : does it complies with the given
        description ?

        :type afild: OCC.wrapper.StepData.StepData_Field
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _StepData.StepData_PDescr_Check(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_PDescr_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_PDescr_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_PDescr_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_PDescr
StepData_PDescr_swigregister = _StepData.StepData_PDescr_swigregister
StepData_PDescr_swigregister(StepData_PDescr)

def StepData_PDescr_get_type_name(*args):
    """
    StepData_PDescr_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_PDescr_get_type_name(*args)

def StepData_PDescr_get_type_descriptor(*args):
    """
    StepData_PDescr_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_PDescr_get_type_descriptor(*args)

class StepData_NodeOfWriterLib(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_NodeOfWriterLib
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_NodeOfWriterLib(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepData_NodeOfWriterLib self) -> StepData_NodeOfWriterLib

        Creates an empty Node, with no Next


        """
        this = _StepData.new_StepData_NodeOfWriterLib(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def AddNode(self, *args):
        """
        AddNode(StepData_NodeOfWriterLib self, Handle_StepData_GlobalNodeOfWriterLib anode)

        Adds a couple (Module,Protocol), that is, stores it into
        itself if not yet done, else creates a Next Node to do it

        :type anode: OCC.wrapper.StepData.Handle_StepData_GlobalNodeOfWriterLib

        """
        return _StepData.StepData_NodeOfWriterLib_AddNode(self, *args)


    def Module(self, *args):
        """
        Returns the Module designated by a precise Node

        :rtype: OCC.wrapper.StepData.Handle_StepData_ReadWriteModule

        """
        res = _StepData.StepData_NodeOfWriterLib_Module(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Protocol(self, *args):
        """
        Returns the Protocol designated by a precise Node

        :rtype: OCC.wrapper.StepData.Handle_StepData_Protocol

        """
        res = _StepData.StepData_NodeOfWriterLib_Protocol(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Next(self, *args):
        """
        Returns the Next Node. If none was defined, returned value
        is a Null Handle

        :rtype: OCC.wrapper.StepData.Handle_StepData_NodeOfWriterLib

        """
        res = _StepData.StepData_NodeOfWriterLib_Next(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_NodeOfWriterLib_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_NodeOfWriterLib_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_NodeOfWriterLib_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_NodeOfWriterLib
StepData_NodeOfWriterLib_swigregister = _StepData.StepData_NodeOfWriterLib_swigregister
StepData_NodeOfWriterLib_swigregister(StepData_NodeOfWriterLib)

def StepData_NodeOfWriterLib_get_type_name(*args):
    """
    StepData_NodeOfWriterLib_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_NodeOfWriterLib_get_type_name(*args)

def StepData_NodeOfWriterLib_get_type_descriptor(*args):
    """
    StepData_NodeOfWriterLib_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_NodeOfWriterLib_get_type_descriptor(*args)

class StepData_ESDescr(StepData_EDescr):
    """
    This class is intended to describe the authorized form for a
    Simple (not Plex) Entity, as a list of fields
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_ESDescr
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_ESDescr(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepData_ESDescr self, Standard_CString const name) -> StepData_ESDescr

        Creates an ESDescr with a type name

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        this = _StepData.new_StepData_ESDescr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetNbFields(self, *args):
        """
        SetNbFields(StepData_ESDescr self, Standard_Integer const nb)

        Sets a new count of fields
        Each one is described by a PDescr

        :type nb: int

        """
        return _StepData.StepData_ESDescr_SetNbFields(self, *args)


    def SetField(self, *args):
        """
        SetField(StepData_ESDescr self, Standard_Integer const num, Standard_CString const name, Handle_StepData_PDescr descr)

        Sets a PDescr to describe a field
        A Field is designated by its rank and name

        :type num: int
        :type name: OCC.wrapper.Standard.Standard_CString
        :type descr: OCC.wrapper.StepData.Handle_StepData_PDescr

        """
        return _StepData.StepData_ESDescr_SetField(self, *args)


    def SetBase(self, *args):
        """
        SetBase(StepData_ESDescr self, Handle_StepData_ESDescr base)

        Sets an ESDescr as based on another one
        Hence, if there are inherited fields, the derived ESDescr
        cumulates all them, while the base just records its own ones

        :type base: OCC.wrapper.StepData.Handle_StepData_ESDescr

        """
        return _StepData.StepData_ESDescr_SetBase(self, *args)


    def SetSuper(self, *args):
        """
        SetSuper(StepData_ESDescr self, Handle_StepData_ESDescr super)

        Sets an ESDescr as "super-type". Applies an a base (non
        derived) ESDescr

        :type super: OCC.wrapper.StepData.Handle_StepData_ESDescr

        """
        return _StepData.StepData_ESDescr_SetSuper(self, *args)


    def TypeName(self, *args):
        """
        TypeName(StepData_ESDescr self) -> Standard_CString

        Returns the type name given at creation time

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_ESDescr_TypeName(self, *args)


    def StepType(self, *args):
        """
        Returns the type name as an AsciiString

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _StepData.StepData_ESDescr_StepType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Base(self, *args):
        """
        Base(StepData_ESDescr self) -> Handle_StepData_ESDescr

        Returns the basic ESDescr, null if <me> is not derived

        :rtype: OCC.wrapper.StepData.Handle_StepData_ESDescr

        """
        return _StepData.StepData_ESDescr_Base(self, *args)


    def Super(self, *args):
        """
        Super(StepData_ESDescr self) -> Handle_StepData_ESDescr

        Returns the super-type ESDescr, null if <me> is root

        :rtype: OCC.wrapper.StepData.Handle_StepData_ESDescr

        """
        return _StepData.StepData_ESDescr_Super(self, *args)


    def IsSub(self, *args):
        """
        IsSub(StepData_ESDescr self, Handle_StepData_ESDescr other) -> Standard_Boolean

        Tells if <me> is sub-type of (or equal to) another one

        :type other: OCC.wrapper.StepData.Handle_StepData_ESDescr
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_ESDescr_IsSub(self, *args)


    def NbFields(self, *args):
        """
        NbFields(StepData_ESDescr self) -> Standard_Integer

        Returns the count of fields

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_ESDescr_NbFields(self, *args)


    def Rank(self, *args):
        """
        Rank(StepData_ESDescr self, Standard_CString const name) -> Standard_Integer

        Returns the rank of a field from its name. 0 if unknown

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_ESDescr_Rank(self, *args)


    def Name(self, *args):
        """
        Name(StepData_ESDescr self, Standard_Integer const num) -> Standard_CString

        Returns the name of a field from its rank. empty if outofrange

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_ESDescr_Name(self, *args)


    def Field(self, *args):
        """
        Field(StepData_ESDescr self, Standard_Integer const num) -> Handle_StepData_PDescr

        Returns the PDescr for the field <num> (or Null)

        :type num: int
        :rtype: OCC.wrapper.StepData.Handle_StepData_PDescr

        """
        return _StepData.StepData_ESDescr_Field(self, *args)


    def NamedField(self, *args):
        """
        NamedField(StepData_ESDescr self, Standard_CString const name) -> Handle_StepData_PDescr

        Returns the PDescr for the field named <name> (or Null)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.StepData.Handle_StepData_PDescr

        """
        return _StepData.StepData_ESDescr_NamedField(self, *args)


    def Matches(self, *args):
        """
        Matches(StepData_ESDescr self, Standard_CString const steptype) -> Standard_Boolean

        Tells if a ESDescr matches a step type : exact or super type

        :type steptype: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_ESDescr_Matches(self, *args)


    def IsComplex(self, *args):
        """
        IsComplex(StepData_ESDescr self) -> Standard_Boolean

        Returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_ESDescr_IsComplex(self, *args)


    def NewEntity(self, *args):
        """
        NewEntity(StepData_ESDescr self) -> Handle_StepData_Described

        Creates a described entity (i.e. a simple one)

        :rtype: OCC.wrapper.StepData.Handle_StepData_Described

        """
        return _StepData.StepData_ESDescr_NewEntity(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_ESDescr_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_ESDescr_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_ESDescr_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_ESDescr
StepData_ESDescr_swigregister = _StepData.StepData_ESDescr_swigregister
StepData_ESDescr_swigregister(StepData_ESDescr)

def StepData_ESDescr_get_type_name(*args):
    """
    StepData_ESDescr_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_ESDescr_get_type_name(*args)

def StepData_ESDescr_get_type_descriptor(*args):
    """
    StepData_ESDescr_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_ESDescr_get_type_descriptor(*args)

class Handle_StepData_ReadWriteModule(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_ReadWriteModule self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_ReadWriteModule_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_ReadWriteModule self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_ReadWriteModule_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_ReadWriteModule self, StepData_ReadWriteModule thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_ReadWriteModule_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_ReadWriteModule self, Handle_StepData_ReadWriteModule theHandle) -> Handle_StepData_ReadWriteModule
        assign(Handle_StepData_ReadWriteModule self, StepData_ReadWriteModule thePtr) -> Handle_StepData_ReadWriteModule
        assign(Handle_StepData_ReadWriteModule self, Handle_StepData_ReadWriteModule theHandle) -> Handle_StepData_ReadWriteModule

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_ReadWriteModule_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_ReadWriteModule self) -> StepData_ReadWriteModule

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_ReadWriteModule_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_ReadWriteModule self) -> StepData_ReadWriteModule

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_ReadWriteModule___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_ReadWriteModule self) -> StepData_ReadWriteModule

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_ReadWriteModule___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_ReadWriteModule___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_ReadWriteModule___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_ReadWriteModule(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_ReadWriteModule_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_ReadWriteModule

    def CaseNum(self, *args):
        """
        CaseNum(Handle_StepData_ReadWriteModule self, Handle_Interface_FileReaderData data, Standard_Integer const num) -> Standard_Integer

        Translate the Type of record <num> in <data> to a positive
        Case Number, or 0 if failed.
        Works with a StepReaderData, in which the Type of an Entity
        is defined as a String : Reads the RecordType <num> then calls
        CaseNum (this type)
        Warning : The methods CaseStep, StepType and Recognize,
        must be in phase (triplets CaseNum-StepType-Type of Object)

        :type data: OCC.wrapper.Interface.Handle_Interface_FileReaderData
        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_ReadWriteModule_CaseNum(self, *args)


    def CaseStep(self, *args):
        """
        CaseStep(Handle_StepData_ReadWriteModule self, TCollection_AsciiString atype) -> Standard_Integer
        CaseStep(Handle_StepData_ReadWriteModule self, NCollection_Sequence_TCollection_AsciiString types) -> Standard_Integer

        Same a above but for a Complex Type Entity ("Plex")
        The provided Default recognizes nothing

        :type types: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_ReadWriteModule_CaseStep(self, *args)


    def IsComplex(self, *args):
        """
        IsComplex(Handle_StepData_ReadWriteModule self, Standard_Integer const CN) -> Standard_Boolean

        Returns True if the Case Number corresponds to a Complex Type
        ("Plex"). Remember that all possible combinations must be
        aknowledged to be processed
        Default is False for all cases. For a Protocol which defines
        possible Plexes, this method must be redefined.

        :type CN: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_ReadWriteModule_IsComplex(self, *args)


    def StepType(self, *args):
        """
        Function specific to STEP, which delivers the StepType as it
        is recorded in and read from a File compliant with STEP.
        This method is symmetric to the method CaseStep.
        StepType can be different from Dynamic Type's name, but
        belongs to the same class of Object.
        Returns an empty String if <CN> is zero.
        Warning : For a Complex Type Entity, returns an Empty String
        (Complex Type must be managed by users)

        :type CN: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _StepData.Handle_StepData_ReadWriteModule_StepType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ShortType(self, *args):
        """
        ShortType(Handle_StepData_ReadWriteModule self, Standard_Integer const CN) -> TCollection_AsciiString

        Function specific to STEP. Some STEP Types have a short form
        This method can be redefined to fill it
        By default, returns an empty string, which is then interpreted
        to take normal form from StepType

        :type CN: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _StepData.Handle_StepData_ReadWriteModule_ShortType(self, *args)


    def ComplexType(self, *args):
        """
        ComplexType(Handle_StepData_ReadWriteModule self, Standard_Integer const CN, NCollection_Sequence_TCollection_AsciiString types) -> Standard_Boolean

        Function specific to STEP, which delivers the list of types
        which corresponds to a complex type. If <CN> is not for a
        complex type, this method returns False. Else it returns True
        and fills the list in alphabetic order.
        The default returns False. To be redefined as required.

        :type CN: int
        :type types: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_ReadWriteModule_ComplexType(self, *args)


    def Read(self, *args):
        """
        Read(Handle_StepData_ReadWriteModule self, Standard_Integer const CN, Handle_Interface_FileReaderData data, Standard_Integer const num, Handle_Interface_Check ach, Handle_Standard_Transient ent)

        General Read Function, calls ReadStep

        :type CN: int
        :type data: OCC.wrapper.Interface.Handle_Interface_FileReaderData
        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.Handle_StepData_ReadWriteModule_Read(self, *args)


    def ReadStep(self, *args):
        """
        ReadStep(Handle_StepData_ReadWriteModule self, Standard_Integer const CN, Handle_StepData_StepReaderData data, Standard_Integer const num, Handle_Interface_Check ach, Handle_Standard_Transient ent)

        Specific Read Function. Works with StepReaderData

        :type CN: int
        :type data: OCC.wrapper.StepData.Handle_StepData_StepReaderData
        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.Handle_StepData_ReadWriteModule_ReadStep(self, *args)


    def WriteStep(self, *args):
        """
        WriteStep(Handle_StepData_ReadWriteModule self, Standard_Integer const CN, StepData_StepWriter SW, Handle_Standard_Transient ent)

        Write Function, switched by CaseNum

        :type CN: int
        :type SW: OCC.wrapper.StepData.StepData_StepWriter
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.Handle_StepData_ReadWriteModule_WriteStep(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_ReadWriteModule self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_ReadWriteModule_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_ReadWriteModule_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_ReadWriteModule_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NewRead(self, *args):
        """
        NewRead(Handle_StepData_ReadWriteModule self, Standard_Integer const casenum, Handle_Interface_FileReaderData data, Standard_Integer const num, Handle_Interface_Check ach, Handle_Standard_Transient ent) -> Standard_Boolean

        Specific operator (create+read) defaulted to do nothing.
        It can be redefined when it is not possible to work in two
        steps (NewVoid then Read). This occurs when no default
        constructor is defined : hence the result <ent> must be
        created with an effective definition from the reader.
        Remark : if NewRead is defined, Copy has nothing to do.

        Returns True if it has produced something, false else.
        If nothing was produced, <ach> should be filled : it will be
        treated as "Unrecognized case" by reader tool.

        :type casenum: int
        :type data: OCC.wrapper.Interface.Handle_Interface_FileReaderData
        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_ReadWriteModule_NewRead(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepData_ReadWriteModule self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_ReadWriteModule_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_ReadWriteModule self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_ReadWriteModule self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_ReadWriteModule_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_ReadWriteModule self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_ReadWriteModule self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_ReadWriteModule_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_ReadWriteModule self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_ReadWriteModule_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_ReadWriteModule self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_ReadWriteModule_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_ReadWriteModule self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_ReadWriteModule_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_ReadWriteModule self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_ReadWriteModule_DecrementRefCounter(self, *args)

Handle_StepData_ReadWriteModule_swigregister = _StepData.Handle_StepData_ReadWriteModule_swigregister
Handle_StepData_ReadWriteModule_swigregister(Handle_StepData_ReadWriteModule)

def Handle_StepData_ReadWriteModule_DownCast(thing):
    return _StepData.Handle_StepData_ReadWriteModule_DownCast(thing)
Handle_StepData_ReadWriteModule_DownCast = _StepData.Handle_StepData_ReadWriteModule_DownCast

class StepData_StepDumper(object):
    """
    Provides a way to dump entities processed through STEP, with
    these features :
    - same form as for writing a STEP File (because it is clear
    and compact enough, even if the names of the fields do not
    appear) : thus, no additionnal resource is required
    - possibility to look for an entity itself (only its Type or
    with its content), an entity and it shared items (one level)
    or all the entities its refers to, directly or recursively.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepData_StepDumper self, Handle_StepData_StepModel amodel, Handle_StepData_Protocol protocol, Standard_Integer const mode=0) -> StepData_StepDumper

        Creates a StepDumper, able to work on a given StepModel
        (which defines the total scope for dumping entities) and
        a given Protocol from Step (which defines the authorized
        types to be dumped)
        <mode> commands what is to be displayed (number or label)
        0 for number (and corresponding labels  are displayed apart)
        1 for label  (and corresponding numbers are displayed apart)
        2 for label without anymore

        :type amodel: OCC.wrapper.StepData.Handle_StepData_StepModel
        :type protocol: OCC.wrapper.StepData.Handle_StepData_Protocol
        :type mode: int

        """
        this = _StepData.new_StepData_StepDumper(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def StepWriter(self, *args):
        """
        StepWriter(StepData_StepDumper self) -> StepData_StepWriter

        Gives an access to the tool which is used to work : this allow
        to acts on some parameters : Floating Format, Scopes ...

        :rtype: OCC.wrapper.StepData.StepData_StepWriter

        """
        return _StepData.StepData_StepDumper_StepWriter(self, *args)


    def Dump(self, *args):
        """
        Dump(StepData_StepDumper self, Handle_Message_Messenger S, Handle_Standard_Transient ent, Standard_Integer const level) -> Standard_Boolean
        Dump(StepData_StepDumper self, Handle_Message_Messenger S, Standard_Integer const num, Standard_Integer const level) -> Standard_Boolean

        Works as Dump with a Transient, but directly takes the
        entity designated by its number in the Model
        Returns False, also if <num> is out of range

        :type S: OCC.wrapper.Message.Handle_Message_Messenger
        :type num: int
        :type level: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_StepDumper_Dump(self, *args)

    __swig_destroy__ = _StepData.delete_StepData_StepDumper
StepData_StepDumper_swigregister = _StepData.StepData_StepDumper_swigregister
StepData_StepDumper_swigregister(StepData_StepDumper)

class Handle_StepData_Simple(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_Simple self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_Simple_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_Simple self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_Simple_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_Simple self, StepData_Simple thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_Simple_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_Simple self, Handle_StepData_Simple theHandle) -> Handle_StepData_Simple
        assign(Handle_StepData_Simple self, StepData_Simple thePtr) -> Handle_StepData_Simple
        assign(Handle_StepData_Simple self, Handle_StepData_Simple theHandle) -> Handle_StepData_Simple

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_Simple_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_Simple self) -> StepData_Simple

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_Simple_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_Simple self) -> StepData_Simple

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_Simple___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_Simple self) -> StepData_Simple

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_Simple___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_Simple___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_Simple___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_Simple(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_Simple_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_Simple

    def ESDescr(self, *args):
        """
        ESDescr(Handle_StepData_Simple self) -> Handle_StepData_ESDescr

        Returns description, as for simple

        :rtype: OCC.wrapper.StepData.Handle_StepData_ESDescr

        """
        return _StepData.Handle_StepData_Simple_ESDescr(self, *args)


    def StepType(self, *args):
        """
        StepType(Handle_StepData_Simple self) -> Standard_CString

        Returns the recorded StepType (TypeName of its ESDescr)

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_Simple_StepType(self, *args)


    def IsComplex(self, *args):
        """
        IsComplex(Handle_StepData_Simple self) -> Standard_Boolean

        Returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_Simple_IsComplex(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_StepData_Simple self, Standard_CString const steptype) -> Standard_Boolean

        Tells if a step type is matched by <me>
        For a Simple Entity : own type or super type
        For a Complex Entity : one of the members

        :type steptype: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_Simple_Matches(self, *args)


    def As(self, *args):
        """
        As(Handle_StepData_Simple self, Standard_CString const steptype) -> Handle_StepData_Simple

        Returns a Simple Entity which matches with a Type in <me> :
        For a Simple Entity : me if it matches, else a null handle
        For a Complex Entity : the member which matches, else null

        :type steptype: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.StepData.Handle_StepData_Simple

        """
        return _StepData.Handle_StepData_Simple_As(self, *args)


    def HasField(self, *args):
        """
        HasField(Handle_StepData_Simple self, Standard_CString const name) -> Standard_Boolean

        Tells if a Field brings a given name

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_Simple_HasField(self, *args)


    def Field(self, *args):
        """
        Returns a Field from its name; read-only

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        res = _StepData.Handle_StepData_Simple_Field(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CField(self, *args):
        """
        CField(Handle_StepData_Simple self, Standard_CString const name) -> StepData_Field

        Returns a Field from its name; read or write

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        return _StepData.Handle_StepData_Simple_CField(self, *args)


    def NbFields(self, *args):
        """
        NbFields(Handle_StepData_Simple self) -> Standard_Integer

        Returns the count of fields

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_Simple_NbFields(self, *args)


    def FieldNum(self, *args):
        """
        Returns a field from its rank, for read-only use

        :type num: int
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        res = _StepData.Handle_StepData_Simple_FieldNum(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CFieldNum(self, *args):
        """
        CFieldNum(Handle_StepData_Simple self, Standard_Integer const num) -> StepData_Field

        Returns a field from its rank, in order to modify it

        :type num: int
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        return _StepData.Handle_StepData_Simple_CFieldNum(self, *args)


    def Fields(self, *args):
        """
        Returns the entire field list, read-only

        :rtype: OCC.wrapper.StepData.StepData_FieldListN

        """
        res = _StepData.Handle_StepData_Simple_Fields(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CFields(self, *args):
        """
        CFields(Handle_StepData_Simple self) -> StepData_FieldListN

        Returns the entire field list, read or write

        :rtype: OCC.wrapper.StepData.StepData_FieldListN

        """
        return _StepData.Handle_StepData_Simple_CFields(self, *args)


    def Check(self, *args):
        """
        Check(Handle_StepData_Simple self, Handle_Interface_Check ach)

        Fills a Check by using its Description

        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _StepData.Handle_StepData_Simple_Check(self, *args)


    def Shared(self, *args):
        """
        Shared(Handle_StepData_Simple self, Interface_EntityIterator list)

        Fills an EntityIterator with entities shared by <me>

        :type list: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.Handle_StepData_Simple_Shared(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_Simple self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_Simple_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_Simple_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_Simple_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Description(self, *args):
        """
        Description(Handle_StepData_Simple self) -> Handle_StepData_EDescr

        Returns the Description used to define this entity

        :rtype: OCC.wrapper.StepData.Handle_StepData_EDescr

        """
        return _StepData.Handle_StepData_Simple_Description(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepData_Simple self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_Simple_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_Simple self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_Simple self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_Simple_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_Simple self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_Simple self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_Simple_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_Simple self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_Simple_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_Simple self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_Simple_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_Simple self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_Simple_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_Simple self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_Simple_DecrementRefCounter(self, *args)

Handle_StepData_Simple_swigregister = _StepData.Handle_StepData_Simple_swigregister
Handle_StepData_Simple_swigregister(Handle_StepData_Simple)

def Handle_StepData_Simple_DownCast(thing):
    return _StepData.Handle_StepData_Simple_DownCast(thing)
Handle_StepData_Simple_DownCast = _StepData.Handle_StepData_Simple_DownCast

class StepData_StepReaderData(Interface.Interface_FileReaderData):
    """
    Specific FileReaderData for Step
    Contains litteral description of entities (for each one : type
    as a string, ident, parameter list)
    provides references evaluation, plus access to litteral data
    and specific access methods (Boolean, XY, XYZ)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_StepReaderData
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_StepReaderData(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepData_StepReaderData self, Standard_Integer const nbheader, Standard_Integer const nbtotal, Standard_Integer const nbpar) -> StepData_StepReaderData

        creates StepReaderData correctly dimensionned (necessary at
        creation time, because it contains arrays)
        nbheader is nb of records for Header, nbtotal for Header+Data
        and nbpar gives the total count of parameters

        :type nbheader: int
        :type nbtotal: int
        :type nbpar: int

        """
        this = _StepData.new_StepData_StepReaderData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetRecord(self, *args):
        """
        SetRecord(StepData_StepReaderData self, Standard_Integer const num, Standard_CString const ident, Standard_CString const type, Standard_Integer const nbpar)

        Fills the fields of a record

        :type num: int
        :type ident: OCC.wrapper.Standard.Standard_CString
        :type type: OCC.wrapper.Standard.Standard_CString
        :type nbpar: int

        """
        return _StepData.StepData_StepReaderData_SetRecord(self, *args)


    def AddStepParam(self, *args):
        """
        AddStepParam(StepData_StepReaderData self, Standard_Integer const num, Standard_CString const aval, Interface_ParamType const atype, Standard_Integer const nument=0)

        Fills the fields of a parameter of a record. This is a variant
        of AddParam, Adapted to STEP (optimized for specific values)

        :type num: int
        :type aval: OCC.wrapper.Standard.Standard_CString
        :type atype: OCC.wrapper.Interface.Interface_ParamType
        :type nument: int

        """
        return _StepData.StepData_StepReaderData_AddStepParam(self, *args)


    def RecordType(self, *args):
        """
        Returns Record Type

        :type num: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _StepData.StepData_StepReaderData_RecordType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CType(self, *args):
        """
        CType(StepData_StepReaderData self, Standard_Integer const num) -> Standard_CString

        Returns Record Type as a CString
        was C++ : return const

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_StepReaderData_CType(self, *args)


    def RecordIdent(self, *args):
        """
        RecordIdent(StepData_StepReaderData self, Standard_Integer const num) -> Standard_Integer

        Returns record identifier (Positive number)
        If returned ident is not positive : Sub-List or Scope mark

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_StepReaderData_RecordIdent(self, *args)


    def SubListNumber(self, *args):
        """
        SubListNumber(StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_Boolean const aslast) -> Standard_Integer

        Returns SubList numero designated by a parameter (nump) in a
        record (num), or zero if the parameter does not exist or is
        not a SubList address. Zero too If aslast is True and nump
        is not for the last parameter

        :type num: int
        :type nump: int
        :type aslast: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_StepReaderData_SubListNumber(self, *args)


    def IsComplex(self, *args):
        """
        IsComplex(StepData_StepReaderData self, Standard_Integer const num) -> Standard_Boolean

        Returns True if <num> corresponds to a Complex Type Entity
        (as can be defined by ANDOR Express clause)

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_StepReaderData_IsComplex(self, *args)


    def ComplexType(self, *args):
        """
        ComplexType(StepData_StepReaderData self, Standard_Integer const num, NCollection_Sequence_TCollection_AsciiString types)

        Returns the List of Types which correspond to a Complex Type
        Entity. If not Complex, there is just one Type in it
        For a SubList or a Scope mark, <types> remains empty

        :type num: int
        :type types: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString

        """
        return _StepData.StepData_StepReaderData_ComplexType(self, *args)


    def NextForComplex(self, *args):
        """
        NextForComplex(StepData_StepReaderData self, Standard_Integer const num) -> Standard_Integer

        Returns the Next "Componant" for a Complex Type Entity, of
        which <num> is already a Componant (the first one or a next one)
        Returns 0 for a Simple Type or for the last Componant

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_StepReaderData_NextForComplex(self, *args)


    def NamedForComplex(self, *args):
        """
        NamedForComplex(StepData_StepReaderData self, Standard_CString const name, Standard_Integer const num0, Handle_Interface_Check ach) -> Standard_Boolean
        NamedForComplex(StepData_StepReaderData self, Standard_CString const theName, Standard_CString const theShortName, Standard_Integer const num0, Handle_Interface_Check ach) -> Standard_Boolean

        Determines the first component which brings a given name, or
        short name for a Complex Type Entity
        <num0> is the very first record of this entity
        <num> is given the last NextNamedForComplex, starts at zero
        it is returned as the newly found number
        Hence, in the normal case, NextNamedForComplex starts by num0
        if <num> is zero, else by NextForComplex(num)
        If the alphabetic order is not respected, it restarts from
        num0 and loops on NextForComplex until finding <name>
        In case of "non-alphabetic order", <ach> is filled with a
        Warning for this name
        In case of "not-found at all", <ach> is filled with a Fail,
        and <num> is returned as zero

        Returns True if alphabetic order, False else

        :type theName: OCC.wrapper.Standard.Standard_CString
        :type theShortName: OCC.wrapper.Standard.Standard_CString
        :type num0: int
        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_StepReaderData_NamedForComplex(self, *args)


    def CheckNbParams(self, *args):
        """
        CheckNbParams(StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nbreq, Handle_Interface_Check ach, Standard_CString const mess) -> Standard_Boolean

        Checks Count of Parameters of record <num> to equate <nbreq>
        If this Check is successful, returns True
        Else, fills <ach> with an Error Message then returns False
        <mess> is included in the Error message if given non empty

        :type num: int
        :type nbreq: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type mess: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_StepReaderData_CheckNbParams(self, *args)


    def ReadSubList(self, *args):
        """
        ReadSubList(StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach, Standard_Boolean const optional, Standard_Integer const lenmin=0, Standard_Integer const lenmax=0) -> Standard_Boolean

        reads parameter <nump> of record <num> as a sub-list (may be
        typed, see ReadTypedParameter in this case)
        Returns True if OK. Else (not a LIST), returns false and
        feeds Check with appropriate check
        If <optional> is True and Param is not defined, returns True
        with <ach> not filled and <numsub> returned as 0
        Works with SubListNumber with <aslast> false (no specific case
        for last parameter)

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type numsub: int
        :type optional: bool
        :type lenmin: int
        :type lenmax: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_StepReaderData_ReadSubList(self, *args)


    def ReadSub(self, *args):
        """
        ReadSub(StepData_StepReaderData self, Standard_Integer const numsub, Standard_CString const mess, Handle_Interface_Check ach, Handle_StepData_PDescr descr, Handle_Standard_Transient val) -> Standard_Integer

        reads the content of a sub-list into a transient :
        SelectNamed, or HArray1 of Integer,Real,String,Transient ...
        recursive call if list of list ...
        If a sub-list has mixed types, an HArray1OfTransient is
        produced, it may contain SelectMember
        Intended to be called by ReadField
        The returned status is : negative if failed, 0 if empty.
        Else the kind to be recorded in the field

        :type numsub: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type descr: OCC.wrapper.StepData.Handle_StepData_PDescr
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_StepReaderData_ReadSub(self, *args)


    def ReadMember(self, *args):
        """
        ReadMember(StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach, Handle_StepData_SelectMember val) -> Standard_Boolean

        Reads parameter <nump> of record <num> into a SelectMember,
        self-sufficient (no Description needed)
        If <val> is already created, it will be filled, as possible
        And if reading does not match its own description, the result
        will be False
        If <val> is not it not yet created, it will be (SelectNamed)
        Usefull if a field is defined as a SelectMember, directly
        (SELECT with no Entity as member)
        But SelectType also manages SelectMember (for SELECT with
        some members as Entity, some other not)

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type val: OCC.wrapper.StepData.Handle_StepData_SelectMember
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_StepReaderData_ReadMember(self, *args)


    def ReadField(self, *args):
        """
        ReadField(StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach, Handle_StepData_PDescr descr, StepData_Field fild) -> Standard_Boolean

        reads parameter <nump> of record <num> into a Field,
        controlled by a Parameter Descriptor (PDescr), which controls
        its allowed type(s) and value
        <ach> is filled if the read parameter does not match its
        description (but the field is read anyway)
        If the description is not defined, no control is done
        Returns True when done

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type descr: OCC.wrapper.StepData.Handle_StepData_PDescr
        :type fild: OCC.wrapper.StepData.StepData_Field
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_StepReaderData_ReadField(self, *args)


    def ReadList(self, *args):
        """
        ReadList(StepData_StepReaderData self, Standard_Integer const num, Handle_Interface_Check ach, Handle_StepData_ESDescr descr, StepData_FieldList list) -> Standard_Boolean

        reads a list of fields controlled by an ESDescr

        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type descr: OCC.wrapper.StepData.Handle_StepData_ESDescr
        :type list: OCC.wrapper.StepData.StepData_FieldList
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_StepReaderData_ReadList(self, *args)


    def ReadAny(self, *args):
        """
        ReadAny(StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach, Handle_StepData_PDescr descr, Handle_Standard_Transient val) -> Standard_Boolean

        Reads parameter <nump> of record <num> into a Transient Value
        according to the type of the parameter :
        Named for Integer,Boolean,Logical,Enum,Real : SelectNamed
        Immediate Integer,Boolean,Logical,Enum,Real : SelectInt/Real
        Text  : HAsciiString
        Ident : the referenced Entity
        Sub-List not processed, see ReadSub
        This value is controlled by a Parameter Descriptor (PDescr),
        which controls its allowed type and value
        <ach> is filled if the read parameter does not match its
        description (the select is nevertheless created if possible)

        Warning : val is in out, hence it is possible to predefine a specific
        SelectMember then to fill it. If <val> is Null or if the
        result is not a SelectMember, val itself is returned a new ref
        For a Select with a Name, <val> must then be a SelectNamed

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type descr: OCC.wrapper.StepData.Handle_StepData_PDescr
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_StepReaderData_ReadAny(self, *args)


    def ReadXY(self, *args):
        """
        ReadXY(StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach) -> Standard_Boolean

        reads parameter <nump> of record <num> as a sub-list of
        two Reals X,Y. Returns True if OK. Else, returns false and
        feeds Check with appropriate Fails (parameter not a sub-list,
        not two Reals in the sub-list) composed with "mess" which
        gives the name of the parameter

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type X: float
        :type Y: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_StepReaderData_ReadXY(self, *args)


    def ReadXYZ(self, *args):
        """
        ReadXYZ(StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach) -> Standard_Boolean

        reads parameter <nump> of record <num> as a sub-list of
        three Reals X,Y,Z. Return value and Check managed as by
        ReadXY (demands a sub-list of three Reals)

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type X: float
        :type Y: float
        :type Z: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_StepReaderData_ReadXYZ(self, *args)


    def ReadReal(self, *args):
        """
        ReadReal(StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach) -> Standard_Boolean

        reads parameter <nump> of record <num> as a single Real value.
        Return value and Check managed as by ReadXY (demands a Real)

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type val: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_StepReaderData_ReadReal(self, *args)


    def ReadEntity(self, *args):
        """
        ReadEntity(StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach, Handle_Standard_Type atype, Handle_Standard_Transient ent) -> Standard_Boolean
        ReadEntity(StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach, StepData_SelectType sel) -> Standard_Boolean

        Same as above, but a SelectType checks Type Matching, and
        records the read Entity (see method Value from SelectType)

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type sel: OCC.wrapper.StepData.StepData_SelectType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_StepReaderData_ReadEntity(self, *args)


    def ReadInteger(self, *args):
        """
        ReadInteger(StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach) -> Standard_Boolean

        reads parameter <nump> of record <num> as a single Integer.
        Return value & Check managed as by ReadXY (demands an Integer)

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_StepReaderData_ReadInteger(self, *args)


    def ReadBoolean(self, *args):
        """
        ReadBoolean(StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach) -> Standard_Boolean

        reads parameter <nump> of record <num> as a Boolean
        Return value and Check managed as by ReadReal (demands a
        Boolean enum, i.e. text ".T." for True or ".F." for False)

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type flag: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_StepReaderData_ReadBoolean(self, *args)


    def ReadLogical(self, *args):
        """
        ReadLogical(StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach) -> Standard_Boolean

        reads parameter <nump> of record <num> as a Logical
        Return value and Check managed as by ReadBoolean (demands a
        Logical enum, i.e. text ".T.", ".F.", or ".U.")

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type flag: OCC.wrapper.StepData.StepData_Logical
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_StepReaderData_ReadLogical(self, *args)


    def ReadString(self, *args):
        """
        ReadString(StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach, Handle_TCollection_HAsciiString val) -> Standard_Boolean

        reads parameter <nump> of record <num> as a String (text
        between quotes, quotes are removed by the Read operation)
        Return value and Check managed as by ReadXY (demands a String)

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type val: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_StepReaderData_ReadString(self, *args)


    def ReadEnumParam(self, *args):
        """
        ReadEnumParam(StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach, Standard_CString & text) -> Standard_Boolean

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type text: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_StepReaderData_ReadEnumParam(self, *args)


    def FailEnumValue(self, *args):
        """
        FailEnumValue(StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach)

        Fills a check with a fail message if enumeration value does
        match parameter definition
        Just a help to centralize message definitions

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _StepData.StepData_StepReaderData_FailEnumValue(self, *args)


    def ReadEnum(self, *args):
        """
        ReadEnum(StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach, StepData_EnumTool enumtool) -> Standard_Boolean

        Reads parameter <nump> of record <num> as an Enumeration (text
        between dots) and converts it to an integer value, by an
        EnumTool. Returns True if OK, false if : this parameter is not
        enumeration, or is not recognized by the EnumTool (with fail)

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type enumtool: OCC.wrapper.StepData.StepData_EnumTool
        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_StepReaderData_ReadEnum(self, *args)


    def ReadTypedParam(self, *args):
        """
        ReadTypedParam(StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_Boolean const mustbetyped, Standard_CString const mess, Handle_Interface_Check ach, TCollection_AsciiString typ) -> Standard_Boolean

        Resolves a parameter which can be enclosed in a type def., as
        TYPE(val). The parameter must then be read normally according
        its type.  Parameter to be resolved is <nump> of record <num>
        <mustbetyped> True  demands a typed parameter
        <mustbetyped> False accepts a non-typed parameter as option
        mess and ach as usual
        <numr>,<numrp> are the resolved record and parameter numbers
        = num,nump if no type,  else numrp=1
        <typ> returns the recorded type, or empty string
        Remark : a non-typed list is considered as "non-typed"

        :type num: int
        :type nump: int
        :type mustbetyped: bool
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type numr: int
        :type numrp: int
        :type typ: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_StepReaderData_ReadTypedParam(self, *args)


    def CheckDerived(self, *args):
        """
        CheckDerived(StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach, Standard_Boolean const errstat) -> Standard_Boolean

        Checks if parameter <nump> of record <num> is given as Derived
        If this Check is successful (i.e. Param = "*"), returns True
        Else, fills <ach> with a Message which contains <mess> and
        returns False. According to <errstat>, this message is Warning
        if errstat is False (Default), Fail if errstat is True

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type errstat: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_StepReaderData_CheckDerived(self, *args)


    def NbEntities(self, *args):
        """
        NbEntities(StepData_StepReaderData self) -> Standard_Integer

        Returns total count of Entities (including Header)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_StepReaderData_NbEntities(self, *args)


    def FindNextRecord(self, *args):
        """
        FindNextRecord(StepData_StepReaderData self, Standard_Integer const num) -> Standard_Integer

        determines the first suitable record following a given one
        that is, skips SCOPE,ENDSCOPE and SUBLIST records
        Note : skips Header records, which are accessed separately

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_StepReaderData_FindNextRecord(self, *args)


    def SetEntityNumbers(self, *args):
        """
        SetEntityNumbers(StepData_StepReaderData self, Standard_Boolean const withmap)

        determines reference numbers in EntityNumber fields
        called by Prepare from StepReaderTool to prepare later using
        by a StepModel. This method is attached to StepReaderData
        because it needs a massive amount of data accesses to work

        If <withmap> is given False, the basic exploration algorithm
        is activated, otherwise a map is used as far as it is possible
        this option can be used only to test this algorithm

        :type withmap: bool

        """
        return _StepData.StepData_StepReaderData_SetEntityNumbers(self, *args)


    def FindNextHeaderRecord(self, *args):
        """
        FindNextHeaderRecord(StepData_StepReaderData self, Standard_Integer const num) -> Standard_Integer

        determine first suitable record of Header
        works as FindNextRecord, but treats only Header records

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_StepReaderData_FindNextHeaderRecord(self, *args)


    def PrepareHeader(self, *args):
        """
        PrepareHeader(StepData_StepReaderData self)

        Works as SetEntityNumbers but for Header : more simple because
        there are no Reference, only Sub-Lists


        """
        return _StepData.StepData_StepReaderData_PrepareHeader(self, *args)


    def GlobalCheck(self, *args):
        """
        GlobalCheck(StepData_StepReaderData self) -> Handle_Interface_Check

        Returns the Global Check. It can record Fail messages about
        Undefined References (detected by SetEntityNumbers)

        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _StepData.StepData_StepReaderData_GlobalCheck(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_StepReaderData_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_StepReaderData_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_StepReaderData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_StepReaderData
StepData_StepReaderData_swigregister = _StepData.StepData_StepReaderData_swigregister
StepData_StepReaderData_swigregister(StepData_StepReaderData)

def StepData_StepReaderData_get_type_name(*args):
    """
    StepData_StepReaderData_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_StepReaderData_get_type_name(*args)

def StepData_StepReaderData_get_type_descriptor(*args):
    """
    StepData_StepReaderData_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_StepReaderData_get_type_descriptor(*args)

class Handle_StepData_Described(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_Described self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_Described_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_Described self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_Described_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_Described self, StepData_Described thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_Described_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_Described self, Handle_StepData_Described theHandle) -> Handle_StepData_Described
        assign(Handle_StepData_Described self, StepData_Described thePtr) -> Handle_StepData_Described
        assign(Handle_StepData_Described self, Handle_StepData_Described theHandle) -> Handle_StepData_Described

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_Described_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_Described self) -> StepData_Described

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_Described_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_Described self) -> StepData_Described

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_Described___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_Described self) -> StepData_Described

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_Described___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_Described___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_Described___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_Described(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_Described_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_Described

    def Description(self, *args):
        """
        Description(Handle_StepData_Described self) -> Handle_StepData_EDescr

        Returns the Description used to define this entity

        :rtype: OCC.wrapper.StepData.Handle_StepData_EDescr

        """
        return _StepData.Handle_StepData_Described_Description(self, *args)


    def IsComplex(self, *args):
        """
        IsComplex(Handle_StepData_Described self) -> Standard_Boolean

        Tells if a described entity is complex

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_Described_IsComplex(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_StepData_Described self, Standard_CString const steptype) -> Standard_Boolean

        Tells if a step type is matched by <me>
        For a Simple Entity : own type or super type
        For a Complex Entity : one of the members

        :type steptype: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_Described_Matches(self, *args)


    def As(self, *args):
        """
        As(Handle_StepData_Described self, Standard_CString const steptype) -> Handle_StepData_Simple

        Returns a Simple Entity which matches with a Type in <me> :
        For a Simple Entity : me if it matches, else a null handle
        For a Complex Entity : the member which matches, else null

        :type steptype: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.StepData.Handle_StepData_Simple

        """
        return _StepData.Handle_StepData_Described_As(self, *args)


    def HasField(self, *args):
        """
        HasField(Handle_StepData_Described self, Standard_CString const name) -> Standard_Boolean

        Tells if a Field brings a given name

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_Described_HasField(self, *args)


    def Field(self, *args):
        """
        Returns a Field from its name; read-only

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        res = _StepData.Handle_StepData_Described_Field(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CField(self, *args):
        """
        CField(Handle_StepData_Described self, Standard_CString const name) -> StepData_Field

        Returns a Field from its name; read or write

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        return _StepData.Handle_StepData_Described_CField(self, *args)


    def Check(self, *args):
        """
        Check(Handle_StepData_Described self, Handle_Interface_Check ach)

        Fills a Check by using its Description

        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _StepData.Handle_StepData_Described_Check(self, *args)


    def Shared(self, *args):
        """
        Shared(Handle_StepData_Described self, Interface_EntityIterator list)

        Fills an EntityIterator with entities shared by <me>

        :type list: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.Handle_StepData_Described_Shared(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_Described self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_Described_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_Described_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_Described_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepData_Described self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_Described_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_Described self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_Described self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_Described_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_Described self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_Described self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_Described_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_Described self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_Described_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_Described self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_Described_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_Described self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_Described_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_Described self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_Described_DecrementRefCounter(self, *args)

Handle_StepData_Described_swigregister = _StepData.Handle_StepData_Described_swigregister
Handle_StepData_Described_swigregister(Handle_StepData_Described)

def Handle_StepData_Described_DownCast(thing):
    return _StepData.Handle_StepData_Described_DownCast(thing)
Handle_StepData_Described_DownCast = _StepData.Handle_StepData_Described_DownCast

class StepData_SelectArrReal(StepData_SelectNamed):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_SelectArrReal
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_SelectArrReal(self) 
            return h


    def __init__(self, *args):
        """__init__(StepData_SelectArrReal self) -> StepData_SelectArrReal"""
        this = _StepData.new_StepData_SelectArrReal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Kind(self, *args):
        """
        Kind(StepData_SelectArrReal self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_SelectArrReal_Kind(self, *args)


    def ArrReal(self, *args):
        """
        ArrReal(StepData_SelectArrReal self) -> Handle_TColStd_HArray1OfReal

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepData.StepData_SelectArrReal_ArrReal(self, *args)


    def SetArrReal(self, *args):
        """
        SetArrReal(StepData_SelectArrReal self, Handle_TColStd_HArray1OfReal arr)

        :type arr: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepData.StepData_SelectArrReal_SetArrReal(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_SelectArrReal_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_SelectArrReal_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_SelectArrReal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_SelectArrReal
StepData_SelectArrReal_swigregister = _StepData.StepData_SelectArrReal_swigregister
StepData_SelectArrReal_swigregister(StepData_SelectArrReal)

def StepData_SelectArrReal_get_type_name(*args):
    """
    StepData_SelectArrReal_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_SelectArrReal_get_type_name(*args)

def StepData_SelectArrReal_get_type_descriptor(*args):
    """
    StepData_SelectArrReal_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_SelectArrReal_get_type_descriptor(*args)

class Handle_StepData_DescrGeneral(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_DescrGeneral self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_DescrGeneral_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_DescrGeneral self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_DescrGeneral_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_DescrGeneral self, StepData_DescrGeneral thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_DescrGeneral_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_DescrGeneral self, Handle_StepData_DescrGeneral theHandle) -> Handle_StepData_DescrGeneral
        assign(Handle_StepData_DescrGeneral self, StepData_DescrGeneral thePtr) -> Handle_StepData_DescrGeneral
        assign(Handle_StepData_DescrGeneral self, Handle_StepData_DescrGeneral theHandle) -> Handle_StepData_DescrGeneral

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_DescrGeneral_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_DescrGeneral self) -> StepData_DescrGeneral

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_DescrGeneral_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_DescrGeneral self) -> StepData_DescrGeneral

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_DescrGeneral___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_DescrGeneral self) -> StepData_DescrGeneral

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_DescrGeneral___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_DescrGeneral___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_DescrGeneral___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_DescrGeneral(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_DescrGeneral_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_DescrGeneral

    def FillSharedCase(self, *args):
        """
        FillSharedCase(Handle_StepData_DescrGeneral self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.Handle_StepData_DescrGeneral_FillSharedCase(self, *args)


    def CheckCase(self, *args):
        """
        CheckCase(Handle_StepData_DescrGeneral self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_ShareTool shares, Handle_Interface_Check ach)

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type shares: OCC.wrapper.Interface.Interface_ShareTool
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _StepData.Handle_StepData_DescrGeneral_CheckCase(self, *args)


    def CopyCase(self, *args):
        """
        CopyCase(Handle_StepData_DescrGeneral self, Standard_Integer const CN, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC)

        :type CN: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _StepData.Handle_StepData_DescrGeneral_CopyCase(self, *args)


    def NewVoid(self, *args):
        """
        NewVoid(Handle_StepData_DescrGeneral self, Standard_Integer const CN, Handle_Standard_Transient ent) -> Standard_Boolean

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_DescrGeneral_NewVoid(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_DescrGeneral self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_DescrGeneral_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_DescrGeneral_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_DescrGeneral_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FillShared(self, *args):
        """
        FillShared(Handle_StepData_DescrGeneral self, Handle_Interface_InterfaceModel model, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        Specific filling of the list of Entities shared by an Entity
        <ent>, according a Case Number <CN> (formerly computed by
        CaseNum), considered in the context of a Model <model>
        Default calls FillSharedCase (i.e., ignores the model)
        Can be redefined to use the model for working

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.Handle_StepData_DescrGeneral_FillShared(self, *args)


    def Share(self, *args):
        """
        Share(Handle_StepData_DescrGeneral self, Interface_EntityIterator iter, Handle_Standard_Transient shared)

        Adds an Entity to a Shared List (uses GetOneItem on <iter>)

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator
        :type shared: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.Handle_StepData_DescrGeneral_Share(self, *args)


    def ListImplied(self, *args):
        """
        ListImplied(Handle_StepData_DescrGeneral self, Handle_Interface_InterfaceModel model, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        List the Implied References of <ent> considered in the context
        of a Model <model> : i.e. the Entities which are Referenced
        while not considered as Shared (not copied if <ent> is,
        references not renewed by CopyCase but by ImpliedCase, only
        if referenced Entities have been Copied too)
        FillShared + ListImplied give the complete list of References
        Default calls ListImpliedCase (i.e. ignores the model)
        Can be redefined to use the model for working

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.Handle_StepData_DescrGeneral_ListImplied(self, *args)


    def ListImpliedCase(self, *args):
        """
        ListImpliedCase(Handle_StepData_DescrGeneral self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        List the Implied References of <ent> (see above)
        are Referenced while not considered as Shared (not copied if
        <ent> is, references not renewed by CopyCase but by
        ImpliedCase, only if referenced Entities have been Copied too)
        FillSharedCase + ListImpliedCase give the complete list of
        Referenced Entities
        The provided default method does nothing (Implied References
        are specific of a little amount of Entity Classes).

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.Handle_StepData_DescrGeneral_ListImpliedCase(self, *args)


    def CanCopy(self, *args):
        """
        CanCopy(Handle_StepData_DescrGeneral self, Standard_Integer const CN, Handle_Standard_Transient ent) -> Standard_Boolean

        Specific answer to the question "is Copy properly implemented"
        Remark that it should be in phase with the implementation of
        NewVoid+CopyCase/NewCopyCase
        Default returns always False, can be redefined

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_DescrGeneral_CanCopy(self, *args)


    def Dispatch(self, *args):
        """
        Dispatch(Handle_StepData_DescrGeneral self, Standard_Integer const CN, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC) -> Standard_Boolean

        Dispatches an entity
        Returns True if it works by copy, False if it just duplicates
        the starting Handle

        Dispatching means producing a new entity, image of the
        starting one, in order to be put into a new Model, this Model
        being itself the result of a dispatch from an original Model

        According to the cases, dispatch can either
        * just return <entto> as equating <entfrom>
        -> the new model designates the starting entity : it is
        lighter, but the dispatched entity being shared might not be
        modified for dispatch
        * copy <entfrom> to <entto>
        by calling NewVoid+CopyCase (two steps) or NewCopiedCase (1)
        -> the dispatched entity is a COPY, hence it can be modified

        The provided default just duplicates the handle without
        copying, then returns False. Can be redefined

        :type CN: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_DescrGeneral_Dispatch(self, *args)


    def NewCopiedCase(self, *args):
        """
        NewCopiedCase(Handle_StepData_DescrGeneral self, Standard_Integer const CN, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC) -> Standard_Boolean

        Specific operator (create+copy) defaulted to do nothing.
        It can be redefined : When it is not possible to work in two
        steps (NewVoid then CopyCase). This can occur when there is
        no default constructor : hence the result <entto> must be
        created with an effective definition.
        Remark : if NewCopiedCase is defined, CopyCase has nothing to do
        Returns True if it has produced something, false else

        :type CN: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_DescrGeneral_NewCopiedCase(self, *args)


    def RenewImpliedCase(self, *args):
        """
        RenewImpliedCase(Handle_StepData_DescrGeneral self, Standard_Integer const CN, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC)

        Specific Copying of Implied References
        A Default is provided which does nothing (must current case !)
        Already copied references (by CopyFrom) must remain unchanged
        Use method Search from CopyTool to work

        :type CN: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _StepData.Handle_StepData_DescrGeneral_RenewImpliedCase(self, *args)


    def WhenDeleteCase(self, *args):
        """
        WhenDeleteCase(Handle_StepData_DescrGeneral self, Standard_Integer const CN, Handle_Standard_Transient ent, Standard_Boolean const dispatched)

        Prepares an entity to be deleted. What does it mean :
        Basically, any class of entity may define its own destructor
        By default, it does nothing but calling destructors on fields
        With the Memory Manager, it is useless to call destructor,
        it is done automatically when the Handle is nullified(cleared)
        BUT this is ineffective in looping structures (whatever these
        are "Implied" references or not).

        THUS : if no loop may appear in definitions, a class which
        inherits from TShared is correctly managed by automatic way
        BUT if there can be loops (or simply back pointers), they must
        be broken, for instance by clearing fields of one of the nodes
        The default does nothing, to be redefined if a loop can occur
        (Implied generally requires WhenDelete, but other cases can
        occur)

        Warning : <dispatched> tells if the entity to be deleted has been
        produced by Dispatch or not. Hence WhenDelete must be in
        coherence with Dispatch
        Dispatch can either copy or not.
        If it copies the entity, this one should be deleted
        If it doesnt (i.e. duplicates the handle) nothing to do

        If <dispatch> is False, normal deletion is to be performed

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type dispatched: bool

        """
        return _StepData.Handle_StepData_DescrGeneral_WhenDeleteCase(self, *args)


    def CategoryNumber(self, *args):
        """
        CategoryNumber(Handle_StepData_DescrGeneral self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_ShareTool shares) -> Standard_Integer

        Returns a category number which characterizes an entity
        Category Numbers are managed by the class Category
        <shares> can be used to evaluate this number in the context
        Default returns 0 which means "unspecified"

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type shares: OCC.wrapper.Interface.Interface_ShareTool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_DescrGeneral_CategoryNumber(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepData_DescrGeneral self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_ShareTool shares) -> Handle_TCollection_HAsciiString

        Determines if an entity brings a Name (or widerly, if a Name
        can be attached to it, through the ShareTool
        By default, returns a Null Handle (no name can be produced)
        Can be redefined

        Warning : While this string may be edited on the spot, if it is a read
        field, the returned value must be copied before.

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type shares: OCC.wrapper.Interface.Interface_ShareTool
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepData.Handle_StepData_DescrGeneral_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepData_DescrGeneral self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_DescrGeneral_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_DescrGeneral self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_DescrGeneral self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_DescrGeneral_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_DescrGeneral self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_DescrGeneral self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_DescrGeneral_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_DescrGeneral self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_DescrGeneral_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_DescrGeneral self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_DescrGeneral_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_DescrGeneral self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_DescrGeneral_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_DescrGeneral self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_DescrGeneral_DecrementRefCounter(self, *args)

Handle_StepData_DescrGeneral_swigregister = _StepData.Handle_StepData_DescrGeneral_swigregister
Handle_StepData_DescrGeneral_swigregister(Handle_StepData_DescrGeneral)

def Handle_StepData_DescrGeneral_DownCast(thing):
    return _StepData.Handle_StepData_DescrGeneral_DownCast(thing)
Handle_StepData_DescrGeneral_DownCast = _StepData.Handle_StepData_DescrGeneral_DownCast

class StepData_FieldListN(StepData_FieldList):
    """
    Describes a list of fields, in a general way
    This basic class is for a null size list
    Subclasses are for 1, N (fixed) or Dynamic sizes
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepData_FieldListN self, Standard_Integer const nb) -> StepData_FieldListN

        Creates a FieldListN of <nb> Fields

        :type nb: int

        """
        this = _StepData.new_StepData_FieldListN(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbFields(self, *args):
        """
        NbFields(StepData_FieldListN self) -> Standard_Integer

        Returns the count of fields. Here, returns starting <nb>

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_FieldListN_NbFields(self, *args)


    def Field(self, *args):
        """
        Returns the field n0 <num> between 1 and NbFields (read only)

        :type num: int
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        res = _StepData.StepData_FieldListN_Field(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CField(self, *args):
        """
        CField(StepData_FieldListN self, Standard_Integer const num) -> StepData_Field

        Returns the field n0 <num> between 1 and NbFields, in order to
        modify its content

        :type num: int
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        return _StepData.StepData_FieldListN_CField(self, *args)

    __swig_destroy__ = _StepData.delete_StepData_FieldListN
StepData_FieldListN_swigregister = _StepData.StepData_FieldListN_swigregister
StepData_FieldListN_swigregister(StepData_FieldListN)

class Handle_StepData_NodeOfWriterLib(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_NodeOfWriterLib self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_NodeOfWriterLib_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_NodeOfWriterLib self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_NodeOfWriterLib_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_NodeOfWriterLib self, StepData_NodeOfWriterLib thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_NodeOfWriterLib_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_NodeOfWriterLib self, Handle_StepData_NodeOfWriterLib theHandle) -> Handle_StepData_NodeOfWriterLib
        assign(Handle_StepData_NodeOfWriterLib self, StepData_NodeOfWriterLib thePtr) -> Handle_StepData_NodeOfWriterLib
        assign(Handle_StepData_NodeOfWriterLib self, Handle_StepData_NodeOfWriterLib theHandle) -> Handle_StepData_NodeOfWriterLib

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_NodeOfWriterLib_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_NodeOfWriterLib self) -> StepData_NodeOfWriterLib

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_NodeOfWriterLib_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_NodeOfWriterLib self) -> StepData_NodeOfWriterLib

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_NodeOfWriterLib___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_NodeOfWriterLib self) -> StepData_NodeOfWriterLib

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_NodeOfWriterLib___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_NodeOfWriterLib___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_NodeOfWriterLib___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_NodeOfWriterLib(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_NodeOfWriterLib_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_NodeOfWriterLib

    def AddNode(self, *args):
        """
        AddNode(Handle_StepData_NodeOfWriterLib self, Handle_StepData_GlobalNodeOfWriterLib anode)

        Adds a couple (Module,Protocol), that is, stores it into
        itself if not yet done, else creates a Next Node to do it

        :type anode: OCC.wrapper.StepData.Handle_StepData_GlobalNodeOfWriterLib

        """
        return _StepData.Handle_StepData_NodeOfWriterLib_AddNode(self, *args)


    def Module(self, *args):
        """
        Returns the Module designated by a precise Node

        :rtype: OCC.wrapper.StepData.Handle_StepData_ReadWriteModule

        """
        res = _StepData.Handle_StepData_NodeOfWriterLib_Module(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Protocol(self, *args):
        """
        Returns the Protocol designated by a precise Node

        :rtype: OCC.wrapper.StepData.Handle_StepData_Protocol

        """
        res = _StepData.Handle_StepData_NodeOfWriterLib_Protocol(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Next(self, *args):
        """
        Returns the Next Node. If none was defined, returned value
        is a Null Handle

        :rtype: OCC.wrapper.StepData.Handle_StepData_NodeOfWriterLib

        """
        res = _StepData.Handle_StepData_NodeOfWriterLib_Next(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_NodeOfWriterLib self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_NodeOfWriterLib_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_NodeOfWriterLib_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_NodeOfWriterLib_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepData_NodeOfWriterLib self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_NodeOfWriterLib_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_NodeOfWriterLib self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_NodeOfWriterLib self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_NodeOfWriterLib_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_NodeOfWriterLib self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_NodeOfWriterLib self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_NodeOfWriterLib_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_NodeOfWriterLib self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_NodeOfWriterLib_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_NodeOfWriterLib self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_NodeOfWriterLib_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_NodeOfWriterLib self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_NodeOfWriterLib_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_NodeOfWriterLib self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_NodeOfWriterLib_DecrementRefCounter(self, *args)

Handle_StepData_NodeOfWriterLib_swigregister = _StepData.Handle_StepData_NodeOfWriterLib_swigregister
Handle_StepData_NodeOfWriterLib_swigregister(Handle_StepData_NodeOfWriterLib)

def Handle_StepData_NodeOfWriterLib_DownCast(thing):
    return _StepData.Handle_StepData_NodeOfWriterLib_DownCast(thing)
Handle_StepData_NodeOfWriterLib_DownCast = _StepData.Handle_StepData_NodeOfWriterLib_DownCast

class StepData_StepWriter(object):
    """
    manages atomic file writing, under control of StepModel (for
    general organisation of file) and each class of Transient
    (for its own parameters) : prepares text to be written then
    writes it
    A stream cannot be used because Step limits line length at 72
    In more, a specific object offers more appropriate functions
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepData_StepWriter self, Handle_StepData_StepModel amodel) -> StepData_StepWriter

        Creates an empty StepWriter from a StepModel. The StepModel
        provides the Number of Entities, as identifiers for File

        :type amodel: OCC.wrapper.StepData.Handle_StepData_StepModel

        """
        this = _StepData.new_StepData_StepWriter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def LabelMode(self, *args):
        """
        LabelMode(StepData_StepWriter self) -> Standard_Integer &

        ModeLabel controls how to display entity ids :
        0 (D) gives entity number in the model
        1 gives the already recorded label (else, its number)
        Warning : conflicts are not controlled

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_StepWriter_LabelMode(self, *args)


    def TypeMode(self, *args):
        """
        TypeMode(StepData_StepWriter self) -> Standard_Integer &

        TypeMode  controls the type form to use :
        0 (D) for normal long form
        1 for short form (if a type name has no short form, normal
        long form is then used)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_StepWriter_TypeMode(self, *args)


    def FloatWriter(self, *args):
        """
        FloatWriter(StepData_StepWriter self) -> Interface_FloatWriter

        Returns the embedded FloatWriter, which controls sending Reals
        Use this method to access FloatWriter in order to consult or
        change its options (MainFormat, FormatForRange,ZeroSuppress),
        because it is returned as the address of its field

        :rtype: OCC.wrapper.Interface.Interface_FloatWriter

        """
        return _StepData.StepData_StepWriter_FloatWriter(self, *args)


    def SetScope(self, *args):
        """
        SetScope(StepData_StepWriter self, Standard_Integer const numscope, Standard_Integer const numin)

        Declares the Entity Number <numscope> to correspond to a Scope
        which contains the Entity Number <numin>. Several calls to the
        same <numscope> add Entities in this Scope, in this order.
        Error if <numin> is already declared in the Scope
        Warning : the declaration of the Scopes is assumed to be consistent,
        i.e. <numin> is not referenced from outside this Scope
        (not checked here)

        :type numscope: int
        :type numin: int

        """
        return _StepData.StepData_StepWriter_SetScope(self, *args)


    def IsInScope(self, *args):
        """
        IsInScope(StepData_StepWriter self, Standard_Integer const num) -> Standard_Boolean

        Returns True if an Entity identified by its Number is in a Scope

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_StepWriter_IsInScope(self, *args)


    def SendModel(self, *args):
        """
        SendModel(StepData_StepWriter self, Handle_StepData_Protocol protocol, Standard_Boolean const headeronly)

        Sends the complete Model, included HEADER and DATA Sections
        Works with a WriterLib defined through a Protocol
        If <headeronly> is given True, only the HEADER Section is sent
        (used to Dump the Header of a StepModel)

        :type protocol: OCC.wrapper.StepData.Handle_StepData_Protocol
        :type headeronly: bool

        """
        return _StepData.StepData_StepWriter_SendModel(self, *args)


    def SendHeader(self, *args):
        """
        SendHeader(StepData_StepWriter self)

        Begins model header


        """
        return _StepData.StepData_StepWriter_SendHeader(self, *args)


    def SendData(self, *args):
        """
        SendData(StepData_StepWriter self)

        Begins data section; error if EndSec was not set


        """
        return _StepData.StepData_StepWriter_SendData(self, *args)


    def SendEntity(self, *args):
        """
        SendEntity(StepData_StepWriter self, Standard_Integer const nument, StepData_WriterLib lib)

        Send an Entity of the Data Section. If it corresponds to a
        Scope, also Sends the Scope informations and contained Items

        :type nument: int
        :type lib: OCC.wrapper.StepData.StepData_WriterLib

        """
        return _StepData.StepData_StepWriter_SendEntity(self, *args)


    def EndSec(self, *args):
        """
        EndSec(StepData_StepWriter self)

        sets end of section; to be done before passing to next one


        """
        return _StepData.StepData_StepWriter_EndSec(self, *args)


    def EndFile(self, *args):
        """
        EndFile(StepData_StepWriter self)

        sets end of file; error is EndSec was not set


        """
        return _StepData.StepData_StepWriter_EndFile(self, *args)


    def NewLine(self, *args):
        """
        NewLine(StepData_StepWriter self, Standard_Boolean const evenempty)

        flushes current line; if empty, flushes it (defines a new
        empty line) if evenempty is True; else, skips it

        :type evenempty: bool

        """
        return _StepData.StepData_StepWriter_NewLine(self, *args)


    def JoinLast(self, *args):
        """
        JoinLast(StepData_StepWriter self, Standard_Boolean const newline)

        joins current line to last one, only if new length is 72 max
        if newline is True, a new current line begins; else, current
        line is set to the last line (once joined) itself an can be
        completed

        :type newline: bool

        """
        return _StepData.StepData_StepWriter_JoinLast(self, *args)


    def Indent(self, *args):
        """
        Indent(StepData_StepWriter self, Standard_Boolean const onent)

        asks that further indentations will begin at position of
        entity first opening bracket; else they begin at zero (def)
        for each sublist level, two more blancks are added at beginning
        (except for text continuation, which must begin at true zero)

        :type onent: bool

        """
        return _StepData.StepData_StepWriter_Indent(self, *args)


    def SendIdent(self, *args):
        """
        SendIdent(StepData_StepWriter self, Standard_Integer const ident)

        begins an entity with an ident plus '=' (at beginning of line)
        entity ident is its Number given by the containing Model
        Warning : <ident> must be, either Number or Label, according LabelMode

        :type ident: int

        """
        return _StepData.StepData_StepWriter_SendIdent(self, *args)


    def SendScope(self, *args):
        """
        SendScope(StepData_StepWriter self)

        sets a begin of Scope (ends this line)


        """
        return _StepData.StepData_StepWriter_SendScope(self, *args)


    def SendEndscope(self, *args):
        """
        SendEndscope(StepData_StepWriter self)

        sets an end of Scope  (on a separate line)


        """
        return _StepData.StepData_StepWriter_SendEndscope(self, *args)


    def Comment(self, *args):
        """
        Comment(StepData_StepWriter self, Standard_Boolean const mode)

        sets a comment mark : if mode is True, begins Comment zone,
        if mode is False, ends Comment zone (if one is begun)

        :type mode: bool

        """
        return _StepData.StepData_StepWriter_Comment(self, *args)


    def SendComment(self, *args):
        """
        SendComment(StepData_StepWriter self, Handle_TCollection_HAsciiString text)
        SendComment(StepData_StepWriter self, Standard_CString const text)

        same as above but accepts a CString (ex.: "..." directly)

        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_StepWriter_SendComment(self, *args)


    def StartEntity(self, *args):
        """
        StartEntity(StepData_StepWriter self, TCollection_AsciiString atype)

        sets entity's StepType, opens brakets, starts param no to 0
        params are separated by comma
        Remark : for a Multiple Type Entity (see Express ANDOR clause)
        StartComplex must be called before sending componants, then
        each "Componant" must be send separately (one call to
        StartEntity for each one) : the Type which preceeds is then
        automaticaly closed. Once all the componants have been sent,
        EndComplex must be called, then and only then EndEntity

        :type atype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _StepData.StepData_StepWriter_StartEntity(self, *args)


    def StartComplex(self, *args):
        """
        StartComplex(StepData_StepWriter self)

        sends the start of a complex entity, which is a simple open
        bracket (without increasing braket level)
        It must be called JUST AFTER SendEntity and BEFORE sending
        componants, each one begins by StartEntity


        """
        return _StepData.StepData_StepWriter_StartComplex(self, *args)


    def EndComplex(self, *args):
        """
        EndComplex(StepData_StepWriter self)

        sends the end of a complex entity : a simple closed bracket
        It must be called AFTER sending all the componants and BEFORE
        the final call to EndEntity


        """
        return _StepData.StepData_StepWriter_EndComplex(self, *args)


    def SendField(self, *args):
        """
        SendField(StepData_StepWriter self, StepData_Field fild, Handle_StepData_PDescr descr)

        Sends the content of a field, controlled by its descriptor
        If the descriptor is not defined, follows the description
        detained by the field itself

        :type fild: OCC.wrapper.StepData.StepData_Field
        :type descr: OCC.wrapper.StepData.Handle_StepData_PDescr

        """
        return _StepData.StepData_StepWriter_SendField(self, *args)


    def SendSelect(self, *args):
        """
        SendSelect(StepData_StepWriter self, Handle_StepData_SelectMember sm, Handle_StepData_PDescr descr)

        Sends a SelectMember, which cab be named or not

        :type sm: OCC.wrapper.StepData.Handle_StepData_SelectMember
        :type descr: OCC.wrapper.StepData.Handle_StepData_PDescr

        """
        return _StepData.StepData_StepWriter_SendSelect(self, *args)


    def SendList(self, *args):
        """
        SendList(StepData_StepWriter self, StepData_FieldList list, Handle_StepData_ESDescr descr)

        Send the content of an entity as being a FieldList controlled
        by its descriptor. This includes start and end brackets but
        not the entity type

        :type list: OCC.wrapper.StepData.StepData_FieldList
        :type descr: OCC.wrapper.StepData.Handle_StepData_ESDescr

        """
        return _StepData.StepData_StepWriter_SendList(self, *args)


    def OpenSub(self, *args):
        """
        OpenSub(StepData_StepWriter self)

        open a sublist by a '('


        """
        return _StepData.StepData_StepWriter_OpenSub(self, *args)


    def OpenTypedSub(self, *args):
        """
        OpenTypedSub(StepData_StepWriter self, Standard_CString const subtype)

        open a sublist with its type then a '('

        :type subtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_StepWriter_OpenTypedSub(self, *args)


    def CloseSub(self, *args):
        """
        CloseSub(StepData_StepWriter self)

        closes a sublist by a ')'


        """
        return _StepData.StepData_StepWriter_CloseSub(self, *args)


    def AddParam(self, *args):
        """
        AddParam(StepData_StepWriter self)

        prepares adding a parameter (that is, adds ',' except for
        first one); normally for internal use; can be used to send
        a totally empty parameter (with no litteral value)


        """
        return _StepData.StepData_StepWriter_AddParam(self, *args)


    def Send(self, *args):
        """
        Send(StepData_StepWriter self, Standard_Integer const val)
        Send(StepData_StepWriter self, Standard_Real const val)
        Send(StepData_StepWriter self, TCollection_AsciiString val)
        Send(StepData_StepWriter self, Handle_Standard_Transient val)

        sends a reference to an entity (its identifier with '#')
        REMARK 1 : a Null <val> is interpreted as "Undefined"
        REMARK 2 : for an HAsciiString which is not recorded in the
        Model, it is send as its String Content, between quotes

        :type val: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.StepData_StepWriter_Send(self, *args)


    def SendBoolean(self, *args):
        """
        SendBoolean(StepData_StepWriter self, Standard_Boolean const val)

        sends a Boolean as .T. for True or .F. for False
        (it is an useful case of Enum, which is built-in)

        :type val: bool

        """
        return _StepData.StepData_StepWriter_SendBoolean(self, *args)


    def SendLogical(self, *args):
        """
        SendLogical(StepData_StepWriter self, StepData_Logical const val)

        sends a Logical as .T. or .F. or .U. according its Value
        (it is a standard case of Enum for Step, and is built-in)

        :type val: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepData.StepData_StepWriter_SendLogical(self, *args)


    def SendString(self, *args):
        """
        SendString(StepData_StepWriter self, TCollection_AsciiString val)
        SendString(StepData_StepWriter self, Standard_CString const val)

        sends a string exactly as it is given

        :type val: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_StepWriter_SendString(self, *args)


    def SendEnum(self, *args):
        """
        SendEnum(StepData_StepWriter self, TCollection_AsciiString val)
        SendEnum(StepData_StepWriter self, Standard_CString const val)

        sends an enum given by String (litteral expression)
        adds '.' around it if not done

        :type val: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_StepWriter_SendEnum(self, *args)


    def SendArrReal(self, *args):
        """
        SendArrReal(StepData_StepWriter self, Handle_TColStd_HArray1OfReal anArr)

        sends an array of real

        :type anArr: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepData.StepData_StepWriter_SendArrReal(self, *args)


    def SendUndef(self, *args):
        """
        SendUndef(StepData_StepWriter self)

        sends an undefined (optionnal absent) parameter (by '$')


        """
        return _StepData.StepData_StepWriter_SendUndef(self, *args)


    def SendDerived(self, *args):
        """
        SendDerived(StepData_StepWriter self)

        sends a "Derived" parameter (by '*'). A Derived Parameter has
        been inherited from a Super-Type then redefined as being
        computed by a function. Hence its value in file is senseless.


        """
        return _StepData.StepData_StepWriter_SendDerived(self, *args)


    def EndEntity(self, *args):
        """
        EndEntity(StepData_StepWriter self)

        sends end of entity (closing bracket plus ';')
        Error if count of opened-closed brackets is not null


        """
        return _StepData.StepData_StepWriter_EndEntity(self, *args)


    def CheckList(self, *args):
        """
        CheckList(StepData_StepWriter self) -> Interface_CheckIterator

        Returns the check-list, which has received possible checks :
        for unknown entities, badly loaded ones, null or unknown
        references

        :rtype: OCC.wrapper.Interface.Interface_CheckIterator

        """
        return _StepData.StepData_StepWriter_CheckList(self, *args)


    def NbLines(self, *args):
        """
        NbLines(StepData_StepWriter self) -> Standard_Integer

        Returns count of Lines

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_StepWriter_NbLines(self, *args)


    def Line(self, *args):
        """
        Line(StepData_StepWriter self, Standard_Integer const num) -> Handle_TCollection_HAsciiString

        Returns a Line given its rank in the File

        :type num: int
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepData.StepData_StepWriter_Line(self, *args)


    def Print(self, *args):
        """
        Print(StepData_StepWriter self, Standard_OStream & S) -> Standard_Boolean

        writes result on an output defined as an OStream
        then clears it

        :type S: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_StepWriter_Print(self, *args)

    __swig_destroy__ = _StepData.delete_StepData_StepWriter
StepData_StepWriter_swigregister = _StepData.StepData_StepWriter_swigregister
StepData_StepWriter_swigregister(StepData_StepWriter)

class StepData_FileRecognizer(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_FileRecognizer
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_FileRecognizer(self) 
            return h


    def Evaluate(self, *args):
        """
        Evaluate(StepData_FileRecognizer self, TCollection_AsciiString akey, Handle_Standard_Transient res) -> Standard_Boolean

        Evaluates if recognition has a result, returns it if yes
        In case of success, Returns True and puts result in "res"
        In case of Failure, simply Returns False
        Works by calling deferred method Eval, and in case of failure,
        looks for Added Recognizers to work

        :type akey: OCC.wrapper.TCollection.TCollection_AsciiString
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_FileRecognizer_Evaluate(self, *args)


    def Result(self, *args):
        """
        Result(StepData_FileRecognizer self) -> Handle_Standard_Transient

        Returns result of last recognition (call of Evaluate)

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.StepData_FileRecognizer_Result(self, *args)


    def Add(self, *args):
        """
        Add(StepData_FileRecognizer self, Handle_StepData_FileRecognizer reco)

        Adds a new Recognizer to the Compound, at the end
        Several calls to Add work by adding in the order of calls :
        Hence, when Eval has failed to recognize, Evaluate will call
        Evaluate from the first added Recognizer if there is one,
        and to the second if there is still no result, and so on

        :type reco: OCC.wrapper.StepData.Handle_StepData_FileRecognizer

        """
        return _StepData.StepData_FileRecognizer_Add(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_FileRecognizer_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_FileRecognizer_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_FileRecognizer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_FileRecognizer
StepData_FileRecognizer_swigregister = _StepData.StepData_FileRecognizer_swigregister
StepData_FileRecognizer_swigregister(StepData_FileRecognizer)

def StepData_FileRecognizer_get_type_name(*args):
    """
    StepData_FileRecognizer_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_FileRecognizer_get_type_name(*args)

def StepData_FileRecognizer_get_type_descriptor(*args):
    """
    StepData_FileRecognizer_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_FileRecognizer_get_type_descriptor(*args)

class Handle_StepData_FileProtocol(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_FileProtocol self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_FileProtocol_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_FileProtocol self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_FileProtocol_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_FileProtocol self, StepData_FileProtocol thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_FileProtocol_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_FileProtocol self, Handle_StepData_FileProtocol theHandle) -> Handle_StepData_FileProtocol
        assign(Handle_StepData_FileProtocol self, StepData_FileProtocol thePtr) -> Handle_StepData_FileProtocol
        assign(Handle_StepData_FileProtocol self, Handle_StepData_FileProtocol theHandle) -> Handle_StepData_FileProtocol

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_FileProtocol_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_FileProtocol self) -> StepData_FileProtocol

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_FileProtocol_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_FileProtocol self) -> StepData_FileProtocol

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_FileProtocol___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_FileProtocol self) -> StepData_FileProtocol

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_FileProtocol___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_FileProtocol___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_FileProtocol___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_FileProtocol(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_FileProtocol_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_FileProtocol

    def Add(self, *args):
        """
        Add(Handle_StepData_FileProtocol self, Handle_StepData_Protocol protocol)

        Adds a Protocol to the definition list of the FileProtocol
        But ensures that each class of Protocol is present only once
        in this list

        :type protocol: OCC.wrapper.StepData.Handle_StepData_Protocol

        """
        return _StepData.Handle_StepData_FileProtocol_Add(self, *args)


    def NbResources(self, *args):
        """
        NbResources(Handle_StepData_FileProtocol self) -> Standard_Integer

        Gives the count of Protocols used as Resource (can be zero)
        i.e. the count of Protocol recorded by calling the method Add

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_FileProtocol_NbResources(self, *args)


    def Resource(self, *args):
        """
        Resource(Handle_StepData_FileProtocol self, Standard_Integer const num) -> Handle_Interface_Protocol

        Returns a Resource, given a rank. Here, rank of calling Add

        :type num: int
        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _StepData.Handle_StepData_FileProtocol_Resource(self, *args)


    def TypeNumber(self, *args):
        """
        TypeNumber(Handle_StepData_FileProtocol self, Handle_Standard_Type atype) -> Standard_Integer

        Returns a Case Number, specific of each recognized Type
        Here, NO Type at all is recognized properly : all Types are
        recognized by the resources

        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_FileProtocol_TypeNumber(self, *args)


    def GlobalCheck(self, *args):
        """
        GlobalCheck(Handle_StepData_FileProtocol self, Interface_Graph G, Handle_Interface_Check ach) -> Standard_Boolean

        Calls GlobalCheck for each of its recorded ressources

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_FileProtocol_GlobalCheck(self, *args)


    def SchemaName(self, *args):
        """
        SchemaName(Handle_StepData_FileProtocol self) -> Standard_CString

        Returns the Schema Name attached to each class of Protocol
        To be redefined by each sub-class
        Here, SchemaName returns "" (empty String)
        was C++ : return const

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_FileProtocol_SchemaName(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_FileProtocol self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_FileProtocol_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_FileProtocol_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_FileProtocol_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CaseNumber(self, *args):
        """
        CaseNumber(Handle_StepData_FileProtocol self, Handle_Standard_Transient obj) -> Standard_Integer

        Returns a unique positive number for any recognized entity
        Redefined to work by calling both TypeNumber and, for a
        Described Entity (late binding) DescrNumber

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_FileProtocol_CaseNumber(self, *args)


    def NewModel(self, *args):
        """
        NewModel(Handle_StepData_FileProtocol self) -> Handle_Interface_InterfaceModel

        Creates an empty Model for Step Norm

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _StepData.Handle_StepData_FileProtocol_NewModel(self, *args)


    def IsSuitableModel(self, *args):
        """
        IsSuitableModel(Handle_StepData_FileProtocol self, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns True if <model> is a Model of Step Norm

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_FileProtocol_IsSuitableModel(self, *args)


    def UnknownEntity(self, *args):
        """
        UnknownEntity(Handle_StepData_FileProtocol self) -> Handle_Standard_Transient

        Creates a new Unknown Entity for Step (UndefinedEntity)

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.Handle_StepData_FileProtocol_UnknownEntity(self, *args)


    def IsUnknownEntity(self, *args):
        """
        IsUnknownEntity(Handle_StepData_FileProtocol self, Handle_Standard_Transient ent) -> Standard_Boolean

        Returns True if <ent> is an Unknown Entity for the Norm, i.e.
        Type UndefinedEntity, status Unknown

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_FileProtocol_IsUnknownEntity(self, *args)


    def DescrNumber(self, *args):
        """
        DescrNumber(Handle_StepData_FileProtocol self, Handle_StepData_EDescr adescr) -> Standard_Integer

        Returns a unique positive CaseNumber for types described by
        an EDescr (late binding)
        Warning : TypeNumber and DescrNumber must give together a unique
        positive case number for each distinct case, type or descr

        :type adescr: OCC.wrapper.StepData.Handle_StepData_EDescr
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_FileProtocol_DescrNumber(self, *args)


    def AddDescr(self, *args):
        """
        AddDescr(Handle_StepData_FileProtocol self, Handle_StepData_EDescr adescr, Standard_Integer const CN)

        Records an EDescr with its case number
        Also records its name for an ESDescr (simple type): an ESDescr
        is then used, for case number, or for type name

        :type adescr: OCC.wrapper.StepData.Handle_StepData_EDescr
        :type CN: int

        """
        return _StepData.Handle_StepData_FileProtocol_AddDescr(self, *args)


    def HasDescr(self, *args):
        """
        HasDescr(Handle_StepData_FileProtocol self) -> Standard_Boolean

        Tells if a Protocol brings at least one ESDescr, i.e. if it
        defines at least one entity description by ESDescr mechanism

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_FileProtocol_HasDescr(self, *args)


    def Descr(self, *args):
        """
        Descr(Handle_StepData_FileProtocol self, Standard_Integer const num) -> Handle_StepData_EDescr
        Descr(Handle_StepData_FileProtocol self, Standard_CString const name, Standard_Boolean const anylevel) -> Handle_StepData_EDescr

        Returns a description according to its name
        <anylevel> True (D) : for <me> and its resources
        <anylevel> False : for <me> only

        :type name: OCC.wrapper.Standard.Standard_CString
        :type anylevel: bool
        :rtype: OCC.wrapper.StepData.Handle_StepData_EDescr

        """
        return _StepData.Handle_StepData_FileProtocol_Descr(self, *args)


    def ESDescr(self, *args):
        """
        ESDescr(Handle_StepData_FileProtocol self, Standard_CString const name, Standard_Boolean const anylevel) -> Handle_StepData_ESDescr

        Idem as Descr but cast to simple description

        :type name: OCC.wrapper.Standard.Standard_CString
        :type anylevel: bool
        :rtype: OCC.wrapper.StepData.Handle_StepData_ESDescr

        """
        return _StepData.Handle_StepData_FileProtocol_ESDescr(self, *args)


    def ECDescr(self, *args):
        """
        ECDescr(Handle_StepData_FileProtocol self, NCollection_Sequence_TCollection_AsciiString names, Standard_Boolean const anylevel) -> Handle_StepData_ECDescr

        Returns a complex description according to list of names
        <anylevel> True (D) : for <me> and its resources
        <anylevel> False : for <me> only

        :type names: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString
        :type anylevel: bool
        :rtype: OCC.wrapper.StepData.Handle_StepData_ECDescr

        """
        return _StepData.Handle_StepData_FileProtocol_ECDescr(self, *args)


    def AddPDescr(self, *args):
        """
        AddPDescr(Handle_StepData_FileProtocol self, Handle_StepData_PDescr pdescr)

        Records an PDescr

        :type pdescr: OCC.wrapper.StepData.Handle_StepData_PDescr

        """
        return _StepData.Handle_StepData_FileProtocol_AddPDescr(self, *args)


    def PDescr(self, *args):
        """
        PDescr(Handle_StepData_FileProtocol self, Standard_CString const name, Standard_Boolean const anylevel) -> Handle_StepData_PDescr

        Returns a parameter description according to its name
        <anylevel> True (D) : for <me> and its resources
        <anylevel> False : for <me> only

        :type name: OCC.wrapper.Standard.Standard_CString
        :type anylevel: bool
        :rtype: OCC.wrapper.StepData.Handle_StepData_PDescr

        """
        return _StepData.Handle_StepData_FileProtocol_PDescr(self, *args)


    def AddBasicDescr(self, *args):
        """
        AddBasicDescr(Handle_StepData_FileProtocol self, Handle_StepData_ESDescr esdescr)

        Records an ESDescr, intended to build complex descriptions

        :type esdescr: OCC.wrapper.StepData.Handle_StepData_ESDescr

        """
        return _StepData.Handle_StepData_FileProtocol_AddBasicDescr(self, *args)


    def BasicDescr(self, *args):
        """
        BasicDescr(Handle_StepData_FileProtocol self, Standard_CString const name, Standard_Boolean const anylevel) -> Handle_StepData_EDescr

        Returns a basic description according to its name
        <anylevel> True (D) : for <me> and its resources
        <anylevel> False : for <me> only

        :type name: OCC.wrapper.Standard.Standard_CString
        :type anylevel: bool
        :rtype: OCC.wrapper.StepData.Handle_StepData_EDescr

        """
        return _StepData.Handle_StepData_FileProtocol_BasicDescr(self, *args)


    def Active(self, *args):
        """
        Active(Handle_StepData_FileProtocol self) -> Handle_Interface_Protocol

        Returns the Active Protocol, if defined (else, returns a
        Null Handle, which means "no defined active protocol")

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _StepData.Handle_StepData_FileProtocol_Active(self, *args)


    def SetActive(self, *args):
        """
        SetActive(Handle_StepData_FileProtocol self, Handle_Interface_Protocol aprotocol)

        Sets a given Protocol to be the Active one (for the users of
        Active, see just above). Applies to every sub-type of Protocol

        :type aprotocol: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _StepData.Handle_StepData_FileProtocol_SetActive(self, *args)


    def ClearActive(self, *args):
        """
        ClearActive(Handle_StepData_FileProtocol self)

        Erases the Active Protocol (hence it becomes undefined)


        """
        return _StepData.Handle_StepData_FileProtocol_ClearActive(self, *args)


    def IsDynamicType(self, *args):
        """
        IsDynamicType(Handle_StepData_FileProtocol self, Handle_Standard_Transient obj) -> Standard_Boolean

        Returns True if type of <obj> is that defined from CDL
        This is the default but it may change according implementation

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_FileProtocol_IsDynamicType(self, *args)


    def NbTypes(self, *args):
        """
        NbTypes(Handle_StepData_FileProtocol self, Handle_Standard_Transient obj) -> Standard_Integer

        Returns the count of DISTINCT types under which an entity may
        be processed. Each one is candidate to be recognized by
        TypeNumber, <obj> is then processed according it
        By default, returns 1 (the DynamicType)

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_FileProtocol_NbTypes(self, *args)


    def Type(self, *args):
        """
        Type(Handle_StepData_FileProtocol self, Handle_Standard_Transient obj, Standard_Integer const nt=1) -> Handle_Standard_Type

        Returns a type under which <obj> can be recognized and
        processed, according its rank in its definition list (see
        NbTypes).
        By default, returns DynamicType

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :type nt: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.Handle_StepData_FileProtocol_Type(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepData_FileProtocol self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_FileProtocol_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_FileProtocol self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_FileProtocol self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_FileProtocol_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_FileProtocol self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_FileProtocol self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_FileProtocol_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_FileProtocol self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_FileProtocol_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_FileProtocol self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_FileProtocol_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_FileProtocol self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_FileProtocol_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_FileProtocol self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_FileProtocol_DecrementRefCounter(self, *args)

Handle_StepData_FileProtocol_swigregister = _StepData.Handle_StepData_FileProtocol_swigregister
Handle_StepData_FileProtocol_swigregister(Handle_StepData_FileProtocol)

def Handle_StepData_FileProtocol_DownCast(thing):
    return _StepData.Handle_StepData_FileProtocol_DownCast(thing)
Handle_StepData_FileProtocol_DownCast = _StepData.Handle_StepData_FileProtocol_DownCast

class Handle_StepData_Plex(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_Plex self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_Plex_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_Plex self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_Plex_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_Plex self, StepData_Plex thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_Plex_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_Plex self, Handle_StepData_Plex theHandle) -> Handle_StepData_Plex
        assign(Handle_StepData_Plex self, StepData_Plex thePtr) -> Handle_StepData_Plex
        assign(Handle_StepData_Plex self, Handle_StepData_Plex theHandle) -> Handle_StepData_Plex

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_Plex_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_Plex self) -> StepData_Plex

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_Plex_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_Plex self) -> StepData_Plex

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_Plex___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_Plex self) -> StepData_Plex

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_Plex___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_Plex___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_Plex___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_Plex(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_Plex_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_Plex

    def Add(self, *args):
        """
        Add(Handle_StepData_Plex self, Handle_StepData_Simple member)

        Adds a member to <me>

        :type member: OCC.wrapper.StepData.Handle_StepData_Simple

        """
        return _StepData.Handle_StepData_Plex_Add(self, *args)


    def ECDescr(self, *args):
        """
        ECDescr(Handle_StepData_Plex self) -> Handle_StepData_ECDescr

        Returns the Description as for a Plex

        :rtype: OCC.wrapper.StepData.Handle_StepData_ECDescr

        """
        return _StepData.Handle_StepData_Plex_ECDescr(self, *args)


    def IsComplex(self, *args):
        """
        IsComplex(Handle_StepData_Plex self) -> Standard_Boolean

        Returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_Plex_IsComplex(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_StepData_Plex self, Standard_CString const steptype) -> Standard_Boolean

        Tells if a step type is matched by <me>
        For a Simple Entity : own type or super type
        For a Complex Entity : one of the members

        :type steptype: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_Plex_Matches(self, *args)


    def As(self, *args):
        """
        As(Handle_StepData_Plex self, Standard_CString const steptype) -> Handle_StepData_Simple

        Returns a Simple Entity which matches with a Type in <me> :
        For a Simple Entity : me if it matches, else a null handle
        For a Complex Entity : the member which matches, else null

        :type steptype: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.StepData.Handle_StepData_Simple

        """
        return _StepData.Handle_StepData_Plex_As(self, *args)


    def HasField(self, *args):
        """
        HasField(Handle_StepData_Plex self, Standard_CString const name) -> Standard_Boolean

        Tells if a Field brings a given name

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_Plex_HasField(self, *args)


    def Field(self, *args):
        """
        Returns a Field from its name; read-only

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        res = _StepData.Handle_StepData_Plex_Field(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CField(self, *args):
        """
        CField(Handle_StepData_Plex self, Standard_CString const name) -> StepData_Field

        Returns a Field from its name; read or write

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        return _StepData.Handle_StepData_Plex_CField(self, *args)


    def NbMembers(self, *args):
        """
        NbMembers(Handle_StepData_Plex self) -> Standard_Integer

        Returns the count of simple members

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_Plex_NbMembers(self, *args)


    def Member(self, *args):
        """
        Member(Handle_StepData_Plex self, Standard_Integer const num) -> Handle_StepData_Simple

        Returns a simple member from its rank

        :type num: int
        :rtype: OCC.wrapper.StepData.Handle_StepData_Simple

        """
        return _StepData.Handle_StepData_Plex_Member(self, *args)


    def TypeList(self, *args):
        """
        TypeList(Handle_StepData_Plex self) -> Handle_TColStd_HSequenceOfAsciiString

        Returns the actual list of members types

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _StepData.Handle_StepData_Plex_TypeList(self, *args)


    def Check(self, *args):
        """
        Check(Handle_StepData_Plex self, Handle_Interface_Check ach)

        Fills a Check by using its Description

        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _StepData.Handle_StepData_Plex_Check(self, *args)


    def Shared(self, *args):
        """
        Shared(Handle_StepData_Plex self, Interface_EntityIterator list)

        Fills an EntityIterator with entities shared by <me>

        :type list: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.Handle_StepData_Plex_Shared(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_Plex self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_Plex_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_Plex_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_Plex_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Description(self, *args):
        """
        Description(Handle_StepData_Plex self) -> Handle_StepData_EDescr

        Returns the Description used to define this entity

        :rtype: OCC.wrapper.StepData.Handle_StepData_EDescr

        """
        return _StepData.Handle_StepData_Plex_Description(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepData_Plex self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_Plex_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_Plex self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_Plex self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_Plex_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_Plex self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_Plex self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_Plex_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_Plex self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_Plex_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_Plex self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_Plex_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_Plex self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_Plex_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_Plex self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_Plex_DecrementRefCounter(self, *args)

Handle_StepData_Plex_swigregister = _StepData.Handle_StepData_Plex_swigregister
Handle_StepData_Plex_swigregister(Handle_StepData_Plex)

def Handle_StepData_Plex_DownCast(thing):
    return _StepData.Handle_StepData_Plex_DownCast(thing)
Handle_StepData_Plex_DownCast = _StepData.Handle_StepData_Plex_DownCast

class Handle_StepData_FreeFormEntity(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_FreeFormEntity self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_FreeFormEntity_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_FreeFormEntity self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_FreeFormEntity_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_FreeFormEntity self, StepData_FreeFormEntity thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_FreeFormEntity_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_FreeFormEntity self, Handle_StepData_FreeFormEntity theHandle) -> Handle_StepData_FreeFormEntity
        assign(Handle_StepData_FreeFormEntity self, StepData_FreeFormEntity thePtr) -> Handle_StepData_FreeFormEntity
        assign(Handle_StepData_FreeFormEntity self, Handle_StepData_FreeFormEntity theHandle) -> Handle_StepData_FreeFormEntity

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_FreeFormEntity_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_FreeFormEntity self) -> StepData_FreeFormEntity

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_FreeFormEntity_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_FreeFormEntity self) -> StepData_FreeFormEntity

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_FreeFormEntity___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_FreeFormEntity self) -> StepData_FreeFormEntity

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_FreeFormEntity___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_FreeFormEntity___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_FreeFormEntity___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_FreeFormEntity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_FreeFormEntity_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_FreeFormEntity

    def SetStepType(self, *args):
        """
        SetStepType(Handle_StepData_FreeFormEntity self, Standard_CString const typenam)

        Sets the type of an entity
        For a complex one, the type of this member

        :type typenam: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_FreeFormEntity_SetStepType(self, *args)


    def StepType(self, *args):
        """
        StepType(Handle_StepData_FreeFormEntity self) -> Standard_CString

        Returns the recorded StepType
        For a complex one, the type of this member

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_FreeFormEntity_StepType(self, *args)


    def SetNext(self, *args):
        """
        SetNext(Handle_StepData_FreeFormEntity self, Handle_StepData_FreeFormEntity next, Standard_Boolean const last)

        Sets a next member, in order to define or complete a Complex
        entity
        If <last> is True (D), this next will be set as last of list
        Else, it is inserted just as next of <me>
        If <next> is Null, Next is cleared

        :type next: OCC.wrapper.StepData.Handle_StepData_FreeFormEntity
        :type last: bool

        """
        return _StepData.Handle_StepData_FreeFormEntity_SetNext(self, *args)


    def Next(self, *args):
        """
        Next(Handle_StepData_FreeFormEntity self) -> Handle_StepData_FreeFormEntity

        Returns the next member of a Complex entity
        (remark : the last member has none)

        :rtype: OCC.wrapper.StepData.Handle_StepData_FreeFormEntity

        """
        return _StepData.Handle_StepData_FreeFormEntity_Next(self, *args)


    def IsComplex(self, *args):
        """
        IsComplex(Handle_StepData_FreeFormEntity self) -> Standard_Boolean

        Returns True if a FreeFormEntity is Complex (i.e. has Next)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_FreeFormEntity_IsComplex(self, *args)


    def Typed(self, *args):
        """
        Typed(Handle_StepData_FreeFormEntity self, Standard_CString const typenam) -> Handle_StepData_FreeFormEntity

        Returns the member of a FreeFormEntity of which the type name
        is given (exact match, no sub-type)

        :type typenam: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.StepData.Handle_StepData_FreeFormEntity

        """
        return _StepData.Handle_StepData_FreeFormEntity_Typed(self, *args)


    def TypeList(self, *args):
        """
        TypeList(Handle_StepData_FreeFormEntity self) -> Handle_TColStd_HSequenceOfAsciiString

        Returns the list of types (one type for a simple entity),
        as is (non reordered)

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _StepData.Handle_StepData_FreeFormEntity_TypeList(self, *args)


    def Reorder(self, *args):
        """
        Reorder(Handle_StepData_FreeFormEntity self, Handle_StepData_FreeFormEntity ent) -> Standard_Boolean

        Reorders a Complex entity if required, i.e. if member types
        are not in alphabetic order
        Returns False if nothing done (order was OK or simple entity),
        True plus modified <ent> if <ent> has been reordered

        :type ent: OCC.wrapper.StepData.Handle_StepData_FreeFormEntity
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_FreeFormEntity_Reorder(self, *args)


    def SetNbFields(self, *args):
        """
        SetNbFields(Handle_StepData_FreeFormEntity self, Standard_Integer const nb)

        Sets a count of Fields, from scratch

        :type nb: int

        """
        return _StepData.Handle_StepData_FreeFormEntity_SetNbFields(self, *args)


    def NbFields(self, *args):
        """
        NbFields(Handle_StepData_FreeFormEntity self) -> Standard_Integer

        Returns the count of fields

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_FreeFormEntity_NbFields(self, *args)


    def Field(self, *args):
        """
        Returns a field from its rank, for read-only use

        :type num: int
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        res = _StepData.Handle_StepData_FreeFormEntity_Field(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CField(self, *args):
        """
        CField(Handle_StepData_FreeFormEntity self, Standard_Integer const num) -> StepData_Field

        Returns a field from its rank, in order to modify it

        :type num: int
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        return _StepData.Handle_StepData_FreeFormEntity_CField(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_FreeFormEntity self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_FreeFormEntity_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_FreeFormEntity_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_FreeFormEntity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepData_FreeFormEntity self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_FreeFormEntity_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_FreeFormEntity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_FreeFormEntity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_FreeFormEntity_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_FreeFormEntity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_FreeFormEntity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_FreeFormEntity_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_FreeFormEntity self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_FreeFormEntity_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_FreeFormEntity self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_FreeFormEntity_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_FreeFormEntity self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_FreeFormEntity_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_FreeFormEntity self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_FreeFormEntity_DecrementRefCounter(self, *args)

Handle_StepData_FreeFormEntity_swigregister = _StepData.Handle_StepData_FreeFormEntity_swigregister
Handle_StepData_FreeFormEntity_swigregister(Handle_StepData_FreeFormEntity)

def Handle_StepData_FreeFormEntity_DownCast(thing):
    return _StepData.Handle_StepData_FreeFormEntity_DownCast(thing)
Handle_StepData_FreeFormEntity_DownCast = _StepData.Handle_StepData_FreeFormEntity_DownCast

class StepData_SelectReal(StepData_SelectMember):
    """
    A SelectReal is a SelectMember specialised for a basic real
    type in a select which also accepts entities : this one has
    NO NAME
    For a named select, see SelectNamed
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_SelectReal
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_SelectReal(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepData_SelectReal self) -> StepData_SelectReal

        A SelectReal is a SelectMember specialised for a basic real
        type in a select which also accepts entities : this one has
        NO NAME
        For a named select, see SelectNamed
        """
        this = _StepData.new_StepData_SelectReal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Kind(self, *args):
        """
        Kind(StepData_SelectReal self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_SelectReal_Kind(self, *args)


    def Real(self, *args):
        """
        Real(StepData_SelectReal self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepData.StepData_SelectReal_Real(self, *args)


    def SetReal(self, *args):
        """
        SetReal(StepData_SelectReal self, Standard_Real const val)

        :type val: float

        """
        return _StepData.StepData_SelectReal_SetReal(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_SelectReal_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_SelectReal_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_SelectReal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_SelectReal
StepData_SelectReal_swigregister = _StepData.StepData_SelectReal_swigregister
StepData_SelectReal_swigregister(StepData_SelectReal)

def StepData_SelectReal_get_type_name(*args):
    """
    StepData_SelectReal_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_SelectReal_get_type_name(*args)

def StepData_SelectReal_get_type_descriptor(*args):
    """
    StepData_SelectReal_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_SelectReal_get_type_descriptor(*args)

class StepData_StepModel(Interface.Interface_InterfaceModel):
    """
    Gives access to
    - entities in a STEP file,
    - the STEP file header.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_StepModel
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_StepModel(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepData_StepModel self) -> StepData_StepModel

        Creates an empty STEP model with an empty header.


        """
        this = _StepData.new_StepData_StepModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Entity(self, *args):
        """
        Entity(StepData_StepModel self, Standard_Integer const num) -> Handle_Standard_Transient

        returns entity given its rank.
        Same as InterfaceEntity, but with a shorter name

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.StepData_StepModel_Entity(self, *args)


    def GetFromAnother(self, *args):
        """
        GetFromAnother(StepData_StepModel self, Handle_Interface_InterfaceModel other)

        gets header from another Model (uses Header Protocol)

        :type other: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _StepData.StepData_StepModel_GetFromAnother(self, *args)


    def NewEmptyModel(self, *args):
        """
        NewEmptyModel(StepData_StepModel self) -> Handle_Interface_InterfaceModel

        Returns a New Empty Model, same type as <me>, i.e. StepModel

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _StepData.StepData_StepModel_NewEmptyModel(self, *args)


    def Header(self, *args):
        """
        Header(StepData_StepModel self) -> Interface_EntityIterator

        returns Header entities under the form of an iterator

        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.StepData_StepModel_Header(self, *args)


    def HasHeaderEntity(self, *args):
        """
        HasHeaderEntity(StepData_StepModel self, Handle_Standard_Type atype) -> Standard_Boolean

        says if a Header entity has a specifed type

        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_StepModel_HasHeaderEntity(self, *args)


    def HeaderEntity(self, *args):
        """
        HeaderEntity(StepData_StepModel self, Handle_Standard_Type atype) -> Handle_Standard_Transient

        Returns Header entity with specified type, if there is

        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.StepData_StepModel_HeaderEntity(self, *args)


    def ClearHeader(self, *args):
        """
        ClearHeader(StepData_StepModel self)

        Clears the Header


        """
        return _StepData.StepData_StepModel_ClearHeader(self, *args)


    def AddHeaderEntity(self, *args):
        """
        AddHeaderEntity(StepData_StepModel self, Handle_Standard_Transient ent)

        Adds an Entity to the Header

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.StepData_StepModel_AddHeaderEntity(self, *args)


    def VerifyCheck(self, *args):
        """
        VerifyCheck(StepData_StepModel self, Handle_Interface_Check ach)

        Specific Check, checks Header Items with HeaderProtocol

        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _StepData.StepData_StepModel_VerifyCheck(self, *args)


    def DumpHeader(self, *args):
        """
        DumpHeader(StepData_StepModel self, Handle_Message_Messenger S, Standard_Integer const level=0)

        Dumps the Header, with the Header Protocol of StepData.
        If the Header Protocol is not defined, for each Header Entity,
        prints its Type. Else sends the Header under the form of
        HEADER Section of an Ascii Step File
        <level> is not used because Header is not so big

        :type S: OCC.wrapper.Message.Handle_Message_Messenger
        :type level: int

        """
        return _StepData.StepData_StepModel_DumpHeader(self, *args)


    def ClearLabels(self, *args):
        """
        ClearLabels(StepData_StepModel self)

        erases specific labels, i.e. clears the map (entity-ident)


        """
        return _StepData.StepData_StepModel_ClearLabels(self, *args)


    def SetIdentLabel(self, *args):
        """
        SetIdentLabel(StepData_StepModel self, Handle_Standard_Transient ent, Standard_Integer const ident)

        Attaches an ident to an entity to produce a label
        (does nothing if <ent> is not in <me>)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type ident: int

        """
        return _StepData.StepData_StepModel_SetIdentLabel(self, *args)


    def IdentLabel(self, *args):
        """
        IdentLabel(StepData_StepModel self, Handle_Standard_Transient ent) -> Standard_Integer

        returns the label ident attached to an entity, 0 if not in me

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_StepModel_IdentLabel(self, *args)


    def PrintLabel(self, *args):
        """
        PrintLabel(StepData_StepModel self, Handle_Standard_Transient ent, Handle_Message_Messenger S)

        Prints label specific to STEP norm for a given entity, i.e.
        if a LabelIdent has been recorded, its value with '#', else
        the number in the model with '#' and between ()

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _StepData.StepData_StepModel_PrintLabel(self, *args)


    def StringLabel(self, *args):
        """
        StringLabel(StepData_StepModel self, Handle_Standard_Transient ent) -> Handle_TCollection_HAsciiString

        Returns a string with the label attached to a given entity,
        same form as for PrintLabel

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepData.StepData_StepModel_StringLabel(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_StepModel_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_StepModel_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_StepModel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_StepModel
StepData_StepModel_swigregister = _StepData.StepData_StepModel_swigregister
StepData_StepModel_swigregister(StepData_StepModel)

def StepData_StepModel_get_type_name(*args):
    """
    StepData_StepModel_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_StepModel_get_type_name(*args)

def StepData_StepModel_get_type_descriptor(*args):
    """
    StepData_StepModel_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_StepModel_get_type_descriptor(*args)

class StepData_DescrProtocol(StepData_FileProtocol):
    """
    A DescrProtocol is a protocol dynamically (at execution time)
    defined with :
    - a list of resources (inherits FileProtocol)
    - a list of entity descriptions
    i.e. it can be defined with only C++ writing to initialize it
    Its initialization must :
    - set its schema name
    - define its resources (which can also be other DescrProtocol)
    - define its entity descriptions
    - record it in the system by calling RecordLib
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_DescrProtocol
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_DescrProtocol(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepData_DescrProtocol self) -> StepData_DescrProtocol

        A DescrProtocol is a protocol dynamically (at execution time)
        defined with :
        - a list of resources (inherits FileProtocol)
        - a list of entity descriptions
        i.e. it can be defined with only C++ writing to initialize it
        Its initialization must :
        - set its schema name
        - define its resources (which can also be other DescrProtocol)
        - define its entity descriptions
        - record it in the system by calling RecordLib
        """
        this = _StepData.new_StepData_DescrProtocol(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetSchemaName(self, *args):
        """
        SetSchemaName(StepData_DescrProtocol self, Standard_CString const name)

        Defines a specific Schema Name for this Protocol

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_DescrProtocol_SetSchemaName(self, *args)


    def LibRecord(self, *args):
        """
        LibRecord(StepData_DescrProtocol self)

        Records this Protocol in the service libraries, with a
        DescrGeneral and a DescrReadWrite
        Does nothing if the Protocol brings no proper description


        """
        return _StepData.StepData_DescrProtocol_LibRecord(self, *args)


    def SchemaName(self, *args):
        """
        SchemaName(StepData_DescrProtocol self) -> Standard_CString

        Returns the Schema Name attached to each class of Protocol
        here, returns the SchemaName set by SetSchemaName
        was C++ : return const

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_DescrProtocol_SchemaName(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_DescrProtocol_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_DescrProtocol_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_DescrProtocol_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_DescrProtocol
StepData_DescrProtocol_swigregister = _StepData.StepData_DescrProtocol_swigregister
StepData_DescrProtocol_swigregister(StepData_DescrProtocol)

def StepData_DescrProtocol_get_type_name(*args):
    """
    StepData_DescrProtocol_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_DescrProtocol_get_type_name(*args)

def StepData_DescrProtocol_get_type_descriptor(*args):
    """
    StepData_DescrProtocol_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_DescrProtocol_get_type_descriptor(*args)

class Handle_StepData_GeneralModule(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_GeneralModule self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_GeneralModule_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_GeneralModule self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_GeneralModule_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_GeneralModule self, StepData_GeneralModule thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_GeneralModule_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_GeneralModule self, Handle_StepData_GeneralModule theHandle) -> Handle_StepData_GeneralModule
        assign(Handle_StepData_GeneralModule self, StepData_GeneralModule thePtr) -> Handle_StepData_GeneralModule
        assign(Handle_StepData_GeneralModule self, Handle_StepData_GeneralModule theHandle) -> Handle_StepData_GeneralModule

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_GeneralModule_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_GeneralModule self) -> StepData_GeneralModule

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_GeneralModule_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_GeneralModule self) -> StepData_GeneralModule

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_GeneralModule___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_GeneralModule self) -> StepData_GeneralModule

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_GeneralModule___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_GeneralModule___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_GeneralModule___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_GeneralModule(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_GeneralModule_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_GeneralModule

    def FillSharedCase(self, *args):
        """
        FillSharedCase(Handle_StepData_GeneralModule self, Standard_Integer const casenum, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        Specific filling of the list of Entities shared by an Entity
        <ent>. Can use the internal utility method Share, below

        :type casenum: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.Handle_StepData_GeneralModule_FillSharedCase(self, *args)


    def CheckCase(self, *args):
        """
        CheckCase(Handle_StepData_GeneralModule self, Standard_Integer const casenum, Handle_Standard_Transient ent, Interface_ShareTool shares, Handle_Interface_Check ach)

        Specific Checking of an Entity <ent>

        :type casenum: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type shares: OCC.wrapper.Interface.Interface_ShareTool
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _StepData.Handle_StepData_GeneralModule_CheckCase(self, *args)


    def CopyCase(self, *args):
        """
        CopyCase(Handle_StepData_GeneralModule self, Standard_Integer const casenum, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC)

        Specific Copy ("Deep") from <entfrom> to <entto> (same type)
        by using a TransferControl which provides its working Map.
        Use method Transferred from TransferControl to work
        Specific Copying of Implied References
        A Default is provided which does nothing (must current case !)
        Already copied references (by CopyFrom) must remain unchanged
        Use method Search from TransferControl to work

        :type casenum: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _StepData.Handle_StepData_GeneralModule_CopyCase(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_GeneralModule self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_GeneralModule_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_GeneralModule_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_GeneralModule_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FillShared(self, *args):
        """
        FillShared(Handle_StepData_GeneralModule self, Handle_Interface_InterfaceModel model, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        Specific filling of the list of Entities shared by an Entity
        <ent>, according a Case Number <CN> (formerly computed by
        CaseNum), considered in the context of a Model <model>
        Default calls FillSharedCase (i.e., ignores the model)
        Can be redefined to use the model for working

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.Handle_StepData_GeneralModule_FillShared(self, *args)


    def Share(self, *args):
        """
        Share(Handle_StepData_GeneralModule self, Interface_EntityIterator iter, Handle_Standard_Transient shared)

        Adds an Entity to a Shared List (uses GetOneItem on <iter>)

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator
        :type shared: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.Handle_StepData_GeneralModule_Share(self, *args)


    def ListImplied(self, *args):
        """
        ListImplied(Handle_StepData_GeneralModule self, Handle_Interface_InterfaceModel model, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        List the Implied References of <ent> considered in the context
        of a Model <model> : i.e. the Entities which are Referenced
        while not considered as Shared (not copied if <ent> is,
        references not renewed by CopyCase but by ImpliedCase, only
        if referenced Entities have been Copied too)
        FillShared + ListImplied give the complete list of References
        Default calls ListImpliedCase (i.e. ignores the model)
        Can be redefined to use the model for working

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.Handle_StepData_GeneralModule_ListImplied(self, *args)


    def ListImpliedCase(self, *args):
        """
        ListImpliedCase(Handle_StepData_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        List the Implied References of <ent> (see above)
        are Referenced while not considered as Shared (not copied if
        <ent> is, references not renewed by CopyCase but by
        ImpliedCase, only if referenced Entities have been Copied too)
        FillSharedCase + ListImpliedCase give the complete list of
        Referenced Entities
        The provided default method does nothing (Implied References
        are specific of a little amount of Entity Classes).

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.Handle_StepData_GeneralModule_ListImpliedCase(self, *args)


    def CanCopy(self, *args):
        """
        CanCopy(Handle_StepData_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent) -> Standard_Boolean

        Specific answer to the question "is Copy properly implemented"
        Remark that it should be in phase with the implementation of
        NewVoid+CopyCase/NewCopyCase
        Default returns always False, can be redefined

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_GeneralModule_CanCopy(self, *args)


    def Dispatch(self, *args):
        """
        Dispatch(Handle_StepData_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC) -> Standard_Boolean

        Dispatches an entity
        Returns True if it works by copy, False if it just duplicates
        the starting Handle

        Dispatching means producing a new entity, image of the
        starting one, in order to be put into a new Model, this Model
        being itself the result of a dispatch from an original Model

        According to the cases, dispatch can either
        * just return <entto> as equating <entfrom>
        -> the new model designates the starting entity : it is
        lighter, but the dispatched entity being shared might not be
        modified for dispatch
        * copy <entfrom> to <entto>
        by calling NewVoid+CopyCase (two steps) or NewCopiedCase (1)
        -> the dispatched entity is a COPY, hence it can be modified

        The provided default just duplicates the handle without
        copying, then returns False. Can be redefined

        :type CN: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_GeneralModule_Dispatch(self, *args)


    def NewVoid(self, *args):
        """
        NewVoid(Handle_StepData_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient entto) -> Standard_Boolean

        Creates a new void entity <entto> according to a Case Number
        This entity remains to be filled, by reading from a file or
        by copying from another entity of same type (see CopyCase)

        :type CN: int
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_GeneralModule_NewVoid(self, *args)


    def NewCopiedCase(self, *args):
        """
        NewCopiedCase(Handle_StepData_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC) -> Standard_Boolean

        Specific operator (create+copy) defaulted to do nothing.
        It can be redefined : When it is not possible to work in two
        steps (NewVoid then CopyCase). This can occur when there is
        no default constructor : hence the result <entto> must be
        created with an effective definition.
        Remark : if NewCopiedCase is defined, CopyCase has nothing to do
        Returns True if it has produced something, false else

        :type CN: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_GeneralModule_NewCopiedCase(self, *args)


    def RenewImpliedCase(self, *args):
        """
        RenewImpliedCase(Handle_StepData_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC)

        Specific Copying of Implied References
        A Default is provided which does nothing (must current case !)
        Already copied references (by CopyFrom) must remain unchanged
        Use method Search from CopyTool to work

        :type CN: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _StepData.Handle_StepData_GeneralModule_RenewImpliedCase(self, *args)


    def WhenDeleteCase(self, *args):
        """
        WhenDeleteCase(Handle_StepData_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent, Standard_Boolean const dispatched)

        Prepares an entity to be deleted. What does it mean :
        Basically, any class of entity may define its own destructor
        By default, it does nothing but calling destructors on fields
        With the Memory Manager, it is useless to call destructor,
        it is done automatically when the Handle is nullified(cleared)
        BUT this is ineffective in looping structures (whatever these
        are "Implied" references or not).

        THUS : if no loop may appear in definitions, a class which
        inherits from TShared is correctly managed by automatic way
        BUT if there can be loops (or simply back pointers), they must
        be broken, for instance by clearing fields of one of the nodes
        The default does nothing, to be redefined if a loop can occur
        (Implied generally requires WhenDelete, but other cases can
        occur)

        Warning : <dispatched> tells if the entity to be deleted has been
        produced by Dispatch or not. Hence WhenDelete must be in
        coherence with Dispatch
        Dispatch can either copy or not.
        If it copies the entity, this one should be deleted
        If it doesnt (i.e. duplicates the handle) nothing to do

        If <dispatch> is False, normal deletion is to be performed

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type dispatched: bool

        """
        return _StepData.Handle_StepData_GeneralModule_WhenDeleteCase(self, *args)


    def CategoryNumber(self, *args):
        """
        CategoryNumber(Handle_StepData_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_ShareTool shares) -> Standard_Integer

        Returns a category number which characterizes an entity
        Category Numbers are managed by the class Category
        <shares> can be used to evaluate this number in the context
        Default returns 0 which means "unspecified"

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type shares: OCC.wrapper.Interface.Interface_ShareTool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_GeneralModule_CategoryNumber(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepData_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_ShareTool shares) -> Handle_TCollection_HAsciiString

        Determines if an entity brings a Name (or widerly, if a Name
        can be attached to it, through the ShareTool
        By default, returns a Null Handle (no name can be produced)
        Can be redefined

        Warning : While this string may be edited on the spot, if it is a read
        field, the returned value must be copied before.

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type shares: OCC.wrapper.Interface.Interface_ShareTool
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepData.Handle_StepData_GeneralModule_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepData_GeneralModule self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_GeneralModule_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_GeneralModule self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_GeneralModule self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_GeneralModule_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_GeneralModule self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_GeneralModule self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_GeneralModule_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_GeneralModule self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_GeneralModule_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_GeneralModule self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_GeneralModule_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_GeneralModule self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_GeneralModule_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_GeneralModule self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_GeneralModule_DecrementRefCounter(self, *args)

Handle_StepData_GeneralModule_swigregister = _StepData.Handle_StepData_GeneralModule_swigregister
Handle_StepData_GeneralModule_swigregister(Handle_StepData_GeneralModule)

def Handle_StepData_GeneralModule_DownCast(thing):
    return _StepData.Handle_StepData_GeneralModule_DownCast(thing)
Handle_StepData_GeneralModule_DownCast = _StepData.Handle_StepData_GeneralModule_DownCast

class Handle_StepData_StepModel(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_StepModel self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_StepModel_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_StepModel self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_StepModel_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_StepModel self, StepData_StepModel thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_StepModel_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_StepModel self, Handle_StepData_StepModel theHandle) -> Handle_StepData_StepModel
        assign(Handle_StepData_StepModel self, StepData_StepModel thePtr) -> Handle_StepData_StepModel
        assign(Handle_StepData_StepModel self, Handle_StepData_StepModel theHandle) -> Handle_StepData_StepModel

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_StepModel_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_StepModel self) -> StepData_StepModel

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_StepModel_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_StepModel self) -> StepData_StepModel

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_StepModel___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_StepModel self) -> StepData_StepModel

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_StepModel___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_StepModel___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_StepModel___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_StepModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_StepModel_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_StepModel

    def Entity(self, *args):
        """
        Entity(Handle_StepData_StepModel self, Standard_Integer const num) -> Handle_Standard_Transient

        returns entity given its rank.
        Same as InterfaceEntity, but with a shorter name

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.Handle_StepData_StepModel_Entity(self, *args)


    def GetFromAnother(self, *args):
        """
        GetFromAnother(Handle_StepData_StepModel self, Handle_Interface_InterfaceModel other)

        gets header from another Model (uses Header Protocol)

        :type other: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _StepData.Handle_StepData_StepModel_GetFromAnother(self, *args)


    def NewEmptyModel(self, *args):
        """
        NewEmptyModel(Handle_StepData_StepModel self) -> Handle_Interface_InterfaceModel

        Returns a New Empty Model, same type as <me>, i.e. StepModel

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _StepData.Handle_StepData_StepModel_NewEmptyModel(self, *args)


    def Header(self, *args):
        """
        Header(Handle_StepData_StepModel self) -> Interface_EntityIterator

        returns Header entities under the form of an iterator

        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.Handle_StepData_StepModel_Header(self, *args)


    def HasHeaderEntity(self, *args):
        """
        HasHeaderEntity(Handle_StepData_StepModel self, Handle_Standard_Type atype) -> Standard_Boolean

        says if a Header entity has a specifed type

        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepModel_HasHeaderEntity(self, *args)


    def HeaderEntity(self, *args):
        """
        HeaderEntity(Handle_StepData_StepModel self, Handle_Standard_Type atype) -> Handle_Standard_Transient

        Returns Header entity with specified type, if there is

        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.Handle_StepData_StepModel_HeaderEntity(self, *args)


    def ClearHeader(self, *args):
        """
        ClearHeader(Handle_StepData_StepModel self)

        Clears the Header


        """
        return _StepData.Handle_StepData_StepModel_ClearHeader(self, *args)


    def AddHeaderEntity(self, *args):
        """
        AddHeaderEntity(Handle_StepData_StepModel self, Handle_Standard_Transient ent)

        Adds an Entity to the Header

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.Handle_StepData_StepModel_AddHeaderEntity(self, *args)


    def VerifyCheck(self, *args):
        """
        VerifyCheck(Handle_StepData_StepModel self, Handle_Interface_Check ach)

        Specific Check, checks Header Items with HeaderProtocol

        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _StepData.Handle_StepData_StepModel_VerifyCheck(self, *args)


    def DumpHeader(self, *args):
        """
        DumpHeader(Handle_StepData_StepModel self, Handle_Message_Messenger S, Standard_Integer const level=0)

        Dumps the Header, with the Header Protocol of StepData.
        If the Header Protocol is not defined, for each Header Entity,
        prints its Type. Else sends the Header under the form of
        HEADER Section of an Ascii Step File
        <level> is not used because Header is not so big

        :type S: OCC.wrapper.Message.Handle_Message_Messenger
        :type level: int

        """
        return _StepData.Handle_StepData_StepModel_DumpHeader(self, *args)


    def ClearLabels(self, *args):
        """
        ClearLabels(Handle_StepData_StepModel self)

        erases specific labels, i.e. clears the map (entity-ident)


        """
        return _StepData.Handle_StepData_StepModel_ClearLabels(self, *args)


    def SetIdentLabel(self, *args):
        """
        SetIdentLabel(Handle_StepData_StepModel self, Handle_Standard_Transient ent, Standard_Integer const ident)

        Attaches an ident to an entity to produce a label
        (does nothing if <ent> is not in <me>)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type ident: int

        """
        return _StepData.Handle_StepData_StepModel_SetIdentLabel(self, *args)


    def IdentLabel(self, *args):
        """
        IdentLabel(Handle_StepData_StepModel self, Handle_Standard_Transient ent) -> Standard_Integer

        returns the label ident attached to an entity, 0 if not in me

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_StepModel_IdentLabel(self, *args)


    def PrintLabel(self, *args):
        """
        PrintLabel(Handle_StepData_StepModel self, Handle_Standard_Transient ent, Handle_Message_Messenger S)

        Prints label specific to STEP norm for a given entity, i.e.
        if a LabelIdent has been recorded, its value with '#', else
        the number in the model with '#' and between ()

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _StepData.Handle_StepData_StepModel_PrintLabel(self, *args)


    def StringLabel(self, *args):
        """
        StringLabel(Handle_StepData_StepModel self, Handle_Standard_Transient ent) -> Handle_TCollection_HAsciiString

        Returns a string with the label attached to a given entity,
        same form as for PrintLabel

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepData.Handle_StepData_StepModel_StringLabel(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_StepModel self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_StepModel_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_StepModel_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_StepModel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Destroy(self, *args):
        """
        Destroy(Handle_StepData_StepModel self)

        Clears the list of entities (service WhenDelete)


        """
        return _StepData.Handle_StepData_StepModel_Destroy(self, *args)


    def SetProtocol(self, *args):
        """
        SetProtocol(Handle_StepData_StepModel self, Handle_Interface_Protocol proto)

        Sets a Protocol for this Model
        It is also set by a call to AddWithRefs with Protocol
        It is used for : DumpHeader (as required), ClearEntities ...

        :type proto: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _StepData.Handle_StepData_StepModel_SetProtocol(self, *args)


    def Protocol(self, *args):
        """
        Protocol(Handle_StepData_StepModel self) -> Handle_Interface_Protocol

        Returns the Protocol which has been set by SetProtocol, or
        AddWithRefs with Protocol

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _StepData.Handle_StepData_StepModel_Protocol(self, *args)


    def SetGTool(self, *args):
        """
        SetGTool(Handle_StepData_StepModel self, Handle_Interface_GTool gtool)

        Sets a GTool for this model, which already defines a Protocol

        :type gtool: OCC.wrapper.Interface.Handle_Interface_GTool

        """
        return _StepData.Handle_StepData_StepModel_SetGTool(self, *args)


    def GTool(self, *args):
        """
        GTool(Handle_StepData_StepModel self) -> Handle_Interface_GTool

        Returns the GTool, set by SetProtocol or by SetGTool

        :rtype: OCC.wrapper.Interface.Handle_Interface_GTool

        """
        return _StepData.Handle_StepData_StepModel_GTool(self, *args)


    def DispatchStatus(self, *args):
        """
        DispatchStatus(Handle_StepData_StepModel self) -> Standard_Boolean &

        Returns the Dispatch Status, either for get or set
        A Model which is produced from Dispatch may share entities
        with the original (according to the Protocol), hence these
        non-copied entities should not be deleted

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepModel_DispatchStatus(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_StepData_StepModel self)

        Erases contained data; used when a Model is copied to others :
        the new copied ones begin from clear
        Clear calls specific method ClearHeader (see below)


        """
        return _StepData.Handle_StepData_StepModel_Clear(self, *args)


    def ClearEntities(self, *args):
        """
        ClearEntities(Handle_StepData_StepModel self)

        Clears the entities; uses the general service WhenDelete, in
        addition to the standard Memory Manager; can be redefined


        """
        return _StepData.Handle_StepData_StepModel_ClearEntities(self, *args)


    def NbEntities(self, *args):
        """
        NbEntities(Handle_StepData_StepModel self) -> Standard_Integer

        Returns count of contained Entities

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_StepModel_NbEntities(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_StepData_StepModel self, Handle_Standard_Transient anentity) -> Standard_Boolean

        Returns True if a Model contains an Entity (for a ReportEntity,
        looks for the ReportEntity itself AND its Concerned Entity)

        :type anentity: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepModel_Contains(self, *args)


    def Number(self, *args):
        """
        Number(Handle_StepData_StepModel self, Handle_Standard_Transient anentity) -> Standard_Integer

        Returns the Number of an Entity in the Model if it contains it.
        Else returns 0. For a ReportEntity, looks at Concerned Entity.
        Returns the Directory entry   Number of  an Entity in
        the  Model if it contains it.   Else returns  0.  For a
        ReportEntity, looks at Concerned Entity.

        :type anentity: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_StepModel_Number(self, *args)


    def Value(self, *args):
        """
        Returns an Entity identified by its number in the Model
        Each sub-class of InterfaceModel can define its own method
        Entity to return its specific class of Entity (e.g. for VDA,
        VDAModel returns a VDAEntity), working by calling Value
        Remark : For a Reported Entity, (Erroneous, Corrected, Unknown), this
        method returns this Reported Entity.
        See ReportEntity for other questions.

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _StepData.Handle_StepData_StepModel_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbTypes(self, *args):
        """
        NbTypes(Handle_StepData_StepModel self, Handle_Standard_Transient ent) -> Standard_Integer

        Returns the count of DISTINCT types under which an entity may
        be processed. Defined by the Protocol, which gives default as
        1 (dynamic Type).

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_StepModel_NbTypes(self, *args)


    def Type(self, *args):
        """
        Type(Handle_StepData_StepModel self, Handle_Standard_Transient ent, Standard_Integer const num=1) -> Handle_Standard_Type

        Returns a type, given its rank : defined by the Protocol
        (by default, the first one)

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.Handle_StepData_StepModel_Type(self, *args)


    def TypeName(self, *args):
        """
        TypeName(Handle_StepData_StepModel self, Handle_Standard_Transient ent, Standard_Boolean const complete) -> Standard_CString

        Returns the type name of an entity, from the list of types
        (one or more ...)
        <complete> True (D) gives the complete type, else packages are
        removed
        WARNING : buffered, to be immediately copied or printed

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type complete: bool
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_StepModel_TypeName(self, *args)


    def ClassName(self, *args):
        """
        ClassName(Handle_StepData_StepModel self, Standard_CString const typnam) -> Standard_CString

        From a CDL Type Name, returns the Class part (package dropped)
        WARNING : buffered, to be immediately copied or printed

        :type typnam: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_StepModel_ClassName(self, *args)


    def EntityState(self, *args):
        """
        EntityState(Handle_StepData_StepModel self, Standard_Integer const num) -> Interface_DataState

        Returns the State of an entity, given its number

        :type num: int
        :rtype: OCC.wrapper.Interface.Interface_DataState

        """
        return _StepData.Handle_StepData_StepModel_EntityState(self, *args)


    def IsReportEntity(self, *args):
        """
        IsReportEntity(Handle_StepData_StepModel self, Standard_Integer const num, Standard_Boolean const semantic) -> Standard_Boolean

        Returns True if <num> identifies a ReportEntity in the Model
        Hence, ReportEntity can be called.

        By default, queries main report, if <semantic> is True, it
        queries report for semantic check

        Remember that a Report Entity can be defined for an Unknown
        Entity, or a Corrected or Erroneous (at read time) Entity.
        The ReportEntity is defined before call to method AddEntity.

        :type num: int
        :type semantic: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepModel_IsReportEntity(self, *args)


    def ReportEntity(self, *args):
        """
        ReportEntity(Handle_StepData_StepModel self, Standard_Integer const num, Standard_Boolean const semantic) -> Handle_Interface_ReportEntity

        Returns a ReportEntity identified by its number in the Model,
        or a Null Handle If <num> does not identify a ReportEntity.

        By default, queries main report, if <semantic> is True, it
        queries report for semantic check

        :type num: int
        :type semantic: bool
        :rtype: OCC.wrapper.Interface.Handle_Interface_ReportEntity

        """
        return _StepData.Handle_StepData_StepModel_ReportEntity(self, *args)


    def IsErrorEntity(self, *args):
        """
        IsErrorEntity(Handle_StepData_StepModel self, Standard_Integer const num) -> Standard_Boolean

        Returns True if <num> identifies an Error Entity : in this
        case, a ReportEntity brings Fail Messages and possibly an
        "undefined" Content, see IsRedefinedEntity

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepModel_IsErrorEntity(self, *args)


    def IsRedefinedContent(self, *args):
        """
        IsRedefinedContent(Handle_StepData_StepModel self, Standard_Integer const num) -> Standard_Boolean

        Returns True if <num> identifies an Entity which content is
        redefined through a ReportEntity (i.e. with literal data only)
        This happens when an entity is syntactically erroneous in the
        way that its basic content remains empty.
        For more details (such as content itself), see ReportEntity

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepModel_IsRedefinedContent(self, *args)


    def ClearReportEntity(self, *args):
        """
        ClearReportEntity(Handle_StepData_StepModel self, Standard_Integer const num) -> Standard_Boolean

        Removes the ReportEntity attached to Entity <num>. Returns
        True if done, False if no ReportEntity was attached to <num>.
        Warning : the caller must assume that this clearing is meaningfull

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepModel_ClearReportEntity(self, *args)


    def SetReportEntity(self, *args):
        """
        SetReportEntity(Handle_StepData_StepModel self, Standard_Integer const num, Handle_Interface_ReportEntity rep) -> Standard_Boolean

        Sets or Replaces a ReportEntity for the Entity <num>. Returns
        True if Report is replaced, False if it has been replaced
        Warning : the caller must assume that this setting is meaningfull

        :type num: int
        :type rep: OCC.wrapper.Interface.Handle_Interface_ReportEntity
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepModel_SetReportEntity(self, *args)


    def AddReportEntity(self, *args):
        """
        AddReportEntity(Handle_StepData_StepModel self, Handle_Interface_ReportEntity rep, Standard_Boolean const semantic) -> Standard_Boolean

        Adds a ReportEntity as such. Returns False if the concerned
        entity is not recorded in the Model
        Else, adds it into, either the main report list or the
        list for semantic checks, then returns True

        :type rep: OCC.wrapper.Interface.Handle_Interface_ReportEntity
        :type semantic: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepModel_AddReportEntity(self, *args)


    def IsUnknownEntity(self, *args):
        """
        IsUnknownEntity(Handle_StepData_StepModel self, Standard_Integer const num) -> Standard_Boolean

        Returns True if <num> identifies an Unknown Entity : in this
        case, a ReportEntity with no Check Messages designates it.

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepModel_IsUnknownEntity(self, *args)


    def FillSemanticChecks(self, *args):
        """
        FillSemanticChecks(Handle_StepData_StepModel self, Interface_CheckIterator checks, Standard_Boolean const clear)

        Fills the list of semantic checks.
        This list is computed (by CheckTool). Hence, it can be stored
        in the model for later queries
        <clear> True (D) : new list replaces
        <clear> False    : new list is cumulated

        :type checks: OCC.wrapper.Interface.Interface_CheckIterator
        :type clear: bool

        """
        return _StepData.Handle_StepData_StepModel_FillSemanticChecks(self, *args)


    def HasSemanticChecks(self, *args):
        """
        HasSemanticChecks(Handle_StepData_StepModel self) -> Standard_Boolean

        Returns True if semantic checks have been filled

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepModel_HasSemanticChecks(self, *args)


    def Check(self, *args):
        """
        Returns the check attached to an entity, designated by its
        Number. 0 for global check
        <semantic> True  : recorded semantic check
        <semantic> False : recorded syntactic check (see ReportEntity)
        If no check is recorded for <num>, returns an empty Check

        :type num: int
        :type syntactic: bool
        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        res = _StepData.Handle_StepData_StepModel_Check(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Reservate(self, *args):
        """
        Reservate(Handle_StepData_StepModel self, Standard_Integer const nbent)

        Does a reservation for the List of Entities (for optimized
        storage management). If it is not called, storage management
        can be less efficient. <nbent> is the expected count of
        Entities to store

        :type nbent: int

        """
        return _StepData.Handle_StepData_StepModel_Reservate(self, *args)


    def AddEntity(self, *args):
        """
        AddEntity(Handle_StepData_StepModel self, Handle_Standard_Transient anentity)

        Internal method for adding an Entity. Used by file reading
        (defined by each Interface) and Transfer tools. It adds the
        entity required to be added, not its refs : see AddWithRefs.
        If <anentity> is a ReportEntity, it is added to the list of
        Reports, its Concerned Entity (Erroneous or Corrected, else
        Unknown) is added to the list of Entities.
        That is, the ReportEntity must be created before Adding

        :type anentity: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.Handle_StepData_StepModel_AddEntity(self, *args)


    def AddWithRefs(self, *args):
        """
        AddWithRefs(Handle_StepData_StepModel self, Handle_Standard_Transient anent, Handle_Interface_Protocol proto, Standard_Integer const level=0, Standard_Boolean const listall)
        AddWithRefs(Handle_StepData_StepModel self, Handle_Standard_Transient anent, Standard_Integer const level=0, Standard_Boolean const listall)
        AddWithRefs(Handle_StepData_StepModel self, Handle_Standard_Transient anent, Interface_GeneralLib lib, Standard_Integer const level=0, Standard_Boolean const listall)

        Same as above, but works with an already created GeneralLib

        :type anent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type lib: OCC.wrapper.Interface.Interface_GeneralLib
        :type level: int
        :type listall: bool

        """
        return _StepData.Handle_StepData_StepModel_AddWithRefs(self, *args)


    def ReplaceEntity(self, *args):
        """
        ReplaceEntity(Handle_StepData_StepModel self, Standard_Integer const nument, Handle_Standard_Transient anent)

        Replace Entity with Number=nument on other entity - "anent"

        :type nument: int
        :type anent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.Handle_StepData_StepModel_ReplaceEntity(self, *args)


    def ReverseOrders(self, *args):
        """
        ReverseOrders(Handle_StepData_StepModel self, Standard_Integer const after=0)

        Reverses the Numbers of the Entities, between <after> and the
        total count of Entities. Thus, the entities :
        1,2 ... after, after+1 ... nb-1, nb  become numbered as :
        1,2 ... after, nb, nb-1 ... after+1
        By default (after = 0) the whole list of Entities is reversed

        :type after: int

        """
        return _StepData.Handle_StepData_StepModel_ReverseOrders(self, *args)


    def ChangeOrder(self, *args):
        """
        ChangeOrder(Handle_StepData_StepModel self, Standard_Integer const oldnum, Standard_Integer const newnum, Standard_Integer const count=1)

        Changes the Numbers of some Entities : <oldnum> is moved to
        <newnum>, same for <count> entities. Thus :
        1,2 ... newnum-1 newnum ... oldnum .. oldnum+count oldnum+count+1 .. gives
        1,2 ... newnum-1 oldnum .. oldnum+count newnum ... oldnum+count+1
        (can be seen as a circular permutation)

        :type oldnum: int
        :type newnum: int
        :type count: int

        """
        return _StepData.Handle_StepData_StepModel_ChangeOrder(self, *args)


    def GetFromTransfer(self, *args):
        """
        GetFromTransfer(Handle_StepData_StepModel self, Interface_EntityIterator aniter)

        Gets contents from an EntityIterator, prepared by a
        Transfer tool (e.g TransferCopy). Starts from clear

        :type aniter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.Handle_StepData_StepModel_GetFromTransfer(self, *args)


    def SetCategoryNumber(self, *args):
        """
        SetCategoryNumber(Handle_StepData_StepModel self, Standard_Integer const num, Standard_Integer const val) -> Standard_Boolean

        Records a category number for an entity number
        Returns True when done, False if <num> is out of range

        :type num: int
        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepModel_SetCategoryNumber(self, *args)


    def CategoryNumber(self, *args):
        """
        CategoryNumber(Handle_StepData_StepModel self, Standard_Integer const num) -> Standard_Integer

        Returns the recorded category number for a given entity number
        0 if none was defined for this entity

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_StepModel_CategoryNumber(self, *args)


    def FillIterator(self, *args):
        """
        FillIterator(Handle_StepData_StepModel self, Interface_EntityIterator iter)

        Allows an EntityIterator to get a list of Entities

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.Handle_StepData_StepModel_FillIterator(self, *args)


    def Entities(self, *args):
        """
        Entities(Handle_StepData_StepModel self) -> Interface_EntityIterator

        Returns the list of all Entities, as an Iterator on Entities
        (the Entities themselves, not the Reports)

        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.Handle_StepData_StepModel_Entities(self, *args)


    def Reports(self, *args):
        """
        Reports(Handle_StepData_StepModel self, Standard_Boolean const semantic) -> Interface_EntityIterator

        Returns the list of all ReportEntities, i.e. data about
        Entities read with Error or Warning informations
        (each item has to be casted to Report Entity then it can be
        queried for Concerned Entity, Content, Check ...)
        By default, returns the main reports, is <semantic> is True it
        returns the list for sematic checks

        :type semantic: bool
        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.Handle_StepData_StepModel_Reports(self, *args)


    def Redefineds(self, *args):
        """
        Redefineds(Handle_StepData_StepModel self) -> Interface_EntityIterator

        Returns the list of ReportEntities which redefine data
        (generally, if concerned entity is "Error", a literal content
        is added to it : this is a "redefined entity"

        :rtype: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.Handle_StepData_StepModel_Redefineds(self, *args)


    def GlobalCheck(self, *args):
        """
        Returns the GlobalCheck, which memorizes messages global to
        the file (not specific to an Entity), especially Header

        :type syntactic: bool
        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        res = _StepData.Handle_StepData_StepModel_GlobalCheck(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetGlobalCheck(self, *args):
        """
        SetGlobalCheck(Handle_StepData_StepModel self, Handle_Interface_Check ach)

        Allows to modify GlobalCheck, after getting then completing it
        Remark : it is SYNTACTIC check. Semantics, see FillChecks

        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _StepData.Handle_StepData_StepModel_SetGlobalCheck(self, *args)


    def Print(self, *args):
        """
        Print(Handle_StepData_StepModel self, Handle_Standard_Transient ent, Handle_Message_Messenger s, Standard_Integer const mode=0)

        Prints identification of a given entity in <me>, in order to
        be printed in a list or phrase
        <mode> < 0 : prints only its number
        <mode> = 1 : just calls PrintLabel
        <mode> = 0 (D) : prints its number plus '/' plus PrintLabel
        If <ent> == <me>, simply prints "Global"
        If <ent> is unknown, prints "??/its type"

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type s: OCC.wrapper.Message.Handle_Message_Messenger
        :type mode: int

        """
        return _StepData.Handle_StepData_StepModel_Print(self, *args)


    def PrintToLog(self, *args):
        """
        PrintToLog(Handle_StepData_StepModel self, Handle_Standard_Transient ent, Handle_Message_Messenger S)

        Prints label specific to each norm in log format, for
        a given entity.
        By default, just calls PrintLabel, can be redefined

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type S: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _StepData.Handle_StepData_StepModel_PrintToLog(self, *args)


    def NextNumberForLabel(self, *args):
        """
        NextNumberForLabel(Handle_StepData_StepModel self, Standard_CString const label, Standard_Integer const lastnum=0, Standard_Boolean const exact) -> Standard_Integer

        Searches a label which matches with one entity.
        Begins from <lastnum>+1 (default:1) and scans the entities
        until <NbEntities>. For the first which matches <label>,
        this method returns its Number. Returns 0 if nothing found
        Can be called recursively (labels are not specified as unique)
        <exact> : if True (default), exact match is required
        else, checks the END of entity label

        This method is virtual, hence it can be redefined for a more
        efficient search (if exact is true).

        :type label: OCC.wrapper.Standard.Standard_CString
        :type lastnum: int
        :type exact: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_StepModel_NextNumberForLabel(self, *args)


    def HasTemplate(self, *args):
        """
        HasTemplate(Handle_StepData_StepModel self, Standard_CString const name) -> Standard_Boolean

        Returns true if a template is attached to a given name

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepModel_HasTemplate(self, *args)


    def Template(self, *args):
        """
        Template(Handle_StepData_StepModel self, Standard_CString const name) -> Handle_Interface_InterfaceModel

        Returns the template model attached to a name, or a Null Handle

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _StepData.Handle_StepData_StepModel_Template(self, *args)


    def SetTemplate(self, *args):
        """
        SetTemplate(Handle_StepData_StepModel self, Standard_CString const name, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Records a new template model with a name. If the name was
        already recorded, the corresponding template is replaced by
        the new one. Then, WARNING : test HasTemplate to avoid
        surprises

        :type name: OCC.wrapper.Standard.Standard_CString
        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepModel_SetTemplate(self, *args)


    def ListTemplates(self, *args):
        """
        ListTemplates(Handle_StepData_StepModel self) -> Handle_TColStd_HSequenceOfHAsciiString

        Returns the complete list of names attached to template models

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfHAsciiString

        """
        return _StepData.Handle_StepData_StepModel_ListTemplates(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepData_StepModel self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_StepModel_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_StepModel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_StepModel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepModel_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_StepModel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_StepModel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepModel_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_StepModel self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_StepModel_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_StepModel self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_StepModel_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_StepModel self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_StepModel_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_StepModel self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_StepModel_DecrementRefCounter(self, *args)

Handle_StepData_StepModel_swigregister = _StepData.Handle_StepData_StepModel_swigregister
Handle_StepData_StepModel_swigregister(Handle_StepData_StepModel)

def Handle_StepData_StepModel_DownCast(thing):
    return _StepData.Handle_StepData_StepModel_DownCast(thing)
Handle_StepData_StepModel_DownCast = _StepData.Handle_StepData_StepModel_DownCast

class NCollection_Array1_StepData_Field(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_StepData_Field self) -> NCollection_Array1< StepData_Field >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepData.NCollection_Array1_StepData_Field_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_StepData_Field self) -> NCollection_Array1< StepData_Field >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepData.NCollection_Array1_StepData_Field_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_StepData_Field self) -> NCollection_Array1< StepData_Field >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepData.NCollection_Array1_StepData_Field_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_StepData_Field self) -> NCollection_Array1< StepData_Field >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepData.NCollection_Array1_StepData_Field_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepData.new_NCollection_Array1_StepData_Field(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_StepData_Field self, StepData_Field theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepData.NCollection_Array1_StepData_Field_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_StepData_Field self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.NCollection_Array1_StepData_Field_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_StepData_Field self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.NCollection_Array1_StepData_Field_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_StepData_Field self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.NCollection_Array1_StepData_Field_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_StepData_Field self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.NCollection_Array1_StepData_Field_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_StepData_Field self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.NCollection_Array1_StepData_Field_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_StepData_Field self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.NCollection_Array1_StepData_Field_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_StepData_Field self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.NCollection_Array1_StepData_Field_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_StepData_Field self, NCollection_Array1_StepData_Field theOther) -> NCollection_Array1_StepData_Field

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepData.NCollection_Array1_StepData_Field_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_StepData_Field self, NCollection_Array1_StepData_Field theOther) -> NCollection_Array1_StepData_Field

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepData.NCollection_Array1_StepData_Field_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_StepData_Field self, NCollection_Array1_StepData_Field theOther) -> NCollection_Array1_StepData_Field
        assign(NCollection_Array1_StepData_Field self, NCollection_Array1_StepData_Field theOther) -> NCollection_Array1_StepData_Field

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepData.NCollection_Array1_StepData_Field_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepData.NCollection_Array1_StepData_Field_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_StepData_Field self) -> StepData_Field

        @return first element

        :rtype: TheItemType &

        """
        return _StepData.NCollection_Array1_StepData_Field_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepData.NCollection_Array1_StepData_Field_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_StepData_Field self) -> StepData_Field

        @return last element

        :rtype: TheItemType &

        """
        return _StepData.NCollection_Array1_StepData_Field_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepData.NCollection_Array1_StepData_Field_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_StepData_Field self, Standard_Integer const theIndex) -> StepData_Field

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepData.NCollection_Array1_StepData_Field_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepData.NCollection_Array1_StepData_Field___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepData.NCollection_Array1_StepData_Field_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_StepData_Field self, Standard_Integer const theIndex, StepData_Field theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepData.NCollection_Array1_StepData_Field_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_StepData_Field self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepData.NCollection_Array1_StepData_Field_Resize(self, *args)

    __swig_destroy__ = _StepData.delete_NCollection_Array1_StepData_Field
NCollection_Array1_StepData_Field_swigregister = _StepData.NCollection_Array1_StepData_Field_swigregister
NCollection_Array1_StepData_Field_swigregister(NCollection_Array1_StepData_Field)


try:
	StepData_Array1OfField = NCollection_Array1_StepData_Field
except NameError:
	pass # does not exist, probably ignored

class Handle_StepData_EDescr(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_EDescr self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_EDescr_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_EDescr self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_EDescr_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_EDescr self, StepData_EDescr thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_EDescr_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_EDescr self, Handle_StepData_EDescr theHandle) -> Handle_StepData_EDescr
        assign(Handle_StepData_EDescr self, StepData_EDescr thePtr) -> Handle_StepData_EDescr
        assign(Handle_StepData_EDescr self, Handle_StepData_EDescr theHandle) -> Handle_StepData_EDescr

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_EDescr_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_EDescr self) -> StepData_EDescr

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_EDescr_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_EDescr self) -> StepData_EDescr

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_EDescr___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_EDescr self) -> StepData_EDescr

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_EDescr___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_EDescr___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_EDescr___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_EDescr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_EDescr_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_EDescr

    def Matches(self, *args):
        """
        Matches(Handle_StepData_EDescr self, Standard_CString const steptype) -> Standard_Boolean

        Tells if a ESDescr matches a step type : exact or super type

        :type steptype: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_EDescr_Matches(self, *args)


    def IsComplex(self, *args):
        """
        IsComplex(Handle_StepData_EDescr self) -> Standard_Boolean

        Tells if a EDescr is complex (ECDescr) or simple (ESDescr)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_EDescr_IsComplex(self, *args)


    def NewEntity(self, *args):
        """
        NewEntity(Handle_StepData_EDescr self) -> Handle_StepData_Described

        Creates a described entity (i.e. a simple one)

        :rtype: OCC.wrapper.StepData.Handle_StepData_Described

        """
        return _StepData.Handle_StepData_EDescr_NewEntity(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_EDescr self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_EDescr_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_EDescr_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_EDescr_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepData_EDescr self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_EDescr_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_EDescr self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_EDescr self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_EDescr_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_EDescr self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_EDescr self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_EDescr_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_EDescr self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_EDescr_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_EDescr self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_EDescr_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_EDescr self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_EDescr_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_EDescr self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_EDescr_DecrementRefCounter(self, *args)

Handle_StepData_EDescr_swigregister = _StepData.Handle_StepData_EDescr_swigregister
Handle_StepData_EDescr_swigregister(Handle_StepData_EDescr)

def Handle_StepData_EDescr_DownCast(thing):
    return _StepData.Handle_StepData_EDescr_DownCast(thing)
Handle_StepData_EDescr_DownCast = _StepData.Handle_StepData_EDescr_DownCast

class Handle_StepData_ECDescr(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_ECDescr self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_ECDescr_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_ECDescr self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_ECDescr_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_ECDescr self, StepData_ECDescr thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_ECDescr_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_ECDescr self, Handle_StepData_ECDescr theHandle) -> Handle_StepData_ECDescr
        assign(Handle_StepData_ECDescr self, StepData_ECDescr thePtr) -> Handle_StepData_ECDescr
        assign(Handle_StepData_ECDescr self, Handle_StepData_ECDescr theHandle) -> Handle_StepData_ECDescr

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_ECDescr_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_ECDescr self) -> StepData_ECDescr

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_ECDescr_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_ECDescr self) -> StepData_ECDescr

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_ECDescr___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_ECDescr self) -> StepData_ECDescr

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_ECDescr___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_ECDescr___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_ECDescr___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_ECDescr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_ECDescr_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_ECDescr

    def Add(self, *args):
        """
        Add(Handle_StepData_ECDescr self, Handle_StepData_ESDescr member)

        Adds a member
        Warning : members are added in alphabetic order

        :type member: OCC.wrapper.StepData.Handle_StepData_ESDescr

        """
        return _StepData.Handle_StepData_ECDescr_Add(self, *args)


    def NbMembers(self, *args):
        """
        NbMembers(Handle_StepData_ECDescr self) -> Standard_Integer

        Returns the count of members

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_ECDescr_NbMembers(self, *args)


    def Member(self, *args):
        """
        Member(Handle_StepData_ECDescr self, Standard_Integer const num) -> Handle_StepData_ESDescr

        Returns a Member from its rank

        :type num: int
        :rtype: OCC.wrapper.StepData.Handle_StepData_ESDescr

        """
        return _StepData.Handle_StepData_ECDescr_Member(self, *args)


    def TypeList(self, *args):
        """
        TypeList(Handle_StepData_ECDescr self) -> Handle_TColStd_HSequenceOfAsciiString

        Returns the ordered list of types

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfAsciiString

        """
        return _StepData.Handle_StepData_ECDescr_TypeList(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_StepData_ECDescr self, Standard_CString const steptype) -> Standard_Boolean

        Tells if a ESDescr matches a step type : exact or super type

        :type steptype: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_ECDescr_Matches(self, *args)


    def IsComplex(self, *args):
        """
        IsComplex(Handle_StepData_ECDescr self) -> Standard_Boolean

        Returns True

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_ECDescr_IsComplex(self, *args)


    def NewEntity(self, *args):
        """
        NewEntity(Handle_StepData_ECDescr self) -> Handle_StepData_Described

        Creates a described entity (i.e. a complex one, made of one
        simple entity per member)

        :rtype: OCC.wrapper.StepData.Handle_StepData_Described

        """
        return _StepData.Handle_StepData_ECDescr_NewEntity(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_ECDescr self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_ECDescr_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_ECDescr_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_ECDescr_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepData_ECDescr self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_ECDescr_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_ECDescr self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_ECDescr self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_ECDescr_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_ECDescr self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_ECDescr self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_ECDescr_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_ECDescr self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_ECDescr_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_ECDescr self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_ECDescr_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_ECDescr self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_ECDescr_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_ECDescr self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_ECDescr_DecrementRefCounter(self, *args)

Handle_StepData_ECDescr_swigregister = _StepData.Handle_StepData_ECDescr_swigregister
Handle_StepData_ECDescr_swigregister(Handle_StepData_ECDescr)

def Handle_StepData_ECDescr_DownCast(thing):
    return _StepData.Handle_StepData_ECDescr_DownCast(thing)
Handle_StepData_ECDescr_DownCast = _StepData.Handle_StepData_ECDescr_DownCast

class Handle_StepData_GlobalNodeOfWriterLib(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_GlobalNodeOfWriterLib self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_GlobalNodeOfWriterLib_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_GlobalNodeOfWriterLib self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_GlobalNodeOfWriterLib_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_GlobalNodeOfWriterLib self, StepData_GlobalNodeOfWriterLib thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_GlobalNodeOfWriterLib_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_GlobalNodeOfWriterLib self, Handle_StepData_GlobalNodeOfWriterLib theHandle) -> Handle_StepData_GlobalNodeOfWriterLib
        assign(Handle_StepData_GlobalNodeOfWriterLib self, StepData_GlobalNodeOfWriterLib thePtr) -> Handle_StepData_GlobalNodeOfWriterLib
        assign(Handle_StepData_GlobalNodeOfWriterLib self, Handle_StepData_GlobalNodeOfWriterLib theHandle) -> Handle_StepData_GlobalNodeOfWriterLib

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_GlobalNodeOfWriterLib_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_GlobalNodeOfWriterLib self) -> StepData_GlobalNodeOfWriterLib

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_GlobalNodeOfWriterLib_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_GlobalNodeOfWriterLib self) -> StepData_GlobalNodeOfWriterLib

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_GlobalNodeOfWriterLib___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_GlobalNodeOfWriterLib self) -> StepData_GlobalNodeOfWriterLib

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_GlobalNodeOfWriterLib___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_GlobalNodeOfWriterLib___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_GlobalNodeOfWriterLib___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_GlobalNodeOfWriterLib(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_GlobalNodeOfWriterLib_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_GlobalNodeOfWriterLib

    def Add(self, *args):
        """
        Add(Handle_StepData_GlobalNodeOfWriterLib self, Handle_StepData_ReadWriteModule amodule, Handle_StepData_Protocol aprotocol)

        Adds a Module bound with a Protocol to the list : does
        nothing if already in the list, THAT IS, Same Type (exact
        match) and Same State (that is, IsEqual is not required)
        Once added, stores its attached Protocol in correspondance

        :type amodule: OCC.wrapper.StepData.Handle_StepData_ReadWriteModule
        :type aprotocol: OCC.wrapper.StepData.Handle_StepData_Protocol

        """
        return _StepData.Handle_StepData_GlobalNodeOfWriterLib_Add(self, *args)


    def Module(self, *args):
        """
        Returns the Module stored in a given GlobalNode

        :rtype: OCC.wrapper.StepData.Handle_StepData_ReadWriteModule

        """
        res = _StepData.Handle_StepData_GlobalNodeOfWriterLib_Module(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Protocol(self, *args):
        """
        Returns the attached Protocol stored in a given GlobalNode

        :rtype: OCC.wrapper.StepData.Handle_StepData_Protocol

        """
        res = _StepData.Handle_StepData_GlobalNodeOfWriterLib_Protocol(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Next(self, *args):
        """
        Returns the Next GlobalNode. If none is defined, returned
        value is a Null Handle

        :rtype: OCC.wrapper.StepData.Handle_StepData_GlobalNodeOfWriterLib

        """
        res = _StepData.Handle_StepData_GlobalNodeOfWriterLib_Next(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_GlobalNodeOfWriterLib self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_GlobalNodeOfWriterLib_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_GlobalNodeOfWriterLib_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_GlobalNodeOfWriterLib_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepData_GlobalNodeOfWriterLib self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_GlobalNodeOfWriterLib_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_GlobalNodeOfWriterLib self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_GlobalNodeOfWriterLib self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_GlobalNodeOfWriterLib_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_GlobalNodeOfWriterLib self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_GlobalNodeOfWriterLib self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_GlobalNodeOfWriterLib_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_GlobalNodeOfWriterLib self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_GlobalNodeOfWriterLib_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_GlobalNodeOfWriterLib self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_GlobalNodeOfWriterLib_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_GlobalNodeOfWriterLib self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_GlobalNodeOfWriterLib_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_GlobalNodeOfWriterLib self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_GlobalNodeOfWriterLib_DecrementRefCounter(self, *args)

Handle_StepData_GlobalNodeOfWriterLib_swigregister = _StepData.Handle_StepData_GlobalNodeOfWriterLib_swigregister
Handle_StepData_GlobalNodeOfWriterLib_swigregister(Handle_StepData_GlobalNodeOfWriterLib)

def Handle_StepData_GlobalNodeOfWriterLib_DownCast(thing):
    return _StepData.Handle_StepData_GlobalNodeOfWriterLib_DownCast(thing)
Handle_StepData_GlobalNodeOfWriterLib_DownCast = _StepData.Handle_StepData_GlobalNodeOfWriterLib_DownCast

class Handle_StepData_SelectNamed(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_SelectNamed self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_SelectNamed_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_SelectNamed self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_SelectNamed_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_SelectNamed self, StepData_SelectNamed thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_SelectNamed_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_SelectNamed self, Handle_StepData_SelectNamed theHandle) -> Handle_StepData_SelectNamed
        assign(Handle_StepData_SelectNamed self, StepData_SelectNamed thePtr) -> Handle_StepData_SelectNamed
        assign(Handle_StepData_SelectNamed self, Handle_StepData_SelectNamed theHandle) -> Handle_StepData_SelectNamed

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_SelectNamed_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_SelectNamed self) -> StepData_SelectNamed

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_SelectNamed_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_SelectNamed self) -> StepData_SelectNamed

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_SelectNamed___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_SelectNamed self) -> StepData_SelectNamed

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_SelectNamed___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_SelectNamed___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_SelectNamed___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_SelectNamed(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_SelectNamed_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_SelectNamed

    def HasName(self, *args):
        """
        HasName(Handle_StepData_SelectNamed self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectNamed_HasName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepData_SelectNamed self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectNamed_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepData_SelectNamed self, Standard_CString const name) -> Standard_Boolean

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectNamed_SetName(self, *args)


    def Field(self, *args):
        """
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        res = _StepData.Handle_StepData_SelectNamed_Field(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CField(self, *args):
        """
        CField(Handle_StepData_SelectNamed self) -> StepData_Field

        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        return _StepData.Handle_StepData_SelectNamed_CField(self, *args)


    def Kind(self, *args):
        """
        Kind(Handle_StepData_SelectNamed self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectNamed_Kind(self, *args)


    def SetKind(self, *args):
        """
        SetKind(Handle_StepData_SelectNamed self, Standard_Integer const kind)

        :type kind: int

        """
        return _StepData.Handle_StepData_SelectNamed_SetKind(self, *args)


    def Int(self, *args):
        """
        Int(Handle_StepData_SelectNamed self) -> Standard_Integer

        This internal method gives access to a value implemented by an
        Integer (to read it)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectNamed_Int(self, *args)


    def SetInt(self, *args):
        """
        SetInt(Handle_StepData_SelectNamed self, Standard_Integer const val)

        This internal method gives access to a value implemented by an
        Integer (to set it)

        :type val: int

        """
        return _StepData.Handle_StepData_SelectNamed_SetInt(self, *args)


    def Real(self, *args):
        """
        Real(Handle_StepData_SelectNamed self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepData.Handle_StepData_SelectNamed_Real(self, *args)


    def SetReal(self, *args):
        """
        SetReal(Handle_StepData_SelectNamed self, Standard_Real const val)

        :type val: float

        """
        return _StepData.Handle_StepData_SelectNamed_SetReal(self, *args)


    def String(self, *args):
        """
        String(Handle_StepData_SelectNamed self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectNamed_String(self, *args)


    def SetString(self, *args):
        """
        SetString(Handle_StepData_SelectNamed self, Standard_CString const val)

        :type val: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectNamed_SetString(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_SelectNamed self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_SelectNamed_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_SelectNamed_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_SelectNamed_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Matches(self, *args):
        """
        Matches(Handle_StepData_SelectNamed self, Standard_CString const name) -> Standard_Boolean

        Tells if the name of a SelectMember matches a given one
        By default, compares the strings, can be redefined (optimised)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectNamed_Matches(self, *args)


    def ParamType(self, *args):
        """
        ParamType(Handle_StepData_SelectNamed self) -> Interface_ParamType

        Returns the Kind of the SelectMember, under the form of an
        enum ParamType

        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _StepData.Handle_StepData_SelectNamed_ParamType(self, *args)


    def Integer(self, *args):
        """
        Integer(Handle_StepData_SelectNamed self) -> Standard_Integer

        Gets the value as an Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectNamed_Integer(self, *args)


    def SetInteger(self, *args):
        """
        SetInteger(Handle_StepData_SelectNamed self, Standard_Integer const val)

        :type val: int

        """
        return _StepData.Handle_StepData_SelectNamed_SetInteger(self, *args)


    def Boolean(self, *args):
        """
        Boolean(Handle_StepData_SelectNamed self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectNamed_Boolean(self, *args)


    def SetBoolean(self, *args):
        """
        SetBoolean(Handle_StepData_SelectNamed self, Standard_Boolean const val)

        :type val: bool

        """
        return _StepData.Handle_StepData_SelectNamed_SetBoolean(self, *args)


    def Logical(self, *args):
        """
        Logical(Handle_StepData_SelectNamed self) -> StepData_Logical

        :rtype: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepData.Handle_StepData_SelectNamed_Logical(self, *args)


    def SetLogical(self, *args):
        """
        SetLogical(Handle_StepData_SelectNamed self, StepData_Logical const val)

        :type val: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepData.Handle_StepData_SelectNamed_SetLogical(self, *args)


    def Enum(self, *args):
        """
        Enum(Handle_StepData_SelectNamed self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectNamed_Enum(self, *args)


    def EnumText(self, *args):
        """
        EnumText(Handle_StepData_SelectNamed self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectNamed_EnumText(self, *args)


    def SetEnum(self, *args):
        """
        SetEnum(Handle_StepData_SelectNamed self, Standard_Integer const val, Standard_CString const text)

        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectNamed_SetEnum(self, *args)


    def SetEnumText(self, *args):
        """
        SetEnumText(Handle_StepData_SelectNamed self, Standard_Integer const val, Standard_CString const text)

        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectNamed_SetEnumText(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepData_SelectNamed self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_SelectNamed_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_SelectNamed self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_SelectNamed self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectNamed_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_SelectNamed self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_SelectNamed self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectNamed_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_SelectNamed self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_SelectNamed_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_SelectNamed self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectNamed_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_SelectNamed self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_SelectNamed_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_SelectNamed self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectNamed_DecrementRefCounter(self, *args)

Handle_StepData_SelectNamed_swigregister = _StepData.Handle_StepData_SelectNamed_swigregister
Handle_StepData_SelectNamed_swigregister(Handle_StepData_SelectNamed)

def Handle_StepData_SelectNamed_DownCast(thing):
    return _StepData.Handle_StepData_SelectNamed_DownCast(thing)
Handle_StepData_SelectNamed_DownCast = _StepData.Handle_StepData_SelectNamed_DownCast

class Handle_StepData_DescrReadWrite(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_DescrReadWrite self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_DescrReadWrite_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_DescrReadWrite self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_DescrReadWrite_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_DescrReadWrite self, StepData_DescrReadWrite thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_DescrReadWrite_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_DescrReadWrite self, Handle_StepData_DescrReadWrite theHandle) -> Handle_StepData_DescrReadWrite
        assign(Handle_StepData_DescrReadWrite self, StepData_DescrReadWrite thePtr) -> Handle_StepData_DescrReadWrite
        assign(Handle_StepData_DescrReadWrite self, Handle_StepData_DescrReadWrite theHandle) -> Handle_StepData_DescrReadWrite

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_DescrReadWrite_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_DescrReadWrite self) -> StepData_DescrReadWrite

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_DescrReadWrite_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_DescrReadWrite self) -> StepData_DescrReadWrite

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_DescrReadWrite___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_DescrReadWrite self) -> StepData_DescrReadWrite

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_DescrReadWrite___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_DescrReadWrite___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_DescrReadWrite___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_DescrReadWrite(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_DescrReadWrite_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_DescrReadWrite

    def CaseStep(self, *args):
        """
        CaseStep(Handle_StepData_DescrReadWrite self, TCollection_AsciiString atype) -> Standard_Integer
        CaseStep(Handle_StepData_DescrReadWrite self, NCollection_Sequence_TCollection_AsciiString types) -> Standard_Integer

        :type types: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_DescrReadWrite_CaseStep(self, *args)


    def IsComplex(self, *args):
        """
        IsComplex(Handle_StepData_DescrReadWrite self, Standard_Integer const CN) -> Standard_Boolean

        :type CN: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_DescrReadWrite_IsComplex(self, *args)


    def StepType(self, *args):
        """
        :type CN: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _StepData.Handle_StepData_DescrReadWrite_StepType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ComplexType(self, *args):
        """
        ComplexType(Handle_StepData_DescrReadWrite self, Standard_Integer const CN, NCollection_Sequence_TCollection_AsciiString types) -> Standard_Boolean

        :type CN: int
        :type types: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_DescrReadWrite_ComplexType(self, *args)


    def ReadStep(self, *args):
        """
        ReadStep(Handle_StepData_DescrReadWrite self, Standard_Integer const CN, Handle_StepData_StepReaderData data, Standard_Integer const num, Handle_Interface_Check ach, Handle_Standard_Transient ent)

        :type CN: int
        :type data: OCC.wrapper.StepData.Handle_StepData_StepReaderData
        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.Handle_StepData_DescrReadWrite_ReadStep(self, *args)


    def WriteStep(self, *args):
        """
        WriteStep(Handle_StepData_DescrReadWrite self, Standard_Integer const CN, StepData_StepWriter SW, Handle_Standard_Transient ent)

        :type CN: int
        :type SW: OCC.wrapper.StepData.StepData_StepWriter
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.Handle_StepData_DescrReadWrite_WriteStep(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_DescrReadWrite self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_DescrReadWrite_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_DescrReadWrite_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_DescrReadWrite_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CaseNum(self, *args):
        """
        CaseNum(Handle_StepData_DescrReadWrite self, Handle_Interface_FileReaderData data, Standard_Integer const num) -> Standard_Integer

        Translate the Type of record <num> in <data> to a positive
        Case Number, or 0 if failed.
        Works with a StepReaderData, in which the Type of an Entity
        is defined as a String : Reads the RecordType <num> then calls
        CaseNum (this type)
        Warning : The methods CaseStep, StepType and Recognize,
        must be in phase (triplets CaseNum-StepType-Type of Object)

        :type data: OCC.wrapper.Interface.Handle_Interface_FileReaderData
        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_DescrReadWrite_CaseNum(self, *args)


    def ShortType(self, *args):
        """
        ShortType(Handle_StepData_DescrReadWrite self, Standard_Integer const CN) -> TCollection_AsciiString

        Function specific to STEP. Some STEP Types have a short form
        This method can be redefined to fill it
        By default, returns an empty string, which is then interpreted
        to take normal form from StepType

        :type CN: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _StepData.Handle_StepData_DescrReadWrite_ShortType(self, *args)


    def Read(self, *args):
        """
        Read(Handle_StepData_DescrReadWrite self, Standard_Integer const CN, Handle_Interface_FileReaderData data, Standard_Integer const num, Handle_Interface_Check ach, Handle_Standard_Transient ent)

        General Read Function, calls ReadStep

        :type CN: int
        :type data: OCC.wrapper.Interface.Handle_Interface_FileReaderData
        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.Handle_StepData_DescrReadWrite_Read(self, *args)


    def NewRead(self, *args):
        """
        NewRead(Handle_StepData_DescrReadWrite self, Standard_Integer const casenum, Handle_Interface_FileReaderData data, Standard_Integer const num, Handle_Interface_Check ach, Handle_Standard_Transient ent) -> Standard_Boolean

        Specific operator (create+read) defaulted to do nothing.
        It can be redefined when it is not possible to work in two
        steps (NewVoid then Read). This occurs when no default
        constructor is defined : hence the result <ent> must be
        created with an effective definition from the reader.
        Remark : if NewRead is defined, Copy has nothing to do.

        Returns True if it has produced something, false else.
        If nothing was produced, <ach> should be filled : it will be
        treated as "Unrecognized case" by reader tool.

        :type casenum: int
        :type data: OCC.wrapper.Interface.Handle_Interface_FileReaderData
        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_DescrReadWrite_NewRead(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepData_DescrReadWrite self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_DescrReadWrite_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_DescrReadWrite self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_DescrReadWrite self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_DescrReadWrite_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_DescrReadWrite self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_DescrReadWrite self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_DescrReadWrite_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_DescrReadWrite self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_DescrReadWrite_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_DescrReadWrite self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_DescrReadWrite_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_DescrReadWrite self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_DescrReadWrite_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_DescrReadWrite self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_DescrReadWrite_DecrementRefCounter(self, *args)

Handle_StepData_DescrReadWrite_swigregister = _StepData.Handle_StepData_DescrReadWrite_swigregister
Handle_StepData_DescrReadWrite_swigregister(Handle_StepData_DescrReadWrite)

def Handle_StepData_DescrReadWrite_DownCast(thing):
    return _StepData.Handle_StepData_DescrReadWrite_DownCast(thing)
Handle_StepData_DescrReadWrite_DownCast = _StepData.Handle_StepData_DescrReadWrite_DownCast

class Handle_StepData_StepReaderData(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_StepReaderData self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_StepReaderData_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_StepReaderData self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_StepReaderData_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_StepReaderData self, StepData_StepReaderData thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_StepReaderData_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_StepReaderData self, Handle_StepData_StepReaderData theHandle) -> Handle_StepData_StepReaderData
        assign(Handle_StepData_StepReaderData self, StepData_StepReaderData thePtr) -> Handle_StepData_StepReaderData
        assign(Handle_StepData_StepReaderData self, Handle_StepData_StepReaderData theHandle) -> Handle_StepData_StepReaderData

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_StepReaderData_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_StepReaderData self) -> StepData_StepReaderData

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_StepReaderData_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_StepReaderData self) -> StepData_StepReaderData

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_StepReaderData___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_StepReaderData self) -> StepData_StepReaderData

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_StepReaderData___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_StepReaderData___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_StepReaderData___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_StepReaderData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_StepReaderData_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_StepReaderData

    def SetRecord(self, *args):
        """
        SetRecord(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_CString const ident, Standard_CString const type, Standard_Integer const nbpar)

        Fills the fields of a record

        :type num: int
        :type ident: OCC.wrapper.Standard.Standard_CString
        :type type: OCC.wrapper.Standard.Standard_CString
        :type nbpar: int

        """
        return _StepData.Handle_StepData_StepReaderData_SetRecord(self, *args)


    def AddStepParam(self, *args):
        """
        AddStepParam(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_CString const aval, Interface_ParamType const atype, Standard_Integer const nument=0)

        Fills the fields of a parameter of a record. This is a variant
        of AddParam, Adapted to STEP (optimized for specific values)

        :type num: int
        :type aval: OCC.wrapper.Standard.Standard_CString
        :type atype: OCC.wrapper.Interface.Interface_ParamType
        :type nument: int

        """
        return _StepData.Handle_StepData_StepReaderData_AddStepParam(self, *args)


    def RecordType(self, *args):
        """
        Returns Record Type

        :type num: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _StepData.Handle_StepData_StepReaderData_RecordType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CType(self, *args):
        """
        CType(Handle_StepData_StepReaderData self, Standard_Integer const num) -> Standard_CString

        Returns Record Type as a CString
        was C++ : return const

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_StepReaderData_CType(self, *args)


    def RecordIdent(self, *args):
        """
        RecordIdent(Handle_StepData_StepReaderData self, Standard_Integer const num) -> Standard_Integer

        Returns record identifier (Positive number)
        If returned ident is not positive : Sub-List or Scope mark

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_StepReaderData_RecordIdent(self, *args)


    def SubListNumber(self, *args):
        """
        SubListNumber(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_Boolean const aslast) -> Standard_Integer

        Returns SubList numero designated by a parameter (nump) in a
        record (num), or zero if the parameter does not exist or is
        not a SubList address. Zero too If aslast is True and nump
        is not for the last parameter

        :type num: int
        :type nump: int
        :type aslast: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_StepReaderData_SubListNumber(self, *args)


    def IsComplex(self, *args):
        """
        IsComplex(Handle_StepData_StepReaderData self, Standard_Integer const num) -> Standard_Boolean

        Returns True if <num> corresponds to a Complex Type Entity
        (as can be defined by ANDOR Express clause)

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepReaderData_IsComplex(self, *args)


    def ComplexType(self, *args):
        """
        ComplexType(Handle_StepData_StepReaderData self, Standard_Integer const num, NCollection_Sequence_TCollection_AsciiString types)

        Returns the List of Types which correspond to a Complex Type
        Entity. If not Complex, there is just one Type in it
        For a SubList or a Scope mark, <types> remains empty

        :type num: int
        :type types: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString

        """
        return _StepData.Handle_StepData_StepReaderData_ComplexType(self, *args)


    def NextForComplex(self, *args):
        """
        NextForComplex(Handle_StepData_StepReaderData self, Standard_Integer const num) -> Standard_Integer

        Returns the Next "Componant" for a Complex Type Entity, of
        which <num> is already a Componant (the first one or a next one)
        Returns 0 for a Simple Type or for the last Componant

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_StepReaderData_NextForComplex(self, *args)


    def NamedForComplex(self, *args):
        """
        NamedForComplex(Handle_StepData_StepReaderData self, Standard_CString const name, Standard_Integer const num0, Handle_Interface_Check ach) -> Standard_Boolean
        NamedForComplex(Handle_StepData_StepReaderData self, Standard_CString const theName, Standard_CString const theShortName, Standard_Integer const num0, Handle_Interface_Check ach) -> Standard_Boolean

        Determines the first component which brings a given name, or
        short name for a Complex Type Entity
        <num0> is the very first record of this entity
        <num> is given the last NextNamedForComplex, starts at zero
        it is returned as the newly found number
        Hence, in the normal case, NextNamedForComplex starts by num0
        if <num> is zero, else by NextForComplex(num)
        If the alphabetic order is not respected, it restarts from
        num0 and loops on NextForComplex until finding <name>
        In case of "non-alphabetic order", <ach> is filled with a
        Warning for this name
        In case of "not-found at all", <ach> is filled with a Fail,
        and <num> is returned as zero

        Returns True if alphabetic order, False else

        :type theName: OCC.wrapper.Standard.Standard_CString
        :type theShortName: OCC.wrapper.Standard.Standard_CString
        :type num0: int
        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepReaderData_NamedForComplex(self, *args)


    def CheckNbParams(self, *args):
        """
        CheckNbParams(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nbreq, Handle_Interface_Check ach, Standard_CString const mess) -> Standard_Boolean

        Checks Count of Parameters of record <num> to equate <nbreq>
        If this Check is successful, returns True
        Else, fills <ach> with an Error Message then returns False
        <mess> is included in the Error message if given non empty

        :type num: int
        :type nbreq: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type mess: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepReaderData_CheckNbParams(self, *args)


    def ReadSubList(self, *args):
        """
        ReadSubList(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach, Standard_Boolean const optional, Standard_Integer const lenmin=0, Standard_Integer const lenmax=0) -> Standard_Boolean

        reads parameter <nump> of record <num> as a sub-list (may be
        typed, see ReadTypedParameter in this case)
        Returns True if OK. Else (not a LIST), returns false and
        feeds Check with appropriate check
        If <optional> is True and Param is not defined, returns True
        with <ach> not filled and <numsub> returned as 0
        Works with SubListNumber with <aslast> false (no specific case
        for last parameter)

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type numsub: int
        :type optional: bool
        :type lenmin: int
        :type lenmax: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepReaderData_ReadSubList(self, *args)


    def ReadSub(self, *args):
        """
        ReadSub(Handle_StepData_StepReaderData self, Standard_Integer const numsub, Standard_CString const mess, Handle_Interface_Check ach, Handle_StepData_PDescr descr, Handle_Standard_Transient val) -> Standard_Integer

        reads the content of a sub-list into a transient :
        SelectNamed, or HArray1 of Integer,Real,String,Transient ...
        recursive call if list of list ...
        If a sub-list has mixed types, an HArray1OfTransient is
        produced, it may contain SelectMember
        Intended to be called by ReadField
        The returned status is : negative if failed, 0 if empty.
        Else the kind to be recorded in the field

        :type numsub: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type descr: OCC.wrapper.StepData.Handle_StepData_PDescr
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_StepReaderData_ReadSub(self, *args)


    def ReadMember(self, *args):
        """
        ReadMember(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach, Handle_StepData_SelectMember val) -> Standard_Boolean

        Reads parameter <nump> of record <num> into a SelectMember,
        self-sufficient (no Description needed)
        If <val> is already created, it will be filled, as possible
        And if reading does not match its own description, the result
        will be False
        If <val> is not it not yet created, it will be (SelectNamed)
        Usefull if a field is defined as a SelectMember, directly
        (SELECT with no Entity as member)
        But SelectType also manages SelectMember (for SELECT with
        some members as Entity, some other not)

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type val: OCC.wrapper.StepData.Handle_StepData_SelectMember
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepReaderData_ReadMember(self, *args)


    def ReadField(self, *args):
        """
        ReadField(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach, Handle_StepData_PDescr descr, StepData_Field fild) -> Standard_Boolean

        reads parameter <nump> of record <num> into a Field,
        controlled by a Parameter Descriptor (PDescr), which controls
        its allowed type(s) and value
        <ach> is filled if the read parameter does not match its
        description (but the field is read anyway)
        If the description is not defined, no control is done
        Returns True when done

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type descr: OCC.wrapper.StepData.Handle_StepData_PDescr
        :type fild: OCC.wrapper.StepData.StepData_Field
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepReaderData_ReadField(self, *args)


    def ReadList(self, *args):
        """
        ReadList(Handle_StepData_StepReaderData self, Standard_Integer const num, Handle_Interface_Check ach, Handle_StepData_ESDescr descr, StepData_FieldList list) -> Standard_Boolean

        reads a list of fields controlled by an ESDescr

        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type descr: OCC.wrapper.StepData.Handle_StepData_ESDescr
        :type list: OCC.wrapper.StepData.StepData_FieldList
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepReaderData_ReadList(self, *args)


    def ReadAny(self, *args):
        """
        ReadAny(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach, Handle_StepData_PDescr descr, Handle_Standard_Transient val) -> Standard_Boolean

        Reads parameter <nump> of record <num> into a Transient Value
        according to the type of the parameter :
        Named for Integer,Boolean,Logical,Enum,Real : SelectNamed
        Immediate Integer,Boolean,Logical,Enum,Real : SelectInt/Real
        Text  : HAsciiString
        Ident : the referenced Entity
        Sub-List not processed, see ReadSub
        This value is controlled by a Parameter Descriptor (PDescr),
        which controls its allowed type and value
        <ach> is filled if the read parameter does not match its
        description (the select is nevertheless created if possible)

        Warning : val is in out, hence it is possible to predefine a specific
        SelectMember then to fill it. If <val> is Null or if the
        result is not a SelectMember, val itself is returned a new ref
        For a Select with a Name, <val> must then be a SelectNamed

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type descr: OCC.wrapper.StepData.Handle_StepData_PDescr
        :type val: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepReaderData_ReadAny(self, *args)


    def ReadXY(self, *args):
        """
        ReadXY(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach) -> Standard_Boolean

        reads parameter <nump> of record <num> as a sub-list of
        two Reals X,Y. Returns True if OK. Else, returns false and
        feeds Check with appropriate Fails (parameter not a sub-list,
        not two Reals in the sub-list) composed with "mess" which
        gives the name of the parameter

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type X: float
        :type Y: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepReaderData_ReadXY(self, *args)


    def ReadXYZ(self, *args):
        """
        ReadXYZ(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach) -> Standard_Boolean

        reads parameter <nump> of record <num> as a sub-list of
        three Reals X,Y,Z. Return value and Check managed as by
        ReadXY (demands a sub-list of three Reals)

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type X: float
        :type Y: float
        :type Z: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepReaderData_ReadXYZ(self, *args)


    def ReadReal(self, *args):
        """
        ReadReal(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach) -> Standard_Boolean

        reads parameter <nump> of record <num> as a single Real value.
        Return value and Check managed as by ReadXY (demands a Real)

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type val: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepReaderData_ReadReal(self, *args)


    def ReadEntity(self, *args):
        """
        ReadEntity(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach, Handle_Standard_Type atype, Handle_Standard_Transient ent) -> Standard_Boolean
        ReadEntity(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach, StepData_SelectType sel) -> Standard_Boolean

        Same as above, but a SelectType checks Type Matching, and
        records the read Entity (see method Value from SelectType)

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type sel: OCC.wrapper.StepData.StepData_SelectType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepReaderData_ReadEntity(self, *args)


    def ReadInteger(self, *args):
        """
        ReadInteger(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach) -> Standard_Boolean

        reads parameter <nump> of record <num> as a single Integer.
        Return value & Check managed as by ReadXY (demands an Integer)

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepReaderData_ReadInteger(self, *args)


    def ReadBoolean(self, *args):
        """
        ReadBoolean(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach) -> Standard_Boolean

        reads parameter <nump> of record <num> as a Boolean
        Return value and Check managed as by ReadReal (demands a
        Boolean enum, i.e. text ".T." for True or ".F." for False)

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type flag: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepReaderData_ReadBoolean(self, *args)


    def ReadLogical(self, *args):
        """
        ReadLogical(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach) -> Standard_Boolean

        reads parameter <nump> of record <num> as a Logical
        Return value and Check managed as by ReadBoolean (demands a
        Logical enum, i.e. text ".T.", ".F.", or ".U.")

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type flag: OCC.wrapper.StepData.StepData_Logical
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepReaderData_ReadLogical(self, *args)


    def ReadString(self, *args):
        """
        ReadString(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach, Handle_TCollection_HAsciiString val) -> Standard_Boolean

        reads parameter <nump> of record <num> as a String (text
        between quotes, quotes are removed by the Read operation)
        Return value and Check managed as by ReadXY (demands a String)

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type val: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepReaderData_ReadString(self, *args)


    def ReadEnumParam(self, *args):
        """
        ReadEnumParam(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach, Standard_CString & text) -> Standard_Boolean

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type text: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepReaderData_ReadEnumParam(self, *args)


    def FailEnumValue(self, *args):
        """
        FailEnumValue(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach)

        Fills a check with a fail message if enumeration value does
        match parameter definition
        Just a help to centralize message definitions

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _StepData.Handle_StepData_StepReaderData_FailEnumValue(self, *args)


    def ReadEnum(self, *args):
        """
        ReadEnum(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach, StepData_EnumTool enumtool) -> Standard_Boolean

        Reads parameter <nump> of record <num> as an Enumeration (text
        between dots) and converts it to an integer value, by an
        EnumTool. Returns True if OK, false if : this parameter is not
        enumeration, or is not recognized by the EnumTool (with fail)

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type enumtool: OCC.wrapper.StepData.StepData_EnumTool
        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepReaderData_ReadEnum(self, *args)


    def ReadTypedParam(self, *args):
        """
        ReadTypedParam(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_Boolean const mustbetyped, Standard_CString const mess, Handle_Interface_Check ach, TCollection_AsciiString typ) -> Standard_Boolean

        Resolves a parameter which can be enclosed in a type def., as
        TYPE(val). The parameter must then be read normally according
        its type.  Parameter to be resolved is <nump> of record <num>
        <mustbetyped> True  demands a typed parameter
        <mustbetyped> False accepts a non-typed parameter as option
        mess and ach as usual
        <numr>,<numrp> are the resolved record and parameter numbers
        = num,nump if no type,  else numrp=1
        <typ> returns the recorded type, or empty string
        Remark : a non-typed list is considered as "non-typed"

        :type num: int
        :type nump: int
        :type mustbetyped: bool
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type numr: int
        :type numrp: int
        :type typ: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepReaderData_ReadTypedParam(self, *args)


    def CheckDerived(self, *args):
        """
        CheckDerived(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Standard_CString const mess, Handle_Interface_Check ach, Standard_Boolean const errstat) -> Standard_Boolean

        Checks if parameter <nump> of record <num> is given as Derived
        If this Check is successful (i.e. Param = "*"), returns True
        Else, fills <ach> with a Message which contains <mess> and
        returns False. According to <errstat>, this message is Warning
        if errstat is False (Default), Fail if errstat is True

        :type num: int
        :type nump: int
        :type mess: OCC.wrapper.Standard.Standard_CString
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type errstat: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepReaderData_CheckDerived(self, *args)


    def NbEntities(self, *args):
        """
        NbEntities(Handle_StepData_StepReaderData self) -> Standard_Integer

        Returns total count of Entities (including Header)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_StepReaderData_NbEntities(self, *args)


    def FindNextRecord(self, *args):
        """
        FindNextRecord(Handle_StepData_StepReaderData self, Standard_Integer const num) -> Standard_Integer

        determines the first suitable record following a given one
        that is, skips SCOPE,ENDSCOPE and SUBLIST records
        Note : skips Header records, which are accessed separately

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_StepReaderData_FindNextRecord(self, *args)


    def SetEntityNumbers(self, *args):
        """
        SetEntityNumbers(Handle_StepData_StepReaderData self, Standard_Boolean const withmap)

        determines reference numbers in EntityNumber fields
        called by Prepare from StepReaderTool to prepare later using
        by a StepModel. This method is attached to StepReaderData
        because it needs a massive amount of data accesses to work

        If <withmap> is given False, the basic exploration algorithm
        is activated, otherwise a map is used as far as it is possible
        this option can be used only to test this algorithm

        :type withmap: bool

        """
        return _StepData.Handle_StepData_StepReaderData_SetEntityNumbers(self, *args)


    def FindNextHeaderRecord(self, *args):
        """
        FindNextHeaderRecord(Handle_StepData_StepReaderData self, Standard_Integer const num) -> Standard_Integer

        determine first suitable record of Header
        works as FindNextRecord, but treats only Header records

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_StepReaderData_FindNextHeaderRecord(self, *args)


    def PrepareHeader(self, *args):
        """
        PrepareHeader(Handle_StepData_StepReaderData self)

        Works as SetEntityNumbers but for Header : more simple because
        there are no Reference, only Sub-Lists


        """
        return _StepData.Handle_StepData_StepReaderData_PrepareHeader(self, *args)


    def GlobalCheck(self, *args):
        """
        GlobalCheck(Handle_StepData_StepReaderData self) -> Handle_Interface_Check

        Returns the Global Check. It can record Fail messages about
        Undefined References (detected by SetEntityNumbers)

        :rtype: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _StepData.Handle_StepData_StepReaderData_GlobalCheck(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_StepReaderData self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_StepReaderData_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_StepReaderData_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_StepReaderData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbRecords(self, *args):
        """
        NbRecords(Handle_StepData_StepReaderData self) -> Standard_Integer

        Returns the count of registered records
        That is, value given for Initialization (can be redefined)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_StepReaderData_NbRecords(self, *args)


    def InitParams(self, *args):
        """
        InitParams(Handle_StepData_StepReaderData self, Standard_Integer const num)

        attaches an empty ParamList to a Record

        :type num: int

        """
        return _StepData.Handle_StepData_StepReaderData_InitParams(self, *args)


    def AddParam(self, *args):
        """
        AddParam(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_CString const aval, Interface_ParamType const atype, Standard_Integer const nument=0)
        AddParam(Handle_StepData_StepReaderData self, Standard_Integer const num, TCollection_AsciiString aval, Interface_ParamType const atype, Standard_Integer const nument=0)
        AddParam(Handle_StepData_StepReaderData self, Standard_Integer const num, Interface_FileParameter FP)

        Same as above, but gets a complete FileParameter
        Warning : Content of <FP> is NOT copied : its original address and space
        in memory are assumed to be managed elsewhere (see ParamSet)

        :type num: int
        :type FP: OCC.wrapper.Interface.Interface_FileParameter

        """
        return _StepData.Handle_StepData_StepReaderData_AddParam(self, *args)


    def SetParam(self, *args):
        """
        SetParam(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump, Interface_FileParameter FP)

        Sets a new value for a parameter of a record, given by :
        num : record number; nump : parameter number in the record

        :type num: int
        :type nump: int
        :type FP: OCC.wrapper.Interface.Interface_FileParameter

        """
        return _StepData.Handle_StepData_StepReaderData_SetParam(self, *args)


    def NbParams(self, *args):
        """
        NbParams(Handle_StepData_StepReaderData self, Standard_Integer const num) -> Standard_Integer

        Returns count of parameters attached to record "num"
        If <num> = 0, returns the total recorded count of parameters

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_StepReaderData_NbParams(self, *args)


    def Params(self, *args):
        """
        Params(Handle_StepData_StepReaderData self, Standard_Integer const num) -> Handle_Interface_ParamList

        Returns the complete ParamList of a record (read only)
        num = 0 to return the whole param list for the file

        :type num: int
        :rtype: OCC.wrapper.Interface.Handle_Interface_ParamList

        """
        return _StepData.Handle_StepData_StepReaderData_Params(self, *args)


    def Param(self, *args):
        """
        Returns parameter "nump" of record "num", as a complete
        FileParameter

        :type num: int
        :type nump: int
        :rtype: OCC.wrapper.Interface.Interface_FileParameter

        """
        res = _StepData.Handle_StepData_StepReaderData_Param(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeParam(self, *args):
        """
        ChangeParam(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump) -> Interface_FileParameter

        Same as above, but in order to be modified on place

        :type num: int
        :type nump: int
        :rtype: OCC.wrapper.Interface.Interface_FileParameter

        """
        return _StepData.Handle_StepData_StepReaderData_ChangeParam(self, *args)


    def ParamType(self, *args):
        """
        ParamType(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump) -> Interface_ParamType

        Returns type of parameter "nump" of record "num"
        Returns literal value of parameter "nump" of record "num"
        was C++ : return const &

        :type num: int
        :type nump: int
        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _StepData.Handle_StepData_StepReaderData_ParamType(self, *args)


    def ParamCValue(self, *args):
        """
        ParamCValue(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump) -> Standard_CString

        Same as above, but as a CString
        was C++ : return const

        :type num: int
        :type nump: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_StepReaderData_ParamCValue(self, *args)


    def IsParamDefined(self, *args):
        """
        IsParamDefined(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump) -> Standard_Boolean

        Returns True if parameter "nump" of record "num" is defined
        (it is not if its type is ParamVoid)

        :type num: int
        :type nump: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepReaderData_IsParamDefined(self, *args)


    def ParamNumber(self, *args):
        """
        ParamNumber(Handle_StepData_StepReaderData self, Standard_Integer const num, Standard_Integer const nump) -> Standard_Integer

        Returns record number of an entity referenced by a parameter
        of type Ident; 0 if no EntityNumber has been determined
        Note that it is used to reference Entities but also Sublists
        (sublists are not objects, but internal descriptions)

        :type num: int
        :type nump: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_StepReaderData_ParamNumber(self, *args)


    def ParamEntity(self, *args):
        """
        Returns the StepEntity referenced by a parameter
        Error if none

        :type num: int
        :type nump: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _StepData.Handle_StepData_StepReaderData_ParamEntity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParamFirstRank(self, *args):
        """
        ParamFirstRank(Handle_StepData_StepReaderData self, Standard_Integer const num) -> Standard_Integer

        Returns the absolute rank of the beginning of a record
        (its lsit is from ParamFirstRank+1 to ParamFirstRank+NbParams)

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_StepReaderData_ParamFirstRank(self, *args)


    def BoundEntity(self, *args):
        """
        Returns the entity bound to a record, set by SetEntities

        :type num: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _StepData.Handle_StepData_StepReaderData_BoundEntity(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BindEntity(self, *args):
        """
        BindEntity(Handle_StepData_StepReaderData self, Standard_Integer const num, Handle_Standard_Transient ent)

        Binds an entity to a record

        :type num: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.Handle_StepData_StepReaderData_BindEntity(self, *args)


    def SetErrorLoad(self, *args):
        """
        SetErrorLoad(Handle_StepData_StepReaderData self, Standard_Boolean const val)

        Sets the status "Error Load" on, to overside check fails
        <val> True  : declares unloaded
        <val> False : declares loaded
        If not called before loading (see FileReaderTool), check fails
        give the status
        IsErrorLoad says if SetErrorLoad has been called by user
        ResetErrorLoad resets it (called by FileReaderTool)
        This allows to specify that the currently loaded entity
        remains unloaded (because of syntactic fail)

        :type val: bool

        """
        return _StepData.Handle_StepData_StepReaderData_SetErrorLoad(self, *args)


    def IsErrorLoad(self, *args):
        """
        IsErrorLoad(Handle_StepData_StepReaderData self) -> Standard_Boolean

        Returns True if the status "Error Load" has been set (to True
        or False)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepReaderData_IsErrorLoad(self, *args)


    def ResetErrorLoad(self, *args):
        """
        ResetErrorLoad(Handle_StepData_StepReaderData self) -> Standard_Boolean

        Returns the former value of status "Error Load" then resets it
        Used to read the status then ensure it is reset

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepReaderData_ResetErrorLoad(self, *args)


    def Destroy(self, *args):
        """
        Destroy(Handle_StepData_StepReaderData self)

        Destructor (waiting for memory management)


        """
        return _StepData.Handle_StepData_StepReaderData_Destroy(self, *args)


    def Fastof(self, *args):
        """
        Fastof(Handle_StepData_StepReaderData self, Standard_CString const str) -> Standard_Real

        Same spec.s as standard <atof> but 5 times faster

        :type str: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepData.Handle_StepData_StepReaderData_Fastof(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepData_StepReaderData self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_StepReaderData_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_StepReaderData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_StepReaderData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepReaderData_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_StepReaderData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_StepReaderData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_StepReaderData_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_StepReaderData self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_StepReaderData_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_StepReaderData self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_StepReaderData_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_StepReaderData self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_StepReaderData_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_StepReaderData self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_StepReaderData_DecrementRefCounter(self, *args)

Handle_StepData_StepReaderData_swigregister = _StepData.Handle_StepData_StepReaderData_swigregister
Handle_StepData_StepReaderData_swigregister(Handle_StepData_StepReaderData)

def Handle_StepData_StepReaderData_DownCast(thing):
    return _StepData.Handle_StepData_StepReaderData_DownCast(thing)
Handle_StepData_StepReaderData_DownCast = _StepData.Handle_StepData_StepReaderData_DownCast

class Handle_StepData_PDescr(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_PDescr self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_PDescr_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_PDescr self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_PDescr_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_PDescr self, StepData_PDescr thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_PDescr_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_PDescr self, Handle_StepData_PDescr theHandle) -> Handle_StepData_PDescr
        assign(Handle_StepData_PDescr self, StepData_PDescr thePtr) -> Handle_StepData_PDescr
        assign(Handle_StepData_PDescr self, Handle_StepData_PDescr theHandle) -> Handle_StepData_PDescr

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_PDescr_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_PDescr self) -> StepData_PDescr

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_PDescr_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_PDescr self) -> StepData_PDescr

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_PDescr___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_PDescr self) -> StepData_PDescr

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_PDescr___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_PDescr___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_PDescr___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_PDescr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_PDescr_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_PDescr

    def SetName(self, *args):
        """
        SetName(Handle_StepData_PDescr self, Standard_CString const name)

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_PDescr_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepData_PDescr self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_PDescr_Name(self, *args)


    def SetSelect(self, *args):
        """
        SetSelect(Handle_StepData_PDescr self)

        Declares this PDescr to be a Select, hence to have members
        <me> itself can be the first member


        """
        return _StepData.Handle_StepData_PDescr_SetSelect(self, *args)


    def AddMember(self, *args):
        """
        AddMember(Handle_StepData_PDescr self, Handle_StepData_PDescr member)

        Adds a member to a SELECT description

        :type member: OCC.wrapper.StepData.Handle_StepData_PDescr

        """
        return _StepData.Handle_StepData_PDescr_AddMember(self, *args)


    def SetMemberName(self, *args):
        """
        SetMemberName(Handle_StepData_PDescr self, Standard_CString const memname)

        Sets a name for SELECT member. To be used if a member is for
        an immediate type

        :type memname: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_PDescr_SetMemberName(self, *args)


    def SetInteger(self, *args):
        """
        SetInteger(Handle_StepData_PDescr self)

        Sets <me> for an Integer value


        """
        return _StepData.Handle_StepData_PDescr_SetInteger(self, *args)


    def SetReal(self, *args):
        """
        SetReal(Handle_StepData_PDescr self)

        Sets <me> for a Real value


        """
        return _StepData.Handle_StepData_PDescr_SetReal(self, *args)


    def SetString(self, *args):
        """
        SetString(Handle_StepData_PDescr self)

        Sets <me> for a String value


        """
        return _StepData.Handle_StepData_PDescr_SetString(self, *args)


    def SetBoolean(self, *args):
        """
        SetBoolean(Handle_StepData_PDescr self)

        Sets <me> for a Boolean value (false,true)


        """
        return _StepData.Handle_StepData_PDescr_SetBoolean(self, *args)


    def SetLogical(self, *args):
        """
        SetLogical(Handle_StepData_PDescr self)

        Sets <me> for a Logical value (false,true,unknown)


        """
        return _StepData.Handle_StepData_PDescr_SetLogical(self, *args)


    def SetEnum(self, *args):
        """
        SetEnum(Handle_StepData_PDescr self)

        Sets <me> for an Enum value
        Then, call AddEnumDef ordered from the first one (value 0)


        """
        return _StepData.Handle_StepData_PDescr_SetEnum(self, *args)


    def AddEnumDef(self, *args):
        """
        AddEnumDef(Handle_StepData_PDescr self, Standard_CString const enumdef)

        Adds an enum value as a string

        :type enumdef: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_PDescr_AddEnumDef(self, *args)


    def SetType(self, *args):
        """
        SetType(Handle_StepData_PDescr self, Handle_Standard_Type atype)

        Sets <me> for an Entity which must match a Type (early-bound)

        :type atype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.Handle_StepData_PDescr_SetType(self, *args)


    def SetDescr(self, *args):
        """
        SetDescr(Handle_StepData_PDescr self, Standard_CString const dscnam)

        Sets <me> for a Described Entity, whose Description must match
        the type name  <dscnam>

        :type dscnam: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_PDescr_SetDescr(self, *args)


    def AddArity(self, *args):
        """
        AddArity(Handle_StepData_PDescr self, Standard_Integer const arity=1)

        Adds an arity count to <me>, by default 1
        1 : a simple field passes to a LIST/ARRAY etc
        or a LIST to a LIST OF LIST
        2 : a simple field passes to a LIST OF LIST

        :type arity: int

        """
        return _StepData.Handle_StepData_PDescr_AddArity(self, *args)


    def SetArity(self, *args):
        """
        SetArity(Handle_StepData_PDescr self, Standard_Integer const arity=1)

        Directly sets the arity count
        0 : simple field
        1 : LIST or ARRAY etc
        2 : LIST OF LIST

        :type arity: int

        """
        return _StepData.Handle_StepData_PDescr_SetArity(self, *args)


    def SetFrom(self, *args):
        """
        SetFrom(Handle_StepData_PDescr self, Handle_StepData_PDescr other)

        Sets <me> as <other> but duplicated
        Hence, some definition may be changed

        :type other: OCC.wrapper.StepData.Handle_StepData_PDescr

        """
        return _StepData.Handle_StepData_PDescr_SetFrom(self, *args)


    def SetOptional(self, *args):
        """
        SetOptional(Handle_StepData_PDescr self, Standard_Boolean const opt)

        Sets/Unsets <me> to accept undefined values

        :type opt: bool

        """
        return _StepData.Handle_StepData_PDescr_SetOptional(self, *args)


    def SetDerived(self, *args):
        """
        SetDerived(Handle_StepData_PDescr self, Standard_Boolean const der)

        Sets/Unsets <me> to be for a derived field

        :type der: bool

        """
        return _StepData.Handle_StepData_PDescr_SetDerived(self, *args)


    def SetField(self, *args):
        """
        SetField(Handle_StepData_PDescr self, Standard_CString const name, Standard_Integer const rank)

        Sets <me> to describe a field of an entity
        With a name and a rank

        :type name: OCC.wrapper.Standard.Standard_CString
        :type rank: int

        """
        return _StepData.Handle_StepData_PDescr_SetField(self, *args)


    def IsSelect(self, *args):
        """
        IsSelect(Handle_StepData_PDescr self) -> Standard_Boolean

        Tells if <me> is for a SELECT

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_PDescr_IsSelect(self, *args)


    def Member(self, *args):
        """
        Member(Handle_StepData_PDescr self, Standard_CString const name) -> Handle_StepData_PDescr

        For a SELECT, returns the member whose name matches <name>
        To this member, the following question can then be asked
        Null Handle if <name> not matched or <me> not a SELECT

        Remark : not to be asked for an entity type
        Hence, following IsInteger .. Enum* only apply on <me> and
        require Member
        While IsType applies on <me> and all Select Members

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.StepData.Handle_StepData_PDescr

        """
        return _StepData.Handle_StepData_PDescr_Member(self, *args)


    def IsInteger(self, *args):
        """
        IsInteger(Handle_StepData_PDescr self) -> Standard_Boolean

        Tells if <me> is for an Integer

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_PDescr_IsInteger(self, *args)


    def IsReal(self, *args):
        """
        IsReal(Handle_StepData_PDescr self) -> Standard_Boolean

        Tells if <me> is for a Real value

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_PDescr_IsReal(self, *args)


    def IsString(self, *args):
        """
        IsString(Handle_StepData_PDescr self) -> Standard_Boolean

        Tells if <me> is for a String value

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_PDescr_IsString(self, *args)


    def IsBoolean(self, *args):
        """
        IsBoolean(Handle_StepData_PDescr self) -> Standard_Boolean

        Tells if <me> is for a Boolean value (false,true)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_PDescr_IsBoolean(self, *args)


    def IsLogical(self, *args):
        """
        IsLogical(Handle_StepData_PDescr self) -> Standard_Boolean

        Tells if <me> is for a Logical value (false,true,unknown)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_PDescr_IsLogical(self, *args)


    def IsEnum(self, *args):
        """
        IsEnum(Handle_StepData_PDescr self) -> Standard_Boolean

        Tells if <me> is for an Enum value
        Then, call AddEnumDef ordered from the first one (value 0)
        Managed by an EnumTool

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_PDescr_IsEnum(self, *args)


    def EnumMax(self, *args):
        """
        EnumMax(Handle_StepData_PDescr self) -> Standard_Integer

        Returns the maximum integer for a suitable value (count - 1)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_PDescr_EnumMax(self, *args)


    def EnumValue(self, *args):
        """
        EnumValue(Handle_StepData_PDescr self, Standard_CString const name) -> Standard_Integer

        Returns the numeric value found for an enum text
        The text must be in capitals and limited by dots
        A non-suitable text gives a negative value to be returned

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_PDescr_EnumValue(self, *args)


    def EnumText(self, *args):
        """
        EnumText(Handle_StepData_PDescr self, Standard_Integer const val) -> Standard_CString

        Returns the text which corresponds to a numeric value,
        between 0 and EnumMax. It is limited by dots

        :type val: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_PDescr_EnumText(self, *args)


    def IsEntity(self, *args):
        """
        IsEntity(Handle_StepData_PDescr self) -> Standard_Boolean

        Tells if <me> is for an Entity, either Described or CDL Type

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_PDescr_IsEntity(self, *args)


    def IsType(self, *args):
        """
        IsType(Handle_StepData_PDescr self, Handle_Standard_Type atype) -> Standard_Boolean

        Tells if <me> is for an entity of a given CDL type (early-bnd)
        (works for <me> + nexts if <me> is a Select)

        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_PDescr_IsType(self, *args)


    def Type(self, *args):
        """
        Type(Handle_StepData_PDescr self) -> Handle_Standard_Type

        Returns the type to match (IsKind), for a CDL Entity
        (else, null handle)

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.Handle_StepData_PDescr_Type(self, *args)


    def IsDescr(self, *args):
        """
        IsDescr(Handle_StepData_PDescr self, Handle_StepData_EDescr descr) -> Standard_Boolean

        Tells if <me> is for a Described entity of a given EDescr
        (does this EDescr match description name ?). For late-bnd
        (works for <me> + nexts if <me> is a Select)

        :type descr: OCC.wrapper.StepData.Handle_StepData_EDescr
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_PDescr_IsDescr(self, *args)


    def DescrName(self, *args):
        """
        DescrName(Handle_StepData_PDescr self) -> Standard_CString

        Returns the description (type name) to match, for a Described
        (else, empty string)

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_PDescr_DescrName(self, *args)


    def Arity(self, *args):
        """
        Arity(Handle_StepData_PDescr self) -> Standard_Integer

        Returns the arity of <me>

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_PDescr_Arity(self, *args)


    def Simple(self, *args):
        """
        Simple(Handle_StepData_PDescr self) -> Handle_StepData_PDescr

        For a LIST or LIST OF LIST, Returns the PDescr for the simpler
        PDescr. Else, returns <me>
        This allows to have different attributes for Optional for
        instance, on a field, and on the parameter of a LIST :
        [OPTIONAL] LIST OF [OPTIONAL] ...

        :rtype: OCC.wrapper.StepData.Handle_StepData_PDescr

        """
        return _StepData.Handle_StepData_PDescr_Simple(self, *args)


    def IsOptional(self, *args):
        """
        IsOptional(Handle_StepData_PDescr self) -> Standard_Boolean

        Tells if <me> is Optional

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_PDescr_IsOptional(self, *args)


    def IsDerived(self, *args):
        """
        IsDerived(Handle_StepData_PDescr self) -> Standard_Boolean

        Tells if <me> is Derived

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_PDescr_IsDerived(self, *args)


    def IsField(self, *args):
        """
        IsField(Handle_StepData_PDescr self) -> Standard_Boolean

        Tells if <me> is a Field. Else it is a Type

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_PDescr_IsField(self, *args)


    def FieldName(self, *args):
        """
        FieldName(Handle_StepData_PDescr self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_PDescr_FieldName(self, *args)


    def FieldRank(self, *args):
        """
        FieldRank(Handle_StepData_PDescr self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_PDescr_FieldRank(self, *args)


    def Check(self, *args):
        """
        Check(Handle_StepData_PDescr self, StepData_Field afild, Handle_Interface_Check ach)

        Semantic Check of a Field : does it complies with the given
        description ?

        :type afild: OCC.wrapper.StepData.StepData_Field
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _StepData.Handle_StepData_PDescr_Check(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_PDescr self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_PDescr_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_PDescr_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_PDescr_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepData_PDescr self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_PDescr_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_PDescr self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_PDescr self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_PDescr_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_PDescr self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_PDescr self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_PDescr_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_PDescr self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_PDescr_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_PDescr self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_PDescr_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_PDescr self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_PDescr_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_PDescr self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_PDescr_DecrementRefCounter(self, *args)

Handle_StepData_PDescr_swigregister = _StepData.Handle_StepData_PDescr_swigregister
Handle_StepData_PDescr_swigregister(Handle_StepData_PDescr)

def Handle_StepData_PDescr_DownCast(thing):
    return _StepData.Handle_StepData_PDescr_DownCast(thing)
Handle_StepData_PDescr_DownCast = _StepData.Handle_StepData_PDescr_DownCast

class Handle_StepData_HArray1OfField(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_HArray1OfField self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_HArray1OfField_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_HArray1OfField self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_HArray1OfField_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_HArray1OfField self, StepData_HArray1OfField thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_HArray1OfField_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_HArray1OfField self, Handle_StepData_HArray1OfField theHandle) -> Handle_StepData_HArray1OfField
        assign(Handle_StepData_HArray1OfField self, StepData_HArray1OfField thePtr) -> Handle_StepData_HArray1OfField
        assign(Handle_StepData_HArray1OfField self, Handle_StepData_HArray1OfField theHandle) -> Handle_StepData_HArray1OfField

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_HArray1OfField_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_HArray1OfField self) -> StepData_HArray1OfField

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_HArray1OfField_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_HArray1OfField self) -> StepData_HArray1OfField

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_HArray1OfField___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_HArray1OfField self) -> StepData_HArray1OfField

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_HArray1OfField___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_HArray1OfField___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_HArray1OfField___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_HArray1OfField(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_HArray1OfField_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_HArray1OfField

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepData.StepData_Array1OfField

        """
        res = _StepData.Handle_StepData_HArray1OfField_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepData_HArray1OfField self) -> NCollection_Array1_StepData_Field

        :rtype: OCC.wrapper.StepData.StepData_Array1OfField

        """
        return _StepData.Handle_StepData_HArray1OfField_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_HArray1OfField self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_HArray1OfField_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_HArray1OfField_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_HArray1OfField_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepData_HArray1OfField self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_HArray1OfField_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_HArray1OfField self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_HArray1OfField self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_HArray1OfField_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_HArray1OfField self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_HArray1OfField self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_HArray1OfField_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_HArray1OfField self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_HArray1OfField_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_HArray1OfField self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_HArray1OfField_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_HArray1OfField self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_HArray1OfField_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_HArray1OfField self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_HArray1OfField_DecrementRefCounter(self, *args)

Handle_StepData_HArray1OfField_swigregister = _StepData.Handle_StepData_HArray1OfField_swigregister
Handle_StepData_HArray1OfField_swigregister(Handle_StepData_HArray1OfField)

def Handle_StepData_HArray1OfField_DownCast(thing):
    return _StepData.Handle_StepData_HArray1OfField_DownCast(thing)
Handle_StepData_HArray1OfField_DownCast = _StepData.Handle_StepData_HArray1OfField_DownCast

class StepData_StepReaderTool(Interface.Interface_FileReaderTool):
    """
    Specific FileReaderTool for Step; works with FileReaderData
    provides references evaluation, plus access to litteral data
    and specific methods defined by FileReaderTool
    Remarks : works with a ReaderLib to load Entities
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepData_StepReaderTool self, Handle_StepData_StepReaderData reader, Handle_StepData_Protocol protocol) -> StepData_StepReaderTool

        creates StepReaderTool to work with a StepReaderData according
        to a Step Protocol. Defines the ReaderLib at this time

        :type reader: OCC.wrapper.StepData.Handle_StepData_StepReaderData
        :type protocol: OCC.wrapper.StepData.Handle_StepData_Protocol

        """
        this = _StepData.new_StepData_StepReaderTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Prepare(self, *args):
        """
        Prepare(StepData_StepReaderTool self, Standard_Boolean const optimize)
        Prepare(StepData_StepReaderTool self, Handle_StepData_FileRecognizer reco, Standard_Boolean const optimize)

        Bounds empty entities to records, works with a specific
        FileRecognizer, stored and later used in Recognize
        Works only on data entities (skips header)
        <optimize : same as above

        :type reco: OCC.wrapper.StepData.Handle_StepData_FileRecognizer
        :type optimize: bool

        """
        return _StepData.StepData_StepReaderTool_Prepare(self, *args)


    def Recognize(self, *args):
        """
        Recognize(StepData_StepReaderTool self, Standard_Integer const num, Handle_Interface_Check ach, Handle_Standard_Transient ent) -> Standard_Boolean

        recognizes records, by asking either ReaderLib (default) or
        FileRecognizer (if defined) to do so. <ach> is to call
        RecognizeByLib

        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_StepReaderTool_Recognize(self, *args)


    def PrepareHeader(self, *args):
        """
        PrepareHeader(StepData_StepReaderTool self, Handle_StepData_FileRecognizer reco)

        bounds empty entities and sub-lists to header records
        works like Prepare + SetEntityNumbers, but for header
        (N.B.: in Header, no Ident and no reference)
        FileRecognizer is to specify Entities which are allowed to be
        defined in the Header (not every type can be)

        :type reco: OCC.wrapper.StepData.Handle_StepData_FileRecognizer

        """
        return _StepData.StepData_StepReaderTool_PrepareHeader(self, *args)


    def BeginRead(self, *args):
        """
        BeginRead(StepData_StepReaderTool self, Handle_Interface_InterfaceModel amodel)

        fills model's header; that is, gives to it Header entities
        and commands their loading. Also fills StepModel's Global
        Check from StepReaderData's GlobalCheck

        :type amodel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _StepData.StepData_StepReaderTool_BeginRead(self, *args)


    def AnalyseRecord(self, *args):
        """
        AnalyseRecord(StepData_StepReaderTool self, Standard_Integer const num, Handle_Standard_Transient anent, Handle_Interface_Check acheck) -> Standard_Boolean

        fills an entity, given record no; works by using a ReaderLib
        to load each entity, which must be a Transient
        Actually, returned value is True if no fail, False else

        :type num: int
        :type anent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type acheck: OCC.wrapper.Interface.Handle_Interface_Check
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_StepReaderTool_AnalyseRecord(self, *args)


    def EndRead(self, *args):
        """
        EndRead(StepData_StepReaderTool self, Handle_Interface_InterfaceModel amodel)

        Ends file reading after reading all the entities
        Here, it binds in the model, Idents to Entities (for checks)

        :type amodel: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _StepData.StepData_StepReaderTool_EndRead(self, *args)

    __swig_destroy__ = _StepData.delete_StepData_StepReaderTool
StepData_StepReaderTool_swigregister = _StepData.StepData_StepReaderTool_swigregister
StepData_StepReaderTool_swigregister(StepData_StepReaderTool)

class StepData_SelectInt(StepData_SelectMember):
    """
    A SelectInt is a SelectMember specialised for a basic integer
    type in a select which also accepts entities : this one has
    NO NAME.
    For a named select, see SelectNamed
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_SelectInt
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_SelectInt(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepData_SelectInt self) -> StepData_SelectInt

        A SelectInt is a SelectMember specialised for a basic integer
        type in a select which also accepts entities : this one has
        NO NAME.
        For a named select, see SelectNamed
        """
        this = _StepData.new_StepData_SelectInt(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Kind(self, *args):
        """
        Kind(StepData_SelectInt self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_SelectInt_Kind(self, *args)


    def SetKind(self, *args):
        """
        SetKind(StepData_SelectInt self, Standard_Integer const kind)

        :type kind: int

        """
        return _StepData.StepData_SelectInt_SetKind(self, *args)


    def Int(self, *args):
        """
        Int(StepData_SelectInt self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_SelectInt_Int(self, *args)


    def SetInt(self, *args):
        """
        SetInt(StepData_SelectInt self, Standard_Integer const val)

        :type val: int

        """
        return _StepData.StepData_SelectInt_SetInt(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_SelectInt_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_SelectInt_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_SelectInt_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_SelectInt
StepData_SelectInt_swigregister = _StepData.StepData_SelectInt_swigregister
StepData_SelectInt_swigregister(StepData_SelectInt)

def StepData_SelectInt_get_type_name(*args):
    """
    StepData_SelectInt_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_SelectInt_get_type_name(*args)

def StepData_SelectInt_get_type_descriptor(*args):
    """
    StepData_SelectInt_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_SelectInt_get_type_descriptor(*args)

class Handle_StepData_Protocol(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_Protocol self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_Protocol_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_Protocol self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_Protocol_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_Protocol self, StepData_Protocol thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_Protocol_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_Protocol self, Handle_StepData_Protocol theHandle) -> Handle_StepData_Protocol
        assign(Handle_StepData_Protocol self, StepData_Protocol thePtr) -> Handle_StepData_Protocol
        assign(Handle_StepData_Protocol self, Handle_StepData_Protocol theHandle) -> Handle_StepData_Protocol

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_Protocol_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_Protocol self) -> StepData_Protocol

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_Protocol_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_Protocol self) -> StepData_Protocol

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_Protocol___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_Protocol self) -> StepData_Protocol

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_Protocol___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_Protocol___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_Protocol___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_Protocol(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_Protocol_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_Protocol

    def NbResources(self, *args):
        """
        NbResources(Handle_StepData_Protocol self) -> Standard_Integer

        Gives the count of Protocols used as Resource (can be zero)
        Here, No resource

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_Protocol_NbResources(self, *args)


    def Resource(self, *args):
        """
        Resource(Handle_StepData_Protocol self, Standard_Integer const num) -> Handle_Interface_Protocol

        Returns a Resource, given a rank. Here, none

        :type num: int
        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _StepData.Handle_StepData_Protocol_Resource(self, *args)


    def CaseNumber(self, *args):
        """
        CaseNumber(Handle_StepData_Protocol self, Handle_Standard_Transient obj) -> Standard_Integer

        Returns a unique positive number for any recognized entity
        Redefined to work by calling both TypeNumber and, for a
        Described Entity (late binding) DescrNumber

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_Protocol_CaseNumber(self, *args)


    def TypeNumber(self, *args):
        """
        TypeNumber(Handle_StepData_Protocol self, Handle_Standard_Type atype) -> Standard_Integer

        Returns a Case Number, specific of each recognized Type
        Here, only Unknown Entity is recognized

        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_Protocol_TypeNumber(self, *args)


    def SchemaName(self, *args):
        """
        SchemaName(Handle_StepData_Protocol self) -> Standard_CString

        Returns the Schema Name attached to each class of Protocol
        To be redefined by each sub-class
        Here, SchemaName returns "(DEFAULT)"
        was C++ : return const

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_Protocol_SchemaName(self, *args)


    def NewModel(self, *args):
        """
        NewModel(Handle_StepData_Protocol self) -> Handle_Interface_InterfaceModel

        Creates an empty Model for Step Norm

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _StepData.Handle_StepData_Protocol_NewModel(self, *args)


    def IsSuitableModel(self, *args):
        """
        IsSuitableModel(Handle_StepData_Protocol self, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns True if <model> is a Model of Step Norm

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_Protocol_IsSuitableModel(self, *args)


    def UnknownEntity(self, *args):
        """
        UnknownEntity(Handle_StepData_Protocol self) -> Handle_Standard_Transient

        Creates a new Unknown Entity for Step (UndefinedEntity)

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.Handle_StepData_Protocol_UnknownEntity(self, *args)


    def IsUnknownEntity(self, *args):
        """
        IsUnknownEntity(Handle_StepData_Protocol self, Handle_Standard_Transient ent) -> Standard_Boolean

        Returns True if <ent> is an Unknown Entity for the Norm, i.e.
        Type UndefinedEntity, status Unknown

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_Protocol_IsUnknownEntity(self, *args)


    def DescrNumber(self, *args):
        """
        DescrNumber(Handle_StepData_Protocol self, Handle_StepData_EDescr adescr) -> Standard_Integer

        Returns a unique positive CaseNumber for types described by
        an EDescr (late binding)
        Warning : TypeNumber and DescrNumber must give together a unique
        positive case number for each distinct case, type or descr

        :type adescr: OCC.wrapper.StepData.Handle_StepData_EDescr
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_Protocol_DescrNumber(self, *args)


    def AddDescr(self, *args):
        """
        AddDescr(Handle_StepData_Protocol self, Handle_StepData_EDescr adescr, Standard_Integer const CN)

        Records an EDescr with its case number
        Also records its name for an ESDescr (simple type): an ESDescr
        is then used, for case number, or for type name

        :type adescr: OCC.wrapper.StepData.Handle_StepData_EDescr
        :type CN: int

        """
        return _StepData.Handle_StepData_Protocol_AddDescr(self, *args)


    def HasDescr(self, *args):
        """
        HasDescr(Handle_StepData_Protocol self) -> Standard_Boolean

        Tells if a Protocol brings at least one ESDescr, i.e. if it
        defines at least one entity description by ESDescr mechanism

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_Protocol_HasDescr(self, *args)


    def Descr(self, *args):
        """
        Descr(Handle_StepData_Protocol self, Standard_Integer const num) -> Handle_StepData_EDescr
        Descr(Handle_StepData_Protocol self, Standard_CString const name, Standard_Boolean const anylevel) -> Handle_StepData_EDescr

        Returns a description according to its name
        <anylevel> True (D) : for <me> and its resources
        <anylevel> False : for <me> only

        :type name: OCC.wrapper.Standard.Standard_CString
        :type anylevel: bool
        :rtype: OCC.wrapper.StepData.Handle_StepData_EDescr

        """
        return _StepData.Handle_StepData_Protocol_Descr(self, *args)


    def ESDescr(self, *args):
        """
        ESDescr(Handle_StepData_Protocol self, Standard_CString const name, Standard_Boolean const anylevel) -> Handle_StepData_ESDescr

        Idem as Descr but cast to simple description

        :type name: OCC.wrapper.Standard.Standard_CString
        :type anylevel: bool
        :rtype: OCC.wrapper.StepData.Handle_StepData_ESDescr

        """
        return _StepData.Handle_StepData_Protocol_ESDescr(self, *args)


    def ECDescr(self, *args):
        """
        ECDescr(Handle_StepData_Protocol self, NCollection_Sequence_TCollection_AsciiString names, Standard_Boolean const anylevel) -> Handle_StepData_ECDescr

        Returns a complex description according to list of names
        <anylevel> True (D) : for <me> and its resources
        <anylevel> False : for <me> only

        :type names: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString
        :type anylevel: bool
        :rtype: OCC.wrapper.StepData.Handle_StepData_ECDescr

        """
        return _StepData.Handle_StepData_Protocol_ECDescr(self, *args)


    def AddPDescr(self, *args):
        """
        AddPDescr(Handle_StepData_Protocol self, Handle_StepData_PDescr pdescr)

        Records an PDescr

        :type pdescr: OCC.wrapper.StepData.Handle_StepData_PDescr

        """
        return _StepData.Handle_StepData_Protocol_AddPDescr(self, *args)


    def PDescr(self, *args):
        """
        PDescr(Handle_StepData_Protocol self, Standard_CString const name, Standard_Boolean const anylevel) -> Handle_StepData_PDescr

        Returns a parameter description according to its name
        <anylevel> True (D) : for <me> and its resources
        <anylevel> False : for <me> only

        :type name: OCC.wrapper.Standard.Standard_CString
        :type anylevel: bool
        :rtype: OCC.wrapper.StepData.Handle_StepData_PDescr

        """
        return _StepData.Handle_StepData_Protocol_PDescr(self, *args)


    def AddBasicDescr(self, *args):
        """
        AddBasicDescr(Handle_StepData_Protocol self, Handle_StepData_ESDescr esdescr)

        Records an ESDescr, intended to build complex descriptions

        :type esdescr: OCC.wrapper.StepData.Handle_StepData_ESDescr

        """
        return _StepData.Handle_StepData_Protocol_AddBasicDescr(self, *args)


    def BasicDescr(self, *args):
        """
        BasicDescr(Handle_StepData_Protocol self, Standard_CString const name, Standard_Boolean const anylevel) -> Handle_StepData_EDescr

        Returns a basic description according to its name
        <anylevel> True (D) : for <me> and its resources
        <anylevel> False : for <me> only

        :type name: OCC.wrapper.Standard.Standard_CString
        :type anylevel: bool
        :rtype: OCC.wrapper.StepData.Handle_StepData_EDescr

        """
        return _StepData.Handle_StepData_Protocol_BasicDescr(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_Protocol self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_Protocol_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_Protocol_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_Protocol_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Active(self, *args):
        """
        Active(Handle_StepData_Protocol self) -> Handle_Interface_Protocol

        Returns the Active Protocol, if defined (else, returns a
        Null Handle, which means "no defined active protocol")

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _StepData.Handle_StepData_Protocol_Active(self, *args)


    def SetActive(self, *args):
        """
        SetActive(Handle_StepData_Protocol self, Handle_Interface_Protocol aprotocol)

        Sets a given Protocol to be the Active one (for the users of
        Active, see just above). Applies to every sub-type of Protocol

        :type aprotocol: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _StepData.Handle_StepData_Protocol_SetActive(self, *args)


    def ClearActive(self, *args):
        """
        ClearActive(Handle_StepData_Protocol self)

        Erases the Active Protocol (hence it becomes undefined)


        """
        return _StepData.Handle_StepData_Protocol_ClearActive(self, *args)


    def IsDynamicType(self, *args):
        """
        IsDynamicType(Handle_StepData_Protocol self, Handle_Standard_Transient obj) -> Standard_Boolean

        Returns True if type of <obj> is that defined from CDL
        This is the default but it may change according implementation

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_Protocol_IsDynamicType(self, *args)


    def NbTypes(self, *args):
        """
        NbTypes(Handle_StepData_Protocol self, Handle_Standard_Transient obj) -> Standard_Integer

        Returns the count of DISTINCT types under which an entity may
        be processed. Each one is candidate to be recognized by
        TypeNumber, <obj> is then processed according it
        By default, returns 1 (the DynamicType)

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_Protocol_NbTypes(self, *args)


    def Type(self, *args):
        """
        Type(Handle_StepData_Protocol self, Handle_Standard_Transient obj, Standard_Integer const nt=1) -> Handle_Standard_Type

        Returns a type under which <obj> can be recognized and
        processed, according its rank in its definition list (see
        NbTypes).
        By default, returns DynamicType

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :type nt: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.Handle_StepData_Protocol_Type(self, *args)


    def GlobalCheck(self, *args):
        """
        GlobalCheck(Handle_StepData_Protocol self, Interface_Graph G, Handle_Interface_Check ach) -> Standard_Boolean

        Evaluates a Global Check for a model (with its Graph)
        Returns True when done, False if data in model do not apply

        Very specific of each norm, i.e. of each protocol : the
        uppest level Protocol assumes it, it can call GlobalCheck of
        its ressources only if it is necessary

        Default does nothing, can be redefined

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_Protocol_GlobalCheck(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepData_Protocol self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_Protocol_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_Protocol self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_Protocol self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_Protocol_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_Protocol self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_Protocol self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_Protocol_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_Protocol self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_Protocol_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_Protocol self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_Protocol_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_Protocol self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_Protocol_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_Protocol self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_Protocol_DecrementRefCounter(self, *args)

Handle_StepData_Protocol_swigregister = _StepData.Handle_StepData_Protocol_swigregister
Handle_StepData_Protocol_swigregister(Handle_StepData_Protocol)

def Handle_StepData_Protocol_DownCast(thing):
    return _StepData.Handle_StepData_Protocol_DownCast(thing)
Handle_StepData_Protocol_DownCast = _StepData.Handle_StepData_Protocol_DownCast

class Handle_StepData_FileRecognizer(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_FileRecognizer self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_FileRecognizer_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_FileRecognizer self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_FileRecognizer_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_FileRecognizer self, StepData_FileRecognizer thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_FileRecognizer_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_FileRecognizer self, Handle_StepData_FileRecognizer theHandle) -> Handle_StepData_FileRecognizer
        assign(Handle_StepData_FileRecognizer self, StepData_FileRecognizer thePtr) -> Handle_StepData_FileRecognizer
        assign(Handle_StepData_FileRecognizer self, Handle_StepData_FileRecognizer theHandle) -> Handle_StepData_FileRecognizer

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_FileRecognizer_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_FileRecognizer self) -> StepData_FileRecognizer

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_FileRecognizer_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_FileRecognizer self) -> StepData_FileRecognizer

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_FileRecognizer___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_FileRecognizer self) -> StepData_FileRecognizer

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_FileRecognizer___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_FileRecognizer___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_FileRecognizer___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_FileRecognizer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_FileRecognizer_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_FileRecognizer

    def Evaluate(self, *args):
        """
        Evaluate(Handle_StepData_FileRecognizer self, TCollection_AsciiString akey, Handle_Standard_Transient res) -> Standard_Boolean

        Evaluates if recognition has a result, returns it if yes
        In case of success, Returns True and puts result in "res"
        In case of Failure, simply Returns False
        Works by calling deferred method Eval, and in case of failure,
        looks for Added Recognizers to work

        :type akey: OCC.wrapper.TCollection.TCollection_AsciiString
        :type res: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_FileRecognizer_Evaluate(self, *args)


    def Result(self, *args):
        """
        Result(Handle_StepData_FileRecognizer self) -> Handle_Standard_Transient

        Returns result of last recognition (call of Evaluate)

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.Handle_StepData_FileRecognizer_Result(self, *args)


    def Add(self, *args):
        """
        Add(Handle_StepData_FileRecognizer self, Handle_StepData_FileRecognizer reco)

        Adds a new Recognizer to the Compound, at the end
        Several calls to Add work by adding in the order of calls :
        Hence, when Eval has failed to recognize, Evaluate will call
        Evaluate from the first added Recognizer if there is one,
        and to the second if there is still no result, and so on

        :type reco: OCC.wrapper.StepData.Handle_StepData_FileRecognizer

        """
        return _StepData.Handle_StepData_FileRecognizer_Add(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_FileRecognizer self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_FileRecognizer_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_FileRecognizer_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_FileRecognizer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepData_FileRecognizer self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_FileRecognizer_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_FileRecognizer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_FileRecognizer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_FileRecognizer_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_FileRecognizer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_FileRecognizer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_FileRecognizer_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_FileRecognizer self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_FileRecognizer_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_FileRecognizer self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_FileRecognizer_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_FileRecognizer self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_FileRecognizer_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_FileRecognizer self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_FileRecognizer_DecrementRefCounter(self, *args)

Handle_StepData_FileRecognizer_swigregister = _StepData.Handle_StepData_FileRecognizer_swigregister
Handle_StepData_FileRecognizer_swigregister(Handle_StepData_FileRecognizer)

def Handle_StepData_FileRecognizer_DownCast(thing):
    return _StepData.Handle_StepData_FileRecognizer_DownCast(thing)
Handle_StepData_FileRecognizer_DownCast = _StepData.Handle_StepData_FileRecognizer_DownCast

class StepData_UndefinedEntity(Standard.Standard_Transient):
    """
    Undefined entity specific to Step Interface, in which StepType
    is defined at each instance, or is a SubList of another one
    Uses an UndefinedContent, that from Interface is suitable.
    Also an Entity defined by STEP can be "Complex Type" (see
    ANDOR clause in Express).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_UndefinedEntity
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_UndefinedEntity(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepData_UndefinedEntity self) -> StepData_UndefinedEntity
        __init__(StepData_UndefinedEntity self, Standard_Boolean const issub) -> StepData_UndefinedEntity

        Creates a SubList of an Unknown entity : it is an Unknown
        Entity with no Type, but flagged as "SUB" if issub is True

        :type issub: bool

        """
        this = _StepData.new_StepData_UndefinedEntity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def UndefinedContent(self, *args):
        """
        UndefinedContent(StepData_UndefinedEntity self) -> Handle_Interface_UndefinedContent

        Returns the UndefinedContent which brings the Parameters

        :rtype: OCC.wrapper.Interface.Handle_Interface_UndefinedContent

        """
        return _StepData.StepData_UndefinedEntity_UndefinedContent(self, *args)


    def IsSub(self, *args):
        """
        IsSub(StepData_UndefinedEntity self) -> Standard_Boolean

        Returns True if an Unndefined Entity is SubPart of another one

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_UndefinedEntity_IsSub(self, *args)


    def IsComplex(self, *args):
        """
        IsComplex(StepData_UndefinedEntity self) -> Standard_Boolean

        Returns True if <me> defines a Multiple Type Entity (see ANDOR)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_UndefinedEntity_IsComplex(self, *args)


    def Next(self, *args):
        """
        Next(StepData_UndefinedEntity self) -> Handle_StepData_UndefinedEntity

        For a Multiple Type Entity, returns the Next "Componant"
        For more than two Types, iterative definition (Next->Next...)
        Returns a Null Handle for the end of the List

        :rtype: OCC.wrapper.StepData.Handle_StepData_UndefinedEntity

        """
        return _StepData.StepData_UndefinedEntity_Next(self, *args)


    def StepType(self, *args):
        """
        StepType(StepData_UndefinedEntity self) -> Standard_CString

        gives entity type, read from file
        For a Complex Type Entity, gives the first Type read, each
        "Next" gives its "partial" type
        was C++ : return const

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_UndefinedEntity_StepType(self, *args)


    def ReadRecord(self, *args):
        """
        ReadRecord(StepData_UndefinedEntity self, Handle_StepData_StepReaderData SR, Standard_Integer const num, Handle_Interface_Check ach)

        reads data from StepReaderData (i.e. from file), by filling
        StepType and parameters stored in the UndefinedContent

        :type SR: OCC.wrapper.StepData.Handle_StepData_StepReaderData
        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _StepData.StepData_UndefinedEntity_ReadRecord(self, *args)


    def WriteParams(self, *args):
        """
        WriteParams(StepData_UndefinedEntity self, StepData_StepWriter SW)

        write data to StepWriter, taken from UndefinedContent

        :type SW: OCC.wrapper.StepData.StepData_StepWriter

        """
        return _StepData.StepData_UndefinedEntity_WriteParams(self, *args)


    def GetFromAnother(self, *args):
        """
        GetFromAnother(StepData_UndefinedEntity self, Handle_StepData_UndefinedEntity other, Interface_CopyTool TC)

        reads another UndefinedEntity from StepData

        :type other: OCC.wrapper.StepData.Handle_StepData_UndefinedEntity
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _StepData.StepData_UndefinedEntity_GetFromAnother(self, *args)


    def FillShared(self, *args):
        """
        FillShared(StepData_UndefinedEntity self, Interface_EntityIterator list)

        Fills the list of shared entities

        :type list: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.StepData_UndefinedEntity_FillShared(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_UndefinedEntity_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_UndefinedEntity_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_UndefinedEntity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_UndefinedEntity
StepData_UndefinedEntity_swigregister = _StepData.StepData_UndefinedEntity_swigregister
StepData_UndefinedEntity_swigregister(StepData_UndefinedEntity)

def StepData_UndefinedEntity_get_type_name(*args):
    """
    StepData_UndefinedEntity_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_UndefinedEntity_get_type_name(*args)

def StepData_UndefinedEntity_get_type_descriptor(*args):
    """
    StepData_UndefinedEntity_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_UndefinedEntity_get_type_descriptor(*args)

class StepData_FieldList1(StepData_FieldList):
    """Describes a list of ONE field"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepData_FieldList1 self) -> StepData_FieldList1

        Creates a FieldList of 1 Field


        """
        this = _StepData.new_StepData_FieldList1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbFields(self, *args):
        """
        NbFields(StepData_FieldList1 self) -> Standard_Integer

        Returns the count of fields. Here, returns 1

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_FieldList1_NbFields(self, *args)


    def Field(self, *args):
        """
        Returns the field n0 <num> between 1 and NbFields (read only)

        :type num: int
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        res = _StepData.StepData_FieldList1_Field(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CField(self, *args):
        """
        CField(StepData_FieldList1 self, Standard_Integer const num) -> StepData_Field

        Returns the field n0 <num> between 1 and NbFields, in order to
        modify its content

        :type num: int
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        return _StepData.StepData_FieldList1_CField(self, *args)

    __swig_destroy__ = _StepData.delete_StepData_FieldList1
StepData_FieldList1_swigregister = _StepData.StepData_FieldList1_swigregister
StepData_FieldList1_swigregister(StepData_FieldList1)

class StepData_FieldListD(StepData_FieldList):
    """
    Describes a list of fields, in a general way
    This basic class is for a null size list
    Subclasses are for 1, N (fixed) or Dynamic sizes
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepData_FieldListD self, Standard_Integer const nb) -> StepData_FieldListD

        Creates a FieldListD of <nb> Fields

        :type nb: int

        """
        this = _StepData.new_StepData_FieldListD(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetNb(self, *args):
        """
        SetNb(StepData_FieldListD self, Standard_Integer const nb)

        Sets a new count of Fields. Former contents are lost

        :type nb: int

        """
        return _StepData.StepData_FieldListD_SetNb(self, *args)


    def NbFields(self, *args):
        """
        NbFields(StepData_FieldListD self) -> Standard_Integer

        Returns the count of fields. Here, returns starting <nb>

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_FieldListD_NbFields(self, *args)


    def Field(self, *args):
        """
        Returns the field n0 <num> between 1 and NbFields (read only)

        :type num: int
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        res = _StepData.StepData_FieldListD_Field(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CField(self, *args):
        """
        CField(StepData_FieldListD self, Standard_Integer const num) -> StepData_Field

        Returns the field n0 <num> between 1 and NbFields, in order to
        modify its content

        :type num: int
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        return _StepData.StepData_FieldListD_CField(self, *args)

    __swig_destroy__ = _StepData.delete_StepData_FieldListD
StepData_FieldListD_swigregister = _StepData.StepData_FieldListD_swigregister
StepData_FieldListD_swigregister(StepData_FieldListD)

class Handle_StepData_SelectArrReal(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_SelectArrReal self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_SelectArrReal_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_SelectArrReal self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_SelectArrReal_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_SelectArrReal self, StepData_SelectArrReal thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_SelectArrReal_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_SelectArrReal self, Handle_StepData_SelectArrReal theHandle) -> Handle_StepData_SelectArrReal
        assign(Handle_StepData_SelectArrReal self, StepData_SelectArrReal thePtr) -> Handle_StepData_SelectArrReal
        assign(Handle_StepData_SelectArrReal self, Handle_StepData_SelectArrReal theHandle) -> Handle_StepData_SelectArrReal

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_SelectArrReal_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_SelectArrReal self) -> StepData_SelectArrReal

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_SelectArrReal_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_SelectArrReal self) -> StepData_SelectArrReal

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_SelectArrReal___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_SelectArrReal self) -> StepData_SelectArrReal

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_SelectArrReal___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_SelectArrReal___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_SelectArrReal___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_SelectArrReal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_SelectArrReal_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_SelectArrReal

    def Kind(self, *args):
        """
        Kind(Handle_StepData_SelectArrReal self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectArrReal_Kind(self, *args)


    def ArrReal(self, *args):
        """
        ArrReal(Handle_StepData_SelectArrReal self) -> Handle_TColStd_HArray1OfReal

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepData.Handle_StepData_SelectArrReal_ArrReal(self, *args)


    def SetArrReal(self, *args):
        """
        SetArrReal(Handle_StepData_SelectArrReal self, Handle_TColStd_HArray1OfReal arr)

        :type arr: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepData.Handle_StepData_SelectArrReal_SetArrReal(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_SelectArrReal self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_SelectArrReal_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_SelectArrReal_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_SelectArrReal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasName(self, *args):
        """
        HasName(Handle_StepData_SelectArrReal self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectArrReal_HasName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepData_SelectArrReal self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectArrReal_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepData_SelectArrReal self, Standard_CString const name) -> Standard_Boolean

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectArrReal_SetName(self, *args)


    def Field(self, *args):
        """
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        res = _StepData.Handle_StepData_SelectArrReal_Field(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CField(self, *args):
        """
        CField(Handle_StepData_SelectArrReal self) -> StepData_Field

        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        return _StepData.Handle_StepData_SelectArrReal_CField(self, *args)


    def SetKind(self, *args):
        """
        SetKind(Handle_StepData_SelectArrReal self, Standard_Integer const kind)

        :type kind: int

        """
        return _StepData.Handle_StepData_SelectArrReal_SetKind(self, *args)


    def Int(self, *args):
        """
        Int(Handle_StepData_SelectArrReal self) -> Standard_Integer

        This internal method gives access to a value implemented by an
        Integer (to read it)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectArrReal_Int(self, *args)


    def SetInt(self, *args):
        """
        SetInt(Handle_StepData_SelectArrReal self, Standard_Integer const val)

        This internal method gives access to a value implemented by an
        Integer (to set it)

        :type val: int

        """
        return _StepData.Handle_StepData_SelectArrReal_SetInt(self, *args)


    def Real(self, *args):
        """
        Real(Handle_StepData_SelectArrReal self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepData.Handle_StepData_SelectArrReal_Real(self, *args)


    def SetReal(self, *args):
        """
        SetReal(Handle_StepData_SelectArrReal self, Standard_Real const val)

        :type val: float

        """
        return _StepData.Handle_StepData_SelectArrReal_SetReal(self, *args)


    def String(self, *args):
        """
        String(Handle_StepData_SelectArrReal self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectArrReal_String(self, *args)


    def SetString(self, *args):
        """
        SetString(Handle_StepData_SelectArrReal self, Standard_CString const val)

        :type val: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectArrReal_SetString(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_StepData_SelectArrReal self, Standard_CString const name) -> Standard_Boolean

        Tells if the name of a SelectMember matches a given one
        By default, compares the strings, can be redefined (optimised)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectArrReal_Matches(self, *args)


    def ParamType(self, *args):
        """
        ParamType(Handle_StepData_SelectArrReal self) -> Interface_ParamType

        Returns the Kind of the SelectMember, under the form of an
        enum ParamType

        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _StepData.Handle_StepData_SelectArrReal_ParamType(self, *args)


    def Integer(self, *args):
        """
        Integer(Handle_StepData_SelectArrReal self) -> Standard_Integer

        Gets the value as an Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectArrReal_Integer(self, *args)


    def SetInteger(self, *args):
        """
        SetInteger(Handle_StepData_SelectArrReal self, Standard_Integer const val)

        :type val: int

        """
        return _StepData.Handle_StepData_SelectArrReal_SetInteger(self, *args)


    def Boolean(self, *args):
        """
        Boolean(Handle_StepData_SelectArrReal self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectArrReal_Boolean(self, *args)


    def SetBoolean(self, *args):
        """
        SetBoolean(Handle_StepData_SelectArrReal self, Standard_Boolean const val)

        :type val: bool

        """
        return _StepData.Handle_StepData_SelectArrReal_SetBoolean(self, *args)


    def Logical(self, *args):
        """
        Logical(Handle_StepData_SelectArrReal self) -> StepData_Logical

        :rtype: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepData.Handle_StepData_SelectArrReal_Logical(self, *args)


    def SetLogical(self, *args):
        """
        SetLogical(Handle_StepData_SelectArrReal self, StepData_Logical const val)

        :type val: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepData.Handle_StepData_SelectArrReal_SetLogical(self, *args)


    def Enum(self, *args):
        """
        Enum(Handle_StepData_SelectArrReal self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectArrReal_Enum(self, *args)


    def EnumText(self, *args):
        """
        EnumText(Handle_StepData_SelectArrReal self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectArrReal_EnumText(self, *args)


    def SetEnum(self, *args):
        """
        SetEnum(Handle_StepData_SelectArrReal self, Standard_Integer const val, Standard_CString const text)

        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectArrReal_SetEnum(self, *args)


    def SetEnumText(self, *args):
        """
        SetEnumText(Handle_StepData_SelectArrReal self, Standard_Integer const val, Standard_CString const text)

        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectArrReal_SetEnumText(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepData_SelectArrReal self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_SelectArrReal_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_SelectArrReal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_SelectArrReal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectArrReal_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_SelectArrReal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_SelectArrReal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectArrReal_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_SelectArrReal self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_SelectArrReal_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_SelectArrReal self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectArrReal_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_SelectArrReal self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_SelectArrReal_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_SelectArrReal self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectArrReal_DecrementRefCounter(self, *args)

Handle_StepData_SelectArrReal_swigregister = _StepData.Handle_StepData_SelectArrReal_swigregister
Handle_StepData_SelectArrReal_swigregister(Handle_StepData_SelectArrReal)

def Handle_StepData_SelectArrReal_DownCast(thing):
    return _StepData.Handle_StepData_SelectArrReal_DownCast(thing)
Handle_StepData_SelectArrReal_DownCast = _StepData.Handle_StepData_SelectArrReal_DownCast

class Handle_StepData_SelectReal(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_SelectReal self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_SelectReal_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_SelectReal self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_SelectReal_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_SelectReal self, StepData_SelectReal thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_SelectReal_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_SelectReal self, Handle_StepData_SelectReal theHandle) -> Handle_StepData_SelectReal
        assign(Handle_StepData_SelectReal self, StepData_SelectReal thePtr) -> Handle_StepData_SelectReal
        assign(Handle_StepData_SelectReal self, Handle_StepData_SelectReal theHandle) -> Handle_StepData_SelectReal

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_SelectReal_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_SelectReal self) -> StepData_SelectReal

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_SelectReal_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_SelectReal self) -> StepData_SelectReal

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_SelectReal___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_SelectReal self) -> StepData_SelectReal

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_SelectReal___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_SelectReal___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_SelectReal___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_SelectReal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_SelectReal_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_SelectReal

    def Kind(self, *args):
        """
        Kind(Handle_StepData_SelectReal self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectReal_Kind(self, *args)


    def Real(self, *args):
        """
        Real(Handle_StepData_SelectReal self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepData.Handle_StepData_SelectReal_Real(self, *args)


    def SetReal(self, *args):
        """
        SetReal(Handle_StepData_SelectReal self, Standard_Real const val)

        :type val: float

        """
        return _StepData.Handle_StepData_SelectReal_SetReal(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_SelectReal self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_SelectReal_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_SelectReal_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_SelectReal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasName(self, *args):
        """
        HasName(Handle_StepData_SelectReal self) -> Standard_Boolean

        Tells if a SelectMember has a name. Default is False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectReal_HasName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepData_SelectReal self) -> Standard_CString

        Returns the name of a SelectMember. Default is empty

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectReal_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepData_SelectReal self, Standard_CString const name) -> Standard_Boolean

        Sets the name of a SelectMember, returns True if done, False
        if no name is allowed
        Default does nothing and returns False

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectReal_SetName(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_StepData_SelectReal self, Standard_CString const name) -> Standard_Boolean

        Tells if the name of a SelectMember matches a given one
        By default, compares the strings, can be redefined (optimised)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectReal_Matches(self, *args)


    def SetKind(self, *args):
        """
        SetKind(Handle_StepData_SelectReal self, Standard_Integer const kind)

        :type kind: int

        """
        return _StepData.Handle_StepData_SelectReal_SetKind(self, *args)


    def ParamType(self, *args):
        """
        ParamType(Handle_StepData_SelectReal self) -> Interface_ParamType

        Returns the Kind of the SelectMember, under the form of an
        enum ParamType

        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _StepData.Handle_StepData_SelectReal_ParamType(self, *args)


    def Int(self, *args):
        """
        Int(Handle_StepData_SelectReal self) -> Standard_Integer

        This internal method gives access to a value implemented by an
        Integer (to read it)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectReal_Int(self, *args)


    def SetInt(self, *args):
        """
        SetInt(Handle_StepData_SelectReal self, Standard_Integer const val)

        This internal method gives access to a value implemented by an
        Integer (to set it)

        :type val: int

        """
        return _StepData.Handle_StepData_SelectReal_SetInt(self, *args)


    def Integer(self, *args):
        """
        Integer(Handle_StepData_SelectReal self) -> Standard_Integer

        Gets the value as an Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectReal_Integer(self, *args)


    def SetInteger(self, *args):
        """
        SetInteger(Handle_StepData_SelectReal self, Standard_Integer const val)

        :type val: int

        """
        return _StepData.Handle_StepData_SelectReal_SetInteger(self, *args)


    def Boolean(self, *args):
        """
        Boolean(Handle_StepData_SelectReal self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectReal_Boolean(self, *args)


    def SetBoolean(self, *args):
        """
        SetBoolean(Handle_StepData_SelectReal self, Standard_Boolean const val)

        :type val: bool

        """
        return _StepData.Handle_StepData_SelectReal_SetBoolean(self, *args)


    def Logical(self, *args):
        """
        Logical(Handle_StepData_SelectReal self) -> StepData_Logical

        :rtype: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepData.Handle_StepData_SelectReal_Logical(self, *args)


    def SetLogical(self, *args):
        """
        SetLogical(Handle_StepData_SelectReal self, StepData_Logical const val)

        :type val: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepData.Handle_StepData_SelectReal_SetLogical(self, *args)


    def String(self, *args):
        """
        String(Handle_StepData_SelectReal self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectReal_String(self, *args)


    def SetString(self, *args):
        """
        SetString(Handle_StepData_SelectReal self, Standard_CString const val)

        :type val: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectReal_SetString(self, *args)


    def Enum(self, *args):
        """
        Enum(Handle_StepData_SelectReal self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectReal_Enum(self, *args)


    def EnumText(self, *args):
        """
        EnumText(Handle_StepData_SelectReal self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectReal_EnumText(self, *args)


    def SetEnum(self, *args):
        """
        SetEnum(Handle_StepData_SelectReal self, Standard_Integer const val, Standard_CString const text)

        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectReal_SetEnum(self, *args)


    def SetEnumText(self, *args):
        """
        SetEnumText(Handle_StepData_SelectReal self, Standard_Integer const val, Standard_CString const text)

        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectReal_SetEnumText(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepData_SelectReal self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_SelectReal_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_SelectReal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_SelectReal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectReal_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_SelectReal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_SelectReal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectReal_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_SelectReal self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_SelectReal_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_SelectReal self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectReal_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_SelectReal self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_SelectReal_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_SelectReal self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectReal_DecrementRefCounter(self, *args)

Handle_StepData_SelectReal_swigregister = _StepData.Handle_StepData_SelectReal_swigregister
Handle_StepData_SelectReal_swigregister(Handle_StepData_SelectReal)

def Handle_StepData_SelectReal_DownCast(thing):
    return _StepData.Handle_StepData_SelectReal_DownCast(thing)
Handle_StepData_SelectReal_DownCast = _StepData.Handle_StepData_SelectReal_DownCast

class StepData_DefaultGeneral(StepData_GeneralModule):
    """
    DefaultGeneral defines a GeneralModule which processes
    Unknown Entity from StepData  only
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepData_DefaultGeneral
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepData_DefaultGeneral(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepData_DefaultGeneral self) -> StepData_DefaultGeneral

        Creates a Default General Module


        """
        this = _StepData.new_StepData_DefaultGeneral(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def FillSharedCase(self, *args):
        """
        FillSharedCase(StepData_DefaultGeneral self, Standard_Integer const casenum, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        Specific filling of the list of Entities shared by an Entity
        <ent>, which is an UnknownEntity from StepData.

        :type casenum: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.StepData_DefaultGeneral_FillSharedCase(self, *args)


    def CheckCase(self, *args):
        """
        CheckCase(StepData_DefaultGeneral self, Standard_Integer const casenum, Handle_Standard_Transient ent, Interface_ShareTool shares, Handle_Interface_Check ach)

        Specific Checking of an Entity <ent>

        :type casenum: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type shares: OCC.wrapper.Interface.Interface_ShareTool
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _StepData.StepData_DefaultGeneral_CheckCase(self, *args)


    def NewVoid(self, *args):
        """
        NewVoid(StepData_DefaultGeneral self, Standard_Integer const CN, Handle_Standard_Transient entto) -> Standard_Boolean

        Specific creation of a new void entity

        :type CN: int
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_DefaultGeneral_NewVoid(self, *args)


    def CopyCase(self, *args):
        """
        CopyCase(StepData_DefaultGeneral self, Standard_Integer const casenum, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC)

        Specific Copy ("Deep") from <entfrom> to <entto> (same type)
        by using a CopyTool which provides its working Map.
        Use method Transferred from TransferControl to work

        :type casenum: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _StepData.StepData_DefaultGeneral_CopyCase(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepData.StepData_DefaultGeneral_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_DefaultGeneral_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.StepData_DefaultGeneral_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_DefaultGeneral
StepData_DefaultGeneral_swigregister = _StepData.StepData_DefaultGeneral_swigregister
StepData_DefaultGeneral_swigregister(StepData_DefaultGeneral)

def StepData_DefaultGeneral_get_type_name(*args):
    """
    StepData_DefaultGeneral_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepData.StepData_DefaultGeneral_get_type_name(*args)

def StepData_DefaultGeneral_get_type_descriptor(*args):
    """
    StepData_DefaultGeneral_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepData.StepData_DefaultGeneral_get_type_descriptor(*args)

class StepData_(object):
    """
    Gives basic data definition for Step Interface.
    Any class of a data model described in EXPRESS Language
    is candidate to be managed by a Step Interface
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HeaderProtocol(*args):
        """
        HeaderProtocol() -> Handle_StepData_Protocol

        Returns the recorded HeaderProtocol, which can be :
        - a Null Handle if no Header Protocol was yet defined
        - a simple Protocol if only one was defined
        - a FileProtocol if more than one Protocol was yet defined

        :rtype: OCC.wrapper.StepData.Handle_StepData_Protocol

        """
        return _StepData.StepData__HeaderProtocol(*args)

    HeaderProtocol = staticmethod(HeaderProtocol)

    def AddHeaderProtocol(*args):
        """
        AddHeaderProtocol(Handle_StepData_Protocol headerproto)

        Adds a new Header Protocol to the Header Definition

        :type headerproto: OCC.wrapper.StepData.Handle_StepData_Protocol

        """
        return _StepData.StepData__AddHeaderProtocol(*args)

    AddHeaderProtocol = staticmethod(AddHeaderProtocol)

    def Init(*args):
        """
        Init()

        Prepares General Data required to work with this package,
        which are the Protocol and Modules to be loaded into Libraries


        """
        return _StepData.StepData__Init(*args)

    Init = staticmethod(Init)

    def Protocol(*args):
        """
        Protocol() -> Handle_StepData_Protocol

        Returns a Protocol from StepData (avoids to create it)

        :rtype: OCC.wrapper.StepData.Handle_StepData_Protocol

        """
        return _StepData.StepData__Protocol(*args)

    Protocol = staticmethod(Protocol)

    def __init__(self):
        """
        Gives basic data definition for Step Interface.
        Any class of a data model described in EXPRESS Language
        is candidate to be managed by a Step Interface
        """
        this = _StepData.new_StepData_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepData.delete_StepData_
StepData__swigregister = _StepData.StepData__swigregister
StepData__swigregister(StepData_)

def StepData__HeaderProtocol(*args):
    """
    StepData__HeaderProtocol() -> Handle_StepData_Protocol

    Returns the recorded HeaderProtocol, which can be :
    - a Null Handle if no Header Protocol was yet defined
    - a simple Protocol if only one was defined
    - a FileProtocol if more than one Protocol was yet defined

    :rtype: OCC.wrapper.StepData.Handle_StepData_Protocol

    """
    return _StepData.StepData__HeaderProtocol(*args)

def StepData__AddHeaderProtocol(*args):
    """
    StepData__AddHeaderProtocol(Handle_StepData_Protocol headerproto)

    Adds a new Header Protocol to the Header Definition

    :type headerproto: OCC.wrapper.StepData.Handle_StepData_Protocol

    """
    return _StepData.StepData__AddHeaderProtocol(*args)

def StepData__Init(*args):
    """
    StepData__Init()

    Prepares General Data required to work with this package,
    which are the Protocol and Modules to be loaded into Libraries


    """
    return _StepData.StepData__Init(*args)

def StepData__Protocol(*args):
    """
    StepData__Protocol() -> Handle_StepData_Protocol

    Returns a Protocol from StepData (avoids to create it)

    :rtype: OCC.wrapper.StepData.Handle_StepData_Protocol

    """
    return _StepData.StepData__Protocol(*args)

class StepData_SelectType(object):
    """
    SelectType is the basis used for SELECT_TYPE definitions from
    the EXPRESS form. A SELECT_TYPE in EXPRESS is an enumeration
    of Types, it corresponds in a way to a Super-Type, but with
    no specific Methods, and no exclusivity (a given Type can be
    member of several SELECT_TYPES, plus be itself a SUB_TYPE).

    A SelectType can be field of a Transient Entity or only used
    to control an input Argument

    This class implies to designate each member Type by a Case
    Number which is a positive Integer value (this allows a faster
    treatement).

    With this class, a specific SelectType can :
    - recognize an Entity as complying or not with its definition,
    - storing it, with the garanty that the stored Entity complies
    with the definition of the SelectType
    - and (if judged useful) give the stored Entity under the good
    Type rather than simply "Transient".
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def CaseNum(self, *args):
        """
        CaseNum(StepData_SelectType self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes the Type of an Entity. Returns a positive Number
        which identifies the Type in the definition List of the
        SelectType. Returns Zero if its Type in not in this List.

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_SelectType_CaseNum(self, *args)


    def Matches(self, *args):
        """
        Matches(StepData_SelectType self, Handle_Standard_Transient ent) -> Standard_Boolean

        Returns True if the Type of an Entity complies with the
        definition list of the SelectType.
        Also checks for a SelectMember
        Default Implementation looks for CaseNum  or CaseMem positive

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_SelectType_Matches(self, *args)


    def SetValue(self, *args):
        """
        SetValue(StepData_SelectType self, Handle_Standard_Transient ent)

        Stores an Entity. This allows to define a specific SelectType
        class with one read method per member Type, which returns the
        Value casted with the good Type.

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.StepData_SelectType_SetValue(self, *args)


    def Nullify(self, *args):
        """
        Nullify(StepData_SelectType self)

        Nullifies the Stored Entity


        """
        return _StepData.StepData_SelectType_Nullify(self, *args)


    def Value(self, *args):
        """
        Returns the Stored Entity. Can be used to define specific
        read methods (see above)

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        res = _StepData.StepData_SelectType_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsNull(self, *args):
        """
        IsNull(StepData_SelectType self) -> Standard_Boolean

        Returns True if there is no Stored Entity (i.e. it is Null)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_SelectType_IsNull(self, *args)


    def Type(self, *args):
        """
        Type(StepData_SelectType self) -> Handle_Standard_Type

        Returns the Effective (Dynamic) Type of the Stored Entity
        If it is Null, returns TYPE(Transient)

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.StepData_SelectType_Type(self, *args)


    def CaseNumber(self, *args):
        """
        CaseNumber(StepData_SelectType self) -> Standard_Integer

        Recognizes the Type of the stored Entity, or zero if it is
        Null or SelectMember. Calls the first method CaseNum on Value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_SelectType_CaseNumber(self, *args)


    def Description(self, *args):
        """
        Description(StepData_SelectType self) -> Handle_StepData_PDescr

        Returns the Description which corresponds to <me>
        Null if no specific description to give. This description is
        used to control reading an check validity.
        Default returns a Null Handle, i.e. undefined description
        It can suffice if CaseNum and CaseMem give enough control

        :rtype: OCC.wrapper.StepData.Handle_StepData_PDescr

        """
        return _StepData.StepData_SelectType_Description(self, *args)


    def NewMember(self, *args):
        """
        NewMember(StepData_SelectType self) -> Handle_StepData_SelectMember

        Returns a preferred SelectMember. Default returns a Null
        By default, a SelectMember can be set according to data type
        and Name : it is a SelectNamed if Name is defined

        This method allows to define, for a specific SelectType, a
        specific SelectMember than SelectNamed. For instance for a
        Real plus a Name, a SelectReal plus a case number is a good
        solution, lighter than SelectNamed which is very multipurpose

        :rtype: OCC.wrapper.StepData.Handle_StepData_SelectMember

        """
        return _StepData.StepData_SelectType_NewMember(self, *args)


    def CaseMem(self, *args):
        """
        CaseMem(StepData_SelectType self, Handle_StepData_SelectMember ent) -> Standard_Integer

        Recognize a SelectMember (kind, name). Returns a positive
        value which identifies the case in the List of immediate cases
        (distinct from the List of Entity Types). Zero if not
        recognizes
        Default returns 0, saying that no immediate value is allowed

        :type ent: OCC.wrapper.StepData.Handle_StepData_SelectMember
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_SelectType_CaseMem(self, *args)


    def CaseMember(self, *args):
        """
        CaseMember(StepData_SelectType self) -> Standard_Integer

        Returns the Type of the stored SelectMember, or zero if it is
        Null or Entity. Calls the method CaseMem on Value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_SelectType_CaseMember(self, *args)


    def Member(self, *args):
        """
        Member(StepData_SelectType self) -> Handle_StepData_SelectMember

        Returns Value as a SelectMember. Null if not a SelectMember

        :rtype: OCC.wrapper.StepData.Handle_StepData_SelectMember

        """
        return _StepData.StepData_SelectType_Member(self, *args)


    def SelectName(self, *args):
        """
        SelectName(StepData_SelectType self) -> Standard_CString

        Returns the type name of SelectMember. If no SelectMember or
        with no type name, returns an empty string
        To change it, pass through the SelectMember itself

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_SelectType_SelectName(self, *args)


    def Int(self, *args):
        """
        Int(StepData_SelectType self) -> Standard_Integer

        This internal method gives access to a value implemented by an
        Integer (to read it)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_SelectType_Int(self, *args)


    def SetInt(self, *args):
        """
        SetInt(StepData_SelectType self, Standard_Integer const val)

        This internal method gives access to a value implemented by an
        Integer (to set it) : a SelectMember MUST ALREADY BE THERE !

        :type val: int

        """
        return _StepData.StepData_SelectType_SetInt(self, *args)


    def Integer(self, *args):
        """
        Integer(StepData_SelectType self) -> Standard_Integer

        Gets the value as an Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_SelectType_Integer(self, *args)


    def SetInteger(self, *args):
        """
        SetInteger(StepData_SelectType self, Standard_Integer const val, Standard_CString const name)

        Sets a new Integer value, with an optional type name
        Warning : If a SelectMember is already set, works on it : value and
        name must then be accepted by this SelectMember

        :type val: int
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_SelectType_SetInteger(self, *args)


    def Boolean(self, *args):
        """
        Boolean(StepData_SelectType self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_SelectType_Boolean(self, *args)


    def SetBoolean(self, *args):
        """
        SetBoolean(StepData_SelectType self, Standard_Boolean const val, Standard_CString const name)

        :type val: bool
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_SelectType_SetBoolean(self, *args)


    def Logical(self, *args):
        """
        Logical(StepData_SelectType self) -> StepData_Logical

        :rtype: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepData.StepData_SelectType_Logical(self, *args)


    def SetLogical(self, *args):
        """
        SetLogical(StepData_SelectType self, StepData_Logical const val, Standard_CString const name)

        :type val: OCC.wrapper.StepData.StepData_Logical
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_SelectType_SetLogical(self, *args)


    def Real(self, *args):
        """
        Real(StepData_SelectType self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepData.StepData_SelectType_Real(self, *args)


    def SetReal(self, *args):
        """
        SetReal(StepData_SelectType self, Standard_Real const val, Standard_CString const name)

        :type val: float
        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_SelectType_SetReal(self, *args)

    __swig_destroy__ = _StepData.delete_StepData_SelectType
StepData_SelectType_swigregister = _StepData.StepData_SelectType_swigregister
StepData_SelectType_swigregister(StepData_SelectType)

class StepData_WriterLib(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def SetGlobal(*args):
        """
        SetGlobal(Handle_StepData_ReadWriteModule amodule, Handle_StepData_Protocol aprotocol)

        Adds a couple (Module-Protocol) into the global definition set
        for this class of Library.

        :type amodule: OCC.wrapper.StepData.Handle_StepData_ReadWriteModule
        :type aprotocol: OCC.wrapper.StepData.Handle_StepData_Protocol

        """
        return _StepData.StepData_WriterLib_SetGlobal(*args)

    SetGlobal = staticmethod(SetGlobal)

    def __init__(self, *args):
        """
        __init__(StepData_WriterLib self, Handle_StepData_Protocol aprotocol) -> StepData_WriterLib
        __init__(StepData_WriterLib self) -> StepData_WriterLib

        Creates an empty Library : it will later by filled by method
        AddProtocol


        """
        this = _StepData.new_StepData_WriterLib(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddProtocol(self, *args):
        """
        AddProtocol(StepData_WriterLib self, Handle_Standard_Transient aprotocol)

        Adds a couple (Module-Protocol) to the Library, given the
        class of a Protocol. Takes Resources into account.
        (if <aprotocol> is not of type TheProtocol, it is not added)

        :type aprotocol: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.StepData_WriterLib_AddProtocol(self, *args)


    def Clear(self, *args):
        """
        Clear(StepData_WriterLib self)

        Clears the list of Modules of a library (can be used to
        redefine the order of Modules before action : Clear then
        refill the Library by calls to AddProtocol)


        """
        return _StepData.StepData_WriterLib_Clear(self, *args)


    def SetComplete(self, *args):
        """
        SetComplete(StepData_WriterLib self)

        Sets a library to be defined with the complete Global list
        (all the couples Protocol/Modules recorded in it)


        """
        return _StepData.StepData_WriterLib_SetComplete(self, *args)


    def Select(self, *args):
        """
        Select(StepData_WriterLib self, Handle_Standard_Transient obj, Handle_StepData_ReadWriteModule module) -> Standard_Boolean

        Selects a Module from the Library, given an Object.
        Returns True if Select has succeeded, False else.
        Also Returns (as arguments) the selected Module and the Case
        Number determined by the associated Protocol.
        If Select has failed, <module> is Null Handle and CN is zero.
        (Select can work on any criterium, such as Object DynamicType)

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :type module: OCC.wrapper.StepData.Handle_StepData_ReadWriteModule
        :type CN: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_WriterLib_Select(self, *args)


    def Start(self, *args):
        """
        Start(StepData_WriterLib self)

        Starts Iteration on the Modules (sets it on the first one)


        """
        return _StepData.StepData_WriterLib_Start(self, *args)


    def More(self, *args):
        """
        More(StepData_WriterLib self) -> Standard_Boolean

        Returns True if there are more Modules to iterate on

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_WriterLib_More(self, *args)


    def Next(self, *args):
        """
        Next(StepData_WriterLib self)

        Iterates by getting the next Module in the list
        If there is none, the exception will be raised by Value


        """
        return _StepData.StepData_WriterLib_Next(self, *args)


    def Module(self, *args):
        """
        Returns the current Module in the Iteration

        :rtype: OCC.wrapper.StepData.Handle_StepData_ReadWriteModule

        """
        res = _StepData.StepData_WriterLib_Module(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Protocol(self, *args):
        """
        Returns the current Protocol in the Iteration

        :rtype: OCC.wrapper.StepData.Handle_StepData_Protocol

        """
        res = _StepData.StepData_WriterLib_Protocol(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepData.delete_StepData_WriterLib
StepData_WriterLib_swigregister = _StepData.StepData_WriterLib_swigregister
StepData_WriterLib_swigregister(StepData_WriterLib)

def StepData_WriterLib_SetGlobal(*args):
    """
    StepData_WriterLib_SetGlobal(Handle_StepData_ReadWriteModule amodule, Handle_StepData_Protocol aprotocol)

    Adds a couple (Module-Protocol) into the global definition set
    for this class of Library.

    :type amodule: OCC.wrapper.StepData.Handle_StepData_ReadWriteModule
    :type aprotocol: OCC.wrapper.StepData.Handle_StepData_Protocol

    """
    return _StepData.StepData_WriterLib_SetGlobal(*args)

class Handle_StepData_DefaultGeneral(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_DefaultGeneral self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_DefaultGeneral_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_DefaultGeneral self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_DefaultGeneral_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_DefaultGeneral self, StepData_DefaultGeneral thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_DefaultGeneral_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_DefaultGeneral self, Handle_StepData_DefaultGeneral theHandle) -> Handle_StepData_DefaultGeneral
        assign(Handle_StepData_DefaultGeneral self, StepData_DefaultGeneral thePtr) -> Handle_StepData_DefaultGeneral
        assign(Handle_StepData_DefaultGeneral self, Handle_StepData_DefaultGeneral theHandle) -> Handle_StepData_DefaultGeneral

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_DefaultGeneral_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_DefaultGeneral self) -> StepData_DefaultGeneral

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_DefaultGeneral_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_DefaultGeneral self) -> StepData_DefaultGeneral

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_DefaultGeneral___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_DefaultGeneral self) -> StepData_DefaultGeneral

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_DefaultGeneral___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_DefaultGeneral___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_DefaultGeneral___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_DefaultGeneral(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_DefaultGeneral_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_DefaultGeneral

    def FillSharedCase(self, *args):
        """
        FillSharedCase(Handle_StepData_DefaultGeneral self, Standard_Integer const casenum, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        Specific filling of the list of Entities shared by an Entity
        <ent>, which is an UnknownEntity from StepData.

        :type casenum: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.Handle_StepData_DefaultGeneral_FillSharedCase(self, *args)


    def CheckCase(self, *args):
        """
        CheckCase(Handle_StepData_DefaultGeneral self, Standard_Integer const casenum, Handle_Standard_Transient ent, Interface_ShareTool shares, Handle_Interface_Check ach)

        Specific Checking of an Entity <ent>

        :type casenum: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type shares: OCC.wrapper.Interface.Interface_ShareTool
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _StepData.Handle_StepData_DefaultGeneral_CheckCase(self, *args)


    def NewVoid(self, *args):
        """
        NewVoid(Handle_StepData_DefaultGeneral self, Standard_Integer const CN, Handle_Standard_Transient entto) -> Standard_Boolean

        Specific creation of a new void entity

        :type CN: int
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_DefaultGeneral_NewVoid(self, *args)


    def CopyCase(self, *args):
        """
        CopyCase(Handle_StepData_DefaultGeneral self, Standard_Integer const casenum, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC)

        Specific Copy ("Deep") from <entfrom> to <entto> (same type)
        by using a CopyTool which provides its working Map.
        Use method Transferred from TransferControl to work

        :type casenum: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _StepData.Handle_StepData_DefaultGeneral_CopyCase(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_DefaultGeneral self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_DefaultGeneral_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_DefaultGeneral_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_DefaultGeneral_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FillShared(self, *args):
        """
        FillShared(Handle_StepData_DefaultGeneral self, Handle_Interface_InterfaceModel model, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        Specific filling of the list of Entities shared by an Entity
        <ent>, according a Case Number <CN> (formerly computed by
        CaseNum), considered in the context of a Model <model>
        Default calls FillSharedCase (i.e., ignores the model)
        Can be redefined to use the model for working

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.Handle_StepData_DefaultGeneral_FillShared(self, *args)


    def Share(self, *args):
        """
        Share(Handle_StepData_DefaultGeneral self, Interface_EntityIterator iter, Handle_Standard_Transient shared)

        Adds an Entity to a Shared List (uses GetOneItem on <iter>)

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator
        :type shared: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.Handle_StepData_DefaultGeneral_Share(self, *args)


    def ListImplied(self, *args):
        """
        ListImplied(Handle_StepData_DefaultGeneral self, Handle_Interface_InterfaceModel model, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        List the Implied References of <ent> considered in the context
        of a Model <model> : i.e. the Entities which are Referenced
        while not considered as Shared (not copied if <ent> is,
        references not renewed by CopyCase but by ImpliedCase, only
        if referenced Entities have been Copied too)
        FillShared + ListImplied give the complete list of References
        Default calls ListImpliedCase (i.e. ignores the model)
        Can be redefined to use the model for working

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.Handle_StepData_DefaultGeneral_ListImplied(self, *args)


    def ListImpliedCase(self, *args):
        """
        ListImpliedCase(Handle_StepData_DefaultGeneral self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        List the Implied References of <ent> (see above)
        are Referenced while not considered as Shared (not copied if
        <ent> is, references not renewed by CopyCase but by
        ImpliedCase, only if referenced Entities have been Copied too)
        FillSharedCase + ListImpliedCase give the complete list of
        Referenced Entities
        The provided default method does nothing (Implied References
        are specific of a little amount of Entity Classes).

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.Handle_StepData_DefaultGeneral_ListImpliedCase(self, *args)


    def CanCopy(self, *args):
        """
        CanCopy(Handle_StepData_DefaultGeneral self, Standard_Integer const CN, Handle_Standard_Transient ent) -> Standard_Boolean

        Specific answer to the question "is Copy properly implemented"
        Remark that it should be in phase with the implementation of
        NewVoid+CopyCase/NewCopyCase
        Default returns always False, can be redefined

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_DefaultGeneral_CanCopy(self, *args)


    def Dispatch(self, *args):
        """
        Dispatch(Handle_StepData_DefaultGeneral self, Standard_Integer const CN, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC) -> Standard_Boolean

        Dispatches an entity
        Returns True if it works by copy, False if it just duplicates
        the starting Handle

        Dispatching means producing a new entity, image of the
        starting one, in order to be put into a new Model, this Model
        being itself the result of a dispatch from an original Model

        According to the cases, dispatch can either
        * just return <entto> as equating <entfrom>
        -> the new model designates the starting entity : it is
        lighter, but the dispatched entity being shared might not be
        modified for dispatch
        * copy <entfrom> to <entto>
        by calling NewVoid+CopyCase (two steps) or NewCopiedCase (1)
        -> the dispatched entity is a COPY, hence it can be modified

        The provided default just duplicates the handle without
        copying, then returns False. Can be redefined

        :type CN: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_DefaultGeneral_Dispatch(self, *args)


    def NewCopiedCase(self, *args):
        """
        NewCopiedCase(Handle_StepData_DefaultGeneral self, Standard_Integer const CN, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC) -> Standard_Boolean

        Specific operator (create+copy) defaulted to do nothing.
        It can be redefined : When it is not possible to work in two
        steps (NewVoid then CopyCase). This can occur when there is
        no default constructor : hence the result <entto> must be
        created with an effective definition.
        Remark : if NewCopiedCase is defined, CopyCase has nothing to do
        Returns True if it has produced something, false else

        :type CN: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_DefaultGeneral_NewCopiedCase(self, *args)


    def RenewImpliedCase(self, *args):
        """
        RenewImpliedCase(Handle_StepData_DefaultGeneral self, Standard_Integer const CN, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC)

        Specific Copying of Implied References
        A Default is provided which does nothing (must current case !)
        Already copied references (by CopyFrom) must remain unchanged
        Use method Search from CopyTool to work

        :type CN: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _StepData.Handle_StepData_DefaultGeneral_RenewImpliedCase(self, *args)


    def WhenDeleteCase(self, *args):
        """
        WhenDeleteCase(Handle_StepData_DefaultGeneral self, Standard_Integer const CN, Handle_Standard_Transient ent, Standard_Boolean const dispatched)

        Prepares an entity to be deleted. What does it mean :
        Basically, any class of entity may define its own destructor
        By default, it does nothing but calling destructors on fields
        With the Memory Manager, it is useless to call destructor,
        it is done automatically when the Handle is nullified(cleared)
        BUT this is ineffective in looping structures (whatever these
        are "Implied" references or not).

        THUS : if no loop may appear in definitions, a class which
        inherits from TShared is correctly managed by automatic way
        BUT if there can be loops (or simply back pointers), they must
        be broken, for instance by clearing fields of one of the nodes
        The default does nothing, to be redefined if a loop can occur
        (Implied generally requires WhenDelete, but other cases can
        occur)

        Warning : <dispatched> tells if the entity to be deleted has been
        produced by Dispatch or not. Hence WhenDelete must be in
        coherence with Dispatch
        Dispatch can either copy or not.
        If it copies the entity, this one should be deleted
        If it doesnt (i.e. duplicates the handle) nothing to do

        If <dispatch> is False, normal deletion is to be performed

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type dispatched: bool

        """
        return _StepData.Handle_StepData_DefaultGeneral_WhenDeleteCase(self, *args)


    def CategoryNumber(self, *args):
        """
        CategoryNumber(Handle_StepData_DefaultGeneral self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_ShareTool shares) -> Standard_Integer

        Returns a category number which characterizes an entity
        Category Numbers are managed by the class Category
        <shares> can be used to evaluate this number in the context
        Default returns 0 which means "unspecified"

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type shares: OCC.wrapper.Interface.Interface_ShareTool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_DefaultGeneral_CategoryNumber(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepData_DefaultGeneral self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_ShareTool shares) -> Handle_TCollection_HAsciiString

        Determines if an entity brings a Name (or widerly, if a Name
        can be attached to it, through the ShareTool
        By default, returns a Null Handle (no name can be produced)
        Can be redefined

        Warning : While this string may be edited on the spot, if it is a read
        field, the returned value must be copied before.

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type shares: OCC.wrapper.Interface.Interface_ShareTool
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepData.Handle_StepData_DefaultGeneral_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepData_DefaultGeneral self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_DefaultGeneral_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_DefaultGeneral self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_DefaultGeneral self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_DefaultGeneral_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_DefaultGeneral self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_DefaultGeneral self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_DefaultGeneral_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_DefaultGeneral self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_DefaultGeneral_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_DefaultGeneral self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_DefaultGeneral_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_DefaultGeneral self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_DefaultGeneral_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_DefaultGeneral self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_DefaultGeneral_DecrementRefCounter(self, *args)

Handle_StepData_DefaultGeneral_swigregister = _StepData.Handle_StepData_DefaultGeneral_swigregister
Handle_StepData_DefaultGeneral_swigregister(Handle_StepData_DefaultGeneral)

def Handle_StepData_DefaultGeneral_DownCast(thing):
    return _StepData.Handle_StepData_DefaultGeneral_DownCast(thing)
Handle_StepData_DefaultGeneral_DownCast = _StepData.Handle_StepData_DefaultGeneral_DownCast

class StepData_HeaderTool(object):
    """
    HeaderTool exploits data from Header to build a Protocol :
    it uses the Header Entity FileSchema to do this.
    It builds a Protocol from the Global List of Protocols
    stored in the Library ReaderLib
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepData_HeaderTool self, Handle_StepData_StepReaderData data) -> StepData_HeaderTool
        __init__(StepData_HeaderTool self, NCollection_Sequence_TCollection_AsciiString names) -> StepData_HeaderTool

        Creates a HeaderTool directly from a list of Schema Names

        :type names: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString

        """
        this = _StepData.new_StepData_HeaderTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbSchemaNames(self, *args):
        """
        NbSchemaNames(StepData_HeaderTool self) -> Standard_Integer

        Returns the count of SchemaNames

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_HeaderTool_NbSchemaNames(self, *args)


    def SchemaName(self, *args):
        """
        Returns a SchemaName, given its rank

        :type num: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _StepData.StepData_HeaderTool_SchemaName(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NamedProtocol(self, *args):
        """
        NamedProtocol(StepData_HeaderTool self, TCollection_AsciiString name) -> Handle_StepData_Protocol

        Returns the Protocol which corresponds to a Schema Name
        Returns a Null Handle if this Schema Name is attached to no
        Protocol recorded in the Global List of ReaderLib

        :type name: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.StepData.Handle_StepData_Protocol

        """
        return _StepData.StepData_HeaderTool_NamedProtocol(self, *args)


    def Build(self, *args):
        """
        Build(StepData_HeaderTool self, Handle_StepData_FileProtocol protocol)

        Fills a FileProtocol with the list of Protocols attached to
        the list of Schema Names. It can remain empty ...

        :type protocol: OCC.wrapper.StepData.Handle_StepData_FileProtocol

        """
        return _StepData.StepData_HeaderTool_Build(self, *args)


    def Protocol(self, *args):
        """
        Protocol(StepData_HeaderTool self) -> Handle_StepData_Protocol

        Returns a Protocol computed from the list of Schema Names :
        - a Null Handle if no SchemaName has been recognized (or list
        empty)
        - a single Protocol if only one SchemaName has been recognized
        - a FileProtocol with its componants if several SchemaNames
        have been recognized

        :rtype: OCC.wrapper.StepData.Handle_StepData_Protocol

        """
        return _StepData.StepData_HeaderTool_Protocol(self, *args)


    def IsDone(self, *args):
        """
        IsDone(StepData_HeaderTool self) -> Standard_Boolean

        Returns True if either Build or Protocol has been called
        If it is False, Ignored and NbIgnored should not be called

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_HeaderTool_IsDone(self, *args)


    def NbIgnoreds(self, *args):
        """
        NbIgnoreds(StepData_HeaderTool self) -> Standard_Integer

        Returns the count of ignored SchemaNames (0 if all were OK)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_HeaderTool_NbIgnoreds(self, *args)


    def Ignored(self, *args):
        """
        Returns an ignored SchemaName, given its rank in the list of
        Ignored SchemaNames (not in the total list)

        :type num: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _StepData.StepData_HeaderTool_Ignored(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(StepData_HeaderTool self, Standard_OStream & S)

        Sends the state of the HeaderTool in a comprehensive way,
        to an output stream

        :type S: OCC.wrapper.Standard.Standard_OStream

        """
        return _StepData.StepData_HeaderTool_Print(self, *args)

    __swig_destroy__ = _StepData.delete_StepData_HeaderTool
StepData_HeaderTool_swigregister = _StepData.StepData_HeaderTool_swigregister
StepData_HeaderTool_swigregister(StepData_HeaderTool)

class StepData_EnumTool(object):
    """
    This class gives a way of conversion between the value of an
    enumeration and its representation in STEP
    An enumeration corresponds to an integer with reserved values,
    which begin to 0
    In STEP, it is represented by a name in capital letter and
    limited by two dots, e.g. .UNKNOWN.

    EnumTool works with integers, it is just required to cast
    between an integer and an enumeration of required type.

    Its definition is intended to allow static creation in once,
    without having to recreate once for each use.

    It is possible to define subclasses on it, which directly give
    the good list of definition texts, and accepts a enumeration
    of the good type instead of an integer
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepData_EnumTool self, Standard_CString const e0, Standard_CString const e1, Standard_CString const e2, Standard_CString const e3, Standard_CString const e4, Standard_CString const e5, Standard_CString const e6, Standard_CString const e7, Standard_CString const e8, Standard_CString const e9, Standard_CString const e10, Standard_CString const e11, Standard_CString const e12, Standard_CString const e13, Standard_CString const e14, Standard_CString const e15, Standard_CString const e16, Standard_CString const e17, Standard_CString const e18, Standard_CString const e19, Standard_CString const e20, Standard_CString const e21, Standard_CString const e22, Standard_CString const e23, Standard_CString const e24, Standard_CString const e25, Standard_CString const e26, Standard_CString const e27, Standard_CString const e28, Standard_CString const e29, Standard_CString const e30, Standard_CString const e31, Standard_CString const e32, Standard_CString const e33, Standard_CString const e34, Standard_CString const e35, Standard_CString const e36, Standard_CString const e37, Standard_CString const e38, Standard_CString const e39) -> StepData_EnumTool

        Creates an EnumTool with definitions given by e0 .. e<max>
        Each definition string can bring one term, or several
        separated by blanks. Each term corresponds to one value of the
        enumeration, if dots are not presents they are added

        Such a static constructor allows to build a static description
        as : static StepData_EnumTool myenumtool("e0","e1"...);
        then use it without having to initialise it

        A null definition can be input by given "$" :the corresponding
        position is attached to "null/undefined" value (as one
        particular item of the enumeration list)

        :type e0: OCC.wrapper.Standard.Standard_CString
        :type e1: OCC.wrapper.Standard.Standard_CString
        :type e2: OCC.wrapper.Standard.Standard_CString
        :type e3: OCC.wrapper.Standard.Standard_CString
        :type e4: OCC.wrapper.Standard.Standard_CString
        :type e5: OCC.wrapper.Standard.Standard_CString
        :type e6: OCC.wrapper.Standard.Standard_CString
        :type e7: OCC.wrapper.Standard.Standard_CString
        :type e8: OCC.wrapper.Standard.Standard_CString
        :type e9: OCC.wrapper.Standard.Standard_CString
        :type e10: OCC.wrapper.Standard.Standard_CString
        :type e11: OCC.wrapper.Standard.Standard_CString
        :type e12: OCC.wrapper.Standard.Standard_CString
        :type e13: OCC.wrapper.Standard.Standard_CString
        :type e14: OCC.wrapper.Standard.Standard_CString
        :type e15: OCC.wrapper.Standard.Standard_CString
        :type e16: OCC.wrapper.Standard.Standard_CString
        :type e17: OCC.wrapper.Standard.Standard_CString
        :type e18: OCC.wrapper.Standard.Standard_CString
        :type e19: OCC.wrapper.Standard.Standard_CString
        :type e20: OCC.wrapper.Standard.Standard_CString
        :type e21: OCC.wrapper.Standard.Standard_CString
        :type e22: OCC.wrapper.Standard.Standard_CString
        :type e23: OCC.wrapper.Standard.Standard_CString
        :type e24: OCC.wrapper.Standard.Standard_CString
        :type e25: OCC.wrapper.Standard.Standard_CString
        :type e26: OCC.wrapper.Standard.Standard_CString
        :type e27: OCC.wrapper.Standard.Standard_CString
        :type e28: OCC.wrapper.Standard.Standard_CString
        :type e29: OCC.wrapper.Standard.Standard_CString
        :type e30: OCC.wrapper.Standard.Standard_CString
        :type e31: OCC.wrapper.Standard.Standard_CString
        :type e32: OCC.wrapper.Standard.Standard_CString
        :type e33: OCC.wrapper.Standard.Standard_CString
        :type e34: OCC.wrapper.Standard.Standard_CString
        :type e35: OCC.wrapper.Standard.Standard_CString
        :type e36: OCC.wrapper.Standard.Standard_CString
        :type e37: OCC.wrapper.Standard.Standard_CString
        :type e38: OCC.wrapper.Standard.Standard_CString
        :type e39: OCC.wrapper.Standard.Standard_CString

        """
        this = _StepData.new_StepData_EnumTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddDefinition(self, *args):
        """
        AddDefinition(StepData_EnumTool self, Standard_CString const term)

        Processes a definition, splits it according blanks if any
        empty definitions are ignored
        A null definition can be input by given "$" :the corresponding
        position is attached to "null/undefined" value (as one
        particular item of the enumeration list)
        See also IsSet

        :type term: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.StepData_EnumTool_AddDefinition(self, *args)


    def IsSet(self, *args):
        """
        IsSet(StepData_EnumTool self) -> Standard_Boolean

        Returns True if at least one definition has been entered after
        creation time (i.e. by AddDefinition only)

        This allows to build a static description by a first pass :
        static StepData_EnumTool myenumtool("e0" ...);
        ...
        if (!myenumtool.IsSet()) {             for further inits
        myenumtool.AddDefinition("e21");
        ...
        }

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.StepData_EnumTool_IsSet(self, *args)


    def MaxValue(self, *args):
        """
        MaxValue(StepData_EnumTool self) -> Standard_Integer

        Returns the maximum integer for a suitable value
        Remark : while values begin at zero, MaxValue is the count of
        recorded values minus one

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_EnumTool_MaxValue(self, *args)


    def Optional(self, *args):
        """
        Optional(StepData_EnumTool self, Standard_Boolean const mode)

        Sets or Unsets the EnumTool to accept undefined value (for
        optional field). Ignored if no null value is defined (by "$")
        Can be changed during execution (to read each field),
        Default is True (if a null value is defined)

        :type mode: bool

        """
        return _StepData.StepData_EnumTool_Optional(self, *args)


    def NullValue(self, *args):
        """
        NullValue(StepData_EnumTool self) -> Standard_Integer

        Returns the value attached to "null/undefined value"
        If none is specified or if Optional has been set to False,
        returns -1
        Null Value has been specified by definition "$"

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_EnumTool_NullValue(self, *args)


    def Text(self, *args):
        """
        Returns the text which corresponds to a given numeric value
        It is limited by dots
        If num is out of range, returns an empty string

        :type num: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _StepData.StepData_EnumTool_Text(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Value(self, *args):
        """
        Value(StepData_EnumTool self, Standard_CString const txt) -> Standard_Integer
        Value(StepData_EnumTool self, TCollection_AsciiString txt) -> Standard_Integer

        Same as above but works on an AsciiString

        :type txt: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.StepData_EnumTool_Value(self, *args)

    __swig_destroy__ = _StepData.delete_StepData_EnumTool
StepData_EnumTool_swigregister = _StepData.StepData_EnumTool_swigregister
StepData_EnumTool_swigregister(StepData_EnumTool)

class Handle_StepData_UndefinedEntity(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_UndefinedEntity self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_UndefinedEntity_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_UndefinedEntity self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_UndefinedEntity_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_UndefinedEntity self, StepData_UndefinedEntity thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_UndefinedEntity_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_UndefinedEntity self, Handle_StepData_UndefinedEntity theHandle) -> Handle_StepData_UndefinedEntity
        assign(Handle_StepData_UndefinedEntity self, StepData_UndefinedEntity thePtr) -> Handle_StepData_UndefinedEntity
        assign(Handle_StepData_UndefinedEntity self, Handle_StepData_UndefinedEntity theHandle) -> Handle_StepData_UndefinedEntity

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_UndefinedEntity_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_UndefinedEntity self) -> StepData_UndefinedEntity

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_UndefinedEntity_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_UndefinedEntity self) -> StepData_UndefinedEntity

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_UndefinedEntity___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_UndefinedEntity self) -> StepData_UndefinedEntity

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_UndefinedEntity___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_UndefinedEntity___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_UndefinedEntity___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_UndefinedEntity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_UndefinedEntity_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_UndefinedEntity

    def UndefinedContent(self, *args):
        """
        UndefinedContent(Handle_StepData_UndefinedEntity self) -> Handle_Interface_UndefinedContent

        Returns the UndefinedContent which brings the Parameters

        :rtype: OCC.wrapper.Interface.Handle_Interface_UndefinedContent

        """
        return _StepData.Handle_StepData_UndefinedEntity_UndefinedContent(self, *args)


    def IsSub(self, *args):
        """
        IsSub(Handle_StepData_UndefinedEntity self) -> Standard_Boolean

        Returns True if an Unndefined Entity is SubPart of another one

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_UndefinedEntity_IsSub(self, *args)


    def IsComplex(self, *args):
        """
        IsComplex(Handle_StepData_UndefinedEntity self) -> Standard_Boolean

        Returns True if <me> defines a Multiple Type Entity (see ANDOR)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_UndefinedEntity_IsComplex(self, *args)


    def Next(self, *args):
        """
        Next(Handle_StepData_UndefinedEntity self) -> Handle_StepData_UndefinedEntity

        For a Multiple Type Entity, returns the Next "Componant"
        For more than two Types, iterative definition (Next->Next...)
        Returns a Null Handle for the end of the List

        :rtype: OCC.wrapper.StepData.Handle_StepData_UndefinedEntity

        """
        return _StepData.Handle_StepData_UndefinedEntity_Next(self, *args)


    def StepType(self, *args):
        """
        StepType(Handle_StepData_UndefinedEntity self) -> Standard_CString

        gives entity type, read from file
        For a Complex Type Entity, gives the first Type read, each
        "Next" gives its "partial" type
        was C++ : return const

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_UndefinedEntity_StepType(self, *args)


    def ReadRecord(self, *args):
        """
        ReadRecord(Handle_StepData_UndefinedEntity self, Handle_StepData_StepReaderData SR, Standard_Integer const num, Handle_Interface_Check ach)

        reads data from StepReaderData (i.e. from file), by filling
        StepType and parameters stored in the UndefinedContent

        :type SR: OCC.wrapper.StepData.Handle_StepData_StepReaderData
        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _StepData.Handle_StepData_UndefinedEntity_ReadRecord(self, *args)


    def WriteParams(self, *args):
        """
        WriteParams(Handle_StepData_UndefinedEntity self, StepData_StepWriter SW)

        write data to StepWriter, taken from UndefinedContent

        :type SW: OCC.wrapper.StepData.StepData_StepWriter

        """
        return _StepData.Handle_StepData_UndefinedEntity_WriteParams(self, *args)


    def GetFromAnother(self, *args):
        """
        GetFromAnother(Handle_StepData_UndefinedEntity self, Handle_StepData_UndefinedEntity other, Interface_CopyTool TC)

        reads another UndefinedEntity from StepData

        :type other: OCC.wrapper.StepData.Handle_StepData_UndefinedEntity
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _StepData.Handle_StepData_UndefinedEntity_GetFromAnother(self, *args)


    def FillShared(self, *args):
        """
        FillShared(Handle_StepData_UndefinedEntity self, Interface_EntityIterator list)

        Fills the list of shared entities

        :type list: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _StepData.Handle_StepData_UndefinedEntity_FillShared(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_UndefinedEntity self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_UndefinedEntity_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_UndefinedEntity_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_UndefinedEntity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepData_UndefinedEntity self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_UndefinedEntity_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_UndefinedEntity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_UndefinedEntity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_UndefinedEntity_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_UndefinedEntity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_UndefinedEntity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_UndefinedEntity_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_UndefinedEntity self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_UndefinedEntity_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_UndefinedEntity self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_UndefinedEntity_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_UndefinedEntity self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_UndefinedEntity_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_UndefinedEntity self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_UndefinedEntity_DecrementRefCounter(self, *args)

Handle_StepData_UndefinedEntity_swigregister = _StepData.Handle_StepData_UndefinedEntity_swigregister
Handle_StepData_UndefinedEntity_swigregister(Handle_StepData_UndefinedEntity)

def Handle_StepData_UndefinedEntity_DownCast(thing):
    return _StepData.Handle_StepData_UndefinedEntity_DownCast(thing)
Handle_StepData_UndefinedEntity_DownCast = _StepData.Handle_StepData_UndefinedEntity_DownCast

class Handle_StepData_SelectInt(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_SelectInt self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_SelectInt_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_SelectInt self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_SelectInt_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_SelectInt self, StepData_SelectInt thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_SelectInt_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_SelectInt self, Handle_StepData_SelectInt theHandle) -> Handle_StepData_SelectInt
        assign(Handle_StepData_SelectInt self, StepData_SelectInt thePtr) -> Handle_StepData_SelectInt
        assign(Handle_StepData_SelectInt self, Handle_StepData_SelectInt theHandle) -> Handle_StepData_SelectInt

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_SelectInt_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_SelectInt self) -> StepData_SelectInt

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_SelectInt_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_SelectInt self) -> StepData_SelectInt

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_SelectInt___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_SelectInt self) -> StepData_SelectInt

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_SelectInt___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_SelectInt___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_SelectInt___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_SelectInt(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_SelectInt_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_SelectInt

    def Kind(self, *args):
        """
        Kind(Handle_StepData_SelectInt self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectInt_Kind(self, *args)


    def SetKind(self, *args):
        """
        SetKind(Handle_StepData_SelectInt self, Standard_Integer const kind)

        :type kind: int

        """
        return _StepData.Handle_StepData_SelectInt_SetKind(self, *args)


    def Int(self, *args):
        """
        Int(Handle_StepData_SelectInt self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectInt_Int(self, *args)


    def SetInt(self, *args):
        """
        SetInt(Handle_StepData_SelectInt self, Standard_Integer const val)

        :type val: int

        """
        return _StepData.Handle_StepData_SelectInt_SetInt(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_SelectInt self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_SelectInt_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_SelectInt_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_SelectInt_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasName(self, *args):
        """
        HasName(Handle_StepData_SelectInt self) -> Standard_Boolean

        Tells if a SelectMember has a name. Default is False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectInt_HasName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepData_SelectInt self) -> Standard_CString

        Returns the name of a SelectMember. Default is empty

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectInt_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepData_SelectInt self, Standard_CString const name) -> Standard_Boolean

        Sets the name of a SelectMember, returns True if done, False
        if no name is allowed
        Default does nothing and returns False

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectInt_SetName(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_StepData_SelectInt self, Standard_CString const name) -> Standard_Boolean

        Tells if the name of a SelectMember matches a given one
        By default, compares the strings, can be redefined (optimised)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectInt_Matches(self, *args)


    def ParamType(self, *args):
        """
        ParamType(Handle_StepData_SelectInt self) -> Interface_ParamType

        Returns the Kind of the SelectMember, under the form of an
        enum ParamType

        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _StepData.Handle_StepData_SelectInt_ParamType(self, *args)


    def Integer(self, *args):
        """
        Integer(Handle_StepData_SelectInt self) -> Standard_Integer

        Gets the value as an Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectInt_Integer(self, *args)


    def SetInteger(self, *args):
        """
        SetInteger(Handle_StepData_SelectInt self, Standard_Integer const val)

        :type val: int

        """
        return _StepData.Handle_StepData_SelectInt_SetInteger(self, *args)


    def Boolean(self, *args):
        """
        Boolean(Handle_StepData_SelectInt self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectInt_Boolean(self, *args)


    def SetBoolean(self, *args):
        """
        SetBoolean(Handle_StepData_SelectInt self, Standard_Boolean const val)

        :type val: bool

        """
        return _StepData.Handle_StepData_SelectInt_SetBoolean(self, *args)


    def Logical(self, *args):
        """
        Logical(Handle_StepData_SelectInt self) -> StepData_Logical

        :rtype: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepData.Handle_StepData_SelectInt_Logical(self, *args)


    def SetLogical(self, *args):
        """
        SetLogical(Handle_StepData_SelectInt self, StepData_Logical const val)

        :type val: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepData.Handle_StepData_SelectInt_SetLogical(self, *args)


    def Real(self, *args):
        """
        Real(Handle_StepData_SelectInt self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepData.Handle_StepData_SelectInt_Real(self, *args)


    def SetReal(self, *args):
        """
        SetReal(Handle_StepData_SelectInt self, Standard_Real const val)

        :type val: float

        """
        return _StepData.Handle_StepData_SelectInt_SetReal(self, *args)


    def String(self, *args):
        """
        String(Handle_StepData_SelectInt self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectInt_String(self, *args)


    def SetString(self, *args):
        """
        SetString(Handle_StepData_SelectInt self, Standard_CString const val)

        :type val: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectInt_SetString(self, *args)


    def Enum(self, *args):
        """
        Enum(Handle_StepData_SelectInt self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectInt_Enum(self, *args)


    def EnumText(self, *args):
        """
        EnumText(Handle_StepData_SelectInt self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectInt_EnumText(self, *args)


    def SetEnum(self, *args):
        """
        SetEnum(Handle_StepData_SelectInt self, Standard_Integer const val, Standard_CString const text)

        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectInt_SetEnum(self, *args)


    def SetEnumText(self, *args):
        """
        SetEnumText(Handle_StepData_SelectInt self, Standard_Integer const val, Standard_CString const text)

        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectInt_SetEnumText(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepData_SelectInt self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_SelectInt_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_SelectInt self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_SelectInt self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectInt_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_SelectInt self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_SelectInt self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectInt_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_SelectInt self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_SelectInt_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_SelectInt self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectInt_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_SelectInt self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_SelectInt_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_SelectInt self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectInt_DecrementRefCounter(self, *args)

Handle_StepData_SelectInt_swigregister = _StepData.Handle_StepData_SelectInt_swigregister
Handle_StepData_SelectInt_swigregister(Handle_StepData_SelectInt)

def Handle_StepData_SelectInt_DownCast(thing):
    return _StepData.Handle_StepData_SelectInt_DownCast(thing)
Handle_StepData_SelectInt_DownCast = _StepData.Handle_StepData_SelectInt_DownCast

class Handle_StepData_ESDescr(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_ESDescr self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_ESDescr_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_ESDescr self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_ESDescr_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_ESDescr self, StepData_ESDescr thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_ESDescr_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_ESDescr self, Handle_StepData_ESDescr theHandle) -> Handle_StepData_ESDescr
        assign(Handle_StepData_ESDescr self, StepData_ESDescr thePtr) -> Handle_StepData_ESDescr
        assign(Handle_StepData_ESDescr self, Handle_StepData_ESDescr theHandle) -> Handle_StepData_ESDescr

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_ESDescr_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_ESDescr self) -> StepData_ESDescr

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_ESDescr_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_ESDescr self) -> StepData_ESDescr

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_ESDescr___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_ESDescr self) -> StepData_ESDescr

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_ESDescr___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_ESDescr___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_ESDescr___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_ESDescr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_ESDescr_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_ESDescr

    def SetNbFields(self, *args):
        """
        SetNbFields(Handle_StepData_ESDescr self, Standard_Integer const nb)

        Sets a new count of fields
        Each one is described by a PDescr

        :type nb: int

        """
        return _StepData.Handle_StepData_ESDescr_SetNbFields(self, *args)


    def SetField(self, *args):
        """
        SetField(Handle_StepData_ESDescr self, Standard_Integer const num, Standard_CString const name, Handle_StepData_PDescr descr)

        Sets a PDescr to describe a field
        A Field is designated by its rank and name

        :type num: int
        :type name: OCC.wrapper.Standard.Standard_CString
        :type descr: OCC.wrapper.StepData.Handle_StepData_PDescr

        """
        return _StepData.Handle_StepData_ESDescr_SetField(self, *args)


    def SetBase(self, *args):
        """
        SetBase(Handle_StepData_ESDescr self, Handle_StepData_ESDescr base)

        Sets an ESDescr as based on another one
        Hence, if there are inherited fields, the derived ESDescr
        cumulates all them, while the base just records its own ones

        :type base: OCC.wrapper.StepData.Handle_StepData_ESDescr

        """
        return _StepData.Handle_StepData_ESDescr_SetBase(self, *args)


    def SetSuper(self, *args):
        """
        SetSuper(Handle_StepData_ESDescr self, Handle_StepData_ESDescr super)

        Sets an ESDescr as "super-type". Applies an a base (non
        derived) ESDescr

        :type super: OCC.wrapper.StepData.Handle_StepData_ESDescr

        """
        return _StepData.Handle_StepData_ESDescr_SetSuper(self, *args)


    def TypeName(self, *args):
        """
        TypeName(Handle_StepData_ESDescr self) -> Standard_CString

        Returns the type name given at creation time

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_ESDescr_TypeName(self, *args)


    def StepType(self, *args):
        """
        Returns the type name as an AsciiString

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _StepData.Handle_StepData_ESDescr_StepType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Base(self, *args):
        """
        Base(Handle_StepData_ESDescr self) -> Handle_StepData_ESDescr

        Returns the basic ESDescr, null if <me> is not derived

        :rtype: OCC.wrapper.StepData.Handle_StepData_ESDescr

        """
        return _StepData.Handle_StepData_ESDescr_Base(self, *args)


    def Super(self, *args):
        """
        Super(Handle_StepData_ESDescr self) -> Handle_StepData_ESDescr

        Returns the super-type ESDescr, null if <me> is root

        :rtype: OCC.wrapper.StepData.Handle_StepData_ESDescr

        """
        return _StepData.Handle_StepData_ESDescr_Super(self, *args)


    def IsSub(self, *args):
        """
        IsSub(Handle_StepData_ESDescr self, Handle_StepData_ESDescr other) -> Standard_Boolean

        Tells if <me> is sub-type of (or equal to) another one

        :type other: OCC.wrapper.StepData.Handle_StepData_ESDescr
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_ESDescr_IsSub(self, *args)


    def NbFields(self, *args):
        """
        NbFields(Handle_StepData_ESDescr self) -> Standard_Integer

        Returns the count of fields

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_ESDescr_NbFields(self, *args)


    def Rank(self, *args):
        """
        Rank(Handle_StepData_ESDescr self, Standard_CString const name) -> Standard_Integer

        Returns the rank of a field from its name. 0 if unknown

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_ESDescr_Rank(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepData_ESDescr self, Standard_Integer const num) -> Standard_CString

        Returns the name of a field from its rank. empty if outofrange

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_ESDescr_Name(self, *args)


    def Field(self, *args):
        """
        Field(Handle_StepData_ESDescr self, Standard_Integer const num) -> Handle_StepData_PDescr

        Returns the PDescr for the field <num> (or Null)

        :type num: int
        :rtype: OCC.wrapper.StepData.Handle_StepData_PDescr

        """
        return _StepData.Handle_StepData_ESDescr_Field(self, *args)


    def NamedField(self, *args):
        """
        NamedField(Handle_StepData_ESDescr self, Standard_CString const name) -> Handle_StepData_PDescr

        Returns the PDescr for the field named <name> (or Null)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.StepData.Handle_StepData_PDescr

        """
        return _StepData.Handle_StepData_ESDescr_NamedField(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_StepData_ESDescr self, Standard_CString const steptype) -> Standard_Boolean

        Tells if a ESDescr matches a step type : exact or super type

        :type steptype: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_ESDescr_Matches(self, *args)


    def IsComplex(self, *args):
        """
        IsComplex(Handle_StepData_ESDescr self) -> Standard_Boolean

        Returns False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_ESDescr_IsComplex(self, *args)


    def NewEntity(self, *args):
        """
        NewEntity(Handle_StepData_ESDescr self) -> Handle_StepData_Described

        Creates a described entity (i.e. a simple one)

        :rtype: OCC.wrapper.StepData.Handle_StepData_Described

        """
        return _StepData.Handle_StepData_ESDescr_NewEntity(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_ESDescr self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_ESDescr_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_ESDescr_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_ESDescr_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepData_ESDescr self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_ESDescr_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_ESDescr self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_ESDescr self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_ESDescr_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_ESDescr self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_ESDescr self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_ESDescr_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_ESDescr self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_ESDescr_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_ESDescr self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_ESDescr_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_ESDescr self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_ESDescr_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_ESDescr self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_ESDescr_DecrementRefCounter(self, *args)

Handle_StepData_ESDescr_swigregister = _StepData.Handle_StepData_ESDescr_swigregister
Handle_StepData_ESDescr_swigregister(Handle_StepData_ESDescr)

def Handle_StepData_ESDescr_DownCast(thing):
    return _StepData.Handle_StepData_ESDescr_DownCast(thing)
Handle_StepData_ESDescr_DownCast = _StepData.Handle_StepData_ESDescr_DownCast

class Handle_StepData_DescrProtocol(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_DescrProtocol self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_DescrProtocol_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_DescrProtocol self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_DescrProtocol_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_DescrProtocol self, StepData_DescrProtocol thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_DescrProtocol_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_DescrProtocol self, Handle_StepData_DescrProtocol theHandle) -> Handle_StepData_DescrProtocol
        assign(Handle_StepData_DescrProtocol self, StepData_DescrProtocol thePtr) -> Handle_StepData_DescrProtocol
        assign(Handle_StepData_DescrProtocol self, Handle_StepData_DescrProtocol theHandle) -> Handle_StepData_DescrProtocol

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_DescrProtocol_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_DescrProtocol self) -> StepData_DescrProtocol

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_DescrProtocol_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_DescrProtocol self) -> StepData_DescrProtocol

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_DescrProtocol___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_DescrProtocol self) -> StepData_DescrProtocol

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_DescrProtocol___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_DescrProtocol___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_DescrProtocol___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_DescrProtocol(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_DescrProtocol_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_DescrProtocol

    def SetSchemaName(self, *args):
        """
        SetSchemaName(Handle_StepData_DescrProtocol self, Standard_CString const name)

        Defines a specific Schema Name for this Protocol

        :type name: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_DescrProtocol_SetSchemaName(self, *args)


    def LibRecord(self, *args):
        """
        LibRecord(Handle_StepData_DescrProtocol self)

        Records this Protocol in the service libraries, with a
        DescrGeneral and a DescrReadWrite
        Does nothing if the Protocol brings no proper description


        """
        return _StepData.Handle_StepData_DescrProtocol_LibRecord(self, *args)


    def SchemaName(self, *args):
        """
        SchemaName(Handle_StepData_DescrProtocol self) -> Standard_CString

        Returns the Schema Name attached to each class of Protocol
        here, returns the SchemaName set by SetSchemaName
        was C++ : return const

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_DescrProtocol_SchemaName(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_DescrProtocol self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_DescrProtocol_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_DescrProtocol_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_DescrProtocol_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Add(self, *args):
        """
        Add(Handle_StepData_DescrProtocol self, Handle_StepData_Protocol protocol)

        Adds a Protocol to the definition list of the FileProtocol
        But ensures that each class of Protocol is present only once
        in this list

        :type protocol: OCC.wrapper.StepData.Handle_StepData_Protocol

        """
        return _StepData.Handle_StepData_DescrProtocol_Add(self, *args)


    def NbResources(self, *args):
        """
        NbResources(Handle_StepData_DescrProtocol self) -> Standard_Integer

        Gives the count of Protocols used as Resource (can be zero)
        i.e. the count of Protocol recorded by calling the method Add

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_DescrProtocol_NbResources(self, *args)


    def Resource(self, *args):
        """
        Resource(Handle_StepData_DescrProtocol self, Standard_Integer const num) -> Handle_Interface_Protocol

        Returns a Resource, given a rank. Here, rank of calling Add

        :type num: int
        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _StepData.Handle_StepData_DescrProtocol_Resource(self, *args)


    def TypeNumber(self, *args):
        """
        TypeNumber(Handle_StepData_DescrProtocol self, Handle_Standard_Type atype) -> Standard_Integer

        Returns a Case Number, specific of each recognized Type
        Here, NO Type at all is recognized properly : all Types are
        recognized by the resources

        :type atype: OCC.wrapper.Standard.Handle_Standard_Type
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_DescrProtocol_TypeNumber(self, *args)


    def GlobalCheck(self, *args):
        """
        GlobalCheck(Handle_StepData_DescrProtocol self, Interface_Graph G, Handle_Interface_Check ach) -> Standard_Boolean

        Calls GlobalCheck for each of its recorded ressources

        :type G: OCC.wrapper.Interface.Interface_Graph
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_DescrProtocol_GlobalCheck(self, *args)


    def CaseNumber(self, *args):
        """
        CaseNumber(Handle_StepData_DescrProtocol self, Handle_Standard_Transient obj) -> Standard_Integer

        Returns a unique positive number for any recognized entity
        Redefined to work by calling both TypeNumber and, for a
        Described Entity (late binding) DescrNumber

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_DescrProtocol_CaseNumber(self, *args)


    def NewModel(self, *args):
        """
        NewModel(Handle_StepData_DescrProtocol self) -> Handle_Interface_InterfaceModel

        Creates an empty Model for Step Norm

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _StepData.Handle_StepData_DescrProtocol_NewModel(self, *args)


    def IsSuitableModel(self, *args):
        """
        IsSuitableModel(Handle_StepData_DescrProtocol self, Handle_Interface_InterfaceModel model) -> Standard_Boolean

        Returns True if <model> is a Model of Step Norm

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_DescrProtocol_IsSuitableModel(self, *args)


    def UnknownEntity(self, *args):
        """
        UnknownEntity(Handle_StepData_DescrProtocol self) -> Handle_Standard_Transient

        Creates a new Unknown Entity for Step (UndefinedEntity)

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepData.Handle_StepData_DescrProtocol_UnknownEntity(self, *args)


    def IsUnknownEntity(self, *args):
        """
        IsUnknownEntity(Handle_StepData_DescrProtocol self, Handle_Standard_Transient ent) -> Standard_Boolean

        Returns True if <ent> is an Unknown Entity for the Norm, i.e.
        Type UndefinedEntity, status Unknown

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_DescrProtocol_IsUnknownEntity(self, *args)


    def DescrNumber(self, *args):
        """
        DescrNumber(Handle_StepData_DescrProtocol self, Handle_StepData_EDescr adescr) -> Standard_Integer

        Returns a unique positive CaseNumber for types described by
        an EDescr (late binding)
        Warning : TypeNumber and DescrNumber must give together a unique
        positive case number for each distinct case, type or descr

        :type adescr: OCC.wrapper.StepData.Handle_StepData_EDescr
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_DescrProtocol_DescrNumber(self, *args)


    def AddDescr(self, *args):
        """
        AddDescr(Handle_StepData_DescrProtocol self, Handle_StepData_EDescr adescr, Standard_Integer const CN)

        Records an EDescr with its case number
        Also records its name for an ESDescr (simple type): an ESDescr
        is then used, for case number, or for type name

        :type adescr: OCC.wrapper.StepData.Handle_StepData_EDescr
        :type CN: int

        """
        return _StepData.Handle_StepData_DescrProtocol_AddDescr(self, *args)


    def HasDescr(self, *args):
        """
        HasDescr(Handle_StepData_DescrProtocol self) -> Standard_Boolean

        Tells if a Protocol brings at least one ESDescr, i.e. if it
        defines at least one entity description by ESDescr mechanism

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_DescrProtocol_HasDescr(self, *args)


    def Descr(self, *args):
        """
        Descr(Handle_StepData_DescrProtocol self, Standard_Integer const num) -> Handle_StepData_EDescr
        Descr(Handle_StepData_DescrProtocol self, Standard_CString const name, Standard_Boolean const anylevel) -> Handle_StepData_EDescr

        Returns a description according to its name
        <anylevel> True (D) : for <me> and its resources
        <anylevel> False : for <me> only

        :type name: OCC.wrapper.Standard.Standard_CString
        :type anylevel: bool
        :rtype: OCC.wrapper.StepData.Handle_StepData_EDescr

        """
        return _StepData.Handle_StepData_DescrProtocol_Descr(self, *args)


    def ESDescr(self, *args):
        """
        ESDescr(Handle_StepData_DescrProtocol self, Standard_CString const name, Standard_Boolean const anylevel) -> Handle_StepData_ESDescr

        Idem as Descr but cast to simple description

        :type name: OCC.wrapper.Standard.Standard_CString
        :type anylevel: bool
        :rtype: OCC.wrapper.StepData.Handle_StepData_ESDescr

        """
        return _StepData.Handle_StepData_DescrProtocol_ESDescr(self, *args)


    def ECDescr(self, *args):
        """
        ECDescr(Handle_StepData_DescrProtocol self, NCollection_Sequence_TCollection_AsciiString names, Standard_Boolean const anylevel) -> Handle_StepData_ECDescr

        Returns a complex description according to list of names
        <anylevel> True (D) : for <me> and its resources
        <anylevel> False : for <me> only

        :type names: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString
        :type anylevel: bool
        :rtype: OCC.wrapper.StepData.Handle_StepData_ECDescr

        """
        return _StepData.Handle_StepData_DescrProtocol_ECDescr(self, *args)


    def AddPDescr(self, *args):
        """
        AddPDescr(Handle_StepData_DescrProtocol self, Handle_StepData_PDescr pdescr)

        Records an PDescr

        :type pdescr: OCC.wrapper.StepData.Handle_StepData_PDescr

        """
        return _StepData.Handle_StepData_DescrProtocol_AddPDescr(self, *args)


    def PDescr(self, *args):
        """
        PDescr(Handle_StepData_DescrProtocol self, Standard_CString const name, Standard_Boolean const anylevel) -> Handle_StepData_PDescr

        Returns a parameter description according to its name
        <anylevel> True (D) : for <me> and its resources
        <anylevel> False : for <me> only

        :type name: OCC.wrapper.Standard.Standard_CString
        :type anylevel: bool
        :rtype: OCC.wrapper.StepData.Handle_StepData_PDescr

        """
        return _StepData.Handle_StepData_DescrProtocol_PDescr(self, *args)


    def AddBasicDescr(self, *args):
        """
        AddBasicDescr(Handle_StepData_DescrProtocol self, Handle_StepData_ESDescr esdescr)

        Records an ESDescr, intended to build complex descriptions

        :type esdescr: OCC.wrapper.StepData.Handle_StepData_ESDescr

        """
        return _StepData.Handle_StepData_DescrProtocol_AddBasicDescr(self, *args)


    def BasicDescr(self, *args):
        """
        BasicDescr(Handle_StepData_DescrProtocol self, Standard_CString const name, Standard_Boolean const anylevel) -> Handle_StepData_EDescr

        Returns a basic description according to its name
        <anylevel> True (D) : for <me> and its resources
        <anylevel> False : for <me> only

        :type name: OCC.wrapper.Standard.Standard_CString
        :type anylevel: bool
        :rtype: OCC.wrapper.StepData.Handle_StepData_EDescr

        """
        return _StepData.Handle_StepData_DescrProtocol_BasicDescr(self, *args)


    def Active(self, *args):
        """
        Active(Handle_StepData_DescrProtocol self) -> Handle_Interface_Protocol

        Returns the Active Protocol, if defined (else, returns a
        Null Handle, which means "no defined active protocol")

        :rtype: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _StepData.Handle_StepData_DescrProtocol_Active(self, *args)


    def SetActive(self, *args):
        """
        SetActive(Handle_StepData_DescrProtocol self, Handle_Interface_Protocol aprotocol)

        Sets a given Protocol to be the Active one (for the users of
        Active, see just above). Applies to every sub-type of Protocol

        :type aprotocol: OCC.wrapper.Interface.Handle_Interface_Protocol

        """
        return _StepData.Handle_StepData_DescrProtocol_SetActive(self, *args)


    def ClearActive(self, *args):
        """
        ClearActive(Handle_StepData_DescrProtocol self)

        Erases the Active Protocol (hence it becomes undefined)


        """
        return _StepData.Handle_StepData_DescrProtocol_ClearActive(self, *args)


    def IsDynamicType(self, *args):
        """
        IsDynamicType(Handle_StepData_DescrProtocol self, Handle_Standard_Transient obj) -> Standard_Boolean

        Returns True if type of <obj> is that defined from CDL
        This is the default but it may change according implementation

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_DescrProtocol_IsDynamicType(self, *args)


    def NbTypes(self, *args):
        """
        NbTypes(Handle_StepData_DescrProtocol self, Handle_Standard_Transient obj) -> Standard_Integer

        Returns the count of DISTINCT types under which an entity may
        be processed. Each one is candidate to be recognized by
        TypeNumber, <obj> is then processed according it
        By default, returns 1 (the DynamicType)

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_DescrProtocol_NbTypes(self, *args)


    def Type(self, *args):
        """
        Type(Handle_StepData_DescrProtocol self, Handle_Standard_Transient obj, Standard_Integer const nt=1) -> Handle_Standard_Type

        Returns a type under which <obj> can be recognized and
        processed, according its rank in its definition list (see
        NbTypes).
        By default, returns DynamicType

        :type obj: OCC.wrapper.Standard.Handle_Standard_Transient
        :type nt: int
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepData.Handle_StepData_DescrProtocol_Type(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepData_DescrProtocol self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_DescrProtocol_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_DescrProtocol self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_DescrProtocol self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_DescrProtocol_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_DescrProtocol self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_DescrProtocol self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_DescrProtocol_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_DescrProtocol self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_DescrProtocol_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_DescrProtocol self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_DescrProtocol_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_DescrProtocol self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_DescrProtocol_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_DescrProtocol self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_DescrProtocol_DecrementRefCounter(self, *args)

Handle_StepData_DescrProtocol_swigregister = _StepData.Handle_StepData_DescrProtocol_swigregister
Handle_StepData_DescrProtocol_swigregister(Handle_StepData_DescrProtocol)

def Handle_StepData_DescrProtocol_DownCast(thing):
    return _StepData.Handle_StepData_DescrProtocol_DownCast(thing)
Handle_StepData_DescrProtocol_DownCast = _StepData.Handle_StepData_DescrProtocol_DownCast

class Handle_StepData_SelectMember(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepData_SelectMember self)

        Nullify the handle


        """
        return _StepData.Handle_StepData_SelectMember_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepData_SelectMember self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepData.Handle_StepData_SelectMember_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepData_SelectMember self, StepData_SelectMember thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepData.Handle_StepData_SelectMember_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepData_SelectMember self, Handle_StepData_SelectMember theHandle) -> Handle_StepData_SelectMember
        assign(Handle_StepData_SelectMember self, StepData_SelectMember thePtr) -> Handle_StepData_SelectMember
        assign(Handle_StepData_SelectMember self, Handle_StepData_SelectMember theHandle) -> Handle_StepData_SelectMember

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepData.Handle_StepData_SelectMember_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepData_SelectMember self) -> StepData_SelectMember

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepData.Handle_StepData_SelectMember_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepData_SelectMember self) -> StepData_SelectMember

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepData.Handle_StepData_SelectMember___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepData_SelectMember self) -> StepData_SelectMember

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepData.Handle_StepData_SelectMember___ref__(self, *args)


    def __hash__(self):
        return _StepData.Handle_StepData_SelectMember___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepData.Handle_StepData_SelectMember___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepData.new_Handle_StepData_SelectMember(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepData.Handle_StepData_SelectMember_DownCast)
    __swig_destroy__ = _StepData.delete_Handle_StepData_SelectMember

    def HasName(self, *args):
        """
        HasName(Handle_StepData_SelectMember self) -> Standard_Boolean

        Tells if a SelectMember has a name. Default is False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectMember_HasName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepData_SelectMember self) -> Standard_CString

        Returns the name of a SelectMember. Default is empty

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectMember_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepData_SelectMember self, Standard_CString const name) -> Standard_Boolean

        Sets the name of a SelectMember, returns True if done, False
        if no name is allowed
        Default does nothing and returns False

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectMember_SetName(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_StepData_SelectMember self, Standard_CString const name) -> Standard_Boolean

        Tells if the name of a SelectMember matches a given one
        By default, compares the strings, can be redefined (optimised)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectMember_Matches(self, *args)


    def Kind(self, *args):
        """
        Kind(Handle_StepData_SelectMember self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectMember_Kind(self, *args)


    def SetKind(self, *args):
        """
        SetKind(Handle_StepData_SelectMember self, Standard_Integer const kind)

        :type kind: int

        """
        return _StepData.Handle_StepData_SelectMember_SetKind(self, *args)


    def ParamType(self, *args):
        """
        ParamType(Handle_StepData_SelectMember self) -> Interface_ParamType

        Returns the Kind of the SelectMember, under the form of an
        enum ParamType

        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _StepData.Handle_StepData_SelectMember_ParamType(self, *args)


    def Int(self, *args):
        """
        Int(Handle_StepData_SelectMember self) -> Standard_Integer

        This internal method gives access to a value implemented by an
        Integer (to read it)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectMember_Int(self, *args)


    def SetInt(self, *args):
        """
        SetInt(Handle_StepData_SelectMember self, Standard_Integer const val)

        This internal method gives access to a value implemented by an
        Integer (to set it)

        :type val: int

        """
        return _StepData.Handle_StepData_SelectMember_SetInt(self, *args)


    def Integer(self, *args):
        """
        Integer(Handle_StepData_SelectMember self) -> Standard_Integer

        Gets the value as an Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectMember_Integer(self, *args)


    def SetInteger(self, *args):
        """
        SetInteger(Handle_StepData_SelectMember self, Standard_Integer const val)

        :type val: int

        """
        return _StepData.Handle_StepData_SelectMember_SetInteger(self, *args)


    def Boolean(self, *args):
        """
        Boolean(Handle_StepData_SelectMember self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectMember_Boolean(self, *args)


    def SetBoolean(self, *args):
        """
        SetBoolean(Handle_StepData_SelectMember self, Standard_Boolean const val)

        :type val: bool

        """
        return _StepData.Handle_StepData_SelectMember_SetBoolean(self, *args)


    def Logical(self, *args):
        """
        Logical(Handle_StepData_SelectMember self) -> StepData_Logical

        :rtype: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepData.Handle_StepData_SelectMember_Logical(self, *args)


    def SetLogical(self, *args):
        """
        SetLogical(Handle_StepData_SelectMember self, StepData_Logical const val)

        :type val: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepData.Handle_StepData_SelectMember_SetLogical(self, *args)


    def Real(self, *args):
        """
        Real(Handle_StepData_SelectMember self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepData.Handle_StepData_SelectMember_Real(self, *args)


    def SetReal(self, *args):
        """
        SetReal(Handle_StepData_SelectMember self, Standard_Real const val)

        :type val: float

        """
        return _StepData.Handle_StepData_SelectMember_SetReal(self, *args)


    def String(self, *args):
        """
        String(Handle_StepData_SelectMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectMember_String(self, *args)


    def SetString(self, *args):
        """
        SetString(Handle_StepData_SelectMember self, Standard_CString const val)

        :type val: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectMember_SetString(self, *args)


    def Enum(self, *args):
        """
        Enum(Handle_StepData_SelectMember self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectMember_Enum(self, *args)


    def EnumText(self, *args):
        """
        EnumText(Handle_StepData_SelectMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectMember_EnumText(self, *args)


    def SetEnum(self, *args):
        """
        SetEnum(Handle_StepData_SelectMember self, Standard_Integer const val, Standard_CString const text)

        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectMember_SetEnum(self, *args)


    def SetEnumText(self, *args):
        """
        SetEnumText(Handle_StepData_SelectMember self, Standard_Integer const val, Standard_CString const text)

        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepData.Handle_StepData_SelectMember_SetEnumText(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepData_SelectMember self) -> char const *

        :rtype: const char *

        """
        return _StepData.Handle_StepData_SelectMember_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_SelectMember_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepData.Handle_StepData_SelectMember_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepData_SelectMember self)

        Memory deallocator for transient classes


        """
        return _StepData.Handle_StepData_SelectMember_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepData_SelectMember self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepData_SelectMember self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectMember_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepData_SelectMember self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepData_SelectMember self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepData.Handle_StepData_SelectMember_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepData_SelectMember self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepData.Handle_StepData_SelectMember_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepData_SelectMember self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectMember_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepData_SelectMember self)

        Increments the reference counter of this object


        """
        return _StepData.Handle_StepData_SelectMember_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepData_SelectMember self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepData.Handle_StepData_SelectMember_DecrementRefCounter(self, *args)

Handle_StepData_SelectMember_swigregister = _StepData.Handle_StepData_SelectMember_swigregister
Handle_StepData_SelectMember_swigregister(Handle_StepData_SelectMember)

def Handle_StepData_SelectMember_DownCast(thing):
    return _StepData.Handle_StepData_SelectMember_DownCast(thing)
Handle_StepData_SelectMember_DownCast = _StepData.Handle_StepData_SelectMember_DownCast




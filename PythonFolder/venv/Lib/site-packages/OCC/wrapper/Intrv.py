# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Intrv')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Intrv')
    _Intrv = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Intrv', [dirname(__file__)])
        except ImportError:
            import _Intrv
            return _Intrv
        try:
            _mod = imp.load_module('_Intrv', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Intrv = swig_import_helper()
    del swig_import_helper
else:
    import _Intrv
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Intrv.delete_SwigPyIterator

    def value(self):
        return _Intrv.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Intrv.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Intrv.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Intrv.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Intrv.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Intrv.SwigPyIterator_copy(self)

    def next(self):
        return _Intrv.SwigPyIterator_next(self)

    def __next__(self):
        return _Intrv.SwigPyIterator___next__(self)

    def previous(self):
        return _Intrv.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Intrv.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Intrv.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Intrv.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Intrv.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Intrv.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Intrv.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Intrv.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Intrv.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Intrv.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Intrv.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Intrv.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Intrv.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Intrv.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Intrv.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Intrv.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Intrv.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Intrv.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Intrv.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Intrv.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Intrv.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Intrv.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Intrv.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Intrv.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Intrv.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Intrv.ptr_to_number(item)
ptr_to_number = _Intrv.ptr_to_number

def HashCode(*args):
    return _Intrv.HashCode(*args)
HashCode = _Intrv.HashCode

def ptr_equal(a, b):
    return _Intrv.ptr_equal(a, b)
ptr_equal = _Intrv.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
Intrv_Before = _Intrv.Intrv_Before
Intrv_JustBefore = _Intrv.Intrv_JustBefore
Intrv_OverlappingAtStart = _Intrv.Intrv_OverlappingAtStart
Intrv_JustEnclosingAtEnd = _Intrv.Intrv_JustEnclosingAtEnd
Intrv_Enclosing = _Intrv.Intrv_Enclosing
Intrv_JustOverlappingAtStart = _Intrv.Intrv_JustOverlappingAtStart
Intrv_Similar = _Intrv.Intrv_Similar
Intrv_JustEnclosingAtStart = _Intrv.Intrv_JustEnclosingAtStart
Intrv_Inside = _Intrv.Intrv_Inside
Intrv_JustOverlappingAtEnd = _Intrv.Intrv_JustOverlappingAtEnd
Intrv_OverlappingAtEnd = _Intrv.Intrv_OverlappingAtEnd
Intrv_JustAfter = _Intrv.Intrv_JustAfter
Intrv_After = _Intrv.Intrv_After
class Intrv_Interval(object):
    """
    **-----------****             Other
    ***---*                                   IsBefore
    ***----------*                            IsJustBefore
    ***---------------*                       IsOverlappingAtStart
    ***------------------------*              IsJustEnclosingAtEnd
    ***-----------------------------------*   IsEnclosing
    ***----*                       IsJustOverlappingAtStart
    ***-------------*              IsSimilar
    ***------------------------*   IsJustEnclosingAtStart
    ***-*                   IsInside
    ***------*              IsJustOverlappingAtEnd
    ***-----------------*   IsOverlappingAtEnd
    ***--------*   IsJustAfter
    ***---*   IsAfter
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Intrv_Interval self) -> Intrv_Interval
        __init__(Intrv_Interval self, Standard_Real const Start, Standard_Real const End) -> Intrv_Interval
        __init__(Intrv_Interval self, Standard_Real const Start, Standard_ShortReal const TolStart, Standard_Real const End, Standard_ShortReal const TolEnd) -> Intrv_Interval

        :type Start: float
        :type TolStart: float
        :type End: float
        :type TolEnd: float

        """
        this = _Intrv.new_Intrv_Interval(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Start(self, *args):
        """
        Start(Intrv_Interval self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Intrv.Intrv_Interval_Start(self, *args)


    def End(self, *args):
        """
        End(Intrv_Interval self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Intrv.Intrv_Interval_End(self, *args)


    def TolStart(self, *args):
        """
        TolStart(Intrv_Interval self) -> Standard_ShortReal

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _Intrv.Intrv_Interval_TolStart(self, *args)


    def TolEnd(self, *args):
        """
        TolEnd(Intrv_Interval self) -> Standard_ShortReal

        :rtype: OCC.wrapper.Standard.Standard_ShortReal

        """
        return _Intrv.Intrv_Interval_TolEnd(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Intrv_Interval self)

        :type Start: float
        :type TolStart: float
        :type End: float
        :type TolEnd: float

        """
        return _Intrv.Intrv_Interval_Bounds(self, *args)


    def SetStart(self, *args):
        """
        SetStart(Intrv_Interval self, Standard_Real const Start, Standard_ShortReal const TolStart)

        :type Start: float
        :type TolStart: float

        """
        return _Intrv.Intrv_Interval_SetStart(self, *args)


    def FuseAtStart(self, *args):
        """
        FuseAtStart(Intrv_Interval self, Standard_Real const Start, Standard_ShortReal const TolStart)

        ****+****-------------------->      Old one
        ****+****------------------------>      New one to fuse
        <<<     <<<
        ****+****------------------------>      result

        :type Start: float
        :type TolStart: float

        """
        return _Intrv.Intrv_Interval_FuseAtStart(self, *args)


    def CutAtStart(self, *args):
        """
        CutAtStart(Intrv_Interval self, Standard_Real const Start, Standard_ShortReal const TolStart)

        ****+****----------->      Old one
        <----------**+**                        Tool for cutting
        >>>     >>>
        ****+****----------->      result

        :type Start: float
        :type TolStart: float

        """
        return _Intrv.Intrv_Interval_CutAtStart(self, *args)


    def SetEnd(self, *args):
        """
        SetEnd(Intrv_Interval self, Standard_Real const End, Standard_ShortReal const TolEnd)

        :type End: float
        :type TolEnd: float

        """
        return _Intrv.Intrv_Interval_SetEnd(self, *args)


    def FuseAtEnd(self, *args):
        """
        FuseAtEnd(Intrv_Interval self, Standard_Real const End, Standard_ShortReal const TolEnd)

        <---------------------****+****      Old one
        <-----------------**+**              New one to fuse
        >>>     >>>
        <---------------------****+****      result

        :type End: float
        :type TolEnd: float

        """
        return _Intrv.Intrv_Interval_FuseAtEnd(self, *args)


    def CutAtEnd(self, *args):
        """
        CutAtEnd(Intrv_Interval self, Standard_Real const End, Standard_ShortReal const TolEnd)

        <-----****+****                      Old one
        **+**------>             Tool for cutting
        <<<     <<<
        <-----****+****                      result

        :type End: float
        :type TolEnd: float

        """
        return _Intrv.Intrv_Interval_CutAtEnd(self, *args)


    def IsProbablyEmpty(self, *args):
        """
        IsProbablyEmpty(Intrv_Interval self) -> Standard_Boolean

        True if myStart+myTolStart > myEnd-myTolEnd
        or if myEnd+myTolEnd > myStart-myTolStart

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intrv.Intrv_Interval_IsProbablyEmpty(self, *args)


    def Position(self, *args):
        """
        Position(Intrv_Interval self, Intrv_Interval Other) -> Intrv_Position

        True if me is Before Other
        **-----------****             Other
        ***-----*                                   Before
        ***------------*                            JustBefore
        ***-----------------*                       OverlappingAtStart
        ***--------------------------*              JustEnclosingAtEnd
        ***-------------------------------------*   Enclosing
        ***----*                       JustOverlappingAtStart
        ***-------------*              Similar
        ***------------------------*   JustEnclosingAtStart
        ***-*                   Inside
        ***------*              JustOverlappingAtEnd
        ***-----------------*   OverlappingAtEnd
        ***--------*   JustAfter
        ***---*   After

        :type Other: OCC.wrapper.Intrv.Intrv_Interval
        :rtype: OCC.wrapper.Intrv.Intrv_Position

        """
        return _Intrv.Intrv_Interval_Position(self, *args)


    def IsBefore(self, *args):
        """
        IsBefore(Intrv_Interval self, Intrv_Interval Other) -> Standard_Boolean

        True if me is Before Other
        ***----------------**                              me
        **-----------****          Other

        :type Other: OCC.wrapper.Intrv.Intrv_Interval
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intrv.Intrv_Interval_IsBefore(self, *args)


    def IsAfter(self, *args):
        """
        IsAfter(Intrv_Interval self, Intrv_Interval Other) -> Standard_Boolean

        True if me is After Other
        **-----------****          me
        ***----------------**                              Other

        :type Other: OCC.wrapper.Intrv.Intrv_Interval
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intrv.Intrv_Interval_IsAfter(self, *args)


    def IsInside(self, *args):
        """
        IsInside(Intrv_Interval self, Intrv_Interval Other) -> Standard_Boolean

        True if me is Inside Other
        **-----------****                          me
        ***--------------------------**                    Other

        :type Other: OCC.wrapper.Intrv.Intrv_Interval
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intrv.Intrv_Interval_IsInside(self, *args)


    def IsEnclosing(self, *args):
        """
        IsEnclosing(Intrv_Interval self, Intrv_Interval Other) -> Standard_Boolean

        True if me is Enclosing Other
        ***----------------------------****                  me
        ***------------------**                        Other

        :type Other: OCC.wrapper.Intrv.Intrv_Interval
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intrv.Intrv_Interval_IsEnclosing(self, *args)


    def IsJustEnclosingAtStart(self, *args):
        """
        IsJustEnclosingAtStart(Intrv_Interval self, Intrv_Interval Other) -> Standard_Boolean

        True if me is just Enclosing Other at start
        ***---------------------------****            me
        ***------------------**                        Other

        :type Other: OCC.wrapper.Intrv.Intrv_Interval
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intrv.Intrv_Interval_IsJustEnclosingAtStart(self, *args)


    def IsJustEnclosingAtEnd(self, *args):
        """
        IsJustEnclosingAtEnd(Intrv_Interval self, Intrv_Interval Other) -> Standard_Boolean

        True if me is just Enclosing Other at End
        ***----------------------------****                  me
        ***-----------------****                   Other

        :type Other: OCC.wrapper.Intrv.Intrv_Interval
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intrv.Intrv_Interval_IsJustEnclosingAtEnd(self, *args)


    def IsJustBefore(self, *args):
        """
        IsJustBefore(Intrv_Interval self, Intrv_Interval Other) -> Standard_Boolean

        True if me is just before Other
        ***--------****                                      me
        ***-----------**                        Other

        :type Other: OCC.wrapper.Intrv.Intrv_Interval
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intrv.Intrv_Interval_IsJustBefore(self, *args)


    def IsJustAfter(self, *args):
        """
        IsJustAfter(Intrv_Interval self, Intrv_Interval Other) -> Standard_Boolean

        True if me is just after Other
        ****-------****                         me
        ***-----------**                                     Other

        :type Other: OCC.wrapper.Intrv.Intrv_Interval
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intrv.Intrv_Interval_IsJustAfter(self, *args)


    def IsOverlappingAtStart(self, *args):
        """
        IsOverlappingAtStart(Intrv_Interval self, Intrv_Interval Other) -> Standard_Boolean

        True if me is overlapping Other at start
        ***---------------***                                me
        ***-----------**                        Other

        :type Other: OCC.wrapper.Intrv.Intrv_Interval
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intrv.Intrv_Interval_IsOverlappingAtStart(self, *args)


    def IsOverlappingAtEnd(self, *args):
        """
        IsOverlappingAtEnd(Intrv_Interval self, Intrv_Interval Other) -> Standard_Boolean

        True if me is overlapping Other at end
        ***-----------**                        me
        ***---------------***                                Other

        :type Other: OCC.wrapper.Intrv.Intrv_Interval
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intrv.Intrv_Interval_IsOverlappingAtEnd(self, *args)


    def IsJustOverlappingAtStart(self, *args):
        """
        IsJustOverlappingAtStart(Intrv_Interval self, Intrv_Interval Other) -> Standard_Boolean

        True if me is just overlapping Other at start
        ***-----------***                                    me
        ***------------------------**                        Other

        :type Other: OCC.wrapper.Intrv.Intrv_Interval
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intrv.Intrv_Interval_IsJustOverlappingAtStart(self, *args)


    def IsJustOverlappingAtEnd(self, *args):
        """
        IsJustOverlappingAtEnd(Intrv_Interval self, Intrv_Interval Other) -> Standard_Boolean

        True if me is just overlapping Other at end
        ***-----------*                         me
        ***------------------------**                        Other

        :type Other: OCC.wrapper.Intrv.Intrv_Interval
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intrv.Intrv_Interval_IsJustOverlappingAtEnd(self, *args)


    def IsSimilar(self, *args):
        """
        IsSimilar(Intrv_Interval self, Intrv_Interval Other) -> Standard_Boolean

        True if me and Other have the same bounds
        *----------------***                                me
        ***-----------------**                               Other

        :type Other: OCC.wrapper.Intrv.Intrv_Interval
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intrv.Intrv_Interval_IsSimilar(self, *args)

    __swig_destroy__ = _Intrv.delete_Intrv_Interval
Intrv_Interval_swigregister = _Intrv.Intrv_Interval_swigregister
Intrv_Interval_swigregister(Intrv_Interval)

class Intrv_Intervals(object):
    """
    The class  Intervals is a  sorted  sequence of non
    overlapping  Real Intervals.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Intrv_Intervals self) -> Intrv_Intervals
        __init__(Intrv_Intervals self, Intrv_Interval Int) -> Intrv_Intervals
        __init__(Intrv_Intervals self, Intrv_Intervals Int) -> Intrv_Intervals

        Creates   by   copying  an   existing  sequence of
        intervals.

        :type Int: OCC.wrapper.Intrv.Intrv_Intervals

        """
        this = _Intrv.new_Intrv_Intervals(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Intersect(self, *args):
        """
        Intersect(Intrv_Intervals self, Intrv_Interval Tool)
        Intersect(Intrv_Intervals self, Intrv_Intervals Tool)

        Intersects the intervals with the intervals in the
        sequence  <Tool>.

        :type Tool: OCC.wrapper.Intrv.Intrv_Intervals

        """
        return _Intrv.Intrv_Intervals_Intersect(self, *args)


    def Subtract(self, *args):
        """
        Subtract(Intrv_Intervals self, Intrv_Interval Tool)
        Subtract(Intrv_Intervals self, Intrv_Intervals Tool)

        :type Tool: OCC.wrapper.Intrv.Intrv_Intervals

        """
        return _Intrv.Intrv_Intervals_Subtract(self, *args)


    def Unite(self, *args):
        """
        Unite(Intrv_Intervals self, Intrv_Interval Tool)
        Unite(Intrv_Intervals self, Intrv_Intervals Tool)

        :type Tool: OCC.wrapper.Intrv.Intrv_Intervals

        """
        return _Intrv.Intrv_Intervals_Unite(self, *args)


    def XUnite(self, *args):
        """
        XUnite(Intrv_Intervals self, Intrv_Interval Tool)
        XUnite(Intrv_Intervals self, Intrv_Intervals Tool)

        :type Tool: OCC.wrapper.Intrv.Intrv_Intervals

        """
        return _Intrv.Intrv_Intervals_XUnite(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Intrv_Intervals self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intrv.Intrv_Intervals_NbIntervals(self, *args)


    def Value(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.Intrv.Intrv_Interval

        """
        res = _Intrv.Intrv_Intervals_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Intrv.delete_Intrv_Intervals
Intrv_Intervals_swigregister = _Intrv.Intrv_Intervals_swigregister
Intrv_Intervals_swigregister(Intrv_Intervals)

class NCollection_Sequence_Intrv_Interval(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Intrv_Interval self) -> NCollection_Sequence< Intrv_Interval >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Intrv.NCollection_Sequence_Intrv_Interval_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Intrv_Interval self) -> NCollection_Sequence< Intrv_Interval >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Intrv.NCollection_Sequence_Intrv_Interval_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Intrv_Interval self) -> NCollection_Sequence< Intrv_Interval >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Intrv.NCollection_Sequence_Intrv_Interval_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Intrv_Interval self) -> NCollection_Sequence< Intrv_Interval >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Intrv.NCollection_Sequence_Intrv_Interval_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Intrv.new_NCollection_Sequence_Intrv_Interval(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Intrv_Interval self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intrv.NCollection_Sequence_Intrv_Interval_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Intrv_Interval self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intrv.NCollection_Sequence_Intrv_Interval_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Intrv_Interval self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intrv.NCollection_Sequence_Intrv_Interval_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Intrv_Interval self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intrv.NCollection_Sequence_Intrv_Interval_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Intrv_Interval self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intrv.NCollection_Sequence_Intrv_Interval_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Intrv_Interval self)

        Reverse sequence


        """
        return _Intrv.NCollection_Sequence_Intrv_Interval_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Intrv_Interval self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Intrv.NCollection_Sequence_Intrv_Interval_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Intrv.NCollection_Sequence_Intrv_Interval_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Intrv_Interval self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Intrv.NCollection_Sequence_Intrv_Interval_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Intrv_Interval self, NCollection_Sequence_Intrv_Interval theOther) -> NCollection_Sequence_Intrv_Interval

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Intrv.NCollection_Sequence_Intrv_Interval_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Intrv_Interval self, NCollection_Sequence_Intrv_Interval theOther) -> NCollection_Sequence_Intrv_Interval

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Intrv.NCollection_Sequence_Intrv_Interval_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Intrv_Interval self, NCollection_Sequence< Intrv_Interval >::Iterator & thePosition)
        Remove(NCollection_Sequence_Intrv_Interval self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Intrv_Interval self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Intrv.NCollection_Sequence_Intrv_Interval_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Intrv_Interval self, Intrv_Interval theItem)
        Append(NCollection_Sequence_Intrv_Interval self, NCollection_Sequence_Intrv_Interval theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Intrv.NCollection_Sequence_Intrv_Interval_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Intrv_Interval self, Intrv_Interval theItem)
        Prepend(NCollection_Sequence_Intrv_Interval self, NCollection_Sequence_Intrv_Interval theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Intrv.NCollection_Sequence_Intrv_Interval_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Intrv_Interval self, Standard_Integer const theIndex, Intrv_Interval theItem)
        InsertBefore(NCollection_Sequence_Intrv_Interval self, Standard_Integer const theIndex, NCollection_Sequence_Intrv_Interval theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Intrv.NCollection_Sequence_Intrv_Interval_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Intrv_Interval self, NCollection_Sequence< Intrv_Interval >::Iterator & thePosition, Intrv_Interval theItem)
        InsertAfter(NCollection_Sequence_Intrv_Interval self, Standard_Integer const theIndex, NCollection_Sequence_Intrv_Interval theSeq)
        InsertAfter(NCollection_Sequence_Intrv_Interval self, Standard_Integer const theIndex, Intrv_Interval theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Intrv.NCollection_Sequence_Intrv_Interval_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Intrv_Interval self, Standard_Integer const theIndex, NCollection_Sequence_Intrv_Interval theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Intrv.NCollection_Sequence_Intrv_Interval_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Intrv.NCollection_Sequence_Intrv_Interval_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Intrv_Interval self) -> Intrv_Interval

        First item access

        :rtype: TheItemType &

        """
        return _Intrv.NCollection_Sequence_Intrv_Interval_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Intrv.NCollection_Sequence_Intrv_Interval_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Intrv_Interval self) -> Intrv_Interval

        Last item access

        :rtype: TheItemType &

        """
        return _Intrv.NCollection_Sequence_Intrv_Interval_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Intrv.NCollection_Sequence_Intrv_Interval_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Intrv_Interval self, Standard_Integer const theIndex) -> Intrv_Interval

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Intrv.NCollection_Sequence_Intrv_Interval_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Intrv.NCollection_Sequence_Intrv_Interval___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Intrv_Interval self, Standard_Integer const theIndex, Intrv_Interval theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Intrv.NCollection_Sequence_Intrv_Interval_SetValue(self, *args)


    def __iter__(self):
        return _Intrv.NCollection_Sequence_Intrv_Interval___iter__(self)
    __swig_destroy__ = _Intrv.delete_NCollection_Sequence_Intrv_Interval
NCollection_Sequence_Intrv_Interval_swigregister = _Intrv.NCollection_Sequence_Intrv_Interval_swigregister
NCollection_Sequence_Intrv_Interval_swigregister(NCollection_Sequence_Intrv_Interval)

def NCollection_Sequence_Intrv_Interval_delNode(*args):
    """
    NCollection_Sequence_Intrv_Interval_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Intrv.NCollection_Sequence_Intrv_Interval_delNode(*args)

class NCollection_Sequence_Intrv_Interval_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Intrv.new_NCollection_Sequence_Intrv_Interval_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Intrv.delete_NCollection_Sequence_Intrv_Interval_IteratorHelper

    def __next__(self):
        return _Intrv.NCollection_Sequence_Intrv_Interval_IteratorHelper___next__(self)
NCollection_Sequence_Intrv_Interval_IteratorHelper_swigregister = _Intrv.NCollection_Sequence_Intrv_Interval_IteratorHelper_swigregister
NCollection_Sequence_Intrv_Interval_IteratorHelper_swigregister(NCollection_Sequence_Intrv_Interval_IteratorHelper)


try:
	Intrv_SequenceOfInterval = NCollection_Sequence_Intrv_Interval
except NameError:
	pass # does not exist, probably ignored




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_ExprIntrp')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_ExprIntrp')
    _ExprIntrp = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ExprIntrp', [dirname(__file__)])
        except ImportError:
            import _ExprIntrp
            return _ExprIntrp
        try:
            _mod = imp.load_module('_ExprIntrp', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _ExprIntrp = swig_import_helper()
    del swig_import_helper
else:
    import _ExprIntrp
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ExprIntrp.delete_SwigPyIterator

    def value(self):
        return _ExprIntrp.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _ExprIntrp.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _ExprIntrp.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _ExprIntrp.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _ExprIntrp.SwigPyIterator_equal(self, x)

    def copy(self):
        return _ExprIntrp.SwigPyIterator_copy(self)

    def next(self):
        return _ExprIntrp.SwigPyIterator_next(self)

    def __next__(self):
        return _ExprIntrp.SwigPyIterator___next__(self)

    def previous(self):
        return _ExprIntrp.SwigPyIterator_previous(self)

    def advance(self, n):
        return _ExprIntrp.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _ExprIntrp.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _ExprIntrp.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _ExprIntrp.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _ExprIntrp.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _ExprIntrp.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _ExprIntrp.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _ExprIntrp.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _ExprIntrp.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_ExprIntrp.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _ExprIntrp.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _ExprIntrp.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ExprIntrp.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _ExprIntrp.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _ExprIntrp.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _ExprIntrp.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _ExprIntrp.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_ExprIntrp.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _ExprIntrp.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _ExprIntrp.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ExprIntrp.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _ExprIntrp.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _ExprIntrp.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _ExprIntrp.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _ExprIntrp.ptr_to_number(item)
ptr_to_number = _ExprIntrp.ptr_to_number

def HashCode(*args):
    return _ExprIntrp.HashCode(*args)
HashCode = _ExprIntrp.HashCode

def ptr_equal(a, b):
    return _ExprIntrp.ptr_equal(a, b)
ptr_equal = _ExprIntrp.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Expr
else:
    import Expr
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
class ExprIntrp_Generator(Standard.Standard_Transient):
    """
    Implements general services for interpretation of
    expressions.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ExprIntrp_Generator
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ExprIntrp_Generator(self) 
            return h


    def Use(self, *args):
        """
        Use(ExprIntrp_Generator self, Handle_Expr_NamedFunction func)
        Use(ExprIntrp_Generator self, Handle_Expr_NamedExpression named)

        :type named: OCC.wrapper.Expr.Handle_Expr_NamedExpression

        """
        return _ExprIntrp.ExprIntrp_Generator_Use(self, *args)


    def GetFunctions(self, *args):
        """
        :rtype: OCC.wrapper.ExprIntrp.ExprIntrp_SequenceOfNamedFunction

        """
        res = _ExprIntrp.ExprIntrp_Generator_GetFunctions(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetNamed(self, *args):
        """
        :rtype: OCC.wrapper.ExprIntrp.ExprIntrp_SequenceOfNamedExpression

        """
        res = _ExprIntrp.ExprIntrp_Generator_GetNamed(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetFunction(self, *args):
        """
        GetFunction(ExprIntrp_Generator self, TCollection_AsciiString name) -> Handle_Expr_NamedFunction

        Returns NamedFunction with name <name> already
        interpreted if it exists. Returns a null handle if
        not.

        :type name: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Expr.Handle_Expr_NamedFunction

        """
        return _ExprIntrp.ExprIntrp_Generator_GetFunction(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ExprIntrp.ExprIntrp_Generator_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ExprIntrp.ExprIntrp_Generator_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ExprIntrp.ExprIntrp_Generator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ExprIntrp.delete_ExprIntrp_Generator
ExprIntrp_Generator_swigregister = _ExprIntrp.ExprIntrp_Generator_swigregister
ExprIntrp_Generator_swigregister(ExprIntrp_Generator)

def ExprIntrp_Generator_get_type_name(*args):
    """
    ExprIntrp_Generator_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ExprIntrp.ExprIntrp_Generator_get_type_name(*args)

def ExprIntrp_Generator_get_type_descriptor(*args):
    """
    ExprIntrp_Generator_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ExprIntrp.ExprIntrp_Generator_get_type_descriptor(*args)

class ExprIntrp_GenExp(ExprIntrp_Generator):
    """
    This class permits, from a string, to create any
    kind of expression of package Expr by using
    built-in functions such as Sin,Cos, etc, and by
    creating variables.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ExprIntrp_GenExp
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ExprIntrp_GenExp(self) 
            return h


    def Create(*args):
        """
        Create() -> Handle_ExprIntrp_GenExp

        :rtype: OCC.wrapper.ExprIntrp.Handle_ExprIntrp_GenExp

        """
        return _ExprIntrp.ExprIntrp_GenExp_Create(*args)

    Create = staticmethod(Create)

    def Process(self, *args):
        """
        Process(ExprIntrp_GenExp self, TCollection_AsciiString str)

        Processes given string.

        :type str: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _ExprIntrp.ExprIntrp_GenExp_Process(self, *args)


    def IsDone(self, *args):
        """
        IsDone(ExprIntrp_GenExp self) -> Standard_Boolean

        Returns false if any syntax error has occurred during
        process.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ExprIntrp.ExprIntrp_GenExp_IsDone(self, *args)


    def Expression(self, *args):
        """
        Expression(ExprIntrp_GenExp self) -> Handle_Expr_GeneralExpression

        Returns expression generated. Raises an exception if
        IsDone answers false.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _ExprIntrp.ExprIntrp_GenExp_Expression(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ExprIntrp.ExprIntrp_GenExp_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ExprIntrp.ExprIntrp_GenExp_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ExprIntrp.ExprIntrp_GenExp_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ExprIntrp.delete_ExprIntrp_GenExp
ExprIntrp_GenExp_swigregister = _ExprIntrp.ExprIntrp_GenExp_swigregister
ExprIntrp_GenExp_swigregister(ExprIntrp_GenExp)

def ExprIntrp_GenExp_Create(*args):
    """
    ExprIntrp_GenExp_Create() -> Handle_ExprIntrp_GenExp

    :rtype: OCC.wrapper.ExprIntrp.Handle_ExprIntrp_GenExp

    """
    return _ExprIntrp.ExprIntrp_GenExp_Create(*args)

def ExprIntrp_GenExp_get_type_name(*args):
    """
    ExprIntrp_GenExp_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ExprIntrp.ExprIntrp_GenExp_get_type_name(*args)

def ExprIntrp_GenExp_get_type_descriptor(*args):
    """
    ExprIntrp_GenExp_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ExprIntrp.ExprIntrp_GenExp_get_type_descriptor(*args)

class ExprIntrp_GenRel(ExprIntrp_Generator):
    """
    Implements an interpreter for equations or system
    of equations made of expressions of package Expr.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ExprIntrp_GenRel
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ExprIntrp_GenRel(self) 
            return h


    def Create(*args):
        """
        Create() -> Handle_ExprIntrp_GenRel

        :rtype: OCC.wrapper.ExprIntrp.Handle_ExprIntrp_GenRel

        """
        return _ExprIntrp.ExprIntrp_GenRel_Create(*args)

    Create = staticmethod(Create)

    def Process(self, *args):
        """
        Process(ExprIntrp_GenRel self, TCollection_AsciiString str)

        Processes given string.

        :type str: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _ExprIntrp.ExprIntrp_GenRel_Process(self, *args)


    def IsDone(self, *args):
        """
        IsDone(ExprIntrp_GenRel self) -> Standard_Boolean

        Returns false if any syntax error has occurred during
        process.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ExprIntrp.ExprIntrp_GenRel_IsDone(self, *args)


    def Relation(self, *args):
        """
        Relation(ExprIntrp_GenRel self) -> Handle_Expr_GeneralRelation

        Returns relation generated. Raises an exception if
        IsDone answers false.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _ExprIntrp.ExprIntrp_GenRel_Relation(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ExprIntrp.ExprIntrp_GenRel_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ExprIntrp.ExprIntrp_GenRel_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ExprIntrp.ExprIntrp_GenRel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ExprIntrp.delete_ExprIntrp_GenRel
ExprIntrp_GenRel_swigregister = _ExprIntrp.ExprIntrp_GenRel_swigregister
ExprIntrp_GenRel_swigregister(ExprIntrp_GenRel)

def ExprIntrp_GenRel_Create(*args):
    """
    ExprIntrp_GenRel_Create() -> Handle_ExprIntrp_GenRel

    :rtype: OCC.wrapper.ExprIntrp.Handle_ExprIntrp_GenRel

    """
    return _ExprIntrp.ExprIntrp_GenRel_Create(*args)

def ExprIntrp_GenRel_get_type_name(*args):
    """
    ExprIntrp_GenRel_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ExprIntrp.ExprIntrp_GenRel_get_type_name(*args)

def ExprIntrp_GenRel_get_type_descriptor(*args):
    """
    ExprIntrp_GenRel_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ExprIntrp.ExprIntrp_GenRel_get_type_descriptor(*args)

class Handle_ExprIntrp_GenExp(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ExprIntrp_GenExp self)

        Nullify the handle


        """
        return _ExprIntrp.Handle_ExprIntrp_GenExp_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ExprIntrp_GenExp self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ExprIntrp.Handle_ExprIntrp_GenExp_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ExprIntrp_GenExp self, ExprIntrp_GenExp thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ExprIntrp.Handle_ExprIntrp_GenExp_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ExprIntrp_GenExp self, Handle_ExprIntrp_GenExp theHandle) -> Handle_ExprIntrp_GenExp
        assign(Handle_ExprIntrp_GenExp self, ExprIntrp_GenExp thePtr) -> Handle_ExprIntrp_GenExp
        assign(Handle_ExprIntrp_GenExp self, Handle_ExprIntrp_GenExp theHandle) -> Handle_ExprIntrp_GenExp

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ExprIntrp.Handle_ExprIntrp_GenExp_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ExprIntrp_GenExp self) -> ExprIntrp_GenExp

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ExprIntrp.Handle_ExprIntrp_GenExp_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ExprIntrp_GenExp self) -> ExprIntrp_GenExp

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ExprIntrp.Handle_ExprIntrp_GenExp___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ExprIntrp_GenExp self) -> ExprIntrp_GenExp

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ExprIntrp.Handle_ExprIntrp_GenExp___ref__(self, *args)


    def __hash__(self):
        return _ExprIntrp.Handle_ExprIntrp_GenExp___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ExprIntrp.Handle_ExprIntrp_GenExp___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ExprIntrp.new_Handle_ExprIntrp_GenExp(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ExprIntrp.Handle_ExprIntrp_GenExp_DownCast)
    __swig_destroy__ = _ExprIntrp.delete_Handle_ExprIntrp_GenExp

    def Create(self, *args):
        """
        Create(Handle_ExprIntrp_GenExp self) -> Handle_ExprIntrp_GenExp

        :rtype: OCC.wrapper.ExprIntrp.Handle_ExprIntrp_GenExp

        """
        return _ExprIntrp.Handle_ExprIntrp_GenExp_Create(self, *args)


    def Process(self, *args):
        """
        Process(Handle_ExprIntrp_GenExp self, TCollection_AsciiString str)

        Processes given string.

        :type str: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _ExprIntrp.Handle_ExprIntrp_GenExp_Process(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Handle_ExprIntrp_GenExp self) -> Standard_Boolean

        Returns false if any syntax error has occurred during
        process.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ExprIntrp.Handle_ExprIntrp_GenExp_IsDone(self, *args)


    def Expression(self, *args):
        """
        Expression(Handle_ExprIntrp_GenExp self) -> Handle_Expr_GeneralExpression

        Returns expression generated. Raises an exception if
        IsDone answers false.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _ExprIntrp.Handle_ExprIntrp_GenExp_Expression(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ExprIntrp_GenExp self) -> char const *

        :rtype: const char *

        """
        return _ExprIntrp.Handle_ExprIntrp_GenExp_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ExprIntrp.Handle_ExprIntrp_GenExp_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ExprIntrp.Handle_ExprIntrp_GenExp_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Use(self, *args):
        """
        Use(Handle_ExprIntrp_GenExp self, Handle_Expr_NamedFunction func)
        Use(Handle_ExprIntrp_GenExp self, Handle_Expr_NamedExpression named)

        :type named: OCC.wrapper.Expr.Handle_Expr_NamedExpression

        """
        return _ExprIntrp.Handle_ExprIntrp_GenExp_Use(self, *args)


    def GetNamed(self, *args):
        """
        :rtype: OCC.wrapper.ExprIntrp.ExprIntrp_SequenceOfNamedExpression

        """
        res = _ExprIntrp.Handle_ExprIntrp_GenExp_GetNamed(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetFunctions(self, *args):
        """
        :rtype: OCC.wrapper.ExprIntrp.ExprIntrp_SequenceOfNamedFunction

        """
        res = _ExprIntrp.Handle_ExprIntrp_GenExp_GetFunctions(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetFunction(self, *args):
        """
        GetFunction(Handle_ExprIntrp_GenExp self, TCollection_AsciiString name) -> Handle_Expr_NamedFunction

        Returns NamedFunction with name <name> already
        interpreted if it exists. Returns a null handle if
        not.

        :type name: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Expr.Handle_Expr_NamedFunction

        """
        return _ExprIntrp.Handle_ExprIntrp_GenExp_GetFunction(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ExprIntrp_GenExp self)

        Memory deallocator for transient classes


        """
        return _ExprIntrp.Handle_ExprIntrp_GenExp_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ExprIntrp_GenExp self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ExprIntrp_GenExp self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ExprIntrp.Handle_ExprIntrp_GenExp_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ExprIntrp_GenExp self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ExprIntrp_GenExp self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ExprIntrp.Handle_ExprIntrp_GenExp_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ExprIntrp_GenExp self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ExprIntrp.Handle_ExprIntrp_GenExp_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ExprIntrp_GenExp self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ExprIntrp.Handle_ExprIntrp_GenExp_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ExprIntrp_GenExp self)

        Increments the reference counter of this object


        """
        return _ExprIntrp.Handle_ExprIntrp_GenExp_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ExprIntrp_GenExp self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ExprIntrp.Handle_ExprIntrp_GenExp_DecrementRefCounter(self, *args)

Handle_ExprIntrp_GenExp_swigregister = _ExprIntrp.Handle_ExprIntrp_GenExp_swigregister
Handle_ExprIntrp_GenExp_swigregister(Handle_ExprIntrp_GenExp)

def Handle_ExprIntrp_GenExp_DownCast(thing):
    return _ExprIntrp.Handle_ExprIntrp_GenExp_DownCast(thing)
Handle_ExprIntrp_GenExp_DownCast = _ExprIntrp.Handle_ExprIntrp_GenExp_DownCast

class ExprIntrp_GenFct(ExprIntrp_Generator):
    """
    Implements an interpreter for defining functions.
    All its functionnalities can be found in class
    GenExp.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ExprIntrp_GenFct
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ExprIntrp_GenFct(self) 
            return h


    def Create(*args):
        """
        Create() -> Handle_ExprIntrp_GenFct

        :rtype: OCC.wrapper.ExprIntrp.Handle_ExprIntrp_GenFct

        """
        return _ExprIntrp.ExprIntrp_GenFct_Create(*args)

    Create = staticmethod(Create)

    def Process(self, *args):
        """
        Process(ExprIntrp_GenFct self, TCollection_AsciiString str)

        :type str: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _ExprIntrp.ExprIntrp_GenFct_Process(self, *args)


    def IsDone(self, *args):
        """
        IsDone(ExprIntrp_GenFct self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ExprIntrp.ExprIntrp_GenFct_IsDone(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ExprIntrp.ExprIntrp_GenFct_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ExprIntrp.ExprIntrp_GenFct_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ExprIntrp.ExprIntrp_GenFct_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ExprIntrp.delete_ExprIntrp_GenFct
ExprIntrp_GenFct_swigregister = _ExprIntrp.ExprIntrp_GenFct_swigregister
ExprIntrp_GenFct_swigregister(ExprIntrp_GenFct)

def ExprIntrp_GenFct_Create(*args):
    """
    ExprIntrp_GenFct_Create() -> Handle_ExprIntrp_GenFct

    :rtype: OCC.wrapper.ExprIntrp.Handle_ExprIntrp_GenFct

    """
    return _ExprIntrp.ExprIntrp_GenFct_Create(*args)

def ExprIntrp_GenFct_get_type_name(*args):
    """
    ExprIntrp_GenFct_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ExprIntrp.ExprIntrp_GenFct_get_type_name(*args)

def ExprIntrp_GenFct_get_type_descriptor(*args):
    """
    ExprIntrp_GenFct_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ExprIntrp.ExprIntrp_GenFct_get_type_descriptor(*args)

class ExprIntrp_(object):
    """
    Describes an interpreter for GeneralExpressions,
    GeneralFunctions, and GeneralRelations defined in
    package Expr.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """
        Describes an interpreter for GeneralExpressions,
        GeneralFunctions, and GeneralRelations defined in
        package Expr.
        """
        this = _ExprIntrp.new_ExprIntrp_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ExprIntrp.delete_ExprIntrp_
ExprIntrp__swigregister = _ExprIntrp.ExprIntrp__swigregister
ExprIntrp__swigregister(ExprIntrp_)

class NCollection_List_Handle_Expr_GeneralExpression(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_Expr_GeneralExpression self) -> NCollection_List< opencascade::handle< Expr_GeneralExpression > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralExpression_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_Expr_GeneralExpression self) -> NCollection_List< opencascade::handle< Expr_GeneralExpression > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralExpression_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_Expr_GeneralExpression self) -> NCollection_List< opencascade::handle< Expr_GeneralExpression > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralExpression_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_Expr_GeneralExpression self) -> NCollection_List< opencascade::handle< Expr_GeneralExpression > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralExpression_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _ExprIntrp.new_NCollection_List_Handle_Expr_GeneralExpression(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_Expr_GeneralExpression self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralExpression_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_Expr_GeneralExpression self, NCollection_List_Handle_Expr_GeneralExpression theOther) -> NCollection_List_Handle_Expr_GeneralExpression

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralExpression_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_Expr_GeneralExpression self, NCollection_List_Handle_Expr_GeneralExpression theOther) -> NCollection_List_Handle_Expr_GeneralExpression

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralExpression_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_Expr_GeneralExpression self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralExpression_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _ExprIntrp.NCollection_List_Handle_Expr_GeneralExpression_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _ExprIntrp.NCollection_List_Handle_Expr_GeneralExpression_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_Expr_GeneralExpression self, Handle_Expr_GeneralExpression theItem) -> Handle_Expr_GeneralExpression
        Append(NCollection_List_Handle_Expr_GeneralExpression self, Handle_Expr_GeneralExpression theItem, NCollection_List< opencascade::handle< Expr_GeneralExpression > >::Iterator & theIter)
        Append(NCollection_List_Handle_Expr_GeneralExpression self, NCollection_List_Handle_Expr_GeneralExpression theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralExpression_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_Expr_GeneralExpression self, Handle_Expr_GeneralExpression theItem) -> Handle_Expr_GeneralExpression
        Prepend(NCollection_List_Handle_Expr_GeneralExpression self, NCollection_List_Handle_Expr_GeneralExpression theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralExpression_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_Expr_GeneralExpression self)

        RemoveFirst item


        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralExpression_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_Expr_GeneralExpression self, NCollection_List< opencascade::handle< Expr_GeneralExpression > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralExpression_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_Expr_GeneralExpression self, Handle_Expr_GeneralExpression theItem, NCollection_List< opencascade::handle< Expr_GeneralExpression > >::Iterator & theIter) -> Handle_Expr_GeneralExpression
        InsertBefore(NCollection_List_Handle_Expr_GeneralExpression self, NCollection_List_Handle_Expr_GeneralExpression theOther, NCollection_List< opencascade::handle< Expr_GeneralExpression > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralExpression_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_Expr_GeneralExpression self, Handle_Expr_GeneralExpression theItem, NCollection_List< opencascade::handle< Expr_GeneralExpression > >::Iterator & theIter) -> Handle_Expr_GeneralExpression
        InsertAfter(NCollection_List_Handle_Expr_GeneralExpression self, NCollection_List_Handle_Expr_GeneralExpression theOther, NCollection_List< opencascade::handle< Expr_GeneralExpression > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralExpression_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_Expr_GeneralExpression self)

        Reverse the list


        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralExpression_Reverse(self, *args)


    def __iter__(self):
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralExpression___iter__(self)
    __swig_destroy__ = _ExprIntrp.delete_NCollection_List_Handle_Expr_GeneralExpression
NCollection_List_Handle_Expr_GeneralExpression_swigregister = _ExprIntrp.NCollection_List_Handle_Expr_GeneralExpression_swigregister
NCollection_List_Handle_Expr_GeneralExpression_swigregister(NCollection_List_Handle_Expr_GeneralExpression)

class NCollection_List_Handle_Expr_GeneralExpression_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _ExprIntrp.new_NCollection_List_Handle_Expr_GeneralExpression_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ExprIntrp.delete_NCollection_List_Handle_Expr_GeneralExpression_IteratorHelper

    def __next__(self):
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralExpression_IteratorHelper___next__(self)
NCollection_List_Handle_Expr_GeneralExpression_IteratorHelper_swigregister = _ExprIntrp.NCollection_List_Handle_Expr_GeneralExpression_IteratorHelper_swigregister
NCollection_List_Handle_Expr_GeneralExpression_IteratorHelper_swigregister(NCollection_List_Handle_Expr_GeneralExpression_IteratorHelper)


try:
	ExprIntrp_StackOfGeneralExpression = NCollection_List_Handle_Expr_GeneralExpression
except NameError:
	pass # does not exist, probably ignored

class Handle_ExprIntrp_GenRel(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ExprIntrp_GenRel self)

        Nullify the handle


        """
        return _ExprIntrp.Handle_ExprIntrp_GenRel_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ExprIntrp_GenRel self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ExprIntrp.Handle_ExprIntrp_GenRel_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ExprIntrp_GenRel self, ExprIntrp_GenRel thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ExprIntrp.Handle_ExprIntrp_GenRel_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ExprIntrp_GenRel self, Handle_ExprIntrp_GenRel theHandle) -> Handle_ExprIntrp_GenRel
        assign(Handle_ExprIntrp_GenRel self, ExprIntrp_GenRel thePtr) -> Handle_ExprIntrp_GenRel
        assign(Handle_ExprIntrp_GenRel self, Handle_ExprIntrp_GenRel theHandle) -> Handle_ExprIntrp_GenRel

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ExprIntrp.Handle_ExprIntrp_GenRel_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ExprIntrp_GenRel self) -> ExprIntrp_GenRel

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ExprIntrp.Handle_ExprIntrp_GenRel_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ExprIntrp_GenRel self) -> ExprIntrp_GenRel

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ExprIntrp.Handle_ExprIntrp_GenRel___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ExprIntrp_GenRel self) -> ExprIntrp_GenRel

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ExprIntrp.Handle_ExprIntrp_GenRel___ref__(self, *args)


    def __hash__(self):
        return _ExprIntrp.Handle_ExprIntrp_GenRel___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ExprIntrp.Handle_ExprIntrp_GenRel___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ExprIntrp.new_Handle_ExprIntrp_GenRel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ExprIntrp.Handle_ExprIntrp_GenRel_DownCast)
    __swig_destroy__ = _ExprIntrp.delete_Handle_ExprIntrp_GenRel

    def Create(self, *args):
        """
        Create(Handle_ExprIntrp_GenRel self) -> Handle_ExprIntrp_GenRel

        :rtype: OCC.wrapper.ExprIntrp.Handle_ExprIntrp_GenRel

        """
        return _ExprIntrp.Handle_ExprIntrp_GenRel_Create(self, *args)


    def Process(self, *args):
        """
        Process(Handle_ExprIntrp_GenRel self, TCollection_AsciiString str)

        Processes given string.

        :type str: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _ExprIntrp.Handle_ExprIntrp_GenRel_Process(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Handle_ExprIntrp_GenRel self) -> Standard_Boolean

        Returns false if any syntax error has occurred during
        process.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ExprIntrp.Handle_ExprIntrp_GenRel_IsDone(self, *args)


    def Relation(self, *args):
        """
        Relation(Handle_ExprIntrp_GenRel self) -> Handle_Expr_GeneralRelation

        Returns relation generated. Raises an exception if
        IsDone answers false.

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _ExprIntrp.Handle_ExprIntrp_GenRel_Relation(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ExprIntrp_GenRel self) -> char const *

        :rtype: const char *

        """
        return _ExprIntrp.Handle_ExprIntrp_GenRel_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ExprIntrp.Handle_ExprIntrp_GenRel_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ExprIntrp.Handle_ExprIntrp_GenRel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Use(self, *args):
        """
        Use(Handle_ExprIntrp_GenRel self, Handle_Expr_NamedFunction func)
        Use(Handle_ExprIntrp_GenRel self, Handle_Expr_NamedExpression named)

        :type named: OCC.wrapper.Expr.Handle_Expr_NamedExpression

        """
        return _ExprIntrp.Handle_ExprIntrp_GenRel_Use(self, *args)


    def GetNamed(self, *args):
        """
        :rtype: OCC.wrapper.ExprIntrp.ExprIntrp_SequenceOfNamedExpression

        """
        res = _ExprIntrp.Handle_ExprIntrp_GenRel_GetNamed(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetFunctions(self, *args):
        """
        :rtype: OCC.wrapper.ExprIntrp.ExprIntrp_SequenceOfNamedFunction

        """
        res = _ExprIntrp.Handle_ExprIntrp_GenRel_GetFunctions(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetFunction(self, *args):
        """
        GetFunction(Handle_ExprIntrp_GenRel self, TCollection_AsciiString name) -> Handle_Expr_NamedFunction

        Returns NamedFunction with name <name> already
        interpreted if it exists. Returns a null handle if
        not.

        :type name: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Expr.Handle_Expr_NamedFunction

        """
        return _ExprIntrp.Handle_ExprIntrp_GenRel_GetFunction(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ExprIntrp_GenRel self)

        Memory deallocator for transient classes


        """
        return _ExprIntrp.Handle_ExprIntrp_GenRel_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ExprIntrp_GenRel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ExprIntrp_GenRel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ExprIntrp.Handle_ExprIntrp_GenRel_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ExprIntrp_GenRel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ExprIntrp_GenRel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ExprIntrp.Handle_ExprIntrp_GenRel_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ExprIntrp_GenRel self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ExprIntrp.Handle_ExprIntrp_GenRel_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ExprIntrp_GenRel self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ExprIntrp.Handle_ExprIntrp_GenRel_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ExprIntrp_GenRel self)

        Increments the reference counter of this object


        """
        return _ExprIntrp.Handle_ExprIntrp_GenRel_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ExprIntrp_GenRel self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ExprIntrp.Handle_ExprIntrp_GenRel_DecrementRefCounter(self, *args)

Handle_ExprIntrp_GenRel_swigregister = _ExprIntrp.Handle_ExprIntrp_GenRel_swigregister
Handle_ExprIntrp_GenRel_swigregister(Handle_ExprIntrp_GenRel)

def Handle_ExprIntrp_GenRel_DownCast(thing):
    return _ExprIntrp.Handle_ExprIntrp_GenRel_DownCast(thing)
Handle_ExprIntrp_GenRel_DownCast = _ExprIntrp.Handle_ExprIntrp_GenRel_DownCast

class NCollection_List_Handle_Expr_GeneralFunction(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_Expr_GeneralFunction self) -> NCollection_List< opencascade::handle< Expr_GeneralFunction > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralFunction_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_Expr_GeneralFunction self) -> NCollection_List< opencascade::handle< Expr_GeneralFunction > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralFunction_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_Expr_GeneralFunction self) -> NCollection_List< opencascade::handle< Expr_GeneralFunction > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralFunction_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_Expr_GeneralFunction self) -> NCollection_List< opencascade::handle< Expr_GeneralFunction > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralFunction_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _ExprIntrp.new_NCollection_List_Handle_Expr_GeneralFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_Expr_GeneralFunction self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralFunction_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_Expr_GeneralFunction self, NCollection_List_Handle_Expr_GeneralFunction theOther) -> NCollection_List_Handle_Expr_GeneralFunction

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralFunction_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_Expr_GeneralFunction self, NCollection_List_Handle_Expr_GeneralFunction theOther) -> NCollection_List_Handle_Expr_GeneralFunction

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralFunction_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_Expr_GeneralFunction self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralFunction_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _ExprIntrp.NCollection_List_Handle_Expr_GeneralFunction_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _ExprIntrp.NCollection_List_Handle_Expr_GeneralFunction_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_Expr_GeneralFunction self, Handle_Expr_GeneralFunction theItem) -> Handle_Expr_GeneralFunction
        Append(NCollection_List_Handle_Expr_GeneralFunction self, Handle_Expr_GeneralFunction theItem, NCollection_List< opencascade::handle< Expr_GeneralFunction > >::Iterator & theIter)
        Append(NCollection_List_Handle_Expr_GeneralFunction self, NCollection_List_Handle_Expr_GeneralFunction theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralFunction_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_Expr_GeneralFunction self, Handle_Expr_GeneralFunction theItem) -> Handle_Expr_GeneralFunction
        Prepend(NCollection_List_Handle_Expr_GeneralFunction self, NCollection_List_Handle_Expr_GeneralFunction theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralFunction_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_Expr_GeneralFunction self)

        RemoveFirst item


        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralFunction_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_Expr_GeneralFunction self, NCollection_List< opencascade::handle< Expr_GeneralFunction > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralFunction_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_Expr_GeneralFunction self, Handle_Expr_GeneralFunction theItem, NCollection_List< opencascade::handle< Expr_GeneralFunction > >::Iterator & theIter) -> Handle_Expr_GeneralFunction
        InsertBefore(NCollection_List_Handle_Expr_GeneralFunction self, NCollection_List_Handle_Expr_GeneralFunction theOther, NCollection_List< opencascade::handle< Expr_GeneralFunction > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralFunction_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_Expr_GeneralFunction self, Handle_Expr_GeneralFunction theItem, NCollection_List< opencascade::handle< Expr_GeneralFunction > >::Iterator & theIter) -> Handle_Expr_GeneralFunction
        InsertAfter(NCollection_List_Handle_Expr_GeneralFunction self, NCollection_List_Handle_Expr_GeneralFunction theOther, NCollection_List< opencascade::handle< Expr_GeneralFunction > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralFunction_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_Expr_GeneralFunction self)

        Reverse the list


        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralFunction_Reverse(self, *args)


    def __iter__(self):
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralFunction___iter__(self)
    __swig_destroy__ = _ExprIntrp.delete_NCollection_List_Handle_Expr_GeneralFunction
NCollection_List_Handle_Expr_GeneralFunction_swigregister = _ExprIntrp.NCollection_List_Handle_Expr_GeneralFunction_swigregister
NCollection_List_Handle_Expr_GeneralFunction_swigregister(NCollection_List_Handle_Expr_GeneralFunction)

class NCollection_List_Handle_Expr_GeneralFunction_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _ExprIntrp.new_NCollection_List_Handle_Expr_GeneralFunction_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ExprIntrp.delete_NCollection_List_Handle_Expr_GeneralFunction_IteratorHelper

    def __next__(self):
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralFunction_IteratorHelper___next__(self)
NCollection_List_Handle_Expr_GeneralFunction_IteratorHelper_swigregister = _ExprIntrp.NCollection_List_Handle_Expr_GeneralFunction_IteratorHelper_swigregister
NCollection_List_Handle_Expr_GeneralFunction_IteratorHelper_swigregister(NCollection_List_Handle_Expr_GeneralFunction_IteratorHelper)


try:
	ExprIntrp_StackOfGeneralFunction = NCollection_List_Handle_Expr_GeneralFunction
except NameError:
	pass # does not exist, probably ignored

class Handle_ExprIntrp_Generator(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ExprIntrp_Generator self)

        Nullify the handle


        """
        return _ExprIntrp.Handle_ExprIntrp_Generator_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ExprIntrp_Generator self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ExprIntrp.Handle_ExprIntrp_Generator_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ExprIntrp_Generator self, ExprIntrp_Generator thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ExprIntrp.Handle_ExprIntrp_Generator_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ExprIntrp_Generator self, Handle_ExprIntrp_Generator theHandle) -> Handle_ExprIntrp_Generator
        assign(Handle_ExprIntrp_Generator self, ExprIntrp_Generator thePtr) -> Handle_ExprIntrp_Generator
        assign(Handle_ExprIntrp_Generator self, Handle_ExprIntrp_Generator theHandle) -> Handle_ExprIntrp_Generator

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ExprIntrp.Handle_ExprIntrp_Generator_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ExprIntrp_Generator self) -> ExprIntrp_Generator

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ExprIntrp.Handle_ExprIntrp_Generator_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ExprIntrp_Generator self) -> ExprIntrp_Generator

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ExprIntrp.Handle_ExprIntrp_Generator___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ExprIntrp_Generator self) -> ExprIntrp_Generator

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ExprIntrp.Handle_ExprIntrp_Generator___ref__(self, *args)


    def __hash__(self):
        return _ExprIntrp.Handle_ExprIntrp_Generator___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ExprIntrp.Handle_ExprIntrp_Generator___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ExprIntrp.new_Handle_ExprIntrp_Generator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ExprIntrp.Handle_ExprIntrp_Generator_DownCast)
    __swig_destroy__ = _ExprIntrp.delete_Handle_ExprIntrp_Generator

    def Use(self, *args):
        """
        Use(Handle_ExprIntrp_Generator self, Handle_Expr_NamedFunction func)
        Use(Handle_ExprIntrp_Generator self, Handle_Expr_NamedExpression named)

        :type named: OCC.wrapper.Expr.Handle_Expr_NamedExpression

        """
        return _ExprIntrp.Handle_ExprIntrp_Generator_Use(self, *args)


    def GetNamed(self, *args):
        """
        :rtype: OCC.wrapper.ExprIntrp.ExprIntrp_SequenceOfNamedExpression

        """
        res = _ExprIntrp.Handle_ExprIntrp_Generator_GetNamed(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetFunctions(self, *args):
        """
        :rtype: OCC.wrapper.ExprIntrp.ExprIntrp_SequenceOfNamedFunction

        """
        res = _ExprIntrp.Handle_ExprIntrp_Generator_GetFunctions(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetFunction(self, *args):
        """
        GetFunction(Handle_ExprIntrp_Generator self, TCollection_AsciiString name) -> Handle_Expr_NamedFunction

        Returns NamedFunction with name <name> already
        interpreted if it exists. Returns a null handle if
        not.

        :type name: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Expr.Handle_Expr_NamedFunction

        """
        return _ExprIntrp.Handle_ExprIntrp_Generator_GetFunction(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ExprIntrp_Generator self) -> char const *

        :rtype: const char *

        """
        return _ExprIntrp.Handle_ExprIntrp_Generator_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ExprIntrp.Handle_ExprIntrp_Generator_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ExprIntrp.Handle_ExprIntrp_Generator_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ExprIntrp_Generator self)

        Memory deallocator for transient classes


        """
        return _ExprIntrp.Handle_ExprIntrp_Generator_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ExprIntrp_Generator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ExprIntrp_Generator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ExprIntrp.Handle_ExprIntrp_Generator_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ExprIntrp_Generator self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ExprIntrp_Generator self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ExprIntrp.Handle_ExprIntrp_Generator_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ExprIntrp_Generator self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ExprIntrp.Handle_ExprIntrp_Generator_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ExprIntrp_Generator self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ExprIntrp.Handle_ExprIntrp_Generator_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ExprIntrp_Generator self)

        Increments the reference counter of this object


        """
        return _ExprIntrp.Handle_ExprIntrp_Generator_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ExprIntrp_Generator self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ExprIntrp.Handle_ExprIntrp_Generator_DecrementRefCounter(self, *args)

Handle_ExprIntrp_Generator_swigregister = _ExprIntrp.Handle_ExprIntrp_Generator_swigregister
Handle_ExprIntrp_Generator_swigregister(Handle_ExprIntrp_Generator)

def Handle_ExprIntrp_Generator_DownCast(thing):
    return _ExprIntrp.Handle_ExprIntrp_Generator_DownCast(thing)
Handle_ExprIntrp_Generator_DownCast = _ExprIntrp.Handle_ExprIntrp_Generator_DownCast

class ExprIntrp_SyntaxError(Standard.Standard_Failure):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ExprIntrp_SyntaxError
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ExprIntrp_SyntaxError(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ExprIntrp_SyntaxError self) -> ExprIntrp_SyntaxError
        __init__(ExprIntrp_SyntaxError self, Standard_CString const theMessage) -> ExprIntrp_SyntaxError

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _ExprIntrp.new_ExprIntrp_SyntaxError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_ExprIntrp_SyntaxError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.ExprIntrp.Handle_ExprIntrp_SyntaxError

        """
        return _ExprIntrp.ExprIntrp_SyntaxError_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ExprIntrp.ExprIntrp_SyntaxError_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ExprIntrp.ExprIntrp_SyntaxError_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ExprIntrp.ExprIntrp_SyntaxError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ExprIntrp.delete_ExprIntrp_SyntaxError
ExprIntrp_SyntaxError_swigregister = _ExprIntrp.ExprIntrp_SyntaxError_swigregister
ExprIntrp_SyntaxError_swigregister(ExprIntrp_SyntaxError)

def ExprIntrp_SyntaxError_NewInstance(*args):
    """
    ExprIntrp_SyntaxError_NewInstance(Standard_CString const theMessage) -> Handle_ExprIntrp_SyntaxError

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.ExprIntrp.Handle_ExprIntrp_SyntaxError

    """
    return _ExprIntrp.ExprIntrp_SyntaxError_NewInstance(*args)

def ExprIntrp_SyntaxError_get_type_name(*args):
    """
    ExprIntrp_SyntaxError_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ExprIntrp.ExprIntrp_SyntaxError_get_type_name(*args)

def ExprIntrp_SyntaxError_get_type_descriptor(*args):
    """
    ExprIntrp_SyntaxError_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ExprIntrp.ExprIntrp_SyntaxError_get_type_descriptor(*args)

class NCollection_Sequence_Handle_Expr_NamedFunction(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_Expr_NamedFunction self) -> NCollection_Sequence< opencascade::handle< Expr_NamedFunction > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_Expr_NamedFunction self) -> NCollection_Sequence< opencascade::handle< Expr_NamedFunction > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_Expr_NamedFunction self) -> NCollection_Sequence< opencascade::handle< Expr_NamedFunction > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_Expr_NamedFunction self) -> NCollection_Sequence< opencascade::handle< Expr_NamedFunction > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _ExprIntrp.new_NCollection_Sequence_Handle_Expr_NamedFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_Expr_NamedFunction self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_Expr_NamedFunction self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_Expr_NamedFunction self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_Expr_NamedFunction self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_Expr_NamedFunction self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_Expr_NamedFunction self)

        Reverse sequence


        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_Expr_NamedFunction self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_Expr_NamedFunction self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_Expr_NamedFunction self, NCollection_Sequence_Handle_Expr_NamedFunction theOther) -> NCollection_Sequence_Handle_Expr_NamedFunction

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_Expr_NamedFunction self, NCollection_Sequence_Handle_Expr_NamedFunction theOther) -> NCollection_Sequence_Handle_Expr_NamedFunction

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_Expr_NamedFunction self, NCollection_Sequence< opencascade::handle< Expr_NamedFunction > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_Expr_NamedFunction self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_Expr_NamedFunction self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_Expr_NamedFunction self, Handle_Expr_NamedFunction theItem)
        Append(NCollection_Sequence_Handle_Expr_NamedFunction self, NCollection_Sequence_Handle_Expr_NamedFunction theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_Expr_NamedFunction self, Handle_Expr_NamedFunction theItem)
        Prepend(NCollection_Sequence_Handle_Expr_NamedFunction self, NCollection_Sequence_Handle_Expr_NamedFunction theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_Expr_NamedFunction self, Standard_Integer const theIndex, Handle_Expr_NamedFunction theItem)
        InsertBefore(NCollection_Sequence_Handle_Expr_NamedFunction self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Expr_NamedFunction theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_Expr_NamedFunction self, NCollection_Sequence< opencascade::handle< Expr_NamedFunction > >::Iterator & thePosition, Handle_Expr_NamedFunction theItem)
        InsertAfter(NCollection_Sequence_Handle_Expr_NamedFunction self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Expr_NamedFunction theSeq)
        InsertAfter(NCollection_Sequence_Handle_Expr_NamedFunction self, Standard_Integer const theIndex, Handle_Expr_NamedFunction theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_Expr_NamedFunction self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Expr_NamedFunction theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_Expr_NamedFunction self) -> Handle_Expr_NamedFunction

        First item access

        :rtype: TheItemType &

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_Expr_NamedFunction self) -> Handle_Expr_NamedFunction

        Last item access

        :rtype: TheItemType &

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_Expr_NamedFunction self, Standard_Integer const theIndex) -> Handle_Expr_NamedFunction

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_Expr_NamedFunction self, Standard_Integer const theIndex, Handle_Expr_NamedFunction theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_SetValue(self, *args)


    def __iter__(self):
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction___iter__(self)
    __swig_destroy__ = _ExprIntrp.delete_NCollection_Sequence_Handle_Expr_NamedFunction
NCollection_Sequence_Handle_Expr_NamedFunction_swigregister = _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_swigregister
NCollection_Sequence_Handle_Expr_NamedFunction_swigregister(NCollection_Sequence_Handle_Expr_NamedFunction)

def NCollection_Sequence_Handle_Expr_NamedFunction_delNode(*args):
    """
    NCollection_Sequence_Handle_Expr_NamedFunction_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_delNode(*args)

class NCollection_Sequence_Handle_Expr_NamedFunction_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _ExprIntrp.new_NCollection_Sequence_Handle_Expr_NamedFunction_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ExprIntrp.delete_NCollection_Sequence_Handle_Expr_NamedFunction_IteratorHelper

    def __next__(self):
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_IteratorHelper___next__(self)
NCollection_Sequence_Handle_Expr_NamedFunction_IteratorHelper_swigregister = _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedFunction_IteratorHelper_swigregister
NCollection_Sequence_Handle_Expr_NamedFunction_IteratorHelper_swigregister(NCollection_Sequence_Handle_Expr_NamedFunction_IteratorHelper)


try:
	ExprIntrp_SequenceOfNamedFunction = NCollection_Sequence_Handle_Expr_NamedFunction
except NameError:
	pass # does not exist, probably ignored

class ExprIntrp_Analysis(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(ExprIntrp_Analysis self) -> ExprIntrp_Analysis"""
        this = _ExprIntrp.new_ExprIntrp_Analysis(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetMaster(self, *args):
        """
        SetMaster(ExprIntrp_Analysis self, Handle_ExprIntrp_Generator agen)

        :type agen: OCC.wrapper.ExprIntrp.Handle_ExprIntrp_Generator

        """
        return _ExprIntrp.ExprIntrp_Analysis_SetMaster(self, *args)


    def Push(self, *args):
        """
        Push(ExprIntrp_Analysis self, Handle_Expr_GeneralExpression exp)

        :type exp: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _ExprIntrp.ExprIntrp_Analysis_Push(self, *args)


    def PushRelation(self, *args):
        """
        PushRelation(ExprIntrp_Analysis self, Handle_Expr_GeneralRelation rel)

        :type rel: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _ExprIntrp.ExprIntrp_Analysis_PushRelation(self, *args)


    def PushName(self, *args):
        """
        PushName(ExprIntrp_Analysis self, TCollection_AsciiString name)

        :type name: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _ExprIntrp.ExprIntrp_Analysis_PushName(self, *args)


    def PushValue(self, *args):
        """
        PushValue(ExprIntrp_Analysis self, Standard_Integer const degree)

        :type degree: int

        """
        return _ExprIntrp.ExprIntrp_Analysis_PushValue(self, *args)


    def PushFunction(self, *args):
        """
        PushFunction(ExprIntrp_Analysis self, Handle_Expr_GeneralFunction func)

        :type func: OCC.wrapper.Expr.Handle_Expr_GeneralFunction

        """
        return _ExprIntrp.ExprIntrp_Analysis_PushFunction(self, *args)


    def Pop(self, *args):
        """
        Pop(ExprIntrp_Analysis self) -> Handle_Expr_GeneralExpression

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralExpression

        """
        return _ExprIntrp.ExprIntrp_Analysis_Pop(self, *args)


    def PopRelation(self, *args):
        """
        PopRelation(ExprIntrp_Analysis self) -> Handle_Expr_GeneralRelation

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralRelation

        """
        return _ExprIntrp.ExprIntrp_Analysis_PopRelation(self, *args)


    def PopName(self, *args):
        """
        PopName(ExprIntrp_Analysis self) -> TCollection_AsciiString

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _ExprIntrp.ExprIntrp_Analysis_PopName(self, *args)


    def PopValue(self, *args):
        """
        PopValue(ExprIntrp_Analysis self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ExprIntrp.ExprIntrp_Analysis_PopValue(self, *args)


    def PopFunction(self, *args):
        """
        PopFunction(ExprIntrp_Analysis self) -> Handle_Expr_GeneralFunction

        :rtype: OCC.wrapper.Expr.Handle_Expr_GeneralFunction

        """
        return _ExprIntrp.ExprIntrp_Analysis_PopFunction(self, *args)


    def IsExpStackEmpty(self, *args):
        """
        IsExpStackEmpty(ExprIntrp_Analysis self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ExprIntrp.ExprIntrp_Analysis_IsExpStackEmpty(self, *args)


    def IsRelStackEmpty(self, *args):
        """
        IsRelStackEmpty(ExprIntrp_Analysis self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ExprIntrp.ExprIntrp_Analysis_IsRelStackEmpty(self, *args)


    def ResetAll(self, *args):
        """ResetAll(ExprIntrp_Analysis self)"""
        return _ExprIntrp.ExprIntrp_Analysis_ResetAll(self, *args)


    def Use(self, *args):
        """
        Use(ExprIntrp_Analysis self, Handle_Expr_NamedFunction func)
        Use(ExprIntrp_Analysis self, Handle_Expr_NamedExpression named)

        :type named: OCC.wrapper.Expr.Handle_Expr_NamedExpression

        """
        return _ExprIntrp.ExprIntrp_Analysis_Use(self, *args)


    def GetNamed(self, *args):
        """
        GetNamed(ExprIntrp_Analysis self, TCollection_AsciiString name) -> Handle_Expr_NamedExpression

        :type name: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Expr.Handle_Expr_NamedExpression

        """
        return _ExprIntrp.ExprIntrp_Analysis_GetNamed(self, *args)


    def GetFunction(self, *args):
        """
        GetFunction(ExprIntrp_Analysis self, TCollection_AsciiString name) -> Handle_Expr_NamedFunction

        :type name: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Expr.Handle_Expr_NamedFunction

        """
        return _ExprIntrp.ExprIntrp_Analysis_GetFunction(self, *args)

    __swig_destroy__ = _ExprIntrp.delete_ExprIntrp_Analysis
ExprIntrp_Analysis_swigregister = _ExprIntrp.ExprIntrp_Analysis_swigregister
ExprIntrp_Analysis_swigregister(ExprIntrp_Analysis)

class NCollection_Sequence_Handle_Expr_NamedExpression(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_Expr_NamedExpression self) -> NCollection_Sequence< opencascade::handle< Expr_NamedExpression > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_Expr_NamedExpression self) -> NCollection_Sequence< opencascade::handle< Expr_NamedExpression > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_Expr_NamedExpression self) -> NCollection_Sequence< opencascade::handle< Expr_NamedExpression > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_Expr_NamedExpression self) -> NCollection_Sequence< opencascade::handle< Expr_NamedExpression > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _ExprIntrp.new_NCollection_Sequence_Handle_Expr_NamedExpression(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_Expr_NamedExpression self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_Expr_NamedExpression self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_Expr_NamedExpression self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_Expr_NamedExpression self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_Expr_NamedExpression self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_Expr_NamedExpression self)

        Reverse sequence


        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_Expr_NamedExpression self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_Expr_NamedExpression self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_Expr_NamedExpression self, NCollection_Sequence_Handle_Expr_NamedExpression theOther) -> NCollection_Sequence_Handle_Expr_NamedExpression

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_Expr_NamedExpression self, NCollection_Sequence_Handle_Expr_NamedExpression theOther) -> NCollection_Sequence_Handle_Expr_NamedExpression

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_Expr_NamedExpression self, NCollection_Sequence< opencascade::handle< Expr_NamedExpression > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_Expr_NamedExpression self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_Expr_NamedExpression self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_Expr_NamedExpression self, Handle_Expr_NamedExpression theItem)
        Append(NCollection_Sequence_Handle_Expr_NamedExpression self, NCollection_Sequence_Handle_Expr_NamedExpression theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_Expr_NamedExpression self, Handle_Expr_NamedExpression theItem)
        Prepend(NCollection_Sequence_Handle_Expr_NamedExpression self, NCollection_Sequence_Handle_Expr_NamedExpression theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_Expr_NamedExpression self, Standard_Integer const theIndex, Handle_Expr_NamedExpression theItem)
        InsertBefore(NCollection_Sequence_Handle_Expr_NamedExpression self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Expr_NamedExpression theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_Expr_NamedExpression self, NCollection_Sequence< opencascade::handle< Expr_NamedExpression > >::Iterator & thePosition, Handle_Expr_NamedExpression theItem)
        InsertAfter(NCollection_Sequence_Handle_Expr_NamedExpression self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Expr_NamedExpression theSeq)
        InsertAfter(NCollection_Sequence_Handle_Expr_NamedExpression self, Standard_Integer const theIndex, Handle_Expr_NamedExpression theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_Expr_NamedExpression self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Expr_NamedExpression theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_Expr_NamedExpression self) -> Handle_Expr_NamedExpression

        First item access

        :rtype: TheItemType &

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_Expr_NamedExpression self) -> Handle_Expr_NamedExpression

        Last item access

        :rtype: TheItemType &

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_Expr_NamedExpression self, Standard_Integer const theIndex) -> Handle_Expr_NamedExpression

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_Expr_NamedExpression self, Standard_Integer const theIndex, Handle_Expr_NamedExpression theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_SetValue(self, *args)


    def __iter__(self):
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression___iter__(self)
    __swig_destroy__ = _ExprIntrp.delete_NCollection_Sequence_Handle_Expr_NamedExpression
NCollection_Sequence_Handle_Expr_NamedExpression_swigregister = _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_swigregister
NCollection_Sequence_Handle_Expr_NamedExpression_swigregister(NCollection_Sequence_Handle_Expr_NamedExpression)

def NCollection_Sequence_Handle_Expr_NamedExpression_delNode(*args):
    """
    NCollection_Sequence_Handle_Expr_NamedExpression_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_delNode(*args)

class NCollection_Sequence_Handle_Expr_NamedExpression_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _ExprIntrp.new_NCollection_Sequence_Handle_Expr_NamedExpression_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ExprIntrp.delete_NCollection_Sequence_Handle_Expr_NamedExpression_IteratorHelper

    def __next__(self):
        return _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_IteratorHelper___next__(self)
NCollection_Sequence_Handle_Expr_NamedExpression_IteratorHelper_swigregister = _ExprIntrp.NCollection_Sequence_Handle_Expr_NamedExpression_IteratorHelper_swigregister
NCollection_Sequence_Handle_Expr_NamedExpression_IteratorHelper_swigregister(NCollection_Sequence_Handle_Expr_NamedExpression_IteratorHelper)


try:
	ExprIntrp_SequenceOfNamedExpression = NCollection_Sequence_Handle_Expr_NamedExpression
except NameError:
	pass # does not exist, probably ignored

class Handle_ExprIntrp_GenFct(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ExprIntrp_GenFct self)

        Nullify the handle


        """
        return _ExprIntrp.Handle_ExprIntrp_GenFct_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ExprIntrp_GenFct self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ExprIntrp.Handle_ExprIntrp_GenFct_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ExprIntrp_GenFct self, ExprIntrp_GenFct thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ExprIntrp.Handle_ExprIntrp_GenFct_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ExprIntrp_GenFct self, Handle_ExprIntrp_GenFct theHandle) -> Handle_ExprIntrp_GenFct
        assign(Handle_ExprIntrp_GenFct self, ExprIntrp_GenFct thePtr) -> Handle_ExprIntrp_GenFct
        assign(Handle_ExprIntrp_GenFct self, Handle_ExprIntrp_GenFct theHandle) -> Handle_ExprIntrp_GenFct

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ExprIntrp.Handle_ExprIntrp_GenFct_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ExprIntrp_GenFct self) -> ExprIntrp_GenFct

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ExprIntrp.Handle_ExprIntrp_GenFct_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ExprIntrp_GenFct self) -> ExprIntrp_GenFct

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ExprIntrp.Handle_ExprIntrp_GenFct___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ExprIntrp_GenFct self) -> ExprIntrp_GenFct

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ExprIntrp.Handle_ExprIntrp_GenFct___ref__(self, *args)


    def __hash__(self):
        return _ExprIntrp.Handle_ExprIntrp_GenFct___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ExprIntrp.Handle_ExprIntrp_GenFct___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ExprIntrp.new_Handle_ExprIntrp_GenFct(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ExprIntrp.Handle_ExprIntrp_GenFct_DownCast)
    __swig_destroy__ = _ExprIntrp.delete_Handle_ExprIntrp_GenFct

    def Create(self, *args):
        """
        Create(Handle_ExprIntrp_GenFct self) -> Handle_ExprIntrp_GenFct

        :rtype: OCC.wrapper.ExprIntrp.Handle_ExprIntrp_GenFct

        """
        return _ExprIntrp.Handle_ExprIntrp_GenFct_Create(self, *args)


    def Process(self, *args):
        """
        Process(Handle_ExprIntrp_GenFct self, TCollection_AsciiString str)

        :type str: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _ExprIntrp.Handle_ExprIntrp_GenFct_Process(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Handle_ExprIntrp_GenFct self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ExprIntrp.Handle_ExprIntrp_GenFct_IsDone(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ExprIntrp_GenFct self) -> char const *

        :rtype: const char *

        """
        return _ExprIntrp.Handle_ExprIntrp_GenFct_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ExprIntrp.Handle_ExprIntrp_GenFct_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ExprIntrp.Handle_ExprIntrp_GenFct_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Use(self, *args):
        """
        Use(Handle_ExprIntrp_GenFct self, Handle_Expr_NamedFunction func)
        Use(Handle_ExprIntrp_GenFct self, Handle_Expr_NamedExpression named)

        :type named: OCC.wrapper.Expr.Handle_Expr_NamedExpression

        """
        return _ExprIntrp.Handle_ExprIntrp_GenFct_Use(self, *args)


    def GetNamed(self, *args):
        """
        :rtype: OCC.wrapper.ExprIntrp.ExprIntrp_SequenceOfNamedExpression

        """
        res = _ExprIntrp.Handle_ExprIntrp_GenFct_GetNamed(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetFunctions(self, *args):
        """
        :rtype: OCC.wrapper.ExprIntrp.ExprIntrp_SequenceOfNamedFunction

        """
        res = _ExprIntrp.Handle_ExprIntrp_GenFct_GetFunctions(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetFunction(self, *args):
        """
        GetFunction(Handle_ExprIntrp_GenFct self, TCollection_AsciiString name) -> Handle_Expr_NamedFunction

        Returns NamedFunction with name <name> already
        interpreted if it exists. Returns a null handle if
        not.

        :type name: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.Expr.Handle_Expr_NamedFunction

        """
        return _ExprIntrp.Handle_ExprIntrp_GenFct_GetFunction(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ExprIntrp_GenFct self)

        Memory deallocator for transient classes


        """
        return _ExprIntrp.Handle_ExprIntrp_GenFct_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ExprIntrp_GenFct self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ExprIntrp_GenFct self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ExprIntrp.Handle_ExprIntrp_GenFct_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ExprIntrp_GenFct self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ExprIntrp_GenFct self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ExprIntrp.Handle_ExprIntrp_GenFct_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ExprIntrp_GenFct self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ExprIntrp.Handle_ExprIntrp_GenFct_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ExprIntrp_GenFct self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ExprIntrp.Handle_ExprIntrp_GenFct_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ExprIntrp_GenFct self)

        Increments the reference counter of this object


        """
        return _ExprIntrp.Handle_ExprIntrp_GenFct_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ExprIntrp_GenFct self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ExprIntrp.Handle_ExprIntrp_GenFct_DecrementRefCounter(self, *args)

Handle_ExprIntrp_GenFct_swigregister = _ExprIntrp.Handle_ExprIntrp_GenFct_swigregister
Handle_ExprIntrp_GenFct_swigregister(Handle_ExprIntrp_GenFct)

def Handle_ExprIntrp_GenFct_DownCast(thing):
    return _ExprIntrp.Handle_ExprIntrp_GenFct_DownCast(thing)
Handle_ExprIntrp_GenFct_DownCast = _ExprIntrp.Handle_ExprIntrp_GenFct_DownCast

class NCollection_List_Handle_Expr_GeneralRelation(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_Expr_GeneralRelation self) -> NCollection_List< opencascade::handle< Expr_GeneralRelation > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralRelation_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_Expr_GeneralRelation self) -> NCollection_List< opencascade::handle< Expr_GeneralRelation > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralRelation_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_Expr_GeneralRelation self) -> NCollection_List< opencascade::handle< Expr_GeneralRelation > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralRelation_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_Expr_GeneralRelation self) -> NCollection_List< opencascade::handle< Expr_GeneralRelation > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralRelation_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _ExprIntrp.new_NCollection_List_Handle_Expr_GeneralRelation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_Expr_GeneralRelation self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralRelation_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_Expr_GeneralRelation self, NCollection_List_Handle_Expr_GeneralRelation theOther) -> NCollection_List_Handle_Expr_GeneralRelation

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralRelation_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_Expr_GeneralRelation self, NCollection_List_Handle_Expr_GeneralRelation theOther) -> NCollection_List_Handle_Expr_GeneralRelation

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralRelation_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_Expr_GeneralRelation self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralRelation_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _ExprIntrp.NCollection_List_Handle_Expr_GeneralRelation_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _ExprIntrp.NCollection_List_Handle_Expr_GeneralRelation_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_Expr_GeneralRelation self, Handle_Expr_GeneralRelation theItem) -> Handle_Expr_GeneralRelation
        Append(NCollection_List_Handle_Expr_GeneralRelation self, Handle_Expr_GeneralRelation theItem, NCollection_List< opencascade::handle< Expr_GeneralRelation > >::Iterator & theIter)
        Append(NCollection_List_Handle_Expr_GeneralRelation self, NCollection_List_Handle_Expr_GeneralRelation theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralRelation_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_Expr_GeneralRelation self, Handle_Expr_GeneralRelation theItem) -> Handle_Expr_GeneralRelation
        Prepend(NCollection_List_Handle_Expr_GeneralRelation self, NCollection_List_Handle_Expr_GeneralRelation theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralRelation_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_Expr_GeneralRelation self)

        RemoveFirst item


        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralRelation_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_Expr_GeneralRelation self, NCollection_List< opencascade::handle< Expr_GeneralRelation > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralRelation_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_Expr_GeneralRelation self, Handle_Expr_GeneralRelation theItem, NCollection_List< opencascade::handle< Expr_GeneralRelation > >::Iterator & theIter) -> Handle_Expr_GeneralRelation
        InsertBefore(NCollection_List_Handle_Expr_GeneralRelation self, NCollection_List_Handle_Expr_GeneralRelation theOther, NCollection_List< opencascade::handle< Expr_GeneralRelation > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralRelation_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_Expr_GeneralRelation self, Handle_Expr_GeneralRelation theItem, NCollection_List< opencascade::handle< Expr_GeneralRelation > >::Iterator & theIter) -> Handle_Expr_GeneralRelation
        InsertAfter(NCollection_List_Handle_Expr_GeneralRelation self, NCollection_List_Handle_Expr_GeneralRelation theOther, NCollection_List< opencascade::handle< Expr_GeneralRelation > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralRelation_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_Expr_GeneralRelation self)

        Reverse the list


        """
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralRelation_Reverse(self, *args)


    def __iter__(self):
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralRelation___iter__(self)
    __swig_destroy__ = _ExprIntrp.delete_NCollection_List_Handle_Expr_GeneralRelation
NCollection_List_Handle_Expr_GeneralRelation_swigregister = _ExprIntrp.NCollection_List_Handle_Expr_GeneralRelation_swigregister
NCollection_List_Handle_Expr_GeneralRelation_swigregister(NCollection_List_Handle_Expr_GeneralRelation)

class NCollection_List_Handle_Expr_GeneralRelation_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _ExprIntrp.new_NCollection_List_Handle_Expr_GeneralRelation_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ExprIntrp.delete_NCollection_List_Handle_Expr_GeneralRelation_IteratorHelper

    def __next__(self):
        return _ExprIntrp.NCollection_List_Handle_Expr_GeneralRelation_IteratorHelper___next__(self)
NCollection_List_Handle_Expr_GeneralRelation_IteratorHelper_swigregister = _ExprIntrp.NCollection_List_Handle_Expr_GeneralRelation_IteratorHelper_swigregister
NCollection_List_Handle_Expr_GeneralRelation_IteratorHelper_swigregister(NCollection_List_Handle_Expr_GeneralRelation_IteratorHelper)


try:
	ExprIntrp_StackOfGeneralRelation = NCollection_List_Handle_Expr_GeneralRelation
except NameError:
	pass # does not exist, probably ignored

class Handle_ExprIntrp_SyntaxError(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ExprIntrp_SyntaxError self)

        Nullify the handle


        """
        return _ExprIntrp.Handle_ExprIntrp_SyntaxError_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ExprIntrp_SyntaxError self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ExprIntrp.Handle_ExprIntrp_SyntaxError_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ExprIntrp_SyntaxError self, ExprIntrp_SyntaxError thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ExprIntrp.Handle_ExprIntrp_SyntaxError_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ExprIntrp_SyntaxError self, Handle_ExprIntrp_SyntaxError theHandle) -> Handle_ExprIntrp_SyntaxError
        assign(Handle_ExprIntrp_SyntaxError self, ExprIntrp_SyntaxError thePtr) -> Handle_ExprIntrp_SyntaxError
        assign(Handle_ExprIntrp_SyntaxError self, Handle_ExprIntrp_SyntaxError theHandle) -> Handle_ExprIntrp_SyntaxError

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ExprIntrp.Handle_ExprIntrp_SyntaxError_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ExprIntrp_SyntaxError self) -> ExprIntrp_SyntaxError

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ExprIntrp.Handle_ExprIntrp_SyntaxError_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ExprIntrp_SyntaxError self) -> ExprIntrp_SyntaxError

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ExprIntrp.Handle_ExprIntrp_SyntaxError___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ExprIntrp_SyntaxError self) -> ExprIntrp_SyntaxError

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ExprIntrp.Handle_ExprIntrp_SyntaxError___ref__(self, *args)


    def __hash__(self):
        return _ExprIntrp.Handle_ExprIntrp_SyntaxError___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ExprIntrp.Handle_ExprIntrp_SyntaxError___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ExprIntrp.new_Handle_ExprIntrp_SyntaxError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ExprIntrp.Handle_ExprIntrp_SyntaxError_DownCast)
    __swig_destroy__ = _ExprIntrp.delete_Handle_ExprIntrp_SyntaxError

    def NewInstance(self, *args):
        """
        NewInstance(Handle_ExprIntrp_SyntaxError self, Standard_CString const theMessage) -> Handle_ExprIntrp_SyntaxError

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.ExprIntrp.Handle_ExprIntrp_SyntaxError

        """
        return _ExprIntrp.Handle_ExprIntrp_SyntaxError_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ExprIntrp_SyntaxError self) -> char const *

        :rtype: const char *

        """
        return _ExprIntrp.Handle_ExprIntrp_SyntaxError_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ExprIntrp.Handle_ExprIntrp_SyntaxError_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ExprIntrp.Handle_ExprIntrp_SyntaxError_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_ExprIntrp_SyntaxError self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _ExprIntrp.Handle_ExprIntrp_SyntaxError_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_ExprIntrp_SyntaxError self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _ExprIntrp.Handle_ExprIntrp_SyntaxError_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_ExprIntrp_SyntaxError self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _ExprIntrp.Handle_ExprIntrp_SyntaxError_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_ExprIntrp_SyntaxError self)
        Reraise(Handle_ExprIntrp_SyntaxError self, Standard_CString const aMessage)
        Reraise(Handle_ExprIntrp_SyntaxError self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _ExprIntrp.Handle_ExprIntrp_SyntaxError_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_ExprIntrp_SyntaxError self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _ExprIntrp.Handle_ExprIntrp_SyntaxError_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_ExprIntrp_SyntaxError self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _ExprIntrp.Handle_ExprIntrp_SyntaxError_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ExprIntrp_SyntaxError self)

        Memory deallocator for transient classes


        """
        return _ExprIntrp.Handle_ExprIntrp_SyntaxError_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ExprIntrp_SyntaxError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ExprIntrp_SyntaxError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ExprIntrp.Handle_ExprIntrp_SyntaxError_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ExprIntrp_SyntaxError self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ExprIntrp_SyntaxError self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ExprIntrp.Handle_ExprIntrp_SyntaxError_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ExprIntrp_SyntaxError self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ExprIntrp.Handle_ExprIntrp_SyntaxError_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ExprIntrp_SyntaxError self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ExprIntrp.Handle_ExprIntrp_SyntaxError_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ExprIntrp_SyntaxError self)

        Increments the reference counter of this object


        """
        return _ExprIntrp.Handle_ExprIntrp_SyntaxError_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ExprIntrp_SyntaxError self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ExprIntrp.Handle_ExprIntrp_SyntaxError_DecrementRefCounter(self, *args)

Handle_ExprIntrp_SyntaxError_swigregister = _ExprIntrp.Handle_ExprIntrp_SyntaxError_swigregister
Handle_ExprIntrp_SyntaxError_swigregister(Handle_ExprIntrp_SyntaxError)

def Handle_ExprIntrp_SyntaxError_DownCast(thing):
    return _ExprIntrp.Handle_ExprIntrp_SyntaxError_DownCast(thing)
Handle_ExprIntrp_SyntaxError_DownCast = _ExprIntrp.Handle_ExprIntrp_SyntaxError_DownCast




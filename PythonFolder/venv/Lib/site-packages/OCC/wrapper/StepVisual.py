# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_StepVisual')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_StepVisual')
    _StepVisual = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_StepVisual', [dirname(__file__)])
        except ImportError:
            import _StepVisual
            return _StepVisual
        try:
            _mod = imp.load_module('_StepVisual', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _StepVisual = swig_import_helper()
    del swig_import_helper
else:
    import _StepVisual
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _StepVisual.delete_SwigPyIterator

    def value(self):
        return _StepVisual.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _StepVisual.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _StepVisual.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _StepVisual.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _StepVisual.SwigPyIterator_equal(self, x)

    def copy(self):
        return _StepVisual.SwigPyIterator_copy(self)

    def next(self):
        return _StepVisual.SwigPyIterator_next(self)

    def __next__(self):
        return _StepVisual.SwigPyIterator___next__(self)

    def previous(self):
        return _StepVisual.SwigPyIterator_previous(self)

    def advance(self, n):
        return _StepVisual.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _StepVisual.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _StepVisual.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _StepVisual.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _StepVisual.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _StepVisual.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _StepVisual.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _StepVisual.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _StepVisual.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_StepVisual.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _StepVisual.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _StepVisual.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepVisual.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _StepVisual.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _StepVisual.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _StepVisual.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _StepVisual.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_StepVisual.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _StepVisual.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _StepVisual.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepVisual.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _StepVisual.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _StepVisual.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _StepVisual.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _StepVisual.ptr_to_number(item)
ptr_to_number = _StepVisual.ptr_to_number

def HashCode(*args):
    return _StepVisual.HashCode(*args)
HashCode = _StepVisual.HashCode

def ptr_equal(a, b):
    return _StepVisual.ptr_equal(a, b)
ptr_equal = _StepVisual.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepBasic
else:
    import StepBasic
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepData
else:
    import StepData
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Interface
else:
    import Interface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import MoniTool
else:
    import MoniTool
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepShape
else:
    import StepShape
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepGeom
else:
    import StepGeom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepRepr
else:
    import StepRepr
del _swig_python_version_info
StepVisual_copCentral = _StepVisual.StepVisual_copCentral
StepVisual_copParallel = _StepVisual.StepVisual_copParallel
StepVisual_mtDot = _StepVisual.StepVisual_mtDot
StepVisual_mtX = _StepVisual.StepVisual_mtX
StepVisual_mtPlus = _StepVisual.StepVisual_mtPlus
StepVisual_mtAsterisk = _StepVisual.StepVisual_mtAsterisk
StepVisual_mtRing = _StepVisual.StepVisual_mtRing
StepVisual_mtSquare = _StepVisual.StepVisual_mtSquare
StepVisual_mtTriangle = _StepVisual.StepVisual_mtTriangle
StepVisual_Null = _StepVisual.StepVisual_Null
StepVisual_ssNegative = _StepVisual.StepVisual_ssNegative
StepVisual_ssPositive = _StepVisual.StepVisual_ssPositive
StepVisual_ssBoth = _StepVisual.StepVisual_ssBoth
StepVisual_tpUp = _StepVisual.StepVisual_tpUp
StepVisual_tpRight = _StepVisual.StepVisual_tpRight
StepVisual_tpDown = _StepVisual.StepVisual_tpDown
StepVisual_tpLeft = _StepVisual.StepVisual_tpLeft
class StepVisual_StyledItem(StepRepr.StepRepr_RepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_StyledItem
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_StyledItem(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_StyledItem self) -> StepVisual_StyledItem

        Returns a StyledItem


        """
        this = _StepVisual.new_StepVisual_StyledItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_StyledItem self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_HArray1OfPresentationStyleAssignment aStyles, Handle_Standard_Transient aItem)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment
        :type aItem: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepVisual.StepVisual_StyledItem_Init(self, *args)


    def SetStyles(self, *args):
        """
        SetStyles(StepVisual_StyledItem self, Handle_StepVisual_HArray1OfPresentationStyleAssignment aStyles)

        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment

        """
        return _StepVisual.StepVisual_StyledItem_SetStyles(self, *args)


    def Styles(self, *args):
        """
        Styles(StepVisual_StyledItem self) -> Handle_StepVisual_HArray1OfPresentationStyleAssignment

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment

        """
        return _StepVisual.StepVisual_StyledItem_Styles(self, *args)


    def StylesValue(self, *args):
        """
        StylesValue(StepVisual_StyledItem self, Standard_Integer const num) -> Handle_StepVisual_PresentationStyleAssignment

        :type num: int
        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationStyleAssignment

        """
        return _StepVisual.StepVisual_StyledItem_StylesValue(self, *args)


    def NbStyles(self, *args):
        """
        NbStyles(StepVisual_StyledItem self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_StyledItem_NbStyles(self, *args)


    def Item(self, *args):
        """
        Item(StepVisual_StyledItem self) -> Handle_StepRepr_RepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.StepVisual_StyledItem_Item(self, *args)


    def SetItem(self, *args):
        """
        SetItem(StepVisual_StyledItem self, Handle_StepRepr_RepresentationItem aItem)
        SetItem(StepVisual_StyledItem self, StepVisual_StyledItemTarget aItem)

        :type aItem: OCC.wrapper.StepVisual.StepVisual_StyledItemTarget

        """
        return _StepVisual.StepVisual_StyledItem_SetItem(self, *args)


    def ItemAP242(self, *args):
        """
        ItemAP242(StepVisual_StyledItem self) -> StepVisual_StyledItemTarget

        :rtype: OCC.wrapper.StepVisual.StepVisual_StyledItemTarget

        """
        return _StepVisual.StepVisual_StyledItem_ItemAP242(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_StyledItem_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_StyledItem_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_StyledItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_StyledItem
StepVisual_StyledItem_swigregister = _StepVisual.StepVisual_StyledItem_swigregister
StepVisual_StyledItem_swigregister(StepVisual_StyledItem)

def StepVisual_StyledItem_get_type_name(*args):
    """
    StepVisual_StyledItem_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_StyledItem_get_type_name(*args)

def StepVisual_StyledItem_get_type_descriptor(*args):
    """
    StepVisual_StyledItem_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_StyledItem_get_type_descriptor(*args)

class StepVisual_AnnotationOccurrence(StepVisual_StyledItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_AnnotationOccurrence
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_AnnotationOccurrence(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_AnnotationOccurrence self) -> StepVisual_AnnotationOccurrence

        Returns a AnnotationOccurrence


        """
        this = _StepVisual.new_StepVisual_AnnotationOccurrence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_AnnotationOccurrence_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_AnnotationOccurrence_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_AnnotationOccurrence_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_AnnotationOccurrence
StepVisual_AnnotationOccurrence_swigregister = _StepVisual.StepVisual_AnnotationOccurrence_swigregister
StepVisual_AnnotationOccurrence_swigregister(StepVisual_AnnotationOccurrence)

def StepVisual_AnnotationOccurrence_get_type_name(*args):
    """
    StepVisual_AnnotationOccurrence_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_AnnotationOccurrence_get_type_name(*args)

def StepVisual_AnnotationOccurrence_get_type_descriptor(*args):
    """
    StepVisual_AnnotationOccurrence_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_AnnotationOccurrence_get_type_descriptor(*args)

class StepVisual_CameraModel(StepGeom.StepGeom_GeometricRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_CameraModel
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_CameraModel(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_CameraModel self) -> StepVisual_CameraModel

        Returns a CameraModel


        """
        this = _StepVisual.new_StepVisual_CameraModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_CameraModel_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_CameraModel_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_CameraModel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_CameraModel
StepVisual_CameraModel_swigregister = _StepVisual.StepVisual_CameraModel_swigregister
StepVisual_CameraModel_swigregister(StepVisual_CameraModel)

def StepVisual_CameraModel_get_type_name(*args):
    """
    StepVisual_CameraModel_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_CameraModel_get_type_name(*args)

def StepVisual_CameraModel_get_type_descriptor(*args):
    """
    StepVisual_CameraModel_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_CameraModel_get_type_descriptor(*args)

class StepVisual_PreDefinedItem(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_PreDefinedItem
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_PreDefinedItem(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_PreDefinedItem self) -> StepVisual_PreDefinedItem

        Returns a PreDefinedItem


        """
        this = _StepVisual.new_StepVisual_PreDefinedItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_PreDefinedItem self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_PreDefinedItem_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(StepVisual_PreDefinedItem self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_PreDefinedItem_SetName(self, *args)


    def Name(self, *args):
        """
        Name(StepVisual_PreDefinedItem self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_PreDefinedItem_Name(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_PreDefinedItem_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_PreDefinedItem_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_PreDefinedItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_PreDefinedItem
StepVisual_PreDefinedItem_swigregister = _StepVisual.StepVisual_PreDefinedItem_swigregister
StepVisual_PreDefinedItem_swigregister(StepVisual_PreDefinedItem)

def StepVisual_PreDefinedItem_get_type_name(*args):
    """
    StepVisual_PreDefinedItem_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_PreDefinedItem_get_type_name(*args)

def StepVisual_PreDefinedItem_get_type_descriptor(*args):
    """
    StepVisual_PreDefinedItem_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_PreDefinedItem_get_type_descriptor(*args)

class StepVisual_Colour(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_Colour
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_Colour(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_Colour self) -> StepVisual_Colour

        Returns a Colour


        """
        this = _StepVisual.new_StepVisual_Colour(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_Colour_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_Colour_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_Colour_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_Colour
StepVisual_Colour_swigregister = _StepVisual.StepVisual_Colour_swigregister
StepVisual_Colour_swigregister(StepVisual_Colour)

def StepVisual_Colour_get_type_name(*args):
    """
    StepVisual_Colour_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_Colour_get_type_name(*args)

def StepVisual_Colour_get_type_descriptor(*args):
    """
    StepVisual_Colour_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_Colour_get_type_descriptor(*args)

class StepVisual_Invisibility(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_Invisibility
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_Invisibility(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_Invisibility self) -> StepVisual_Invisibility

        Returns a Invisibility


        """
        this = _StepVisual.new_StepVisual_Invisibility(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_Invisibility self, Handle_StepVisual_HArray1OfInvisibleItem aInvisibleItems)

        :type aInvisibleItems: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfInvisibleItem

        """
        return _StepVisual.StepVisual_Invisibility_Init(self, *args)


    def SetInvisibleItems(self, *args):
        """
        SetInvisibleItems(StepVisual_Invisibility self, Handle_StepVisual_HArray1OfInvisibleItem aInvisibleItems)

        :type aInvisibleItems: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfInvisibleItem

        """
        return _StepVisual.StepVisual_Invisibility_SetInvisibleItems(self, *args)


    def InvisibleItems(self, *args):
        """
        InvisibleItems(StepVisual_Invisibility self) -> Handle_StepVisual_HArray1OfInvisibleItem

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfInvisibleItem

        """
        return _StepVisual.StepVisual_Invisibility_InvisibleItems(self, *args)


    def InvisibleItemsValue(self, *args):
        """
        InvisibleItemsValue(StepVisual_Invisibility self, Standard_Integer const num) -> StepVisual_InvisibleItem

        :type num: int
        :rtype: OCC.wrapper.StepVisual.StepVisual_InvisibleItem

        """
        return _StepVisual.StepVisual_Invisibility_InvisibleItemsValue(self, *args)


    def NbInvisibleItems(self, *args):
        """
        NbInvisibleItems(StepVisual_Invisibility self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_Invisibility_NbInvisibleItems(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_Invisibility_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_Invisibility_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_Invisibility_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_Invisibility
StepVisual_Invisibility_swigregister = _StepVisual.StepVisual_Invisibility_swigregister
StepVisual_Invisibility_swigregister(StepVisual_Invisibility)

def StepVisual_Invisibility_get_type_name(*args):
    """
    StepVisual_Invisibility_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_Invisibility_get_type_name(*args)

def StepVisual_Invisibility_get_type_descriptor(*args):
    """
    StepVisual_Invisibility_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_Invisibility_get_type_descriptor(*args)

class StepVisual_DraughtingModel(StepRepr.StepRepr_Representation):
    """Representation of STEP entity DraughtingModel"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_DraughtingModel
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_DraughtingModel(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_DraughtingModel self) -> StepVisual_DraughtingModel

        Empty constructor


        """
        this = _StepVisual.new_StepVisual_DraughtingModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_DraughtingModel_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_DraughtingModel_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_DraughtingModel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_DraughtingModel
StepVisual_DraughtingModel_swigregister = _StepVisual.StepVisual_DraughtingModel_swigregister
StepVisual_DraughtingModel_swigregister(StepVisual_DraughtingModel)

def StepVisual_DraughtingModel_get_type_name(*args):
    """
    StepVisual_DraughtingModel_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_DraughtingModel_get_type_name(*args)

def StepVisual_DraughtingModel_get_type_descriptor(*args):
    """
    StepVisual_DraughtingModel_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_DraughtingModel_get_type_descriptor(*args)

class StepVisual_CameraImage(StepRepr.StepRepr_MappedItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_CameraImage
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_CameraImage(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_CameraImage self) -> StepVisual_CameraImage

        Returns a CameraImage


        """
        this = _StepVisual.new_StepVisual_CameraImage(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_CameraImage_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_CameraImage_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_CameraImage_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_CameraImage
StepVisual_CameraImage_swigregister = _StepVisual.StepVisual_CameraImage_swigregister
StepVisual_CameraImage_swigregister(StepVisual_CameraImage)

def StepVisual_CameraImage_get_type_name(*args):
    """
    StepVisual_CameraImage_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_CameraImage_get_type_name(*args)

def StepVisual_CameraImage_get_type_descriptor(*args):
    """
    StepVisual_CameraImage_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_CameraImage_get_type_descriptor(*args)

class StepVisual_PresentationRepresentation(StepRepr.StepRepr_Representation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_PresentationRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_PresentationRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_PresentationRepresentation self) -> StepVisual_PresentationRepresentation

        Returns a PresentationRepresentation


        """
        this = _StepVisual.new_StepVisual_PresentationRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_PresentationRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_PresentationRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_PresentationRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_PresentationRepresentation
StepVisual_PresentationRepresentation_swigregister = _StepVisual.StepVisual_PresentationRepresentation_swigregister
StepVisual_PresentationRepresentation_swigregister(StepVisual_PresentationRepresentation)

def StepVisual_PresentationRepresentation_get_type_name(*args):
    """
    StepVisual_PresentationRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_PresentationRepresentation_get_type_name(*args)

def StepVisual_PresentationRepresentation_get_type_descriptor(*args):
    """
    StepVisual_PresentationRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_PresentationRepresentation_get_type_descriptor(*args)

class StepVisual_CompositeText(StepGeom.StepGeom_GeometricRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_CompositeText
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_CompositeText(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_CompositeText self) -> StepVisual_CompositeText

        Returns a CompositeText


        """
        this = _StepVisual.new_StepVisual_CompositeText(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_CompositeText self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_HArray1OfTextOrCharacter aCollectedText)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aCollectedText: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter

        """
        return _StepVisual.StepVisual_CompositeText_Init(self, *args)


    def SetCollectedText(self, *args):
        """
        SetCollectedText(StepVisual_CompositeText self, Handle_StepVisual_HArray1OfTextOrCharacter aCollectedText)

        :type aCollectedText: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter

        """
        return _StepVisual.StepVisual_CompositeText_SetCollectedText(self, *args)


    def CollectedText(self, *args):
        """
        CollectedText(StepVisual_CompositeText self) -> Handle_StepVisual_HArray1OfTextOrCharacter

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter

        """
        return _StepVisual.StepVisual_CompositeText_CollectedText(self, *args)


    def CollectedTextValue(self, *args):
        """
        CollectedTextValue(StepVisual_CompositeText self, Standard_Integer const num) -> StepVisual_TextOrCharacter

        :type num: int
        :rtype: OCC.wrapper.StepVisual.StepVisual_TextOrCharacter

        """
        return _StepVisual.StepVisual_CompositeText_CollectedTextValue(self, *args)


    def NbCollectedText(self, *args):
        """
        NbCollectedText(StepVisual_CompositeText self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_CompositeText_NbCollectedText(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_CompositeText_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_CompositeText_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_CompositeText_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_CompositeText
StepVisual_CompositeText_swigregister = _StepVisual.StepVisual_CompositeText_swigregister
StepVisual_CompositeText_swigregister(StepVisual_CompositeText)

def StepVisual_CompositeText_get_type_name(*args):
    """
    StepVisual_CompositeText_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_CompositeText_get_type_name(*args)

def StepVisual_CompositeText_get_type_descriptor(*args):
    """
    StepVisual_CompositeText_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_CompositeText_get_type_descriptor(*args)

class StepVisual_AnnotationCurveOccurrence(StepVisual_AnnotationOccurrence):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_AnnotationCurveOccurrence
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_AnnotationCurveOccurrence(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_AnnotationCurveOccurrence self) -> StepVisual_AnnotationCurveOccurrence

        Returns a AnnotationCurveOccurrence


        """
        this = _StepVisual.new_StepVisual_AnnotationCurveOccurrence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_AnnotationCurveOccurrence_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_AnnotationCurveOccurrence_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_AnnotationCurveOccurrence_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_AnnotationCurveOccurrence
StepVisual_AnnotationCurveOccurrence_swigregister = _StepVisual.StepVisual_AnnotationCurveOccurrence_swigregister
StepVisual_AnnotationCurveOccurrence_swigregister(StepVisual_AnnotationCurveOccurrence)

def StepVisual_AnnotationCurveOccurrence_get_type_name(*args):
    """
    StepVisual_AnnotationCurveOccurrence_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_AnnotationCurveOccurrence_get_type_name(*args)

def StepVisual_AnnotationCurveOccurrence_get_type_descriptor(*args):
    """
    StepVisual_AnnotationCurveOccurrence_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_AnnotationCurveOccurrence_get_type_descriptor(*args)

class StepVisual_AnnotationText(StepRepr.StepRepr_MappedItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_AnnotationText
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_AnnotationText(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_AnnotationText self) -> StepVisual_AnnotationText

        Returns a AnnotationText


        """
        this = _StepVisual.new_StepVisual_AnnotationText(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_AnnotationText_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_AnnotationText_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_AnnotationText_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_AnnotationText
StepVisual_AnnotationText_swigregister = _StepVisual.StepVisual_AnnotationText_swigregister
StepVisual_AnnotationText_swigregister(StepVisual_AnnotationText)

def StepVisual_AnnotationText_get_type_name(*args):
    """
    StepVisual_AnnotationText_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_AnnotationText_get_type_name(*args)

def StepVisual_AnnotationText_get_type_descriptor(*args):
    """
    StepVisual_AnnotationText_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_AnnotationText_get_type_descriptor(*args)

class StepVisual_PreDefinedCurveFont(StepVisual_PreDefinedItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_PreDefinedCurveFont
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_PreDefinedCurveFont(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_PreDefinedCurveFont self) -> StepVisual_PreDefinedCurveFont

        Returns a PreDefinedCurveFont


        """
        this = _StepVisual.new_StepVisual_PreDefinedCurveFont(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_PreDefinedCurveFont_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_PreDefinedCurveFont_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_PreDefinedCurveFont_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_PreDefinedCurveFont
StepVisual_PreDefinedCurveFont_swigregister = _StepVisual.StepVisual_PreDefinedCurveFont_swigregister
StepVisual_PreDefinedCurveFont_swigregister(StepVisual_PreDefinedCurveFont)

def StepVisual_PreDefinedCurveFont_get_type_name(*args):
    """
    StepVisual_PreDefinedCurveFont_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_PreDefinedCurveFont_get_type_name(*args)

def StepVisual_PreDefinedCurveFont_get_type_descriptor(*args):
    """
    StepVisual_PreDefinedCurveFont_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_PreDefinedCurveFont_get_type_descriptor(*args)

class StepVisual_CameraModelD3(StepVisual_CameraModel):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_CameraModelD3
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_CameraModelD3(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_CameraModelD3 self) -> StepVisual_CameraModelD3

        Returns a CameraModelD3


        """
        this = _StepVisual.new_StepVisual_CameraModelD3(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_CameraModelD3 self, Handle_TCollection_HAsciiString aName, Handle_StepGeom_Axis2Placement3d aViewReferenceSystem, Handle_StepVisual_ViewVolume aPerspectiveOfVolume)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aViewReferenceSystem: OCC.wrapper.StepVisual.Handle_StepGeom_Axis2Placement3d
        :type aPerspectiveOfVolume: OCC.wrapper.StepVisual.Handle_StepVisual_ViewVolume

        """
        return _StepVisual.StepVisual_CameraModelD3_Init(self, *args)


    def SetViewReferenceSystem(self, *args):
        """
        SetViewReferenceSystem(StepVisual_CameraModelD3 self, Handle_StepGeom_Axis2Placement3d aViewReferenceSystem)

        :type aViewReferenceSystem: OCC.wrapper.StepVisual.Handle_StepGeom_Axis2Placement3d

        """
        return _StepVisual.StepVisual_CameraModelD3_SetViewReferenceSystem(self, *args)


    def ViewReferenceSystem(self, *args):
        """
        ViewReferenceSystem(StepVisual_CameraModelD3 self) -> Handle_StepGeom_Axis2Placement3d

        :rtype: OCC.wrapper.StepVisual.Handle_StepGeom_Axis2Placement3d

        """
        return _StepVisual.StepVisual_CameraModelD3_ViewReferenceSystem(self, *args)


    def SetPerspectiveOfVolume(self, *args):
        """
        SetPerspectiveOfVolume(StepVisual_CameraModelD3 self, Handle_StepVisual_ViewVolume aPerspectiveOfVolume)

        :type aPerspectiveOfVolume: OCC.wrapper.StepVisual.Handle_StepVisual_ViewVolume

        """
        return _StepVisual.StepVisual_CameraModelD3_SetPerspectiveOfVolume(self, *args)


    def PerspectiveOfVolume(self, *args):
        """
        PerspectiveOfVolume(StepVisual_CameraModelD3 self) -> Handle_StepVisual_ViewVolume

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_ViewVolume

        """
        return _StepVisual.StepVisual_CameraModelD3_PerspectiveOfVolume(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_CameraModelD3_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_CameraModelD3_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_CameraModelD3_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_CameraModelD3
StepVisual_CameraModelD3_swigregister = _StepVisual.StepVisual_CameraModelD3_swigregister
StepVisual_CameraModelD3_swigregister(StepVisual_CameraModelD3)

def StepVisual_CameraModelD3_get_type_name(*args):
    """
    StepVisual_CameraModelD3_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_CameraModelD3_get_type_name(*args)

def StepVisual_CameraModelD3_get_type_descriptor(*args):
    """
    StepVisual_CameraModelD3_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_CameraModelD3_get_type_descriptor(*args)

class StepVisual_HArray1OfPresentationStyleAssignment(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_HArray1OfPresentationStyleAssignment
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_HArray1OfPresentationStyleAssignment(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_HArray1OfPresentationStyleAssignment self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepVisual_HArray1OfPresentationStyleAssignment
        __init__(StepVisual_HArray1OfPresentationStyleAssignment self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_StepVisual_PresentationStyleAssignment theValue) -> StepVisual_HArray1OfPresentationStyleAssignment
        __init__(StepVisual_HArray1OfPresentationStyleAssignment self, NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment theOther) -> StepVisual_HArray1OfPresentationStyleAssignment

        :type theOther: OCC.wrapper.StepVisual.StepVisual_Array1OfPresentationStyleAssignment

        """
        this = _StepVisual.new_StepVisual_HArray1OfPresentationStyleAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfPresentationStyleAssignment

        """
        res = _StepVisual.StepVisual_HArray1OfPresentationStyleAssignment_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepVisual_HArray1OfPresentationStyleAssignment self) -> NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfPresentationStyleAssignment

        """
        return _StepVisual.StepVisual_HArray1OfPresentationStyleAssignment_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_HArray1OfPresentationStyleAssignment_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_HArray1OfPresentationStyleAssignment_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_HArray1OfPresentationStyleAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_HArray1OfPresentationStyleAssignment
StepVisual_HArray1OfPresentationStyleAssignment_swigregister = _StepVisual.StepVisual_HArray1OfPresentationStyleAssignment_swigregister
StepVisual_HArray1OfPresentationStyleAssignment_swigregister(StepVisual_HArray1OfPresentationStyleAssignment)

def StepVisual_HArray1OfPresentationStyleAssignment_get_type_name(*args):
    """
    StepVisual_HArray1OfPresentationStyleAssignment_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_HArray1OfPresentationStyleAssignment_get_type_name(*args)

def StepVisual_HArray1OfPresentationStyleAssignment_get_type_descriptor(*args):
    """
    StepVisual_HArray1OfPresentationStyleAssignment_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_HArray1OfPresentationStyleAssignment_get_type_descriptor(*args)

class StepVisual_PresentationArea(StepVisual_PresentationRepresentation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_PresentationArea
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_PresentationArea(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_PresentationArea self) -> StepVisual_PresentationArea

        Returns a PresentationArea


        """
        this = _StepVisual.new_StepVisual_PresentationArea(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_PresentationArea_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_PresentationArea_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_PresentationArea_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_PresentationArea
StepVisual_PresentationArea_swigregister = _StepVisual.StepVisual_PresentationArea_swigregister
StepVisual_PresentationArea_swigregister(StepVisual_PresentationArea)

def StepVisual_PresentationArea_get_type_name(*args):
    """
    StepVisual_PresentationArea_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_PresentationArea_get_type_name(*args)

def StepVisual_PresentationArea_get_type_descriptor(*args):
    """
    StepVisual_PresentationArea_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_PresentationArea_get_type_descriptor(*args)

class StepVisual_ViewVolume(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_ViewVolume
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_ViewVolume(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_ViewVolume self) -> StepVisual_ViewVolume

        Returns a ViewVolume


        """
        this = _StepVisual.new_StepVisual_ViewVolume(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_ViewVolume self, StepVisual_CentralOrParallel const aProjectionType, Handle_StepGeom_CartesianPoint aProjectionPoint, Standard_Real const aViewPlaneDistance, Standard_Real const aFrontPlaneDistance, Standard_Boolean const aFrontPlaneClipping, Standard_Real const aBackPlaneDistance, Standard_Boolean const aBackPlaneClipping, Standard_Boolean const aViewVolumeSidesClipping, Handle_StepVisual_PlanarBox aViewWindow)

        :type aProjectionType: OCC.wrapper.StepVisual.StepVisual_CentralOrParallel
        :type aProjectionPoint: OCC.wrapper.StepVisual.Handle_StepGeom_CartesianPoint
        :type aViewPlaneDistance: float
        :type aFrontPlaneDistance: float
        :type aFrontPlaneClipping: bool
        :type aBackPlaneDistance: float
        :type aBackPlaneClipping: bool
        :type aViewVolumeSidesClipping: bool
        :type aViewWindow: OCC.wrapper.StepVisual.Handle_StepVisual_PlanarBox

        """
        return _StepVisual.StepVisual_ViewVolume_Init(self, *args)


    def SetProjectionType(self, *args):
        """
        SetProjectionType(StepVisual_ViewVolume self, StepVisual_CentralOrParallel const aProjectionType)

        :type aProjectionType: OCC.wrapper.StepVisual.StepVisual_CentralOrParallel

        """
        return _StepVisual.StepVisual_ViewVolume_SetProjectionType(self, *args)


    def ProjectionType(self, *args):
        """
        ProjectionType(StepVisual_ViewVolume self) -> StepVisual_CentralOrParallel

        :rtype: OCC.wrapper.StepVisual.StepVisual_CentralOrParallel

        """
        return _StepVisual.StepVisual_ViewVolume_ProjectionType(self, *args)


    def SetProjectionPoint(self, *args):
        """
        SetProjectionPoint(StepVisual_ViewVolume self, Handle_StepGeom_CartesianPoint aProjectionPoint)

        :type aProjectionPoint: OCC.wrapper.StepVisual.Handle_StepGeom_CartesianPoint

        """
        return _StepVisual.StepVisual_ViewVolume_SetProjectionPoint(self, *args)


    def ProjectionPoint(self, *args):
        """
        ProjectionPoint(StepVisual_ViewVolume self) -> Handle_StepGeom_CartesianPoint

        :rtype: OCC.wrapper.StepVisual.Handle_StepGeom_CartesianPoint

        """
        return _StepVisual.StepVisual_ViewVolume_ProjectionPoint(self, *args)


    def SetViewPlaneDistance(self, *args):
        """
        SetViewPlaneDistance(StepVisual_ViewVolume self, Standard_Real const aViewPlaneDistance)

        :type aViewPlaneDistance: float

        """
        return _StepVisual.StepVisual_ViewVolume_SetViewPlaneDistance(self, *args)


    def ViewPlaneDistance(self, *args):
        """
        ViewPlaneDistance(StepVisual_ViewVolume self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepVisual.StepVisual_ViewVolume_ViewPlaneDistance(self, *args)


    def SetFrontPlaneDistance(self, *args):
        """
        SetFrontPlaneDistance(StepVisual_ViewVolume self, Standard_Real const aFrontPlaneDistance)

        :type aFrontPlaneDistance: float

        """
        return _StepVisual.StepVisual_ViewVolume_SetFrontPlaneDistance(self, *args)


    def FrontPlaneDistance(self, *args):
        """
        FrontPlaneDistance(StepVisual_ViewVolume self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepVisual.StepVisual_ViewVolume_FrontPlaneDistance(self, *args)


    def SetFrontPlaneClipping(self, *args):
        """
        SetFrontPlaneClipping(StepVisual_ViewVolume self, Standard_Boolean const aFrontPlaneClipping)

        :type aFrontPlaneClipping: bool

        """
        return _StepVisual.StepVisual_ViewVolume_SetFrontPlaneClipping(self, *args)


    def FrontPlaneClipping(self, *args):
        """
        FrontPlaneClipping(StepVisual_ViewVolume self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.StepVisual_ViewVolume_FrontPlaneClipping(self, *args)


    def SetBackPlaneDistance(self, *args):
        """
        SetBackPlaneDistance(StepVisual_ViewVolume self, Standard_Real const aBackPlaneDistance)

        :type aBackPlaneDistance: float

        """
        return _StepVisual.StepVisual_ViewVolume_SetBackPlaneDistance(self, *args)


    def BackPlaneDistance(self, *args):
        """
        BackPlaneDistance(StepVisual_ViewVolume self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepVisual.StepVisual_ViewVolume_BackPlaneDistance(self, *args)


    def SetBackPlaneClipping(self, *args):
        """
        SetBackPlaneClipping(StepVisual_ViewVolume self, Standard_Boolean const aBackPlaneClipping)

        :type aBackPlaneClipping: bool

        """
        return _StepVisual.StepVisual_ViewVolume_SetBackPlaneClipping(self, *args)


    def BackPlaneClipping(self, *args):
        """
        BackPlaneClipping(StepVisual_ViewVolume self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.StepVisual_ViewVolume_BackPlaneClipping(self, *args)


    def SetViewVolumeSidesClipping(self, *args):
        """
        SetViewVolumeSidesClipping(StepVisual_ViewVolume self, Standard_Boolean const aViewVolumeSidesClipping)

        :type aViewVolumeSidesClipping: bool

        """
        return _StepVisual.StepVisual_ViewVolume_SetViewVolumeSidesClipping(self, *args)


    def ViewVolumeSidesClipping(self, *args):
        """
        ViewVolumeSidesClipping(StepVisual_ViewVolume self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.StepVisual_ViewVolume_ViewVolumeSidesClipping(self, *args)


    def SetViewWindow(self, *args):
        """
        SetViewWindow(StepVisual_ViewVolume self, Handle_StepVisual_PlanarBox aViewWindow)

        :type aViewWindow: OCC.wrapper.StepVisual.Handle_StepVisual_PlanarBox

        """
        return _StepVisual.StepVisual_ViewVolume_SetViewWindow(self, *args)


    def ViewWindow(self, *args):
        """
        ViewWindow(StepVisual_ViewVolume self) -> Handle_StepVisual_PlanarBox

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PlanarBox

        """
        return _StepVisual.StepVisual_ViewVolume_ViewWindow(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_ViewVolume_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_ViewVolume_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_ViewVolume_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_ViewVolume
StepVisual_ViewVolume_swigregister = _StepVisual.StepVisual_ViewVolume_swigregister
StepVisual_ViewVolume_swigregister(StepVisual_ViewVolume)

def StepVisual_ViewVolume_get_type_name(*args):
    """
    StepVisual_ViewVolume_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_ViewVolume_get_type_name(*args)

def StepVisual_ViewVolume_get_type_descriptor(*args):
    """
    StepVisual_ViewVolume_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_ViewVolume_get_type_descriptor(*args)

class StepVisual_AnnotationFillAreaOccurrence(StepVisual_AnnotationOccurrence):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_AnnotationFillAreaOccurrence
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_AnnotationFillAreaOccurrence(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_AnnotationFillAreaOccurrence self) -> StepVisual_AnnotationFillAreaOccurrence

        Returns a AnnotationFillAreaOccurrence


        """
        this = _StepVisual.new_StepVisual_AnnotationFillAreaOccurrence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_AnnotationFillAreaOccurrence self, Handle_TCollection_HAsciiString theName, Handle_StepVisual_HArray1OfPresentationStyleAssignment theStyles, Handle_Standard_Transient theItem, Handle_StepGeom_GeometricRepresentationItem theFillStyleTarget)

        Initialize all fields (own and inherited)

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment
        :type theItem: OCC.wrapper.Standard.Handle_Standard_Transient
        :type theFillStyleTarget: OCC.wrapper.StepGeom.Handle_StepGeom_GeometricRepresentationItem

        """
        return _StepVisual.StepVisual_AnnotationFillAreaOccurrence_Init(self, *args)


    def FillStyleTarget(self, *args):
        """
        FillStyleTarget(StepVisual_AnnotationFillAreaOccurrence self) -> Handle_StepGeom_GeometricRepresentationItem

        Returns field fill_style_target

        :rtype: OCC.wrapper.StepGeom.Handle_StepGeom_GeometricRepresentationItem

        """
        return _StepVisual.StepVisual_AnnotationFillAreaOccurrence_FillStyleTarget(self, *args)


    def SetFillStyleTarget(self, *args):
        """
        SetFillStyleTarget(StepVisual_AnnotationFillAreaOccurrence self, Handle_StepGeom_GeometricRepresentationItem theTarget)

        Set field fill_style_target

        :type theTarget: OCC.wrapper.StepGeom.Handle_StepGeom_GeometricRepresentationItem

        """
        return _StepVisual.StepVisual_AnnotationFillAreaOccurrence_SetFillStyleTarget(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_AnnotationFillAreaOccurrence_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_AnnotationFillAreaOccurrence_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_AnnotationFillAreaOccurrence_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_AnnotationFillAreaOccurrence
StepVisual_AnnotationFillAreaOccurrence_swigregister = _StepVisual.StepVisual_AnnotationFillAreaOccurrence_swigregister
StepVisual_AnnotationFillAreaOccurrence_swigregister(StepVisual_AnnotationFillAreaOccurrence)

def StepVisual_AnnotationFillAreaOccurrence_get_type_name(*args):
    """
    StepVisual_AnnotationFillAreaOccurrence_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_AnnotationFillAreaOccurrence_get_type_name(*args)

def StepVisual_AnnotationFillAreaOccurrence_get_type_descriptor(*args):
    """
    StepVisual_AnnotationFillAreaOccurrence_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_AnnotationFillAreaOccurrence_get_type_descriptor(*args)

class StepVisual_TessellatedItem(StepGeom.StepGeom_GeometricRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_TessellatedItem
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_TessellatedItem(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_TessellatedItem self) -> StepVisual_TessellatedItem

        Returns a DraughtingCalloutElement select type


        """
        this = _StepVisual.new_StepVisual_TessellatedItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_TessellatedItem_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_TessellatedItem_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_TessellatedItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_TessellatedItem
StepVisual_TessellatedItem_swigregister = _StepVisual.StepVisual_TessellatedItem_swigregister
StepVisual_TessellatedItem_swigregister(StepVisual_TessellatedItem)

def StepVisual_TessellatedItem_get_type_name(*args):
    """
    StepVisual_TessellatedItem_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_TessellatedItem_get_type_name(*args)

def StepVisual_TessellatedItem_get_type_descriptor(*args):
    """
    StepVisual_TessellatedItem_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_TessellatedItem_get_type_descriptor(*args)

class StepVisual_SurfaceStyleSilhouette(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_SurfaceStyleSilhouette
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_SurfaceStyleSilhouette(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_SurfaceStyleSilhouette self) -> StepVisual_SurfaceStyleSilhouette

        Returns a SurfaceStyleSilhouette


        """
        this = _StepVisual.new_StepVisual_SurfaceStyleSilhouette(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_SurfaceStyleSilhouette self, Handle_StepVisual_CurveStyle aStyleOfSilhouette)

        :type aStyleOfSilhouette: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.StepVisual_SurfaceStyleSilhouette_Init(self, *args)


    def SetStyleOfSilhouette(self, *args):
        """
        SetStyleOfSilhouette(StepVisual_SurfaceStyleSilhouette self, Handle_StepVisual_CurveStyle aStyleOfSilhouette)

        :type aStyleOfSilhouette: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.StepVisual_SurfaceStyleSilhouette_SetStyleOfSilhouette(self, *args)


    def StyleOfSilhouette(self, *args):
        """
        StyleOfSilhouette(StepVisual_SurfaceStyleSilhouette self) -> Handle_StepVisual_CurveStyle

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.StepVisual_SurfaceStyleSilhouette_StyleOfSilhouette(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_SurfaceStyleSilhouette_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_SurfaceStyleSilhouette_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_SurfaceStyleSilhouette_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_SurfaceStyleSilhouette
StepVisual_SurfaceStyleSilhouette_swigregister = _StepVisual.StepVisual_SurfaceStyleSilhouette_swigregister
StepVisual_SurfaceStyleSilhouette_swigregister(StepVisual_SurfaceStyleSilhouette)

def StepVisual_SurfaceStyleSilhouette_get_type_name(*args):
    """
    StepVisual_SurfaceStyleSilhouette_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_SurfaceStyleSilhouette_get_type_name(*args)

def StepVisual_SurfaceStyleSilhouette_get_type_descriptor(*args):
    """
    StepVisual_SurfaceStyleSilhouette_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_SurfaceStyleSilhouette_get_type_descriptor(*args)

class StepVisual_SurfaceStyleBoundary(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_SurfaceStyleBoundary
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_SurfaceStyleBoundary(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_SurfaceStyleBoundary self) -> StepVisual_SurfaceStyleBoundary

        Returns a SurfaceStyleBoundary


        """
        this = _StepVisual.new_StepVisual_SurfaceStyleBoundary(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_SurfaceStyleBoundary self, Handle_StepVisual_CurveStyle aStyleOfBoundary)

        :type aStyleOfBoundary: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.StepVisual_SurfaceStyleBoundary_Init(self, *args)


    def SetStyleOfBoundary(self, *args):
        """
        SetStyleOfBoundary(StepVisual_SurfaceStyleBoundary self, Handle_StepVisual_CurveStyle aStyleOfBoundary)

        :type aStyleOfBoundary: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.StepVisual_SurfaceStyleBoundary_SetStyleOfBoundary(self, *args)


    def StyleOfBoundary(self, *args):
        """
        StyleOfBoundary(StepVisual_SurfaceStyleBoundary self) -> Handle_StepVisual_CurveStyle

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.StepVisual_SurfaceStyleBoundary_StyleOfBoundary(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_SurfaceStyleBoundary_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_SurfaceStyleBoundary_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_SurfaceStyleBoundary_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_SurfaceStyleBoundary
StepVisual_SurfaceStyleBoundary_swigregister = _StepVisual.StepVisual_SurfaceStyleBoundary_swigregister
StepVisual_SurfaceStyleBoundary_swigregister(StepVisual_SurfaceStyleBoundary)

def StepVisual_SurfaceStyleBoundary_get_type_name(*args):
    """
    StepVisual_SurfaceStyleBoundary_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_SurfaceStyleBoundary_get_type_name(*args)

def StepVisual_SurfaceStyleBoundary_get_type_descriptor(*args):
    """
    StepVisual_SurfaceStyleBoundary_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_SurfaceStyleBoundary_get_type_descriptor(*args)

class StepVisual_SurfaceSideStyle(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_SurfaceSideStyle
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_SurfaceSideStyle(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_SurfaceSideStyle self) -> StepVisual_SurfaceSideStyle

        Returns a SurfaceSideStyle


        """
        this = _StepVisual.new_StepVisual_SurfaceSideStyle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_SurfaceSideStyle self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_HArray1OfSurfaceStyleElementSelect aStyles)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect

        """
        return _StepVisual.StepVisual_SurfaceSideStyle_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(StepVisual_SurfaceSideStyle self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_SurfaceSideStyle_SetName(self, *args)


    def Name(self, *args):
        """
        Name(StepVisual_SurfaceSideStyle self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_SurfaceSideStyle_Name(self, *args)


    def SetStyles(self, *args):
        """
        SetStyles(StepVisual_SurfaceSideStyle self, Handle_StepVisual_HArray1OfSurfaceStyleElementSelect aStyles)

        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect

        """
        return _StepVisual.StepVisual_SurfaceSideStyle_SetStyles(self, *args)


    def Styles(self, *args):
        """
        Styles(StepVisual_SurfaceSideStyle self) -> Handle_StepVisual_HArray1OfSurfaceStyleElementSelect

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect

        """
        return _StepVisual.StepVisual_SurfaceSideStyle_Styles(self, *args)


    def StylesValue(self, *args):
        """
        StylesValue(StepVisual_SurfaceSideStyle self, Standard_Integer const num) -> StepVisual_SurfaceStyleElementSelect

        :type num: int
        :rtype: OCC.wrapper.StepVisual.StepVisual_SurfaceStyleElementSelect

        """
        return _StepVisual.StepVisual_SurfaceSideStyle_StylesValue(self, *args)


    def NbStyles(self, *args):
        """
        NbStyles(StepVisual_SurfaceSideStyle self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_SurfaceSideStyle_NbStyles(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_SurfaceSideStyle_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_SurfaceSideStyle_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_SurfaceSideStyle_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_SurfaceSideStyle
StepVisual_SurfaceSideStyle_swigregister = _StepVisual.StepVisual_SurfaceSideStyle_swigregister
StepVisual_SurfaceSideStyle_swigregister(StepVisual_SurfaceSideStyle)

def StepVisual_SurfaceSideStyle_get_type_name(*args):
    """
    StepVisual_SurfaceSideStyle_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_SurfaceSideStyle_get_type_name(*args)

def StepVisual_SurfaceSideStyle_get_type_descriptor(*args):
    """
    StepVisual_SurfaceSideStyle_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_SurfaceSideStyle_get_type_descriptor(*args)

class StepVisual_CameraUsage(StepRepr.StepRepr_RepresentationMap):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_CameraUsage
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_CameraUsage(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_CameraUsage self) -> StepVisual_CameraUsage

        Returns a CameraUsage


        """
        this = _StepVisual.new_StepVisual_CameraUsage(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_CameraUsage_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_CameraUsage_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_CameraUsage_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_CameraUsage
StepVisual_CameraUsage_swigregister = _StepVisual.StepVisual_CameraUsage_swigregister
StepVisual_CameraUsage_swigregister(StepVisual_CameraUsage)

def StepVisual_CameraUsage_get_type_name(*args):
    """
    StepVisual_CameraUsage_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_CameraUsage_get_type_name(*args)

def StepVisual_CameraUsage_get_type_descriptor(*args):
    """
    StepVisual_CameraUsage_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_CameraUsage_get_type_descriptor(*args)

class StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem(StepVisual_AnnotationCurveOccurrence):
    """
    Added for Dimensional Tolerances
    Complex STEP entity AnnotationCurveOccurrence & AnnotationOccurrence & GeometricRepresentationItem & RepresentationItem & StyledItem
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self) -> StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem

        Added for Dimensional Tolerances
        Complex STEP entity AnnotationCurveOccurrence & AnnotationOccurrence & GeometricRepresentationItem & RepresentationItem & StyledItem
        """
        this = _StepVisual.new_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem
StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_swigregister = _StepVisual.StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_swigregister
StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_swigregister(StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem)

def StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_get_type_name(*args):
    """
    StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_get_type_name(*args)

def StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_get_type_descriptor(*args):
    """
    StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_get_type_descriptor(*args)

class StepVisual_MarkerMember(StepData.StepData_SelectInt):
    """
    Defines MarkerType as unique member of MarkerSelect
    Works with an EnumTool
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_MarkerMember
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_MarkerMember(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_MarkerMember self) -> StepVisual_MarkerMember

        Defines MarkerType as unique member of MarkerSelect
        Works with an EnumTool
        """
        this = _StepVisual.new_StepVisual_MarkerMember(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def HasName(self, *args):
        """
        HasName(StepVisual_MarkerMember self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.StepVisual_MarkerMember_HasName(self, *args)


    def Name(self, *args):
        """
        Name(StepVisual_MarkerMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepVisual.StepVisual_MarkerMember_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepVisual_MarkerMember self, Standard_CString const name) -> Standard_Boolean

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.StepVisual_MarkerMember_SetName(self, *args)


    def EnumText(self, *args):
        """
        EnumText(StepVisual_MarkerMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepVisual.StepVisual_MarkerMember_EnumText(self, *args)


    def SetEnumText(self, *args):
        """
        SetEnumText(StepVisual_MarkerMember self, Standard_Integer const val, Standard_CString const text)

        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepVisual.StepVisual_MarkerMember_SetEnumText(self, *args)


    def SetValue(self, *args):
        """
        SetValue(StepVisual_MarkerMember self, StepVisual_MarkerType const val)

        :type val: OCC.wrapper.StepVisual.StepVisual_MarkerType

        """
        return _StepVisual.StepVisual_MarkerMember_SetValue(self, *args)


    def Value(self, *args):
        """
        Value(StepVisual_MarkerMember self) -> StepVisual_MarkerType

        :rtype: OCC.wrapper.StepVisual.StepVisual_MarkerType

        """
        return _StepVisual.StepVisual_MarkerMember_Value(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_MarkerMember_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_MarkerMember_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_MarkerMember_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_MarkerMember
StepVisual_MarkerMember_swigregister = _StepVisual.StepVisual_MarkerMember_swigregister
StepVisual_MarkerMember_swigregister(StepVisual_MarkerMember)

def StepVisual_MarkerMember_get_type_name(*args):
    """
    StepVisual_MarkerMember_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_MarkerMember_get_type_name(*args)

def StepVisual_MarkerMember_get_type_descriptor(*args):
    """
    StepVisual_MarkerMember_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_MarkerMember_get_type_descriptor(*args)

class StepVisual_CameraModelD3MultiClippingUnion(StepGeom.StepGeom_GeometricRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_CameraModelD3MultiClippingUnion
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_CameraModelD3MultiClippingUnion(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_CameraModelD3MultiClippingUnion self) -> StepVisual_CameraModelD3MultiClippingUnion

        Returns a StepVisual_CameraModelD3MultiClippingUnion


        """
        this = _StepVisual.new_StepVisual_CameraModelD3MultiClippingUnion(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_CameraModelD3MultiClippingUnion self, Handle_TCollection_HAsciiString theName, Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect theShapeClipping)

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theShapeClipping: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect

        """
        return _StepVisual.StepVisual_CameraModelD3MultiClippingUnion_Init(self, *args)


    def SetShapeClipping(self, *args):
        """
        SetShapeClipping(StepVisual_CameraModelD3MultiClippingUnion self, Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect theShapeClipping)

        :type theShapeClipping: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect

        """
        return _StepVisual.StepVisual_CameraModelD3MultiClippingUnion_SetShapeClipping(self, *args)


    def ShapeClipping(self, *args):
        """
        ShapeClipping(StepVisual_CameraModelD3MultiClippingUnion self) -> Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect

        """
        return _StepVisual.StepVisual_CameraModelD3MultiClippingUnion_ShapeClipping(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_CameraModelD3MultiClippingUnion_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_CameraModelD3MultiClippingUnion_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_CameraModelD3MultiClippingUnion_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_CameraModelD3MultiClippingUnion
StepVisual_CameraModelD3MultiClippingUnion_swigregister = _StepVisual.StepVisual_CameraModelD3MultiClippingUnion_swigregister
StepVisual_CameraModelD3MultiClippingUnion_swigregister(StepVisual_CameraModelD3MultiClippingUnion)

def StepVisual_CameraModelD3MultiClippingUnion_get_type_name(*args):
    """
    StepVisual_CameraModelD3MultiClippingUnion_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_CameraModelD3MultiClippingUnion_get_type_name(*args)

def StepVisual_CameraModelD3MultiClippingUnion_get_type_descriptor(*args):
    """
    StepVisual_CameraModelD3MultiClippingUnion_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_CameraModelD3MultiClippingUnion_get_type_descriptor(*args)

class StepVisual_DraughtingCalloutElement(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepVisual_DraughtingCalloutElement self) -> StepVisual_DraughtingCalloutElement

        Returns a DraughtingCalloutElement select type


        """
        this = _StepVisual.new_StepVisual_DraughtingCalloutElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepVisual_DraughtingCalloutElement self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a IdAttributeSelect Kind Entity that is :
        1 -> AnnotationCurveOccurrence
        2 -> AnnotationTextOccurrence
        3 -> TessellatedAnnotationOccurrence
        4 -> AnnotationFillAreaOccurrence
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_DraughtingCalloutElement_CaseNum(self, *args)


    def AnnotationCurveOccurrence(self, *args):
        """
        AnnotationCurveOccurrence(StepVisual_DraughtingCalloutElement self) -> Handle_StepVisual_AnnotationCurveOccurrence

        returns Value as a AnnotationCurveOccurrence (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_AnnotationCurveOccurrence

        """
        return _StepVisual.StepVisual_DraughtingCalloutElement_AnnotationCurveOccurrence(self, *args)


    def AnnotationTextOccurrence(self, *args):
        """
        AnnotationTextOccurrence(StepVisual_DraughtingCalloutElement self) -> Handle_StepVisual_AnnotationTextOccurrence

        returns Value as a AnnotationTextOccurrence

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_AnnotationTextOccurrence

        """
        return _StepVisual.StepVisual_DraughtingCalloutElement_AnnotationTextOccurrence(self, *args)


    def TessellatedAnnotationOccurrence(self, *args):
        """
        TessellatedAnnotationOccurrence(StepVisual_DraughtingCalloutElement self) -> Handle_StepVisual_TessellatedAnnotationOccurrence

        returns Value as a TessellatedAnnotationOccurrence

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence

        """
        return _StepVisual.StepVisual_DraughtingCalloutElement_TessellatedAnnotationOccurrence(self, *args)


    def AnnotationFillAreaOccurrence(self, *args):
        """
        AnnotationFillAreaOccurrence(StepVisual_DraughtingCalloutElement self) -> Handle_StepVisual_AnnotationFillAreaOccurrence

        returns Value as a AnnotationFillAreaOccurrence

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence

        """
        return _StepVisual.StepVisual_DraughtingCalloutElement_AnnotationFillAreaOccurrence(self, *args)

    __swig_destroy__ = _StepVisual.delete_StepVisual_DraughtingCalloutElement
StepVisual_DraughtingCalloutElement_swigregister = _StepVisual.StepVisual_DraughtingCalloutElement_swigregister
StepVisual_DraughtingCalloutElement_swigregister(StepVisual_DraughtingCalloutElement)

class StepVisual_SurfaceStyleUsage(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_SurfaceStyleUsage
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_SurfaceStyleUsage(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_SurfaceStyleUsage self) -> StepVisual_SurfaceStyleUsage

        Returns a SurfaceStyleUsage


        """
        this = _StepVisual.new_StepVisual_SurfaceStyleUsage(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_SurfaceStyleUsage self, StepVisual_SurfaceSide const aSide, Handle_StepVisual_SurfaceSideStyle aStyle)

        :type aSide: OCC.wrapper.StepVisual.StepVisual_SurfaceSide
        :type aStyle: OCC.wrapper.StepVisual.Handle_StepVisual_SurfaceSideStyle

        """
        return _StepVisual.StepVisual_SurfaceStyleUsage_Init(self, *args)


    def SetSide(self, *args):
        """
        SetSide(StepVisual_SurfaceStyleUsage self, StepVisual_SurfaceSide const aSide)

        :type aSide: OCC.wrapper.StepVisual.StepVisual_SurfaceSide

        """
        return _StepVisual.StepVisual_SurfaceStyleUsage_SetSide(self, *args)


    def Side(self, *args):
        """
        Side(StepVisual_SurfaceStyleUsage self) -> StepVisual_SurfaceSide

        :rtype: OCC.wrapper.StepVisual.StepVisual_SurfaceSide

        """
        return _StepVisual.StepVisual_SurfaceStyleUsage_Side(self, *args)


    def SetStyle(self, *args):
        """
        SetStyle(StepVisual_SurfaceStyleUsage self, Handle_StepVisual_SurfaceSideStyle aStyle)

        :type aStyle: OCC.wrapper.StepVisual.Handle_StepVisual_SurfaceSideStyle

        """
        return _StepVisual.StepVisual_SurfaceStyleUsage_SetStyle(self, *args)


    def Style(self, *args):
        """
        Style(StepVisual_SurfaceStyleUsage self) -> Handle_StepVisual_SurfaceSideStyle

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_SurfaceSideStyle

        """
        return _StepVisual.StepVisual_SurfaceStyleUsage_Style(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_SurfaceStyleUsage_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_SurfaceStyleUsage_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_SurfaceStyleUsage_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_SurfaceStyleUsage
StepVisual_SurfaceStyleUsage_swigregister = _StepVisual.StepVisual_SurfaceStyleUsage_swigregister
StepVisual_SurfaceStyleUsage_swigregister(StepVisual_SurfaceStyleUsage)

def StepVisual_SurfaceStyleUsage_get_type_name(*args):
    """
    StepVisual_SurfaceStyleUsage_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_SurfaceStyleUsage_get_type_name(*args)

def StepVisual_SurfaceStyleUsage_get_type_descriptor(*args):
    """
    StepVisual_SurfaceStyleUsage_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_SurfaceStyleUsage_get_type_descriptor(*args)

class StepVisual_PresentationStyleSelect(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepVisual_PresentationStyleSelect self) -> StepVisual_PresentationStyleSelect

        Returns a PresentationStyleSelect SelectType


        """
        this = _StepVisual.new_StepVisual_PresentationStyleSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepVisual_PresentationStyleSelect self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a PresentationStyleSelect Kind Entity that is :
        1 -> PointStyle
        2 -> CurveStyle
        3 -> SurfaceStyleUsage
        4 -> SymbolStyle
        5 -> FillAreaStyle
        6 -> TextStyle
        7 -> NullStyle
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_PresentationStyleSelect_CaseNum(self, *args)


    def PointStyle(self, *args):
        """
        PointStyle(StepVisual_PresentationStyleSelect self) -> Handle_StepVisual_PointStyle

        returns Value as a PointStyle (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PointStyle

        """
        return _StepVisual.StepVisual_PresentationStyleSelect_PointStyle(self, *args)


    def CurveStyle(self, *args):
        """
        CurveStyle(StepVisual_PresentationStyleSelect self) -> Handle_StepVisual_CurveStyle

        returns Value as a CurveStyle (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.StepVisual_PresentationStyleSelect_CurveStyle(self, *args)


    def NullStyle(self, *args):
        """
        NullStyle(StepVisual_PresentationStyleSelect self) -> Handle_StepVisual_NullStyleMember

        returns Value as a NullStyleMember (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_NullStyleMember

        """
        return _StepVisual.StepVisual_PresentationStyleSelect_NullStyle(self, *args)


    def SurfaceStyleUsage(self, *args):
        """
        SurfaceStyleUsage(StepVisual_PresentationStyleSelect self) -> Handle_StepVisual_SurfaceStyleUsage

        returns Value as a SurfaceStyleUsage (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_SurfaceStyleUsage

        """
        return _StepVisual.StepVisual_PresentationStyleSelect_SurfaceStyleUsage(self, *args)

    __swig_destroy__ = _StepVisual.delete_StepVisual_PresentationStyleSelect
StepVisual_PresentationStyleSelect_swigregister = _StepVisual.StepVisual_PresentationStyleSelect_swigregister
StepVisual_PresentationStyleSelect_swigregister(StepVisual_PresentationStyleSelect)

class StepVisual_TextStyleForDefinedFont(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_TextStyleForDefinedFont
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_TextStyleForDefinedFont(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_TextStyleForDefinedFont self) -> StepVisual_TextStyleForDefinedFont

        Returns a TextStyleForDefinedFont


        """
        this = _StepVisual.new_StepVisual_TextStyleForDefinedFont(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_TextStyleForDefinedFont self, Handle_StepVisual_Colour aTextColour)

        :type aTextColour: OCC.wrapper.StepVisual.Handle_StepVisual_Colour

        """
        return _StepVisual.StepVisual_TextStyleForDefinedFont_Init(self, *args)


    def SetTextColour(self, *args):
        """
        SetTextColour(StepVisual_TextStyleForDefinedFont self, Handle_StepVisual_Colour aTextColour)

        :type aTextColour: OCC.wrapper.StepVisual.Handle_StepVisual_Colour

        """
        return _StepVisual.StepVisual_TextStyleForDefinedFont_SetTextColour(self, *args)


    def TextColour(self, *args):
        """
        TextColour(StepVisual_TextStyleForDefinedFont self) -> Handle_StepVisual_Colour

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_Colour

        """
        return _StepVisual.StepVisual_TextStyleForDefinedFont_TextColour(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_TextStyleForDefinedFont_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_TextStyleForDefinedFont_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_TextStyleForDefinedFont_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_TextStyleForDefinedFont
StepVisual_TextStyleForDefinedFont_swigregister = _StepVisual.StepVisual_TextStyleForDefinedFont_swigregister
StepVisual_TextStyleForDefinedFont_swigregister(StepVisual_TextStyleForDefinedFont)

def StepVisual_TextStyleForDefinedFont_get_type_name(*args):
    """
    StepVisual_TextStyleForDefinedFont_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_TextStyleForDefinedFont_get_type_name(*args)

def StepVisual_TextStyleForDefinedFont_get_type_descriptor(*args):
    """
    StepVisual_TextStyleForDefinedFont_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_TextStyleForDefinedFont_get_type_descriptor(*args)

class StepVisual_HArray1OfSurfaceStyleElementSelect(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_HArray1OfSurfaceStyleElementSelect
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_HArray1OfSurfaceStyleElementSelect(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_HArray1OfSurfaceStyleElementSelect self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepVisual_HArray1OfSurfaceStyleElementSelect
        __init__(StepVisual_HArray1OfSurfaceStyleElementSelect self, Standard_Integer const theLower, Standard_Integer const theUpper, StepVisual_SurfaceStyleElementSelect theValue) -> StepVisual_HArray1OfSurfaceStyleElementSelect
        __init__(StepVisual_HArray1OfSurfaceStyleElementSelect self, NCollection_Array1_StepVisual_SurfaceStyleElementSelect theOther) -> StepVisual_HArray1OfSurfaceStyleElementSelect

        :type theOther: OCC.wrapper.StepVisual.StepVisual_Array1OfSurfaceStyleElementSelect

        """
        this = _StepVisual.new_StepVisual_HArray1OfSurfaceStyleElementSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfSurfaceStyleElementSelect

        """
        res = _StepVisual.StepVisual_HArray1OfSurfaceStyleElementSelect_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepVisual_HArray1OfSurfaceStyleElementSelect self) -> NCollection_Array1_StepVisual_SurfaceStyleElementSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfSurfaceStyleElementSelect

        """
        return _StepVisual.StepVisual_HArray1OfSurfaceStyleElementSelect_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_HArray1OfSurfaceStyleElementSelect_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_HArray1OfSurfaceStyleElementSelect_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_HArray1OfSurfaceStyleElementSelect_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_HArray1OfSurfaceStyleElementSelect
StepVisual_HArray1OfSurfaceStyleElementSelect_swigregister = _StepVisual.StepVisual_HArray1OfSurfaceStyleElementSelect_swigregister
StepVisual_HArray1OfSurfaceStyleElementSelect_swigregister(StepVisual_HArray1OfSurfaceStyleElementSelect)

def StepVisual_HArray1OfSurfaceStyleElementSelect_get_type_name(*args):
    """
    StepVisual_HArray1OfSurfaceStyleElementSelect_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_HArray1OfSurfaceStyleElementSelect_get_type_name(*args)

def StepVisual_HArray1OfSurfaceStyleElementSelect_get_type_descriptor(*args):
    """
    StepVisual_HArray1OfSurfaceStyleElementSelect_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_HArray1OfSurfaceStyleElementSelect_get_type_descriptor(*args)

class StepVisual_SurfaceStyleControlGrid(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_SurfaceStyleControlGrid
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_SurfaceStyleControlGrid(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_SurfaceStyleControlGrid self) -> StepVisual_SurfaceStyleControlGrid

        Returns a SurfaceStyleControlGrid


        """
        this = _StepVisual.new_StepVisual_SurfaceStyleControlGrid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_SurfaceStyleControlGrid self, Handle_StepVisual_CurveStyle aStyleOfControlGrid)

        :type aStyleOfControlGrid: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.StepVisual_SurfaceStyleControlGrid_Init(self, *args)


    def SetStyleOfControlGrid(self, *args):
        """
        SetStyleOfControlGrid(StepVisual_SurfaceStyleControlGrid self, Handle_StepVisual_CurveStyle aStyleOfControlGrid)

        :type aStyleOfControlGrid: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.StepVisual_SurfaceStyleControlGrid_SetStyleOfControlGrid(self, *args)


    def StyleOfControlGrid(self, *args):
        """
        StyleOfControlGrid(StepVisual_SurfaceStyleControlGrid self) -> Handle_StepVisual_CurveStyle

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.StepVisual_SurfaceStyleControlGrid_StyleOfControlGrid(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_SurfaceStyleControlGrid_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_SurfaceStyleControlGrid_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_SurfaceStyleControlGrid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_SurfaceStyleControlGrid
StepVisual_SurfaceStyleControlGrid_swigregister = _StepVisual.StepVisual_SurfaceStyleControlGrid_swigregister
StepVisual_SurfaceStyleControlGrid_swigregister(StepVisual_SurfaceStyleControlGrid)

def StepVisual_SurfaceStyleControlGrid_get_type_name(*args):
    """
    StepVisual_SurfaceStyleControlGrid_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_SurfaceStyleControlGrid_get_type_name(*args)

def StepVisual_SurfaceStyleControlGrid_get_type_descriptor(*args):
    """
    StepVisual_SurfaceStyleControlGrid_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_SurfaceStyleControlGrid_get_type_descriptor(*args)

class StepVisual_TextLiteral(StepGeom.StepGeom_GeometricRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_TextLiteral
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_TextLiteral(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_TextLiteral self) -> StepVisual_TextLiteral

        Returns a TextLiteral


        """
        this = _StepVisual.new_StepVisual_TextLiteral(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_TextLiteral self, Handle_TCollection_HAsciiString aName, Handle_TCollection_HAsciiString aLiteral, StepGeom_Axis2Placement aPlacement, Handle_TCollection_HAsciiString aAlignment, StepVisual_TextPath const aPath, StepVisual_FontSelect aFont)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aLiteral: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPlacement: OCC.wrapper.StepGeom.StepGeom_Axis2Placement
        :type aAlignment: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPath: OCC.wrapper.StepVisual.StepVisual_TextPath
        :type aFont: OCC.wrapper.StepVisual.StepVisual_FontSelect

        """
        return _StepVisual.StepVisual_TextLiteral_Init(self, *args)


    def SetLiteral(self, *args):
        """
        SetLiteral(StepVisual_TextLiteral self, Handle_TCollection_HAsciiString aLiteral)

        :type aLiteral: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_TextLiteral_SetLiteral(self, *args)


    def Literal(self, *args):
        """
        Literal(StepVisual_TextLiteral self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_TextLiteral_Literal(self, *args)


    def SetPlacement(self, *args):
        """
        SetPlacement(StepVisual_TextLiteral self, StepGeom_Axis2Placement aPlacement)

        :type aPlacement: OCC.wrapper.StepGeom.StepGeom_Axis2Placement

        """
        return _StepVisual.StepVisual_TextLiteral_SetPlacement(self, *args)


    def Placement(self, *args):
        """
        Placement(StepVisual_TextLiteral self) -> StepGeom_Axis2Placement

        :rtype: OCC.wrapper.StepGeom.StepGeom_Axis2Placement

        """
        return _StepVisual.StepVisual_TextLiteral_Placement(self, *args)


    def SetAlignment(self, *args):
        """
        SetAlignment(StepVisual_TextLiteral self, Handle_TCollection_HAsciiString aAlignment)

        :type aAlignment: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_TextLiteral_SetAlignment(self, *args)


    def Alignment(self, *args):
        """
        Alignment(StepVisual_TextLiteral self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_TextLiteral_Alignment(self, *args)


    def SetPath(self, *args):
        """
        SetPath(StepVisual_TextLiteral self, StepVisual_TextPath const aPath)

        :type aPath: OCC.wrapper.StepVisual.StepVisual_TextPath

        """
        return _StepVisual.StepVisual_TextLiteral_SetPath(self, *args)


    def Path(self, *args):
        """
        Path(StepVisual_TextLiteral self) -> StepVisual_TextPath

        :rtype: OCC.wrapper.StepVisual.StepVisual_TextPath

        """
        return _StepVisual.StepVisual_TextLiteral_Path(self, *args)


    def SetFont(self, *args):
        """
        SetFont(StepVisual_TextLiteral self, StepVisual_FontSelect aFont)

        :type aFont: OCC.wrapper.StepVisual.StepVisual_FontSelect

        """
        return _StepVisual.StepVisual_TextLiteral_SetFont(self, *args)


    def Font(self, *args):
        """
        Font(StepVisual_TextLiteral self) -> StepVisual_FontSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_FontSelect

        """
        return _StepVisual.StepVisual_TextLiteral_Font(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_TextLiteral_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_TextLiteral_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_TextLiteral_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_TextLiteral
StepVisual_TextLiteral_swigregister = _StepVisual.StepVisual_TextLiteral_swigregister
StepVisual_TextLiteral_swigregister(StepVisual_TextLiteral)

def StepVisual_TextLiteral_get_type_name(*args):
    """
    StepVisual_TextLiteral_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_TextLiteral_get_type_name(*args)

def StepVisual_TextLiteral_get_type_descriptor(*args):
    """
    StepVisual_TextLiteral_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_TextLiteral_get_type_descriptor(*args)

class StepVisual_PreDefinedTextFont(StepVisual_PreDefinedItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_PreDefinedTextFont
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_PreDefinedTextFont(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_PreDefinedTextFont self) -> StepVisual_PreDefinedTextFont

        Returns a PreDefinedTextFont


        """
        this = _StepVisual.new_StepVisual_PreDefinedTextFont(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_PreDefinedTextFont_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_PreDefinedTextFont_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_PreDefinedTextFont_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_PreDefinedTextFont
StepVisual_PreDefinedTextFont_swigregister = _StepVisual.StepVisual_PreDefinedTextFont_swigregister
StepVisual_PreDefinedTextFont_swigregister(StepVisual_PreDefinedTextFont)

def StepVisual_PreDefinedTextFont_get_type_name(*args):
    """
    StepVisual_PreDefinedTextFont_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_PreDefinedTextFont_get_type_name(*args)

def StepVisual_PreDefinedTextFont_get_type_descriptor(*args):
    """
    StepVisual_PreDefinedTextFont_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_PreDefinedTextFont_get_type_descriptor(*args)

class StepVisual_MechanicalDesignGeometricPresentationRepresentation(StepVisual_PresentationRepresentation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_MechanicalDesignGeometricPresentationRepresentation self) -> StepVisual_MechanicalDesignGeometricPresentationRepresentation

        Returns a MechanicalDesignGeometricPresentationRepresentation


        """
        this = _StepVisual.new_StepVisual_MechanicalDesignGeometricPresentationRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_MechanicalDesignGeometricPresentationRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_MechanicalDesignGeometricPresentationRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_MechanicalDesignGeometricPresentationRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_MechanicalDesignGeometricPresentationRepresentation
StepVisual_MechanicalDesignGeometricPresentationRepresentation_swigregister = _StepVisual.StepVisual_MechanicalDesignGeometricPresentationRepresentation_swigregister
StepVisual_MechanicalDesignGeometricPresentationRepresentation_swigregister(StepVisual_MechanicalDesignGeometricPresentationRepresentation)

def StepVisual_MechanicalDesignGeometricPresentationRepresentation_get_type_name(*args):
    """
    StepVisual_MechanicalDesignGeometricPresentationRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_MechanicalDesignGeometricPresentationRepresentation_get_type_name(*args)

def StepVisual_MechanicalDesignGeometricPresentationRepresentation_get_type_descriptor(*args):
    """
    StepVisual_MechanicalDesignGeometricPresentationRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_MechanicalDesignGeometricPresentationRepresentation_get_type_descriptor(*args)

class StepVisual_AnnotationPlaneElement(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepVisual_AnnotationPlaneElement self) -> StepVisual_AnnotationPlaneElement

        Returns a AnnotationPlaneElement select type


        """
        this = _StepVisual.new_StepVisual_AnnotationPlaneElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepVisual_AnnotationPlaneElement self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a IdAttributeSelect Kind Entity that is :
        1 -> DraughtingCallout
        2 -> StyledItem
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_AnnotationPlaneElement_CaseNum(self, *args)


    def DraughtingCallout(self, *args):
        """
        DraughtingCallout(StepVisual_AnnotationPlaneElement self) -> Handle_StepVisual_DraughtingCallout

        returns Value as a DraughtingCallout (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_DraughtingCallout

        """
        return _StepVisual.StepVisual_AnnotationPlaneElement_DraughtingCallout(self, *args)


    def StyledItem(self, *args):
        """
        StyledItem(StepVisual_AnnotationPlaneElement self) -> Handle_StepVisual_StyledItem

        returns Value as a StyledItem (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_StyledItem

        """
        return _StepVisual.StepVisual_AnnotationPlaneElement_StyledItem(self, *args)

    __swig_destroy__ = _StepVisual.delete_StepVisual_AnnotationPlaneElement
StepVisual_AnnotationPlaneElement_swigregister = _StepVisual.StepVisual_AnnotationPlaneElement_swigregister
StepVisual_AnnotationPlaneElement_swigregister(StepVisual_AnnotationPlaneElement)

class StepVisual_ColourSpecification(StepVisual_Colour):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_ColourSpecification
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_ColourSpecification(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_ColourSpecification self) -> StepVisual_ColourSpecification

        Returns a ColourSpecification


        """
        this = _StepVisual.new_StepVisual_ColourSpecification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_ColourSpecification self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_ColourSpecification_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(StepVisual_ColourSpecification self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_ColourSpecification_SetName(self, *args)


    def Name(self, *args):
        """
        Name(StepVisual_ColourSpecification self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_ColourSpecification_Name(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_ColourSpecification_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_ColourSpecification_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_ColourSpecification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_ColourSpecification
StepVisual_ColourSpecification_swigregister = _StepVisual.StepVisual_ColourSpecification_swigregister
StepVisual_ColourSpecification_swigregister(StepVisual_ColourSpecification)

def StepVisual_ColourSpecification_get_type_name(*args):
    """
    StepVisual_ColourSpecification_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_ColourSpecification_get_type_name(*args)

def StepVisual_ColourSpecification_get_type_descriptor(*args):
    """
    StepVisual_ColourSpecification_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_ColourSpecification_get_type_descriptor(*args)

class StepVisual_CameraImage2dWithScale(StepVisual_CameraImage):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_CameraImage2dWithScale
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_CameraImage2dWithScale(self) 
            return h


    def __init__(self, *args):
        """__init__(StepVisual_CameraImage2dWithScale self) -> StepVisual_CameraImage2dWithScale"""
        this = _StepVisual.new_StepVisual_CameraImage2dWithScale(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_CameraImage2dWithScale_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_CameraImage2dWithScale_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_CameraImage2dWithScale_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_CameraImage2dWithScale
StepVisual_CameraImage2dWithScale_swigregister = _StepVisual.StepVisual_CameraImage2dWithScale_swigregister
StepVisual_CameraImage2dWithScale_swigregister(StepVisual_CameraImage2dWithScale)

def StepVisual_CameraImage2dWithScale_get_type_name(*args):
    """
    StepVisual_CameraImage2dWithScale_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_CameraImage2dWithScale_get_type_name(*args)

def StepVisual_CameraImage2dWithScale_get_type_descriptor(*args):
    """
    StepVisual_CameraImage2dWithScale_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_CameraImage2dWithScale_get_type_descriptor(*args)

class StepVisual_AreaInSet(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_AreaInSet
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_AreaInSet(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_AreaInSet self) -> StepVisual_AreaInSet

        Returns a AreaInSet


        """
        this = _StepVisual.new_StepVisual_AreaInSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_AreaInSet self, Handle_StepVisual_PresentationArea aArea, Handle_StepVisual_PresentationSet aInSet)

        :type aArea: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationArea
        :type aInSet: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationSet

        """
        return _StepVisual.StepVisual_AreaInSet_Init(self, *args)


    def SetArea(self, *args):
        """
        SetArea(StepVisual_AreaInSet self, Handle_StepVisual_PresentationArea aArea)

        :type aArea: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationArea

        """
        return _StepVisual.StepVisual_AreaInSet_SetArea(self, *args)


    def Area(self, *args):
        """
        Area(StepVisual_AreaInSet self) -> Handle_StepVisual_PresentationArea

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationArea

        """
        return _StepVisual.StepVisual_AreaInSet_Area(self, *args)


    def SetInSet(self, *args):
        """
        SetInSet(StepVisual_AreaInSet self, Handle_StepVisual_PresentationSet aInSet)

        :type aInSet: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationSet

        """
        return _StepVisual.StepVisual_AreaInSet_SetInSet(self, *args)


    def InSet(self, *args):
        """
        InSet(StepVisual_AreaInSet self) -> Handle_StepVisual_PresentationSet

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationSet

        """
        return _StepVisual.StepVisual_AreaInSet_InSet(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_AreaInSet_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_AreaInSet_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_AreaInSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_AreaInSet
StepVisual_AreaInSet_swigregister = _StepVisual.StepVisual_AreaInSet_swigregister
StepVisual_AreaInSet_swigregister(StepVisual_AreaInSet)

def StepVisual_AreaInSet_get_type_name(*args):
    """
    StepVisual_AreaInSet_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_AreaInSet_get_type_name(*args)

def StepVisual_AreaInSet_get_type_descriptor(*args):
    """
    StepVisual_AreaInSet_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_AreaInSet_get_type_descriptor(*args)

class StepVisual_ContextDependentInvisibility(StepVisual_Invisibility):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_ContextDependentInvisibility
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_ContextDependentInvisibility(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_ContextDependentInvisibility self) -> StepVisual_ContextDependentInvisibility

        Returns a ContextDependentInvisibility


        """
        this = _StepVisual.new_StepVisual_ContextDependentInvisibility(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_ContextDependentInvisibility self, Handle_StepVisual_HArray1OfInvisibleItem aInvisibleItems, StepVisual_InvisibilityContext aPresentationContext)

        :type aInvisibleItems: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfInvisibleItem
        :type aPresentationContext: OCC.wrapper.StepVisual.StepVisual_InvisibilityContext

        """
        return _StepVisual.StepVisual_ContextDependentInvisibility_Init(self, *args)


    def SetPresentationContext(self, *args):
        """
        SetPresentationContext(StepVisual_ContextDependentInvisibility self, StepVisual_InvisibilityContext aPresentationContext)

        :type aPresentationContext: OCC.wrapper.StepVisual.StepVisual_InvisibilityContext

        """
        return _StepVisual.StepVisual_ContextDependentInvisibility_SetPresentationContext(self, *args)


    def PresentationContext(self, *args):
        """
        PresentationContext(StepVisual_ContextDependentInvisibility self) -> StepVisual_InvisibilityContext

        :rtype: OCC.wrapper.StepVisual.StepVisual_InvisibilityContext

        """
        return _StepVisual.StepVisual_ContextDependentInvisibility_PresentationContext(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_ContextDependentInvisibility_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_ContextDependentInvisibility_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_ContextDependentInvisibility_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_ContextDependentInvisibility
StepVisual_ContextDependentInvisibility_swigregister = _StepVisual.StepVisual_ContextDependentInvisibility_swigregister
StepVisual_ContextDependentInvisibility_swigregister(StepVisual_ContextDependentInvisibility)

def StepVisual_ContextDependentInvisibility_get_type_name(*args):
    """
    StepVisual_ContextDependentInvisibility_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_ContextDependentInvisibility_get_type_name(*args)

def StepVisual_ContextDependentInvisibility_get_type_descriptor(*args):
    """
    StepVisual_ContextDependentInvisibility_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_ContextDependentInvisibility_get_type_descriptor(*args)

class StepVisual_HArray1OfDirectionCountSelect(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_HArray1OfDirectionCountSelect
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_HArray1OfDirectionCountSelect(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_HArray1OfDirectionCountSelect self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepVisual_HArray1OfDirectionCountSelect
        __init__(StepVisual_HArray1OfDirectionCountSelect self, Standard_Integer const theLower, Standard_Integer const theUpper, StepVisual_DirectionCountSelect theValue) -> StepVisual_HArray1OfDirectionCountSelect
        __init__(StepVisual_HArray1OfDirectionCountSelect self, NCollection_Array1_StepVisual_DirectionCountSelect theOther) -> StepVisual_HArray1OfDirectionCountSelect

        :type theOther: OCC.wrapper.StepVisual.StepVisual_Array1OfDirectionCountSelect

        """
        this = _StepVisual.new_StepVisual_HArray1OfDirectionCountSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfDirectionCountSelect

        """
        res = _StepVisual.StepVisual_HArray1OfDirectionCountSelect_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepVisual_HArray1OfDirectionCountSelect self) -> NCollection_Array1_StepVisual_DirectionCountSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfDirectionCountSelect

        """
        return _StepVisual.StepVisual_HArray1OfDirectionCountSelect_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_HArray1OfDirectionCountSelect_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_HArray1OfDirectionCountSelect_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_HArray1OfDirectionCountSelect_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_HArray1OfDirectionCountSelect
StepVisual_HArray1OfDirectionCountSelect_swigregister = _StepVisual.StepVisual_HArray1OfDirectionCountSelect_swigregister
StepVisual_HArray1OfDirectionCountSelect_swigregister(StepVisual_HArray1OfDirectionCountSelect)

def StepVisual_HArray1OfDirectionCountSelect_get_type_name(*args):
    """
    StepVisual_HArray1OfDirectionCountSelect_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_HArray1OfDirectionCountSelect_get_type_name(*args)

def StepVisual_HArray1OfDirectionCountSelect_get_type_descriptor(*args):
    """
    StepVisual_HArray1OfDirectionCountSelect_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_HArray1OfDirectionCountSelect_get_type_descriptor(*args)

class StepVisual_HArray1OfFillStyleSelect(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_HArray1OfFillStyleSelect
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_HArray1OfFillStyleSelect(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_HArray1OfFillStyleSelect self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepVisual_HArray1OfFillStyleSelect
        __init__(StepVisual_HArray1OfFillStyleSelect self, Standard_Integer const theLower, Standard_Integer const theUpper, StepVisual_FillStyleSelect theValue) -> StepVisual_HArray1OfFillStyleSelect
        __init__(StepVisual_HArray1OfFillStyleSelect self, NCollection_Array1_StepVisual_FillStyleSelect theOther) -> StepVisual_HArray1OfFillStyleSelect

        :type theOther: OCC.wrapper.StepVisual.StepVisual_Array1OfFillStyleSelect

        """
        this = _StepVisual.new_StepVisual_HArray1OfFillStyleSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfFillStyleSelect

        """
        res = _StepVisual.StepVisual_HArray1OfFillStyleSelect_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepVisual_HArray1OfFillStyleSelect self) -> NCollection_Array1_StepVisual_FillStyleSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfFillStyleSelect

        """
        return _StepVisual.StepVisual_HArray1OfFillStyleSelect_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_HArray1OfFillStyleSelect_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_HArray1OfFillStyleSelect_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_HArray1OfFillStyleSelect_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_HArray1OfFillStyleSelect
StepVisual_HArray1OfFillStyleSelect_swigregister = _StepVisual.StepVisual_HArray1OfFillStyleSelect_swigregister
StepVisual_HArray1OfFillStyleSelect_swigregister(StepVisual_HArray1OfFillStyleSelect)

def StepVisual_HArray1OfFillStyleSelect_get_type_name(*args):
    """
    StepVisual_HArray1OfFillStyleSelect_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_HArray1OfFillStyleSelect_get_type_name(*args)

def StepVisual_HArray1OfFillStyleSelect_get_type_descriptor(*args):
    """
    StepVisual_HArray1OfFillStyleSelect_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_HArray1OfFillStyleSelect_get_type_descriptor(*args)

class StepVisual_DirectionCountSelect(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(StepVisual_DirectionCountSelect self) -> StepVisual_DirectionCountSelect"""
        this = _StepVisual.new_StepVisual_DirectionCountSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetTypeOfContent(self, *args):
        """
        SetTypeOfContent(StepVisual_DirectionCountSelect self, Standard_Integer const aTypeOfContent)

        :type aTypeOfContent: int

        """
        return _StepVisual.StepVisual_DirectionCountSelect_SetTypeOfContent(self, *args)


    def TypeOfContent(self, *args):
        """
        TypeOfContent(StepVisual_DirectionCountSelect self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_DirectionCountSelect_TypeOfContent(self, *args)


    def UDirectionCount(self, *args):
        """
        UDirectionCount(StepVisual_DirectionCountSelect self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_DirectionCountSelect_UDirectionCount(self, *args)


    def SetUDirectionCount(self, *args):
        """
        SetUDirectionCount(StepVisual_DirectionCountSelect self, Standard_Integer const aUDirectionCount)

        :type aUDirectionCount: int

        """
        return _StepVisual.StepVisual_DirectionCountSelect_SetUDirectionCount(self, *args)


    def VDirectionCount(self, *args):
        """
        VDirectionCount(StepVisual_DirectionCountSelect self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_DirectionCountSelect_VDirectionCount(self, *args)


    def SetVDirectionCount(self, *args):
        """
        SetVDirectionCount(StepVisual_DirectionCountSelect self, Standard_Integer const aUDirectionCount)

        :type aUDirectionCount: int

        """
        return _StepVisual.StepVisual_DirectionCountSelect_SetVDirectionCount(self, *args)

    __swig_destroy__ = _StepVisual.delete_StepVisual_DirectionCountSelect
StepVisual_DirectionCountSelect_swigregister = _StepVisual.StepVisual_DirectionCountSelect_swigregister
StepVisual_DirectionCountSelect_swigregister(StepVisual_DirectionCountSelect)

class StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation(StepVisual_DraughtingModel):
    """
    Added for Dimensional Tolerances
    Complex STEP entity Characterized_Object & Characterized_Representation & Draughting_Model & Representation
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self) -> StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation

        Added for Dimensional Tolerances
        Complex STEP entity Characterized_Object & Characterized_Representation & Draughting_Model & Representation
        """
        this = _StepVisual.new_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation
StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_swigregister = _StepVisual.StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_swigregister
StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_swigregister(StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation)

def StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_get_type_name(*args):
    """
    StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_get_type_name(*args)

def StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_get_type_descriptor(*args):
    """
    StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_get_type_descriptor(*args)

class StepVisual_CameraModelD3MultiClippingInterectionSelect(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepVisual_CameraModelD3MultiClippingInterectionSelect self) -> StepVisual_CameraModelD3MultiClippingInterectionSelect

        Returns a CameraModelD3MultiClippingInterectionSelect select type


        """
        this = _StepVisual.new_StepVisual_CameraModelD3MultiClippingInterectionSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepVisual_CameraModelD3MultiClippingInterectionSelect self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a IdAttributeSelect Kind Entity that is :
        1 -> Plane
        2 -> CameraModelD3MultiClippingUnion
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_CameraModelD3MultiClippingInterectionSelect_CaseNum(self, *args)


    def Plane(self, *args):
        """
        Plane(StepVisual_CameraModelD3MultiClippingInterectionSelect self) -> Handle_StepGeom_Plane

        returns Value as a Plane (Null if another type)

        :rtype: OCC.wrapper.StepGeom.Handle_StepGeom_Plane

        """
        return _StepVisual.StepVisual_CameraModelD3MultiClippingInterectionSelect_Plane(self, *args)


    def CameraModelD3MultiClippingUnion(self, *args):
        """
        CameraModelD3MultiClippingUnion(StepVisual_CameraModelD3MultiClippingInterectionSelect self) -> Handle_StepVisual_CameraModelD3MultiClippingUnion

        returns Value as a CameraModelD3MultiClippingUnion (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion

        """
        return _StepVisual.StepVisual_CameraModelD3MultiClippingInterectionSelect_CameraModelD3MultiClippingUnion(self, *args)

    __swig_destroy__ = _StepVisual.delete_StepVisual_CameraModelD3MultiClippingInterectionSelect
StepVisual_CameraModelD3MultiClippingInterectionSelect_swigregister = _StepVisual.StepVisual_CameraModelD3MultiClippingInterectionSelect_swigregister
StepVisual_CameraModelD3MultiClippingInterectionSelect_swigregister(StepVisual_CameraModelD3MultiClippingInterectionSelect)

class StepVisual_PresentedItemRepresentation(Standard.Standard_Transient):
    """Added from StepVisual Rev2 to Rev4"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_PresentedItemRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_PresentedItemRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_PresentedItemRepresentation self) -> StepVisual_PresentedItemRepresentation

        Added from StepVisual Rev2 to Rev4
        """
        this = _StepVisual.new_StepVisual_PresentedItemRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_PresentedItemRepresentation self, StepVisual_PresentationRepresentationSelect aPresentation, Handle_StepVisual_PresentedItem aItem)

        :type aPresentation: OCC.wrapper.StepVisual.StepVisual_PresentationRepresentationSelect
        :type aItem: OCC.wrapper.StepVisual.Handle_StepVisual_PresentedItem

        """
        return _StepVisual.StepVisual_PresentedItemRepresentation_Init(self, *args)


    def SetPresentation(self, *args):
        """
        SetPresentation(StepVisual_PresentedItemRepresentation self, StepVisual_PresentationRepresentationSelect aPresentation)

        :type aPresentation: OCC.wrapper.StepVisual.StepVisual_PresentationRepresentationSelect

        """
        return _StepVisual.StepVisual_PresentedItemRepresentation_SetPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(StepVisual_PresentedItemRepresentation self) -> StepVisual_PresentationRepresentationSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_PresentationRepresentationSelect

        """
        return _StepVisual.StepVisual_PresentedItemRepresentation_Presentation(self, *args)


    def SetItem(self, *args):
        """
        SetItem(StepVisual_PresentedItemRepresentation self, Handle_StepVisual_PresentedItem aItem)

        :type aItem: OCC.wrapper.StepVisual.Handle_StepVisual_PresentedItem

        """
        return _StepVisual.StepVisual_PresentedItemRepresentation_SetItem(self, *args)


    def Item(self, *args):
        """
        Item(StepVisual_PresentedItemRepresentation self) -> Handle_StepVisual_PresentedItem

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentedItem

        """
        return _StepVisual.StepVisual_PresentedItemRepresentation_Item(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_PresentedItemRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_PresentedItemRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_PresentedItemRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_PresentedItemRepresentation
StepVisual_PresentedItemRepresentation_swigregister = _StepVisual.StepVisual_PresentedItemRepresentation_swigregister
StepVisual_PresentedItemRepresentation_swigregister(StepVisual_PresentedItemRepresentation)

def StepVisual_PresentedItemRepresentation_get_type_name(*args):
    """
    StepVisual_PresentedItemRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_PresentedItemRepresentation_get_type_name(*args)

def StepVisual_PresentedItemRepresentation_get_type_descriptor(*args):
    """
    StepVisual_PresentedItemRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_PresentedItemRepresentation_get_type_descriptor(*args)

class StepVisual_PresentationStyleAssignment(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_PresentationStyleAssignment
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_PresentationStyleAssignment(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_PresentationStyleAssignment self) -> StepVisual_PresentationStyleAssignment

        Returns a PresentationStyleAssignment


        """
        this = _StepVisual.new_StepVisual_PresentationStyleAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_PresentationStyleAssignment self, Handle_StepVisual_HArray1OfPresentationStyleSelect aStyles)

        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect

        """
        return _StepVisual.StepVisual_PresentationStyleAssignment_Init(self, *args)


    def SetStyles(self, *args):
        """
        SetStyles(StepVisual_PresentationStyleAssignment self, Handle_StepVisual_HArray1OfPresentationStyleSelect aStyles)

        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect

        """
        return _StepVisual.StepVisual_PresentationStyleAssignment_SetStyles(self, *args)


    def Styles(self, *args):
        """
        Styles(StepVisual_PresentationStyleAssignment self) -> Handle_StepVisual_HArray1OfPresentationStyleSelect

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect

        """
        return _StepVisual.StepVisual_PresentationStyleAssignment_Styles(self, *args)


    def StylesValue(self, *args):
        """
        StylesValue(StepVisual_PresentationStyleAssignment self, Standard_Integer const num) -> StepVisual_PresentationStyleSelect

        :type num: int
        :rtype: OCC.wrapper.StepVisual.StepVisual_PresentationStyleSelect

        """
        return _StepVisual.StepVisual_PresentationStyleAssignment_StylesValue(self, *args)


    def NbStyles(self, *args):
        """
        NbStyles(StepVisual_PresentationStyleAssignment self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_PresentationStyleAssignment_NbStyles(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_PresentationStyleAssignment_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_PresentationStyleAssignment_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_PresentationStyleAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_PresentationStyleAssignment
StepVisual_PresentationStyleAssignment_swigregister = _StepVisual.StepVisual_PresentationStyleAssignment_swigregister
StepVisual_PresentationStyleAssignment_swigregister(StepVisual_PresentationStyleAssignment)

def StepVisual_PresentationStyleAssignment_get_type_name(*args):
    """
    StepVisual_PresentationStyleAssignment_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_PresentationStyleAssignment_get_type_name(*args)

def StepVisual_PresentationStyleAssignment_get_type_descriptor(*args):
    """
    StepVisual_PresentationStyleAssignment_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_PresentationStyleAssignment_get_type_descriptor(*args)

class StepVisual_PreDefinedColour(StepVisual_Colour):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_PreDefinedColour
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_PreDefinedColour(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_PreDefinedColour self) -> StepVisual_PreDefinedColour

        Returns a PreDefinedColour


        """
        this = _StepVisual.new_StepVisual_PreDefinedColour(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetPreDefinedItem(self, *args):
        """
        SetPreDefinedItem(StepVisual_PreDefinedColour self, Handle_StepVisual_PreDefinedItem item)

        set a pre_defined_item part

        :type item: OCC.wrapper.StepVisual.Handle_StepVisual_PreDefinedItem

        """
        return _StepVisual.StepVisual_PreDefinedColour_SetPreDefinedItem(self, *args)


    def GetPreDefinedItem(self, *args):
        """
        return a pre_defined_item part

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PreDefinedItem

        """
        res = _StepVisual.StepVisual_PreDefinedColour_GetPreDefinedItem(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_PreDefinedColour_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_PreDefinedColour_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_PreDefinedColour_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_PreDefinedColour
StepVisual_PreDefinedColour_swigregister = _StepVisual.StepVisual_PreDefinedColour_swigregister
StepVisual_PreDefinedColour_swigregister(StepVisual_PreDefinedColour)

def StepVisual_PreDefinedColour_get_type_name(*args):
    """
    StepVisual_PreDefinedColour_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_PreDefinedColour_get_type_name(*args)

def StepVisual_PreDefinedColour_get_type_descriptor(*args):
    """
    StepVisual_PreDefinedColour_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_PreDefinedColour_get_type_descriptor(*args)

class StepVisual_ExternallyDefinedTextFont(StepBasic.StepBasic_ExternallyDefinedItem):
    """Representation of STEP entity ExternallyDefinedTextFont"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_ExternallyDefinedTextFont
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_ExternallyDefinedTextFont(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_ExternallyDefinedTextFont self) -> StepVisual_ExternallyDefinedTextFont

        Empty constructor


        """
        this = _StepVisual.new_StepVisual_ExternallyDefinedTextFont(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_ExternallyDefinedTextFont_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_ExternallyDefinedTextFont_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_ExternallyDefinedTextFont_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_ExternallyDefinedTextFont
StepVisual_ExternallyDefinedTextFont_swigregister = _StepVisual.StepVisual_ExternallyDefinedTextFont_swigregister
StepVisual_ExternallyDefinedTextFont_swigregister(StepVisual_ExternallyDefinedTextFont)

def StepVisual_ExternallyDefinedTextFont_get_type_name(*args):
    """
    StepVisual_ExternallyDefinedTextFont_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_ExternallyDefinedTextFont_get_type_name(*args)

def StepVisual_ExternallyDefinedTextFont_get_type_descriptor(*args):
    """
    StepVisual_ExternallyDefinedTextFont_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_ExternallyDefinedTextFont_get_type_descriptor(*args)

class StepVisual_CompositeTextWithExtent(StepVisual_CompositeText):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_CompositeTextWithExtent
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_CompositeTextWithExtent(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_CompositeTextWithExtent self) -> StepVisual_CompositeTextWithExtent

        Returns a CompositeTextWithExtent


        """
        this = _StepVisual.new_StepVisual_CompositeTextWithExtent(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_CompositeTextWithExtent self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_HArray1OfTextOrCharacter aCollectedText, Handle_StepVisual_PlanarExtent aExtent)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aCollectedText: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter
        :type aExtent: OCC.wrapper.StepVisual.Handle_StepVisual_PlanarExtent

        """
        return _StepVisual.StepVisual_CompositeTextWithExtent_Init(self, *args)


    def SetExtent(self, *args):
        """
        SetExtent(StepVisual_CompositeTextWithExtent self, Handle_StepVisual_PlanarExtent aExtent)

        :type aExtent: OCC.wrapper.StepVisual.Handle_StepVisual_PlanarExtent

        """
        return _StepVisual.StepVisual_CompositeTextWithExtent_SetExtent(self, *args)


    def Extent(self, *args):
        """
        Extent(StepVisual_CompositeTextWithExtent self) -> Handle_StepVisual_PlanarExtent

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PlanarExtent

        """
        return _StepVisual.StepVisual_CompositeTextWithExtent_Extent(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_CompositeTextWithExtent_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_CompositeTextWithExtent_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_CompositeTextWithExtent_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_CompositeTextWithExtent
StepVisual_CompositeTextWithExtent_swigregister = _StepVisual.StepVisual_CompositeTextWithExtent_swigregister
StepVisual_CompositeTextWithExtent_swigregister(StepVisual_CompositeTextWithExtent)

def StepVisual_CompositeTextWithExtent_get_type_name(*args):
    """
    StepVisual_CompositeTextWithExtent_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_CompositeTextWithExtent_get_type_name(*args)

def StepVisual_CompositeTextWithExtent_get_type_descriptor(*args):
    """
    StepVisual_CompositeTextWithExtent_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_CompositeTextWithExtent_get_type_descriptor(*args)

class StepVisual_CurveStyleFont(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_CurveStyleFont
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_CurveStyleFont(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_CurveStyleFont self) -> StepVisual_CurveStyleFont

        Returns a CurveStyleFont


        """
        this = _StepVisual.new_StepVisual_CurveStyleFont(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_CurveStyleFont self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_HArray1OfCurveStyleFontPattern aPatternList)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPatternList: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern

        """
        return _StepVisual.StepVisual_CurveStyleFont_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(StepVisual_CurveStyleFont self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_CurveStyleFont_SetName(self, *args)


    def Name(self, *args):
        """
        Name(StepVisual_CurveStyleFont self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_CurveStyleFont_Name(self, *args)


    def SetPatternList(self, *args):
        """
        SetPatternList(StepVisual_CurveStyleFont self, Handle_StepVisual_HArray1OfCurveStyleFontPattern aPatternList)

        :type aPatternList: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern

        """
        return _StepVisual.StepVisual_CurveStyleFont_SetPatternList(self, *args)


    def PatternList(self, *args):
        """
        PatternList(StepVisual_CurveStyleFont self) -> Handle_StepVisual_HArray1OfCurveStyleFontPattern

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern

        """
        return _StepVisual.StepVisual_CurveStyleFont_PatternList(self, *args)


    def PatternListValue(self, *args):
        """
        PatternListValue(StepVisual_CurveStyleFont self, Standard_Integer const num) -> Handle_StepVisual_CurveStyleFontPattern

        :type num: int
        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyleFontPattern

        """
        return _StepVisual.StepVisual_CurveStyleFont_PatternListValue(self, *args)


    def NbPatternList(self, *args):
        """
        NbPatternList(StepVisual_CurveStyleFont self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_CurveStyleFont_NbPatternList(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_CurveStyleFont_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_CurveStyleFont_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_CurveStyleFont_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_CurveStyleFont
StepVisual_CurveStyleFont_swigregister = _StepVisual.StepVisual_CurveStyleFont_swigregister
StepVisual_CurveStyleFont_swigregister(StepVisual_CurveStyleFont)

def StepVisual_CurveStyleFont_get_type_name(*args):
    """
    StepVisual_CurveStyleFont_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_CurveStyleFont_get_type_name(*args)

def StepVisual_CurveStyleFont_get_type_descriptor(*args):
    """
    StepVisual_CurveStyleFont_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_CurveStyleFont_get_type_descriptor(*args)

class StepVisual_FillAreaStyleColour(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_FillAreaStyleColour
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_FillAreaStyleColour(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_FillAreaStyleColour self) -> StepVisual_FillAreaStyleColour

        Returns a FillAreaStyleColour


        """
        this = _StepVisual.new_StepVisual_FillAreaStyleColour(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_FillAreaStyleColour self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_Colour aFillColour)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFillColour: OCC.wrapper.StepVisual.Handle_StepVisual_Colour

        """
        return _StepVisual.StepVisual_FillAreaStyleColour_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(StepVisual_FillAreaStyleColour self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_FillAreaStyleColour_SetName(self, *args)


    def Name(self, *args):
        """
        Name(StepVisual_FillAreaStyleColour self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_FillAreaStyleColour_Name(self, *args)


    def SetFillColour(self, *args):
        """
        SetFillColour(StepVisual_FillAreaStyleColour self, Handle_StepVisual_Colour aFillColour)

        :type aFillColour: OCC.wrapper.StepVisual.Handle_StepVisual_Colour

        """
        return _StepVisual.StepVisual_FillAreaStyleColour_SetFillColour(self, *args)


    def FillColour(self, *args):
        """
        FillColour(StepVisual_FillAreaStyleColour self) -> Handle_StepVisual_Colour

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_Colour

        """
        return _StepVisual.StepVisual_FillAreaStyleColour_FillColour(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_FillAreaStyleColour_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_FillAreaStyleColour_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_FillAreaStyleColour_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_FillAreaStyleColour
StepVisual_FillAreaStyleColour_swigregister = _StepVisual.StepVisual_FillAreaStyleColour_swigregister
StepVisual_FillAreaStyleColour_swigregister(StepVisual_FillAreaStyleColour)

def StepVisual_FillAreaStyleColour_get_type_name(*args):
    """
    StepVisual_FillAreaStyleColour_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_FillAreaStyleColour_get_type_name(*args)

def StepVisual_FillAreaStyleColour_get_type_descriptor(*args):
    """
    StepVisual_FillAreaStyleColour_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_FillAreaStyleColour_get_type_descriptor(*args)

class StepVisual_OverRidingStyledItem(StepVisual_StyledItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_OverRidingStyledItem
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_OverRidingStyledItem(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_OverRidingStyledItem self) -> StepVisual_OverRidingStyledItem

        Returns a OverRidingStyledItem


        """
        this = _StepVisual.new_StepVisual_OverRidingStyledItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_OverRidingStyledItem self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_HArray1OfPresentationStyleAssignment aStyles, Handle_Standard_Transient aItem, Handle_StepVisual_StyledItem aOverRiddenStyle)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment
        :type aItem: OCC.wrapper.Standard.Handle_Standard_Transient
        :type aOverRiddenStyle: OCC.wrapper.StepVisual.Handle_StepVisual_StyledItem

        """
        return _StepVisual.StepVisual_OverRidingStyledItem_Init(self, *args)


    def SetOverRiddenStyle(self, *args):
        """
        SetOverRiddenStyle(StepVisual_OverRidingStyledItem self, Handle_StepVisual_StyledItem aOverRiddenStyle)

        :type aOverRiddenStyle: OCC.wrapper.StepVisual.Handle_StepVisual_StyledItem

        """
        return _StepVisual.StepVisual_OverRidingStyledItem_SetOverRiddenStyle(self, *args)


    def OverRiddenStyle(self, *args):
        """
        OverRiddenStyle(StepVisual_OverRidingStyledItem self) -> Handle_StepVisual_StyledItem

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_StyledItem

        """
        return _StepVisual.StepVisual_OverRidingStyledItem_OverRiddenStyle(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_OverRidingStyledItem_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_OverRidingStyledItem_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_OverRidingStyledItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_OverRidingStyledItem
StepVisual_OverRidingStyledItem_swigregister = _StepVisual.StepVisual_OverRidingStyledItem_swigregister
StepVisual_OverRidingStyledItem_swigregister(StepVisual_OverRidingStyledItem)

def StepVisual_OverRidingStyledItem_get_type_name(*args):
    """
    StepVisual_OverRidingStyledItem_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_OverRidingStyledItem_get_type_name(*args)

def StepVisual_OverRidingStyledItem_get_type_descriptor(*args):
    """
    StepVisual_OverRidingStyledItem_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_OverRidingStyledItem_get_type_descriptor(*args)

class StepVisual_HArray1OfCurveStyleFontPattern(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_HArray1OfCurveStyleFontPattern
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_HArray1OfCurveStyleFontPattern(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_HArray1OfCurveStyleFontPattern self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepVisual_HArray1OfCurveStyleFontPattern
        __init__(StepVisual_HArray1OfCurveStyleFontPattern self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_StepVisual_CurveStyleFontPattern theValue) -> StepVisual_HArray1OfCurveStyleFontPattern
        __init__(StepVisual_HArray1OfCurveStyleFontPattern self, NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern theOther) -> StepVisual_HArray1OfCurveStyleFontPattern

        :type theOther: OCC.wrapper.StepVisual.StepVisual_Array1OfCurveStyleFontPattern

        """
        this = _StepVisual.new_StepVisual_HArray1OfCurveStyleFontPattern(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfCurveStyleFontPattern

        """
        res = _StepVisual.StepVisual_HArray1OfCurveStyleFontPattern_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepVisual_HArray1OfCurveStyleFontPattern self) -> NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfCurveStyleFontPattern

        """
        return _StepVisual.StepVisual_HArray1OfCurveStyleFontPattern_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_HArray1OfCurveStyleFontPattern_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_HArray1OfCurveStyleFontPattern_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_HArray1OfCurveStyleFontPattern_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_HArray1OfCurveStyleFontPattern
StepVisual_HArray1OfCurveStyleFontPattern_swigregister = _StepVisual.StepVisual_HArray1OfCurveStyleFontPattern_swigregister
StepVisual_HArray1OfCurveStyleFontPattern_swigregister(StepVisual_HArray1OfCurveStyleFontPattern)

def StepVisual_HArray1OfCurveStyleFontPattern_get_type_name(*args):
    """
    StepVisual_HArray1OfCurveStyleFontPattern_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_HArray1OfCurveStyleFontPattern_get_type_name(*args)

def StepVisual_HArray1OfCurveStyleFontPattern_get_type_descriptor(*args):
    """
    StepVisual_HArray1OfCurveStyleFontPattern_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_HArray1OfCurveStyleFontPattern_get_type_descriptor(*args)

class StepVisual_LayeredItem(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepVisual_LayeredItem self) -> StepVisual_LayeredItem

        Returns a LayeredItem SelectType


        """
        this = _StepVisual.new_StepVisual_LayeredItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepVisual_LayeredItem self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a LayeredItem Kind Entity that is :
        1 -> PresentationRepresentation
        2 -> RepresentationItem
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_LayeredItem_CaseNum(self, *args)


    def PresentationRepresentation(self, *args):
        """
        PresentationRepresentation(StepVisual_LayeredItem self) -> Handle_StepVisual_PresentationRepresentation

        returns Value as a PresentationRepresentation (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationRepresentation

        """
        return _StepVisual.StepVisual_LayeredItem_PresentationRepresentation(self, *args)


    def RepresentationItem(self, *args):
        """
        RepresentationItem(StepVisual_LayeredItem self) -> Handle_StepRepr_RepresentationItem

        returns Value as a RepresentationItem (Null if another type)

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.StepVisual_LayeredItem_RepresentationItem(self, *args)

    __swig_destroy__ = _StepVisual.delete_StepVisual_LayeredItem
StepVisual_LayeredItem_swigregister = _StepVisual.StepVisual_LayeredItem_swigregister
StepVisual_LayeredItem_swigregister(StepVisual_LayeredItem)

class StepVisual_SurfaceStyleParameterLine(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_SurfaceStyleParameterLine
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_SurfaceStyleParameterLine(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_SurfaceStyleParameterLine self) -> StepVisual_SurfaceStyleParameterLine

        Returns a SurfaceStyleParameterLine


        """
        this = _StepVisual.new_StepVisual_SurfaceStyleParameterLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_SurfaceStyleParameterLine self, Handle_StepVisual_CurveStyle aStyleOfParameterLines, Handle_StepVisual_HArray1OfDirectionCountSelect aDirectionCounts)

        :type aStyleOfParameterLines: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle
        :type aDirectionCounts: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect

        """
        return _StepVisual.StepVisual_SurfaceStyleParameterLine_Init(self, *args)


    def SetStyleOfParameterLines(self, *args):
        """
        SetStyleOfParameterLines(StepVisual_SurfaceStyleParameterLine self, Handle_StepVisual_CurveStyle aStyleOfParameterLines)

        :type aStyleOfParameterLines: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.StepVisual_SurfaceStyleParameterLine_SetStyleOfParameterLines(self, *args)


    def StyleOfParameterLines(self, *args):
        """
        StyleOfParameterLines(StepVisual_SurfaceStyleParameterLine self) -> Handle_StepVisual_CurveStyle

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.StepVisual_SurfaceStyleParameterLine_StyleOfParameterLines(self, *args)


    def SetDirectionCounts(self, *args):
        """
        SetDirectionCounts(StepVisual_SurfaceStyleParameterLine self, Handle_StepVisual_HArray1OfDirectionCountSelect aDirectionCounts)

        :type aDirectionCounts: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect

        """
        return _StepVisual.StepVisual_SurfaceStyleParameterLine_SetDirectionCounts(self, *args)


    def DirectionCounts(self, *args):
        """
        DirectionCounts(StepVisual_SurfaceStyleParameterLine self) -> Handle_StepVisual_HArray1OfDirectionCountSelect

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect

        """
        return _StepVisual.StepVisual_SurfaceStyleParameterLine_DirectionCounts(self, *args)


    def DirectionCountsValue(self, *args):
        """
        DirectionCountsValue(StepVisual_SurfaceStyleParameterLine self, Standard_Integer const num) -> StepVisual_DirectionCountSelect

        :type num: int
        :rtype: OCC.wrapper.StepVisual.StepVisual_DirectionCountSelect

        """
        return _StepVisual.StepVisual_SurfaceStyleParameterLine_DirectionCountsValue(self, *args)


    def NbDirectionCounts(self, *args):
        """
        NbDirectionCounts(StepVisual_SurfaceStyleParameterLine self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_SurfaceStyleParameterLine_NbDirectionCounts(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_SurfaceStyleParameterLine_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_SurfaceStyleParameterLine_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_SurfaceStyleParameterLine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_SurfaceStyleParameterLine
StepVisual_SurfaceStyleParameterLine_swigregister = _StepVisual.StepVisual_SurfaceStyleParameterLine_swigregister
StepVisual_SurfaceStyleParameterLine_swigregister(StepVisual_SurfaceStyleParameterLine)

def StepVisual_SurfaceStyleParameterLine_get_type_name(*args):
    """
    StepVisual_SurfaceStyleParameterLine_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_SurfaceStyleParameterLine_get_type_name(*args)

def StepVisual_SurfaceStyleParameterLine_get_type_descriptor(*args):
    """
    StepVisual_SurfaceStyleParameterLine_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_SurfaceStyleParameterLine_get_type_descriptor(*args)

class StepVisual_TextOrCharacter(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepVisual_TextOrCharacter self) -> StepVisual_TextOrCharacter

        Returns a TextOrCharacter SelectType


        """
        this = _StepVisual.new_StepVisual_TextOrCharacter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepVisual_TextOrCharacter self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a TextOrCharacter Kind Entity that is :
        1 -> AnnotationText
        2 -> CompositeText
        3 -> TextLiteral
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_TextOrCharacter_CaseNum(self, *args)


    def AnnotationText(self, *args):
        """
        AnnotationText(StepVisual_TextOrCharacter self) -> Handle_StepVisual_AnnotationText

        returns Value as a AnnotationText (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_AnnotationText

        """
        return _StepVisual.StepVisual_TextOrCharacter_AnnotationText(self, *args)


    def CompositeText(self, *args):
        """
        CompositeText(StepVisual_TextOrCharacter self) -> Handle_StepVisual_CompositeText

        returns Value as a CompositeText (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_CompositeText

        """
        return _StepVisual.StepVisual_TextOrCharacter_CompositeText(self, *args)


    def TextLiteral(self, *args):
        """
        TextLiteral(StepVisual_TextOrCharacter self) -> Handle_StepVisual_TextLiteral

        returns Value as a TextLiteral (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_TextLiteral

        """
        return _StepVisual.StepVisual_TextOrCharacter_TextLiteral(self, *args)

    __swig_destroy__ = _StepVisual.delete_StepVisual_TextOrCharacter
StepVisual_TextOrCharacter_swigregister = _StepVisual.StepVisual_TextOrCharacter_swigregister
StepVisual_TextOrCharacter_swigregister(StepVisual_TextOrCharacter)

class StepVisual_DraughtingPreDefinedColour(StepVisual_PreDefinedColour):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_DraughtingPreDefinedColour
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_DraughtingPreDefinedColour(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_DraughtingPreDefinedColour self) -> StepVisual_DraughtingPreDefinedColour

        Returns a DraughtingPreDefinedColour


        """
        this = _StepVisual.new_StepVisual_DraughtingPreDefinedColour(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_DraughtingPreDefinedColour_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_DraughtingPreDefinedColour_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_DraughtingPreDefinedColour_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_DraughtingPreDefinedColour
StepVisual_DraughtingPreDefinedColour_swigregister = _StepVisual.StepVisual_DraughtingPreDefinedColour_swigregister
StepVisual_DraughtingPreDefinedColour_swigregister(StepVisual_DraughtingPreDefinedColour)

def StepVisual_DraughtingPreDefinedColour_get_type_name(*args):
    """
    StepVisual_DraughtingPreDefinedColour_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_DraughtingPreDefinedColour_get_type_name(*args)

def StepVisual_DraughtingPreDefinedColour_get_type_descriptor(*args):
    """
    StepVisual_DraughtingPreDefinedColour_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_DraughtingPreDefinedColour_get_type_descriptor(*args)

class StepVisual_DraughtingPreDefinedCurveFont(StepVisual_PreDefinedCurveFont):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_DraughtingPreDefinedCurveFont
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_DraughtingPreDefinedCurveFont(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_DraughtingPreDefinedCurveFont self) -> StepVisual_DraughtingPreDefinedCurveFont

        Returns a DraughtingPreDefinedCurveFont


        """
        this = _StepVisual.new_StepVisual_DraughtingPreDefinedCurveFont(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_DraughtingPreDefinedCurveFont_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_DraughtingPreDefinedCurveFont_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_DraughtingPreDefinedCurveFont_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_DraughtingPreDefinedCurveFont
StepVisual_DraughtingPreDefinedCurveFont_swigregister = _StepVisual.StepVisual_DraughtingPreDefinedCurveFont_swigregister
StepVisual_DraughtingPreDefinedCurveFont_swigregister(StepVisual_DraughtingPreDefinedCurveFont)

def StepVisual_DraughtingPreDefinedCurveFont_get_type_name(*args):
    """
    StepVisual_DraughtingPreDefinedCurveFont_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_DraughtingPreDefinedCurveFont_get_type_name(*args)

def StepVisual_DraughtingPreDefinedCurveFont_get_type_descriptor(*args):
    """
    StepVisual_DraughtingPreDefinedCurveFont_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_DraughtingPreDefinedCurveFont_get_type_descriptor(*args)

class StepVisual_StyleContextSelect(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepVisual_StyleContextSelect self) -> StepVisual_StyleContextSelect

        Returns a StyleContextSelect SelectType


        """
        this = _StepVisual.new_StepVisual_StyleContextSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepVisual_StyleContextSelect self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a StyleContextSelect Kind Entity that is :
        1 -> Representation
        2 -> RepresentationItem
        3 -> PresentationSet
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_StyleContextSelect_CaseNum(self, *args)


    def Representation(self, *args):
        """
        Representation(StepVisual_StyleContextSelect self) -> Handle_StepRepr_Representation

        returns Value as a Representation (Null if another type)

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_Representation

        """
        return _StepVisual.StepVisual_StyleContextSelect_Representation(self, *args)


    def RepresentationItem(self, *args):
        """
        RepresentationItem(StepVisual_StyleContextSelect self) -> Handle_StepRepr_RepresentationItem

        returns Value as a RepresentationItem (Null if another type)

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.StepVisual_StyleContextSelect_RepresentationItem(self, *args)


    def PresentationSet(self, *args):
        """
        PresentationSet(StepVisual_StyleContextSelect self) -> Handle_StepVisual_PresentationSet

        returns Value as a PresentationSet (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationSet

        """
        return _StepVisual.StepVisual_StyleContextSelect_PresentationSet(self, *args)

    __swig_destroy__ = _StepVisual.delete_StepVisual_StyleContextSelect
StepVisual_StyleContextSelect_swigregister = _StepVisual.StepVisual_StyleContextSelect_swigregister
StepVisual_StyleContextSelect_swigregister(StepVisual_StyleContextSelect)

class StepVisual_CameraModelD3MultiClippingIntersection(StepGeom.StepGeom_GeometricRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_CameraModelD3MultiClippingIntersection
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_CameraModelD3MultiClippingIntersection(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_CameraModelD3MultiClippingIntersection self) -> StepVisual_CameraModelD3MultiClippingIntersection

        Returns a StepVisual_CameraModelD3MultiClippingIntersection


        """
        this = _StepVisual.new_StepVisual_CameraModelD3MultiClippingIntersection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_CameraModelD3MultiClippingIntersection self, Handle_TCollection_HAsciiString theName, Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect theShapeClipping)

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theShapeClipping: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect

        """
        return _StepVisual.StepVisual_CameraModelD3MultiClippingIntersection_Init(self, *args)


    def SetShapeClipping(self, *args):
        """
        SetShapeClipping(StepVisual_CameraModelD3MultiClippingIntersection self, Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect theShapeClipping)

        :type theShapeClipping: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect

        """
        return _StepVisual.StepVisual_CameraModelD3MultiClippingIntersection_SetShapeClipping(self, *args)


    def ShapeClipping(self, *args):
        """
        ShapeClipping(StepVisual_CameraModelD3MultiClippingIntersection self) -> Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect

        """
        return _StepVisual.StepVisual_CameraModelD3MultiClippingIntersection_ShapeClipping(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_CameraModelD3MultiClippingIntersection_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_CameraModelD3MultiClippingIntersection_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_CameraModelD3MultiClippingIntersection_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_CameraModelD3MultiClippingIntersection
StepVisual_CameraModelD3MultiClippingIntersection_swigregister = _StepVisual.StepVisual_CameraModelD3MultiClippingIntersection_swigregister
StepVisual_CameraModelD3MultiClippingIntersection_swigregister(StepVisual_CameraModelD3MultiClippingIntersection)

def StepVisual_CameraModelD3MultiClippingIntersection_get_type_name(*args):
    """
    StepVisual_CameraModelD3MultiClippingIntersection_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_CameraModelD3MultiClippingIntersection_get_type_name(*args)

def StepVisual_CameraModelD3MultiClippingIntersection_get_type_descriptor(*args):
    """
    StepVisual_CameraModelD3MultiClippingIntersection_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_CameraModelD3MultiClippingIntersection_get_type_descriptor(*args)

class StepVisual_PresentationLayerUsage(Standard.Standard_Transient):
    """Added from StepVisual Rev2 to Rev4"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_PresentationLayerUsage
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_PresentationLayerUsage(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_PresentationLayerUsage self) -> StepVisual_PresentationLayerUsage

        Added from StepVisual Rev2 to Rev4
        """
        this = _StepVisual.new_StepVisual_PresentationLayerUsage(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_PresentationLayerUsage self, Handle_StepVisual_PresentationLayerAssignment aAssignment, Handle_StepVisual_PresentationRepresentation aPresentation)

        :type aAssignment: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationLayerAssignment
        :type aPresentation: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationRepresentation

        """
        return _StepVisual.StepVisual_PresentationLayerUsage_Init(self, *args)


    def SetAssignment(self, *args):
        """
        SetAssignment(StepVisual_PresentationLayerUsage self, Handle_StepVisual_PresentationLayerAssignment aAssignment)

        :type aAssignment: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationLayerAssignment

        """
        return _StepVisual.StepVisual_PresentationLayerUsage_SetAssignment(self, *args)


    def Assignment(self, *args):
        """
        Assignment(StepVisual_PresentationLayerUsage self) -> Handle_StepVisual_PresentationLayerAssignment

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationLayerAssignment

        """
        return _StepVisual.StepVisual_PresentationLayerUsage_Assignment(self, *args)


    def SetPresentation(self, *args):
        """
        SetPresentation(StepVisual_PresentationLayerUsage self, Handle_StepVisual_PresentationRepresentation aPresentation)

        :type aPresentation: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationRepresentation

        """
        return _StepVisual.StepVisual_PresentationLayerUsage_SetPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(StepVisual_PresentationLayerUsage self) -> Handle_StepVisual_PresentationRepresentation

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationRepresentation

        """
        return _StepVisual.StepVisual_PresentationLayerUsage_Presentation(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_PresentationLayerUsage_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_PresentationLayerUsage_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_PresentationLayerUsage_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_PresentationLayerUsage
StepVisual_PresentationLayerUsage_swigregister = _StepVisual.StepVisual_PresentationLayerUsage_swigregister
StepVisual_PresentationLayerUsage_swigregister(StepVisual_PresentationLayerUsage)

def StepVisual_PresentationLayerUsage_get_type_name(*args):
    """
    StepVisual_PresentationLayerUsage_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_PresentationLayerUsage_get_type_name(*args)

def StepVisual_PresentationLayerUsage_get_type_descriptor(*args):
    """
    StepVisual_PresentationLayerUsage_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_PresentationLayerUsage_get_type_descriptor(*args)

class StepVisual_PresentationSize(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_PresentationSize
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_PresentationSize(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_PresentationSize self) -> StepVisual_PresentationSize

        Returns a PresentationSize


        """
        this = _StepVisual.new_StepVisual_PresentationSize(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_PresentationSize self, StepVisual_PresentationSizeAssignmentSelect aUnit, Handle_StepVisual_PlanarBox aSize)

        :type aUnit: OCC.wrapper.StepVisual.StepVisual_PresentationSizeAssignmentSelect
        :type aSize: OCC.wrapper.StepVisual.Handle_StepVisual_PlanarBox

        """
        return _StepVisual.StepVisual_PresentationSize_Init(self, *args)


    def SetUnit(self, *args):
        """
        SetUnit(StepVisual_PresentationSize self, StepVisual_PresentationSizeAssignmentSelect aUnit)

        :type aUnit: OCC.wrapper.StepVisual.StepVisual_PresentationSizeAssignmentSelect

        """
        return _StepVisual.StepVisual_PresentationSize_SetUnit(self, *args)


    def Unit(self, *args):
        """
        Unit(StepVisual_PresentationSize self) -> StepVisual_PresentationSizeAssignmentSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_PresentationSizeAssignmentSelect

        """
        return _StepVisual.StepVisual_PresentationSize_Unit(self, *args)


    def SetSize(self, *args):
        """
        SetSize(StepVisual_PresentationSize self, Handle_StepVisual_PlanarBox aSize)

        :type aSize: OCC.wrapper.StepVisual.Handle_StepVisual_PlanarBox

        """
        return _StepVisual.StepVisual_PresentationSize_SetSize(self, *args)


    def Size(self, *args):
        """
        Size(StepVisual_PresentationSize self) -> Handle_StepVisual_PlanarBox

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PlanarBox

        """
        return _StepVisual.StepVisual_PresentationSize_Size(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_PresentationSize_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_PresentationSize_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_PresentationSize_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_PresentationSize
StepVisual_PresentationSize_swigregister = _StepVisual.StepVisual_PresentationSize_swigregister
StepVisual_PresentationSize_swigregister(StepVisual_PresentationSize)

def StepVisual_PresentationSize_get_type_name(*args):
    """
    StepVisual_PresentationSize_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_PresentationSize_get_type_name(*args)

def StepVisual_PresentationSize_get_type_descriptor(*args):
    """
    StepVisual_PresentationSize_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_PresentationSize_get_type_descriptor(*args)

class StepVisual_Template(StepRepr.StepRepr_Representation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_Template
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_Template(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_Template self) -> StepVisual_Template

        Returns a Template


        """
        this = _StepVisual.new_StepVisual_Template(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_Template_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_Template_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_Template_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_Template
StepVisual_Template_swigregister = _StepVisual.StepVisual_Template_swigregister
StepVisual_Template_swigregister(StepVisual_Template)

def StepVisual_Template_get_type_name(*args):
    """
    StepVisual_Template_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_Template_get_type_name(*args)

def StepVisual_Template_get_type_descriptor(*args):
    """
    StepVisual_Template_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_Template_get_type_descriptor(*args)

class StepVisual_DraughtingAnnotationOccurrence(StepVisual_AnnotationOccurrence):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_DraughtingAnnotationOccurrence
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_DraughtingAnnotationOccurrence(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_DraughtingAnnotationOccurrence self) -> StepVisual_DraughtingAnnotationOccurrence

        Returns a DraughtingAnnotationOccurrence


        """
        this = _StepVisual.new_StepVisual_DraughtingAnnotationOccurrence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_DraughtingAnnotationOccurrence_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_DraughtingAnnotationOccurrence_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_DraughtingAnnotationOccurrence_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_DraughtingAnnotationOccurrence
StepVisual_DraughtingAnnotationOccurrence_swigregister = _StepVisual.StepVisual_DraughtingAnnotationOccurrence_swigregister
StepVisual_DraughtingAnnotationOccurrence_swigregister(StepVisual_DraughtingAnnotationOccurrence)

def StepVisual_DraughtingAnnotationOccurrence_get_type_name(*args):
    """
    StepVisual_DraughtingAnnotationOccurrence_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_DraughtingAnnotationOccurrence_get_type_name(*args)

def StepVisual_DraughtingAnnotationOccurrence_get_type_descriptor(*args):
    """
    StepVisual_DraughtingAnnotationOccurrence_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_DraughtingAnnotationOccurrence_get_type_descriptor(*args)

class StepVisual_PresentationSet(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_PresentationSet
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_PresentationSet(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_PresentationSet self) -> StepVisual_PresentationSet

        Returns a PresentationSet


        """
        this = _StepVisual.new_StepVisual_PresentationSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_PresentationSet_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_PresentationSet_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_PresentationSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_PresentationSet
StepVisual_PresentationSet_swigregister = _StepVisual.StepVisual_PresentationSet_swigregister
StepVisual_PresentationSet_swigregister(StepVisual_PresentationSet)

def StepVisual_PresentationSet_get_type_name(*args):
    """
    StepVisual_PresentationSet_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_PresentationSet_get_type_name(*args)

def StepVisual_PresentationSet_get_type_descriptor(*args):
    """
    StepVisual_PresentationSet_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_PresentationSet_get_type_descriptor(*args)

class StepVisual_AnnotationPlane(StepVisual_AnnotationOccurrence):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_AnnotationPlane
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_AnnotationPlane(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_AnnotationPlane self) -> StepVisual_AnnotationPlane

        Returns a AnnotationPlane


        """
        this = _StepVisual.new_StepVisual_AnnotationPlane(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_AnnotationPlane self, Handle_TCollection_HAsciiString theName, Handle_StepVisual_HArray1OfPresentationStyleAssignment theStyles, Handle_Standard_Transient theItem, Handle_StepVisual_HArray1OfAnnotationPlaneElement theElements)

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment
        :type theItem: OCC.wrapper.Standard.Handle_Standard_Transient
        :type theElements: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement

        """
        return _StepVisual.StepVisual_AnnotationPlane_Init(self, *args)


    def Elements(self, *args):
        """
        Elements(StepVisual_AnnotationPlane self) -> Handle_StepVisual_HArray1OfAnnotationPlaneElement

        Returns field Elements

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement

        """
        return _StepVisual.StepVisual_AnnotationPlane_Elements(self, *args)


    def SetElements(self, *args):
        """
        SetElements(StepVisual_AnnotationPlane self, Handle_StepVisual_HArray1OfAnnotationPlaneElement theElements)

        Set field Elements

        :type theElements: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement

        """
        return _StepVisual.StepVisual_AnnotationPlane_SetElements(self, *args)


    def NbElements(self, *args):
        """
        NbElements(StepVisual_AnnotationPlane self) -> Standard_Integer

        Returns number of Elements

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_AnnotationPlane_NbElements(self, *args)


    def ElementsValue(self, *args):
        """
        ElementsValue(StepVisual_AnnotationPlane self, Standard_Integer const theNum) -> StepVisual_AnnotationPlaneElement

        Returns Elements with the given number

        :type theNum: int
        :rtype: OCC.wrapper.StepVisual.StepVisual_AnnotationPlaneElement

        """
        return _StepVisual.StepVisual_AnnotationPlane_ElementsValue(self, *args)


    def SetElementsValue(self, *args):
        """
        SetElementsValue(StepVisual_AnnotationPlane self, Standard_Integer const theNum, StepVisual_AnnotationPlaneElement theItem)

        Sets Elements with given number

        :type theNum: int
        :type theItem: OCC.wrapper.StepVisual.StepVisual_AnnotationPlaneElement

        """
        return _StepVisual.StepVisual_AnnotationPlane_SetElementsValue(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_AnnotationPlane_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_AnnotationPlane_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_AnnotationPlane_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_AnnotationPlane
StepVisual_AnnotationPlane_swigregister = _StepVisual.StepVisual_AnnotationPlane_swigregister
StepVisual_AnnotationPlane_swigregister(StepVisual_AnnotationPlane)

def StepVisual_AnnotationPlane_get_type_name(*args):
    """
    StepVisual_AnnotationPlane_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_AnnotationPlane_get_type_name(*args)

def StepVisual_AnnotationPlane_get_type_descriptor(*args):
    """
    StepVisual_AnnotationPlane_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_AnnotationPlane_get_type_descriptor(*args)

class StepVisual_HArray1OfDraughtingCalloutElement(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_HArray1OfDraughtingCalloutElement
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_HArray1OfDraughtingCalloutElement(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_HArray1OfDraughtingCalloutElement self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepVisual_HArray1OfDraughtingCalloutElement
        __init__(StepVisual_HArray1OfDraughtingCalloutElement self, Standard_Integer const theLower, Standard_Integer const theUpper, StepVisual_DraughtingCalloutElement theValue) -> StepVisual_HArray1OfDraughtingCalloutElement
        __init__(StepVisual_HArray1OfDraughtingCalloutElement self, NCollection_Array1_StepVisual_DraughtingCalloutElement theOther) -> StepVisual_HArray1OfDraughtingCalloutElement

        :type theOther: OCC.wrapper.StepVisual.StepVisual_Array1OfDraughtingCalloutElement

        """
        this = _StepVisual.new_StepVisual_HArray1OfDraughtingCalloutElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfDraughtingCalloutElement

        """
        res = _StepVisual.StepVisual_HArray1OfDraughtingCalloutElement_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepVisual_HArray1OfDraughtingCalloutElement self) -> NCollection_Array1_StepVisual_DraughtingCalloutElement

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfDraughtingCalloutElement

        """
        return _StepVisual.StepVisual_HArray1OfDraughtingCalloutElement_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_HArray1OfDraughtingCalloutElement_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_HArray1OfDraughtingCalloutElement_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_HArray1OfDraughtingCalloutElement_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_HArray1OfDraughtingCalloutElement
StepVisual_HArray1OfDraughtingCalloutElement_swigregister = _StepVisual.StepVisual_HArray1OfDraughtingCalloutElement_swigregister
StepVisual_HArray1OfDraughtingCalloutElement_swigregister(StepVisual_HArray1OfDraughtingCalloutElement)

def StepVisual_HArray1OfDraughtingCalloutElement_get_type_name(*args):
    """
    StepVisual_HArray1OfDraughtingCalloutElement_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_HArray1OfDraughtingCalloutElement_get_type_name(*args)

def StepVisual_HArray1OfDraughtingCalloutElement_get_type_descriptor(*args):
    """
    StepVisual_HArray1OfDraughtingCalloutElement_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_HArray1OfDraughtingCalloutElement_get_type_descriptor(*args)

class StepVisual_PresentationLayerAssignment(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_PresentationLayerAssignment
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_PresentationLayerAssignment(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_PresentationLayerAssignment self) -> StepVisual_PresentationLayerAssignment

        Returns a PresentationLayerAssignment


        """
        this = _StepVisual.new_StepVisual_PresentationLayerAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_PresentationLayerAssignment self, Handle_TCollection_HAsciiString aName, Handle_TCollection_HAsciiString aDescription, Handle_StepVisual_HArray1OfLayeredItem aAssignedItems)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aAssignedItems: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfLayeredItem

        """
        return _StepVisual.StepVisual_PresentationLayerAssignment_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(StepVisual_PresentationLayerAssignment self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_PresentationLayerAssignment_SetName(self, *args)


    def Name(self, *args):
        """
        Name(StepVisual_PresentationLayerAssignment self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_PresentationLayerAssignment_Name(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepVisual_PresentationLayerAssignment self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_PresentationLayerAssignment_SetDescription(self, *args)


    def Description(self, *args):
        """
        Description(StepVisual_PresentationLayerAssignment self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_PresentationLayerAssignment_Description(self, *args)


    def SetAssignedItems(self, *args):
        """
        SetAssignedItems(StepVisual_PresentationLayerAssignment self, Handle_StepVisual_HArray1OfLayeredItem aAssignedItems)

        :type aAssignedItems: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfLayeredItem

        """
        return _StepVisual.StepVisual_PresentationLayerAssignment_SetAssignedItems(self, *args)


    def AssignedItems(self, *args):
        """
        AssignedItems(StepVisual_PresentationLayerAssignment self) -> Handle_StepVisual_HArray1OfLayeredItem

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfLayeredItem

        """
        return _StepVisual.StepVisual_PresentationLayerAssignment_AssignedItems(self, *args)


    def AssignedItemsValue(self, *args):
        """
        AssignedItemsValue(StepVisual_PresentationLayerAssignment self, Standard_Integer const num) -> StepVisual_LayeredItem

        :type num: int
        :rtype: OCC.wrapper.StepVisual.StepVisual_LayeredItem

        """
        return _StepVisual.StepVisual_PresentationLayerAssignment_AssignedItemsValue(self, *args)


    def NbAssignedItems(self, *args):
        """
        NbAssignedItems(StepVisual_PresentationLayerAssignment self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_PresentationLayerAssignment_NbAssignedItems(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_PresentationLayerAssignment_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_PresentationLayerAssignment_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_PresentationLayerAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_PresentationLayerAssignment
StepVisual_PresentationLayerAssignment_swigregister = _StepVisual.StepVisual_PresentationLayerAssignment_swigregister
StepVisual_PresentationLayerAssignment_swigregister(StepVisual_PresentationLayerAssignment)

def StepVisual_PresentationLayerAssignment_get_type_name(*args):
    """
    StepVisual_PresentationLayerAssignment_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_PresentationLayerAssignment_get_type_name(*args)

def StepVisual_PresentationLayerAssignment_get_type_descriptor(*args):
    """
    StepVisual_PresentationLayerAssignment_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_PresentationLayerAssignment_get_type_descriptor(*args)

class StepVisual_PlanarExtent(StepGeom.StepGeom_GeometricRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_PlanarExtent
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_PlanarExtent(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_PlanarExtent self) -> StepVisual_PlanarExtent

        Returns a PlanarExtent


        """
        this = _StepVisual.new_StepVisual_PlanarExtent(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_PlanarExtent self, Handle_TCollection_HAsciiString aName, Standard_Real const aSizeInX, Standard_Real const aSizeInY)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aSizeInX: float
        :type aSizeInY: float

        """
        return _StepVisual.StepVisual_PlanarExtent_Init(self, *args)


    def SetSizeInX(self, *args):
        """
        SetSizeInX(StepVisual_PlanarExtent self, Standard_Real const aSizeInX)

        :type aSizeInX: float

        """
        return _StepVisual.StepVisual_PlanarExtent_SetSizeInX(self, *args)


    def SizeInX(self, *args):
        """
        SizeInX(StepVisual_PlanarExtent self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepVisual.StepVisual_PlanarExtent_SizeInX(self, *args)


    def SetSizeInY(self, *args):
        """
        SetSizeInY(StepVisual_PlanarExtent self, Standard_Real const aSizeInY)

        :type aSizeInY: float

        """
        return _StepVisual.StepVisual_PlanarExtent_SetSizeInY(self, *args)


    def SizeInY(self, *args):
        """
        SizeInY(StepVisual_PlanarExtent self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepVisual.StepVisual_PlanarExtent_SizeInY(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_PlanarExtent_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_PlanarExtent_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_PlanarExtent_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_PlanarExtent
StepVisual_PlanarExtent_swigregister = _StepVisual.StepVisual_PlanarExtent_swigregister
StepVisual_PlanarExtent_swigregister(StepVisual_PlanarExtent)

def StepVisual_PlanarExtent_get_type_name(*args):
    """
    StepVisual_PlanarExtent_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_PlanarExtent_get_type_name(*args)

def StepVisual_PlanarExtent_get_type_descriptor(*args):
    """
    StepVisual_PlanarExtent_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_PlanarExtent_get_type_descriptor(*args)

class StepVisual_HArray1OfPresentationStyleSelect(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_HArray1OfPresentationStyleSelect
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_HArray1OfPresentationStyleSelect(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_HArray1OfPresentationStyleSelect self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepVisual_HArray1OfPresentationStyleSelect
        __init__(StepVisual_HArray1OfPresentationStyleSelect self, Standard_Integer const theLower, Standard_Integer const theUpper, StepVisual_PresentationStyleSelect theValue) -> StepVisual_HArray1OfPresentationStyleSelect
        __init__(StepVisual_HArray1OfPresentationStyleSelect self, NCollection_Array1_StepVisual_PresentationStyleSelect theOther) -> StepVisual_HArray1OfPresentationStyleSelect

        :type theOther: OCC.wrapper.StepVisual.StepVisual_Array1OfPresentationStyleSelect

        """
        this = _StepVisual.new_StepVisual_HArray1OfPresentationStyleSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfPresentationStyleSelect

        """
        res = _StepVisual.StepVisual_HArray1OfPresentationStyleSelect_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepVisual_HArray1OfPresentationStyleSelect self) -> NCollection_Array1_StepVisual_PresentationStyleSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfPresentationStyleSelect

        """
        return _StepVisual.StepVisual_HArray1OfPresentationStyleSelect_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_HArray1OfPresentationStyleSelect_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_HArray1OfPresentationStyleSelect_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_HArray1OfPresentationStyleSelect_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_HArray1OfPresentationStyleSelect
StepVisual_HArray1OfPresentationStyleSelect_swigregister = _StepVisual.StepVisual_HArray1OfPresentationStyleSelect_swigregister
StepVisual_HArray1OfPresentationStyleSelect_swigregister(StepVisual_HArray1OfPresentationStyleSelect)

def StepVisual_HArray1OfPresentationStyleSelect_get_type_name(*args):
    """
    StepVisual_HArray1OfPresentationStyleSelect_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_HArray1OfPresentationStyleSelect_get_type_name(*args)

def StepVisual_HArray1OfPresentationStyleSelect_get_type_descriptor(*args):
    """
    StepVisual_HArray1OfPresentationStyleSelect_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_HArray1OfPresentationStyleSelect_get_type_descriptor(*args)

class StepVisual_TextStyle(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_TextStyle
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_TextStyle(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_TextStyle self) -> StepVisual_TextStyle

        Returns a TextStyle


        """
        this = _StepVisual.new_StepVisual_TextStyle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_TextStyle self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_TextStyleForDefinedFont aCharacterAppearance)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aCharacterAppearance: OCC.wrapper.StepVisual.Handle_StepVisual_TextStyleForDefinedFont

        """
        return _StepVisual.StepVisual_TextStyle_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(StepVisual_TextStyle self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_TextStyle_SetName(self, *args)


    def Name(self, *args):
        """
        Name(StepVisual_TextStyle self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_TextStyle_Name(self, *args)


    def SetCharacterAppearance(self, *args):
        """
        SetCharacterAppearance(StepVisual_TextStyle self, Handle_StepVisual_TextStyleForDefinedFont aCharacterAppearance)

        :type aCharacterAppearance: OCC.wrapper.StepVisual.Handle_StepVisual_TextStyleForDefinedFont

        """
        return _StepVisual.StepVisual_TextStyle_SetCharacterAppearance(self, *args)


    def CharacterAppearance(self, *args):
        """
        CharacterAppearance(StepVisual_TextStyle self) -> Handle_StepVisual_TextStyleForDefinedFont

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_TextStyleForDefinedFont

        """
        return _StepVisual.StepVisual_TextStyle_CharacterAppearance(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_TextStyle_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_TextStyle_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_TextStyle_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_TextStyle
StepVisual_TextStyle_swigregister = _StepVisual.StepVisual_TextStyle_swigregister
StepVisual_TextStyle_swigregister(StepVisual_TextStyle)

def StepVisual_TextStyle_get_type_name(*args):
    """
    StepVisual_TextStyle_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_TextStyle_get_type_name(*args)

def StepVisual_TextStyle_get_type_descriptor(*args):
    """
    StepVisual_TextStyle_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_TextStyle_get_type_descriptor(*args)

class StepVisual_PresentationStyleByContext(StepVisual_PresentationStyleAssignment):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_PresentationStyleByContext
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_PresentationStyleByContext(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_PresentationStyleByContext self) -> StepVisual_PresentationStyleByContext

        Returns a PresentationStyleByContext


        """
        this = _StepVisual.new_StepVisual_PresentationStyleByContext(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_PresentationStyleByContext self, Handle_StepVisual_HArray1OfPresentationStyleSelect aStyles, StepVisual_StyleContextSelect aStyleContext)

        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect
        :type aStyleContext: OCC.wrapper.StepVisual.StepVisual_StyleContextSelect

        """
        return _StepVisual.StepVisual_PresentationStyleByContext_Init(self, *args)


    def SetStyleContext(self, *args):
        """
        SetStyleContext(StepVisual_PresentationStyleByContext self, StepVisual_StyleContextSelect aStyleContext)

        :type aStyleContext: OCC.wrapper.StepVisual.StepVisual_StyleContextSelect

        """
        return _StepVisual.StepVisual_PresentationStyleByContext_SetStyleContext(self, *args)


    def StyleContext(self, *args):
        """
        StyleContext(StepVisual_PresentationStyleByContext self) -> StepVisual_StyleContextSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_StyleContextSelect

        """
        return _StepVisual.StepVisual_PresentationStyleByContext_StyleContext(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_PresentationStyleByContext_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_PresentationStyleByContext_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_PresentationStyleByContext_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_PresentationStyleByContext
StepVisual_PresentationStyleByContext_swigregister = _StepVisual.StepVisual_PresentationStyleByContext_swigregister
StepVisual_PresentationStyleByContext_swigregister(StepVisual_PresentationStyleByContext)

def StepVisual_PresentationStyleByContext_get_type_name(*args):
    """
    StepVisual_PresentationStyleByContext_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_PresentationStyleByContext_get_type_name(*args)

def StepVisual_PresentationStyleByContext_get_type_descriptor(*args):
    """
    StepVisual_PresentationStyleByContext_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_PresentationStyleByContext_get_type_descriptor(*args)

class StepVisual_FillStyleSelect(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepVisual_FillStyleSelect self) -> StepVisual_FillStyleSelect

        Returns a FillStyleSelect SelectType


        """
        this = _StepVisual.new_StepVisual_FillStyleSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepVisual_FillStyleSelect self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a FillStyleSelect Kind Entity that is :
        1 -> FillAreaStyleColour
        2 -> ExternallyDefinedTileStyle
        3 -> FillAreaStyleTiles
        4 -> ExternallyDefinedHatchStyle
        5 -> FillAreaStyleHatching
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_FillStyleSelect_CaseNum(self, *args)


    def FillAreaStyleColour(self, *args):
        """
        FillAreaStyleColour(StepVisual_FillStyleSelect self) -> Handle_StepVisual_FillAreaStyleColour

        returns Value as a FillAreaStyleColour (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_FillAreaStyleColour

        """
        return _StepVisual.StepVisual_FillStyleSelect_FillAreaStyleColour(self, *args)

    __swig_destroy__ = _StepVisual.delete_StepVisual_FillStyleSelect
StepVisual_FillStyleSelect_swigregister = _StepVisual.StepVisual_FillStyleSelect_swigregister
StepVisual_FillStyleSelect_swigregister(StepVisual_FillStyleSelect)

class StepVisual_AnnotationTextOccurrence(StepVisual_AnnotationOccurrence):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_AnnotationTextOccurrence
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_AnnotationTextOccurrence(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_AnnotationTextOccurrence self) -> StepVisual_AnnotationTextOccurrence

        Returns a AnnotationTextOccurrence


        """
        this = _StepVisual.new_StepVisual_AnnotationTextOccurrence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_AnnotationTextOccurrence_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_AnnotationTextOccurrence_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_AnnotationTextOccurrence_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_AnnotationTextOccurrence
StepVisual_AnnotationTextOccurrence_swigregister = _StepVisual.StepVisual_AnnotationTextOccurrence_swigregister
StepVisual_AnnotationTextOccurrence_swigregister(StepVisual_AnnotationTextOccurrence)

def StepVisual_AnnotationTextOccurrence_get_type_name(*args):
    """
    StepVisual_AnnotationTextOccurrence_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_AnnotationTextOccurrence_get_type_name(*args)

def StepVisual_AnnotationTextOccurrence_get_type_descriptor(*args):
    """
    StepVisual_AnnotationTextOccurrence_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_AnnotationTextOccurrence_get_type_descriptor(*args)

class StepVisual_TessellatedGeometricSet(StepVisual_TessellatedItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_TessellatedGeometricSet
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_TessellatedGeometricSet(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_TessellatedGeometricSet self) -> StepVisual_TessellatedGeometricSet

        Returns a DraughtingCalloutElement select type


        """
        this = _StepVisual.new_StepVisual_TessellatedGeometricSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_TessellatedGeometricSet self, Handle_TCollection_HAsciiString theName, NCollection_Handle_StepVisual_Array1OfTessellatedItem theItems)

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theItems: OCC.wrapper.StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem

        """
        return _StepVisual.StepVisual_TessellatedGeometricSet_Init(self, *args)


    def Items(self, *args):
        """
        Items(StepVisual_TessellatedGeometricSet self) -> NCollection_Handle_StepVisual_Array1OfTessellatedItem

        :rtype: OCC.wrapper.StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem

        """
        return _StepVisual.StepVisual_TessellatedGeometricSet_Items(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_TessellatedGeometricSet_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_TessellatedGeometricSet_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_TessellatedGeometricSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_TessellatedGeometricSet
StepVisual_TessellatedGeometricSet_swigregister = _StepVisual.StepVisual_TessellatedGeometricSet_swigregister
StepVisual_TessellatedGeometricSet_swigregister(StepVisual_TessellatedGeometricSet)

def StepVisual_TessellatedGeometricSet_get_type_name(*args):
    """
    StepVisual_TessellatedGeometricSet_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_TessellatedGeometricSet_get_type_name(*args)

def StepVisual_TessellatedGeometricSet_get_type_descriptor(*args):
    """
    StepVisual_TessellatedGeometricSet_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_TessellatedGeometricSet_get_type_descriptor(*args)

class StepVisual_FillAreaStyle(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_FillAreaStyle
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_FillAreaStyle(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_FillAreaStyle self) -> StepVisual_FillAreaStyle

        Returns a FillAreaStyle


        """
        this = _StepVisual.new_StepVisual_FillAreaStyle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_FillAreaStyle self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_HArray1OfFillStyleSelect aFillStyles)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFillStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect

        """
        return _StepVisual.StepVisual_FillAreaStyle_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(StepVisual_FillAreaStyle self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_FillAreaStyle_SetName(self, *args)


    def Name(self, *args):
        """
        Name(StepVisual_FillAreaStyle self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_FillAreaStyle_Name(self, *args)


    def SetFillStyles(self, *args):
        """
        SetFillStyles(StepVisual_FillAreaStyle self, Handle_StepVisual_HArray1OfFillStyleSelect aFillStyles)

        :type aFillStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect

        """
        return _StepVisual.StepVisual_FillAreaStyle_SetFillStyles(self, *args)


    def FillStyles(self, *args):
        """
        FillStyles(StepVisual_FillAreaStyle self) -> Handle_StepVisual_HArray1OfFillStyleSelect

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect

        """
        return _StepVisual.StepVisual_FillAreaStyle_FillStyles(self, *args)


    def FillStylesValue(self, *args):
        """
        FillStylesValue(StepVisual_FillAreaStyle self, Standard_Integer const num) -> StepVisual_FillStyleSelect

        :type num: int
        :rtype: OCC.wrapper.StepVisual.StepVisual_FillStyleSelect

        """
        return _StepVisual.StepVisual_FillAreaStyle_FillStylesValue(self, *args)


    def NbFillStyles(self, *args):
        """
        NbFillStyles(StepVisual_FillAreaStyle self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_FillAreaStyle_NbFillStyles(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_FillAreaStyle_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_FillAreaStyle_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_FillAreaStyle_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_FillAreaStyle
StepVisual_FillAreaStyle_swigregister = _StepVisual.StepVisual_FillAreaStyle_swigregister
StepVisual_FillAreaStyle_swigregister(StepVisual_FillAreaStyle)

def StepVisual_FillAreaStyle_get_type_name(*args):
    """
    StepVisual_FillAreaStyle_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_FillAreaStyle_get_type_name(*args)

def StepVisual_FillAreaStyle_get_type_descriptor(*args):
    """
    StepVisual_FillAreaStyle_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_FillAreaStyle_get_type_descriptor(*args)

class StepVisual_TessellatedAnnotationOccurrence(StepVisual_StyledItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_TessellatedAnnotationOccurrence
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_TessellatedAnnotationOccurrence(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_TessellatedAnnotationOccurrence self) -> StepVisual_TessellatedAnnotationOccurrence

        Returns a TesselatedAnnotationOccurence


        """
        this = _StepVisual.new_StepVisual_TessellatedAnnotationOccurrence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_TessellatedAnnotationOccurrence_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_TessellatedAnnotationOccurrence_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_TessellatedAnnotationOccurrence_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_TessellatedAnnotationOccurrence
StepVisual_TessellatedAnnotationOccurrence_swigregister = _StepVisual.StepVisual_TessellatedAnnotationOccurrence_swigregister
StepVisual_TessellatedAnnotationOccurrence_swigregister(StepVisual_TessellatedAnnotationOccurrence)

def StepVisual_TessellatedAnnotationOccurrence_get_type_name(*args):
    """
    StepVisual_TessellatedAnnotationOccurrence_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_TessellatedAnnotationOccurrence_get_type_name(*args)

def StepVisual_TessellatedAnnotationOccurrence_get_type_descriptor(*args):
    """
    StepVisual_TessellatedAnnotationOccurrence_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_TessellatedAnnotationOccurrence_get_type_descriptor(*args)

class StepVisual_InvisibleItem(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepVisual_InvisibleItem self) -> StepVisual_InvisibleItem

        Returns a InvisibleItem SelectType


        """
        this = _StepVisual.new_StepVisual_InvisibleItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepVisual_InvisibleItem self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a InvisibleItem Kind Entity that is :
        1 -> StyledItem
        2 -> PresentationLayerAssignment
        3 -> PresentationRepresentation
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_InvisibleItem_CaseNum(self, *args)


    def StyledItem(self, *args):
        """
        StyledItem(StepVisual_InvisibleItem self) -> Handle_StepVisual_StyledItem

        returns Value as a StyledItem (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_StyledItem

        """
        return _StepVisual.StepVisual_InvisibleItem_StyledItem(self, *args)


    def PresentationLayerAssignment(self, *args):
        """
        PresentationLayerAssignment(StepVisual_InvisibleItem self) -> Handle_StepVisual_PresentationLayerAssignment

        returns Value as a PresentationLayerAssignment (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationLayerAssignment

        """
        return _StepVisual.StepVisual_InvisibleItem_PresentationLayerAssignment(self, *args)


    def PresentationRepresentation(self, *args):
        """
        PresentationRepresentation(StepVisual_InvisibleItem self) -> Handle_StepVisual_PresentationRepresentation

        returns Value as a PresentationRepresentation (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationRepresentation

        """
        return _StepVisual.StepVisual_InvisibleItem_PresentationRepresentation(self, *args)

    __swig_destroy__ = _StepVisual.delete_StepVisual_InvisibleItem
StepVisual_InvisibleItem_swigregister = _StepVisual.StepVisual_InvisibleItem_swigregister
StepVisual_InvisibleItem_swigregister(StepVisual_InvisibleItem)

class StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect
        __init__(StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect self, Standard_Integer const theLower, Standard_Integer const theUpper, StepVisual_CameraModelD3MultiClippingInterectionSelect theValue) -> StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect
        __init__(StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect self, NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect theOther) -> StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect

        :type theOther: OCC.wrapper.StepVisual.StepVisual_Array1OfCameraModelD3MultiClippingInterectionSelect

        """
        this = _StepVisual.new_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfCameraModelD3MultiClippingInterectionSelect

        """
        res = _StepVisual.StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect self) -> NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfCameraModelD3MultiClippingInterectionSelect

        """
        return _StepVisual.StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect
StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_swigregister = _StepVisual.StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_swigregister
StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_swigregister(StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect)

def StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_get_type_name(*args):
    """
    StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_get_type_name(*args)

def StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_get_type_descriptor(*args):
    """
    StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_get_type_descriptor(*args)

class StepVisual_CameraModelD3MultiClipping(StepVisual_CameraModelD3):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_CameraModelD3MultiClipping
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_CameraModelD3MultiClipping(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_CameraModelD3MultiClipping self) -> StepVisual_CameraModelD3MultiClipping

        Returns a CameraModelD3MultiClipping


        """
        this = _StepVisual.new_StepVisual_CameraModelD3MultiClipping(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_CameraModelD3MultiClipping self, Handle_TCollection_HAsciiString theName, Handle_StepGeom_Axis2Placement3d theViewReferenceSystem, Handle_StepVisual_ViewVolume thePerspectiveOfVolume, Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect theShapeClipping)

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theViewReferenceSystem: OCC.wrapper.StepVisual.Handle_StepGeom_Axis2Placement3d
        :type thePerspectiveOfVolume: OCC.wrapper.StepVisual.Handle_StepVisual_ViewVolume
        :type theShapeClipping: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect

        """
        return _StepVisual.StepVisual_CameraModelD3MultiClipping_Init(self, *args)


    def SetShapeClipping(self, *args):
        """
        SetShapeClipping(StepVisual_CameraModelD3MultiClipping self, Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect theShapeClipping)

        :type theShapeClipping: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect

        """
        return _StepVisual.StepVisual_CameraModelD3MultiClipping_SetShapeClipping(self, *args)


    def ShapeClipping(self, *args):
        """
        ShapeClipping(StepVisual_CameraModelD3MultiClipping self) -> Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect

        """
        return _StepVisual.StepVisual_CameraModelD3MultiClipping_ShapeClipping(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_CameraModelD3MultiClipping_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_CameraModelD3MultiClipping_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_CameraModelD3MultiClipping_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_CameraModelD3MultiClipping
StepVisual_CameraModelD3MultiClipping_swigregister = _StepVisual.StepVisual_CameraModelD3MultiClipping_swigregister
StepVisual_CameraModelD3MultiClipping_swigregister(StepVisual_CameraModelD3MultiClipping)

def StepVisual_CameraModelD3MultiClipping_get_type_name(*args):
    """
    StepVisual_CameraModelD3MultiClipping_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_CameraModelD3MultiClipping_get_type_name(*args)

def StepVisual_CameraModelD3MultiClipping_get_type_descriptor(*args):
    """
    StepVisual_CameraModelD3MultiClipping_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_CameraModelD3MultiClipping_get_type_descriptor(*args)

class Handle_StepVisual_SurfaceStyleSilhouette(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_SurfaceStyleSilhouette self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSilhouette_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_SurfaceStyleSilhouette self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSilhouette_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_SurfaceStyleSilhouette self, StepVisual_SurfaceStyleSilhouette thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSilhouette_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_SurfaceStyleSilhouette self, Handle_StepVisual_SurfaceStyleSilhouette theHandle) -> Handle_StepVisual_SurfaceStyleSilhouette
        assign(Handle_StepVisual_SurfaceStyleSilhouette self, StepVisual_SurfaceStyleSilhouette thePtr) -> Handle_StepVisual_SurfaceStyleSilhouette
        assign(Handle_StepVisual_SurfaceStyleSilhouette self, Handle_StepVisual_SurfaceStyleSilhouette theHandle) -> Handle_StepVisual_SurfaceStyleSilhouette

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSilhouette_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_SurfaceStyleSilhouette self) -> StepVisual_SurfaceStyleSilhouette

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSilhouette_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_SurfaceStyleSilhouette self) -> StepVisual_SurfaceStyleSilhouette

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSilhouette___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_SurfaceStyleSilhouette self) -> StepVisual_SurfaceStyleSilhouette

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSilhouette___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_SurfaceStyleSilhouette___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_SurfaceStyleSilhouette___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_SurfaceStyleSilhouette(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_SurfaceStyleSilhouette_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_SurfaceStyleSilhouette

    def Init(self, *args):
        """
        Init(Handle_StepVisual_SurfaceStyleSilhouette self, Handle_StepVisual_CurveStyle aStyleOfSilhouette)

        :type aStyleOfSilhouette: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSilhouette_Init(self, *args)


    def SetStyleOfSilhouette(self, *args):
        """
        SetStyleOfSilhouette(Handle_StepVisual_SurfaceStyleSilhouette self, Handle_StepVisual_CurveStyle aStyleOfSilhouette)

        :type aStyleOfSilhouette: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSilhouette_SetStyleOfSilhouette(self, *args)


    def StyleOfSilhouette(self, *args):
        """
        StyleOfSilhouette(Handle_StepVisual_SurfaceStyleSilhouette self) -> Handle_StepVisual_CurveStyle

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSilhouette_StyleOfSilhouette(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_SurfaceStyleSilhouette self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSilhouette_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_SurfaceStyleSilhouette_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_SurfaceStyleSilhouette_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_SurfaceStyleSilhouette self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSilhouette_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_SurfaceStyleSilhouette self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_SurfaceStyleSilhouette self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSilhouette_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_SurfaceStyleSilhouette self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_SurfaceStyleSilhouette self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSilhouette_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_SurfaceStyleSilhouette self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSilhouette_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_SurfaceStyleSilhouette self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSilhouette_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_SurfaceStyleSilhouette self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSilhouette_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_SurfaceStyleSilhouette self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSilhouette_DecrementRefCounter(self, *args)

Handle_StepVisual_SurfaceStyleSilhouette_swigregister = _StepVisual.Handle_StepVisual_SurfaceStyleSilhouette_swigregister
Handle_StepVisual_SurfaceStyleSilhouette_swigregister(Handle_StepVisual_SurfaceStyleSilhouette)

def Handle_StepVisual_SurfaceStyleSilhouette_DownCast(thing):
    return _StepVisual.Handle_StepVisual_SurfaceStyleSilhouette_DownCast(thing)
Handle_StepVisual_SurfaceStyleSilhouette_DownCast = _StepVisual.Handle_StepVisual_SurfaceStyleSilhouette_DownCast

class StepVisual_CameraImage3dWithScale(StepVisual_CameraImage):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_CameraImage3dWithScale
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_CameraImage3dWithScale(self) 
            return h


    def __init__(self, *args):
        """__init__(StepVisual_CameraImage3dWithScale self) -> StepVisual_CameraImage3dWithScale"""
        this = _StepVisual.new_StepVisual_CameraImage3dWithScale(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_CameraImage3dWithScale_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_CameraImage3dWithScale_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_CameraImage3dWithScale_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_CameraImage3dWithScale
StepVisual_CameraImage3dWithScale_swigregister = _StepVisual.StepVisual_CameraImage3dWithScale_swigregister
StepVisual_CameraImage3dWithScale_swigregister(StepVisual_CameraImage3dWithScale)

def StepVisual_CameraImage3dWithScale_get_type_name(*args):
    """
    StepVisual_CameraImage3dWithScale_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_CameraImage3dWithScale_get_type_name(*args)

def StepVisual_CameraImage3dWithScale_get_type_descriptor(*args):
    """
    StepVisual_CameraImage3dWithScale_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_CameraImage3dWithScale_get_type_descriptor(*args)

class Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self, StepVisual_MechanicalDesignGeometricPresentationRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self, Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation theHandle) -> Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation
        assign(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self, StepVisual_MechanicalDesignGeometricPresentationRepresentation thePtr) -> Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation
        assign(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self, Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation theHandle) -> Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self) -> StepVisual_MechanicalDesignGeometricPresentationRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self) -> StepVisual_MechanicalDesignGeometricPresentationRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self) -> StepVisual_MechanicalDesignGeometricPresentationRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_HArray1OfRepresentationItem aItems, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_DecrementRefCounter(self, *args)

Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_swigregister = _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_swigregister
Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_swigregister(Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation)

def Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_DownCast(thing):
    return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_DownCast(thing)
Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_DownCast = _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation_DownCast

class NCollection_Array1_StepVisual_LayeredItem(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_StepVisual_LayeredItem self) -> NCollection_Array1< StepVisual_LayeredItem >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_LayeredItem_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_StepVisual_LayeredItem self) -> NCollection_Array1< StepVisual_LayeredItem >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_LayeredItem_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_StepVisual_LayeredItem self) -> NCollection_Array1< StepVisual_LayeredItem >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_LayeredItem_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_StepVisual_LayeredItem self) -> NCollection_Array1< StepVisual_LayeredItem >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_LayeredItem_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepVisual.new_NCollection_Array1_StepVisual_LayeredItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_StepVisual_LayeredItem self, StepVisual_LayeredItem theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_LayeredItem_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_StepVisual_LayeredItem self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_LayeredItem_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_StepVisual_LayeredItem self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_LayeredItem_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_StepVisual_LayeredItem self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_LayeredItem_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_StepVisual_LayeredItem self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_LayeredItem_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_StepVisual_LayeredItem self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_LayeredItem_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_StepVisual_LayeredItem self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_LayeredItem_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_StepVisual_LayeredItem self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_LayeredItem_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_StepVisual_LayeredItem self, NCollection_Array1_StepVisual_LayeredItem theOther) -> NCollection_Array1_StepVisual_LayeredItem

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_LayeredItem_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_StepVisual_LayeredItem self, NCollection_Array1_StepVisual_LayeredItem theOther) -> NCollection_Array1_StepVisual_LayeredItem

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_LayeredItem_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_StepVisual_LayeredItem self, NCollection_Array1_StepVisual_LayeredItem theOther) -> NCollection_Array1_StepVisual_LayeredItem
        assign(NCollection_Array1_StepVisual_LayeredItem self, NCollection_Array1_StepVisual_LayeredItem theOther) -> NCollection_Array1_StepVisual_LayeredItem

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_LayeredItem_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_LayeredItem_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_StepVisual_LayeredItem self) -> StepVisual_LayeredItem

        @return first element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_LayeredItem_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_LayeredItem_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_StepVisual_LayeredItem self) -> StepVisual_LayeredItem

        @return last element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_LayeredItem_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_LayeredItem_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_StepVisual_LayeredItem self, Standard_Integer const theIndex) -> StepVisual_LayeredItem

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_LayeredItem_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_LayeredItem___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_LayeredItem_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_StepVisual_LayeredItem self, Standard_Integer const theIndex, StepVisual_LayeredItem theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_LayeredItem_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_StepVisual_LayeredItem self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepVisual.NCollection_Array1_StepVisual_LayeredItem_Resize(self, *args)

    __swig_destroy__ = _StepVisual.delete_NCollection_Array1_StepVisual_LayeredItem
NCollection_Array1_StepVisual_LayeredItem_swigregister = _StepVisual.NCollection_Array1_StepVisual_LayeredItem_swigregister
NCollection_Array1_StepVisual_LayeredItem_swigregister(NCollection_Array1_StepVisual_LayeredItem)


try:
	StepVisual_Array1OfLayeredItem = NCollection_Array1_StepVisual_LayeredItem
except NameError:
	pass # does not exist, probably ignored

class StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect
        __init__(StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect self, Standard_Integer const theLower, Standard_Integer const theUpper, StepVisual_CameraModelD3MultiClippingUnionSelect theValue) -> StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect
        __init__(StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect self, NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect theOther) -> StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect

        :type theOther: OCC.wrapper.StepVisual.StepVisual_Array1OfCameraModelD3MultiClippingUnionSelect

        """
        this = _StepVisual.new_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfCameraModelD3MultiClippingUnionSelect

        """
        res = _StepVisual.StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect self) -> NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfCameraModelD3MultiClippingUnionSelect

        """
        return _StepVisual.StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect
StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_swigregister = _StepVisual.StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_swigregister
StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_swigregister(StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect)

def StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_get_type_name(*args):
    """
    StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_get_type_name(*args)

def StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_get_type_descriptor(*args):
    """
    StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_get_type_descriptor(*args)

class Handle_StepVisual_CameraModelD3MultiClippingUnion(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_CameraModelD3MultiClippingUnion self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_CameraModelD3MultiClippingUnion self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_CameraModelD3MultiClippingUnion self, StepVisual_CameraModelD3MultiClippingUnion thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_CameraModelD3MultiClippingUnion self, Handle_StepVisual_CameraModelD3MultiClippingUnion theHandle) -> Handle_StepVisual_CameraModelD3MultiClippingUnion
        assign(Handle_StepVisual_CameraModelD3MultiClippingUnion self, StepVisual_CameraModelD3MultiClippingUnion thePtr) -> Handle_StepVisual_CameraModelD3MultiClippingUnion
        assign(Handle_StepVisual_CameraModelD3MultiClippingUnion self, Handle_StepVisual_CameraModelD3MultiClippingUnion theHandle) -> Handle_StepVisual_CameraModelD3MultiClippingUnion

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_CameraModelD3MultiClippingUnion self) -> StepVisual_CameraModelD3MultiClippingUnion

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_CameraModelD3MultiClippingUnion self) -> StepVisual_CameraModelD3MultiClippingUnion

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_CameraModelD3MultiClippingUnion self) -> StepVisual_CameraModelD3MultiClippingUnion

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_CameraModelD3MultiClippingUnion(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_CameraModelD3MultiClippingUnion

    def Init(self, *args):
        """
        Init(Handle_StepVisual_CameraModelD3MultiClippingUnion self, Handle_TCollection_HAsciiString theName, Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect theShapeClipping)

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theShapeClipping: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion_Init(self, *args)


    def SetShapeClipping(self, *args):
        """
        SetShapeClipping(Handle_StepVisual_CameraModelD3MultiClippingUnion self, Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect theShapeClipping)

        :type theShapeClipping: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion_SetShapeClipping(self, *args)


    def ShapeClipping(self, *args):
        """
        ShapeClipping(Handle_StepVisual_CameraModelD3MultiClippingUnion self) -> Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion_ShapeClipping(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_CameraModelD3MultiClippingUnion self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_CameraModelD3MultiClippingUnion self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_CameraModelD3MultiClippingUnion self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_CameraModelD3MultiClippingUnion self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_CameraModelD3MultiClippingUnion self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_CameraModelD3MultiClippingUnion self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_CameraModelD3MultiClippingUnion self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_CameraModelD3MultiClippingUnion self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_CameraModelD3MultiClippingUnion self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_CameraModelD3MultiClippingUnion self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_CameraModelD3MultiClippingUnion self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_CameraModelD3MultiClippingUnion self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion_DecrementRefCounter(self, *args)

Handle_StepVisual_CameraModelD3MultiClippingUnion_swigregister = _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion_swigregister
Handle_StepVisual_CameraModelD3MultiClippingUnion_swigregister(Handle_StepVisual_CameraModelD3MultiClippingUnion)

def Handle_StepVisual_CameraModelD3MultiClippingUnion_DownCast(thing):
    return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion_DownCast(thing)
Handle_StepVisual_CameraModelD3MultiClippingUnion_DownCast = _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingUnion_DownCast

class Handle_StepVisual_AnnotationFillAreaOccurrence(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_AnnotationFillAreaOccurrence self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_AnnotationFillAreaOccurrence self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_AnnotationFillAreaOccurrence self, StepVisual_AnnotationFillAreaOccurrence thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_AnnotationFillAreaOccurrence self, Handle_StepVisual_AnnotationFillAreaOccurrence theHandle) -> Handle_StepVisual_AnnotationFillAreaOccurrence
        assign(Handle_StepVisual_AnnotationFillAreaOccurrence self, StepVisual_AnnotationFillAreaOccurrence thePtr) -> Handle_StepVisual_AnnotationFillAreaOccurrence
        assign(Handle_StepVisual_AnnotationFillAreaOccurrence self, Handle_StepVisual_AnnotationFillAreaOccurrence theHandle) -> Handle_StepVisual_AnnotationFillAreaOccurrence

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_AnnotationFillAreaOccurrence self) -> StepVisual_AnnotationFillAreaOccurrence

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_AnnotationFillAreaOccurrence self) -> StepVisual_AnnotationFillAreaOccurrence

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_AnnotationFillAreaOccurrence self) -> StepVisual_AnnotationFillAreaOccurrence

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_AnnotationFillAreaOccurrence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_AnnotationFillAreaOccurrence

    def Init(self, *args):
        """
        Init(Handle_StepVisual_AnnotationFillAreaOccurrence self, Handle_TCollection_HAsciiString theName, Handle_StepVisual_HArray1OfPresentationStyleAssignment theStyles, Handle_Standard_Transient theItem, Handle_StepGeom_GeometricRepresentationItem theFillStyleTarget)

        Initialize all fields (own and inherited)

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment
        :type theItem: OCC.wrapper.Standard.Handle_Standard_Transient
        :type theFillStyleTarget: OCC.wrapper.StepGeom.Handle_StepGeom_GeometricRepresentationItem

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_Init(self, *args)


    def FillStyleTarget(self, *args):
        """
        FillStyleTarget(Handle_StepVisual_AnnotationFillAreaOccurrence self) -> Handle_StepGeom_GeometricRepresentationItem

        Returns field fill_style_target

        :rtype: OCC.wrapper.StepGeom.Handle_StepGeom_GeometricRepresentationItem

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_FillStyleTarget(self, *args)


    def SetFillStyleTarget(self, *args):
        """
        SetFillStyleTarget(Handle_StepVisual_AnnotationFillAreaOccurrence self, Handle_StepGeom_GeometricRepresentationItem theTarget)

        Set field fill_style_target

        :type theTarget: OCC.wrapper.StepGeom.Handle_StepGeom_GeometricRepresentationItem

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_SetFillStyleTarget(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_AnnotationFillAreaOccurrence self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetStyles(self, *args):
        """
        SetStyles(Handle_StepVisual_AnnotationFillAreaOccurrence self, Handle_StepVisual_HArray1OfPresentationStyleAssignment aStyles)

        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_SetStyles(self, *args)


    def Styles(self, *args):
        """
        Styles(Handle_StepVisual_AnnotationFillAreaOccurrence self) -> Handle_StepVisual_HArray1OfPresentationStyleAssignment

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_Styles(self, *args)


    def StylesValue(self, *args):
        """
        StylesValue(Handle_StepVisual_AnnotationFillAreaOccurrence self, Standard_Integer const num) -> Handle_StepVisual_PresentationStyleAssignment

        :type num: int
        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_StylesValue(self, *args)


    def NbStyles(self, *args):
        """
        NbStyles(Handle_StepVisual_AnnotationFillAreaOccurrence self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_NbStyles(self, *args)


    def SetItem(self, *args):
        """
        SetItem(Handle_StepVisual_AnnotationFillAreaOccurrence self, Handle_StepRepr_RepresentationItem aItem)
        SetItem(Handle_StepVisual_AnnotationFillAreaOccurrence self, StepVisual_StyledItemTarget aItem)

        :type aItem: OCC.wrapper.StepVisual.StepVisual_StyledItemTarget

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_SetItem(self, *args)


    def Item(self, *args):
        """
        Item(Handle_StepVisual_AnnotationFillAreaOccurrence self) -> Handle_StepRepr_RepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_Item(self, *args)


    def ItemAP242(self, *args):
        """
        ItemAP242(Handle_StepVisual_AnnotationFillAreaOccurrence self) -> StepVisual_StyledItemTarget

        :rtype: OCC.wrapper.StepVisual.StepVisual_StyledItemTarget

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_ItemAP242(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_AnnotationFillAreaOccurrence self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_AnnotationFillAreaOccurrence self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_AnnotationFillAreaOccurrence self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_AnnotationFillAreaOccurrence self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_AnnotationFillAreaOccurrence self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_AnnotationFillAreaOccurrence self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_AnnotationFillAreaOccurrence self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_AnnotationFillAreaOccurrence self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_AnnotationFillAreaOccurrence self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_AnnotationFillAreaOccurrence self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_AnnotationFillAreaOccurrence self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_DecrementRefCounter(self, *args)

Handle_StepVisual_AnnotationFillAreaOccurrence_swigregister = _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_swigregister
Handle_StepVisual_AnnotationFillAreaOccurrence_swigregister(Handle_StepVisual_AnnotationFillAreaOccurrence)

def Handle_StepVisual_AnnotationFillAreaOccurrence_DownCast(thing):
    return _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_DownCast(thing)
Handle_StepVisual_AnnotationFillAreaOccurrence_DownCast = _StepVisual.Handle_StepVisual_AnnotationFillAreaOccurrence_DownCast

class Handle_StepVisual_HArray1OfDirectionCountSelect(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_HArray1OfDirectionCountSelect self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_HArray1OfDirectionCountSelect self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_HArray1OfDirectionCountSelect self, StepVisual_HArray1OfDirectionCountSelect thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_HArray1OfDirectionCountSelect self, Handle_StepVisual_HArray1OfDirectionCountSelect theHandle) -> Handle_StepVisual_HArray1OfDirectionCountSelect
        assign(Handle_StepVisual_HArray1OfDirectionCountSelect self, StepVisual_HArray1OfDirectionCountSelect thePtr) -> Handle_StepVisual_HArray1OfDirectionCountSelect
        assign(Handle_StepVisual_HArray1OfDirectionCountSelect self, Handle_StepVisual_HArray1OfDirectionCountSelect theHandle) -> Handle_StepVisual_HArray1OfDirectionCountSelect

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_HArray1OfDirectionCountSelect self) -> StepVisual_HArray1OfDirectionCountSelect

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_HArray1OfDirectionCountSelect self) -> StepVisual_HArray1OfDirectionCountSelect

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_HArray1OfDirectionCountSelect self) -> StepVisual_HArray1OfDirectionCountSelect

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_HArray1OfDirectionCountSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_HArray1OfDirectionCountSelect

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfDirectionCountSelect

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepVisual_HArray1OfDirectionCountSelect self) -> NCollection_Array1_StepVisual_DirectionCountSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfDirectionCountSelect

        """
        return _StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_HArray1OfDirectionCountSelect self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_HArray1OfDirectionCountSelect self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_HArray1OfDirectionCountSelect self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_HArray1OfDirectionCountSelect self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_HArray1OfDirectionCountSelect self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_HArray1OfDirectionCountSelect self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_HArray1OfDirectionCountSelect self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_HArray1OfDirectionCountSelect self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_HArray1OfDirectionCountSelect self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_HArray1OfDirectionCountSelect self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect_DecrementRefCounter(self, *args)

Handle_StepVisual_HArray1OfDirectionCountSelect_swigregister = _StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect_swigregister
Handle_StepVisual_HArray1OfDirectionCountSelect_swigregister(Handle_StepVisual_HArray1OfDirectionCountSelect)

def Handle_StepVisual_HArray1OfDirectionCountSelect_DownCast(thing):
    return _StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect_DownCast(thing)
Handle_StepVisual_HArray1OfDirectionCountSelect_DownCast = _StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect_DownCast

class NCollection_Vector_Handle_TColStd_HSequenceOfInteger(NCollection.NCollection_BaseVector):
    """
    Class NCollection_Vector (dynamic array of objects)

    This class is similar to NCollection_Array1  though the indices always start
    at 0 (in Array1 the first index must be specified)

    The Vector is always created with 0 length. It can be enlarged by two means:
    1. Calling the method Append (val) - then "val" is added to the end of the
    vector (the vector length is incremented)
    2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
    to the current length of the vector,  the vector is enlarged to accomo-
    date this index

    The methods Append and SetValue return  a non-const reference  to the copied
    object  inside  the vector.  This reference  is guaranteed to be valid until
    the vector is destroyed. It can be used to access the vector member directly
    or to pass its address to other data structures.

    The vector iterator remembers the length of the vector  at the moment of the
    creation or initialisation of the iterator.   Therefore the iteration begins
    at index 0  and stops at the index equal to (remembered_length-1).  It is OK
    to enlarge the vector during the iteration.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Vector_Handle_TColStd_HSequenceOfInteger self) -> NCollection_Vector< opencascade::handle< TColStd_HSequenceOfInteger > >::iterator

        Returns an iterator pointing to the first element in the vector.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Vector_Handle_TColStd_HSequenceOfInteger_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Vector_Handle_TColStd_HSequenceOfInteger self) -> NCollection_Vector< opencascade::handle< TColStd_HSequenceOfInteger > >::iterator

        Returns an iterator referring to the past-the-end element in the vector.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Vector_Handle_TColStd_HSequenceOfInteger_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Vector_Handle_TColStd_HSequenceOfInteger self) -> NCollection_Vector< opencascade::handle< TColStd_HSequenceOfInteger > >::const_iterator

        Returns a const iterator pointing to the first element in the vector.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Vector_Handle_TColStd_HSequenceOfInteger_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Vector_Handle_TColStd_HSequenceOfInteger self) -> NCollection_Vector< opencascade::handle< TColStd_HSequenceOfInteger > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the vector.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Vector_Handle_TColStd_HSequenceOfInteger_cend(self, *args)


    def __init__(self, *args):
        """
        Class NCollection_Vector (dynamic array of objects)

        This class is similar to NCollection_Array1  though the indices always start
        at 0 (in Array1 the first index must be specified)

        The Vector is always created with 0 length. It can be enlarged by two means:
        1. Calling the method Append (val) - then "val" is added to the end of the
        vector (the vector length is incremented)
        2. Calling the method SetValue (i, val)  - if "i" is greater than or equal
        to the current length of the vector,  the vector is enlarged to accomo-
        date this index

        The methods Append and SetValue return  a non-const reference  to the copied
        object  inside  the vector.  This reference  is guaranteed to be valid until
        the vector is destroyed. It can be used to access the vector member directly
        or to pass its address to other data structures.

        The vector iterator remembers the length of the vector  at the moment of the
        creation or initialisation of the iterator.   Therefore the iteration begins
        at index 0  and stops at the index equal to (remembered_length-1).  It is OK
        to enlarge the vector during the iteration.
        """
        this = _StepVisual.new_NCollection_Vector_Handle_TColStd_HSequenceOfInteger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Length(self, *args):
        """
        Length(NCollection_Vector_Handle_TColStd_HSequenceOfInteger self) -> Standard_Integer

        Total number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Vector_Handle_TColStd_HSequenceOfInteger_Length(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Vector_Handle_TColStd_HSequenceOfInteger self) -> Standard_Integer

        Total number of items in the vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Vector_Handle_TColStd_HSequenceOfInteger_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Vector_Handle_TColStd_HSequenceOfInteger self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Vector_Handle_TColStd_HSequenceOfInteger_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Vector_Handle_TColStd_HSequenceOfInteger self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Vector_Handle_TColStd_HSequenceOfInteger_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Vector_Handle_TColStd_HSequenceOfInteger self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Vector_Handle_TColStd_HSequenceOfInteger_IsEmpty(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Vector_Handle_TColStd_HSequenceOfInteger self, NCollection_Vector_Handle_TColStd_HSequenceOfInteger theOther, Standard_Boolean const theOwnAllocator)

        Assignment to the collection of the same type

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :type theOwnAllocator: bool

        """
        return _StepVisual.NCollection_Vector_Handle_TColStd_HSequenceOfInteger_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Vector_Handle_TColStd_HSequenceOfInteger self, NCollection_Vector_Handle_TColStd_HSequenceOfInteger theOther) -> NCollection_Vector_Handle_TColStd_HSequenceOfInteger

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :rtype: OCC.wrapper.NCollection.NCollection_Vector

        """
        return _StepVisual.NCollection_Vector_Handle_TColStd_HSequenceOfInteger_assign(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Vector_Handle_TColStd_HSequenceOfInteger self, Handle_TColStd_HSequenceOfInteger theValue) -> Handle_TColStd_HSequenceOfInteger

        Append

        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Vector_Handle_TColStd_HSequenceOfInteger_Append(self, *args)


    def Appended(self, *args):
        """
        Appended(NCollection_Vector_Handle_TColStd_HSequenceOfInteger self) -> Handle_TColStd_HSequenceOfInteger

        Appends an empty value and returns the reference to it

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Vector_Handle_TColStd_HSequenceOfInteger_Appended(self, *args)


    def Value(self, *args):
        """
        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Vector_Handle_TColStd_HSequenceOfInteger_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Vector_Handle_TColStd_HSequenceOfInteger_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Vector_Handle_TColStd_HSequenceOfInteger self) -> Handle_TColStd_HSequenceOfInteger

        @return first element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Vector_Handle_TColStd_HSequenceOfInteger_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Vector_Handle_TColStd_HSequenceOfInteger_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Vector_Handle_TColStd_HSequenceOfInteger self) -> Handle_TColStd_HSequenceOfInteger

        @return last element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Vector_Handle_TColStd_HSequenceOfInteger_ChangeLast(self, *args)


    def __call__(self, *args):
        """
        Operator() - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Vector_Handle_TColStd_HSequenceOfInteger___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        Operator[] - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Vector_Handle_TColStd_HSequenceOfInteger_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Vector_Handle_TColStd_HSequenceOfInteger self, Standard_Integer const theIndex) -> Handle_TColStd_HSequenceOfInteger

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Vector_Handle_TColStd_HSequenceOfInteger_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Vector_Handle_TColStd_HSequenceOfInteger self, Standard_Integer const theIndex, Handle_TColStd_HSequenceOfInteger theValue) -> Handle_TColStd_HSequenceOfInteger

        SetValue () - set or append a value

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Vector_Handle_TColStd_HSequenceOfInteger_SetValue(self, *args)

    __swig_destroy__ = _StepVisual.delete_NCollection_Vector_Handle_TColStd_HSequenceOfInteger
NCollection_Vector_Handle_TColStd_HSequenceOfInteger_swigregister = _StepVisual.NCollection_Vector_Handle_TColStd_HSequenceOfInteger_swigregister
NCollection_Vector_Handle_TColStd_HSequenceOfInteger_swigregister(NCollection_Vector_Handle_TColStd_HSequenceOfInteger)


try:
	StepVisual_VectorOfHSequenceOfInteger = NCollection_Vector_Handle_TColStd_HSequenceOfInteger
except NameError:
	pass # does not exist, probably ignored

class StepVisual_AnnotationFillArea(StepShape.StepShape_GeometricCurveSet):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_AnnotationFillArea
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_AnnotationFillArea(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_AnnotationFillArea self) -> StepVisual_AnnotationFillArea

        Returns a AnnotationFillArea


        """
        this = _StepVisual.new_StepVisual_AnnotationFillArea(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_AnnotationFillArea_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_AnnotationFillArea_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_AnnotationFillArea_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_AnnotationFillArea
StepVisual_AnnotationFillArea_swigregister = _StepVisual.StepVisual_AnnotationFillArea_swigregister
StepVisual_AnnotationFillArea_swigregister(StepVisual_AnnotationFillArea)

def StepVisual_AnnotationFillArea_get_type_name(*args):
    """
    StepVisual_AnnotationFillArea_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_AnnotationFillArea_get_type_name(*args)

def StepVisual_AnnotationFillArea_get_type_descriptor(*args):
    """
    StepVisual_AnnotationFillArea_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_AnnotationFillArea_get_type_descriptor(*args)

class Handle_StepVisual_Colour(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_Colour self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_Colour_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_Colour self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_Colour_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_Colour self, StepVisual_Colour thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_Colour_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_Colour self, Handle_StepVisual_Colour theHandle) -> Handle_StepVisual_Colour
        assign(Handle_StepVisual_Colour self, StepVisual_Colour thePtr) -> Handle_StepVisual_Colour
        assign(Handle_StepVisual_Colour self, Handle_StepVisual_Colour theHandle) -> Handle_StepVisual_Colour

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_Colour_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_Colour self) -> StepVisual_Colour

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_Colour_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_Colour self) -> StepVisual_Colour

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_Colour___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_Colour self) -> StepVisual_Colour

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_Colour___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_Colour___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_Colour___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_Colour(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_Colour_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_Colour

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_Colour self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_Colour_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_Colour_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_Colour_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_Colour self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_Colour_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_Colour self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_Colour self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_Colour_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_Colour self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_Colour self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_Colour_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_Colour self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_Colour_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_Colour self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_Colour_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_Colour self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_Colour_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_Colour self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_Colour_DecrementRefCounter(self, *args)

Handle_StepVisual_Colour_swigregister = _StepVisual.Handle_StepVisual_Colour_swigregister
Handle_StepVisual_Colour_swigregister(Handle_StepVisual_Colour)

def Handle_StepVisual_Colour_DownCast(thing):
    return _StepVisual.Handle_StepVisual_Colour_DownCast(thing)
Handle_StepVisual_Colour_DownCast = _StepVisual.Handle_StepVisual_Colour_DownCast

class Handle_StepVisual_AnnotationText(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_AnnotationText self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_AnnotationText_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_AnnotationText self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_AnnotationText_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_AnnotationText self, StepVisual_AnnotationText thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_AnnotationText_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_AnnotationText self, Handle_StepVisual_AnnotationText theHandle) -> Handle_StepVisual_AnnotationText
        assign(Handle_StepVisual_AnnotationText self, StepVisual_AnnotationText thePtr) -> Handle_StepVisual_AnnotationText
        assign(Handle_StepVisual_AnnotationText self, Handle_StepVisual_AnnotationText theHandle) -> Handle_StepVisual_AnnotationText

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_AnnotationText_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_AnnotationText self) -> StepVisual_AnnotationText

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_AnnotationText_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_AnnotationText self) -> StepVisual_AnnotationText

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_AnnotationText___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_AnnotationText self) -> StepVisual_AnnotationText

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_AnnotationText___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_AnnotationText___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_AnnotationText___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_AnnotationText(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_AnnotationText_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_AnnotationText

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_AnnotationText self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_AnnotationText_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_AnnotationText_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_AnnotationText_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_AnnotationText self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_RepresentationMap aMappingSource, Handle_StepRepr_RepresentationItem aMappingTarget)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aMappingSource: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationMap
        :type aMappingTarget: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_AnnotationText_Init(self, *args)


    def SetMappingSource(self, *args):
        """
        SetMappingSource(Handle_StepVisual_AnnotationText self, Handle_StepRepr_RepresentationMap aMappingSource)

        :type aMappingSource: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationMap

        """
        return _StepVisual.Handle_StepVisual_AnnotationText_SetMappingSource(self, *args)


    def MappingSource(self, *args):
        """
        MappingSource(Handle_StepVisual_AnnotationText self) -> Handle_StepRepr_RepresentationMap

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationMap

        """
        return _StepVisual.Handle_StepVisual_AnnotationText_MappingSource(self, *args)


    def SetMappingTarget(self, *args):
        """
        SetMappingTarget(Handle_StepVisual_AnnotationText self, Handle_StepRepr_RepresentationItem aMappingTarget)

        :type aMappingTarget: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_AnnotationText_SetMappingTarget(self, *args)


    def MappingTarget(self, *args):
        """
        MappingTarget(Handle_StepVisual_AnnotationText self) -> Handle_StepRepr_RepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_AnnotationText_MappingTarget(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_AnnotationText self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_AnnotationText_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_AnnotationText self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_AnnotationText_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_AnnotationText self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_AnnotationText_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_AnnotationText self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_AnnotationText self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_AnnotationText_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_AnnotationText self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_AnnotationText self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_AnnotationText_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_AnnotationText self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_AnnotationText_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_AnnotationText self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_AnnotationText_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_AnnotationText self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_AnnotationText_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_AnnotationText self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_AnnotationText_DecrementRefCounter(self, *args)

Handle_StepVisual_AnnotationText_swigregister = _StepVisual.Handle_StepVisual_AnnotationText_swigregister
Handle_StepVisual_AnnotationText_swigregister(Handle_StepVisual_AnnotationText)

def Handle_StepVisual_AnnotationText_DownCast(thing):
    return _StepVisual.Handle_StepVisual_AnnotationText_DownCast(thing)
Handle_StepVisual_AnnotationText_DownCast = _StepVisual.Handle_StepVisual_AnnotationText_DownCast

class StepVisual_PresentationView(StepVisual_PresentationRepresentation):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_PresentationView
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_PresentationView(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_PresentationView self) -> StepVisual_PresentationView

        Returns a PresentationView


        """
        this = _StepVisual.new_StepVisual_PresentationView(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_PresentationView_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_PresentationView_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_PresentationView_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_PresentationView
StepVisual_PresentationView_swigregister = _StepVisual.StepVisual_PresentationView_swigregister
StepVisual_PresentationView_swigregister(StepVisual_PresentationView)

def StepVisual_PresentationView_get_type_name(*args):
    """
    StepVisual_PresentationView_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_PresentationView_get_type_name(*args)

def StepVisual_PresentationView_get_type_descriptor(*args):
    """
    StepVisual_PresentationView_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_PresentationView_get_type_descriptor(*args)

class Handle_StepVisual_DraughtingPreDefinedColour(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_DraughtingPreDefinedColour self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedColour_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_DraughtingPreDefinedColour self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedColour_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_DraughtingPreDefinedColour self, StepVisual_DraughtingPreDefinedColour thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedColour_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_DraughtingPreDefinedColour self, Handle_StepVisual_DraughtingPreDefinedColour theHandle) -> Handle_StepVisual_DraughtingPreDefinedColour
        assign(Handle_StepVisual_DraughtingPreDefinedColour self, StepVisual_DraughtingPreDefinedColour thePtr) -> Handle_StepVisual_DraughtingPreDefinedColour
        assign(Handle_StepVisual_DraughtingPreDefinedColour self, Handle_StepVisual_DraughtingPreDefinedColour theHandle) -> Handle_StepVisual_DraughtingPreDefinedColour

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedColour_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_DraughtingPreDefinedColour self) -> StepVisual_DraughtingPreDefinedColour

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedColour_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_DraughtingPreDefinedColour self) -> StepVisual_DraughtingPreDefinedColour

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedColour___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_DraughtingPreDefinedColour self) -> StepVisual_DraughtingPreDefinedColour

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedColour___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedColour___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_DraughtingPreDefinedColour___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_DraughtingPreDefinedColour(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_DraughtingPreDefinedColour_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_DraughtingPreDefinedColour

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_DraughtingPreDefinedColour self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedColour_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_DraughtingPreDefinedColour_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_DraughtingPreDefinedColour_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetPreDefinedItem(self, *args):
        """
        SetPreDefinedItem(Handle_StepVisual_DraughtingPreDefinedColour self, Handle_StepVisual_PreDefinedItem item)

        set a pre_defined_item part

        :type item: OCC.wrapper.StepVisual.Handle_StepVisual_PreDefinedItem

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedColour_SetPreDefinedItem(self, *args)


    def GetPreDefinedItem(self, *args):
        """
        return a pre_defined_item part

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PreDefinedItem

        """
        res = _StepVisual.Handle_StepVisual_DraughtingPreDefinedColour_GetPreDefinedItem(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_DraughtingPreDefinedColour self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedColour_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_DraughtingPreDefinedColour self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_DraughtingPreDefinedColour self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedColour_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_DraughtingPreDefinedColour self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_DraughtingPreDefinedColour self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedColour_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_DraughtingPreDefinedColour self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedColour_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_DraughtingPreDefinedColour self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedColour_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_DraughtingPreDefinedColour self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedColour_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_DraughtingPreDefinedColour self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedColour_DecrementRefCounter(self, *args)

Handle_StepVisual_DraughtingPreDefinedColour_swigregister = _StepVisual.Handle_StepVisual_DraughtingPreDefinedColour_swigregister
Handle_StepVisual_DraughtingPreDefinedColour_swigregister(Handle_StepVisual_DraughtingPreDefinedColour)

def Handle_StepVisual_DraughtingPreDefinedColour_DownCast(thing):
    return _StepVisual.Handle_StepVisual_DraughtingPreDefinedColour_DownCast(thing)
Handle_StepVisual_DraughtingPreDefinedColour_DownCast = _StepVisual.Handle_StepVisual_DraughtingPreDefinedColour_DownCast

class StepVisual_BoxCharacteristicSelect(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(StepVisual_BoxCharacteristicSelect self) -> StepVisual_BoxCharacteristicSelect"""
        this = _StepVisual.new_StepVisual_BoxCharacteristicSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def TypeOfContent(self, *args):
        """
        TypeOfContent(StepVisual_BoxCharacteristicSelect self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_BoxCharacteristicSelect_TypeOfContent(self, *args)


    def SetTypeOfContent(self, *args):
        """
        SetTypeOfContent(StepVisual_BoxCharacteristicSelect self, Standard_Integer const aType)

        :type aType: int

        """
        return _StepVisual.StepVisual_BoxCharacteristicSelect_SetTypeOfContent(self, *args)


    def RealValue(self, *args):
        """
        RealValue(StepVisual_BoxCharacteristicSelect self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepVisual.StepVisual_BoxCharacteristicSelect_RealValue(self, *args)


    def SetRealValue(self, *args):
        """
        SetRealValue(StepVisual_BoxCharacteristicSelect self, Standard_Real const aValue)

        :type aValue: float

        """
        return _StepVisual.StepVisual_BoxCharacteristicSelect_SetRealValue(self, *args)

    __swig_destroy__ = _StepVisual.delete_StepVisual_BoxCharacteristicSelect
StepVisual_BoxCharacteristicSelect_swigregister = _StepVisual.StepVisual_BoxCharacteristicSelect_swigregister
StepVisual_BoxCharacteristicSelect_swigregister(StepVisual_BoxCharacteristicSelect)

class Handle_StepVisual_StyledItem(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_StyledItem self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_StyledItem_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_StyledItem self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_StyledItem_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_StyledItem self, StepVisual_StyledItem thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_StyledItem_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_StyledItem self, Handle_StepVisual_StyledItem theHandle) -> Handle_StepVisual_StyledItem
        assign(Handle_StepVisual_StyledItem self, StepVisual_StyledItem thePtr) -> Handle_StepVisual_StyledItem
        assign(Handle_StepVisual_StyledItem self, Handle_StepVisual_StyledItem theHandle) -> Handle_StepVisual_StyledItem

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_StyledItem_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_StyledItem self) -> StepVisual_StyledItem

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_StyledItem_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_StyledItem self) -> StepVisual_StyledItem

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_StyledItem___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_StyledItem self) -> StepVisual_StyledItem

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_StyledItem___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_StyledItem___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_StyledItem___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_StyledItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_StyledItem_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_StyledItem

    def Init(self, *args):
        """
        Init(Handle_StepVisual_StyledItem self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_HArray1OfPresentationStyleAssignment aStyles, Handle_Standard_Transient aItem)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment
        :type aItem: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_StyledItem_Init(self, *args)


    def SetStyles(self, *args):
        """
        SetStyles(Handle_StepVisual_StyledItem self, Handle_StepVisual_HArray1OfPresentationStyleAssignment aStyles)

        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_StyledItem_SetStyles(self, *args)


    def Styles(self, *args):
        """
        Styles(Handle_StepVisual_StyledItem self) -> Handle_StepVisual_HArray1OfPresentationStyleAssignment

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_StyledItem_Styles(self, *args)


    def StylesValue(self, *args):
        """
        StylesValue(Handle_StepVisual_StyledItem self, Standard_Integer const num) -> Handle_StepVisual_PresentationStyleAssignment

        :type num: int
        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_StyledItem_StylesValue(self, *args)


    def NbStyles(self, *args):
        """
        NbStyles(Handle_StepVisual_StyledItem self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_StyledItem_NbStyles(self, *args)


    def SetItem(self, *args):
        """
        SetItem(Handle_StepVisual_StyledItem self, Handle_StepRepr_RepresentationItem aItem)
        SetItem(Handle_StepVisual_StyledItem self, StepVisual_StyledItemTarget aItem)

        :type aItem: OCC.wrapper.StepVisual.StepVisual_StyledItemTarget

        """
        return _StepVisual.Handle_StepVisual_StyledItem_SetItem(self, *args)


    def Item(self, *args):
        """
        Item(Handle_StepVisual_StyledItem self) -> Handle_StepRepr_RepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_StyledItem_Item(self, *args)


    def ItemAP242(self, *args):
        """
        ItemAP242(Handle_StepVisual_StyledItem self) -> StepVisual_StyledItemTarget

        :rtype: OCC.wrapper.StepVisual.StepVisual_StyledItemTarget

        """
        return _StepVisual.Handle_StepVisual_StyledItem_ItemAP242(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_StyledItem self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_StyledItem_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_StyledItem_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_StyledItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_StyledItem self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_StyledItem_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_StyledItem self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_StyledItem_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_StyledItem self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_StyledItem_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_StyledItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_StyledItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_StyledItem_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_StyledItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_StyledItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_StyledItem_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_StyledItem self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_StyledItem_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_StyledItem self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_StyledItem_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_StyledItem self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_StyledItem_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_StyledItem self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_StyledItem_DecrementRefCounter(self, *args)

Handle_StepVisual_StyledItem_swigregister = _StepVisual.Handle_StepVisual_StyledItem_swigregister
Handle_StepVisual_StyledItem_swigregister(Handle_StepVisual_StyledItem)

def Handle_StepVisual_StyledItem_DownCast(thing):
    return _StepVisual.Handle_StepVisual_StyledItem_DownCast(thing)
Handle_StepVisual_StyledItem_DownCast = _StepVisual.Handle_StepVisual_StyledItem_DownCast

class StepVisual_PlanarBox(StepVisual_PlanarExtent):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_PlanarBox
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_PlanarBox(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_PlanarBox self) -> StepVisual_PlanarBox

        Returns a PlanarBox


        """
        this = _StepVisual.new_StepVisual_PlanarBox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_PlanarBox self, Handle_TCollection_HAsciiString aName, Standard_Real const aSizeInX, Standard_Real const aSizeInY, StepGeom_Axis2Placement aPlacement)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aSizeInX: float
        :type aSizeInY: float
        :type aPlacement: OCC.wrapper.StepGeom.StepGeom_Axis2Placement

        """
        return _StepVisual.StepVisual_PlanarBox_Init(self, *args)


    def SetPlacement(self, *args):
        """
        SetPlacement(StepVisual_PlanarBox self, StepGeom_Axis2Placement aPlacement)

        :type aPlacement: OCC.wrapper.StepGeom.StepGeom_Axis2Placement

        """
        return _StepVisual.StepVisual_PlanarBox_SetPlacement(self, *args)


    def Placement(self, *args):
        """
        Placement(StepVisual_PlanarBox self) -> StepGeom_Axis2Placement

        :rtype: OCC.wrapper.StepGeom.StepGeom_Axis2Placement

        """
        return _StepVisual.StepVisual_PlanarBox_Placement(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_PlanarBox_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_PlanarBox_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_PlanarBox_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_PlanarBox
StepVisual_PlanarBox_swigregister = _StepVisual.StepVisual_PlanarBox_swigregister
StepVisual_PlanarBox_swigregister(StepVisual_PlanarBox)

def StepVisual_PlanarBox_get_type_name(*args):
    """
    StepVisual_PlanarBox_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_PlanarBox_get_type_name(*args)

def StepVisual_PlanarBox_get_type_descriptor(*args):
    """
    StepVisual_PlanarBox_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_PlanarBox_get_type_descriptor(*args)

class StepVisual_BackgroundColour(StepVisual_Colour):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_BackgroundColour
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_BackgroundColour(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_BackgroundColour self) -> StepVisual_BackgroundColour

        Returns a BackgroundColour


        """
        this = _StepVisual.new_StepVisual_BackgroundColour(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_BackgroundColour self, StepVisual_AreaOrView aPresentation)

        :type aPresentation: OCC.wrapper.StepVisual.StepVisual_AreaOrView

        """
        return _StepVisual.StepVisual_BackgroundColour_Init(self, *args)


    def SetPresentation(self, *args):
        """
        SetPresentation(StepVisual_BackgroundColour self, StepVisual_AreaOrView aPresentation)

        :type aPresentation: OCC.wrapper.StepVisual.StepVisual_AreaOrView

        """
        return _StepVisual.StepVisual_BackgroundColour_SetPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(StepVisual_BackgroundColour self) -> StepVisual_AreaOrView

        :rtype: OCC.wrapper.StepVisual.StepVisual_AreaOrView

        """
        return _StepVisual.StepVisual_BackgroundColour_Presentation(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_BackgroundColour_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_BackgroundColour_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_BackgroundColour_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_BackgroundColour
StepVisual_BackgroundColour_swigregister = _StepVisual.StepVisual_BackgroundColour_swigregister
StepVisual_BackgroundColour_swigregister(StepVisual_BackgroundColour)

def StepVisual_BackgroundColour_get_type_name(*args):
    """
    StepVisual_BackgroundColour_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_BackgroundColour_get_type_name(*args)

def StepVisual_BackgroundColour_get_type_descriptor(*args):
    """
    StepVisual_BackgroundColour_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_BackgroundColour_get_type_descriptor(*args)

class StepVisual_CurveStyle(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_CurveStyle
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_CurveStyle(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_CurveStyle self) -> StepVisual_CurveStyle

        Returns a CurveStyle


        """
        this = _StepVisual.new_StepVisual_CurveStyle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_CurveStyle self, Handle_TCollection_HAsciiString aName, StepVisual_CurveStyleFontSelect aCurveFont, StepBasic_SizeSelect aCurveWidth, Handle_StepVisual_Colour aCurveColour)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aCurveFont: OCC.wrapper.StepVisual.StepVisual_CurveStyleFontSelect
        :type aCurveWidth: OCC.wrapper.StepBasic.StepBasic_SizeSelect
        :type aCurveColour: OCC.wrapper.StepVisual.Handle_StepVisual_Colour

        """
        return _StepVisual.StepVisual_CurveStyle_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(StepVisual_CurveStyle self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_CurveStyle_SetName(self, *args)


    def Name(self, *args):
        """
        Name(StepVisual_CurveStyle self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_CurveStyle_Name(self, *args)


    def SetCurveFont(self, *args):
        """
        SetCurveFont(StepVisual_CurveStyle self, StepVisual_CurveStyleFontSelect aCurveFont)

        :type aCurveFont: OCC.wrapper.StepVisual.StepVisual_CurveStyleFontSelect

        """
        return _StepVisual.StepVisual_CurveStyle_SetCurveFont(self, *args)


    def CurveFont(self, *args):
        """
        CurveFont(StepVisual_CurveStyle self) -> StepVisual_CurveStyleFontSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_CurveStyleFontSelect

        """
        return _StepVisual.StepVisual_CurveStyle_CurveFont(self, *args)


    def SetCurveWidth(self, *args):
        """
        SetCurveWidth(StepVisual_CurveStyle self, StepBasic_SizeSelect aCurveWidth)

        :type aCurveWidth: OCC.wrapper.StepBasic.StepBasic_SizeSelect

        """
        return _StepVisual.StepVisual_CurveStyle_SetCurveWidth(self, *args)


    def CurveWidth(self, *args):
        """
        CurveWidth(StepVisual_CurveStyle self) -> StepBasic_SizeSelect

        :rtype: OCC.wrapper.StepBasic.StepBasic_SizeSelect

        """
        return _StepVisual.StepVisual_CurveStyle_CurveWidth(self, *args)


    def SetCurveColour(self, *args):
        """
        SetCurveColour(StepVisual_CurveStyle self, Handle_StepVisual_Colour aCurveColour)

        :type aCurveColour: OCC.wrapper.StepVisual.Handle_StepVisual_Colour

        """
        return _StepVisual.StepVisual_CurveStyle_SetCurveColour(self, *args)


    def CurveColour(self, *args):
        """
        CurveColour(StepVisual_CurveStyle self) -> Handle_StepVisual_Colour

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_Colour

        """
        return _StepVisual.StepVisual_CurveStyle_CurveColour(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_CurveStyle_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_CurveStyle_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_CurveStyle_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_CurveStyle
StepVisual_CurveStyle_swigregister = _StepVisual.StepVisual_CurveStyle_swigregister
StepVisual_CurveStyle_swigregister(StepVisual_CurveStyle)

def StepVisual_CurveStyle_get_type_name(*args):
    """
    StepVisual_CurveStyle_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_CurveStyle_get_type_name(*args)

def StepVisual_CurveStyle_get_type_descriptor(*args):
    """
    StepVisual_CurveStyle_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_CurveStyle_get_type_descriptor(*args)

class Handle_StepVisual_SurfaceStyleBoundary(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_SurfaceStyleBoundary self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleBoundary_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_SurfaceStyleBoundary self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleBoundary_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_SurfaceStyleBoundary self, StepVisual_SurfaceStyleBoundary thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleBoundary_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_SurfaceStyleBoundary self, Handle_StepVisual_SurfaceStyleBoundary theHandle) -> Handle_StepVisual_SurfaceStyleBoundary
        assign(Handle_StepVisual_SurfaceStyleBoundary self, StepVisual_SurfaceStyleBoundary thePtr) -> Handle_StepVisual_SurfaceStyleBoundary
        assign(Handle_StepVisual_SurfaceStyleBoundary self, Handle_StepVisual_SurfaceStyleBoundary theHandle) -> Handle_StepVisual_SurfaceStyleBoundary

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleBoundary_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_SurfaceStyleBoundary self) -> StepVisual_SurfaceStyleBoundary

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleBoundary_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_SurfaceStyleBoundary self) -> StepVisual_SurfaceStyleBoundary

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleBoundary___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_SurfaceStyleBoundary self) -> StepVisual_SurfaceStyleBoundary

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleBoundary___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_SurfaceStyleBoundary___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_SurfaceStyleBoundary___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_SurfaceStyleBoundary(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_SurfaceStyleBoundary_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_SurfaceStyleBoundary

    def Init(self, *args):
        """
        Init(Handle_StepVisual_SurfaceStyleBoundary self, Handle_StepVisual_CurveStyle aStyleOfBoundary)

        :type aStyleOfBoundary: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleBoundary_Init(self, *args)


    def SetStyleOfBoundary(self, *args):
        """
        SetStyleOfBoundary(Handle_StepVisual_SurfaceStyleBoundary self, Handle_StepVisual_CurveStyle aStyleOfBoundary)

        :type aStyleOfBoundary: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleBoundary_SetStyleOfBoundary(self, *args)


    def StyleOfBoundary(self, *args):
        """
        StyleOfBoundary(Handle_StepVisual_SurfaceStyleBoundary self) -> Handle_StepVisual_CurveStyle

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleBoundary_StyleOfBoundary(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_SurfaceStyleBoundary self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleBoundary_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_SurfaceStyleBoundary_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_SurfaceStyleBoundary_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_SurfaceStyleBoundary self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleBoundary_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_SurfaceStyleBoundary self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_SurfaceStyleBoundary self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleBoundary_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_SurfaceStyleBoundary self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_SurfaceStyleBoundary self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleBoundary_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_SurfaceStyleBoundary self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleBoundary_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_SurfaceStyleBoundary self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleBoundary_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_SurfaceStyleBoundary self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleBoundary_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_SurfaceStyleBoundary self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleBoundary_DecrementRefCounter(self, *args)

Handle_StepVisual_SurfaceStyleBoundary_swigregister = _StepVisual.Handle_StepVisual_SurfaceStyleBoundary_swigregister
Handle_StepVisual_SurfaceStyleBoundary_swigregister(Handle_StepVisual_SurfaceStyleBoundary)

def Handle_StepVisual_SurfaceStyleBoundary_DownCast(thing):
    return _StepVisual.Handle_StepVisual_SurfaceStyleBoundary_DownCast(thing)
Handle_StepVisual_SurfaceStyleBoundary_DownCast = _StepVisual.Handle_StepVisual_SurfaceStyleBoundary_DownCast

class StepVisual_MechanicalDesignGeometricPresentationArea(StepVisual_PresentationArea):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_MechanicalDesignGeometricPresentationArea
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_MechanicalDesignGeometricPresentationArea(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_MechanicalDesignGeometricPresentationArea self) -> StepVisual_MechanicalDesignGeometricPresentationArea

        Returns a MechanicalDesignGeometricPresentationArea


        """
        this = _StepVisual.new_StepVisual_MechanicalDesignGeometricPresentationArea(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_MechanicalDesignGeometricPresentationArea_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_MechanicalDesignGeometricPresentationArea_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_MechanicalDesignGeometricPresentationArea_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_MechanicalDesignGeometricPresentationArea
StepVisual_MechanicalDesignGeometricPresentationArea_swigregister = _StepVisual.StepVisual_MechanicalDesignGeometricPresentationArea_swigregister
StepVisual_MechanicalDesignGeometricPresentationArea_swigregister(StepVisual_MechanicalDesignGeometricPresentationArea)

def StepVisual_MechanicalDesignGeometricPresentationArea_get_type_name(*args):
    """
    StepVisual_MechanicalDesignGeometricPresentationArea_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_MechanicalDesignGeometricPresentationArea_get_type_name(*args)

def StepVisual_MechanicalDesignGeometricPresentationArea_get_type_descriptor(*args):
    """
    StepVisual_MechanicalDesignGeometricPresentationArea_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_MechanicalDesignGeometricPresentationArea_get_type_descriptor(*args)

class Handle_StepVisual_CameraImage(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_CameraImage self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_CameraImage_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_CameraImage self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_CameraImage_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_CameraImage self, StepVisual_CameraImage thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_CameraImage_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_CameraImage self, Handle_StepVisual_CameraImage theHandle) -> Handle_StepVisual_CameraImage
        assign(Handle_StepVisual_CameraImage self, StepVisual_CameraImage thePtr) -> Handle_StepVisual_CameraImage
        assign(Handle_StepVisual_CameraImage self, Handle_StepVisual_CameraImage theHandle) -> Handle_StepVisual_CameraImage

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_CameraImage_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_CameraImage self) -> StepVisual_CameraImage

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CameraImage_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_CameraImage self) -> StepVisual_CameraImage

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CameraImage___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_CameraImage self) -> StepVisual_CameraImage

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_CameraImage___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_CameraImage___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_CameraImage___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_CameraImage(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_CameraImage_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_CameraImage

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_CameraImage self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_CameraImage_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CameraImage_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CameraImage_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_CameraImage self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_RepresentationMap aMappingSource, Handle_StepRepr_RepresentationItem aMappingTarget)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aMappingSource: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationMap
        :type aMappingTarget: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_CameraImage_Init(self, *args)


    def SetMappingSource(self, *args):
        """
        SetMappingSource(Handle_StepVisual_CameraImage self, Handle_StepRepr_RepresentationMap aMappingSource)

        :type aMappingSource: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationMap

        """
        return _StepVisual.Handle_StepVisual_CameraImage_SetMappingSource(self, *args)


    def MappingSource(self, *args):
        """
        MappingSource(Handle_StepVisual_CameraImage self) -> Handle_StepRepr_RepresentationMap

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationMap

        """
        return _StepVisual.Handle_StepVisual_CameraImage_MappingSource(self, *args)


    def SetMappingTarget(self, *args):
        """
        SetMappingTarget(Handle_StepVisual_CameraImage self, Handle_StepRepr_RepresentationItem aMappingTarget)

        :type aMappingTarget: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_CameraImage_SetMappingTarget(self, *args)


    def MappingTarget(self, *args):
        """
        MappingTarget(Handle_StepVisual_CameraImage self) -> Handle_StepRepr_RepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_CameraImage_MappingTarget(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_CameraImage self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CameraImage_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_CameraImage self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CameraImage_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_CameraImage self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_CameraImage_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_CameraImage self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_CameraImage self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CameraImage_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_CameraImage self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_CameraImage self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CameraImage_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_CameraImage self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_CameraImage_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_CameraImage self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CameraImage_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_CameraImage self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_CameraImage_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_CameraImage self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CameraImage_DecrementRefCounter(self, *args)

Handle_StepVisual_CameraImage_swigregister = _StepVisual.Handle_StepVisual_CameraImage_swigregister
Handle_StepVisual_CameraImage_swigregister(Handle_StepVisual_CameraImage)

def Handle_StepVisual_CameraImage_DownCast(thing):
    return _StepVisual.Handle_StepVisual_CameraImage_DownCast(thing)
Handle_StepVisual_CameraImage_DownCast = _StepVisual.Handle_StepVisual_CameraImage_DownCast

class StepVisual_PresentedItem(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_PresentedItem
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_PresentedItem(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_PresentedItem_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_PresentedItem_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_PresentedItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self):
        this = _StepVisual.new_StepVisual_PresentedItem()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle



    __swig_destroy__ = _StepVisual.delete_StepVisual_PresentedItem
StepVisual_PresentedItem_swigregister = _StepVisual.StepVisual_PresentedItem_swigregister
StepVisual_PresentedItem_swigregister(StepVisual_PresentedItem)

def StepVisual_PresentedItem_get_type_name(*args):
    """
    StepVisual_PresentedItem_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_PresentedItem_get_type_name(*args)

def StepVisual_PresentedItem_get_type_descriptor(*args):
    """
    StepVisual_PresentedItem_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_PresentedItem_get_type_descriptor(*args)

class Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self, StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self, Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem theHandle) -> Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem
        assign(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self, StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem thePtr) -> Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem
        assign(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self, Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem theHandle) -> Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self) -> StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self) -> StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self) -> StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_HArray1OfPresentationStyleAssignment aStyles, Handle_Standard_Transient aItem)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment
        :type aItem: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_Init(self, *args)


    def SetStyles(self, *args):
        """
        SetStyles(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self, Handle_StepVisual_HArray1OfPresentationStyleAssignment aStyles)

        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_SetStyles(self, *args)


    def Styles(self, *args):
        """
        Styles(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self) -> Handle_StepVisual_HArray1OfPresentationStyleAssignment

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_Styles(self, *args)


    def StylesValue(self, *args):
        """
        StylesValue(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self, Standard_Integer const num) -> Handle_StepVisual_PresentationStyleAssignment

        :type num: int
        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_StylesValue(self, *args)


    def NbStyles(self, *args):
        """
        NbStyles(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_NbStyles(self, *args)


    def SetItem(self, *args):
        """
        SetItem(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self, Handle_StepRepr_RepresentationItem aItem)
        SetItem(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self, StepVisual_StyledItemTarget aItem)

        :type aItem: OCC.wrapper.StepVisual.StepVisual_StyledItemTarget

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_SetItem(self, *args)


    def Item(self, *args):
        """
        Item(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self) -> Handle_StepRepr_RepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_Item(self, *args)


    def ItemAP242(self, *args):
        """
        ItemAP242(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self) -> StepVisual_StyledItemTarget

        :rtype: OCC.wrapper.StepVisual.StepVisual_StyledItemTarget

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_ItemAP242(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_DecrementRefCounter(self, *args)

Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_swigregister = _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_swigregister
Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_swigregister(Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem)

def Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_DownCast(thing):
    return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_DownCast(thing)
Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_DownCast = _StepVisual.Handle_StepVisual_AnnotationCurveOccurrenceAndAnnotationOccurrenceAndGeomReprItemAndReprItemAndStyledItem_DownCast

class Handle_StepVisual_CompositeText(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_CompositeText self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_CompositeText_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_CompositeText self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_CompositeText_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_CompositeText self, StepVisual_CompositeText thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_CompositeText_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_CompositeText self, Handle_StepVisual_CompositeText theHandle) -> Handle_StepVisual_CompositeText
        assign(Handle_StepVisual_CompositeText self, StepVisual_CompositeText thePtr) -> Handle_StepVisual_CompositeText
        assign(Handle_StepVisual_CompositeText self, Handle_StepVisual_CompositeText theHandle) -> Handle_StepVisual_CompositeText

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_CompositeText_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_CompositeText self) -> StepVisual_CompositeText

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CompositeText_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_CompositeText self) -> StepVisual_CompositeText

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CompositeText___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_CompositeText self) -> StepVisual_CompositeText

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_CompositeText___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_CompositeText___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_CompositeText___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_CompositeText(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_CompositeText_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_CompositeText

    def Init(self, *args):
        """
        Init(Handle_StepVisual_CompositeText self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_HArray1OfTextOrCharacter aCollectedText)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aCollectedText: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter

        """
        return _StepVisual.Handle_StepVisual_CompositeText_Init(self, *args)


    def SetCollectedText(self, *args):
        """
        SetCollectedText(Handle_StepVisual_CompositeText self, Handle_StepVisual_HArray1OfTextOrCharacter aCollectedText)

        :type aCollectedText: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter

        """
        return _StepVisual.Handle_StepVisual_CompositeText_SetCollectedText(self, *args)


    def CollectedText(self, *args):
        """
        CollectedText(Handle_StepVisual_CompositeText self) -> Handle_StepVisual_HArray1OfTextOrCharacter

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter

        """
        return _StepVisual.Handle_StepVisual_CompositeText_CollectedText(self, *args)


    def CollectedTextValue(self, *args):
        """
        CollectedTextValue(Handle_StepVisual_CompositeText self, Standard_Integer const num) -> StepVisual_TextOrCharacter

        :type num: int
        :rtype: OCC.wrapper.StepVisual.StepVisual_TextOrCharacter

        """
        return _StepVisual.Handle_StepVisual_CompositeText_CollectedTextValue(self, *args)


    def NbCollectedText(self, *args):
        """
        NbCollectedText(Handle_StepVisual_CompositeText self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CompositeText_NbCollectedText(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_CompositeText self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_CompositeText_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CompositeText_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CompositeText_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_CompositeText self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CompositeText_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_CompositeText self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CompositeText_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_CompositeText self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_CompositeText_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_CompositeText self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_CompositeText self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CompositeText_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_CompositeText self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_CompositeText self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CompositeText_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_CompositeText self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_CompositeText_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_CompositeText self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CompositeText_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_CompositeText self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_CompositeText_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_CompositeText self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CompositeText_DecrementRefCounter(self, *args)

Handle_StepVisual_CompositeText_swigregister = _StepVisual.Handle_StepVisual_CompositeText_swigregister
Handle_StepVisual_CompositeText_swigregister(Handle_StepVisual_CompositeText)

def Handle_StepVisual_CompositeText_DownCast(thing):
    return _StepVisual.Handle_StepVisual_CompositeText_DownCast(thing)
Handle_StepVisual_CompositeText_DownCast = _StepVisual.Handle_StepVisual_CompositeText_DownCast

class Handle_StepVisual_HArray1OfSurfaceStyleElementSelect(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_HArray1OfSurfaceStyleElementSelect self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_HArray1OfSurfaceStyleElementSelect self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_HArray1OfSurfaceStyleElementSelect self, StepVisual_HArray1OfSurfaceStyleElementSelect thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_HArray1OfSurfaceStyleElementSelect self, Handle_StepVisual_HArray1OfSurfaceStyleElementSelect theHandle) -> Handle_StepVisual_HArray1OfSurfaceStyleElementSelect
        assign(Handle_StepVisual_HArray1OfSurfaceStyleElementSelect self, StepVisual_HArray1OfSurfaceStyleElementSelect thePtr) -> Handle_StepVisual_HArray1OfSurfaceStyleElementSelect
        assign(Handle_StepVisual_HArray1OfSurfaceStyleElementSelect self, Handle_StepVisual_HArray1OfSurfaceStyleElementSelect theHandle) -> Handle_StepVisual_HArray1OfSurfaceStyleElementSelect

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_HArray1OfSurfaceStyleElementSelect self) -> StepVisual_HArray1OfSurfaceStyleElementSelect

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_HArray1OfSurfaceStyleElementSelect self) -> StepVisual_HArray1OfSurfaceStyleElementSelect

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_HArray1OfSurfaceStyleElementSelect self) -> StepVisual_HArray1OfSurfaceStyleElementSelect

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_HArray1OfSurfaceStyleElementSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_HArray1OfSurfaceStyleElementSelect

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfSurfaceStyleElementSelect

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepVisual_HArray1OfSurfaceStyleElementSelect self) -> NCollection_Array1_StepVisual_SurfaceStyleElementSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfSurfaceStyleElementSelect

        """
        return _StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_HArray1OfSurfaceStyleElementSelect self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_HArray1OfSurfaceStyleElementSelect self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_HArray1OfSurfaceStyleElementSelect self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_HArray1OfSurfaceStyleElementSelect self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_HArray1OfSurfaceStyleElementSelect self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_HArray1OfSurfaceStyleElementSelect self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_HArray1OfSurfaceStyleElementSelect self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_HArray1OfSurfaceStyleElementSelect self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_HArray1OfSurfaceStyleElementSelect self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_HArray1OfSurfaceStyleElementSelect self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect_DecrementRefCounter(self, *args)

Handle_StepVisual_HArray1OfSurfaceStyleElementSelect_swigregister = _StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect_swigregister
Handle_StepVisual_HArray1OfSurfaceStyleElementSelect_swigregister(Handle_StepVisual_HArray1OfSurfaceStyleElementSelect)

def Handle_StepVisual_HArray1OfSurfaceStyleElementSelect_DownCast(thing):
    return _StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect_DownCast(thing)
Handle_StepVisual_HArray1OfSurfaceStyleElementSelect_DownCast = _StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect_DownCast

class StepVisual_FontSelect(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepVisual_FontSelect self) -> StepVisual_FontSelect

        Returns a FontSelect SelectType


        """
        this = _StepVisual.new_StepVisual_FontSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepVisual_FontSelect self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a FontSelect Kind Entity that is :
        1 -> PreDefinedTextFont
        2 -> ExternallyDefinedTextFont
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_FontSelect_CaseNum(self, *args)


    def PreDefinedTextFont(self, *args):
        """
        PreDefinedTextFont(StepVisual_FontSelect self) -> Handle_StepVisual_PreDefinedTextFont

        returns Value as a PreDefinedTextFont (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PreDefinedTextFont

        """
        return _StepVisual.StepVisual_FontSelect_PreDefinedTextFont(self, *args)


    def ExternallyDefinedTextFont(self, *args):
        """
        ExternallyDefinedTextFont(StepVisual_FontSelect self) -> Handle_StepVisual_ExternallyDefinedTextFont

        returns Value as a ExternallyDefinedTextFont (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_ExternallyDefinedTextFont

        """
        return _StepVisual.StepVisual_FontSelect_ExternallyDefinedTextFont(self, *args)

    __swig_destroy__ = _StepVisual.delete_StepVisual_FontSelect
StepVisual_FontSelect_swigregister = _StepVisual.StepVisual_FontSelect_swigregister
StepVisual_FontSelect_swigregister(StepVisual_FontSelect)

class StepVisual_DraughtingCallout(StepGeom.StepGeom_GeometricRepresentationItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_DraughtingCallout
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_DraughtingCallout(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_DraughtingCallout self) -> StepVisual_DraughtingCallout

        Returns a DraughtingCallout


        """
        this = _StepVisual.new_StepVisual_DraughtingCallout(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_DraughtingCallout self, Handle_TCollection_HAsciiString theName, Handle_StepVisual_HArray1OfDraughtingCalloutElement theContents)

        Init

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theContents: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement

        """
        return _StepVisual.StepVisual_DraughtingCallout_Init(self, *args)


    def Contents(self, *args):
        """
        Contents(StepVisual_DraughtingCallout self) -> Handle_StepVisual_HArray1OfDraughtingCalloutElement

        Returns field Contents

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement

        """
        return _StepVisual.StepVisual_DraughtingCallout_Contents(self, *args)


    def SetContents(self, *args):
        """
        SetContents(StepVisual_DraughtingCallout self, Handle_StepVisual_HArray1OfDraughtingCalloutElement theContents)

        Set field Contents

        :type theContents: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement

        """
        return _StepVisual.StepVisual_DraughtingCallout_SetContents(self, *args)


    def NbContents(self, *args):
        """
        NbContents(StepVisual_DraughtingCallout self) -> Standard_Integer

        Returns number of Contents

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_DraughtingCallout_NbContents(self, *args)


    def ContentsValue(self, *args):
        """
        ContentsValue(StepVisual_DraughtingCallout self, Standard_Integer const theNum) -> StepVisual_DraughtingCalloutElement

        Returns Contents with the given number

        :type theNum: int
        :rtype: OCC.wrapper.StepVisual.StepVisual_DraughtingCalloutElement

        """
        return _StepVisual.StepVisual_DraughtingCallout_ContentsValue(self, *args)


    def SetContentsValue(self, *args):
        """
        SetContentsValue(StepVisual_DraughtingCallout self, Standard_Integer const theNum, StepVisual_DraughtingCalloutElement theItem)

        Sets Contents with given number

        :type theNum: int
        :type theItem: OCC.wrapper.StepVisual.StepVisual_DraughtingCalloutElement

        """
        return _StepVisual.StepVisual_DraughtingCallout_SetContentsValue(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_DraughtingCallout_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_DraughtingCallout_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_DraughtingCallout_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_DraughtingCallout
StepVisual_DraughtingCallout_swigregister = _StepVisual.StepVisual_DraughtingCallout_swigregister
StepVisual_DraughtingCallout_swigregister(StepVisual_DraughtingCallout)

def StepVisual_DraughtingCallout_get_type_name(*args):
    """
    StepVisual_DraughtingCallout_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_DraughtingCallout_get_type_name(*args)

def StepVisual_DraughtingCallout_get_type_descriptor(*args):
    """
    StepVisual_DraughtingCallout_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_DraughtingCallout_get_type_descriptor(*args)

class Handle_StepVisual_HArray1OfPresentationStyleAssignment(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_HArray1OfPresentationStyleAssignment self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_HArray1OfPresentationStyleAssignment self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_HArray1OfPresentationStyleAssignment self, StepVisual_HArray1OfPresentationStyleAssignment thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_HArray1OfPresentationStyleAssignment self, Handle_StepVisual_HArray1OfPresentationStyleAssignment theHandle) -> Handle_StepVisual_HArray1OfPresentationStyleAssignment
        assign(Handle_StepVisual_HArray1OfPresentationStyleAssignment self, StepVisual_HArray1OfPresentationStyleAssignment thePtr) -> Handle_StepVisual_HArray1OfPresentationStyleAssignment
        assign(Handle_StepVisual_HArray1OfPresentationStyleAssignment self, Handle_StepVisual_HArray1OfPresentationStyleAssignment theHandle) -> Handle_StepVisual_HArray1OfPresentationStyleAssignment

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_HArray1OfPresentationStyleAssignment self) -> StepVisual_HArray1OfPresentationStyleAssignment

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_HArray1OfPresentationStyleAssignment self) -> StepVisual_HArray1OfPresentationStyleAssignment

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_HArray1OfPresentationStyleAssignment self) -> StepVisual_HArray1OfPresentationStyleAssignment

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_HArray1OfPresentationStyleAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_HArray1OfPresentationStyleAssignment

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfPresentationStyleAssignment

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepVisual_HArray1OfPresentationStyleAssignment self) -> NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfPresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_HArray1OfPresentationStyleAssignment self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_HArray1OfPresentationStyleAssignment self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_HArray1OfPresentationStyleAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_HArray1OfPresentationStyleAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_HArray1OfPresentationStyleAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_HArray1OfPresentationStyleAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_HArray1OfPresentationStyleAssignment self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_HArray1OfPresentationStyleAssignment self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_HArray1OfPresentationStyleAssignment self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_HArray1OfPresentationStyleAssignment self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment_DecrementRefCounter(self, *args)

Handle_StepVisual_HArray1OfPresentationStyleAssignment_swigregister = _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment_swigregister
Handle_StepVisual_HArray1OfPresentationStyleAssignment_swigregister(Handle_StepVisual_HArray1OfPresentationStyleAssignment)

def Handle_StepVisual_HArray1OfPresentationStyleAssignment_DownCast(thing):
    return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment_DownCast(thing)
Handle_StepVisual_HArray1OfPresentationStyleAssignment_DownCast = _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment_DownCast

class NCollection_Array1_StepVisual_TextOrCharacter(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_StepVisual_TextOrCharacter self) -> NCollection_Array1< StepVisual_TextOrCharacter >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_TextOrCharacter_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_StepVisual_TextOrCharacter self) -> NCollection_Array1< StepVisual_TextOrCharacter >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_TextOrCharacter_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_StepVisual_TextOrCharacter self) -> NCollection_Array1< StepVisual_TextOrCharacter >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_TextOrCharacter_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_StepVisual_TextOrCharacter self) -> NCollection_Array1< StepVisual_TextOrCharacter >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_TextOrCharacter_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepVisual.new_NCollection_Array1_StepVisual_TextOrCharacter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_StepVisual_TextOrCharacter self, StepVisual_TextOrCharacter theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_TextOrCharacter_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_StepVisual_TextOrCharacter self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_TextOrCharacter_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_StepVisual_TextOrCharacter self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_TextOrCharacter_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_StepVisual_TextOrCharacter self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_TextOrCharacter_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_StepVisual_TextOrCharacter self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_TextOrCharacter_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_StepVisual_TextOrCharacter self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_TextOrCharacter_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_StepVisual_TextOrCharacter self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_TextOrCharacter_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_StepVisual_TextOrCharacter self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_TextOrCharacter_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_StepVisual_TextOrCharacter self, NCollection_Array1_StepVisual_TextOrCharacter theOther) -> NCollection_Array1_StepVisual_TextOrCharacter

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_TextOrCharacter_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_StepVisual_TextOrCharacter self, NCollection_Array1_StepVisual_TextOrCharacter theOther) -> NCollection_Array1_StepVisual_TextOrCharacter

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_TextOrCharacter_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_StepVisual_TextOrCharacter self, NCollection_Array1_StepVisual_TextOrCharacter theOther) -> NCollection_Array1_StepVisual_TextOrCharacter
        assign(NCollection_Array1_StepVisual_TextOrCharacter self, NCollection_Array1_StepVisual_TextOrCharacter theOther) -> NCollection_Array1_StepVisual_TextOrCharacter

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_TextOrCharacter_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_TextOrCharacter_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_StepVisual_TextOrCharacter self) -> StepVisual_TextOrCharacter

        @return first element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_TextOrCharacter_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_TextOrCharacter_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_StepVisual_TextOrCharacter self) -> StepVisual_TextOrCharacter

        @return last element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_TextOrCharacter_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_TextOrCharacter_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_StepVisual_TextOrCharacter self, Standard_Integer const theIndex) -> StepVisual_TextOrCharacter

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_TextOrCharacter_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_TextOrCharacter___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_TextOrCharacter_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_StepVisual_TextOrCharacter self, Standard_Integer const theIndex, StepVisual_TextOrCharacter theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_TextOrCharacter_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_StepVisual_TextOrCharacter self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepVisual.NCollection_Array1_StepVisual_TextOrCharacter_Resize(self, *args)

    __swig_destroy__ = _StepVisual.delete_NCollection_Array1_StepVisual_TextOrCharacter
NCollection_Array1_StepVisual_TextOrCharacter_swigregister = _StepVisual.NCollection_Array1_StepVisual_TextOrCharacter_swigregister
NCollection_Array1_StepVisual_TextOrCharacter_swigregister(NCollection_Array1_StepVisual_TextOrCharacter)


try:
	StepVisual_Array1OfTextOrCharacter = NCollection_Array1_StepVisual_TextOrCharacter
except NameError:
	pass # does not exist, probably ignored

class Handle_StepVisual_TessellatedItem(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_TessellatedItem self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_TessellatedItem_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_TessellatedItem self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_TessellatedItem_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_TessellatedItem self, StepVisual_TessellatedItem thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_TessellatedItem_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_TessellatedItem self, Handle_StepVisual_TessellatedItem theHandle) -> Handle_StepVisual_TessellatedItem
        assign(Handle_StepVisual_TessellatedItem self, StepVisual_TessellatedItem thePtr) -> Handle_StepVisual_TessellatedItem
        assign(Handle_StepVisual_TessellatedItem self, Handle_StepVisual_TessellatedItem theHandle) -> Handle_StepVisual_TessellatedItem

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_TessellatedItem_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_TessellatedItem self) -> StepVisual_TessellatedItem

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_TessellatedItem_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_TessellatedItem self) -> StepVisual_TessellatedItem

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_TessellatedItem___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_TessellatedItem self) -> StepVisual_TessellatedItem

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_TessellatedItem___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_TessellatedItem___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_TessellatedItem___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_TessellatedItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_TessellatedItem_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_TessellatedItem

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_TessellatedItem self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_TessellatedItem_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_TessellatedItem_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_TessellatedItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_TessellatedItem self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_TessellatedItem_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_TessellatedItem self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_TessellatedItem_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_TessellatedItem self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_TessellatedItem_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_TessellatedItem self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_TessellatedItem_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_TessellatedItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_TessellatedItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_TessellatedItem_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_TessellatedItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_TessellatedItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_TessellatedItem_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_TessellatedItem self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_TessellatedItem_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_TessellatedItem self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_TessellatedItem_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_TessellatedItem self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_TessellatedItem_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_TessellatedItem self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_TessellatedItem_DecrementRefCounter(self, *args)

Handle_StepVisual_TessellatedItem_swigregister = _StepVisual.Handle_StepVisual_TessellatedItem_swigregister
Handle_StepVisual_TessellatedItem_swigregister(Handle_StepVisual_TessellatedItem)

def Handle_StepVisual_TessellatedItem_DownCast(thing):
    return _StepVisual.Handle_StepVisual_TessellatedItem_DownCast(thing)
Handle_StepVisual_TessellatedItem_DownCast = _StepVisual.Handle_StepVisual_TessellatedItem_DownCast

class Handle_StepVisual_TextStyleForDefinedFont(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_TextStyleForDefinedFont self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_TextStyleForDefinedFont_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_TextStyleForDefinedFont self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_TextStyleForDefinedFont_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_TextStyleForDefinedFont self, StepVisual_TextStyleForDefinedFont thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_TextStyleForDefinedFont_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_TextStyleForDefinedFont self, Handle_StepVisual_TextStyleForDefinedFont theHandle) -> Handle_StepVisual_TextStyleForDefinedFont
        assign(Handle_StepVisual_TextStyleForDefinedFont self, StepVisual_TextStyleForDefinedFont thePtr) -> Handle_StepVisual_TextStyleForDefinedFont
        assign(Handle_StepVisual_TextStyleForDefinedFont self, Handle_StepVisual_TextStyleForDefinedFont theHandle) -> Handle_StepVisual_TextStyleForDefinedFont

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_TextStyleForDefinedFont_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_TextStyleForDefinedFont self) -> StepVisual_TextStyleForDefinedFont

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_TextStyleForDefinedFont_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_TextStyleForDefinedFont self) -> StepVisual_TextStyleForDefinedFont

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_TextStyleForDefinedFont___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_TextStyleForDefinedFont self) -> StepVisual_TextStyleForDefinedFont

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_TextStyleForDefinedFont___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_TextStyleForDefinedFont___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_TextStyleForDefinedFont___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_TextStyleForDefinedFont(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_TextStyleForDefinedFont_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_TextStyleForDefinedFont

    def Init(self, *args):
        """
        Init(Handle_StepVisual_TextStyleForDefinedFont self, Handle_StepVisual_Colour aTextColour)

        :type aTextColour: OCC.wrapper.StepVisual.Handle_StepVisual_Colour

        """
        return _StepVisual.Handle_StepVisual_TextStyleForDefinedFont_Init(self, *args)


    def SetTextColour(self, *args):
        """
        SetTextColour(Handle_StepVisual_TextStyleForDefinedFont self, Handle_StepVisual_Colour aTextColour)

        :type aTextColour: OCC.wrapper.StepVisual.Handle_StepVisual_Colour

        """
        return _StepVisual.Handle_StepVisual_TextStyleForDefinedFont_SetTextColour(self, *args)


    def TextColour(self, *args):
        """
        TextColour(Handle_StepVisual_TextStyleForDefinedFont self) -> Handle_StepVisual_Colour

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_Colour

        """
        return _StepVisual.Handle_StepVisual_TextStyleForDefinedFont_TextColour(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_TextStyleForDefinedFont self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_TextStyleForDefinedFont_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_TextStyleForDefinedFont_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_TextStyleForDefinedFont_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_TextStyleForDefinedFont self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_TextStyleForDefinedFont_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_TextStyleForDefinedFont self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_TextStyleForDefinedFont self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_TextStyleForDefinedFont_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_TextStyleForDefinedFont self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_TextStyleForDefinedFont self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_TextStyleForDefinedFont_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_TextStyleForDefinedFont self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_TextStyleForDefinedFont_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_TextStyleForDefinedFont self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_TextStyleForDefinedFont_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_TextStyleForDefinedFont self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_TextStyleForDefinedFont_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_TextStyleForDefinedFont self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_TextStyleForDefinedFont_DecrementRefCounter(self, *args)

Handle_StepVisual_TextStyleForDefinedFont_swigregister = _StepVisual.Handle_StepVisual_TextStyleForDefinedFont_swigregister
Handle_StepVisual_TextStyleForDefinedFont_swigregister(Handle_StepVisual_TextStyleForDefinedFont)

def Handle_StepVisual_TextStyleForDefinedFont_DownCast(thing):
    return _StepVisual.Handle_StepVisual_TextStyleForDefinedFont_DownCast(thing)
Handle_StepVisual_TextStyleForDefinedFont_DownCast = _StepVisual.Handle_StepVisual_TextStyleForDefinedFont_DownCast

class StepVisual_TessellatedCurveSet(StepVisual_TessellatedItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_TessellatedCurveSet
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_TessellatedCurveSet(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_TessellatedCurveSet self) -> StepVisual_TessellatedCurveSet

        Returns a DraughtingCalloutElement select type


        """
        this = _StepVisual.new_StepVisual_TessellatedCurveSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_TessellatedCurveSet self, Handle_TCollection_HAsciiString theName, Handle_StepVisual_CoordinatesList theCoordList, NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger theCurves)

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theCoordList: OCC.wrapper.StepVisual.Handle_StepVisual_CoordinatesList
        :type theCurves: OCC.wrapper.StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger

        """
        return _StepVisual.StepVisual_TessellatedCurveSet_Init(self, *args)


    def CoordList(self, *args):
        """
        CoordList(StepVisual_TessellatedCurveSet self) -> Handle_StepVisual_CoordinatesList

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_CoordinatesList

        """
        return _StepVisual.StepVisual_TessellatedCurveSet_CoordList(self, *args)


    def Curves(self, *args):
        """
        Curves(StepVisual_TessellatedCurveSet self) -> NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger

        :rtype: OCC.wrapper.StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger

        """
        return _StepVisual.StepVisual_TessellatedCurveSet_Curves(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_TessellatedCurveSet_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_TessellatedCurveSet_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_TessellatedCurveSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_TessellatedCurveSet
StepVisual_TessellatedCurveSet_swigregister = _StepVisual.StepVisual_TessellatedCurveSet_swigregister
StepVisual_TessellatedCurveSet_swigregister(StepVisual_TessellatedCurveSet)

def StepVisual_TessellatedCurveSet_get_type_name(*args):
    """
    StepVisual_TessellatedCurveSet_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_TessellatedCurveSet_get_type_name(*args)

def StepVisual_TessellatedCurveSet_get_type_descriptor(*args):
    """
    StepVisual_TessellatedCurveSet_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_TessellatedCurveSet_get_type_descriptor(*args)

class Handle_StepVisual_SurfaceStyleControlGrid(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_SurfaceStyleControlGrid self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleControlGrid_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_SurfaceStyleControlGrid self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleControlGrid_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_SurfaceStyleControlGrid self, StepVisual_SurfaceStyleControlGrid thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleControlGrid_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_SurfaceStyleControlGrid self, Handle_StepVisual_SurfaceStyleControlGrid theHandle) -> Handle_StepVisual_SurfaceStyleControlGrid
        assign(Handle_StepVisual_SurfaceStyleControlGrid self, StepVisual_SurfaceStyleControlGrid thePtr) -> Handle_StepVisual_SurfaceStyleControlGrid
        assign(Handle_StepVisual_SurfaceStyleControlGrid self, Handle_StepVisual_SurfaceStyleControlGrid theHandle) -> Handle_StepVisual_SurfaceStyleControlGrid

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleControlGrid_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_SurfaceStyleControlGrid self) -> StepVisual_SurfaceStyleControlGrid

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleControlGrid_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_SurfaceStyleControlGrid self) -> StepVisual_SurfaceStyleControlGrid

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleControlGrid___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_SurfaceStyleControlGrid self) -> StepVisual_SurfaceStyleControlGrid

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleControlGrid___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_SurfaceStyleControlGrid___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_SurfaceStyleControlGrid___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_SurfaceStyleControlGrid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_SurfaceStyleControlGrid_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_SurfaceStyleControlGrid

    def Init(self, *args):
        """
        Init(Handle_StepVisual_SurfaceStyleControlGrid self, Handle_StepVisual_CurveStyle aStyleOfControlGrid)

        :type aStyleOfControlGrid: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleControlGrid_Init(self, *args)


    def SetStyleOfControlGrid(self, *args):
        """
        SetStyleOfControlGrid(Handle_StepVisual_SurfaceStyleControlGrid self, Handle_StepVisual_CurveStyle aStyleOfControlGrid)

        :type aStyleOfControlGrid: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleControlGrid_SetStyleOfControlGrid(self, *args)


    def StyleOfControlGrid(self, *args):
        """
        StyleOfControlGrid(Handle_StepVisual_SurfaceStyleControlGrid self) -> Handle_StepVisual_CurveStyle

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleControlGrid_StyleOfControlGrid(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_SurfaceStyleControlGrid self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleControlGrid_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_SurfaceStyleControlGrid_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_SurfaceStyleControlGrid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_SurfaceStyleControlGrid self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleControlGrid_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_SurfaceStyleControlGrid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_SurfaceStyleControlGrid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleControlGrid_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_SurfaceStyleControlGrid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_SurfaceStyleControlGrid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleControlGrid_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_SurfaceStyleControlGrid self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleControlGrid_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_SurfaceStyleControlGrid self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleControlGrid_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_SurfaceStyleControlGrid self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleControlGrid_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_SurfaceStyleControlGrid self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleControlGrid_DecrementRefCounter(self, *args)

Handle_StepVisual_SurfaceStyleControlGrid_swigregister = _StepVisual.Handle_StepVisual_SurfaceStyleControlGrid_swigregister
Handle_StepVisual_SurfaceStyleControlGrid_swigregister(Handle_StepVisual_SurfaceStyleControlGrid)

def Handle_StepVisual_SurfaceStyleControlGrid_DownCast(thing):
    return _StepVisual.Handle_StepVisual_SurfaceStyleControlGrid_DownCast(thing)
Handle_StepVisual_SurfaceStyleControlGrid_DownCast = _StepVisual.Handle_StepVisual_SurfaceStyleControlGrid_DownCast

class Handle_StepVisual_CompositeTextWithExtent(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_CompositeTextWithExtent self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_CompositeTextWithExtent_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_CompositeTextWithExtent self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_CompositeTextWithExtent_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_CompositeTextWithExtent self, StepVisual_CompositeTextWithExtent thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_CompositeTextWithExtent_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_CompositeTextWithExtent self, Handle_StepVisual_CompositeTextWithExtent theHandle) -> Handle_StepVisual_CompositeTextWithExtent
        assign(Handle_StepVisual_CompositeTextWithExtent self, StepVisual_CompositeTextWithExtent thePtr) -> Handle_StepVisual_CompositeTextWithExtent
        assign(Handle_StepVisual_CompositeTextWithExtent self, Handle_StepVisual_CompositeTextWithExtent theHandle) -> Handle_StepVisual_CompositeTextWithExtent

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_CompositeTextWithExtent_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_CompositeTextWithExtent self) -> StepVisual_CompositeTextWithExtent

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CompositeTextWithExtent_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_CompositeTextWithExtent self) -> StepVisual_CompositeTextWithExtent

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CompositeTextWithExtent___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_CompositeTextWithExtent self) -> StepVisual_CompositeTextWithExtent

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_CompositeTextWithExtent___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_CompositeTextWithExtent___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_CompositeTextWithExtent___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_CompositeTextWithExtent(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_CompositeTextWithExtent_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_CompositeTextWithExtent

    def Init(self, *args):
        """
        Init(Handle_StepVisual_CompositeTextWithExtent self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_HArray1OfTextOrCharacter aCollectedText, Handle_StepVisual_PlanarExtent aExtent)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aCollectedText: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter
        :type aExtent: OCC.wrapper.StepVisual.Handle_StepVisual_PlanarExtent

        """
        return _StepVisual.Handle_StepVisual_CompositeTextWithExtent_Init(self, *args)


    def SetExtent(self, *args):
        """
        SetExtent(Handle_StepVisual_CompositeTextWithExtent self, Handle_StepVisual_PlanarExtent aExtent)

        :type aExtent: OCC.wrapper.StepVisual.Handle_StepVisual_PlanarExtent

        """
        return _StepVisual.Handle_StepVisual_CompositeTextWithExtent_SetExtent(self, *args)


    def Extent(self, *args):
        """
        Extent(Handle_StepVisual_CompositeTextWithExtent self) -> Handle_StepVisual_PlanarExtent

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PlanarExtent

        """
        return _StepVisual.Handle_StepVisual_CompositeTextWithExtent_Extent(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_CompositeTextWithExtent self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_CompositeTextWithExtent_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CompositeTextWithExtent_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CompositeTextWithExtent_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetCollectedText(self, *args):
        """
        SetCollectedText(Handle_StepVisual_CompositeTextWithExtent self, Handle_StepVisual_HArray1OfTextOrCharacter aCollectedText)

        :type aCollectedText: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter

        """
        return _StepVisual.Handle_StepVisual_CompositeTextWithExtent_SetCollectedText(self, *args)


    def CollectedText(self, *args):
        """
        CollectedText(Handle_StepVisual_CompositeTextWithExtent self) -> Handle_StepVisual_HArray1OfTextOrCharacter

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter

        """
        return _StepVisual.Handle_StepVisual_CompositeTextWithExtent_CollectedText(self, *args)


    def CollectedTextValue(self, *args):
        """
        CollectedTextValue(Handle_StepVisual_CompositeTextWithExtent self, Standard_Integer const num) -> StepVisual_TextOrCharacter

        :type num: int
        :rtype: OCC.wrapper.StepVisual.StepVisual_TextOrCharacter

        """
        return _StepVisual.Handle_StepVisual_CompositeTextWithExtent_CollectedTextValue(self, *args)


    def NbCollectedText(self, *args):
        """
        NbCollectedText(Handle_StepVisual_CompositeTextWithExtent self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CompositeTextWithExtent_NbCollectedText(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_CompositeTextWithExtent self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CompositeTextWithExtent_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_CompositeTextWithExtent self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CompositeTextWithExtent_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_CompositeTextWithExtent self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_CompositeTextWithExtent_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_CompositeTextWithExtent self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_CompositeTextWithExtent self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CompositeTextWithExtent_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_CompositeTextWithExtent self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_CompositeTextWithExtent self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CompositeTextWithExtent_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_CompositeTextWithExtent self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_CompositeTextWithExtent_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_CompositeTextWithExtent self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CompositeTextWithExtent_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_CompositeTextWithExtent self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_CompositeTextWithExtent_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_CompositeTextWithExtent self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CompositeTextWithExtent_DecrementRefCounter(self, *args)

Handle_StepVisual_CompositeTextWithExtent_swigregister = _StepVisual.Handle_StepVisual_CompositeTextWithExtent_swigregister
Handle_StepVisual_CompositeTextWithExtent_swigregister(Handle_StepVisual_CompositeTextWithExtent)

def Handle_StepVisual_CompositeTextWithExtent_DownCast(thing):
    return _StepVisual.Handle_StepVisual_CompositeTextWithExtent_DownCast(thing)
Handle_StepVisual_CompositeTextWithExtent_DownCast = _StepVisual.Handle_StepVisual_CompositeTextWithExtent_DownCast

class Handle_StepVisual_CameraUsage(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_CameraUsage self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_CameraUsage_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_CameraUsage self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_CameraUsage_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_CameraUsage self, StepVisual_CameraUsage thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_CameraUsage_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_CameraUsage self, Handle_StepVisual_CameraUsage theHandle) -> Handle_StepVisual_CameraUsage
        assign(Handle_StepVisual_CameraUsage self, StepVisual_CameraUsage thePtr) -> Handle_StepVisual_CameraUsage
        assign(Handle_StepVisual_CameraUsage self, Handle_StepVisual_CameraUsage theHandle) -> Handle_StepVisual_CameraUsage

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_CameraUsage_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_CameraUsage self) -> StepVisual_CameraUsage

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CameraUsage_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_CameraUsage self) -> StepVisual_CameraUsage

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CameraUsage___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_CameraUsage self) -> StepVisual_CameraUsage

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_CameraUsage___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_CameraUsage___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_CameraUsage___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_CameraUsage(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_CameraUsage_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_CameraUsage

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_CameraUsage self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_CameraUsage_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CameraUsage_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CameraUsage_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_CameraUsage self, Handle_StepRepr_RepresentationItem aMappingOrigin, Handle_StepRepr_Representation aMappedRepresentation)

        :type aMappingOrigin: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem
        :type aMappedRepresentation: OCC.wrapper.StepRepr.Handle_StepRepr_Representation

        """
        return _StepVisual.Handle_StepVisual_CameraUsage_Init(self, *args)


    def SetMappingOrigin(self, *args):
        """
        SetMappingOrigin(Handle_StepVisual_CameraUsage self, Handle_StepRepr_RepresentationItem aMappingOrigin)

        :type aMappingOrigin: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_CameraUsage_SetMappingOrigin(self, *args)


    def MappingOrigin(self, *args):
        """
        MappingOrigin(Handle_StepVisual_CameraUsage self) -> Handle_StepRepr_RepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_CameraUsage_MappingOrigin(self, *args)


    def SetMappedRepresentation(self, *args):
        """
        SetMappedRepresentation(Handle_StepVisual_CameraUsage self, Handle_StepRepr_Representation aMappedRepresentation)

        :type aMappedRepresentation: OCC.wrapper.StepRepr.Handle_StepRepr_Representation

        """
        return _StepVisual.Handle_StepVisual_CameraUsage_SetMappedRepresentation(self, *args)


    def MappedRepresentation(self, *args):
        """
        MappedRepresentation(Handle_StepVisual_CameraUsage self) -> Handle_StepRepr_Representation

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_Representation

        """
        return _StepVisual.Handle_StepVisual_CameraUsage_MappedRepresentation(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_CameraUsage self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_CameraUsage_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_CameraUsage self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_CameraUsage self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CameraUsage_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_CameraUsage self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_CameraUsage self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CameraUsage_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_CameraUsage self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_CameraUsage_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_CameraUsage self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CameraUsage_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_CameraUsage self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_CameraUsage_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_CameraUsage self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CameraUsage_DecrementRefCounter(self, *args)

Handle_StepVisual_CameraUsage_swigregister = _StepVisual.Handle_StepVisual_CameraUsage_swigregister
Handle_StepVisual_CameraUsage_swigregister(Handle_StepVisual_CameraUsage)

def Handle_StepVisual_CameraUsage_DownCast(thing):
    return _StepVisual.Handle_StepVisual_CameraUsage_DownCast(thing)
Handle_StepVisual_CameraUsage_DownCast = _StepVisual.Handle_StepVisual_CameraUsage_DownCast

class StepVisual_HArray1OfTextOrCharacter(NCollection_Array1_StepVisual_TextOrCharacter, Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_HArray1OfTextOrCharacter
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_HArray1OfTextOrCharacter(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_HArray1OfTextOrCharacter self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepVisual_HArray1OfTextOrCharacter
        __init__(StepVisual_HArray1OfTextOrCharacter self, Standard_Integer const theLower, Standard_Integer const theUpper, StepVisual_TextOrCharacter theValue) -> StepVisual_HArray1OfTextOrCharacter
        __init__(StepVisual_HArray1OfTextOrCharacter self, NCollection_Array1_StepVisual_TextOrCharacter theOther) -> StepVisual_HArray1OfTextOrCharacter

        :type theOther: OCC.wrapper.StepVisual.StepVisual_Array1OfTextOrCharacter

        """
        this = _StepVisual.new_StepVisual_HArray1OfTextOrCharacter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfTextOrCharacter

        """
        res = _StepVisual.StepVisual_HArray1OfTextOrCharacter_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepVisual_HArray1OfTextOrCharacter self) -> NCollection_Array1_StepVisual_TextOrCharacter

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfTextOrCharacter

        """
        return _StepVisual.StepVisual_HArray1OfTextOrCharacter_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_HArray1OfTextOrCharacter_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_HArray1OfTextOrCharacter_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_HArray1OfTextOrCharacter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_HArray1OfTextOrCharacter
StepVisual_HArray1OfTextOrCharacter_swigregister = _StepVisual.StepVisual_HArray1OfTextOrCharacter_swigregister
StepVisual_HArray1OfTextOrCharacter_swigregister(StepVisual_HArray1OfTextOrCharacter)

def StepVisual_HArray1OfTextOrCharacter_get_type_name(*args):
    """
    StepVisual_HArray1OfTextOrCharacter_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_HArray1OfTextOrCharacter_get_type_name(*args)

def StepVisual_HArray1OfTextOrCharacter_get_type_descriptor(*args):
    """
    StepVisual_HArray1OfTextOrCharacter_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_HArray1OfTextOrCharacter_get_type_descriptor(*args)

class StepVisual_PresentationSizeAssignmentSelect(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepVisual_PresentationSizeAssignmentSelect self) -> StepVisual_PresentationSizeAssignmentSelect

        Returns a PresentationSizeAssignmentSelect SelectType


        """
        this = _StepVisual.new_StepVisual_PresentationSizeAssignmentSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepVisual_PresentationSizeAssignmentSelect self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a PresentationSizeAssignmentSelect Kind Entity that is :
        1 -> PresentationView
        2 -> PresentationArea
        3 -> AreaInSet
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_PresentationSizeAssignmentSelect_CaseNum(self, *args)


    def PresentationView(self, *args):
        """
        PresentationView(StepVisual_PresentationSizeAssignmentSelect self) -> Handle_StepVisual_PresentationView

        returns Value as a PresentationView (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationView

        """
        return _StepVisual.StepVisual_PresentationSizeAssignmentSelect_PresentationView(self, *args)


    def PresentationArea(self, *args):
        """
        PresentationArea(StepVisual_PresentationSizeAssignmentSelect self) -> Handle_StepVisual_PresentationArea

        returns Value as a PresentationArea (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationArea

        """
        return _StepVisual.StepVisual_PresentationSizeAssignmentSelect_PresentationArea(self, *args)


    def AreaInSet(self, *args):
        """
        AreaInSet(StepVisual_PresentationSizeAssignmentSelect self) -> Handle_StepVisual_AreaInSet

        returns Value as a AreaInSet (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_AreaInSet

        """
        return _StepVisual.StepVisual_PresentationSizeAssignmentSelect_AreaInSet(self, *args)

    __swig_destroy__ = _StepVisual.delete_StepVisual_PresentationSizeAssignmentSelect
StepVisual_PresentationSizeAssignmentSelect_swigregister = _StepVisual.StepVisual_PresentationSizeAssignmentSelect_swigregister
StepVisual_PresentationSizeAssignmentSelect_swigregister(StepVisual_PresentationSizeAssignmentSelect)

class NCollection_Array1_StepVisual_DraughtingCalloutElement(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_StepVisual_DraughtingCalloutElement self) -> NCollection_Array1< StepVisual_DraughtingCalloutElement >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_DraughtingCalloutElement_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_StepVisual_DraughtingCalloutElement self) -> NCollection_Array1< StepVisual_DraughtingCalloutElement >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_DraughtingCalloutElement_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_StepVisual_DraughtingCalloutElement self) -> NCollection_Array1< StepVisual_DraughtingCalloutElement >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_DraughtingCalloutElement_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_StepVisual_DraughtingCalloutElement self) -> NCollection_Array1< StepVisual_DraughtingCalloutElement >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_DraughtingCalloutElement_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepVisual.new_NCollection_Array1_StepVisual_DraughtingCalloutElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_StepVisual_DraughtingCalloutElement self, StepVisual_DraughtingCalloutElement theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_DraughtingCalloutElement_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_StepVisual_DraughtingCalloutElement self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_DraughtingCalloutElement_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_StepVisual_DraughtingCalloutElement self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_DraughtingCalloutElement_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_StepVisual_DraughtingCalloutElement self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_DraughtingCalloutElement_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_StepVisual_DraughtingCalloutElement self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_DraughtingCalloutElement_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_StepVisual_DraughtingCalloutElement self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_DraughtingCalloutElement_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_StepVisual_DraughtingCalloutElement self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_DraughtingCalloutElement_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_StepVisual_DraughtingCalloutElement self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_DraughtingCalloutElement_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_StepVisual_DraughtingCalloutElement self, NCollection_Array1_StepVisual_DraughtingCalloutElement theOther) -> NCollection_Array1_StepVisual_DraughtingCalloutElement

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_DraughtingCalloutElement_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_StepVisual_DraughtingCalloutElement self, NCollection_Array1_StepVisual_DraughtingCalloutElement theOther) -> NCollection_Array1_StepVisual_DraughtingCalloutElement

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_DraughtingCalloutElement_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_StepVisual_DraughtingCalloutElement self, NCollection_Array1_StepVisual_DraughtingCalloutElement theOther) -> NCollection_Array1_StepVisual_DraughtingCalloutElement
        assign(NCollection_Array1_StepVisual_DraughtingCalloutElement self, NCollection_Array1_StepVisual_DraughtingCalloutElement theOther) -> NCollection_Array1_StepVisual_DraughtingCalloutElement

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_DraughtingCalloutElement_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_DraughtingCalloutElement_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_StepVisual_DraughtingCalloutElement self) -> StepVisual_DraughtingCalloutElement

        @return first element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_DraughtingCalloutElement_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_DraughtingCalloutElement_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_StepVisual_DraughtingCalloutElement self) -> StepVisual_DraughtingCalloutElement

        @return last element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_DraughtingCalloutElement_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_DraughtingCalloutElement_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_StepVisual_DraughtingCalloutElement self, Standard_Integer const theIndex) -> StepVisual_DraughtingCalloutElement

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_DraughtingCalloutElement_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_DraughtingCalloutElement___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_DraughtingCalloutElement_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_StepVisual_DraughtingCalloutElement self, Standard_Integer const theIndex, StepVisual_DraughtingCalloutElement theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_DraughtingCalloutElement_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_StepVisual_DraughtingCalloutElement self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepVisual.NCollection_Array1_StepVisual_DraughtingCalloutElement_Resize(self, *args)

    __swig_destroy__ = _StepVisual.delete_NCollection_Array1_StepVisual_DraughtingCalloutElement
NCollection_Array1_StepVisual_DraughtingCalloutElement_swigregister = _StepVisual.NCollection_Array1_StepVisual_DraughtingCalloutElement_swigregister
NCollection_Array1_StepVisual_DraughtingCalloutElement_swigregister(NCollection_Array1_StepVisual_DraughtingCalloutElement)


try:
	StepVisual_Array1OfDraughtingCalloutElement = NCollection_Array1_StepVisual_DraughtingCalloutElement
except NameError:
	pass # does not exist, probably ignored

class StepVisual_ColourRgb(StepVisual_ColourSpecification):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_ColourRgb
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_ColourRgb(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_ColourRgb self) -> StepVisual_ColourRgb

        Returns a ColourRgb


        """
        this = _StepVisual.new_StepVisual_ColourRgb(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_ColourRgb self, Handle_TCollection_HAsciiString aName, Standard_Real const aRed, Standard_Real const aGreen, Standard_Real const aBlue)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRed: float
        :type aGreen: float
        :type aBlue: float

        """
        return _StepVisual.StepVisual_ColourRgb_Init(self, *args)


    def SetRed(self, *args):
        """
        SetRed(StepVisual_ColourRgb self, Standard_Real const aRed)

        :type aRed: float

        """
        return _StepVisual.StepVisual_ColourRgb_SetRed(self, *args)


    def Red(self, *args):
        """
        Red(StepVisual_ColourRgb self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepVisual.StepVisual_ColourRgb_Red(self, *args)


    def SetGreen(self, *args):
        """
        SetGreen(StepVisual_ColourRgb self, Standard_Real const aGreen)

        :type aGreen: float

        """
        return _StepVisual.StepVisual_ColourRgb_SetGreen(self, *args)


    def Green(self, *args):
        """
        Green(StepVisual_ColourRgb self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepVisual.StepVisual_ColourRgb_Green(self, *args)


    def SetBlue(self, *args):
        """
        SetBlue(StepVisual_ColourRgb self, Standard_Real const aBlue)

        :type aBlue: float

        """
        return _StepVisual.StepVisual_ColourRgb_SetBlue(self, *args)


    def Blue(self, *args):
        """
        Blue(StepVisual_ColourRgb self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepVisual.StepVisual_ColourRgb_Blue(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_ColourRgb_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_ColourRgb_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_ColourRgb_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_ColourRgb
StepVisual_ColourRgb_swigregister = _StepVisual.StepVisual_ColourRgb_swigregister
StepVisual_ColourRgb_swigregister(StepVisual_ColourRgb)

def StepVisual_ColourRgb_get_type_name(*args):
    """
    StepVisual_ColourRgb_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_ColourRgb_get_type_name(*args)

def StepVisual_ColourRgb_get_type_descriptor(*args):
    """
    StepVisual_ColourRgb_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_ColourRgb_get_type_descriptor(*args)

class Handle_StepVisual_MarkerMember(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_MarkerMember self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_MarkerMember_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_MarkerMember self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_MarkerMember self, StepVisual_MarkerMember thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_MarkerMember self, Handle_StepVisual_MarkerMember theHandle) -> Handle_StepVisual_MarkerMember
        assign(Handle_StepVisual_MarkerMember self, StepVisual_MarkerMember thePtr) -> Handle_StepVisual_MarkerMember
        assign(Handle_StepVisual_MarkerMember self, Handle_StepVisual_MarkerMember theHandle) -> Handle_StepVisual_MarkerMember

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_MarkerMember self) -> StepVisual_MarkerMember

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_MarkerMember self) -> StepVisual_MarkerMember

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_MarkerMember___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_MarkerMember self) -> StepVisual_MarkerMember

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_MarkerMember___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_MarkerMember___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_MarkerMember___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_MarkerMember(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_MarkerMember_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_MarkerMember

    def HasName(self, *args):
        """
        HasName(Handle_StepVisual_MarkerMember self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_HasName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_MarkerMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_MarkerMember self, Standard_CString const name) -> Standard_Boolean

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_SetName(self, *args)


    def EnumText(self, *args):
        """
        EnumText(Handle_StepVisual_MarkerMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_EnumText(self, *args)


    def SetEnumText(self, *args):
        """
        SetEnumText(Handle_StepVisual_MarkerMember self, Standard_Integer const val, Standard_CString const text)

        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_SetEnumText(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_StepVisual_MarkerMember self, StepVisual_MarkerType const val)

        :type val: OCC.wrapper.StepVisual.StepVisual_MarkerType

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_SetValue(self, *args)


    def Value(self, *args):
        """
        Value(Handle_StepVisual_MarkerMember self) -> StepVisual_MarkerType

        :rtype: OCC.wrapper.StepVisual.StepVisual_MarkerType

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_Value(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_MarkerMember self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_MarkerMember_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_MarkerMember_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Kind(self, *args):
        """
        Kind(Handle_StepVisual_MarkerMember self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_Kind(self, *args)


    def SetKind(self, *args):
        """
        SetKind(Handle_StepVisual_MarkerMember self, Standard_Integer const kind)

        :type kind: int

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_SetKind(self, *args)


    def Int(self, *args):
        """
        Int(Handle_StepVisual_MarkerMember self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_Int(self, *args)


    def SetInt(self, *args):
        """
        SetInt(Handle_StepVisual_MarkerMember self, Standard_Integer const val)

        :type val: int

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_SetInt(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_StepVisual_MarkerMember self, Standard_CString const name) -> Standard_Boolean

        Tells if the name of a SelectMember matches a given one
        By default, compares the strings, can be redefined (optimised)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_Matches(self, *args)


    def ParamType(self, *args):
        """
        ParamType(Handle_StepVisual_MarkerMember self) -> Interface_ParamType

        Returns the Kind of the SelectMember, under the form of an
        enum ParamType

        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_ParamType(self, *args)


    def Integer(self, *args):
        """
        Integer(Handle_StepVisual_MarkerMember self) -> Standard_Integer

        Gets the value as an Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_Integer(self, *args)


    def SetInteger(self, *args):
        """
        SetInteger(Handle_StepVisual_MarkerMember self, Standard_Integer const val)

        :type val: int

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_SetInteger(self, *args)


    def Boolean(self, *args):
        """
        Boolean(Handle_StepVisual_MarkerMember self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_Boolean(self, *args)


    def SetBoolean(self, *args):
        """
        SetBoolean(Handle_StepVisual_MarkerMember self, Standard_Boolean const val)

        :type val: bool

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_SetBoolean(self, *args)


    def Logical(self, *args):
        """
        Logical(Handle_StepVisual_MarkerMember self) -> StepData_Logical

        :rtype: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_Logical(self, *args)


    def SetLogical(self, *args):
        """
        SetLogical(Handle_StepVisual_MarkerMember self, StepData_Logical const val)

        :type val: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_SetLogical(self, *args)


    def Real(self, *args):
        """
        Real(Handle_StepVisual_MarkerMember self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_Real(self, *args)


    def SetReal(self, *args):
        """
        SetReal(Handle_StepVisual_MarkerMember self, Standard_Real const val)

        :type val: float

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_SetReal(self, *args)


    def String(self, *args):
        """
        String(Handle_StepVisual_MarkerMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_String(self, *args)


    def SetString(self, *args):
        """
        SetString(Handle_StepVisual_MarkerMember self, Standard_CString const val)

        :type val: OCC.wrapper.Standard.Standard_CString

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_SetString(self, *args)


    def Enum(self, *args):
        """
        Enum(Handle_StepVisual_MarkerMember self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_Enum(self, *args)


    def SetEnum(self, *args):
        """
        SetEnum(Handle_StepVisual_MarkerMember self, Standard_Integer const val, Standard_CString const text)

        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_SetEnum(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_MarkerMember self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_MarkerMember_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_MarkerMember self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_MarkerMember self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_MarkerMember self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_MarkerMember self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_MarkerMember self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_MarkerMember self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_MarkerMember self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_MarkerMember_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_MarkerMember self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_MarkerMember_DecrementRefCounter(self, *args)

Handle_StepVisual_MarkerMember_swigregister = _StepVisual.Handle_StepVisual_MarkerMember_swigregister
Handle_StepVisual_MarkerMember_swigregister(Handle_StepVisual_MarkerMember)

def Handle_StepVisual_MarkerMember_DownCast(thing):
    return _StepVisual.Handle_StepVisual_MarkerMember_DownCast(thing)
Handle_StepVisual_MarkerMember_DownCast = _StepVisual.Handle_StepVisual_MarkerMember_DownCast

class StepVisual_TemplateInstance(StepRepr.StepRepr_MappedItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_TemplateInstance
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_TemplateInstance(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_TemplateInstance self) -> StepVisual_TemplateInstance

        Returns a TemplateInstance


        """
        this = _StepVisual.new_StepVisual_TemplateInstance(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_TemplateInstance_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_TemplateInstance_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_TemplateInstance_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_TemplateInstance
StepVisual_TemplateInstance_swigregister = _StepVisual.StepVisual_TemplateInstance_swigregister
StepVisual_TemplateInstance_swigregister(StepVisual_TemplateInstance)

def StepVisual_TemplateInstance_get_type_name(*args):
    """
    StepVisual_TemplateInstance_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_TemplateInstance_get_type_name(*args)

def StepVisual_TemplateInstance_get_type_descriptor(*args):
    """
    StepVisual_TemplateInstance_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_TemplateInstance_get_type_descriptor(*args)

class StepVisual_HArray1OfStyleContextSelect(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_HArray1OfStyleContextSelect
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_HArray1OfStyleContextSelect(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_HArray1OfStyleContextSelect self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepVisual_HArray1OfStyleContextSelect
        __init__(StepVisual_HArray1OfStyleContextSelect self, Standard_Integer const theLower, Standard_Integer const theUpper, StepVisual_StyleContextSelect theValue) -> StepVisual_HArray1OfStyleContextSelect
        __init__(StepVisual_HArray1OfStyleContextSelect self, NCollection_Array1_StepVisual_StyleContextSelect theOther) -> StepVisual_HArray1OfStyleContextSelect

        :type theOther: OCC.wrapper.StepVisual.StepVisual_Array1OfStyleContextSelect

        """
        this = _StepVisual.new_StepVisual_HArray1OfStyleContextSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfStyleContextSelect

        """
        res = _StepVisual.StepVisual_HArray1OfStyleContextSelect_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepVisual_HArray1OfStyleContextSelect self) -> NCollection_Array1_StepVisual_StyleContextSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfStyleContextSelect

        """
        return _StepVisual.StepVisual_HArray1OfStyleContextSelect_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_HArray1OfStyleContextSelect_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_HArray1OfStyleContextSelect_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_HArray1OfStyleContextSelect_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_HArray1OfStyleContextSelect
StepVisual_HArray1OfStyleContextSelect_swigregister = _StepVisual.StepVisual_HArray1OfStyleContextSelect_swigregister
StepVisual_HArray1OfStyleContextSelect_swigregister(StepVisual_HArray1OfStyleContextSelect)

def StepVisual_HArray1OfStyleContextSelect_get_type_name(*args):
    """
    StepVisual_HArray1OfStyleContextSelect_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_HArray1OfStyleContextSelect_get_type_name(*args)

def StepVisual_HArray1OfStyleContextSelect_get_type_descriptor(*args):
    """
    StepVisual_HArray1OfStyleContextSelect_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_HArray1OfStyleContextSelect_get_type_descriptor(*args)

class Handle_StepVisual_ViewVolume(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_ViewVolume self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_ViewVolume_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_ViewVolume self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_ViewVolume self, StepVisual_ViewVolume thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_ViewVolume self, Handle_StepVisual_ViewVolume theHandle) -> Handle_StepVisual_ViewVolume
        assign(Handle_StepVisual_ViewVolume self, StepVisual_ViewVolume thePtr) -> Handle_StepVisual_ViewVolume
        assign(Handle_StepVisual_ViewVolume self, Handle_StepVisual_ViewVolume theHandle) -> Handle_StepVisual_ViewVolume

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_ViewVolume self) -> StepVisual_ViewVolume

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_ViewVolume self) -> StepVisual_ViewVolume

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_ViewVolume___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_ViewVolume self) -> StepVisual_ViewVolume

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_ViewVolume___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_ViewVolume___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_ViewVolume___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_ViewVolume(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_ViewVolume_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_ViewVolume

    def Init(self, *args):
        """
        Init(Handle_StepVisual_ViewVolume self, StepVisual_CentralOrParallel const aProjectionType, Handle_StepGeom_CartesianPoint aProjectionPoint, Standard_Real const aViewPlaneDistance, Standard_Real const aFrontPlaneDistance, Standard_Boolean const aFrontPlaneClipping, Standard_Real const aBackPlaneDistance, Standard_Boolean const aBackPlaneClipping, Standard_Boolean const aViewVolumeSidesClipping, Handle_StepVisual_PlanarBox aViewWindow)

        :type aProjectionType: OCC.wrapper.StepVisual.StepVisual_CentralOrParallel
        :type aProjectionPoint: OCC.wrapper.StepVisual.Handle_StepGeom_CartesianPoint
        :type aViewPlaneDistance: float
        :type aFrontPlaneDistance: float
        :type aFrontPlaneClipping: bool
        :type aBackPlaneDistance: float
        :type aBackPlaneClipping: bool
        :type aViewVolumeSidesClipping: bool
        :type aViewWindow: OCC.wrapper.StepVisual.Handle_StepVisual_PlanarBox

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_Init(self, *args)


    def SetProjectionType(self, *args):
        """
        SetProjectionType(Handle_StepVisual_ViewVolume self, StepVisual_CentralOrParallel const aProjectionType)

        :type aProjectionType: OCC.wrapper.StepVisual.StepVisual_CentralOrParallel

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_SetProjectionType(self, *args)


    def ProjectionType(self, *args):
        """
        ProjectionType(Handle_StepVisual_ViewVolume self) -> StepVisual_CentralOrParallel

        :rtype: OCC.wrapper.StepVisual.StepVisual_CentralOrParallel

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_ProjectionType(self, *args)


    def SetProjectionPoint(self, *args):
        """
        SetProjectionPoint(Handle_StepVisual_ViewVolume self, Handle_StepGeom_CartesianPoint aProjectionPoint)

        :type aProjectionPoint: OCC.wrapper.StepVisual.Handle_StepGeom_CartesianPoint

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_SetProjectionPoint(self, *args)


    def ProjectionPoint(self, *args):
        """
        ProjectionPoint(Handle_StepVisual_ViewVolume self) -> Handle_StepGeom_CartesianPoint

        :rtype: OCC.wrapper.StepVisual.Handle_StepGeom_CartesianPoint

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_ProjectionPoint(self, *args)


    def SetViewPlaneDistance(self, *args):
        """
        SetViewPlaneDistance(Handle_StepVisual_ViewVolume self, Standard_Real const aViewPlaneDistance)

        :type aViewPlaneDistance: float

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_SetViewPlaneDistance(self, *args)


    def ViewPlaneDistance(self, *args):
        """
        ViewPlaneDistance(Handle_StepVisual_ViewVolume self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_ViewPlaneDistance(self, *args)


    def SetFrontPlaneDistance(self, *args):
        """
        SetFrontPlaneDistance(Handle_StepVisual_ViewVolume self, Standard_Real const aFrontPlaneDistance)

        :type aFrontPlaneDistance: float

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_SetFrontPlaneDistance(self, *args)


    def FrontPlaneDistance(self, *args):
        """
        FrontPlaneDistance(Handle_StepVisual_ViewVolume self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_FrontPlaneDistance(self, *args)


    def SetFrontPlaneClipping(self, *args):
        """
        SetFrontPlaneClipping(Handle_StepVisual_ViewVolume self, Standard_Boolean const aFrontPlaneClipping)

        :type aFrontPlaneClipping: bool

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_SetFrontPlaneClipping(self, *args)


    def FrontPlaneClipping(self, *args):
        """
        FrontPlaneClipping(Handle_StepVisual_ViewVolume self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_FrontPlaneClipping(self, *args)


    def SetBackPlaneDistance(self, *args):
        """
        SetBackPlaneDistance(Handle_StepVisual_ViewVolume self, Standard_Real const aBackPlaneDistance)

        :type aBackPlaneDistance: float

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_SetBackPlaneDistance(self, *args)


    def BackPlaneDistance(self, *args):
        """
        BackPlaneDistance(Handle_StepVisual_ViewVolume self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_BackPlaneDistance(self, *args)


    def SetBackPlaneClipping(self, *args):
        """
        SetBackPlaneClipping(Handle_StepVisual_ViewVolume self, Standard_Boolean const aBackPlaneClipping)

        :type aBackPlaneClipping: bool

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_SetBackPlaneClipping(self, *args)


    def BackPlaneClipping(self, *args):
        """
        BackPlaneClipping(Handle_StepVisual_ViewVolume self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_BackPlaneClipping(self, *args)


    def SetViewVolumeSidesClipping(self, *args):
        """
        SetViewVolumeSidesClipping(Handle_StepVisual_ViewVolume self, Standard_Boolean const aViewVolumeSidesClipping)

        :type aViewVolumeSidesClipping: bool

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_SetViewVolumeSidesClipping(self, *args)


    def ViewVolumeSidesClipping(self, *args):
        """
        ViewVolumeSidesClipping(Handle_StepVisual_ViewVolume self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_ViewVolumeSidesClipping(self, *args)


    def SetViewWindow(self, *args):
        """
        SetViewWindow(Handle_StepVisual_ViewVolume self, Handle_StepVisual_PlanarBox aViewWindow)

        :type aViewWindow: OCC.wrapper.StepVisual.Handle_StepVisual_PlanarBox

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_SetViewWindow(self, *args)


    def ViewWindow(self, *args):
        """
        ViewWindow(Handle_StepVisual_ViewVolume self) -> Handle_StepVisual_PlanarBox

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PlanarBox

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_ViewWindow(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_ViewVolume self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_ViewVolume_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_ViewVolume_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_ViewVolume self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_ViewVolume_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_ViewVolume self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_ViewVolume self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_ViewVolume self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_ViewVolume self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_ViewVolume self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_ViewVolume self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_ViewVolume self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_ViewVolume_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_ViewVolume self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_ViewVolume_DecrementRefCounter(self, *args)

Handle_StepVisual_ViewVolume_swigregister = _StepVisual.Handle_StepVisual_ViewVolume_swigregister
Handle_StepVisual_ViewVolume_swigregister(Handle_StepVisual_ViewVolume)

def Handle_StepVisual_ViewVolume_DownCast(thing):
    return _StepVisual.Handle_StepVisual_ViewVolume_DownCast(thing)
Handle_StepVisual_ViewVolume_DownCast = _StepVisual.Handle_StepVisual_ViewVolume_DownCast

class StepVisual_HArray1OfAnnotationPlaneElement(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_HArray1OfAnnotationPlaneElement
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_HArray1OfAnnotationPlaneElement(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_HArray1OfAnnotationPlaneElement self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepVisual_HArray1OfAnnotationPlaneElement
        __init__(StepVisual_HArray1OfAnnotationPlaneElement self, Standard_Integer const theLower, Standard_Integer const theUpper, StepVisual_AnnotationPlaneElement theValue) -> StepVisual_HArray1OfAnnotationPlaneElement
        __init__(StepVisual_HArray1OfAnnotationPlaneElement self, NCollection_Array1_StepVisual_AnnotationPlaneElement theOther) -> StepVisual_HArray1OfAnnotationPlaneElement

        :type theOther: OCC.wrapper.StepVisual.StepVisual_Array1OfAnnotationPlaneElement

        """
        this = _StepVisual.new_StepVisual_HArray1OfAnnotationPlaneElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfAnnotationPlaneElement

        """
        res = _StepVisual.StepVisual_HArray1OfAnnotationPlaneElement_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepVisual_HArray1OfAnnotationPlaneElement self) -> NCollection_Array1_StepVisual_AnnotationPlaneElement

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfAnnotationPlaneElement

        """
        return _StepVisual.StepVisual_HArray1OfAnnotationPlaneElement_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_HArray1OfAnnotationPlaneElement_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_HArray1OfAnnotationPlaneElement_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_HArray1OfAnnotationPlaneElement_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_HArray1OfAnnotationPlaneElement
StepVisual_HArray1OfAnnotationPlaneElement_swigregister = _StepVisual.StepVisual_HArray1OfAnnotationPlaneElement_swigregister
StepVisual_HArray1OfAnnotationPlaneElement_swigregister(StepVisual_HArray1OfAnnotationPlaneElement)

def StepVisual_HArray1OfAnnotationPlaneElement_get_type_name(*args):
    """
    StepVisual_HArray1OfAnnotationPlaneElement_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_HArray1OfAnnotationPlaneElement_get_type_name(*args)

def StepVisual_HArray1OfAnnotationPlaneElement_get_type_descriptor(*args):
    """
    StepVisual_HArray1OfAnnotationPlaneElement_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_HArray1OfAnnotationPlaneElement_get_type_descriptor(*args)

class Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect self, StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect self, Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect theHandle) -> Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect
        assign(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect self, StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect thePtr) -> Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect
        assign(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect self, Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect theHandle) -> Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect self) -> StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect self) -> StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect self) -> StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfCameraModelD3MultiClippingUnionSelect

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect self) -> NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfCameraModelD3MultiClippingUnionSelect

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_DecrementRefCounter(self, *args)

Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_swigregister = _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_swigregister
Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_swigregister(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect)

def Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_DownCast(thing):
    return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_DownCast(thing)
Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_DownCast = _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingUnionSelect_DownCast

class Handle_StepVisual_PresentationRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_PresentationRepresentation self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_PresentationRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_PresentationRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_PresentationRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_PresentationRepresentation self, StepVisual_PresentationRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_PresentationRepresentation self, Handle_StepVisual_PresentationRepresentation theHandle) -> Handle_StepVisual_PresentationRepresentation
        assign(Handle_StepVisual_PresentationRepresentation self, StepVisual_PresentationRepresentation thePtr) -> Handle_StepVisual_PresentationRepresentation
        assign(Handle_StepVisual_PresentationRepresentation self, Handle_StepVisual_PresentationRepresentation theHandle) -> Handle_StepVisual_PresentationRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_PresentationRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_PresentationRepresentation self) -> StepVisual_PresentationRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_PresentationRepresentation self) -> StepVisual_PresentationRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_PresentationRepresentation self) -> StepVisual_PresentationRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_PresentationRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_PresentationRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_PresentationRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_PresentationRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_PresentationRepresentation_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_PresentationRepresentation

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_PresentationRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_PresentationRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PresentationRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PresentationRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_PresentationRepresentation self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_HArray1OfRepresentationItem aItems, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepVisual.Handle_StepVisual_PresentationRepresentation_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_PresentationRepresentation self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_PresentationRepresentation_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_PresentationRepresentation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_PresentationRepresentation_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepVisual_PresentationRepresentation self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepVisual.Handle_StepVisual_PresentationRepresentation_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepVisual_PresentationRepresentation self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepVisual.Handle_StepVisual_PresentationRepresentation_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepVisual_PresentationRepresentation self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_PresentationRepresentation_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepVisual_PresentationRepresentation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentationRepresentation_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepVisual_PresentationRepresentation self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepVisual.Handle_StepVisual_PresentationRepresentation_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepVisual_PresentationRepresentation self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepVisual.Handle_StepVisual_PresentationRepresentation_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_PresentationRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_PresentationRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_PresentationRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_PresentationRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PresentationRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_PresentationRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_PresentationRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PresentationRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_PresentationRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_PresentationRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_PresentationRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentationRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_PresentationRepresentation self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_PresentationRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_PresentationRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentationRepresentation_DecrementRefCounter(self, *args)

Handle_StepVisual_PresentationRepresentation_swigregister = _StepVisual.Handle_StepVisual_PresentationRepresentation_swigregister
Handle_StepVisual_PresentationRepresentation_swigregister(Handle_StepVisual_PresentationRepresentation)

def Handle_StepVisual_PresentationRepresentation_DownCast(thing):
    return _StepVisual.Handle_StepVisual_PresentationRepresentation_DownCast(thing)
Handle_StepVisual_PresentationRepresentation_DownCast = _StepVisual.Handle_StepVisual_PresentationRepresentation_DownCast

class Handle_StepVisual_HArray1OfCurveStyleFontPattern(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_HArray1OfCurveStyleFontPattern self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_HArray1OfCurveStyleFontPattern self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_HArray1OfCurveStyleFontPattern self, StepVisual_HArray1OfCurveStyleFontPattern thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_HArray1OfCurveStyleFontPattern self, Handle_StepVisual_HArray1OfCurveStyleFontPattern theHandle) -> Handle_StepVisual_HArray1OfCurveStyleFontPattern
        assign(Handle_StepVisual_HArray1OfCurveStyleFontPattern self, StepVisual_HArray1OfCurveStyleFontPattern thePtr) -> Handle_StepVisual_HArray1OfCurveStyleFontPattern
        assign(Handle_StepVisual_HArray1OfCurveStyleFontPattern self, Handle_StepVisual_HArray1OfCurveStyleFontPattern theHandle) -> Handle_StepVisual_HArray1OfCurveStyleFontPattern

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_HArray1OfCurveStyleFontPattern self) -> StepVisual_HArray1OfCurveStyleFontPattern

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_HArray1OfCurveStyleFontPattern self) -> StepVisual_HArray1OfCurveStyleFontPattern

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_HArray1OfCurveStyleFontPattern self) -> StepVisual_HArray1OfCurveStyleFontPattern

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_HArray1OfCurveStyleFontPattern(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_HArray1OfCurveStyleFontPattern

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfCurveStyleFontPattern

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepVisual_HArray1OfCurveStyleFontPattern self) -> NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfCurveStyleFontPattern

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_HArray1OfCurveStyleFontPattern self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_HArray1OfCurveStyleFontPattern self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_HArray1OfCurveStyleFontPattern self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_HArray1OfCurveStyleFontPattern self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_HArray1OfCurveStyleFontPattern self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_HArray1OfCurveStyleFontPattern self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_HArray1OfCurveStyleFontPattern self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_HArray1OfCurveStyleFontPattern self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_HArray1OfCurveStyleFontPattern self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_HArray1OfCurveStyleFontPattern self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern_DecrementRefCounter(self, *args)

Handle_StepVisual_HArray1OfCurveStyleFontPattern_swigregister = _StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern_swigregister
Handle_StepVisual_HArray1OfCurveStyleFontPattern_swigregister(Handle_StepVisual_HArray1OfCurveStyleFontPattern)

def Handle_StepVisual_HArray1OfCurveStyleFontPattern_DownCast(thing):
    return _StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern_DownCast(thing)
Handle_StepVisual_HArray1OfCurveStyleFontPattern_DownCast = _StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern_DownCast

class Handle_StepVisual_ExternallyDefinedTextFont(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_ExternallyDefinedTextFont self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_ExternallyDefinedTextFont self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_ExternallyDefinedTextFont self, StepVisual_ExternallyDefinedTextFont thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_ExternallyDefinedTextFont self, Handle_StepVisual_ExternallyDefinedTextFont theHandle) -> Handle_StepVisual_ExternallyDefinedTextFont
        assign(Handle_StepVisual_ExternallyDefinedTextFont self, StepVisual_ExternallyDefinedTextFont thePtr) -> Handle_StepVisual_ExternallyDefinedTextFont
        assign(Handle_StepVisual_ExternallyDefinedTextFont self, Handle_StepVisual_ExternallyDefinedTextFont theHandle) -> Handle_StepVisual_ExternallyDefinedTextFont

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_ExternallyDefinedTextFont self) -> StepVisual_ExternallyDefinedTextFont

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_ExternallyDefinedTextFont self) -> StepVisual_ExternallyDefinedTextFont

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_ExternallyDefinedTextFont self) -> StepVisual_ExternallyDefinedTextFont

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_ExternallyDefinedTextFont(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_ExternallyDefinedTextFont_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_ExternallyDefinedTextFont

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_ExternallyDefinedTextFont self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_ExternallyDefinedTextFont self, StepBasic_SourceItem aItemId, Handle_StepBasic_ExternalSource aSource)

        Initialize all fields (own and inherited)

        :type aItemId: OCC.wrapper.StepBasic.StepBasic_SourceItem
        :type aSource: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont_Init(self, *args)


    def ItemId(self, *args):
        """
        ItemId(Handle_StepVisual_ExternallyDefinedTextFont self) -> StepBasic_SourceItem

        Returns field ItemId

        :rtype: OCC.wrapper.StepBasic.StepBasic_SourceItem

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont_ItemId(self, *args)


    def SetItemId(self, *args):
        """
        SetItemId(Handle_StepVisual_ExternallyDefinedTextFont self, StepBasic_SourceItem ItemId)

        Set field ItemId

        :type ItemId: OCC.wrapper.StepBasic.StepBasic_SourceItem

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont_SetItemId(self, *args)


    def Source(self, *args):
        """
        Source(Handle_StepVisual_ExternallyDefinedTextFont self) -> Handle_StepBasic_ExternalSource

        Returns field Source

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont_Source(self, *args)


    def SetSource(self, *args):
        """
        SetSource(Handle_StepVisual_ExternallyDefinedTextFont self, Handle_StepBasic_ExternalSource Source)

        Set field Source

        :type Source: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont_SetSource(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_ExternallyDefinedTextFont self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_ExternallyDefinedTextFont self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_ExternallyDefinedTextFont self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_ExternallyDefinedTextFont self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_ExternallyDefinedTextFont self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_ExternallyDefinedTextFont self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_ExternallyDefinedTextFont self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_ExternallyDefinedTextFont self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_ExternallyDefinedTextFont self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont_DecrementRefCounter(self, *args)

Handle_StepVisual_ExternallyDefinedTextFont_swigregister = _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont_swigregister
Handle_StepVisual_ExternallyDefinedTextFont_swigregister(Handle_StepVisual_ExternallyDefinedTextFont)

def Handle_StepVisual_ExternallyDefinedTextFont_DownCast(thing):
    return _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont_DownCast(thing)
Handle_StepVisual_ExternallyDefinedTextFont_DownCast = _StepVisual.Handle_StepVisual_ExternallyDefinedTextFont_DownCast

class Handle_StepVisual_PreDefinedColour(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_PreDefinedColour self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_PreDefinedColour_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_PreDefinedColour self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_PreDefinedColour_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_PreDefinedColour self, StepVisual_PreDefinedColour thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_PreDefinedColour_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_PreDefinedColour self, Handle_StepVisual_PreDefinedColour theHandle) -> Handle_StepVisual_PreDefinedColour
        assign(Handle_StepVisual_PreDefinedColour self, StepVisual_PreDefinedColour thePtr) -> Handle_StepVisual_PreDefinedColour
        assign(Handle_StepVisual_PreDefinedColour self, Handle_StepVisual_PreDefinedColour theHandle) -> Handle_StepVisual_PreDefinedColour

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_PreDefinedColour_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_PreDefinedColour self) -> StepVisual_PreDefinedColour

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PreDefinedColour_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_PreDefinedColour self) -> StepVisual_PreDefinedColour

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PreDefinedColour___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_PreDefinedColour self) -> StepVisual_PreDefinedColour

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_PreDefinedColour___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_PreDefinedColour___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_PreDefinedColour___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_PreDefinedColour(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_PreDefinedColour_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_PreDefinedColour

    def SetPreDefinedItem(self, *args):
        """
        SetPreDefinedItem(Handle_StepVisual_PreDefinedColour self, Handle_StepVisual_PreDefinedItem item)

        set a pre_defined_item part

        :type item: OCC.wrapper.StepVisual.Handle_StepVisual_PreDefinedItem

        """
        return _StepVisual.Handle_StepVisual_PreDefinedColour_SetPreDefinedItem(self, *args)


    def GetPreDefinedItem(self, *args):
        """
        return a pre_defined_item part

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PreDefinedItem

        """
        res = _StepVisual.Handle_StepVisual_PreDefinedColour_GetPreDefinedItem(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_PreDefinedColour self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_PreDefinedColour_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PreDefinedColour_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PreDefinedColour_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_PreDefinedColour self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_PreDefinedColour_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_PreDefinedColour self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_PreDefinedColour self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PreDefinedColour_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_PreDefinedColour self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_PreDefinedColour self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PreDefinedColour_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_PreDefinedColour self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_PreDefinedColour_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_PreDefinedColour self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PreDefinedColour_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_PreDefinedColour self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_PreDefinedColour_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_PreDefinedColour self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PreDefinedColour_DecrementRefCounter(self, *args)

Handle_StepVisual_PreDefinedColour_swigregister = _StepVisual.Handle_StepVisual_PreDefinedColour_swigregister
Handle_StepVisual_PreDefinedColour_swigregister(Handle_StepVisual_PreDefinedColour)

def Handle_StepVisual_PreDefinedColour_DownCast(thing):
    return _StepVisual.Handle_StepVisual_PreDefinedColour_DownCast(thing)
Handle_StepVisual_PreDefinedColour_DownCast = _StepVisual.Handle_StepVisual_PreDefinedColour_DownCast

class Handle_StepVisual_TextLiteral(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_TextLiteral self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_TextLiteral_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_TextLiteral self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_TextLiteral_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_TextLiteral self, StepVisual_TextLiteral thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_TextLiteral_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_TextLiteral self, Handle_StepVisual_TextLiteral theHandle) -> Handle_StepVisual_TextLiteral
        assign(Handle_StepVisual_TextLiteral self, StepVisual_TextLiteral thePtr) -> Handle_StepVisual_TextLiteral
        assign(Handle_StepVisual_TextLiteral self, Handle_StepVisual_TextLiteral theHandle) -> Handle_StepVisual_TextLiteral

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_TextLiteral_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_TextLiteral self) -> StepVisual_TextLiteral

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_TextLiteral_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_TextLiteral self) -> StepVisual_TextLiteral

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_TextLiteral___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_TextLiteral self) -> StepVisual_TextLiteral

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_TextLiteral___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_TextLiteral___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_TextLiteral___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_TextLiteral(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_TextLiteral_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_TextLiteral

    def Init(self, *args):
        """
        Init(Handle_StepVisual_TextLiteral self, Handle_TCollection_HAsciiString aName, Handle_TCollection_HAsciiString aLiteral, StepGeom_Axis2Placement aPlacement, Handle_TCollection_HAsciiString aAlignment, StepVisual_TextPath const aPath, StepVisual_FontSelect aFont)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aLiteral: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPlacement: OCC.wrapper.StepGeom.StepGeom_Axis2Placement
        :type aAlignment: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPath: OCC.wrapper.StepVisual.StepVisual_TextPath
        :type aFont: OCC.wrapper.StepVisual.StepVisual_FontSelect

        """
        return _StepVisual.Handle_StepVisual_TextLiteral_Init(self, *args)


    def SetLiteral(self, *args):
        """
        SetLiteral(Handle_StepVisual_TextLiteral self, Handle_TCollection_HAsciiString aLiteral)

        :type aLiteral: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_TextLiteral_SetLiteral(self, *args)


    def Literal(self, *args):
        """
        Literal(Handle_StepVisual_TextLiteral self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_TextLiteral_Literal(self, *args)


    def SetPlacement(self, *args):
        """
        SetPlacement(Handle_StepVisual_TextLiteral self, StepGeom_Axis2Placement aPlacement)

        :type aPlacement: OCC.wrapper.StepGeom.StepGeom_Axis2Placement

        """
        return _StepVisual.Handle_StepVisual_TextLiteral_SetPlacement(self, *args)


    def Placement(self, *args):
        """
        Placement(Handle_StepVisual_TextLiteral self) -> StepGeom_Axis2Placement

        :rtype: OCC.wrapper.StepGeom.StepGeom_Axis2Placement

        """
        return _StepVisual.Handle_StepVisual_TextLiteral_Placement(self, *args)


    def SetAlignment(self, *args):
        """
        SetAlignment(Handle_StepVisual_TextLiteral self, Handle_TCollection_HAsciiString aAlignment)

        :type aAlignment: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_TextLiteral_SetAlignment(self, *args)


    def Alignment(self, *args):
        """
        Alignment(Handle_StepVisual_TextLiteral self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_TextLiteral_Alignment(self, *args)


    def SetPath(self, *args):
        """
        SetPath(Handle_StepVisual_TextLiteral self, StepVisual_TextPath const aPath)

        :type aPath: OCC.wrapper.StepVisual.StepVisual_TextPath

        """
        return _StepVisual.Handle_StepVisual_TextLiteral_SetPath(self, *args)


    def Path(self, *args):
        """
        Path(Handle_StepVisual_TextLiteral self) -> StepVisual_TextPath

        :rtype: OCC.wrapper.StepVisual.StepVisual_TextPath

        """
        return _StepVisual.Handle_StepVisual_TextLiteral_Path(self, *args)


    def SetFont(self, *args):
        """
        SetFont(Handle_StepVisual_TextLiteral self, StepVisual_FontSelect aFont)

        :type aFont: OCC.wrapper.StepVisual.StepVisual_FontSelect

        """
        return _StepVisual.Handle_StepVisual_TextLiteral_SetFont(self, *args)


    def Font(self, *args):
        """
        Font(Handle_StepVisual_TextLiteral self) -> StepVisual_FontSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_FontSelect

        """
        return _StepVisual.Handle_StepVisual_TextLiteral_Font(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_TextLiteral self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_TextLiteral_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_TextLiteral_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_TextLiteral_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_TextLiteral self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_TextLiteral_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_TextLiteral self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_TextLiteral_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_TextLiteral self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_TextLiteral_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_TextLiteral self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_TextLiteral self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_TextLiteral_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_TextLiteral self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_TextLiteral self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_TextLiteral_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_TextLiteral self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_TextLiteral_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_TextLiteral self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_TextLiteral_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_TextLiteral self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_TextLiteral_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_TextLiteral self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_TextLiteral_DecrementRefCounter(self, *args)

Handle_StepVisual_TextLiteral_swigregister = _StepVisual.Handle_StepVisual_TextLiteral_swigregister
Handle_StepVisual_TextLiteral_swigregister(Handle_StepVisual_TextLiteral)

def Handle_StepVisual_TextLiteral_DownCast(thing):
    return _StepVisual.Handle_StepVisual_TextLiteral_DownCast(thing)
Handle_StepVisual_TextLiteral_DownCast = _StepVisual.Handle_StepVisual_TextLiteral_DownCast

class StepVisual_PresentationRepresentationSelect(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepVisual_PresentationRepresentationSelect self) -> StepVisual_PresentationRepresentationSelect

        Returns a PresentationRepresentationSelect SelectType


        """
        this = _StepVisual.new_StepVisual_PresentationRepresentationSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepVisual_PresentationRepresentationSelect self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a PresentationRepresentationSelect Kind Entity that is :
        1 -> PresentationRepresentation
        2 -> PresentationSet
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_PresentationRepresentationSelect_CaseNum(self, *args)


    def PresentationRepresentation(self, *args):
        """
        PresentationRepresentation(StepVisual_PresentationRepresentationSelect self) -> Handle_StepVisual_PresentationRepresentation

        returns Value as a PresentationRepresentation (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationRepresentation

        """
        return _StepVisual.StepVisual_PresentationRepresentationSelect_PresentationRepresentation(self, *args)


    def PresentationSet(self, *args):
        """
        PresentationSet(StepVisual_PresentationRepresentationSelect self) -> Handle_StepVisual_PresentationSet

        returns Value as a PresentationSet (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationSet

        """
        return _StepVisual.StepVisual_PresentationRepresentationSelect_PresentationSet(self, *args)

    __swig_destroy__ = _StepVisual.delete_StepVisual_PresentationRepresentationSelect
StepVisual_PresentationRepresentationSelect_swigregister = _StepVisual.StepVisual_PresentationRepresentationSelect_swigregister
StepVisual_PresentationRepresentationSelect_swigregister(StepVisual_PresentationRepresentationSelect)

class Handle_StepVisual_CurveStyle(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_CurveStyle self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_CurveStyle_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_CurveStyle self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_CurveStyle_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_CurveStyle self, StepVisual_CurveStyle thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_CurveStyle_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_CurveStyle self, Handle_StepVisual_CurveStyle theHandle) -> Handle_StepVisual_CurveStyle
        assign(Handle_StepVisual_CurveStyle self, StepVisual_CurveStyle thePtr) -> Handle_StepVisual_CurveStyle
        assign(Handle_StepVisual_CurveStyle self, Handle_StepVisual_CurveStyle theHandle) -> Handle_StepVisual_CurveStyle

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_CurveStyle_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_CurveStyle self) -> StepVisual_CurveStyle

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CurveStyle_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_CurveStyle self) -> StepVisual_CurveStyle

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CurveStyle___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_CurveStyle self) -> StepVisual_CurveStyle

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_CurveStyle___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_CurveStyle___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_CurveStyle___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_CurveStyle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_CurveStyle_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_CurveStyle

    def Init(self, *args):
        """
        Init(Handle_StepVisual_CurveStyle self, Handle_TCollection_HAsciiString aName, StepVisual_CurveStyleFontSelect aCurveFont, StepBasic_SizeSelect aCurveWidth, Handle_StepVisual_Colour aCurveColour)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aCurveFont: OCC.wrapper.StepVisual.StepVisual_CurveStyleFontSelect
        :type aCurveWidth: OCC.wrapper.StepBasic.StepBasic_SizeSelect
        :type aCurveColour: OCC.wrapper.StepVisual.Handle_StepVisual_Colour

        """
        return _StepVisual.Handle_StepVisual_CurveStyle_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_CurveStyle self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CurveStyle_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_CurveStyle self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CurveStyle_Name(self, *args)


    def SetCurveFont(self, *args):
        """
        SetCurveFont(Handle_StepVisual_CurveStyle self, StepVisual_CurveStyleFontSelect aCurveFont)

        :type aCurveFont: OCC.wrapper.StepVisual.StepVisual_CurveStyleFontSelect

        """
        return _StepVisual.Handle_StepVisual_CurveStyle_SetCurveFont(self, *args)


    def CurveFont(self, *args):
        """
        CurveFont(Handle_StepVisual_CurveStyle self) -> StepVisual_CurveStyleFontSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_CurveStyleFontSelect

        """
        return _StepVisual.Handle_StepVisual_CurveStyle_CurveFont(self, *args)


    def SetCurveWidth(self, *args):
        """
        SetCurveWidth(Handle_StepVisual_CurveStyle self, StepBasic_SizeSelect aCurveWidth)

        :type aCurveWidth: OCC.wrapper.StepBasic.StepBasic_SizeSelect

        """
        return _StepVisual.Handle_StepVisual_CurveStyle_SetCurveWidth(self, *args)


    def CurveWidth(self, *args):
        """
        CurveWidth(Handle_StepVisual_CurveStyle self) -> StepBasic_SizeSelect

        :rtype: OCC.wrapper.StepBasic.StepBasic_SizeSelect

        """
        return _StepVisual.Handle_StepVisual_CurveStyle_CurveWidth(self, *args)


    def SetCurveColour(self, *args):
        """
        SetCurveColour(Handle_StepVisual_CurveStyle self, Handle_StepVisual_Colour aCurveColour)

        :type aCurveColour: OCC.wrapper.StepVisual.Handle_StepVisual_Colour

        """
        return _StepVisual.Handle_StepVisual_CurveStyle_SetCurveColour(self, *args)


    def CurveColour(self, *args):
        """
        CurveColour(Handle_StepVisual_CurveStyle self) -> Handle_StepVisual_Colour

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_Colour

        """
        return _StepVisual.Handle_StepVisual_CurveStyle_CurveColour(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_CurveStyle self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_CurveStyle_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CurveStyle_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CurveStyle_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_CurveStyle self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_CurveStyle_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_CurveStyle self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_CurveStyle self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CurveStyle_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_CurveStyle self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_CurveStyle self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CurveStyle_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_CurveStyle self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_CurveStyle_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_CurveStyle self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CurveStyle_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_CurveStyle self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_CurveStyle_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_CurveStyle self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CurveStyle_DecrementRefCounter(self, *args)

Handle_StepVisual_CurveStyle_swigregister = _StepVisual.Handle_StepVisual_CurveStyle_swigregister
Handle_StepVisual_CurveStyle_swigregister(Handle_StepVisual_CurveStyle)

def Handle_StepVisual_CurveStyle_DownCast(thing):
    return _StepVisual.Handle_StepVisual_CurveStyle_DownCast(thing)
Handle_StepVisual_CurveStyle_DownCast = _StepVisual.Handle_StepVisual_CurveStyle_DownCast

class NCollection_Array1_StepVisual_AnnotationPlaneElement(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_StepVisual_AnnotationPlaneElement self) -> NCollection_Array1< StepVisual_AnnotationPlaneElement >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_AnnotationPlaneElement_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_StepVisual_AnnotationPlaneElement self) -> NCollection_Array1< StepVisual_AnnotationPlaneElement >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_AnnotationPlaneElement_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_StepVisual_AnnotationPlaneElement self) -> NCollection_Array1< StepVisual_AnnotationPlaneElement >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_AnnotationPlaneElement_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_StepVisual_AnnotationPlaneElement self) -> NCollection_Array1< StepVisual_AnnotationPlaneElement >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_AnnotationPlaneElement_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepVisual.new_NCollection_Array1_StepVisual_AnnotationPlaneElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_StepVisual_AnnotationPlaneElement self, StepVisual_AnnotationPlaneElement theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_AnnotationPlaneElement_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_StepVisual_AnnotationPlaneElement self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_AnnotationPlaneElement_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_StepVisual_AnnotationPlaneElement self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_AnnotationPlaneElement_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_StepVisual_AnnotationPlaneElement self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_AnnotationPlaneElement_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_StepVisual_AnnotationPlaneElement self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_AnnotationPlaneElement_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_StepVisual_AnnotationPlaneElement self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_AnnotationPlaneElement_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_StepVisual_AnnotationPlaneElement self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_AnnotationPlaneElement_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_StepVisual_AnnotationPlaneElement self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_AnnotationPlaneElement_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_StepVisual_AnnotationPlaneElement self, NCollection_Array1_StepVisual_AnnotationPlaneElement theOther) -> NCollection_Array1_StepVisual_AnnotationPlaneElement

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_AnnotationPlaneElement_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_StepVisual_AnnotationPlaneElement self, NCollection_Array1_StepVisual_AnnotationPlaneElement theOther) -> NCollection_Array1_StepVisual_AnnotationPlaneElement

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_AnnotationPlaneElement_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_StepVisual_AnnotationPlaneElement self, NCollection_Array1_StepVisual_AnnotationPlaneElement theOther) -> NCollection_Array1_StepVisual_AnnotationPlaneElement
        assign(NCollection_Array1_StepVisual_AnnotationPlaneElement self, NCollection_Array1_StepVisual_AnnotationPlaneElement theOther) -> NCollection_Array1_StepVisual_AnnotationPlaneElement

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_AnnotationPlaneElement_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_AnnotationPlaneElement_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_StepVisual_AnnotationPlaneElement self) -> StepVisual_AnnotationPlaneElement

        @return first element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_AnnotationPlaneElement_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_AnnotationPlaneElement_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_StepVisual_AnnotationPlaneElement self) -> StepVisual_AnnotationPlaneElement

        @return last element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_AnnotationPlaneElement_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_AnnotationPlaneElement_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_StepVisual_AnnotationPlaneElement self, Standard_Integer const theIndex) -> StepVisual_AnnotationPlaneElement

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_AnnotationPlaneElement_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_AnnotationPlaneElement___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_AnnotationPlaneElement_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_StepVisual_AnnotationPlaneElement self, Standard_Integer const theIndex, StepVisual_AnnotationPlaneElement theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_AnnotationPlaneElement_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_StepVisual_AnnotationPlaneElement self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepVisual.NCollection_Array1_StepVisual_AnnotationPlaneElement_Resize(self, *args)

    __swig_destroy__ = _StepVisual.delete_NCollection_Array1_StepVisual_AnnotationPlaneElement
NCollection_Array1_StepVisual_AnnotationPlaneElement_swigregister = _StepVisual.NCollection_Array1_StepVisual_AnnotationPlaneElement_swigregister
NCollection_Array1_StepVisual_AnnotationPlaneElement_swigregister(NCollection_Array1_StepVisual_AnnotationPlaneElement)


try:
	StepVisual_Array1OfAnnotationPlaneElement = NCollection_Array1_StepVisual_AnnotationPlaneElement
except NameError:
	pass # does not exist, probably ignored

class StepVisual_StyledItemTarget(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepVisual_StyledItemTarget self) -> StepVisual_StyledItemTarget

        Returns a StyledItemTarget select type


        """
        this = _StepVisual.new_StepVisual_StyledItemTarget(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepVisual_StyledItemTarget self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a StyledItemTarget Kind Entity that is :
        1 -> GeometricRepresentationItem
        2 -> MappedItem
        3 -> Representation
        4 -> TopologicalRepresentationItem
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_StyledItemTarget_CaseNum(self, *args)


    def GeometricRepresentationItem(self, *args):
        """
        GeometricRepresentationItem(StepVisual_StyledItemTarget self) -> Handle_StepGeom_GeometricRepresentationItem

        returns Value as a GeometricRepresentationItem (Null if another type)

        :rtype: OCC.wrapper.StepGeom.Handle_StepGeom_GeometricRepresentationItem

        """
        return _StepVisual.StepVisual_StyledItemTarget_GeometricRepresentationItem(self, *args)


    def MappedItem(self, *args):
        """
        MappedItem(StepVisual_StyledItemTarget self) -> Handle_StepRepr_MappedItem

        returns Value as a MappedItem (Null if another type)

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_MappedItem

        """
        return _StepVisual.StepVisual_StyledItemTarget_MappedItem(self, *args)


    def Representation(self, *args):
        """
        Representation(StepVisual_StyledItemTarget self) -> Handle_StepRepr_Representation

        returns Value as a Representation (Null if another type)

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_Representation

        """
        return _StepVisual.StepVisual_StyledItemTarget_Representation(self, *args)


    def TopologicalRepresentationItem(self, *args):
        """
        TopologicalRepresentationItem(StepVisual_StyledItemTarget self) -> Handle_StepShape_TopologicalRepresentationItem

        returns Value as a TopologicalRepresentationItem (Null if another type)

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_TopologicalRepresentationItem

        """
        return _StepVisual.StepVisual_StyledItemTarget_TopologicalRepresentationItem(self, *args)

    __swig_destroy__ = _StepVisual.delete_StepVisual_StyledItemTarget
StepVisual_StyledItemTarget_swigregister = _StepVisual.StepVisual_StyledItemTarget_swigregister
StepVisual_StyledItemTarget_swigregister(StepVisual_StyledItemTarget)

class Handle_StepVisual_SurfaceSideStyle(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_SurfaceSideStyle self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_SurfaceSideStyle_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_SurfaceSideStyle self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_SurfaceSideStyle_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_SurfaceSideStyle self, StepVisual_SurfaceSideStyle thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_SurfaceSideStyle_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_SurfaceSideStyle self, Handle_StepVisual_SurfaceSideStyle theHandle) -> Handle_StepVisual_SurfaceSideStyle
        assign(Handle_StepVisual_SurfaceSideStyle self, StepVisual_SurfaceSideStyle thePtr) -> Handle_StepVisual_SurfaceSideStyle
        assign(Handle_StepVisual_SurfaceSideStyle self, Handle_StepVisual_SurfaceSideStyle theHandle) -> Handle_StepVisual_SurfaceSideStyle

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_SurfaceSideStyle_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_SurfaceSideStyle self) -> StepVisual_SurfaceSideStyle

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_SurfaceSideStyle_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_SurfaceSideStyle self) -> StepVisual_SurfaceSideStyle

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_SurfaceSideStyle___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_SurfaceSideStyle self) -> StepVisual_SurfaceSideStyle

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_SurfaceSideStyle___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_SurfaceSideStyle___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_SurfaceSideStyle___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_SurfaceSideStyle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_SurfaceSideStyle_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_SurfaceSideStyle

    def Init(self, *args):
        """
        Init(Handle_StepVisual_SurfaceSideStyle self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_HArray1OfSurfaceStyleElementSelect aStyles)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect

        """
        return _StepVisual.Handle_StepVisual_SurfaceSideStyle_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_SurfaceSideStyle self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_SurfaceSideStyle_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_SurfaceSideStyle self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_SurfaceSideStyle_Name(self, *args)


    def SetStyles(self, *args):
        """
        SetStyles(Handle_StepVisual_SurfaceSideStyle self, Handle_StepVisual_HArray1OfSurfaceStyleElementSelect aStyles)

        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect

        """
        return _StepVisual.Handle_StepVisual_SurfaceSideStyle_SetStyles(self, *args)


    def Styles(self, *args):
        """
        Styles(Handle_StepVisual_SurfaceSideStyle self) -> Handle_StepVisual_HArray1OfSurfaceStyleElementSelect

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfSurfaceStyleElementSelect

        """
        return _StepVisual.Handle_StepVisual_SurfaceSideStyle_Styles(self, *args)


    def StylesValue(self, *args):
        """
        StylesValue(Handle_StepVisual_SurfaceSideStyle self, Standard_Integer const num) -> StepVisual_SurfaceStyleElementSelect

        :type num: int
        :rtype: OCC.wrapper.StepVisual.StepVisual_SurfaceStyleElementSelect

        """
        return _StepVisual.Handle_StepVisual_SurfaceSideStyle_StylesValue(self, *args)


    def NbStyles(self, *args):
        """
        NbStyles(Handle_StepVisual_SurfaceSideStyle self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_SurfaceSideStyle_NbStyles(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_SurfaceSideStyle self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_SurfaceSideStyle_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_SurfaceSideStyle_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_SurfaceSideStyle_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_SurfaceSideStyle self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_SurfaceSideStyle_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_SurfaceSideStyle self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_SurfaceSideStyle self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_SurfaceSideStyle_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_SurfaceSideStyle self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_SurfaceSideStyle self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_SurfaceSideStyle_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_SurfaceSideStyle self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_SurfaceSideStyle_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_SurfaceSideStyle self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_SurfaceSideStyle_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_SurfaceSideStyle self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_SurfaceSideStyle_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_SurfaceSideStyle self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_SurfaceSideStyle_DecrementRefCounter(self, *args)

Handle_StepVisual_SurfaceSideStyle_swigregister = _StepVisual.Handle_StepVisual_SurfaceSideStyle_swigregister
Handle_StepVisual_SurfaceSideStyle_swigregister(Handle_StepVisual_SurfaceSideStyle)

def Handle_StepVisual_SurfaceSideStyle_DownCast(thing):
    return _StepVisual.Handle_StepVisual_SurfaceSideStyle_DownCast(thing)
Handle_StepVisual_SurfaceSideStyle_DownCast = _StepVisual.Handle_StepVisual_SurfaceSideStyle_DownCast

class Handle_StepVisual_PreDefinedItem(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_PreDefinedItem self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_PreDefinedItem_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_PreDefinedItem self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_PreDefinedItem_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_PreDefinedItem self, StepVisual_PreDefinedItem thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_PreDefinedItem_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_PreDefinedItem self, Handle_StepVisual_PreDefinedItem theHandle) -> Handle_StepVisual_PreDefinedItem
        assign(Handle_StepVisual_PreDefinedItem self, StepVisual_PreDefinedItem thePtr) -> Handle_StepVisual_PreDefinedItem
        assign(Handle_StepVisual_PreDefinedItem self, Handle_StepVisual_PreDefinedItem theHandle) -> Handle_StepVisual_PreDefinedItem

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_PreDefinedItem_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_PreDefinedItem self) -> StepVisual_PreDefinedItem

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PreDefinedItem_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_PreDefinedItem self) -> StepVisual_PreDefinedItem

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PreDefinedItem___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_PreDefinedItem self) -> StepVisual_PreDefinedItem

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_PreDefinedItem___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_PreDefinedItem___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_PreDefinedItem___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_PreDefinedItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_PreDefinedItem_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_PreDefinedItem

    def Init(self, *args):
        """
        Init(Handle_StepVisual_PreDefinedItem self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_PreDefinedItem_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_PreDefinedItem self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_PreDefinedItem_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_PreDefinedItem self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_PreDefinedItem_Name(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_PreDefinedItem self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_PreDefinedItem_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PreDefinedItem_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PreDefinedItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_PreDefinedItem self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_PreDefinedItem_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_PreDefinedItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_PreDefinedItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PreDefinedItem_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_PreDefinedItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_PreDefinedItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PreDefinedItem_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_PreDefinedItem self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_PreDefinedItem_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_PreDefinedItem self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PreDefinedItem_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_PreDefinedItem self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_PreDefinedItem_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_PreDefinedItem self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PreDefinedItem_DecrementRefCounter(self, *args)

Handle_StepVisual_PreDefinedItem_swigregister = _StepVisual.Handle_StepVisual_PreDefinedItem_swigregister
Handle_StepVisual_PreDefinedItem_swigregister(Handle_StepVisual_PreDefinedItem)

def Handle_StepVisual_PreDefinedItem_DownCast(thing):
    return _StepVisual.Handle_StepVisual_PreDefinedItem_DownCast(thing)
Handle_StepVisual_PreDefinedItem_DownCast = _StepVisual.Handle_StepVisual_PreDefinedItem_DownCast

class StepVisual_HArray1OfLayeredItem(NCollection_Array1_StepVisual_LayeredItem, Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_HArray1OfLayeredItem
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_HArray1OfLayeredItem(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_HArray1OfLayeredItem self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepVisual_HArray1OfLayeredItem
        __init__(StepVisual_HArray1OfLayeredItem self, Standard_Integer const theLower, Standard_Integer const theUpper, StepVisual_LayeredItem theValue) -> StepVisual_HArray1OfLayeredItem
        __init__(StepVisual_HArray1OfLayeredItem self, NCollection_Array1_StepVisual_LayeredItem theOther) -> StepVisual_HArray1OfLayeredItem

        :type theOther: OCC.wrapper.StepVisual.StepVisual_Array1OfLayeredItem

        """
        this = _StepVisual.new_StepVisual_HArray1OfLayeredItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfLayeredItem

        """
        res = _StepVisual.StepVisual_HArray1OfLayeredItem_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepVisual_HArray1OfLayeredItem self) -> NCollection_Array1_StepVisual_LayeredItem

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfLayeredItem

        """
        return _StepVisual.StepVisual_HArray1OfLayeredItem_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_HArray1OfLayeredItem_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_HArray1OfLayeredItem_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_HArray1OfLayeredItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_HArray1OfLayeredItem
StepVisual_HArray1OfLayeredItem_swigregister = _StepVisual.StepVisual_HArray1OfLayeredItem_swigregister
StepVisual_HArray1OfLayeredItem_swigregister(StepVisual_HArray1OfLayeredItem)

def StepVisual_HArray1OfLayeredItem_get_type_name(*args):
    """
    StepVisual_HArray1OfLayeredItem_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_HArray1OfLayeredItem_get_type_name(*args)

def StepVisual_HArray1OfLayeredItem_get_type_descriptor(*args):
    """
    StepVisual_HArray1OfLayeredItem_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_HArray1OfLayeredItem_get_type_descriptor(*args)

class Handle_StepVisual_FillAreaStyleColour(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_FillAreaStyleColour self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_FillAreaStyleColour_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_FillAreaStyleColour self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyleColour_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_FillAreaStyleColour self, StepVisual_FillAreaStyleColour thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyleColour_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_FillAreaStyleColour self, Handle_StepVisual_FillAreaStyleColour theHandle) -> Handle_StepVisual_FillAreaStyleColour
        assign(Handle_StepVisual_FillAreaStyleColour self, StepVisual_FillAreaStyleColour thePtr) -> Handle_StepVisual_FillAreaStyleColour
        assign(Handle_StepVisual_FillAreaStyleColour self, Handle_StepVisual_FillAreaStyleColour theHandle) -> Handle_StepVisual_FillAreaStyleColour

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyleColour_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_FillAreaStyleColour self) -> StepVisual_FillAreaStyleColour

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyleColour_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_FillAreaStyleColour self) -> StepVisual_FillAreaStyleColour

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyleColour___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_FillAreaStyleColour self) -> StepVisual_FillAreaStyleColour

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyleColour___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_FillAreaStyleColour___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_FillAreaStyleColour___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_FillAreaStyleColour(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_FillAreaStyleColour_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_FillAreaStyleColour

    def Init(self, *args):
        """
        Init(Handle_StepVisual_FillAreaStyleColour self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_Colour aFillColour)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFillColour: OCC.wrapper.StepVisual.Handle_StepVisual_Colour

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyleColour_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_FillAreaStyleColour self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyleColour_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_FillAreaStyleColour self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyleColour_Name(self, *args)


    def SetFillColour(self, *args):
        """
        SetFillColour(Handle_StepVisual_FillAreaStyleColour self, Handle_StepVisual_Colour aFillColour)

        :type aFillColour: OCC.wrapper.StepVisual.Handle_StepVisual_Colour

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyleColour_SetFillColour(self, *args)


    def FillColour(self, *args):
        """
        FillColour(Handle_StepVisual_FillAreaStyleColour self) -> Handle_StepVisual_Colour

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_Colour

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyleColour_FillColour(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_FillAreaStyleColour self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyleColour_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_FillAreaStyleColour_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_FillAreaStyleColour_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_FillAreaStyleColour self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_FillAreaStyleColour_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_FillAreaStyleColour self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_FillAreaStyleColour self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyleColour_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_FillAreaStyleColour self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_FillAreaStyleColour self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyleColour_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_FillAreaStyleColour self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyleColour_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_FillAreaStyleColour self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyleColour_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_FillAreaStyleColour self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_FillAreaStyleColour_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_FillAreaStyleColour self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyleColour_DecrementRefCounter(self, *args)

Handle_StepVisual_FillAreaStyleColour_swigregister = _StepVisual.Handle_StepVisual_FillAreaStyleColour_swigregister
Handle_StepVisual_FillAreaStyleColour_swigregister(Handle_StepVisual_FillAreaStyleColour)

def Handle_StepVisual_FillAreaStyleColour_DownCast(thing):
    return _StepVisual.Handle_StepVisual_FillAreaStyleColour_DownCast(thing)
Handle_StepVisual_FillAreaStyleColour_DownCast = _StepVisual.Handle_StepVisual_FillAreaStyleColour_DownCast

class StepVisual_InvisibilityContext(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepVisual_InvisibilityContext self) -> StepVisual_InvisibilityContext

        Returns a InvisibilityContext SelectType


        """
        this = _StepVisual.new_StepVisual_InvisibilityContext(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepVisual_InvisibilityContext self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a InvisibilityContext Kind Entity that is :
        1 -> PresentationRepresentation
        2 -> PresentationSet
        2 -> DraughtingModel
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_InvisibilityContext_CaseNum(self, *args)


    def PresentationRepresentation(self, *args):
        """
        PresentationRepresentation(StepVisual_InvisibilityContext self) -> Handle_StepVisual_PresentationRepresentation

        returns Value as a PresentationRepresentation (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationRepresentation

        """
        return _StepVisual.StepVisual_InvisibilityContext_PresentationRepresentation(self, *args)


    def PresentationSet(self, *args):
        """
        PresentationSet(StepVisual_InvisibilityContext self) -> Handle_StepVisual_PresentationSet

        returns Value as a PresentationSet (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationSet

        """
        return _StepVisual.StepVisual_InvisibilityContext_PresentationSet(self, *args)


    def DraughtingModel(self, *args):
        """
        DraughtingModel(StepVisual_InvisibilityContext self) -> Handle_StepVisual_DraughtingModel

        returns Value as a PresentationSet (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_DraughtingModel

        """
        return _StepVisual.StepVisual_InvisibilityContext_DraughtingModel(self, *args)

    __swig_destroy__ = _StepVisual.delete_StepVisual_InvisibilityContext
StepVisual_InvisibilityContext_swigregister = _StepVisual.StepVisual_InvisibilityContext_swigregister
StepVisual_InvisibilityContext_swigregister(StepVisual_InvisibilityContext)

class Handle_StepVisual_AnnotationTextOccurrence(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_AnnotationTextOccurrence self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_AnnotationTextOccurrence self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_AnnotationTextOccurrence self, StepVisual_AnnotationTextOccurrence thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_AnnotationTextOccurrence self, Handle_StepVisual_AnnotationTextOccurrence theHandle) -> Handle_StepVisual_AnnotationTextOccurrence
        assign(Handle_StepVisual_AnnotationTextOccurrence self, StepVisual_AnnotationTextOccurrence thePtr) -> Handle_StepVisual_AnnotationTextOccurrence
        assign(Handle_StepVisual_AnnotationTextOccurrence self, Handle_StepVisual_AnnotationTextOccurrence theHandle) -> Handle_StepVisual_AnnotationTextOccurrence

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_AnnotationTextOccurrence self) -> StepVisual_AnnotationTextOccurrence

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_AnnotationTextOccurrence self) -> StepVisual_AnnotationTextOccurrence

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_AnnotationTextOccurrence self) -> StepVisual_AnnotationTextOccurrence

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_AnnotationTextOccurrence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_AnnotationTextOccurrence_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_AnnotationTextOccurrence

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_AnnotationTextOccurrence self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_AnnotationTextOccurrence self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_HArray1OfPresentationStyleAssignment aStyles, Handle_Standard_Transient aItem)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment
        :type aItem: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_Init(self, *args)


    def SetStyles(self, *args):
        """
        SetStyles(Handle_StepVisual_AnnotationTextOccurrence self, Handle_StepVisual_HArray1OfPresentationStyleAssignment aStyles)

        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_SetStyles(self, *args)


    def Styles(self, *args):
        """
        Styles(Handle_StepVisual_AnnotationTextOccurrence self) -> Handle_StepVisual_HArray1OfPresentationStyleAssignment

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_Styles(self, *args)


    def StylesValue(self, *args):
        """
        StylesValue(Handle_StepVisual_AnnotationTextOccurrence self, Standard_Integer const num) -> Handle_StepVisual_PresentationStyleAssignment

        :type num: int
        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_StylesValue(self, *args)


    def NbStyles(self, *args):
        """
        NbStyles(Handle_StepVisual_AnnotationTextOccurrence self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_NbStyles(self, *args)


    def SetItem(self, *args):
        """
        SetItem(Handle_StepVisual_AnnotationTextOccurrence self, Handle_StepRepr_RepresentationItem aItem)
        SetItem(Handle_StepVisual_AnnotationTextOccurrence self, StepVisual_StyledItemTarget aItem)

        :type aItem: OCC.wrapper.StepVisual.StepVisual_StyledItemTarget

        """
        return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_SetItem(self, *args)


    def Item(self, *args):
        """
        Item(Handle_StepVisual_AnnotationTextOccurrence self) -> Handle_StepRepr_RepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_Item(self, *args)


    def ItemAP242(self, *args):
        """
        ItemAP242(Handle_StepVisual_AnnotationTextOccurrence self) -> StepVisual_StyledItemTarget

        :rtype: OCC.wrapper.StepVisual.StepVisual_StyledItemTarget

        """
        return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_ItemAP242(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_AnnotationTextOccurrence self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_AnnotationTextOccurrence self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_AnnotationTextOccurrence self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_AnnotationTextOccurrence self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_AnnotationTextOccurrence self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_AnnotationTextOccurrence self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_AnnotationTextOccurrence self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_AnnotationTextOccurrence self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_AnnotationTextOccurrence self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_AnnotationTextOccurrence self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_AnnotationTextOccurrence self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_DecrementRefCounter(self, *args)

Handle_StepVisual_AnnotationTextOccurrence_swigregister = _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_swigregister
Handle_StepVisual_AnnotationTextOccurrence_swigregister(Handle_StepVisual_AnnotationTextOccurrence)

def Handle_StepVisual_AnnotationTextOccurrence_DownCast(thing):
    return _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_DownCast(thing)
Handle_StepVisual_AnnotationTextOccurrence_DownCast = _StepVisual.Handle_StepVisual_AnnotationTextOccurrence_DownCast

class NCollection_Array1_StepVisual_PresentationStyleSelect(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_StepVisual_PresentationStyleSelect self) -> NCollection_Array1< StepVisual_PresentationStyleSelect >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_PresentationStyleSelect_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_StepVisual_PresentationStyleSelect self) -> NCollection_Array1< StepVisual_PresentationStyleSelect >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_PresentationStyleSelect_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_StepVisual_PresentationStyleSelect self) -> NCollection_Array1< StepVisual_PresentationStyleSelect >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_PresentationStyleSelect_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_StepVisual_PresentationStyleSelect self) -> NCollection_Array1< StepVisual_PresentationStyleSelect >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_PresentationStyleSelect_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepVisual.new_NCollection_Array1_StepVisual_PresentationStyleSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_StepVisual_PresentationStyleSelect self, StepVisual_PresentationStyleSelect theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_PresentationStyleSelect_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_StepVisual_PresentationStyleSelect self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_PresentationStyleSelect_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_StepVisual_PresentationStyleSelect self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_PresentationStyleSelect_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_StepVisual_PresentationStyleSelect self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_PresentationStyleSelect_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_StepVisual_PresentationStyleSelect self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_PresentationStyleSelect_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_StepVisual_PresentationStyleSelect self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_PresentationStyleSelect_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_StepVisual_PresentationStyleSelect self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_PresentationStyleSelect_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_StepVisual_PresentationStyleSelect self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_PresentationStyleSelect_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_StepVisual_PresentationStyleSelect self, NCollection_Array1_StepVisual_PresentationStyleSelect theOther) -> NCollection_Array1_StepVisual_PresentationStyleSelect

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_PresentationStyleSelect_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_StepVisual_PresentationStyleSelect self, NCollection_Array1_StepVisual_PresentationStyleSelect theOther) -> NCollection_Array1_StepVisual_PresentationStyleSelect

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_PresentationStyleSelect_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_StepVisual_PresentationStyleSelect self, NCollection_Array1_StepVisual_PresentationStyleSelect theOther) -> NCollection_Array1_StepVisual_PresentationStyleSelect
        assign(NCollection_Array1_StepVisual_PresentationStyleSelect self, NCollection_Array1_StepVisual_PresentationStyleSelect theOther) -> NCollection_Array1_StepVisual_PresentationStyleSelect

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_PresentationStyleSelect_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_PresentationStyleSelect_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_StepVisual_PresentationStyleSelect self) -> StepVisual_PresentationStyleSelect

        @return first element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_PresentationStyleSelect_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_PresentationStyleSelect_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_StepVisual_PresentationStyleSelect self) -> StepVisual_PresentationStyleSelect

        @return last element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_PresentationStyleSelect_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_PresentationStyleSelect_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_StepVisual_PresentationStyleSelect self, Standard_Integer const theIndex) -> StepVisual_PresentationStyleSelect

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_PresentationStyleSelect_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_PresentationStyleSelect___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_PresentationStyleSelect_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_StepVisual_PresentationStyleSelect self, Standard_Integer const theIndex, StepVisual_PresentationStyleSelect theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_PresentationStyleSelect_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_StepVisual_PresentationStyleSelect self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepVisual.NCollection_Array1_StepVisual_PresentationStyleSelect_Resize(self, *args)

    __swig_destroy__ = _StepVisual.delete_NCollection_Array1_StepVisual_PresentationStyleSelect
NCollection_Array1_StepVisual_PresentationStyleSelect_swigregister = _StepVisual.NCollection_Array1_StepVisual_PresentationStyleSelect_swigregister
NCollection_Array1_StepVisual_PresentationStyleSelect_swigregister(NCollection_Array1_StepVisual_PresentationStyleSelect)


try:
	StepVisual_Array1OfPresentationStyleSelect = NCollection_Array1_StepVisual_PresentationStyleSelect
except NameError:
	pass # does not exist, probably ignored

class Handle_StepVisual_DraughtingModel(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_DraughtingModel self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_DraughtingModel_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_DraughtingModel self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_DraughtingModel_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_DraughtingModel self, StepVisual_DraughtingModel thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_DraughtingModel_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_DraughtingModel self, Handle_StepVisual_DraughtingModel theHandle) -> Handle_StepVisual_DraughtingModel
        assign(Handle_StepVisual_DraughtingModel self, StepVisual_DraughtingModel thePtr) -> Handle_StepVisual_DraughtingModel
        assign(Handle_StepVisual_DraughtingModel self, Handle_StepVisual_DraughtingModel theHandle) -> Handle_StepVisual_DraughtingModel

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_DraughtingModel_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_DraughtingModel self) -> StepVisual_DraughtingModel

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_DraughtingModel_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_DraughtingModel self) -> StepVisual_DraughtingModel

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_DraughtingModel___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_DraughtingModel self) -> StepVisual_DraughtingModel

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_DraughtingModel___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_DraughtingModel___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_DraughtingModel___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_DraughtingModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_DraughtingModel_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_DraughtingModel

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_DraughtingModel self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_DraughtingModel_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_DraughtingModel_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_DraughtingModel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_DraughtingModel self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_HArray1OfRepresentationItem aItems, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepVisual.Handle_StepVisual_DraughtingModel_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_DraughtingModel self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_DraughtingModel_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_DraughtingModel self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_DraughtingModel_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepVisual_DraughtingModel self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepVisual.Handle_StepVisual_DraughtingModel_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepVisual_DraughtingModel self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepVisual.Handle_StepVisual_DraughtingModel_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepVisual_DraughtingModel self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_DraughtingModel_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepVisual_DraughtingModel self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_DraughtingModel_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepVisual_DraughtingModel self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepVisual.Handle_StepVisual_DraughtingModel_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepVisual_DraughtingModel self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepVisual.Handle_StepVisual_DraughtingModel_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_DraughtingModel self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_DraughtingModel_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_DraughtingModel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_DraughtingModel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_DraughtingModel_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_DraughtingModel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_DraughtingModel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_DraughtingModel_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_DraughtingModel self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_DraughtingModel_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_DraughtingModel self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_DraughtingModel_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_DraughtingModel self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_DraughtingModel_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_DraughtingModel self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_DraughtingModel_DecrementRefCounter(self, *args)

Handle_StepVisual_DraughtingModel_swigregister = _StepVisual.Handle_StepVisual_DraughtingModel_swigregister
Handle_StepVisual_DraughtingModel_swigregister(Handle_StepVisual_DraughtingModel)

def Handle_StepVisual_DraughtingModel_DownCast(thing):
    return _StepVisual.Handle_StepVisual_DraughtingModel_DownCast(thing)
Handle_StepVisual_DraughtingModel_DownCast = _StepVisual.Handle_StepVisual_DraughtingModel_DownCast

class Handle_StepVisual_HArray1OfFillStyleSelect(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_HArray1OfFillStyleSelect self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_HArray1OfFillStyleSelect self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_HArray1OfFillStyleSelect self, StepVisual_HArray1OfFillStyleSelect thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_HArray1OfFillStyleSelect self, Handle_StepVisual_HArray1OfFillStyleSelect theHandle) -> Handle_StepVisual_HArray1OfFillStyleSelect
        assign(Handle_StepVisual_HArray1OfFillStyleSelect self, StepVisual_HArray1OfFillStyleSelect thePtr) -> Handle_StepVisual_HArray1OfFillStyleSelect
        assign(Handle_StepVisual_HArray1OfFillStyleSelect self, Handle_StepVisual_HArray1OfFillStyleSelect theHandle) -> Handle_StepVisual_HArray1OfFillStyleSelect

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_HArray1OfFillStyleSelect self) -> StepVisual_HArray1OfFillStyleSelect

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_HArray1OfFillStyleSelect self) -> StepVisual_HArray1OfFillStyleSelect

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_HArray1OfFillStyleSelect self) -> StepVisual_HArray1OfFillStyleSelect

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_HArray1OfFillStyleSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_HArray1OfFillStyleSelect

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfFillStyleSelect

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepVisual_HArray1OfFillStyleSelect self) -> NCollection_Array1_StepVisual_FillStyleSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfFillStyleSelect

        """
        return _StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_HArray1OfFillStyleSelect self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_HArray1OfFillStyleSelect self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_HArray1OfFillStyleSelect self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_HArray1OfFillStyleSelect self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_HArray1OfFillStyleSelect self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_HArray1OfFillStyleSelect self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_HArray1OfFillStyleSelect self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_HArray1OfFillStyleSelect self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_HArray1OfFillStyleSelect self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_HArray1OfFillStyleSelect self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect_DecrementRefCounter(self, *args)

Handle_StepVisual_HArray1OfFillStyleSelect_swigregister = _StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect_swigregister
Handle_StepVisual_HArray1OfFillStyleSelect_swigregister(Handle_StepVisual_HArray1OfFillStyleSelect)

def Handle_StepVisual_HArray1OfFillStyleSelect_DownCast(thing):
    return _StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect_DownCast(thing)
Handle_StepVisual_HArray1OfFillStyleSelect_DownCast = _StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect_DownCast

class Handle_StepVisual_SurfaceStyleParameterLine(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_SurfaceStyleParameterLine self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_SurfaceStyleParameterLine self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_SurfaceStyleParameterLine self, StepVisual_SurfaceStyleParameterLine thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_SurfaceStyleParameterLine self, Handle_StepVisual_SurfaceStyleParameterLine theHandle) -> Handle_StepVisual_SurfaceStyleParameterLine
        assign(Handle_StepVisual_SurfaceStyleParameterLine self, StepVisual_SurfaceStyleParameterLine thePtr) -> Handle_StepVisual_SurfaceStyleParameterLine
        assign(Handle_StepVisual_SurfaceStyleParameterLine self, Handle_StepVisual_SurfaceStyleParameterLine theHandle) -> Handle_StepVisual_SurfaceStyleParameterLine

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_SurfaceStyleParameterLine self) -> StepVisual_SurfaceStyleParameterLine

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_SurfaceStyleParameterLine self) -> StepVisual_SurfaceStyleParameterLine

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_SurfaceStyleParameterLine self) -> StepVisual_SurfaceStyleParameterLine

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_SurfaceStyleParameterLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_SurfaceStyleParameterLine_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_SurfaceStyleParameterLine

    def Init(self, *args):
        """
        Init(Handle_StepVisual_SurfaceStyleParameterLine self, Handle_StepVisual_CurveStyle aStyleOfParameterLines, Handle_StepVisual_HArray1OfDirectionCountSelect aDirectionCounts)

        :type aStyleOfParameterLines: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle
        :type aDirectionCounts: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine_Init(self, *args)


    def SetStyleOfParameterLines(self, *args):
        """
        SetStyleOfParameterLines(Handle_StepVisual_SurfaceStyleParameterLine self, Handle_StepVisual_CurveStyle aStyleOfParameterLines)

        :type aStyleOfParameterLines: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine_SetStyleOfParameterLines(self, *args)


    def StyleOfParameterLines(self, *args):
        """
        StyleOfParameterLines(Handle_StepVisual_SurfaceStyleParameterLine self) -> Handle_StepVisual_CurveStyle

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine_StyleOfParameterLines(self, *args)


    def SetDirectionCounts(self, *args):
        """
        SetDirectionCounts(Handle_StepVisual_SurfaceStyleParameterLine self, Handle_StepVisual_HArray1OfDirectionCountSelect aDirectionCounts)

        :type aDirectionCounts: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine_SetDirectionCounts(self, *args)


    def DirectionCounts(self, *args):
        """
        DirectionCounts(Handle_StepVisual_SurfaceStyleParameterLine self) -> Handle_StepVisual_HArray1OfDirectionCountSelect

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfDirectionCountSelect

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine_DirectionCounts(self, *args)


    def DirectionCountsValue(self, *args):
        """
        DirectionCountsValue(Handle_StepVisual_SurfaceStyleParameterLine self, Standard_Integer const num) -> StepVisual_DirectionCountSelect

        :type num: int
        :rtype: OCC.wrapper.StepVisual.StepVisual_DirectionCountSelect

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine_DirectionCountsValue(self, *args)


    def NbDirectionCounts(self, *args):
        """
        NbDirectionCounts(Handle_StepVisual_SurfaceStyleParameterLine self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine_NbDirectionCounts(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_SurfaceStyleParameterLine self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_SurfaceStyleParameterLine self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_SurfaceStyleParameterLine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_SurfaceStyleParameterLine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_SurfaceStyleParameterLine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_SurfaceStyleParameterLine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_SurfaceStyleParameterLine self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_SurfaceStyleParameterLine self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_SurfaceStyleParameterLine self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_SurfaceStyleParameterLine self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine_DecrementRefCounter(self, *args)

Handle_StepVisual_SurfaceStyleParameterLine_swigregister = _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine_swigregister
Handle_StepVisual_SurfaceStyleParameterLine_swigregister(Handle_StepVisual_SurfaceStyleParameterLine)

def Handle_StepVisual_SurfaceStyleParameterLine_DownCast(thing):
    return _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine_DownCast(thing)
Handle_StepVisual_SurfaceStyleParameterLine_DownCast = _StepVisual.Handle_StepVisual_SurfaceStyleParameterLine_DownCast

class StepVisual_ExternallyDefinedCurveFont(StepBasic.StepBasic_ExternallyDefinedItem):
    """Representation of STEP entity ExternallyDefinedCurveFont"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_ExternallyDefinedCurveFont
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_ExternallyDefinedCurveFont(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_ExternallyDefinedCurveFont self) -> StepVisual_ExternallyDefinedCurveFont

        Empty constructor


        """
        this = _StepVisual.new_StepVisual_ExternallyDefinedCurveFont(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_ExternallyDefinedCurveFont_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_ExternallyDefinedCurveFont_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_ExternallyDefinedCurveFont_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_ExternallyDefinedCurveFont
StepVisual_ExternallyDefinedCurveFont_swigregister = _StepVisual.StepVisual_ExternallyDefinedCurveFont_swigregister
StepVisual_ExternallyDefinedCurveFont_swigregister(StepVisual_ExternallyDefinedCurveFont)

def StepVisual_ExternallyDefinedCurveFont_get_type_name(*args):
    """
    StepVisual_ExternallyDefinedCurveFont_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_ExternallyDefinedCurveFont_get_type_name(*args)

def StepVisual_ExternallyDefinedCurveFont_get_type_descriptor(*args):
    """
    StepVisual_ExternallyDefinedCurveFont_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_ExternallyDefinedCurveFont_get_type_descriptor(*args)

class Handle_StepVisual_SurfaceStyleUsage(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_SurfaceStyleUsage self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleUsage_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_SurfaceStyleUsage self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleUsage_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_SurfaceStyleUsage self, StepVisual_SurfaceStyleUsage thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleUsage_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_SurfaceStyleUsage self, Handle_StepVisual_SurfaceStyleUsage theHandle) -> Handle_StepVisual_SurfaceStyleUsage
        assign(Handle_StepVisual_SurfaceStyleUsage self, StepVisual_SurfaceStyleUsage thePtr) -> Handle_StepVisual_SurfaceStyleUsage
        assign(Handle_StepVisual_SurfaceStyleUsage self, Handle_StepVisual_SurfaceStyleUsage theHandle) -> Handle_StepVisual_SurfaceStyleUsage

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleUsage_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_SurfaceStyleUsage self) -> StepVisual_SurfaceStyleUsage

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleUsage_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_SurfaceStyleUsage self) -> StepVisual_SurfaceStyleUsage

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleUsage___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_SurfaceStyleUsage self) -> StepVisual_SurfaceStyleUsage

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleUsage___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_SurfaceStyleUsage___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_SurfaceStyleUsage___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_SurfaceStyleUsage(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_SurfaceStyleUsage_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_SurfaceStyleUsage

    def Init(self, *args):
        """
        Init(Handle_StepVisual_SurfaceStyleUsage self, StepVisual_SurfaceSide const aSide, Handle_StepVisual_SurfaceSideStyle aStyle)

        :type aSide: OCC.wrapper.StepVisual.StepVisual_SurfaceSide
        :type aStyle: OCC.wrapper.StepVisual.Handle_StepVisual_SurfaceSideStyle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleUsage_Init(self, *args)


    def SetSide(self, *args):
        """
        SetSide(Handle_StepVisual_SurfaceStyleUsage self, StepVisual_SurfaceSide const aSide)

        :type aSide: OCC.wrapper.StepVisual.StepVisual_SurfaceSide

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleUsage_SetSide(self, *args)


    def Side(self, *args):
        """
        Side(Handle_StepVisual_SurfaceStyleUsage self) -> StepVisual_SurfaceSide

        :rtype: OCC.wrapper.StepVisual.StepVisual_SurfaceSide

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleUsage_Side(self, *args)


    def SetStyle(self, *args):
        """
        SetStyle(Handle_StepVisual_SurfaceStyleUsage self, Handle_StepVisual_SurfaceSideStyle aStyle)

        :type aStyle: OCC.wrapper.StepVisual.Handle_StepVisual_SurfaceSideStyle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleUsage_SetStyle(self, *args)


    def Style(self, *args):
        """
        Style(Handle_StepVisual_SurfaceStyleUsage self) -> Handle_StepVisual_SurfaceSideStyle

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_SurfaceSideStyle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleUsage_Style(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_SurfaceStyleUsage self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleUsage_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_SurfaceStyleUsage_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_SurfaceStyleUsage_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_SurfaceStyleUsage self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleUsage_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_SurfaceStyleUsage self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_SurfaceStyleUsage self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleUsage_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_SurfaceStyleUsage self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_SurfaceStyleUsage self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleUsage_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_SurfaceStyleUsage self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleUsage_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_SurfaceStyleUsage self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleUsage_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_SurfaceStyleUsage self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleUsage_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_SurfaceStyleUsage self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleUsage_DecrementRefCounter(self, *args)

Handle_StepVisual_SurfaceStyleUsage_swigregister = _StepVisual.Handle_StepVisual_SurfaceStyleUsage_swigregister
Handle_StepVisual_SurfaceStyleUsage_swigregister(Handle_StepVisual_SurfaceStyleUsage)

def Handle_StepVisual_SurfaceStyleUsage_DownCast(thing):
    return _StepVisual.Handle_StepVisual_SurfaceStyleUsage_DownCast(thing)
Handle_StepVisual_SurfaceStyleUsage_DownCast = _StepVisual.Handle_StepVisual_SurfaceStyleUsage_DownCast

class Handle_StepVisual_Template(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_Template self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_Template_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_Template self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_Template_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_Template self, StepVisual_Template thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_Template_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_Template self, Handle_StepVisual_Template theHandle) -> Handle_StepVisual_Template
        assign(Handle_StepVisual_Template self, StepVisual_Template thePtr) -> Handle_StepVisual_Template
        assign(Handle_StepVisual_Template self, Handle_StepVisual_Template theHandle) -> Handle_StepVisual_Template

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_Template_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_Template self) -> StepVisual_Template

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_Template_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_Template self) -> StepVisual_Template

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_Template___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_Template self) -> StepVisual_Template

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_Template___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_Template___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_Template___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_Template(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_Template_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_Template

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_Template self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_Template_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_Template_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_Template_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_Template self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_HArray1OfRepresentationItem aItems, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepVisual.Handle_StepVisual_Template_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_Template self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_Template_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_Template self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_Template_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepVisual_Template self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepVisual.Handle_StepVisual_Template_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepVisual_Template self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepVisual.Handle_StepVisual_Template_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepVisual_Template self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_Template_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepVisual_Template self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_Template_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepVisual_Template self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepVisual.Handle_StepVisual_Template_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepVisual_Template self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepVisual.Handle_StepVisual_Template_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_Template self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_Template_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_Template self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_Template self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_Template_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_Template self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_Template self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_Template_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_Template self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_Template_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_Template self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_Template_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_Template self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_Template_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_Template self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_Template_DecrementRefCounter(self, *args)

Handle_StepVisual_Template_swigregister = _StepVisual.Handle_StepVisual_Template_swigregister
Handle_StepVisual_Template_swigregister(Handle_StepVisual_Template)

def Handle_StepVisual_Template_DownCast(thing):
    return _StepVisual.Handle_StepVisual_Template_DownCast(thing)
Handle_StepVisual_Template_DownCast = _StepVisual.Handle_StepVisual_Template_DownCast

class Handle_StepVisual_HArray1OfDraughtingCalloutElement(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_HArray1OfDraughtingCalloutElement self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_HArray1OfDraughtingCalloutElement self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_HArray1OfDraughtingCalloutElement self, StepVisual_HArray1OfDraughtingCalloutElement thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_HArray1OfDraughtingCalloutElement self, Handle_StepVisual_HArray1OfDraughtingCalloutElement theHandle) -> Handle_StepVisual_HArray1OfDraughtingCalloutElement
        assign(Handle_StepVisual_HArray1OfDraughtingCalloutElement self, StepVisual_HArray1OfDraughtingCalloutElement thePtr) -> Handle_StepVisual_HArray1OfDraughtingCalloutElement
        assign(Handle_StepVisual_HArray1OfDraughtingCalloutElement self, Handle_StepVisual_HArray1OfDraughtingCalloutElement theHandle) -> Handle_StepVisual_HArray1OfDraughtingCalloutElement

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_HArray1OfDraughtingCalloutElement self) -> StepVisual_HArray1OfDraughtingCalloutElement

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_HArray1OfDraughtingCalloutElement self) -> StepVisual_HArray1OfDraughtingCalloutElement

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_HArray1OfDraughtingCalloutElement self) -> StepVisual_HArray1OfDraughtingCalloutElement

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_HArray1OfDraughtingCalloutElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_HArray1OfDraughtingCalloutElement

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfDraughtingCalloutElement

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepVisual_HArray1OfDraughtingCalloutElement self) -> NCollection_Array1_StepVisual_DraughtingCalloutElement

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfDraughtingCalloutElement

        """
        return _StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_HArray1OfDraughtingCalloutElement self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_HArray1OfDraughtingCalloutElement self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_HArray1OfDraughtingCalloutElement self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_HArray1OfDraughtingCalloutElement self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_HArray1OfDraughtingCalloutElement self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_HArray1OfDraughtingCalloutElement self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_HArray1OfDraughtingCalloutElement self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_HArray1OfDraughtingCalloutElement self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_HArray1OfDraughtingCalloutElement self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_HArray1OfDraughtingCalloutElement self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement_DecrementRefCounter(self, *args)

Handle_StepVisual_HArray1OfDraughtingCalloutElement_swigregister = _StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement_swigregister
Handle_StepVisual_HArray1OfDraughtingCalloutElement_swigregister(Handle_StepVisual_HArray1OfDraughtingCalloutElement)

def Handle_StepVisual_HArray1OfDraughtingCalloutElement_DownCast(thing):
    return _StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement_DownCast(thing)
Handle_StepVisual_HArray1OfDraughtingCalloutElement_DownCast = _StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement_DownCast

class Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect self, StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect self, Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect theHandle) -> Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect
        assign(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect self, StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect thePtr) -> Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect
        assign(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect self, Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect theHandle) -> Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect self) -> StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect self) -> StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect self) -> StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfCameraModelD3MultiClippingInterectionSelect

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect self) -> NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfCameraModelD3MultiClippingInterectionSelect

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_DecrementRefCounter(self, *args)

Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_swigregister = _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_swigregister
Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_swigregister(Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect)

def Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_DownCast(thing):
    return _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_DownCast(thing)
Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_DownCast = _StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect_DownCast

class NCollection_Handle_StepVisual_Array1OfTessellatedItem(Standard.Handle_Standard_Transient):
    """
    Purpose: This template class is used to define Handle adaptor
    for allocated dynamically objects of arbitrary type.

    The advantage is that this handle will automatically destroy 
    the object when last referred Handle is destroyed (i.e. it is a 
    typical smart pointer), and that it can be handled as 
    Handle(Standard_Transient) in OCCT components.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Purpose: This template class is used to define Handle adaptor
        for allocated dynamically objects of arbitrary type.

        The advantage is that this handle will automatically destroy 
        the object when last referred Handle is destroyed (i.e. it is a 
        typical smart pointer), and that it can be handled as 
        Handle(Standard_Transient) in OCCT components.
        """
        this = _StepVisual.new_NCollection_Handle_StepVisual_Array1OfTessellatedItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get(self, *args):
        """
        get(NCollection_Handle_StepVisual_Array1OfTessellatedItem self) -> NCollection_Array1_Handle_StepVisual_TessellatedItem
        get(NCollection_Handle_StepVisual_Array1OfTessellatedItem self) -> NCollection_Array1_Handle_StepVisual_TessellatedItem

        Cast handle to contained type

        :rtype: const T *

        """
        return _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(NCollection_Handle_StepVisual_Array1OfTessellatedItem self) -> NCollection_Array1_Handle_StepVisual_TessellatedItem
        __deref__(NCollection_Handle_StepVisual_Array1OfTessellatedItem self) -> NCollection_Array1_Handle_StepVisual_TessellatedItem

        Cast handle to contained type

        :rtype: const T *

        """
        return _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem___deref__(self, *args)


    def __ref__(self, *args):
        """
        Cast handle to contained type

        :rtype: const T &

        """
        res = _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem___ref__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DownCast(*args):
        """
        DownCast(Handle_Standard_Transient theOther) -> NCollection_Handle_StepVisual_Array1OfTessellatedItem

        Downcast arbitrary Handle to the argument type if contained
        object is Handle for this type; returns null otherwise

        :type theOther: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.NCollection.NCollection_Handle_T

        """
        return _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_DownCast(*args)

    DownCast = staticmethod(DownCast)
    __swig_destroy__ = _StepVisual.delete_NCollection_Handle_StepVisual_Array1OfTessellatedItem

    def begin(self, *args):
        """
        begin(NCollection_Handle_StepVisual_Array1OfTessellatedItem self) -> NCollection_Array1< opencascade::handle< StepVisual_TessellatedItem > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Handle_StepVisual_Array1OfTessellatedItem self) -> NCollection_Array1< opencascade::handle< StepVisual_TessellatedItem > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Handle_StepVisual_Array1OfTessellatedItem self) -> NCollection_Array1< opencascade::handle< StepVisual_TessellatedItem > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Handle_StepVisual_Array1OfTessellatedItem self) -> NCollection_Array1< opencascade::handle< StepVisual_TessellatedItem > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_cend(self, *args)


    def Init(self, *args):
        """
        Init(NCollection_Handle_StepVisual_Array1OfTessellatedItem self, Handle_StepVisual_TessellatedItem theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Handle_StepVisual_Array1OfTessellatedItem self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Handle_StepVisual_Array1OfTessellatedItem self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Handle_StepVisual_Array1OfTessellatedItem self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Handle_StepVisual_Array1OfTessellatedItem self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Handle_StepVisual_Array1OfTessellatedItem self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Handle_StepVisual_Array1OfTessellatedItem self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Handle_StepVisual_Array1OfTessellatedItem self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Handle_StepVisual_Array1OfTessellatedItem self, NCollection_Array1_Handle_StepVisual_TessellatedItem theOther) -> NCollection_Array1_Handle_StepVisual_TessellatedItem

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Handle_StepVisual_Array1OfTessellatedItem self, NCollection_Array1_Handle_StepVisual_TessellatedItem theOther) -> NCollection_Array1_Handle_StepVisual_TessellatedItem

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_Move(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Handle_StepVisual_Array1OfTessellatedItem self) -> Handle_StepVisual_TessellatedItem

        @return first element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Handle_StepVisual_Array1OfTessellatedItem self) -> Handle_StepVisual_TessellatedItem

        @return last element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Handle_StepVisual_Array1OfTessellatedItem self, Standard_Integer const theIndex) -> Handle_StepVisual_TessellatedItem

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Handle_StepVisual_Array1OfTessellatedItem self, Standard_Integer const theIndex, Handle_StepVisual_TessellatedItem theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Handle_StepVisual_Array1OfTessellatedItem self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_Resize(self, *args)

NCollection_Handle_StepVisual_Array1OfTessellatedItem_swigregister = _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_swigregister
NCollection_Handle_StepVisual_Array1OfTessellatedItem_swigregister(NCollection_Handle_StepVisual_Array1OfTessellatedItem)

def NCollection_Handle_StepVisual_Array1OfTessellatedItem_DownCast(*args):
    """
    NCollection_Handle_StepVisual_Array1OfTessellatedItem_DownCast(Handle_Standard_Transient theOther) -> NCollection_Handle_StepVisual_Array1OfTessellatedItem

    Downcast arbitrary Handle to the argument type if contained
    object is Handle for this type; returns null otherwise

    :type theOther: OCC.wrapper.Standard.Handle_Standard_Transient
    :rtype: OCC.wrapper.NCollection.NCollection_Handle_T

    """
    return _StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem_DownCast(*args)

class Handle_StepVisual_PresentationStyleAssignment(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_PresentationStyleAssignment self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_PresentationStyleAssignment_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_PresentationStyleAssignment self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleAssignment_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_PresentationStyleAssignment self, StepVisual_PresentationStyleAssignment thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleAssignment_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_PresentationStyleAssignment self, Handle_StepVisual_PresentationStyleAssignment theHandle) -> Handle_StepVisual_PresentationStyleAssignment
        assign(Handle_StepVisual_PresentationStyleAssignment self, StepVisual_PresentationStyleAssignment thePtr) -> Handle_StepVisual_PresentationStyleAssignment
        assign(Handle_StepVisual_PresentationStyleAssignment self, Handle_StepVisual_PresentationStyleAssignment theHandle) -> Handle_StepVisual_PresentationStyleAssignment

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleAssignment_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_PresentationStyleAssignment self) -> StepVisual_PresentationStyleAssignment

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleAssignment_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_PresentationStyleAssignment self) -> StepVisual_PresentationStyleAssignment

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleAssignment___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_PresentationStyleAssignment self) -> StepVisual_PresentationStyleAssignment

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleAssignment___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_PresentationStyleAssignment___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_PresentationStyleAssignment___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_PresentationStyleAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_PresentationStyleAssignment_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_PresentationStyleAssignment

    def Init(self, *args):
        """
        Init(Handle_StepVisual_PresentationStyleAssignment self, Handle_StepVisual_HArray1OfPresentationStyleSelect aStyles)

        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleAssignment_Init(self, *args)


    def SetStyles(self, *args):
        """
        SetStyles(Handle_StepVisual_PresentationStyleAssignment self, Handle_StepVisual_HArray1OfPresentationStyleSelect aStyles)

        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleAssignment_SetStyles(self, *args)


    def Styles(self, *args):
        """
        Styles(Handle_StepVisual_PresentationStyleAssignment self) -> Handle_StepVisual_HArray1OfPresentationStyleSelect

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleAssignment_Styles(self, *args)


    def StylesValue(self, *args):
        """
        StylesValue(Handle_StepVisual_PresentationStyleAssignment self, Standard_Integer const num) -> StepVisual_PresentationStyleSelect

        :type num: int
        :rtype: OCC.wrapper.StepVisual.StepVisual_PresentationStyleSelect

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleAssignment_StylesValue(self, *args)


    def NbStyles(self, *args):
        """
        NbStyles(Handle_StepVisual_PresentationStyleAssignment self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleAssignment_NbStyles(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_PresentationStyleAssignment self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleAssignment_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PresentationStyleAssignment_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PresentationStyleAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_PresentationStyleAssignment self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_PresentationStyleAssignment_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_PresentationStyleAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_PresentationStyleAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleAssignment_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_PresentationStyleAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_PresentationStyleAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleAssignment_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_PresentationStyleAssignment self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleAssignment_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_PresentationStyleAssignment self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleAssignment_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_PresentationStyleAssignment self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_PresentationStyleAssignment_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_PresentationStyleAssignment self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleAssignment_DecrementRefCounter(self, *args)

Handle_StepVisual_PresentationStyleAssignment_swigregister = _StepVisual.Handle_StepVisual_PresentationStyleAssignment_swigregister
Handle_StepVisual_PresentationStyleAssignment_swigregister(Handle_StepVisual_PresentationStyleAssignment)

def Handle_StepVisual_PresentationStyleAssignment_DownCast(thing):
    return _StepVisual.Handle_StepVisual_PresentationStyleAssignment_DownCast(thing)
Handle_StepVisual_PresentationStyleAssignment_DownCast = _StepVisual.Handle_StepVisual_PresentationStyleAssignment_DownCast

class Handle_StepVisual_AreaInSet(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_AreaInSet self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_AreaInSet_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_AreaInSet self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_AreaInSet_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_AreaInSet self, StepVisual_AreaInSet thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_AreaInSet_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_AreaInSet self, Handle_StepVisual_AreaInSet theHandle) -> Handle_StepVisual_AreaInSet
        assign(Handle_StepVisual_AreaInSet self, StepVisual_AreaInSet thePtr) -> Handle_StepVisual_AreaInSet
        assign(Handle_StepVisual_AreaInSet self, Handle_StepVisual_AreaInSet theHandle) -> Handle_StepVisual_AreaInSet

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_AreaInSet_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_AreaInSet self) -> StepVisual_AreaInSet

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_AreaInSet_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_AreaInSet self) -> StepVisual_AreaInSet

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_AreaInSet___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_AreaInSet self) -> StepVisual_AreaInSet

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_AreaInSet___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_AreaInSet___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_AreaInSet___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_AreaInSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_AreaInSet_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_AreaInSet

    def Init(self, *args):
        """
        Init(Handle_StepVisual_AreaInSet self, Handle_StepVisual_PresentationArea aArea, Handle_StepVisual_PresentationSet aInSet)

        :type aArea: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationArea
        :type aInSet: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationSet

        """
        return _StepVisual.Handle_StepVisual_AreaInSet_Init(self, *args)


    def SetArea(self, *args):
        """
        SetArea(Handle_StepVisual_AreaInSet self, Handle_StepVisual_PresentationArea aArea)

        :type aArea: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationArea

        """
        return _StepVisual.Handle_StepVisual_AreaInSet_SetArea(self, *args)


    def Area(self, *args):
        """
        Area(Handle_StepVisual_AreaInSet self) -> Handle_StepVisual_PresentationArea

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationArea

        """
        return _StepVisual.Handle_StepVisual_AreaInSet_Area(self, *args)


    def SetInSet(self, *args):
        """
        SetInSet(Handle_StepVisual_AreaInSet self, Handle_StepVisual_PresentationSet aInSet)

        :type aInSet: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationSet

        """
        return _StepVisual.Handle_StepVisual_AreaInSet_SetInSet(self, *args)


    def InSet(self, *args):
        """
        InSet(Handle_StepVisual_AreaInSet self) -> Handle_StepVisual_PresentationSet

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationSet

        """
        return _StepVisual.Handle_StepVisual_AreaInSet_InSet(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_AreaInSet self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_AreaInSet_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_AreaInSet_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_AreaInSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_AreaInSet self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_AreaInSet_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_AreaInSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_AreaInSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_AreaInSet_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_AreaInSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_AreaInSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_AreaInSet_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_AreaInSet self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_AreaInSet_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_AreaInSet self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_AreaInSet_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_AreaInSet self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_AreaInSet_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_AreaInSet self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_AreaInSet_DecrementRefCounter(self, *args)

Handle_StepVisual_AreaInSet_swigregister = _StepVisual.Handle_StepVisual_AreaInSet_swigregister
Handle_StepVisual_AreaInSet_swigregister(Handle_StepVisual_AreaInSet)

def Handle_StepVisual_AreaInSet_DownCast(thing):
    return _StepVisual.Handle_StepVisual_AreaInSet_DownCast(thing)
Handle_StepVisual_AreaInSet_DownCast = _StepVisual.Handle_StepVisual_AreaInSet_DownCast

class Handle_StepVisual_PreDefinedTextFont(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_PreDefinedTextFont self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_PreDefinedTextFont_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_PreDefinedTextFont self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_PreDefinedTextFont_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_PreDefinedTextFont self, StepVisual_PreDefinedTextFont thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_PreDefinedTextFont_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_PreDefinedTextFont self, Handle_StepVisual_PreDefinedTextFont theHandle) -> Handle_StepVisual_PreDefinedTextFont
        assign(Handle_StepVisual_PreDefinedTextFont self, StepVisual_PreDefinedTextFont thePtr) -> Handle_StepVisual_PreDefinedTextFont
        assign(Handle_StepVisual_PreDefinedTextFont self, Handle_StepVisual_PreDefinedTextFont theHandle) -> Handle_StepVisual_PreDefinedTextFont

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_PreDefinedTextFont_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_PreDefinedTextFont self) -> StepVisual_PreDefinedTextFont

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PreDefinedTextFont_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_PreDefinedTextFont self) -> StepVisual_PreDefinedTextFont

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PreDefinedTextFont___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_PreDefinedTextFont self) -> StepVisual_PreDefinedTextFont

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_PreDefinedTextFont___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_PreDefinedTextFont___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_PreDefinedTextFont___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_PreDefinedTextFont(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_PreDefinedTextFont_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_PreDefinedTextFont

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_PreDefinedTextFont self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_PreDefinedTextFont_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PreDefinedTextFont_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PreDefinedTextFont_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_PreDefinedTextFont self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_PreDefinedTextFont_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_PreDefinedTextFont self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_PreDefinedTextFont_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_PreDefinedTextFont self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_PreDefinedTextFont_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_PreDefinedTextFont self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_PreDefinedTextFont_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_PreDefinedTextFont self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_PreDefinedTextFont self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PreDefinedTextFont_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_PreDefinedTextFont self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_PreDefinedTextFont self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PreDefinedTextFont_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_PreDefinedTextFont self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_PreDefinedTextFont_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_PreDefinedTextFont self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PreDefinedTextFont_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_PreDefinedTextFont self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_PreDefinedTextFont_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_PreDefinedTextFont self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PreDefinedTextFont_DecrementRefCounter(self, *args)

Handle_StepVisual_PreDefinedTextFont_swigregister = _StepVisual.Handle_StepVisual_PreDefinedTextFont_swigregister
Handle_StepVisual_PreDefinedTextFont_swigregister(Handle_StepVisual_PreDefinedTextFont)

def Handle_StepVisual_PreDefinedTextFont_DownCast(thing):
    return _StepVisual.Handle_StepVisual_PreDefinedTextFont_DownCast(thing)
Handle_StepVisual_PreDefinedTextFont_DownCast = _StepVisual.Handle_StepVisual_PreDefinedTextFont_DownCast

class Handle_StepVisual_CameraImage2dWithScale(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_CameraImage2dWithScale self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_CameraImage2dWithScale_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_CameraImage2dWithScale self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_CameraImage2dWithScale_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_CameraImage2dWithScale self, StepVisual_CameraImage2dWithScale thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_CameraImage2dWithScale_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_CameraImage2dWithScale self, Handle_StepVisual_CameraImage2dWithScale theHandle) -> Handle_StepVisual_CameraImage2dWithScale
        assign(Handle_StepVisual_CameraImage2dWithScale self, StepVisual_CameraImage2dWithScale thePtr) -> Handle_StepVisual_CameraImage2dWithScale
        assign(Handle_StepVisual_CameraImage2dWithScale self, Handle_StepVisual_CameraImage2dWithScale theHandle) -> Handle_StepVisual_CameraImage2dWithScale

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_CameraImage2dWithScale_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_CameraImage2dWithScale self) -> StepVisual_CameraImage2dWithScale

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CameraImage2dWithScale_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_CameraImage2dWithScale self) -> StepVisual_CameraImage2dWithScale

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CameraImage2dWithScale___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_CameraImage2dWithScale self) -> StepVisual_CameraImage2dWithScale

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_CameraImage2dWithScale___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_CameraImage2dWithScale___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_CameraImage2dWithScale___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_CameraImage2dWithScale(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_CameraImage2dWithScale_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_CameraImage2dWithScale

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_CameraImage2dWithScale self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_CameraImage2dWithScale_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CameraImage2dWithScale_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CameraImage2dWithScale_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_CameraImage2dWithScale self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_RepresentationMap aMappingSource, Handle_StepRepr_RepresentationItem aMappingTarget)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aMappingSource: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationMap
        :type aMappingTarget: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_CameraImage2dWithScale_Init(self, *args)


    def SetMappingSource(self, *args):
        """
        SetMappingSource(Handle_StepVisual_CameraImage2dWithScale self, Handle_StepRepr_RepresentationMap aMappingSource)

        :type aMappingSource: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationMap

        """
        return _StepVisual.Handle_StepVisual_CameraImage2dWithScale_SetMappingSource(self, *args)


    def MappingSource(self, *args):
        """
        MappingSource(Handle_StepVisual_CameraImage2dWithScale self) -> Handle_StepRepr_RepresentationMap

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationMap

        """
        return _StepVisual.Handle_StepVisual_CameraImage2dWithScale_MappingSource(self, *args)


    def SetMappingTarget(self, *args):
        """
        SetMappingTarget(Handle_StepVisual_CameraImage2dWithScale self, Handle_StepRepr_RepresentationItem aMappingTarget)

        :type aMappingTarget: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_CameraImage2dWithScale_SetMappingTarget(self, *args)


    def MappingTarget(self, *args):
        """
        MappingTarget(Handle_StepVisual_CameraImage2dWithScale self) -> Handle_StepRepr_RepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_CameraImage2dWithScale_MappingTarget(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_CameraImage2dWithScale self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CameraImage2dWithScale_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_CameraImage2dWithScale self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CameraImage2dWithScale_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_CameraImage2dWithScale self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_CameraImage2dWithScale_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_CameraImage2dWithScale self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_CameraImage2dWithScale self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CameraImage2dWithScale_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_CameraImage2dWithScale self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_CameraImage2dWithScale self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CameraImage2dWithScale_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_CameraImage2dWithScale self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_CameraImage2dWithScale_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_CameraImage2dWithScale self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CameraImage2dWithScale_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_CameraImage2dWithScale self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_CameraImage2dWithScale_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_CameraImage2dWithScale self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CameraImage2dWithScale_DecrementRefCounter(self, *args)

Handle_StepVisual_CameraImage2dWithScale_swigregister = _StepVisual.Handle_StepVisual_CameraImage2dWithScale_swigregister
Handle_StepVisual_CameraImage2dWithScale_swigregister(Handle_StepVisual_CameraImage2dWithScale)

def Handle_StepVisual_CameraImage2dWithScale_DownCast(thing):
    return _StepVisual.Handle_StepVisual_CameraImage2dWithScale_DownCast(thing)
Handle_StepVisual_CameraImage2dWithScale_DownCast = _StepVisual.Handle_StepVisual_CameraImage2dWithScale_DownCast

class Handle_StepVisual_ColourSpecification(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_ColourSpecification self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_ColourSpecification_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_ColourSpecification self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_ColourSpecification_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_ColourSpecification self, StepVisual_ColourSpecification thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_ColourSpecification_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_ColourSpecification self, Handle_StepVisual_ColourSpecification theHandle) -> Handle_StepVisual_ColourSpecification
        assign(Handle_StepVisual_ColourSpecification self, StepVisual_ColourSpecification thePtr) -> Handle_StepVisual_ColourSpecification
        assign(Handle_StepVisual_ColourSpecification self, Handle_StepVisual_ColourSpecification theHandle) -> Handle_StepVisual_ColourSpecification

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_ColourSpecification_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_ColourSpecification self) -> StepVisual_ColourSpecification

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_ColourSpecification_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_ColourSpecification self) -> StepVisual_ColourSpecification

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_ColourSpecification___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_ColourSpecification self) -> StepVisual_ColourSpecification

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_ColourSpecification___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_ColourSpecification___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_ColourSpecification___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_ColourSpecification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_ColourSpecification_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_ColourSpecification

    def Init(self, *args):
        """
        Init(Handle_StepVisual_ColourSpecification self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_ColourSpecification_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_ColourSpecification self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_ColourSpecification_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_ColourSpecification self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_ColourSpecification_Name(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_ColourSpecification self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_ColourSpecification_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_ColourSpecification_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_ColourSpecification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_ColourSpecification self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_ColourSpecification_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_ColourSpecification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_ColourSpecification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_ColourSpecification_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_ColourSpecification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_ColourSpecification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_ColourSpecification_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_ColourSpecification self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_ColourSpecification_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_ColourSpecification self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_ColourSpecification_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_ColourSpecification self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_ColourSpecification_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_ColourSpecification self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_ColourSpecification_DecrementRefCounter(self, *args)

Handle_StepVisual_ColourSpecification_swigregister = _StepVisual.Handle_StepVisual_ColourSpecification_swigregister
Handle_StepVisual_ColourSpecification_swigregister(Handle_StepVisual_ColourSpecification)

def Handle_StepVisual_ColourSpecification_DownCast(thing):
    return _StepVisual.Handle_StepVisual_ColourSpecification_DownCast(thing)
Handle_StepVisual_ColourSpecification_DownCast = _StepVisual.Handle_StepVisual_ColourSpecification_DownCast

class StepVisual_CurveStyleFontSelect(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepVisual_CurveStyleFontSelect self) -> StepVisual_CurveStyleFontSelect

        Returns a CurveStyleFontSelect SelectType


        """
        this = _StepVisual.new_StepVisual_CurveStyleFontSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepVisual_CurveStyleFontSelect self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a CurveStyleFontSelect Kind Entity that is :
        1 -> CurveStyleFont
        2 -> PreDefinedCurveFont
        3 -> ExternallyDefinedCurveFont
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_CurveStyleFontSelect_CaseNum(self, *args)


    def CurveStyleFont(self, *args):
        """
        CurveStyleFont(StepVisual_CurveStyleFontSelect self) -> Handle_StepVisual_CurveStyleFont

        returns Value as a CurveStyleFont (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyleFont

        """
        return _StepVisual.StepVisual_CurveStyleFontSelect_CurveStyleFont(self, *args)


    def PreDefinedCurveFont(self, *args):
        """
        PreDefinedCurveFont(StepVisual_CurveStyleFontSelect self) -> Handle_StepVisual_PreDefinedCurveFont

        returns Value as a PreDefinedCurveFont (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PreDefinedCurveFont

        """
        return _StepVisual.StepVisual_CurveStyleFontSelect_PreDefinedCurveFont(self, *args)


    def ExternallyDefinedCurveFont(self, *args):
        """
        ExternallyDefinedCurveFont(StepVisual_CurveStyleFontSelect self) -> Handle_StepVisual_ExternallyDefinedCurveFont

        returns Value as a ExternallyDefinedCurveFont (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont

        """
        return _StepVisual.StepVisual_CurveStyleFontSelect_ExternallyDefinedCurveFont(self, *args)

    __swig_destroy__ = _StepVisual.delete_StepVisual_CurveStyleFontSelect
StepVisual_CurveStyleFontSelect_swigregister = _StepVisual.StepVisual_CurveStyleFontSelect_swigregister
StepVisual_CurveStyleFontSelect_swigregister(StepVisual_CurveStyleFontSelect)

class Handle_StepVisual_AnnotationOccurrence(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_AnnotationOccurrence self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_AnnotationOccurrence_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_AnnotationOccurrence self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_AnnotationOccurrence_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_AnnotationOccurrence self, StepVisual_AnnotationOccurrence thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_AnnotationOccurrence_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_AnnotationOccurrence self, Handle_StepVisual_AnnotationOccurrence theHandle) -> Handle_StepVisual_AnnotationOccurrence
        assign(Handle_StepVisual_AnnotationOccurrence self, StepVisual_AnnotationOccurrence thePtr) -> Handle_StepVisual_AnnotationOccurrence
        assign(Handle_StepVisual_AnnotationOccurrence self, Handle_StepVisual_AnnotationOccurrence theHandle) -> Handle_StepVisual_AnnotationOccurrence

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_AnnotationOccurrence_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_AnnotationOccurrence self) -> StepVisual_AnnotationOccurrence

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_AnnotationOccurrence_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_AnnotationOccurrence self) -> StepVisual_AnnotationOccurrence

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_AnnotationOccurrence___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_AnnotationOccurrence self) -> StepVisual_AnnotationOccurrence

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_AnnotationOccurrence___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_AnnotationOccurrence___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_AnnotationOccurrence___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_AnnotationOccurrence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_AnnotationOccurrence_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_AnnotationOccurrence

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_AnnotationOccurrence self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_AnnotationOccurrence_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_AnnotationOccurrence_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_AnnotationOccurrence_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_AnnotationOccurrence self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_HArray1OfPresentationStyleAssignment aStyles, Handle_Standard_Transient aItem)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment
        :type aItem: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_AnnotationOccurrence_Init(self, *args)


    def SetStyles(self, *args):
        """
        SetStyles(Handle_StepVisual_AnnotationOccurrence self, Handle_StepVisual_HArray1OfPresentationStyleAssignment aStyles)

        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_AnnotationOccurrence_SetStyles(self, *args)


    def Styles(self, *args):
        """
        Styles(Handle_StepVisual_AnnotationOccurrence self) -> Handle_StepVisual_HArray1OfPresentationStyleAssignment

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_AnnotationOccurrence_Styles(self, *args)


    def StylesValue(self, *args):
        """
        StylesValue(Handle_StepVisual_AnnotationOccurrence self, Standard_Integer const num) -> Handle_StepVisual_PresentationStyleAssignment

        :type num: int
        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_AnnotationOccurrence_StylesValue(self, *args)


    def NbStyles(self, *args):
        """
        NbStyles(Handle_StepVisual_AnnotationOccurrence self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_AnnotationOccurrence_NbStyles(self, *args)


    def SetItem(self, *args):
        """
        SetItem(Handle_StepVisual_AnnotationOccurrence self, Handle_StepRepr_RepresentationItem aItem)
        SetItem(Handle_StepVisual_AnnotationOccurrence self, StepVisual_StyledItemTarget aItem)

        :type aItem: OCC.wrapper.StepVisual.StepVisual_StyledItemTarget

        """
        return _StepVisual.Handle_StepVisual_AnnotationOccurrence_SetItem(self, *args)


    def Item(self, *args):
        """
        Item(Handle_StepVisual_AnnotationOccurrence self) -> Handle_StepRepr_RepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_AnnotationOccurrence_Item(self, *args)


    def ItemAP242(self, *args):
        """
        ItemAP242(Handle_StepVisual_AnnotationOccurrence self) -> StepVisual_StyledItemTarget

        :rtype: OCC.wrapper.StepVisual.StepVisual_StyledItemTarget

        """
        return _StepVisual.Handle_StepVisual_AnnotationOccurrence_ItemAP242(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_AnnotationOccurrence self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_AnnotationOccurrence_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_AnnotationOccurrence self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_AnnotationOccurrence_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_AnnotationOccurrence self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_AnnotationOccurrence_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_AnnotationOccurrence self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_AnnotationOccurrence self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_AnnotationOccurrence_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_AnnotationOccurrence self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_AnnotationOccurrence self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_AnnotationOccurrence_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_AnnotationOccurrence self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_AnnotationOccurrence_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_AnnotationOccurrence self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_AnnotationOccurrence_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_AnnotationOccurrence self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_AnnotationOccurrence_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_AnnotationOccurrence self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_AnnotationOccurrence_DecrementRefCounter(self, *args)

Handle_StepVisual_AnnotationOccurrence_swigregister = _StepVisual.Handle_StepVisual_AnnotationOccurrence_swigregister
Handle_StepVisual_AnnotationOccurrence_swigregister(Handle_StepVisual_AnnotationOccurrence)

def Handle_StepVisual_AnnotationOccurrence_DownCast(thing):
    return _StepVisual.Handle_StepVisual_AnnotationOccurrence_DownCast(thing)
Handle_StepVisual_AnnotationOccurrence_DownCast = _StepVisual.Handle_StepVisual_AnnotationOccurrence_DownCast

class Handle_StepVisual_PresentationView(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_PresentationView self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_PresentationView_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_PresentationView self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_PresentationView_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_PresentationView self, StepVisual_PresentationView thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationView_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_PresentationView self, Handle_StepVisual_PresentationView theHandle) -> Handle_StepVisual_PresentationView
        assign(Handle_StepVisual_PresentationView self, StepVisual_PresentationView thePtr) -> Handle_StepVisual_PresentationView
        assign(Handle_StepVisual_PresentationView self, Handle_StepVisual_PresentationView theHandle) -> Handle_StepVisual_PresentationView

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_PresentationView_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_PresentationView self) -> StepVisual_PresentationView

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationView_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_PresentationView self) -> StepVisual_PresentationView

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationView___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_PresentationView self) -> StepVisual_PresentationView

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_PresentationView___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_PresentationView___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_PresentationView___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_PresentationView(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_PresentationView_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_PresentationView

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_PresentationView self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_PresentationView_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PresentationView_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PresentationView_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_PresentationView self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_HArray1OfRepresentationItem aItems, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepVisual.Handle_StepVisual_PresentationView_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_PresentationView self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_PresentationView_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_PresentationView self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_PresentationView_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepVisual_PresentationView self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepVisual.Handle_StepVisual_PresentationView_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepVisual_PresentationView self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepVisual.Handle_StepVisual_PresentationView_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepVisual_PresentationView self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_PresentationView_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepVisual_PresentationView self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentationView_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepVisual_PresentationView self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepVisual.Handle_StepVisual_PresentationView_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepVisual_PresentationView self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepVisual.Handle_StepVisual_PresentationView_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_PresentationView self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_PresentationView_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_PresentationView self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_PresentationView self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PresentationView_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_PresentationView self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_PresentationView self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PresentationView_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_PresentationView self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_PresentationView_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_PresentationView self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentationView_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_PresentationView self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_PresentationView_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_PresentationView self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentationView_DecrementRefCounter(self, *args)

Handle_StepVisual_PresentationView_swigregister = _StepVisual.Handle_StepVisual_PresentationView_swigregister
Handle_StepVisual_PresentationView_swigregister(Handle_StepVisual_PresentationView)

def Handle_StepVisual_PresentationView_DownCast(thing):
    return _StepVisual.Handle_StepVisual_PresentationView_DownCast(thing)
Handle_StepVisual_PresentationView_DownCast = _StepVisual.Handle_StepVisual_PresentationView_DownCast

class Handle_StepVisual_DraughtingPreDefinedCurveFont(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_DraughtingPreDefinedCurveFont self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedCurveFont_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_DraughtingPreDefinedCurveFont self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedCurveFont_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_DraughtingPreDefinedCurveFont self, StepVisual_DraughtingPreDefinedCurveFont thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedCurveFont_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_DraughtingPreDefinedCurveFont self, Handle_StepVisual_DraughtingPreDefinedCurveFont theHandle) -> Handle_StepVisual_DraughtingPreDefinedCurveFont
        assign(Handle_StepVisual_DraughtingPreDefinedCurveFont self, StepVisual_DraughtingPreDefinedCurveFont thePtr) -> Handle_StepVisual_DraughtingPreDefinedCurveFont
        assign(Handle_StepVisual_DraughtingPreDefinedCurveFont self, Handle_StepVisual_DraughtingPreDefinedCurveFont theHandle) -> Handle_StepVisual_DraughtingPreDefinedCurveFont

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedCurveFont_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_DraughtingPreDefinedCurveFont self) -> StepVisual_DraughtingPreDefinedCurveFont

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedCurveFont_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_DraughtingPreDefinedCurveFont self) -> StepVisual_DraughtingPreDefinedCurveFont

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedCurveFont___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_DraughtingPreDefinedCurveFont self) -> StepVisual_DraughtingPreDefinedCurveFont

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedCurveFont___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedCurveFont___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_DraughtingPreDefinedCurveFont___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_DraughtingPreDefinedCurveFont(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_DraughtingPreDefinedCurveFont_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_DraughtingPreDefinedCurveFont

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_DraughtingPreDefinedCurveFont self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedCurveFont_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_DraughtingPreDefinedCurveFont_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_DraughtingPreDefinedCurveFont_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_DraughtingPreDefinedCurveFont self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedCurveFont_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_DraughtingPreDefinedCurveFont self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedCurveFont_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_DraughtingPreDefinedCurveFont self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedCurveFont_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_DraughtingPreDefinedCurveFont self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedCurveFont_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_DraughtingPreDefinedCurveFont self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_DraughtingPreDefinedCurveFont self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedCurveFont_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_DraughtingPreDefinedCurveFont self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_DraughtingPreDefinedCurveFont self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedCurveFont_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_DraughtingPreDefinedCurveFont self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedCurveFont_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_DraughtingPreDefinedCurveFont self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedCurveFont_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_DraughtingPreDefinedCurveFont self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedCurveFont_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_DraughtingPreDefinedCurveFont self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_DraughtingPreDefinedCurveFont_DecrementRefCounter(self, *args)

Handle_StepVisual_DraughtingPreDefinedCurveFont_swigregister = _StepVisual.Handle_StepVisual_DraughtingPreDefinedCurveFont_swigregister
Handle_StepVisual_DraughtingPreDefinedCurveFont_swigregister(Handle_StepVisual_DraughtingPreDefinedCurveFont)

def Handle_StepVisual_DraughtingPreDefinedCurveFont_DownCast(thing):
    return _StepVisual.Handle_StepVisual_DraughtingPreDefinedCurveFont_DownCast(thing)
Handle_StepVisual_DraughtingPreDefinedCurveFont_DownCast = _StepVisual.Handle_StepVisual_DraughtingPreDefinedCurveFont_DownCast

class NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger(Standard.Handle_Standard_Transient):
    """
    Purpose: This template class is used to define Handle adaptor
    for allocated dynamically objects of arbitrary type.

    The advantage is that this handle will automatically destroy 
    the object when last referred Handle is destroyed (i.e. it is a 
    typical smart pointer), and that it can be handled as 
    Handle(Standard_Transient) in OCCT components.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Purpose: This template class is used to define Handle adaptor
        for allocated dynamically objects of arbitrary type.

        The advantage is that this handle will automatically destroy 
        the object when last referred Handle is destroyed (i.e. it is a 
        typical smart pointer), and that it can be handled as 
        Handle(Standard_Transient) in OCCT components.
        """
        this = _StepVisual.new_NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def get(self, *args):
        """
        get(NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger self) -> NCollection_Vector_Handle_TColStd_HSequenceOfInteger
        get(NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger self) -> NCollection_Vector_Handle_TColStd_HSequenceOfInteger

        Cast handle to contained type

        :rtype: const T *

        """
        return _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger self) -> NCollection_Vector_Handle_TColStd_HSequenceOfInteger
        __deref__(NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger self) -> NCollection_Vector_Handle_TColStd_HSequenceOfInteger

        Cast handle to contained type

        :rtype: const T *

        """
        return _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger___deref__(self, *args)


    def __ref__(self, *args):
        """
        Cast handle to contained type

        :rtype: const T &

        """
        res = _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger___ref__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DownCast(*args):
        """
        DownCast(Handle_Standard_Transient theOther) -> NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger

        Downcast arbitrary Handle to the argument type if contained
        object is Handle for this type; returns null otherwise

        :type theOther: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.NCollection.NCollection_Handle_T

        """
        return _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_DownCast(*args)

    DownCast = staticmethod(DownCast)
    __swig_destroy__ = _StepVisual.delete_NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger

    def begin(self, *args):
        """
        begin(NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger self) -> NCollection_Vector< opencascade::handle< TColStd_HSequenceOfInteger > >::iterator

        Returns an iterator pointing to the first element in the vector.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger self) -> NCollection_Vector< opencascade::handle< TColStd_HSequenceOfInteger > >::iterator

        Returns an iterator referring to the past-the-end element in the vector.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger self) -> NCollection_Vector< opencascade::handle< TColStd_HSequenceOfInteger > >::const_iterator

        Returns a const iterator pointing to the first element in the vector.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger self) -> NCollection_Vector< opencascade::handle< TColStd_HSequenceOfInteger > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the vector.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_cend(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger self) -> Standard_Integer

        Total number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_Length(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger self) -> Standard_Integer

        Total number of items in the vector

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_Size(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_IsEmpty(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger self, NCollection_Vector_Handle_TColStd_HSequenceOfInteger theOther, Standard_Boolean const theOwnAllocator)

        Assignment to the collection of the same type

        :type theOther: OCC.wrapper.NCollection.NCollection_Vector
        :type theOwnAllocator: bool

        """
        return _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_Assign(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger self, Handle_TColStd_HSequenceOfInteger theValue) -> Handle_TColStd_HSequenceOfInteger

        Append

        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_Append(self, *args)


    def Appended(self, *args):
        """
        Appended(NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger self) -> Handle_TColStd_HSequenceOfInteger

        Appends an empty value and returns the reference to it

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_Appended(self, *args)


    def __call__(self, *args):
        """
        Operator() - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        Operator[] - query the const value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Value(self, *args):
        """
        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger self) -> Handle_TColStd_HSequenceOfInteger

        @return first element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger self) -> Handle_TColStd_HSequenceOfInteger

        @return last element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_ChangeLast(self, *args)


    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger self, Standard_Integer const theIndex) -> Handle_TColStd_HSequenceOfInteger

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger self, Standard_Integer const theIndex, Handle_TColStd_HSequenceOfInteger theValue) -> Handle_TColStd_HSequenceOfInteger

        SetValue () - set or append a value

        :type theIndex: int
        :type theValue: const TheItemType &
        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_SetValue(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger self)

        Empty the vector of its objects


        """
        return _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_Clear(self, *args)


    def SetIncrement(self, *args):
        """
        SetIncrement(NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger self, Standard_Integer const aIncrement)

        :type aIncrement: int

        """
        return _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_SetIncrement(self, *args)


    def Allocator(self, *args):
        """
        Returns attached allocator

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        res = _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_Allocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_swigregister = _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_swigregister
NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_swigregister(NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger)

def NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_DownCast(*args):
    """
    NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_DownCast(Handle_Standard_Transient theOther) -> NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger

    Downcast arbitrary Handle to the argument type if contained
    object is Handle for this type; returns null otherwise

    :type theOther: OCC.wrapper.Standard.Handle_Standard_Transient
    :rtype: OCC.wrapper.NCollection.NCollection_Handle_T

    """
    return _StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger_DownCast(*args)

class NCollection_Array1_StepVisual_DirectionCountSelect(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_StepVisual_DirectionCountSelect self) -> NCollection_Array1< StepVisual_DirectionCountSelect >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_DirectionCountSelect_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_StepVisual_DirectionCountSelect self) -> NCollection_Array1< StepVisual_DirectionCountSelect >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_DirectionCountSelect_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_StepVisual_DirectionCountSelect self) -> NCollection_Array1< StepVisual_DirectionCountSelect >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_DirectionCountSelect_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_StepVisual_DirectionCountSelect self) -> NCollection_Array1< StepVisual_DirectionCountSelect >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_DirectionCountSelect_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepVisual.new_NCollection_Array1_StepVisual_DirectionCountSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_StepVisual_DirectionCountSelect self, StepVisual_DirectionCountSelect theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_DirectionCountSelect_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_StepVisual_DirectionCountSelect self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_DirectionCountSelect_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_StepVisual_DirectionCountSelect self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_DirectionCountSelect_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_StepVisual_DirectionCountSelect self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_DirectionCountSelect_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_StepVisual_DirectionCountSelect self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_DirectionCountSelect_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_StepVisual_DirectionCountSelect self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_DirectionCountSelect_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_StepVisual_DirectionCountSelect self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_DirectionCountSelect_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_StepVisual_DirectionCountSelect self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_DirectionCountSelect_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_StepVisual_DirectionCountSelect self, NCollection_Array1_StepVisual_DirectionCountSelect theOther) -> NCollection_Array1_StepVisual_DirectionCountSelect

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_DirectionCountSelect_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_StepVisual_DirectionCountSelect self, NCollection_Array1_StepVisual_DirectionCountSelect theOther) -> NCollection_Array1_StepVisual_DirectionCountSelect

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_DirectionCountSelect_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_StepVisual_DirectionCountSelect self, NCollection_Array1_StepVisual_DirectionCountSelect theOther) -> NCollection_Array1_StepVisual_DirectionCountSelect
        assign(NCollection_Array1_StepVisual_DirectionCountSelect self, NCollection_Array1_StepVisual_DirectionCountSelect theOther) -> NCollection_Array1_StepVisual_DirectionCountSelect

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_DirectionCountSelect_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_DirectionCountSelect_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_StepVisual_DirectionCountSelect self) -> StepVisual_DirectionCountSelect

        @return first element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_DirectionCountSelect_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_DirectionCountSelect_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_StepVisual_DirectionCountSelect self) -> StepVisual_DirectionCountSelect

        @return last element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_DirectionCountSelect_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_DirectionCountSelect_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_StepVisual_DirectionCountSelect self, Standard_Integer const theIndex) -> StepVisual_DirectionCountSelect

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_DirectionCountSelect_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_DirectionCountSelect___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_DirectionCountSelect_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_StepVisual_DirectionCountSelect self, Standard_Integer const theIndex, StepVisual_DirectionCountSelect theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_DirectionCountSelect_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_StepVisual_DirectionCountSelect self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepVisual.NCollection_Array1_StepVisual_DirectionCountSelect_Resize(self, *args)

    __swig_destroy__ = _StepVisual.delete_NCollection_Array1_StepVisual_DirectionCountSelect
NCollection_Array1_StepVisual_DirectionCountSelect_swigregister = _StepVisual.NCollection_Array1_StepVisual_DirectionCountSelect_swigregister
NCollection_Array1_StepVisual_DirectionCountSelect_swigregister(NCollection_Array1_StepVisual_DirectionCountSelect)


try:
	StepVisual_Array1OfDirectionCountSelect = NCollection_Array1_StepVisual_DirectionCountSelect
except NameError:
	pass # does not exist, probably ignored

class Handle_StepVisual_PresentationStyleByContext(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_PresentationStyleByContext self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_PresentationStyleByContext_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_PresentationStyleByContext self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleByContext_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_PresentationStyleByContext self, StepVisual_PresentationStyleByContext thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleByContext_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_PresentationStyleByContext self, Handle_StepVisual_PresentationStyleByContext theHandle) -> Handle_StepVisual_PresentationStyleByContext
        assign(Handle_StepVisual_PresentationStyleByContext self, StepVisual_PresentationStyleByContext thePtr) -> Handle_StepVisual_PresentationStyleByContext
        assign(Handle_StepVisual_PresentationStyleByContext self, Handle_StepVisual_PresentationStyleByContext theHandle) -> Handle_StepVisual_PresentationStyleByContext

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleByContext_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_PresentationStyleByContext self) -> StepVisual_PresentationStyleByContext

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleByContext_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_PresentationStyleByContext self) -> StepVisual_PresentationStyleByContext

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleByContext___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_PresentationStyleByContext self) -> StepVisual_PresentationStyleByContext

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleByContext___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_PresentationStyleByContext___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_PresentationStyleByContext___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_PresentationStyleByContext(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_PresentationStyleByContext_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_PresentationStyleByContext

    def Init(self, *args):
        """
        Init(Handle_StepVisual_PresentationStyleByContext self, Handle_StepVisual_HArray1OfPresentationStyleSelect aStyles, StepVisual_StyleContextSelect aStyleContext)

        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect
        :type aStyleContext: OCC.wrapper.StepVisual.StepVisual_StyleContextSelect

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleByContext_Init(self, *args)


    def SetStyleContext(self, *args):
        """
        SetStyleContext(Handle_StepVisual_PresentationStyleByContext self, StepVisual_StyleContextSelect aStyleContext)

        :type aStyleContext: OCC.wrapper.StepVisual.StepVisual_StyleContextSelect

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleByContext_SetStyleContext(self, *args)


    def StyleContext(self, *args):
        """
        StyleContext(Handle_StepVisual_PresentationStyleByContext self) -> StepVisual_StyleContextSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_StyleContextSelect

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleByContext_StyleContext(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_PresentationStyleByContext self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleByContext_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PresentationStyleByContext_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PresentationStyleByContext_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetStyles(self, *args):
        """
        SetStyles(Handle_StepVisual_PresentationStyleByContext self, Handle_StepVisual_HArray1OfPresentationStyleSelect aStyles)

        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleByContext_SetStyles(self, *args)


    def Styles(self, *args):
        """
        Styles(Handle_StepVisual_PresentationStyleByContext self) -> Handle_StepVisual_HArray1OfPresentationStyleSelect

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleByContext_Styles(self, *args)


    def StylesValue(self, *args):
        """
        StylesValue(Handle_StepVisual_PresentationStyleByContext self, Standard_Integer const num) -> StepVisual_PresentationStyleSelect

        :type num: int
        :rtype: OCC.wrapper.StepVisual.StepVisual_PresentationStyleSelect

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleByContext_StylesValue(self, *args)


    def NbStyles(self, *args):
        """
        NbStyles(Handle_StepVisual_PresentationStyleByContext self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleByContext_NbStyles(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_PresentationStyleByContext self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_PresentationStyleByContext_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_PresentationStyleByContext self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_PresentationStyleByContext self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleByContext_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_PresentationStyleByContext self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_PresentationStyleByContext self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleByContext_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_PresentationStyleByContext self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleByContext_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_PresentationStyleByContext self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleByContext_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_PresentationStyleByContext self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_PresentationStyleByContext_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_PresentationStyleByContext self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentationStyleByContext_DecrementRefCounter(self, *args)

Handle_StepVisual_PresentationStyleByContext_swigregister = _StepVisual.Handle_StepVisual_PresentationStyleByContext_swigregister
Handle_StepVisual_PresentationStyleByContext_swigregister(Handle_StepVisual_PresentationStyleByContext)

def Handle_StepVisual_PresentationStyleByContext_DownCast(thing):
    return _StepVisual.Handle_StepVisual_PresentationStyleByContext_DownCast(thing)
Handle_StepVisual_PresentationStyleByContext_DownCast = _StepVisual.Handle_StepVisual_PresentationStyleByContext_DownCast

class Handle_StepVisual_TessellatedGeometricSet(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_TessellatedGeometricSet self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_TessellatedGeometricSet_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_TessellatedGeometricSet self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_TessellatedGeometricSet_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_TessellatedGeometricSet self, StepVisual_TessellatedGeometricSet thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_TessellatedGeometricSet_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_TessellatedGeometricSet self, Handle_StepVisual_TessellatedGeometricSet theHandle) -> Handle_StepVisual_TessellatedGeometricSet
        assign(Handle_StepVisual_TessellatedGeometricSet self, StepVisual_TessellatedGeometricSet thePtr) -> Handle_StepVisual_TessellatedGeometricSet
        assign(Handle_StepVisual_TessellatedGeometricSet self, Handle_StepVisual_TessellatedGeometricSet theHandle) -> Handle_StepVisual_TessellatedGeometricSet

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_TessellatedGeometricSet_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_TessellatedGeometricSet self) -> StepVisual_TessellatedGeometricSet

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_TessellatedGeometricSet_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_TessellatedGeometricSet self) -> StepVisual_TessellatedGeometricSet

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_TessellatedGeometricSet___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_TessellatedGeometricSet self) -> StepVisual_TessellatedGeometricSet

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_TessellatedGeometricSet___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_TessellatedGeometricSet___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_TessellatedGeometricSet___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_TessellatedGeometricSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_TessellatedGeometricSet_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_TessellatedGeometricSet

    def Init(self, *args):
        """
        Init(Handle_StepVisual_TessellatedGeometricSet self, Handle_TCollection_HAsciiString theName, NCollection_Handle_StepVisual_Array1OfTessellatedItem theItems)

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theItems: OCC.wrapper.StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem

        """
        return _StepVisual.Handle_StepVisual_TessellatedGeometricSet_Init(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepVisual_TessellatedGeometricSet self) -> NCollection_Handle_StepVisual_Array1OfTessellatedItem

        :rtype: OCC.wrapper.StepVisual.NCollection_Handle_StepVisual_Array1OfTessellatedItem

        """
        return _StepVisual.Handle_StepVisual_TessellatedGeometricSet_Items(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_TessellatedGeometricSet self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_TessellatedGeometricSet_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_TessellatedGeometricSet_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_TessellatedGeometricSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_TessellatedGeometricSet self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_TessellatedGeometricSet_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_TessellatedGeometricSet self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_TessellatedGeometricSet_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_TessellatedGeometricSet self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_TessellatedGeometricSet_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_TessellatedGeometricSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_TessellatedGeometricSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_TessellatedGeometricSet_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_TessellatedGeometricSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_TessellatedGeometricSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_TessellatedGeometricSet_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_TessellatedGeometricSet self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_TessellatedGeometricSet_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_TessellatedGeometricSet self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_TessellatedGeometricSet_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_TessellatedGeometricSet self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_TessellatedGeometricSet_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_TessellatedGeometricSet self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_TessellatedGeometricSet_DecrementRefCounter(self, *args)

Handle_StepVisual_TessellatedGeometricSet_swigregister = _StepVisual.Handle_StepVisual_TessellatedGeometricSet_swigregister
Handle_StepVisual_TessellatedGeometricSet_swigregister(Handle_StepVisual_TessellatedGeometricSet)

def Handle_StepVisual_TessellatedGeometricSet_DownCast(thing):
    return _StepVisual.Handle_StepVisual_TessellatedGeometricSet_DownCast(thing)
Handle_StepVisual_TessellatedGeometricSet_DownCast = _StepVisual.Handle_StepVisual_TessellatedGeometricSet_DownCast

class Handle_StepVisual_CurveStyleFont(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_CurveStyleFont self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_CurveStyleFont_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_CurveStyleFont self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFont_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_CurveStyleFont self, StepVisual_CurveStyleFont thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFont_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_CurveStyleFont self, Handle_StepVisual_CurveStyleFont theHandle) -> Handle_StepVisual_CurveStyleFont
        assign(Handle_StepVisual_CurveStyleFont self, StepVisual_CurveStyleFont thePtr) -> Handle_StepVisual_CurveStyleFont
        assign(Handle_StepVisual_CurveStyleFont self, Handle_StepVisual_CurveStyleFont theHandle) -> Handle_StepVisual_CurveStyleFont

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFont_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_CurveStyleFont self) -> StepVisual_CurveStyleFont

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFont_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_CurveStyleFont self) -> StepVisual_CurveStyleFont

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFont___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_CurveStyleFont self) -> StepVisual_CurveStyleFont

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFont___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_CurveStyleFont___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_CurveStyleFont___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_CurveStyleFont(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_CurveStyleFont_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_CurveStyleFont

    def Init(self, *args):
        """
        Init(Handle_StepVisual_CurveStyleFont self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_HArray1OfCurveStyleFontPattern aPatternList)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPatternList: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFont_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_CurveStyleFont self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFont_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_CurveStyleFont self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFont_Name(self, *args)


    def SetPatternList(self, *args):
        """
        SetPatternList(Handle_StepVisual_CurveStyleFont self, Handle_StepVisual_HArray1OfCurveStyleFontPattern aPatternList)

        :type aPatternList: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFont_SetPatternList(self, *args)


    def PatternList(self, *args):
        """
        PatternList(Handle_StepVisual_CurveStyleFont self) -> Handle_StepVisual_HArray1OfCurveStyleFontPattern

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfCurveStyleFontPattern

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFont_PatternList(self, *args)


    def PatternListValue(self, *args):
        """
        PatternListValue(Handle_StepVisual_CurveStyleFont self, Standard_Integer const num) -> Handle_StepVisual_CurveStyleFontPattern

        :type num: int
        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyleFontPattern

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFont_PatternListValue(self, *args)


    def NbPatternList(self, *args):
        """
        NbPatternList(Handle_StepVisual_CurveStyleFont self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFont_NbPatternList(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_CurveStyleFont self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFont_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CurveStyleFont_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CurveStyleFont_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_CurveStyleFont self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_CurveStyleFont_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_CurveStyleFont self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_CurveStyleFont self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFont_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_CurveStyleFont self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_CurveStyleFont self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFont_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_CurveStyleFont self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFont_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_CurveStyleFont self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFont_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_CurveStyleFont self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_CurveStyleFont_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_CurveStyleFont self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFont_DecrementRefCounter(self, *args)

Handle_StepVisual_CurveStyleFont_swigregister = _StepVisual.Handle_StepVisual_CurveStyleFont_swigregister
Handle_StepVisual_CurveStyleFont_swigregister(Handle_StepVisual_CurveStyleFont)

def Handle_StepVisual_CurveStyleFont_DownCast(thing):
    return _StepVisual.Handle_StepVisual_CurveStyleFont_DownCast(thing)
Handle_StepVisual_CurveStyleFont_DownCast = _StepVisual.Handle_StepVisual_CurveStyleFont_DownCast

class Handle_StepVisual_CameraImage3dWithScale(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_CameraImage3dWithScale self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_CameraImage3dWithScale_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_CameraImage3dWithScale self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_CameraImage3dWithScale_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_CameraImage3dWithScale self, StepVisual_CameraImage3dWithScale thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_CameraImage3dWithScale_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_CameraImage3dWithScale self, Handle_StepVisual_CameraImage3dWithScale theHandle) -> Handle_StepVisual_CameraImage3dWithScale
        assign(Handle_StepVisual_CameraImage3dWithScale self, StepVisual_CameraImage3dWithScale thePtr) -> Handle_StepVisual_CameraImage3dWithScale
        assign(Handle_StepVisual_CameraImage3dWithScale self, Handle_StepVisual_CameraImage3dWithScale theHandle) -> Handle_StepVisual_CameraImage3dWithScale

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_CameraImage3dWithScale_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_CameraImage3dWithScale self) -> StepVisual_CameraImage3dWithScale

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CameraImage3dWithScale_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_CameraImage3dWithScale self) -> StepVisual_CameraImage3dWithScale

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CameraImage3dWithScale___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_CameraImage3dWithScale self) -> StepVisual_CameraImage3dWithScale

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_CameraImage3dWithScale___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_CameraImage3dWithScale___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_CameraImage3dWithScale___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_CameraImage3dWithScale(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_CameraImage3dWithScale_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_CameraImage3dWithScale

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_CameraImage3dWithScale self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_CameraImage3dWithScale_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CameraImage3dWithScale_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CameraImage3dWithScale_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_CameraImage3dWithScale self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_RepresentationMap aMappingSource, Handle_StepRepr_RepresentationItem aMappingTarget)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aMappingSource: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationMap
        :type aMappingTarget: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_CameraImage3dWithScale_Init(self, *args)


    def SetMappingSource(self, *args):
        """
        SetMappingSource(Handle_StepVisual_CameraImage3dWithScale self, Handle_StepRepr_RepresentationMap aMappingSource)

        :type aMappingSource: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationMap

        """
        return _StepVisual.Handle_StepVisual_CameraImage3dWithScale_SetMappingSource(self, *args)


    def MappingSource(self, *args):
        """
        MappingSource(Handle_StepVisual_CameraImage3dWithScale self) -> Handle_StepRepr_RepresentationMap

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationMap

        """
        return _StepVisual.Handle_StepVisual_CameraImage3dWithScale_MappingSource(self, *args)


    def SetMappingTarget(self, *args):
        """
        SetMappingTarget(Handle_StepVisual_CameraImage3dWithScale self, Handle_StepRepr_RepresentationItem aMappingTarget)

        :type aMappingTarget: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_CameraImage3dWithScale_SetMappingTarget(self, *args)


    def MappingTarget(self, *args):
        """
        MappingTarget(Handle_StepVisual_CameraImage3dWithScale self) -> Handle_StepRepr_RepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_CameraImage3dWithScale_MappingTarget(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_CameraImage3dWithScale self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CameraImage3dWithScale_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_CameraImage3dWithScale self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CameraImage3dWithScale_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_CameraImage3dWithScale self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_CameraImage3dWithScale_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_CameraImage3dWithScale self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_CameraImage3dWithScale self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CameraImage3dWithScale_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_CameraImage3dWithScale self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_CameraImage3dWithScale self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CameraImage3dWithScale_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_CameraImage3dWithScale self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_CameraImage3dWithScale_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_CameraImage3dWithScale self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CameraImage3dWithScale_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_CameraImage3dWithScale self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_CameraImage3dWithScale_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_CameraImage3dWithScale self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CameraImage3dWithScale_DecrementRefCounter(self, *args)

Handle_StepVisual_CameraImage3dWithScale_swigregister = _StepVisual.Handle_StepVisual_CameraImage3dWithScale_swigregister
Handle_StepVisual_CameraImage3dWithScale_swigregister(Handle_StepVisual_CameraImage3dWithScale)

def Handle_StepVisual_CameraImage3dWithScale_DownCast(thing):
    return _StepVisual.Handle_StepVisual_CameraImage3dWithScale_DownCast(thing)
Handle_StepVisual_CameraImage3dWithScale_DownCast = _StepVisual.Handle_StepVisual_CameraImage3dWithScale_DownCast

class NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment self) -> NCollection_Array1< opencascade::handle< StepVisual_PresentationStyleAssignment > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment self) -> NCollection_Array1< opencascade::handle< StepVisual_PresentationStyleAssignment > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment self) -> NCollection_Array1< opencascade::handle< StepVisual_PresentationStyleAssignment > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment self) -> NCollection_Array1< opencascade::handle< StepVisual_PresentationStyleAssignment > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepVisual.new_NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment self, Handle_StepVisual_PresentationStyleAssignment theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment self, NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment theOther) -> NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment self, NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment theOther) -> NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment self, NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment theOther) -> NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment
        assign(NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment self, NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment theOther) -> NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment self) -> Handle_StepVisual_PresentationStyleAssignment

        @return first element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment self) -> Handle_StepVisual_PresentationStyleAssignment

        @return last element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment self, Standard_Integer const theIndex) -> Handle_StepVisual_PresentationStyleAssignment

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment self, Standard_Integer const theIndex, Handle_StepVisual_PresentationStyleAssignment theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_Resize(self, *args)

    __swig_destroy__ = _StepVisual.delete_NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment
NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_swigregister = _StepVisual.NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_swigregister
NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment_swigregister(NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment)


try:
	StepVisual_Array1OfPresentationStyleAssignment = NCollection_Array1_Handle_StepVisual_PresentationStyleAssignment
except NameError:
	pass # does not exist, probably ignored

class StepVisual_SurfaceStyleElementSelect(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepVisual_SurfaceStyleElementSelect self) -> StepVisual_SurfaceStyleElementSelect

        Returns a SurfaceStyleElementSelect SelectType


        """
        this = _StepVisual.new_StepVisual_SurfaceStyleElementSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepVisual_SurfaceStyleElementSelect self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a SurfaceStyleElementSelect Kind Entity that is :
        1 -> SurfaceStyleFillArea
        2 -> SurfaceStyleBoundary
        3 -> SurfaceStyleParameterLine
        4 -> SurfaceStyleSilhouette
        5 -> SurfaceStyleSegmentationCurve
        6 -> SurfaceStyleControlGrid
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_SurfaceStyleElementSelect_CaseNum(self, *args)


    def SurfaceStyleFillArea(self, *args):
        """
        SurfaceStyleFillArea(StepVisual_SurfaceStyleElementSelect self) -> Handle_StepVisual_SurfaceStyleFillArea

        returns Value as a SurfaceStyleFillArea (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_SurfaceStyleFillArea

        """
        return _StepVisual.StepVisual_SurfaceStyleElementSelect_SurfaceStyleFillArea(self, *args)


    def SurfaceStyleBoundary(self, *args):
        """
        SurfaceStyleBoundary(StepVisual_SurfaceStyleElementSelect self) -> Handle_StepVisual_SurfaceStyleBoundary

        returns Value as a SurfaceStyleBoundary (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_SurfaceStyleBoundary

        """
        return _StepVisual.StepVisual_SurfaceStyleElementSelect_SurfaceStyleBoundary(self, *args)


    def SurfaceStyleParameterLine(self, *args):
        """
        SurfaceStyleParameterLine(StepVisual_SurfaceStyleElementSelect self) -> Handle_StepVisual_SurfaceStyleParameterLine

        returns Value as a SurfaceStyleParameterLine (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_SurfaceStyleParameterLine

        """
        return _StepVisual.StepVisual_SurfaceStyleElementSelect_SurfaceStyleParameterLine(self, *args)

    __swig_destroy__ = _StepVisual.delete_StepVisual_SurfaceStyleElementSelect
StepVisual_SurfaceStyleElementSelect_swigregister = _StepVisual.StepVisual_SurfaceStyleElementSelect_swigregister
StepVisual_SurfaceStyleElementSelect_swigregister(StepVisual_SurfaceStyleElementSelect)

class StepVisual_TextStyleWithBoxCharacteristics(StepVisual_TextStyle):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_TextStyleWithBoxCharacteristics
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_TextStyleWithBoxCharacteristics(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_TextStyleWithBoxCharacteristics self) -> StepVisual_TextStyleWithBoxCharacteristics

        Returns a TextStyleWithBoxCharacteristics


        """
        this = _StepVisual.new_StepVisual_TextStyleWithBoxCharacteristics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_TextStyleWithBoxCharacteristics self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_TextStyleForDefinedFont aCharacterAppearance, Handle_StepVisual_HArray1OfBoxCharacteristicSelect aCharacteristics)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aCharacterAppearance: OCC.wrapper.StepVisual.Handle_StepVisual_TextStyleForDefinedFont
        :type aCharacteristics: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect

        """
        return _StepVisual.StepVisual_TextStyleWithBoxCharacteristics_Init(self, *args)


    def SetCharacteristics(self, *args):
        """
        SetCharacteristics(StepVisual_TextStyleWithBoxCharacteristics self, Handle_StepVisual_HArray1OfBoxCharacteristicSelect aCharacteristics)

        :type aCharacteristics: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect

        """
        return _StepVisual.StepVisual_TextStyleWithBoxCharacteristics_SetCharacteristics(self, *args)


    def Characteristics(self, *args):
        """
        Characteristics(StepVisual_TextStyleWithBoxCharacteristics self) -> Handle_StepVisual_HArray1OfBoxCharacteristicSelect

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect

        """
        return _StepVisual.StepVisual_TextStyleWithBoxCharacteristics_Characteristics(self, *args)


    def CharacteristicsValue(self, *args):
        """
        CharacteristicsValue(StepVisual_TextStyleWithBoxCharacteristics self, Standard_Integer const num) -> StepVisual_BoxCharacteristicSelect

        :type num: int
        :rtype: OCC.wrapper.StepVisual.StepVisual_BoxCharacteristicSelect

        """
        return _StepVisual.StepVisual_TextStyleWithBoxCharacteristics_CharacteristicsValue(self, *args)


    def NbCharacteristics(self, *args):
        """
        NbCharacteristics(StepVisual_TextStyleWithBoxCharacteristics self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_TextStyleWithBoxCharacteristics_NbCharacteristics(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_TextStyleWithBoxCharacteristics_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_TextStyleWithBoxCharacteristics_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_TextStyleWithBoxCharacteristics_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_TextStyleWithBoxCharacteristics
StepVisual_TextStyleWithBoxCharacteristics_swigregister = _StepVisual.StepVisual_TextStyleWithBoxCharacteristics_swigregister
StepVisual_TextStyleWithBoxCharacteristics_swigregister(StepVisual_TextStyleWithBoxCharacteristics)

def StepVisual_TextStyleWithBoxCharacteristics_get_type_name(*args):
    """
    StepVisual_TextStyleWithBoxCharacteristics_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_TextStyleWithBoxCharacteristics_get_type_name(*args)

def StepVisual_TextStyleWithBoxCharacteristics_get_type_descriptor(*args):
    """
    StepVisual_TextStyleWithBoxCharacteristics_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_TextStyleWithBoxCharacteristics_get_type_descriptor(*args)

class NCollection_Array1_StepVisual_FillStyleSelect(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_StepVisual_FillStyleSelect self) -> NCollection_Array1< StepVisual_FillStyleSelect >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_FillStyleSelect_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_StepVisual_FillStyleSelect self) -> NCollection_Array1< StepVisual_FillStyleSelect >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_FillStyleSelect_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_StepVisual_FillStyleSelect self) -> NCollection_Array1< StepVisual_FillStyleSelect >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_FillStyleSelect_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_StepVisual_FillStyleSelect self) -> NCollection_Array1< StepVisual_FillStyleSelect >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_FillStyleSelect_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepVisual.new_NCollection_Array1_StepVisual_FillStyleSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_StepVisual_FillStyleSelect self, StepVisual_FillStyleSelect theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_FillStyleSelect_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_StepVisual_FillStyleSelect self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_FillStyleSelect_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_StepVisual_FillStyleSelect self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_FillStyleSelect_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_StepVisual_FillStyleSelect self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_FillStyleSelect_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_StepVisual_FillStyleSelect self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_FillStyleSelect_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_StepVisual_FillStyleSelect self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_FillStyleSelect_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_StepVisual_FillStyleSelect self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_FillStyleSelect_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_StepVisual_FillStyleSelect self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_FillStyleSelect_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_StepVisual_FillStyleSelect self, NCollection_Array1_StepVisual_FillStyleSelect theOther) -> NCollection_Array1_StepVisual_FillStyleSelect

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_FillStyleSelect_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_StepVisual_FillStyleSelect self, NCollection_Array1_StepVisual_FillStyleSelect theOther) -> NCollection_Array1_StepVisual_FillStyleSelect

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_FillStyleSelect_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_StepVisual_FillStyleSelect self, NCollection_Array1_StepVisual_FillStyleSelect theOther) -> NCollection_Array1_StepVisual_FillStyleSelect
        assign(NCollection_Array1_StepVisual_FillStyleSelect self, NCollection_Array1_StepVisual_FillStyleSelect theOther) -> NCollection_Array1_StepVisual_FillStyleSelect

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_FillStyleSelect_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_FillStyleSelect_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_StepVisual_FillStyleSelect self) -> StepVisual_FillStyleSelect

        @return first element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_FillStyleSelect_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_FillStyleSelect_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_StepVisual_FillStyleSelect self) -> StepVisual_FillStyleSelect

        @return last element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_FillStyleSelect_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_FillStyleSelect_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_StepVisual_FillStyleSelect self, Standard_Integer const theIndex) -> StepVisual_FillStyleSelect

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_FillStyleSelect_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_FillStyleSelect___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_FillStyleSelect_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_StepVisual_FillStyleSelect self, Standard_Integer const theIndex, StepVisual_FillStyleSelect theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_FillStyleSelect_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_StepVisual_FillStyleSelect self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepVisual.NCollection_Array1_StepVisual_FillStyleSelect_Resize(self, *args)

    __swig_destroy__ = _StepVisual.delete_NCollection_Array1_StepVisual_FillStyleSelect
NCollection_Array1_StepVisual_FillStyleSelect_swigregister = _StepVisual.NCollection_Array1_StepVisual_FillStyleSelect_swigregister
NCollection_Array1_StepVisual_FillStyleSelect_swigregister(NCollection_Array1_StepVisual_FillStyleSelect)


try:
	StepVisual_Array1OfFillStyleSelect = NCollection_Array1_StepVisual_FillStyleSelect
except NameError:
	pass # does not exist, probably ignored

class Handle_StepVisual_MechanicalDesignGeometricPresentationArea(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self, StepVisual_MechanicalDesignGeometricPresentationArea thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self, Handle_StepVisual_MechanicalDesignGeometricPresentationArea theHandle) -> Handle_StepVisual_MechanicalDesignGeometricPresentationArea
        assign(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self, StepVisual_MechanicalDesignGeometricPresentationArea thePtr) -> Handle_StepVisual_MechanicalDesignGeometricPresentationArea
        assign(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self, Handle_StepVisual_MechanicalDesignGeometricPresentationArea theHandle) -> Handle_StepVisual_MechanicalDesignGeometricPresentationArea

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self) -> StepVisual_MechanicalDesignGeometricPresentationArea

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self) -> StepVisual_MechanicalDesignGeometricPresentationArea

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self) -> StepVisual_MechanicalDesignGeometricPresentationArea

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_MechanicalDesignGeometricPresentationArea(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_MechanicalDesignGeometricPresentationArea

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_HArray1OfRepresentationItem aItems, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_MechanicalDesignGeometricPresentationArea self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_DecrementRefCounter(self, *args)

Handle_StepVisual_MechanicalDesignGeometricPresentationArea_swigregister = _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_swigregister
Handle_StepVisual_MechanicalDesignGeometricPresentationArea_swigregister(Handle_StepVisual_MechanicalDesignGeometricPresentationArea)

def Handle_StepVisual_MechanicalDesignGeometricPresentationArea_DownCast(thing):
    return _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_DownCast(thing)
Handle_StepVisual_MechanicalDesignGeometricPresentationArea_DownCast = _StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationArea_DownCast

class NCollection_Array1_Handle_StepVisual_TessellatedItem(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_StepVisual_TessellatedItem self) -> NCollection_Array1< opencascade::handle< StepVisual_TessellatedItem > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_TessellatedItem_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_StepVisual_TessellatedItem self) -> NCollection_Array1< opencascade::handle< StepVisual_TessellatedItem > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_TessellatedItem_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_StepVisual_TessellatedItem self) -> NCollection_Array1< opencascade::handle< StepVisual_TessellatedItem > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_TessellatedItem_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_StepVisual_TessellatedItem self) -> NCollection_Array1< opencascade::handle< StepVisual_TessellatedItem > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_TessellatedItem_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepVisual.new_NCollection_Array1_Handle_StepVisual_TessellatedItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_StepVisual_TessellatedItem self, Handle_StepVisual_TessellatedItem theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_TessellatedItem_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_StepVisual_TessellatedItem self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_TessellatedItem_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_StepVisual_TessellatedItem self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_TessellatedItem_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_StepVisual_TessellatedItem self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_TessellatedItem_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_StepVisual_TessellatedItem self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_TessellatedItem_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_StepVisual_TessellatedItem self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_TessellatedItem_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_StepVisual_TessellatedItem self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_TessellatedItem_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_StepVisual_TessellatedItem self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_TessellatedItem_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_StepVisual_TessellatedItem self, NCollection_Array1_Handle_StepVisual_TessellatedItem theOther) -> NCollection_Array1_Handle_StepVisual_TessellatedItem

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_TessellatedItem_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_StepVisual_TessellatedItem self, NCollection_Array1_Handle_StepVisual_TessellatedItem theOther) -> NCollection_Array1_Handle_StepVisual_TessellatedItem

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_TessellatedItem_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_StepVisual_TessellatedItem self, NCollection_Array1_Handle_StepVisual_TessellatedItem theOther) -> NCollection_Array1_Handle_StepVisual_TessellatedItem
        assign(NCollection_Array1_Handle_StepVisual_TessellatedItem self, NCollection_Array1_Handle_StepVisual_TessellatedItem theOther) -> NCollection_Array1_Handle_StepVisual_TessellatedItem

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_TessellatedItem_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_Handle_StepVisual_TessellatedItem_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_StepVisual_TessellatedItem self) -> Handle_StepVisual_TessellatedItem

        @return first element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_TessellatedItem_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_Handle_StepVisual_TessellatedItem_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_StepVisual_TessellatedItem self) -> Handle_StepVisual_TessellatedItem

        @return last element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_TessellatedItem_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_Handle_StepVisual_TessellatedItem_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_StepVisual_TessellatedItem self, Standard_Integer const theIndex) -> Handle_StepVisual_TessellatedItem

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_TessellatedItem_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_Handle_StepVisual_TessellatedItem___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_Handle_StepVisual_TessellatedItem_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_StepVisual_TessellatedItem self, Standard_Integer const theIndex, Handle_StepVisual_TessellatedItem theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_TessellatedItem_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_StepVisual_TessellatedItem self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_TessellatedItem_Resize(self, *args)

    __swig_destroy__ = _StepVisual.delete_NCollection_Array1_Handle_StepVisual_TessellatedItem
NCollection_Array1_Handle_StepVisual_TessellatedItem_swigregister = _StepVisual.NCollection_Array1_Handle_StepVisual_TessellatedItem_swigregister
NCollection_Array1_Handle_StepVisual_TessellatedItem_swigregister(NCollection_Array1_Handle_StepVisual_TessellatedItem)


try:
	StepVisual_Array1OfTessellatedItem = NCollection_Array1_Handle_StepVisual_TessellatedItem
except NameError:
	pass # does not exist, probably ignored

class Handle_StepVisual_ContextDependentInvisibility(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_ContextDependentInvisibility self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_ContextDependentInvisibility_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_ContextDependentInvisibility self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_ContextDependentInvisibility_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_ContextDependentInvisibility self, StepVisual_ContextDependentInvisibility thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_ContextDependentInvisibility_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_ContextDependentInvisibility self, Handle_StepVisual_ContextDependentInvisibility theHandle) -> Handle_StepVisual_ContextDependentInvisibility
        assign(Handle_StepVisual_ContextDependentInvisibility self, StepVisual_ContextDependentInvisibility thePtr) -> Handle_StepVisual_ContextDependentInvisibility
        assign(Handle_StepVisual_ContextDependentInvisibility self, Handle_StepVisual_ContextDependentInvisibility theHandle) -> Handle_StepVisual_ContextDependentInvisibility

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_ContextDependentInvisibility_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_ContextDependentInvisibility self) -> StepVisual_ContextDependentInvisibility

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_ContextDependentInvisibility_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_ContextDependentInvisibility self) -> StepVisual_ContextDependentInvisibility

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_ContextDependentInvisibility___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_ContextDependentInvisibility self) -> StepVisual_ContextDependentInvisibility

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_ContextDependentInvisibility___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_ContextDependentInvisibility___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_ContextDependentInvisibility___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_ContextDependentInvisibility(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_ContextDependentInvisibility_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_ContextDependentInvisibility

    def Init(self, *args):
        """
        Init(Handle_StepVisual_ContextDependentInvisibility self, Handle_StepVisual_HArray1OfInvisibleItem aInvisibleItems, StepVisual_InvisibilityContext aPresentationContext)

        :type aInvisibleItems: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfInvisibleItem
        :type aPresentationContext: OCC.wrapper.StepVisual.StepVisual_InvisibilityContext

        """
        return _StepVisual.Handle_StepVisual_ContextDependentInvisibility_Init(self, *args)


    def SetPresentationContext(self, *args):
        """
        SetPresentationContext(Handle_StepVisual_ContextDependentInvisibility self, StepVisual_InvisibilityContext aPresentationContext)

        :type aPresentationContext: OCC.wrapper.StepVisual.StepVisual_InvisibilityContext

        """
        return _StepVisual.Handle_StepVisual_ContextDependentInvisibility_SetPresentationContext(self, *args)


    def PresentationContext(self, *args):
        """
        PresentationContext(Handle_StepVisual_ContextDependentInvisibility self) -> StepVisual_InvisibilityContext

        :rtype: OCC.wrapper.StepVisual.StepVisual_InvisibilityContext

        """
        return _StepVisual.Handle_StepVisual_ContextDependentInvisibility_PresentationContext(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_ContextDependentInvisibility self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_ContextDependentInvisibility_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_ContextDependentInvisibility_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_ContextDependentInvisibility_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetInvisibleItems(self, *args):
        """
        SetInvisibleItems(Handle_StepVisual_ContextDependentInvisibility self, Handle_StepVisual_HArray1OfInvisibleItem aInvisibleItems)

        :type aInvisibleItems: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfInvisibleItem

        """
        return _StepVisual.Handle_StepVisual_ContextDependentInvisibility_SetInvisibleItems(self, *args)


    def InvisibleItems(self, *args):
        """
        InvisibleItems(Handle_StepVisual_ContextDependentInvisibility self) -> Handle_StepVisual_HArray1OfInvisibleItem

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfInvisibleItem

        """
        return _StepVisual.Handle_StepVisual_ContextDependentInvisibility_InvisibleItems(self, *args)


    def InvisibleItemsValue(self, *args):
        """
        InvisibleItemsValue(Handle_StepVisual_ContextDependentInvisibility self, Standard_Integer const num) -> StepVisual_InvisibleItem

        :type num: int
        :rtype: OCC.wrapper.StepVisual.StepVisual_InvisibleItem

        """
        return _StepVisual.Handle_StepVisual_ContextDependentInvisibility_InvisibleItemsValue(self, *args)


    def NbInvisibleItems(self, *args):
        """
        NbInvisibleItems(Handle_StepVisual_ContextDependentInvisibility self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_ContextDependentInvisibility_NbInvisibleItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_ContextDependentInvisibility self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_ContextDependentInvisibility_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_ContextDependentInvisibility self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_ContextDependentInvisibility self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_ContextDependentInvisibility_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_ContextDependentInvisibility self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_ContextDependentInvisibility self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_ContextDependentInvisibility_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_ContextDependentInvisibility self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_ContextDependentInvisibility_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_ContextDependentInvisibility self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_ContextDependentInvisibility_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_ContextDependentInvisibility self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_ContextDependentInvisibility_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_ContextDependentInvisibility self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_ContextDependentInvisibility_DecrementRefCounter(self, *args)

Handle_StepVisual_ContextDependentInvisibility_swigregister = _StepVisual.Handle_StepVisual_ContextDependentInvisibility_swigregister
Handle_StepVisual_ContextDependentInvisibility_swigregister(Handle_StepVisual_ContextDependentInvisibility)

def Handle_StepVisual_ContextDependentInvisibility_DownCast(thing):
    return _StepVisual.Handle_StepVisual_ContextDependentInvisibility_DownCast(thing)
Handle_StepVisual_ContextDependentInvisibility_DownCast = _StepVisual.Handle_StepVisual_ContextDependentInvisibility_DownCast

class Handle_StepVisual_DraughtingAnnotationOccurrence(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_DraughtingAnnotationOccurrence self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_DraughtingAnnotationOccurrence self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_DraughtingAnnotationOccurrence self, StepVisual_DraughtingAnnotationOccurrence thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_DraughtingAnnotationOccurrence self, Handle_StepVisual_DraughtingAnnotationOccurrence theHandle) -> Handle_StepVisual_DraughtingAnnotationOccurrence
        assign(Handle_StepVisual_DraughtingAnnotationOccurrence self, StepVisual_DraughtingAnnotationOccurrence thePtr) -> Handle_StepVisual_DraughtingAnnotationOccurrence
        assign(Handle_StepVisual_DraughtingAnnotationOccurrence self, Handle_StepVisual_DraughtingAnnotationOccurrence theHandle) -> Handle_StepVisual_DraughtingAnnotationOccurrence

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_DraughtingAnnotationOccurrence self) -> StepVisual_DraughtingAnnotationOccurrence

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_DraughtingAnnotationOccurrence self) -> StepVisual_DraughtingAnnotationOccurrence

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_DraughtingAnnotationOccurrence self) -> StepVisual_DraughtingAnnotationOccurrence

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_DraughtingAnnotationOccurrence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_DraughtingAnnotationOccurrence

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_DraughtingAnnotationOccurrence self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_DraughtingAnnotationOccurrence self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_HArray1OfPresentationStyleAssignment aStyles, Handle_Standard_Transient aItem)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment
        :type aItem: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_Init(self, *args)


    def SetStyles(self, *args):
        """
        SetStyles(Handle_StepVisual_DraughtingAnnotationOccurrence self, Handle_StepVisual_HArray1OfPresentationStyleAssignment aStyles)

        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_SetStyles(self, *args)


    def Styles(self, *args):
        """
        Styles(Handle_StepVisual_DraughtingAnnotationOccurrence self) -> Handle_StepVisual_HArray1OfPresentationStyleAssignment

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_Styles(self, *args)


    def StylesValue(self, *args):
        """
        StylesValue(Handle_StepVisual_DraughtingAnnotationOccurrence self, Standard_Integer const num) -> Handle_StepVisual_PresentationStyleAssignment

        :type num: int
        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_StylesValue(self, *args)


    def NbStyles(self, *args):
        """
        NbStyles(Handle_StepVisual_DraughtingAnnotationOccurrence self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_NbStyles(self, *args)


    def SetItem(self, *args):
        """
        SetItem(Handle_StepVisual_DraughtingAnnotationOccurrence self, Handle_StepRepr_RepresentationItem aItem)
        SetItem(Handle_StepVisual_DraughtingAnnotationOccurrence self, StepVisual_StyledItemTarget aItem)

        :type aItem: OCC.wrapper.StepVisual.StepVisual_StyledItemTarget

        """
        return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_SetItem(self, *args)


    def Item(self, *args):
        """
        Item(Handle_StepVisual_DraughtingAnnotationOccurrence self) -> Handle_StepRepr_RepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_Item(self, *args)


    def ItemAP242(self, *args):
        """
        ItemAP242(Handle_StepVisual_DraughtingAnnotationOccurrence self) -> StepVisual_StyledItemTarget

        :rtype: OCC.wrapper.StepVisual.StepVisual_StyledItemTarget

        """
        return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_ItemAP242(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_DraughtingAnnotationOccurrence self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_DraughtingAnnotationOccurrence self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_DraughtingAnnotationOccurrence self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_DraughtingAnnotationOccurrence self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_DraughtingAnnotationOccurrence self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_DraughtingAnnotationOccurrence self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_DraughtingAnnotationOccurrence self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_DraughtingAnnotationOccurrence self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_DraughtingAnnotationOccurrence self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_DraughtingAnnotationOccurrence self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_DraughtingAnnotationOccurrence self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_DecrementRefCounter(self, *args)

Handle_StepVisual_DraughtingAnnotationOccurrence_swigregister = _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_swigregister
Handle_StepVisual_DraughtingAnnotationOccurrence_swigregister(Handle_StepVisual_DraughtingAnnotationOccurrence)

def Handle_StepVisual_DraughtingAnnotationOccurrence_DownCast(thing):
    return _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_DownCast(thing)
Handle_StepVisual_DraughtingAnnotationOccurrence_DownCast = _StepVisual.Handle_StepVisual_DraughtingAnnotationOccurrence_DownCast

class Handle_StepVisual_TemplateInstance(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_TemplateInstance self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_TemplateInstance_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_TemplateInstance self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_TemplateInstance_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_TemplateInstance self, StepVisual_TemplateInstance thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_TemplateInstance_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_TemplateInstance self, Handle_StepVisual_TemplateInstance theHandle) -> Handle_StepVisual_TemplateInstance
        assign(Handle_StepVisual_TemplateInstance self, StepVisual_TemplateInstance thePtr) -> Handle_StepVisual_TemplateInstance
        assign(Handle_StepVisual_TemplateInstance self, Handle_StepVisual_TemplateInstance theHandle) -> Handle_StepVisual_TemplateInstance

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_TemplateInstance_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_TemplateInstance self) -> StepVisual_TemplateInstance

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_TemplateInstance_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_TemplateInstance self) -> StepVisual_TemplateInstance

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_TemplateInstance___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_TemplateInstance self) -> StepVisual_TemplateInstance

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_TemplateInstance___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_TemplateInstance___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_TemplateInstance___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_TemplateInstance(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_TemplateInstance_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_TemplateInstance

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_TemplateInstance self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_TemplateInstance_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_TemplateInstance_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_TemplateInstance_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_TemplateInstance self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_RepresentationMap aMappingSource, Handle_StepRepr_RepresentationItem aMappingTarget)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aMappingSource: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationMap
        :type aMappingTarget: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_TemplateInstance_Init(self, *args)


    def SetMappingSource(self, *args):
        """
        SetMappingSource(Handle_StepVisual_TemplateInstance self, Handle_StepRepr_RepresentationMap aMappingSource)

        :type aMappingSource: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationMap

        """
        return _StepVisual.Handle_StepVisual_TemplateInstance_SetMappingSource(self, *args)


    def MappingSource(self, *args):
        """
        MappingSource(Handle_StepVisual_TemplateInstance self) -> Handle_StepRepr_RepresentationMap

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationMap

        """
        return _StepVisual.Handle_StepVisual_TemplateInstance_MappingSource(self, *args)


    def SetMappingTarget(self, *args):
        """
        SetMappingTarget(Handle_StepVisual_TemplateInstance self, Handle_StepRepr_RepresentationItem aMappingTarget)

        :type aMappingTarget: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_TemplateInstance_SetMappingTarget(self, *args)


    def MappingTarget(self, *args):
        """
        MappingTarget(Handle_StepVisual_TemplateInstance self) -> Handle_StepRepr_RepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_TemplateInstance_MappingTarget(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_TemplateInstance self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_TemplateInstance_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_TemplateInstance self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_TemplateInstance_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_TemplateInstance self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_TemplateInstance_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_TemplateInstance self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_TemplateInstance self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_TemplateInstance_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_TemplateInstance self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_TemplateInstance self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_TemplateInstance_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_TemplateInstance self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_TemplateInstance_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_TemplateInstance self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_TemplateInstance_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_TemplateInstance self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_TemplateInstance_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_TemplateInstance self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_TemplateInstance_DecrementRefCounter(self, *args)

Handle_StepVisual_TemplateInstance_swigregister = _StepVisual.Handle_StepVisual_TemplateInstance_swigregister
Handle_StepVisual_TemplateInstance_swigregister(Handle_StepVisual_TemplateInstance)

def Handle_StepVisual_TemplateInstance_DownCast(thing):
    return _StepVisual.Handle_StepVisual_TemplateInstance_DownCast(thing)
Handle_StepVisual_TemplateInstance_DownCast = _StepVisual.Handle_StepVisual_TemplateInstance_DownCast

class Handle_StepVisual_PresentationLayerUsage(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_PresentationLayerUsage self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_PresentationLayerUsage_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_PresentationLayerUsage self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerUsage_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_PresentationLayerUsage self, StepVisual_PresentationLayerUsage thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerUsage_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_PresentationLayerUsage self, Handle_StepVisual_PresentationLayerUsage theHandle) -> Handle_StepVisual_PresentationLayerUsage
        assign(Handle_StepVisual_PresentationLayerUsage self, StepVisual_PresentationLayerUsage thePtr) -> Handle_StepVisual_PresentationLayerUsage
        assign(Handle_StepVisual_PresentationLayerUsage self, Handle_StepVisual_PresentationLayerUsage theHandle) -> Handle_StepVisual_PresentationLayerUsage

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerUsage_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_PresentationLayerUsage self) -> StepVisual_PresentationLayerUsage

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerUsage_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_PresentationLayerUsage self) -> StepVisual_PresentationLayerUsage

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerUsage___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_PresentationLayerUsage self) -> StepVisual_PresentationLayerUsage

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerUsage___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_PresentationLayerUsage___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_PresentationLayerUsage___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_PresentationLayerUsage(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_PresentationLayerUsage_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_PresentationLayerUsage

    def Init(self, *args):
        """
        Init(Handle_StepVisual_PresentationLayerUsage self, Handle_StepVisual_PresentationLayerAssignment aAssignment, Handle_StepVisual_PresentationRepresentation aPresentation)

        :type aAssignment: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationLayerAssignment
        :type aPresentation: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationRepresentation

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerUsage_Init(self, *args)


    def SetAssignment(self, *args):
        """
        SetAssignment(Handle_StepVisual_PresentationLayerUsage self, Handle_StepVisual_PresentationLayerAssignment aAssignment)

        :type aAssignment: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationLayerAssignment

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerUsage_SetAssignment(self, *args)


    def Assignment(self, *args):
        """
        Assignment(Handle_StepVisual_PresentationLayerUsage self) -> Handle_StepVisual_PresentationLayerAssignment

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationLayerAssignment

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerUsage_Assignment(self, *args)


    def SetPresentation(self, *args):
        """
        SetPresentation(Handle_StepVisual_PresentationLayerUsage self, Handle_StepVisual_PresentationRepresentation aPresentation)

        :type aPresentation: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationRepresentation

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerUsage_SetPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_StepVisual_PresentationLayerUsage self) -> Handle_StepVisual_PresentationRepresentation

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationRepresentation

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerUsage_Presentation(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_PresentationLayerUsage self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerUsage_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PresentationLayerUsage_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PresentationLayerUsage_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_PresentationLayerUsage self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_PresentationLayerUsage_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_PresentationLayerUsage self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_PresentationLayerUsage self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerUsage_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_PresentationLayerUsage self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_PresentationLayerUsage self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerUsage_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_PresentationLayerUsage self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerUsage_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_PresentationLayerUsage self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerUsage_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_PresentationLayerUsage self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_PresentationLayerUsage_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_PresentationLayerUsage self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerUsage_DecrementRefCounter(self, *args)

Handle_StepVisual_PresentationLayerUsage_swigregister = _StepVisual.Handle_StepVisual_PresentationLayerUsage_swigregister
Handle_StepVisual_PresentationLayerUsage_swigregister(Handle_StepVisual_PresentationLayerUsage)

def Handle_StepVisual_PresentationLayerUsage_DownCast(thing):
    return _StepVisual.Handle_StepVisual_PresentationLayerUsage_DownCast(thing)
Handle_StepVisual_PresentationLayerUsage_DownCast = _StepVisual.Handle_StepVisual_PresentationLayerUsage_DownCast

class Handle_StepVisual_TextStyle(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_TextStyle self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_TextStyle_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_TextStyle self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_TextStyle_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_TextStyle self, StepVisual_TextStyle thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_TextStyle_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_TextStyle self, Handle_StepVisual_TextStyle theHandle) -> Handle_StepVisual_TextStyle
        assign(Handle_StepVisual_TextStyle self, StepVisual_TextStyle thePtr) -> Handle_StepVisual_TextStyle
        assign(Handle_StepVisual_TextStyle self, Handle_StepVisual_TextStyle theHandle) -> Handle_StepVisual_TextStyle

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_TextStyle_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_TextStyle self) -> StepVisual_TextStyle

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_TextStyle_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_TextStyle self) -> StepVisual_TextStyle

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_TextStyle___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_TextStyle self) -> StepVisual_TextStyle

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_TextStyle___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_TextStyle___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_TextStyle___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_TextStyle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_TextStyle_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_TextStyle

    def Init(self, *args):
        """
        Init(Handle_StepVisual_TextStyle self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_TextStyleForDefinedFont aCharacterAppearance)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aCharacterAppearance: OCC.wrapper.StepVisual.Handle_StepVisual_TextStyleForDefinedFont

        """
        return _StepVisual.Handle_StepVisual_TextStyle_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_TextStyle self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_TextStyle_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_TextStyle self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_TextStyle_Name(self, *args)


    def SetCharacterAppearance(self, *args):
        """
        SetCharacterAppearance(Handle_StepVisual_TextStyle self, Handle_StepVisual_TextStyleForDefinedFont aCharacterAppearance)

        :type aCharacterAppearance: OCC.wrapper.StepVisual.Handle_StepVisual_TextStyleForDefinedFont

        """
        return _StepVisual.Handle_StepVisual_TextStyle_SetCharacterAppearance(self, *args)


    def CharacterAppearance(self, *args):
        """
        CharacterAppearance(Handle_StepVisual_TextStyle self) -> Handle_StepVisual_TextStyleForDefinedFont

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_TextStyleForDefinedFont

        """
        return _StepVisual.Handle_StepVisual_TextStyle_CharacterAppearance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_TextStyle self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_TextStyle_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_TextStyle_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_TextStyle_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_TextStyle self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_TextStyle_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_TextStyle self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_TextStyle self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_TextStyle_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_TextStyle self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_TextStyle self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_TextStyle_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_TextStyle self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_TextStyle_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_TextStyle self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_TextStyle_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_TextStyle self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_TextStyle_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_TextStyle self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_TextStyle_DecrementRefCounter(self, *args)

Handle_StepVisual_TextStyle_swigregister = _StepVisual.Handle_StepVisual_TextStyle_swigregister
Handle_StepVisual_TextStyle_swigregister(Handle_StepVisual_TextStyle)

def Handle_StepVisual_TextStyle_DownCast(thing):
    return _StepVisual.Handle_StepVisual_TextStyle_DownCast(thing)
Handle_StepVisual_TextStyle_DownCast = _StepVisual.Handle_StepVisual_TextStyle_DownCast

class StepVisual_HArray1OfBoxCharacteristicSelect(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_HArray1OfBoxCharacteristicSelect
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_HArray1OfBoxCharacteristicSelect(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_HArray1OfBoxCharacteristicSelect self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepVisual_HArray1OfBoxCharacteristicSelect
        __init__(StepVisual_HArray1OfBoxCharacteristicSelect self, Standard_Integer const theLower, Standard_Integer const theUpper, StepVisual_BoxCharacteristicSelect theValue) -> StepVisual_HArray1OfBoxCharacteristicSelect
        __init__(StepVisual_HArray1OfBoxCharacteristicSelect self, NCollection_Array1_StepVisual_BoxCharacteristicSelect theOther) -> StepVisual_HArray1OfBoxCharacteristicSelect

        :type theOther: OCC.wrapper.StepVisual.StepVisual_Array1OfBoxCharacteristicSelect

        """
        this = _StepVisual.new_StepVisual_HArray1OfBoxCharacteristicSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfBoxCharacteristicSelect

        """
        res = _StepVisual.StepVisual_HArray1OfBoxCharacteristicSelect_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepVisual_HArray1OfBoxCharacteristicSelect self) -> NCollection_Array1_StepVisual_BoxCharacteristicSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfBoxCharacteristicSelect

        """
        return _StepVisual.StepVisual_HArray1OfBoxCharacteristicSelect_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_HArray1OfBoxCharacteristicSelect_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_HArray1OfBoxCharacteristicSelect_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_HArray1OfBoxCharacteristicSelect_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_HArray1OfBoxCharacteristicSelect
StepVisual_HArray1OfBoxCharacteristicSelect_swigregister = _StepVisual.StepVisual_HArray1OfBoxCharacteristicSelect_swigregister
StepVisual_HArray1OfBoxCharacteristicSelect_swigregister(StepVisual_HArray1OfBoxCharacteristicSelect)

def StepVisual_HArray1OfBoxCharacteristicSelect_get_type_name(*args):
    """
    StepVisual_HArray1OfBoxCharacteristicSelect_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_HArray1OfBoxCharacteristicSelect_get_type_name(*args)

def StepVisual_HArray1OfBoxCharacteristicSelect_get_type_descriptor(*args):
    """
    StepVisual_HArray1OfBoxCharacteristicSelect_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_HArray1OfBoxCharacteristicSelect_get_type_descriptor(*args)

class Handle_StepVisual_PresentationSize(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_PresentationSize self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_PresentationSize_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_PresentationSize self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_PresentationSize_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_PresentationSize self, StepVisual_PresentationSize thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationSize_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_PresentationSize self, Handle_StepVisual_PresentationSize theHandle) -> Handle_StepVisual_PresentationSize
        assign(Handle_StepVisual_PresentationSize self, StepVisual_PresentationSize thePtr) -> Handle_StepVisual_PresentationSize
        assign(Handle_StepVisual_PresentationSize self, Handle_StepVisual_PresentationSize theHandle) -> Handle_StepVisual_PresentationSize

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_PresentationSize_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_PresentationSize self) -> StepVisual_PresentationSize

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationSize_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_PresentationSize self) -> StepVisual_PresentationSize

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationSize___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_PresentationSize self) -> StepVisual_PresentationSize

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_PresentationSize___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_PresentationSize___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_PresentationSize___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_PresentationSize(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_PresentationSize_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_PresentationSize

    def Init(self, *args):
        """
        Init(Handle_StepVisual_PresentationSize self, StepVisual_PresentationSizeAssignmentSelect aUnit, Handle_StepVisual_PlanarBox aSize)

        :type aUnit: OCC.wrapper.StepVisual.StepVisual_PresentationSizeAssignmentSelect
        :type aSize: OCC.wrapper.StepVisual.Handle_StepVisual_PlanarBox

        """
        return _StepVisual.Handle_StepVisual_PresentationSize_Init(self, *args)


    def SetUnit(self, *args):
        """
        SetUnit(Handle_StepVisual_PresentationSize self, StepVisual_PresentationSizeAssignmentSelect aUnit)

        :type aUnit: OCC.wrapper.StepVisual.StepVisual_PresentationSizeAssignmentSelect

        """
        return _StepVisual.Handle_StepVisual_PresentationSize_SetUnit(self, *args)


    def Unit(self, *args):
        """
        Unit(Handle_StepVisual_PresentationSize self) -> StepVisual_PresentationSizeAssignmentSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_PresentationSizeAssignmentSelect

        """
        return _StepVisual.Handle_StepVisual_PresentationSize_Unit(self, *args)


    def SetSize(self, *args):
        """
        SetSize(Handle_StepVisual_PresentationSize self, Handle_StepVisual_PlanarBox aSize)

        :type aSize: OCC.wrapper.StepVisual.Handle_StepVisual_PlanarBox

        """
        return _StepVisual.Handle_StepVisual_PresentationSize_SetSize(self, *args)


    def Size(self, *args):
        """
        Size(Handle_StepVisual_PresentationSize self) -> Handle_StepVisual_PlanarBox

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PlanarBox

        """
        return _StepVisual.Handle_StepVisual_PresentationSize_Size(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_PresentationSize self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_PresentationSize_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PresentationSize_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PresentationSize_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_PresentationSize self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_PresentationSize_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_PresentationSize self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_PresentationSize self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PresentationSize_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_PresentationSize self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_PresentationSize self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PresentationSize_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_PresentationSize self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_PresentationSize_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_PresentationSize self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentationSize_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_PresentationSize self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_PresentationSize_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_PresentationSize self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentationSize_DecrementRefCounter(self, *args)

Handle_StepVisual_PresentationSize_swigregister = _StepVisual.Handle_StepVisual_PresentationSize_swigregister
Handle_StepVisual_PresentationSize_swigregister(Handle_StepVisual_PresentationSize)

def Handle_StepVisual_PresentationSize_DownCast(thing):
    return _StepVisual.Handle_StepVisual_PresentationSize_DownCast(thing)
Handle_StepVisual_PresentationSize_DownCast = _StepVisual.Handle_StepVisual_PresentationSize_DownCast

class StepVisual_NullStyleMember(StepData.StepData_SelectInt):
    """
    Defines NullStyle as unique member of PresentationStyleSelect
    Works with an EnumTool
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_NullStyleMember
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_NullStyleMember(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_NullStyleMember self) -> StepVisual_NullStyleMember

        Defines NullStyle as unique member of PresentationStyleSelect
        Works with an EnumTool
        """
        this = _StepVisual.new_StepVisual_NullStyleMember(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def HasName(self, *args):
        """
        HasName(StepVisual_NullStyleMember self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.StepVisual_NullStyleMember_HasName(self, *args)


    def Name(self, *args):
        """
        Name(StepVisual_NullStyleMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepVisual.StepVisual_NullStyleMember_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepVisual_NullStyleMember self, Standard_CString const arg2) -> Standard_Boolean

        :type : OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.StepVisual_NullStyleMember_SetName(self, *args)


    def Kind(self, *args):
        """
        Kind(StepVisual_NullStyleMember self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_NullStyleMember_Kind(self, *args)


    def EnumText(self, *args):
        """
        EnumText(StepVisual_NullStyleMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepVisual.StepVisual_NullStyleMember_EnumText(self, *args)


    def SetEnumText(self, *args):
        """
        SetEnumText(StepVisual_NullStyleMember self, Standard_Integer const theValue, Standard_CString const theText)

        :type theValue: int
        :type theText: OCC.wrapper.Standard.Standard_CString

        """
        return _StepVisual.StepVisual_NullStyleMember_SetEnumText(self, *args)


    def SetValue(self, *args):
        """
        SetValue(StepVisual_NullStyleMember self, StepVisual_NullStyle const theValue)

        :type theValue: OCC.wrapper.StepVisual.StepVisual_NullStyle

        """
        return _StepVisual.StepVisual_NullStyleMember_SetValue(self, *args)


    def Value(self, *args):
        """
        Value(StepVisual_NullStyleMember self) -> StepVisual_NullStyle

        :rtype: OCC.wrapper.StepVisual.StepVisual_NullStyle

        """
        return _StepVisual.StepVisual_NullStyleMember_Value(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_NullStyleMember_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_NullStyleMember_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_NullStyleMember_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_NullStyleMember
StepVisual_NullStyleMember_swigregister = _StepVisual.StepVisual_NullStyleMember_swigregister
StepVisual_NullStyleMember_swigregister(StepVisual_NullStyleMember)

def StepVisual_NullStyleMember_get_type_name(*args):
    """
    StepVisual_NullStyleMember_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_NullStyleMember_get_type_name(*args)

def StepVisual_NullStyleMember_get_type_descriptor(*args):
    """
    StepVisual_NullStyleMember_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_NullStyleMember_get_type_descriptor(*args)

class Handle_StepVisual_PresentedItem(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_PresentedItem self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_PresentedItem_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_PresentedItem self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_PresentedItem_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_PresentedItem self, StepVisual_PresentedItem thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_PresentedItem_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_PresentedItem self, Handle_StepVisual_PresentedItem theHandle) -> Handle_StepVisual_PresentedItem
        assign(Handle_StepVisual_PresentedItem self, StepVisual_PresentedItem thePtr) -> Handle_StepVisual_PresentedItem
        assign(Handle_StepVisual_PresentedItem self, Handle_StepVisual_PresentedItem theHandle) -> Handle_StepVisual_PresentedItem

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_PresentedItem_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_PresentedItem self) -> StepVisual_PresentedItem

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PresentedItem_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_PresentedItem self) -> StepVisual_PresentedItem

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PresentedItem___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_PresentedItem self) -> StepVisual_PresentedItem

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_PresentedItem___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_PresentedItem___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_PresentedItem___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_PresentedItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_PresentedItem_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_PresentedItem

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_PresentedItem self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_PresentedItem_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PresentedItem_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PresentedItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_PresentedItem self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_PresentedItem_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_PresentedItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_PresentedItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PresentedItem_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_PresentedItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_PresentedItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PresentedItem_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_PresentedItem self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_PresentedItem_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_PresentedItem self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentedItem_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_PresentedItem self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_PresentedItem_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_PresentedItem self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentedItem_DecrementRefCounter(self, *args)

Handle_StepVisual_PresentedItem_swigregister = _StepVisual.Handle_StepVisual_PresentedItem_swigregister
Handle_StepVisual_PresentedItem_swigregister(Handle_StepVisual_PresentedItem)

def Handle_StepVisual_PresentedItem_DownCast(thing):
    return _StepVisual.Handle_StepVisual_PresentedItem_DownCast(thing)
Handle_StepVisual_PresentedItem_DownCast = _StepVisual.Handle_StepVisual_PresentedItem_DownCast

class Handle_StepVisual_HArray1OfAnnotationPlaneElement(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_HArray1OfAnnotationPlaneElement self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_HArray1OfAnnotationPlaneElement self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_HArray1OfAnnotationPlaneElement self, StepVisual_HArray1OfAnnotationPlaneElement thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_HArray1OfAnnotationPlaneElement self, Handle_StepVisual_HArray1OfAnnotationPlaneElement theHandle) -> Handle_StepVisual_HArray1OfAnnotationPlaneElement
        assign(Handle_StepVisual_HArray1OfAnnotationPlaneElement self, StepVisual_HArray1OfAnnotationPlaneElement thePtr) -> Handle_StepVisual_HArray1OfAnnotationPlaneElement
        assign(Handle_StepVisual_HArray1OfAnnotationPlaneElement self, Handle_StepVisual_HArray1OfAnnotationPlaneElement theHandle) -> Handle_StepVisual_HArray1OfAnnotationPlaneElement

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_HArray1OfAnnotationPlaneElement self) -> StepVisual_HArray1OfAnnotationPlaneElement

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_HArray1OfAnnotationPlaneElement self) -> StepVisual_HArray1OfAnnotationPlaneElement

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_HArray1OfAnnotationPlaneElement self) -> StepVisual_HArray1OfAnnotationPlaneElement

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_HArray1OfAnnotationPlaneElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_HArray1OfAnnotationPlaneElement

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfAnnotationPlaneElement

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepVisual_HArray1OfAnnotationPlaneElement self) -> NCollection_Array1_StepVisual_AnnotationPlaneElement

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfAnnotationPlaneElement

        """
        return _StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_HArray1OfAnnotationPlaneElement self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_HArray1OfAnnotationPlaneElement self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_HArray1OfAnnotationPlaneElement self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_HArray1OfAnnotationPlaneElement self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_HArray1OfAnnotationPlaneElement self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_HArray1OfAnnotationPlaneElement self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_HArray1OfAnnotationPlaneElement self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_HArray1OfAnnotationPlaneElement self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_HArray1OfAnnotationPlaneElement self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_HArray1OfAnnotationPlaneElement self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement_DecrementRefCounter(self, *args)

Handle_StepVisual_HArray1OfAnnotationPlaneElement_swigregister = _StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement_swigregister
Handle_StepVisual_HArray1OfAnnotationPlaneElement_swigregister(Handle_StepVisual_HArray1OfAnnotationPlaneElement)

def Handle_StepVisual_HArray1OfAnnotationPlaneElement_DownCast(thing):
    return _StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement_DownCast(thing)
Handle_StepVisual_HArray1OfAnnotationPlaneElement_DownCast = _StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement_DownCast

class Handle_StepVisual_HArray1OfStyleContextSelect(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_HArray1OfStyleContextSelect self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_HArray1OfStyleContextSelect self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_HArray1OfStyleContextSelect self, StepVisual_HArray1OfStyleContextSelect thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_HArray1OfStyleContextSelect self, Handle_StepVisual_HArray1OfStyleContextSelect theHandle) -> Handle_StepVisual_HArray1OfStyleContextSelect
        assign(Handle_StepVisual_HArray1OfStyleContextSelect self, StepVisual_HArray1OfStyleContextSelect thePtr) -> Handle_StepVisual_HArray1OfStyleContextSelect
        assign(Handle_StepVisual_HArray1OfStyleContextSelect self, Handle_StepVisual_HArray1OfStyleContextSelect theHandle) -> Handle_StepVisual_HArray1OfStyleContextSelect

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_HArray1OfStyleContextSelect self) -> StepVisual_HArray1OfStyleContextSelect

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_HArray1OfStyleContextSelect self) -> StepVisual_HArray1OfStyleContextSelect

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_HArray1OfStyleContextSelect self) -> StepVisual_HArray1OfStyleContextSelect

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_HArray1OfStyleContextSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_HArray1OfStyleContextSelect

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfStyleContextSelect

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepVisual_HArray1OfStyleContextSelect self) -> NCollection_Array1_StepVisual_StyleContextSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfStyleContextSelect

        """
        return _StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_HArray1OfStyleContextSelect self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_HArray1OfStyleContextSelect self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_HArray1OfStyleContextSelect self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_HArray1OfStyleContextSelect self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_HArray1OfStyleContextSelect self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_HArray1OfStyleContextSelect self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_HArray1OfStyleContextSelect self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_HArray1OfStyleContextSelect self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_HArray1OfStyleContextSelect self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_HArray1OfStyleContextSelect self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect_DecrementRefCounter(self, *args)

Handle_StepVisual_HArray1OfStyleContextSelect_swigregister = _StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect_swigregister
Handle_StepVisual_HArray1OfStyleContextSelect_swigregister(Handle_StepVisual_HArray1OfStyleContextSelect)

def Handle_StepVisual_HArray1OfStyleContextSelect_DownCast(thing):
    return _StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect_DownCast(thing)
Handle_StepVisual_HArray1OfStyleContextSelect_DownCast = _StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect_DownCast

class Handle_StepVisual_AnnotationPlane(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_AnnotationPlane self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_AnnotationPlane self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_AnnotationPlane self, StepVisual_AnnotationPlane thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_AnnotationPlane self, Handle_StepVisual_AnnotationPlane theHandle) -> Handle_StepVisual_AnnotationPlane
        assign(Handle_StepVisual_AnnotationPlane self, StepVisual_AnnotationPlane thePtr) -> Handle_StepVisual_AnnotationPlane
        assign(Handle_StepVisual_AnnotationPlane self, Handle_StepVisual_AnnotationPlane theHandle) -> Handle_StepVisual_AnnotationPlane

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_AnnotationPlane self) -> StepVisual_AnnotationPlane

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_AnnotationPlane self) -> StepVisual_AnnotationPlane

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_AnnotationPlane self) -> StepVisual_AnnotationPlane

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_AnnotationPlane___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_AnnotationPlane___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_AnnotationPlane(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_AnnotationPlane_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_AnnotationPlane

    def Init(self, *args):
        """
        Init(Handle_StepVisual_AnnotationPlane self, Handle_TCollection_HAsciiString theName, Handle_StepVisual_HArray1OfPresentationStyleAssignment theStyles, Handle_Standard_Transient theItem, Handle_StepVisual_HArray1OfAnnotationPlaneElement theElements)

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment
        :type theItem: OCC.wrapper.Standard.Handle_Standard_Transient
        :type theElements: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_Init(self, *args)


    def Elements(self, *args):
        """
        Elements(Handle_StepVisual_AnnotationPlane self) -> Handle_StepVisual_HArray1OfAnnotationPlaneElement

        Returns field Elements

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_Elements(self, *args)


    def SetElements(self, *args):
        """
        SetElements(Handle_StepVisual_AnnotationPlane self, Handle_StepVisual_HArray1OfAnnotationPlaneElement theElements)

        Set field Elements

        :type theElements: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfAnnotationPlaneElement

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_SetElements(self, *args)


    def NbElements(self, *args):
        """
        NbElements(Handle_StepVisual_AnnotationPlane self) -> Standard_Integer

        Returns number of Elements

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_NbElements(self, *args)


    def ElementsValue(self, *args):
        """
        ElementsValue(Handle_StepVisual_AnnotationPlane self, Standard_Integer const theNum) -> StepVisual_AnnotationPlaneElement

        Returns Elements with the given number

        :type theNum: int
        :rtype: OCC.wrapper.StepVisual.StepVisual_AnnotationPlaneElement

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_ElementsValue(self, *args)


    def SetElementsValue(self, *args):
        """
        SetElementsValue(Handle_StepVisual_AnnotationPlane self, Standard_Integer const theNum, StepVisual_AnnotationPlaneElement theItem)

        Sets Elements with given number

        :type theNum: int
        :type theItem: OCC.wrapper.StepVisual.StepVisual_AnnotationPlaneElement

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_SetElementsValue(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_AnnotationPlane self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_AnnotationPlane_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_AnnotationPlane_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetStyles(self, *args):
        """
        SetStyles(Handle_StepVisual_AnnotationPlane self, Handle_StepVisual_HArray1OfPresentationStyleAssignment aStyles)

        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_SetStyles(self, *args)


    def Styles(self, *args):
        """
        Styles(Handle_StepVisual_AnnotationPlane self) -> Handle_StepVisual_HArray1OfPresentationStyleAssignment

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_Styles(self, *args)


    def StylesValue(self, *args):
        """
        StylesValue(Handle_StepVisual_AnnotationPlane self, Standard_Integer const num) -> Handle_StepVisual_PresentationStyleAssignment

        :type num: int
        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_StylesValue(self, *args)


    def NbStyles(self, *args):
        """
        NbStyles(Handle_StepVisual_AnnotationPlane self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_NbStyles(self, *args)


    def SetItem(self, *args):
        """
        SetItem(Handle_StepVisual_AnnotationPlane self, Handle_StepRepr_RepresentationItem aItem)
        SetItem(Handle_StepVisual_AnnotationPlane self, StepVisual_StyledItemTarget aItem)

        :type aItem: OCC.wrapper.StepVisual.StepVisual_StyledItemTarget

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_SetItem(self, *args)


    def Item(self, *args):
        """
        Item(Handle_StepVisual_AnnotationPlane self) -> Handle_StepRepr_RepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_Item(self, *args)


    def ItemAP242(self, *args):
        """
        ItemAP242(Handle_StepVisual_AnnotationPlane self) -> StepVisual_StyledItemTarget

        :rtype: OCC.wrapper.StepVisual.StepVisual_StyledItemTarget

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_ItemAP242(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_AnnotationPlane self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_AnnotationPlane self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_AnnotationPlane self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_AnnotationPlane self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_AnnotationPlane self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_AnnotationPlane self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_AnnotationPlane self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_AnnotationPlane self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_AnnotationPlane self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_AnnotationPlane self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_AnnotationPlane self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_AnnotationPlane_DecrementRefCounter(self, *args)

Handle_StepVisual_AnnotationPlane_swigregister = _StepVisual.Handle_StepVisual_AnnotationPlane_swigregister
Handle_StepVisual_AnnotationPlane_swigregister(Handle_StepVisual_AnnotationPlane)

def Handle_StepVisual_AnnotationPlane_DownCast(thing):
    return _StepVisual.Handle_StepVisual_AnnotationPlane_DownCast(thing)
Handle_StepVisual_AnnotationPlane_DownCast = _StepVisual.Handle_StepVisual_AnnotationPlane_DownCast

class Handle_StepVisual_PresentedItemRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_PresentedItemRepresentation self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_PresentedItemRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_PresentedItemRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_PresentedItemRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_PresentedItemRepresentation self, StepVisual_PresentedItemRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_PresentedItemRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_PresentedItemRepresentation self, Handle_StepVisual_PresentedItemRepresentation theHandle) -> Handle_StepVisual_PresentedItemRepresentation
        assign(Handle_StepVisual_PresentedItemRepresentation self, StepVisual_PresentedItemRepresentation thePtr) -> Handle_StepVisual_PresentedItemRepresentation
        assign(Handle_StepVisual_PresentedItemRepresentation self, Handle_StepVisual_PresentedItemRepresentation theHandle) -> Handle_StepVisual_PresentedItemRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_PresentedItemRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_PresentedItemRepresentation self) -> StepVisual_PresentedItemRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PresentedItemRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_PresentedItemRepresentation self) -> StepVisual_PresentedItemRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PresentedItemRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_PresentedItemRepresentation self) -> StepVisual_PresentedItemRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_PresentedItemRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_PresentedItemRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_PresentedItemRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_PresentedItemRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_PresentedItemRepresentation_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_PresentedItemRepresentation

    def Init(self, *args):
        """
        Init(Handle_StepVisual_PresentedItemRepresentation self, StepVisual_PresentationRepresentationSelect aPresentation, Handle_StepVisual_PresentedItem aItem)

        :type aPresentation: OCC.wrapper.StepVisual.StepVisual_PresentationRepresentationSelect
        :type aItem: OCC.wrapper.StepVisual.Handle_StepVisual_PresentedItem

        """
        return _StepVisual.Handle_StepVisual_PresentedItemRepresentation_Init(self, *args)


    def SetPresentation(self, *args):
        """
        SetPresentation(Handle_StepVisual_PresentedItemRepresentation self, StepVisual_PresentationRepresentationSelect aPresentation)

        :type aPresentation: OCC.wrapper.StepVisual.StepVisual_PresentationRepresentationSelect

        """
        return _StepVisual.Handle_StepVisual_PresentedItemRepresentation_SetPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_StepVisual_PresentedItemRepresentation self) -> StepVisual_PresentationRepresentationSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_PresentationRepresentationSelect

        """
        return _StepVisual.Handle_StepVisual_PresentedItemRepresentation_Presentation(self, *args)


    def SetItem(self, *args):
        """
        SetItem(Handle_StepVisual_PresentedItemRepresentation self, Handle_StepVisual_PresentedItem aItem)

        :type aItem: OCC.wrapper.StepVisual.Handle_StepVisual_PresentedItem

        """
        return _StepVisual.Handle_StepVisual_PresentedItemRepresentation_SetItem(self, *args)


    def Item(self, *args):
        """
        Item(Handle_StepVisual_PresentedItemRepresentation self) -> Handle_StepVisual_PresentedItem

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentedItem

        """
        return _StepVisual.Handle_StepVisual_PresentedItemRepresentation_Item(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_PresentedItemRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_PresentedItemRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PresentedItemRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PresentedItemRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_PresentedItemRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_PresentedItemRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_PresentedItemRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_PresentedItemRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PresentedItemRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_PresentedItemRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_PresentedItemRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PresentedItemRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_PresentedItemRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_PresentedItemRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_PresentedItemRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentedItemRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_PresentedItemRepresentation self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_PresentedItemRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_PresentedItemRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentedItemRepresentation_DecrementRefCounter(self, *args)

Handle_StepVisual_PresentedItemRepresentation_swigregister = _StepVisual.Handle_StepVisual_PresentedItemRepresentation_swigregister
Handle_StepVisual_PresentedItemRepresentation_swigregister(Handle_StepVisual_PresentedItemRepresentation)

def Handle_StepVisual_PresentedItemRepresentation_DownCast(thing):
    return _StepVisual.Handle_StepVisual_PresentedItemRepresentation_DownCast(thing)
Handle_StepVisual_PresentedItemRepresentation_DownCast = _StepVisual.Handle_StepVisual_PresentedItemRepresentation_DownCast

class Handle_StepVisual_HArray1OfPresentationStyleSelect(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_HArray1OfPresentationStyleSelect self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_HArray1OfPresentationStyleSelect self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_HArray1OfPresentationStyleSelect self, StepVisual_HArray1OfPresentationStyleSelect thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_HArray1OfPresentationStyleSelect self, Handle_StepVisual_HArray1OfPresentationStyleSelect theHandle) -> Handle_StepVisual_HArray1OfPresentationStyleSelect
        assign(Handle_StepVisual_HArray1OfPresentationStyleSelect self, StepVisual_HArray1OfPresentationStyleSelect thePtr) -> Handle_StepVisual_HArray1OfPresentationStyleSelect
        assign(Handle_StepVisual_HArray1OfPresentationStyleSelect self, Handle_StepVisual_HArray1OfPresentationStyleSelect theHandle) -> Handle_StepVisual_HArray1OfPresentationStyleSelect

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_HArray1OfPresentationStyleSelect self) -> StepVisual_HArray1OfPresentationStyleSelect

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_HArray1OfPresentationStyleSelect self) -> StepVisual_HArray1OfPresentationStyleSelect

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_HArray1OfPresentationStyleSelect self) -> StepVisual_HArray1OfPresentationStyleSelect

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_HArray1OfPresentationStyleSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_HArray1OfPresentationStyleSelect

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfPresentationStyleSelect

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepVisual_HArray1OfPresentationStyleSelect self) -> NCollection_Array1_StepVisual_PresentationStyleSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfPresentationStyleSelect

        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_HArray1OfPresentationStyleSelect self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_HArray1OfPresentationStyleSelect self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_HArray1OfPresentationStyleSelect self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_HArray1OfPresentationStyleSelect self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_HArray1OfPresentationStyleSelect self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_HArray1OfPresentationStyleSelect self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_HArray1OfPresentationStyleSelect self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_HArray1OfPresentationStyleSelect self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_HArray1OfPresentationStyleSelect self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_HArray1OfPresentationStyleSelect self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect_DecrementRefCounter(self, *args)

Handle_StepVisual_HArray1OfPresentationStyleSelect_swigregister = _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect_swigregister
Handle_StepVisual_HArray1OfPresentationStyleSelect_swigregister(Handle_StepVisual_HArray1OfPresentationStyleSelect)

def Handle_StepVisual_HArray1OfPresentationStyleSelect_DownCast(thing):
    return _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect_DownCast(thing)
Handle_StepVisual_HArray1OfPresentationStyleSelect_DownCast = _StepVisual.Handle_StepVisual_HArray1OfPresentationStyleSelect_DownCast

class Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self, StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self, Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation theHandle) -> Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation
        assign(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self, StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation thePtr) -> Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation
        assign(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self, Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation theHandle) -> Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self) -> StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self) -> StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self) -> StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_HArray1OfRepresentationItem aItems, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_DecrementRefCounter(self, *args)

Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_swigregister = _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_swigregister
Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_swigregister(Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation)

def Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_DownCast(thing):
    return _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_DownCast(thing)
Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_DownCast = _StepVisual.Handle_StepVisual_CharacterizedObjectAndCharacterizedRepresentationAndDraughtingModelAndRepresentation_DownCast

class Handle_StepVisual_ColourRgb(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_ColourRgb self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_ColourRgb_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_ColourRgb self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_ColourRgb_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_ColourRgb self, StepVisual_ColourRgb thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_ColourRgb_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_ColourRgb self, Handle_StepVisual_ColourRgb theHandle) -> Handle_StepVisual_ColourRgb
        assign(Handle_StepVisual_ColourRgb self, StepVisual_ColourRgb thePtr) -> Handle_StepVisual_ColourRgb
        assign(Handle_StepVisual_ColourRgb self, Handle_StepVisual_ColourRgb theHandle) -> Handle_StepVisual_ColourRgb

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_ColourRgb_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_ColourRgb self) -> StepVisual_ColourRgb

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_ColourRgb_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_ColourRgb self) -> StepVisual_ColourRgb

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_ColourRgb___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_ColourRgb self) -> StepVisual_ColourRgb

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_ColourRgb___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_ColourRgb___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_ColourRgb___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_ColourRgb(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_ColourRgb_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_ColourRgb

    def Init(self, *args):
        """
        Init(Handle_StepVisual_ColourRgb self, Handle_TCollection_HAsciiString aName, Standard_Real const aRed, Standard_Real const aGreen, Standard_Real const aBlue)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRed: float
        :type aGreen: float
        :type aBlue: float

        """
        return _StepVisual.Handle_StepVisual_ColourRgb_Init(self, *args)


    def SetRed(self, *args):
        """
        SetRed(Handle_StepVisual_ColourRgb self, Standard_Real const aRed)

        :type aRed: float

        """
        return _StepVisual.Handle_StepVisual_ColourRgb_SetRed(self, *args)


    def Red(self, *args):
        """
        Red(Handle_StepVisual_ColourRgb self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepVisual.Handle_StepVisual_ColourRgb_Red(self, *args)


    def SetGreen(self, *args):
        """
        SetGreen(Handle_StepVisual_ColourRgb self, Standard_Real const aGreen)

        :type aGreen: float

        """
        return _StepVisual.Handle_StepVisual_ColourRgb_SetGreen(self, *args)


    def Green(self, *args):
        """
        Green(Handle_StepVisual_ColourRgb self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepVisual.Handle_StepVisual_ColourRgb_Green(self, *args)


    def SetBlue(self, *args):
        """
        SetBlue(Handle_StepVisual_ColourRgb self, Standard_Real const aBlue)

        :type aBlue: float

        """
        return _StepVisual.Handle_StepVisual_ColourRgb_SetBlue(self, *args)


    def Blue(self, *args):
        """
        Blue(Handle_StepVisual_ColourRgb self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepVisual.Handle_StepVisual_ColourRgb_Blue(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_ColourRgb self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_ColourRgb_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_ColourRgb_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_ColourRgb_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_ColourRgb self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_ColourRgb_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_ColourRgb self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_ColourRgb_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_ColourRgb self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_ColourRgb_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_ColourRgb self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_ColourRgb self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_ColourRgb_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_ColourRgb self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_ColourRgb self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_ColourRgb_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_ColourRgb self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_ColourRgb_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_ColourRgb self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_ColourRgb_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_ColourRgb self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_ColourRgb_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_ColourRgb self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_ColourRgb_DecrementRefCounter(self, *args)

Handle_StepVisual_ColourRgb_swigregister = _StepVisual.Handle_StepVisual_ColourRgb_swigregister
Handle_StepVisual_ColourRgb_swigregister(Handle_StepVisual_ColourRgb)

def Handle_StepVisual_ColourRgb_DownCast(thing):
    return _StepVisual.Handle_StepVisual_ColourRgb_DownCast(thing)
Handle_StepVisual_ColourRgb_DownCast = _StepVisual.Handle_StepVisual_ColourRgb_DownCast

class NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect self) -> NCollection_Array1< StepVisual_CameraModelD3MultiClippingInterectionSelect >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect self) -> NCollection_Array1< StepVisual_CameraModelD3MultiClippingInterectionSelect >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect self) -> NCollection_Array1< StepVisual_CameraModelD3MultiClippingInterectionSelect >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect self) -> NCollection_Array1< StepVisual_CameraModelD3MultiClippingInterectionSelect >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepVisual.new_NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect self, StepVisual_CameraModelD3MultiClippingInterectionSelect theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect self, NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect theOther) -> NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect self, NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect theOther) -> NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect self, NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect theOther) -> NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect
        assign(NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect self, NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect theOther) -> NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect self) -> StepVisual_CameraModelD3MultiClippingInterectionSelect

        @return first element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect self) -> StepVisual_CameraModelD3MultiClippingInterectionSelect

        @return last element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect self, Standard_Integer const theIndex) -> StepVisual_CameraModelD3MultiClippingInterectionSelect

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect self, Standard_Integer const theIndex, StepVisual_CameraModelD3MultiClippingInterectionSelect theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_Resize(self, *args)

    __swig_destroy__ = _StepVisual.delete_NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect
NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_swigregister = _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_swigregister
NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect_swigregister(NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect)


try:
	StepVisual_Array1OfCameraModelD3MultiClippingInterectionSelect = NCollection_Array1_StepVisual_CameraModelD3MultiClippingInterectionSelect
except NameError:
	pass # does not exist, probably ignored

class Handle_StepVisual_OverRidingStyledItem(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_OverRidingStyledItem self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_OverRidingStyledItem self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_OverRidingStyledItem self, StepVisual_OverRidingStyledItem thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_OverRidingStyledItem self, Handle_StepVisual_OverRidingStyledItem theHandle) -> Handle_StepVisual_OverRidingStyledItem
        assign(Handle_StepVisual_OverRidingStyledItem self, StepVisual_OverRidingStyledItem thePtr) -> Handle_StepVisual_OverRidingStyledItem
        assign(Handle_StepVisual_OverRidingStyledItem self, Handle_StepVisual_OverRidingStyledItem theHandle) -> Handle_StepVisual_OverRidingStyledItem

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_OverRidingStyledItem self) -> StepVisual_OverRidingStyledItem

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_OverRidingStyledItem self) -> StepVisual_OverRidingStyledItem

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_OverRidingStyledItem self) -> StepVisual_OverRidingStyledItem

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_OverRidingStyledItem___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_OverRidingStyledItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_OverRidingStyledItem_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_OverRidingStyledItem

    def Init(self, *args):
        """
        Init(Handle_StepVisual_OverRidingStyledItem self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_HArray1OfPresentationStyleAssignment aStyles, Handle_Standard_Transient aItem, Handle_StepVisual_StyledItem aOverRiddenStyle)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment
        :type aItem: OCC.wrapper.Standard.Handle_Standard_Transient
        :type aOverRiddenStyle: OCC.wrapper.StepVisual.Handle_StepVisual_StyledItem

        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem_Init(self, *args)


    def SetOverRiddenStyle(self, *args):
        """
        SetOverRiddenStyle(Handle_StepVisual_OverRidingStyledItem self, Handle_StepVisual_StyledItem aOverRiddenStyle)

        :type aOverRiddenStyle: OCC.wrapper.StepVisual.Handle_StepVisual_StyledItem

        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem_SetOverRiddenStyle(self, *args)


    def OverRiddenStyle(self, *args):
        """
        OverRiddenStyle(Handle_StepVisual_OverRidingStyledItem self) -> Handle_StepVisual_StyledItem

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_StyledItem

        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem_OverRiddenStyle(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_OverRidingStyledItem self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_OverRidingStyledItem_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_OverRidingStyledItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetStyles(self, *args):
        """
        SetStyles(Handle_StepVisual_OverRidingStyledItem self, Handle_StepVisual_HArray1OfPresentationStyleAssignment aStyles)

        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem_SetStyles(self, *args)


    def Styles(self, *args):
        """
        Styles(Handle_StepVisual_OverRidingStyledItem self) -> Handle_StepVisual_HArray1OfPresentationStyleAssignment

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem_Styles(self, *args)


    def StylesValue(self, *args):
        """
        StylesValue(Handle_StepVisual_OverRidingStyledItem self, Standard_Integer const num) -> Handle_StepVisual_PresentationStyleAssignment

        :type num: int
        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem_StylesValue(self, *args)


    def NbStyles(self, *args):
        """
        NbStyles(Handle_StepVisual_OverRidingStyledItem self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem_NbStyles(self, *args)


    def SetItem(self, *args):
        """
        SetItem(Handle_StepVisual_OverRidingStyledItem self, Handle_StepRepr_RepresentationItem aItem)
        SetItem(Handle_StepVisual_OverRidingStyledItem self, StepVisual_StyledItemTarget aItem)

        :type aItem: OCC.wrapper.StepVisual.StepVisual_StyledItemTarget

        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem_SetItem(self, *args)


    def Item(self, *args):
        """
        Item(Handle_StepVisual_OverRidingStyledItem self) -> Handle_StepRepr_RepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem_Item(self, *args)


    def ItemAP242(self, *args):
        """
        ItemAP242(Handle_StepVisual_OverRidingStyledItem self) -> StepVisual_StyledItemTarget

        :rtype: OCC.wrapper.StepVisual.StepVisual_StyledItemTarget

        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem_ItemAP242(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_OverRidingStyledItem self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_OverRidingStyledItem self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_OverRidingStyledItem self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_OverRidingStyledItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_OverRidingStyledItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_OverRidingStyledItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_OverRidingStyledItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_OverRidingStyledItem self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_OverRidingStyledItem self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_OverRidingStyledItem self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_OverRidingStyledItem self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_OverRidingStyledItem_DecrementRefCounter(self, *args)

Handle_StepVisual_OverRidingStyledItem_swigregister = _StepVisual.Handle_StepVisual_OverRidingStyledItem_swigregister
Handle_StepVisual_OverRidingStyledItem_swigregister(Handle_StepVisual_OverRidingStyledItem)

def Handle_StepVisual_OverRidingStyledItem_DownCast(thing):
    return _StepVisual.Handle_StepVisual_OverRidingStyledItem_DownCast(thing)
Handle_StepVisual_OverRidingStyledItem_DownCast = _StepVisual.Handle_StepVisual_OverRidingStyledItem_DownCast

class StepVisual_CurveStyleFontPattern(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_CurveStyleFontPattern
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_CurveStyleFontPattern(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_CurveStyleFontPattern self) -> StepVisual_CurveStyleFontPattern

        Returns a CurveStyleFontPattern


        """
        this = _StepVisual.new_StepVisual_CurveStyleFontPattern(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_CurveStyleFontPattern self, Standard_Real const aVisibleSegmentLength, Standard_Real const aInvisibleSegmentLength)

        :type aVisibleSegmentLength: float
        :type aInvisibleSegmentLength: float

        """
        return _StepVisual.StepVisual_CurveStyleFontPattern_Init(self, *args)


    def SetVisibleSegmentLength(self, *args):
        """
        SetVisibleSegmentLength(StepVisual_CurveStyleFontPattern self, Standard_Real const aVisibleSegmentLength)

        :type aVisibleSegmentLength: float

        """
        return _StepVisual.StepVisual_CurveStyleFontPattern_SetVisibleSegmentLength(self, *args)


    def VisibleSegmentLength(self, *args):
        """
        VisibleSegmentLength(StepVisual_CurveStyleFontPattern self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepVisual.StepVisual_CurveStyleFontPattern_VisibleSegmentLength(self, *args)


    def SetInvisibleSegmentLength(self, *args):
        """
        SetInvisibleSegmentLength(StepVisual_CurveStyleFontPattern self, Standard_Real const aInvisibleSegmentLength)

        :type aInvisibleSegmentLength: float

        """
        return _StepVisual.StepVisual_CurveStyleFontPattern_SetInvisibleSegmentLength(self, *args)


    def InvisibleSegmentLength(self, *args):
        """
        InvisibleSegmentLength(StepVisual_CurveStyleFontPattern self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepVisual.StepVisual_CurveStyleFontPattern_InvisibleSegmentLength(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_CurveStyleFontPattern_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_CurveStyleFontPattern_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_CurveStyleFontPattern_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_CurveStyleFontPattern
StepVisual_CurveStyleFontPattern_swigregister = _StepVisual.StepVisual_CurveStyleFontPattern_swigregister
StepVisual_CurveStyleFontPattern_swigregister(StepVisual_CurveStyleFontPattern)

def StepVisual_CurveStyleFontPattern_get_type_name(*args):
    """
    StepVisual_CurveStyleFontPattern_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_CurveStyleFontPattern_get_type_name(*args)

def StepVisual_CurveStyleFontPattern_get_type_descriptor(*args):
    """
    StepVisual_CurveStyleFontPattern_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_CurveStyleFontPattern_get_type_descriptor(*args)

class Handle_StepVisual_PresentationLayerAssignment(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_PresentationLayerAssignment self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_PresentationLayerAssignment_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_PresentationLayerAssignment self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerAssignment_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_PresentationLayerAssignment self, StepVisual_PresentationLayerAssignment thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerAssignment_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_PresentationLayerAssignment self, Handle_StepVisual_PresentationLayerAssignment theHandle) -> Handle_StepVisual_PresentationLayerAssignment
        assign(Handle_StepVisual_PresentationLayerAssignment self, StepVisual_PresentationLayerAssignment thePtr) -> Handle_StepVisual_PresentationLayerAssignment
        assign(Handle_StepVisual_PresentationLayerAssignment self, Handle_StepVisual_PresentationLayerAssignment theHandle) -> Handle_StepVisual_PresentationLayerAssignment

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerAssignment_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_PresentationLayerAssignment self) -> StepVisual_PresentationLayerAssignment

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerAssignment_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_PresentationLayerAssignment self) -> StepVisual_PresentationLayerAssignment

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerAssignment___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_PresentationLayerAssignment self) -> StepVisual_PresentationLayerAssignment

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerAssignment___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_PresentationLayerAssignment___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_PresentationLayerAssignment___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_PresentationLayerAssignment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_PresentationLayerAssignment_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_PresentationLayerAssignment

    def Init(self, *args):
        """
        Init(Handle_StepVisual_PresentationLayerAssignment self, Handle_TCollection_HAsciiString aName, Handle_TCollection_HAsciiString aDescription, Handle_StepVisual_HArray1OfLayeredItem aAssignedItems)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aAssignedItems: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfLayeredItem

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerAssignment_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_PresentationLayerAssignment self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerAssignment_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_PresentationLayerAssignment self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerAssignment_Name(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepVisual_PresentationLayerAssignment self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerAssignment_SetDescription(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepVisual_PresentationLayerAssignment self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerAssignment_Description(self, *args)


    def SetAssignedItems(self, *args):
        """
        SetAssignedItems(Handle_StepVisual_PresentationLayerAssignment self, Handle_StepVisual_HArray1OfLayeredItem aAssignedItems)

        :type aAssignedItems: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfLayeredItem

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerAssignment_SetAssignedItems(self, *args)


    def AssignedItems(self, *args):
        """
        AssignedItems(Handle_StepVisual_PresentationLayerAssignment self) -> Handle_StepVisual_HArray1OfLayeredItem

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfLayeredItem

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerAssignment_AssignedItems(self, *args)


    def AssignedItemsValue(self, *args):
        """
        AssignedItemsValue(Handle_StepVisual_PresentationLayerAssignment self, Standard_Integer const num) -> StepVisual_LayeredItem

        :type num: int
        :rtype: OCC.wrapper.StepVisual.StepVisual_LayeredItem

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerAssignment_AssignedItemsValue(self, *args)


    def NbAssignedItems(self, *args):
        """
        NbAssignedItems(Handle_StepVisual_PresentationLayerAssignment self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerAssignment_NbAssignedItems(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_PresentationLayerAssignment self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerAssignment_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PresentationLayerAssignment_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PresentationLayerAssignment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_PresentationLayerAssignment self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_PresentationLayerAssignment_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_PresentationLayerAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_PresentationLayerAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerAssignment_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_PresentationLayerAssignment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_PresentationLayerAssignment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerAssignment_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_PresentationLayerAssignment self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerAssignment_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_PresentationLayerAssignment self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerAssignment_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_PresentationLayerAssignment self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_PresentationLayerAssignment_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_PresentationLayerAssignment self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentationLayerAssignment_DecrementRefCounter(self, *args)

Handle_StepVisual_PresentationLayerAssignment_swigregister = _StepVisual.Handle_StepVisual_PresentationLayerAssignment_swigregister
Handle_StepVisual_PresentationLayerAssignment_swigregister(Handle_StepVisual_PresentationLayerAssignment)

def Handle_StepVisual_PresentationLayerAssignment_DownCast(thing):
    return _StepVisual.Handle_StepVisual_PresentationLayerAssignment_DownCast(thing)
Handle_StepVisual_PresentationLayerAssignment_DownCast = _StepVisual.Handle_StepVisual_PresentationLayerAssignment_DownCast

class Handle_StepVisual_PresentationSet(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_PresentationSet self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_PresentationSet_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_PresentationSet self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_PresentationSet_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_PresentationSet self, StepVisual_PresentationSet thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationSet_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_PresentationSet self, Handle_StepVisual_PresentationSet theHandle) -> Handle_StepVisual_PresentationSet
        assign(Handle_StepVisual_PresentationSet self, StepVisual_PresentationSet thePtr) -> Handle_StepVisual_PresentationSet
        assign(Handle_StepVisual_PresentationSet self, Handle_StepVisual_PresentationSet theHandle) -> Handle_StepVisual_PresentationSet

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_PresentationSet_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_PresentationSet self) -> StepVisual_PresentationSet

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationSet_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_PresentationSet self) -> StepVisual_PresentationSet

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationSet___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_PresentationSet self) -> StepVisual_PresentationSet

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_PresentationSet___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_PresentationSet___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_PresentationSet___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_PresentationSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_PresentationSet_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_PresentationSet

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_PresentationSet self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_PresentationSet_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PresentationSet_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PresentationSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_PresentationSet self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_PresentationSet_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_PresentationSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_PresentationSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PresentationSet_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_PresentationSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_PresentationSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PresentationSet_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_PresentationSet self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_PresentationSet_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_PresentationSet self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentationSet_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_PresentationSet self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_PresentationSet_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_PresentationSet self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentationSet_DecrementRefCounter(self, *args)

Handle_StepVisual_PresentationSet_swigregister = _StepVisual.Handle_StepVisual_PresentationSet_swigregister
Handle_StepVisual_PresentationSet_swigregister(Handle_StepVisual_PresentationSet)

def Handle_StepVisual_PresentationSet_DownCast(thing):
    return _StepVisual.Handle_StepVisual_PresentationSet_DownCast(thing)
Handle_StepVisual_PresentationSet_DownCast = _StepVisual.Handle_StepVisual_PresentationSet_DownCast

class StepVisual_CameraModelD2(StepVisual_CameraModel):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_CameraModelD2
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_CameraModelD2(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_CameraModelD2 self) -> StepVisual_CameraModelD2

        Returns a CameraModelD2


        """
        this = _StepVisual.new_StepVisual_CameraModelD2(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_CameraModelD2 self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_PlanarBox aViewWindow, Standard_Boolean const aViewWindowClipping)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aViewWindow: OCC.wrapper.StepVisual.Handle_StepVisual_PlanarBox
        :type aViewWindowClipping: bool

        """
        return _StepVisual.StepVisual_CameraModelD2_Init(self, *args)


    def SetViewWindow(self, *args):
        """
        SetViewWindow(StepVisual_CameraModelD2 self, Handle_StepVisual_PlanarBox aViewWindow)

        :type aViewWindow: OCC.wrapper.StepVisual.Handle_StepVisual_PlanarBox

        """
        return _StepVisual.StepVisual_CameraModelD2_SetViewWindow(self, *args)


    def ViewWindow(self, *args):
        """
        ViewWindow(StepVisual_CameraModelD2 self) -> Handle_StepVisual_PlanarBox

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PlanarBox

        """
        return _StepVisual.StepVisual_CameraModelD2_ViewWindow(self, *args)


    def SetViewWindowClipping(self, *args):
        """
        SetViewWindowClipping(StepVisual_CameraModelD2 self, Standard_Boolean const aViewWindowClipping)

        :type aViewWindowClipping: bool

        """
        return _StepVisual.StepVisual_CameraModelD2_SetViewWindowClipping(self, *args)


    def ViewWindowClipping(self, *args):
        """
        ViewWindowClipping(StepVisual_CameraModelD2 self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.StepVisual_CameraModelD2_ViewWindowClipping(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_CameraModelD2_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_CameraModelD2_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_CameraModelD2_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_CameraModelD2
StepVisual_CameraModelD2_swigregister = _StepVisual.StepVisual_CameraModelD2_swigregister
StepVisual_CameraModelD2_swigregister(StepVisual_CameraModelD2)

def StepVisual_CameraModelD2_get_type_name(*args):
    """
    StepVisual_CameraModelD2_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_CameraModelD2_get_type_name(*args)

def StepVisual_CameraModelD2_get_type_descriptor(*args):
    """
    StepVisual_CameraModelD2_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_CameraModelD2_get_type_descriptor(*args)

class NCollection_Array1_StepVisual_StyleContextSelect(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_StepVisual_StyleContextSelect self) -> NCollection_Array1< StepVisual_StyleContextSelect >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_StyleContextSelect_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_StepVisual_StyleContextSelect self) -> NCollection_Array1< StepVisual_StyleContextSelect >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_StyleContextSelect_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_StepVisual_StyleContextSelect self) -> NCollection_Array1< StepVisual_StyleContextSelect >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_StyleContextSelect_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_StepVisual_StyleContextSelect self) -> NCollection_Array1< StepVisual_StyleContextSelect >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_StyleContextSelect_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepVisual.new_NCollection_Array1_StepVisual_StyleContextSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_StepVisual_StyleContextSelect self, StepVisual_StyleContextSelect theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_StyleContextSelect_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_StepVisual_StyleContextSelect self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_StyleContextSelect_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_StepVisual_StyleContextSelect self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_StyleContextSelect_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_StepVisual_StyleContextSelect self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_StyleContextSelect_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_StepVisual_StyleContextSelect self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_StyleContextSelect_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_StepVisual_StyleContextSelect self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_StyleContextSelect_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_StepVisual_StyleContextSelect self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_StyleContextSelect_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_StepVisual_StyleContextSelect self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_StyleContextSelect_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_StepVisual_StyleContextSelect self, NCollection_Array1_StepVisual_StyleContextSelect theOther) -> NCollection_Array1_StepVisual_StyleContextSelect

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_StyleContextSelect_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_StepVisual_StyleContextSelect self, NCollection_Array1_StepVisual_StyleContextSelect theOther) -> NCollection_Array1_StepVisual_StyleContextSelect

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_StyleContextSelect_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_StepVisual_StyleContextSelect self, NCollection_Array1_StepVisual_StyleContextSelect theOther) -> NCollection_Array1_StepVisual_StyleContextSelect
        assign(NCollection_Array1_StepVisual_StyleContextSelect self, NCollection_Array1_StepVisual_StyleContextSelect theOther) -> NCollection_Array1_StepVisual_StyleContextSelect

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_StyleContextSelect_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_StyleContextSelect_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_StepVisual_StyleContextSelect self) -> StepVisual_StyleContextSelect

        @return first element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_StyleContextSelect_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_StyleContextSelect_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_StepVisual_StyleContextSelect self) -> StepVisual_StyleContextSelect

        @return last element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_StyleContextSelect_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_StyleContextSelect_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_StepVisual_StyleContextSelect self, Standard_Integer const theIndex) -> StepVisual_StyleContextSelect

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_StyleContextSelect_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_StyleContextSelect___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_StyleContextSelect_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_StepVisual_StyleContextSelect self, Standard_Integer const theIndex, StepVisual_StyleContextSelect theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_StyleContextSelect_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_StepVisual_StyleContextSelect self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepVisual.NCollection_Array1_StepVisual_StyleContextSelect_Resize(self, *args)

    __swig_destroy__ = _StepVisual.delete_NCollection_Array1_StepVisual_StyleContextSelect
NCollection_Array1_StepVisual_StyleContextSelect_swigregister = _StepVisual.NCollection_Array1_StepVisual_StyleContextSelect_swigregister
NCollection_Array1_StepVisual_StyleContextSelect_swigregister(NCollection_Array1_StepVisual_StyleContextSelect)


try:
	StepVisual_Array1OfStyleContextSelect = NCollection_Array1_StepVisual_StyleContextSelect
except NameError:
	pass # does not exist, probably ignored

class StepVisual_AreaOrView(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepVisual_AreaOrView self) -> StepVisual_AreaOrView

        Returns a AreaOrView SelectType


        """
        this = _StepVisual.new_StepVisual_AreaOrView(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepVisual_AreaOrView self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a AreaOrView Kind Entity that is :
        1 -> PresentationArea
        2 -> PresentationView
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_AreaOrView_CaseNum(self, *args)


    def PresentationArea(self, *args):
        """
        PresentationArea(StepVisual_AreaOrView self) -> Handle_StepVisual_PresentationArea

        returns Value as a PresentationArea (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationArea

        """
        return _StepVisual.StepVisual_AreaOrView_PresentationArea(self, *args)


    def PresentationView(self, *args):
        """
        PresentationView(StepVisual_AreaOrView self) -> Handle_StepVisual_PresentationView

        returns Value as a PresentationView (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationView

        """
        return _StepVisual.StepVisual_AreaOrView_PresentationView(self, *args)

    __swig_destroy__ = _StepVisual.delete_StepVisual_AreaOrView
StepVisual_AreaOrView_swigregister = _StepVisual.StepVisual_AreaOrView_swigregister
StepVisual_AreaOrView_swigregister(StepVisual_AreaOrView)

class Handle_StepVisual_CurveStyleFontPattern(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_CurveStyleFontPattern self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_CurveStyleFontPattern_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_CurveStyleFontPattern self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFontPattern_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_CurveStyleFontPattern self, StepVisual_CurveStyleFontPattern thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFontPattern_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_CurveStyleFontPattern self, Handle_StepVisual_CurveStyleFontPattern theHandle) -> Handle_StepVisual_CurveStyleFontPattern
        assign(Handle_StepVisual_CurveStyleFontPattern self, StepVisual_CurveStyleFontPattern thePtr) -> Handle_StepVisual_CurveStyleFontPattern
        assign(Handle_StepVisual_CurveStyleFontPattern self, Handle_StepVisual_CurveStyleFontPattern theHandle) -> Handle_StepVisual_CurveStyleFontPattern

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFontPattern_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_CurveStyleFontPattern self) -> StepVisual_CurveStyleFontPattern

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFontPattern_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_CurveStyleFontPattern self) -> StepVisual_CurveStyleFontPattern

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFontPattern___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_CurveStyleFontPattern self) -> StepVisual_CurveStyleFontPattern

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFontPattern___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_CurveStyleFontPattern___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_CurveStyleFontPattern___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_CurveStyleFontPattern(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_CurveStyleFontPattern_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_CurveStyleFontPattern

    def Init(self, *args):
        """
        Init(Handle_StepVisual_CurveStyleFontPattern self, Standard_Real const aVisibleSegmentLength, Standard_Real const aInvisibleSegmentLength)

        :type aVisibleSegmentLength: float
        :type aInvisibleSegmentLength: float

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFontPattern_Init(self, *args)


    def SetVisibleSegmentLength(self, *args):
        """
        SetVisibleSegmentLength(Handle_StepVisual_CurveStyleFontPattern self, Standard_Real const aVisibleSegmentLength)

        :type aVisibleSegmentLength: float

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFontPattern_SetVisibleSegmentLength(self, *args)


    def VisibleSegmentLength(self, *args):
        """
        VisibleSegmentLength(Handle_StepVisual_CurveStyleFontPattern self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFontPattern_VisibleSegmentLength(self, *args)


    def SetInvisibleSegmentLength(self, *args):
        """
        SetInvisibleSegmentLength(Handle_StepVisual_CurveStyleFontPattern self, Standard_Real const aInvisibleSegmentLength)

        :type aInvisibleSegmentLength: float

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFontPattern_SetInvisibleSegmentLength(self, *args)


    def InvisibleSegmentLength(self, *args):
        """
        InvisibleSegmentLength(Handle_StepVisual_CurveStyleFontPattern self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFontPattern_InvisibleSegmentLength(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_CurveStyleFontPattern self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFontPattern_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CurveStyleFontPattern_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CurveStyleFontPattern_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_CurveStyleFontPattern self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_CurveStyleFontPattern_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_CurveStyleFontPattern self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_CurveStyleFontPattern self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFontPattern_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_CurveStyleFontPattern self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_CurveStyleFontPattern self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFontPattern_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_CurveStyleFontPattern self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFontPattern_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_CurveStyleFontPattern self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFontPattern_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_CurveStyleFontPattern self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_CurveStyleFontPattern_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_CurveStyleFontPattern self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CurveStyleFontPattern_DecrementRefCounter(self, *args)

Handle_StepVisual_CurveStyleFontPattern_swigregister = _StepVisual.Handle_StepVisual_CurveStyleFontPattern_swigregister
Handle_StepVisual_CurveStyleFontPattern_swigregister(Handle_StepVisual_CurveStyleFontPattern)

def Handle_StepVisual_CurveStyleFontPattern_DownCast(thing):
    return _StepVisual.Handle_StepVisual_CurveStyleFontPattern_DownCast(thing)
Handle_StepVisual_CurveStyleFontPattern_DownCast = _StepVisual.Handle_StepVisual_CurveStyleFontPattern_DownCast

class Handle_StepVisual_CameraModelD3MultiClippingIntersection(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_CameraModelD3MultiClippingIntersection self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_CameraModelD3MultiClippingIntersection self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_CameraModelD3MultiClippingIntersection self, StepVisual_CameraModelD3MultiClippingIntersection thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_CameraModelD3MultiClippingIntersection self, Handle_StepVisual_CameraModelD3MultiClippingIntersection theHandle) -> Handle_StepVisual_CameraModelD3MultiClippingIntersection
        assign(Handle_StepVisual_CameraModelD3MultiClippingIntersection self, StepVisual_CameraModelD3MultiClippingIntersection thePtr) -> Handle_StepVisual_CameraModelD3MultiClippingIntersection
        assign(Handle_StepVisual_CameraModelD3MultiClippingIntersection self, Handle_StepVisual_CameraModelD3MultiClippingIntersection theHandle) -> Handle_StepVisual_CameraModelD3MultiClippingIntersection

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_CameraModelD3MultiClippingIntersection self) -> StepVisual_CameraModelD3MultiClippingIntersection

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_CameraModelD3MultiClippingIntersection self) -> StepVisual_CameraModelD3MultiClippingIntersection

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_CameraModelD3MultiClippingIntersection self) -> StepVisual_CameraModelD3MultiClippingIntersection

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_CameraModelD3MultiClippingIntersection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_CameraModelD3MultiClippingIntersection

    def Init(self, *args):
        """
        Init(Handle_StepVisual_CameraModelD3MultiClippingIntersection self, Handle_TCollection_HAsciiString theName, Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect theShapeClipping)

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theShapeClipping: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection_Init(self, *args)


    def SetShapeClipping(self, *args):
        """
        SetShapeClipping(Handle_StepVisual_CameraModelD3MultiClippingIntersection self, Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect theShapeClipping)

        :type theShapeClipping: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection_SetShapeClipping(self, *args)


    def ShapeClipping(self, *args):
        """
        ShapeClipping(Handle_StepVisual_CameraModelD3MultiClippingIntersection self) -> Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection_ShapeClipping(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_CameraModelD3MultiClippingIntersection self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_CameraModelD3MultiClippingIntersection self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_CameraModelD3MultiClippingIntersection self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_CameraModelD3MultiClippingIntersection self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_CameraModelD3MultiClippingIntersection self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_CameraModelD3MultiClippingIntersection self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_CameraModelD3MultiClippingIntersection self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_CameraModelD3MultiClippingIntersection self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_CameraModelD3MultiClippingIntersection self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_CameraModelD3MultiClippingIntersection self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_CameraModelD3MultiClippingIntersection self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_CameraModelD3MultiClippingIntersection self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection_DecrementRefCounter(self, *args)

Handle_StepVisual_CameraModelD3MultiClippingIntersection_swigregister = _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection_swigregister
Handle_StepVisual_CameraModelD3MultiClippingIntersection_swigregister(Handle_StepVisual_CameraModelD3MultiClippingIntersection)

def Handle_StepVisual_CameraModelD3MultiClippingIntersection_DownCast(thing):
    return _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection_DownCast(thing)
Handle_StepVisual_CameraModelD3MultiClippingIntersection_DownCast = _StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection_DownCast

class NCollection_Array1_StepVisual_InvisibleItem(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_StepVisual_InvisibleItem self) -> NCollection_Array1< StepVisual_InvisibleItem >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_InvisibleItem_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_StepVisual_InvisibleItem self) -> NCollection_Array1< StepVisual_InvisibleItem >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_InvisibleItem_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_StepVisual_InvisibleItem self) -> NCollection_Array1< StepVisual_InvisibleItem >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_InvisibleItem_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_StepVisual_InvisibleItem self) -> NCollection_Array1< StepVisual_InvisibleItem >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_InvisibleItem_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepVisual.new_NCollection_Array1_StepVisual_InvisibleItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_StepVisual_InvisibleItem self, StepVisual_InvisibleItem theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_InvisibleItem_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_StepVisual_InvisibleItem self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_InvisibleItem_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_StepVisual_InvisibleItem self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_InvisibleItem_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_StepVisual_InvisibleItem self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_InvisibleItem_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_StepVisual_InvisibleItem self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_InvisibleItem_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_StepVisual_InvisibleItem self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_InvisibleItem_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_StepVisual_InvisibleItem self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_InvisibleItem_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_StepVisual_InvisibleItem self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_InvisibleItem_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_StepVisual_InvisibleItem self, NCollection_Array1_StepVisual_InvisibleItem theOther) -> NCollection_Array1_StepVisual_InvisibleItem

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_InvisibleItem_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_StepVisual_InvisibleItem self, NCollection_Array1_StepVisual_InvisibleItem theOther) -> NCollection_Array1_StepVisual_InvisibleItem

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_InvisibleItem_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_StepVisual_InvisibleItem self, NCollection_Array1_StepVisual_InvisibleItem theOther) -> NCollection_Array1_StepVisual_InvisibleItem
        assign(NCollection_Array1_StepVisual_InvisibleItem self, NCollection_Array1_StepVisual_InvisibleItem theOther) -> NCollection_Array1_StepVisual_InvisibleItem

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_InvisibleItem_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_InvisibleItem_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_StepVisual_InvisibleItem self) -> StepVisual_InvisibleItem

        @return first element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_InvisibleItem_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_InvisibleItem_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_StepVisual_InvisibleItem self) -> StepVisual_InvisibleItem

        @return last element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_InvisibleItem_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_InvisibleItem_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_StepVisual_InvisibleItem self, Standard_Integer const theIndex) -> StepVisual_InvisibleItem

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_InvisibleItem_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_InvisibleItem___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_InvisibleItem_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_StepVisual_InvisibleItem self, Standard_Integer const theIndex, StepVisual_InvisibleItem theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_InvisibleItem_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_StepVisual_InvisibleItem self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepVisual.NCollection_Array1_StepVisual_InvisibleItem_Resize(self, *args)

    __swig_destroy__ = _StepVisual.delete_NCollection_Array1_StepVisual_InvisibleItem
NCollection_Array1_StepVisual_InvisibleItem_swigregister = _StepVisual.NCollection_Array1_StepVisual_InvisibleItem_swigregister
NCollection_Array1_StepVisual_InvisibleItem_swigregister(NCollection_Array1_StepVisual_InvisibleItem)


try:
	StepVisual_Array1OfInvisibleItem = NCollection_Array1_StepVisual_InvisibleItem
except NameError:
	pass # does not exist, probably ignored

class StepVisual_CameraModelD3MultiClippingUnionSelect(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepVisual_CameraModelD3MultiClippingUnionSelect self) -> StepVisual_CameraModelD3MultiClippingUnionSelect

        Returns a CameraModelD3MultiClippingUnionSelect select type


        """
        this = _StepVisual.new_StepVisual_CameraModelD3MultiClippingUnionSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepVisual_CameraModelD3MultiClippingUnionSelect self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a IdAttributeSelect Kind Entity that is :
        1 -> Plane
        2 -> CameraModelD3MultiClippingIntersection
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_CameraModelD3MultiClippingUnionSelect_CaseNum(self, *args)


    def Plane(self, *args):
        """
        Plane(StepVisual_CameraModelD3MultiClippingUnionSelect self) -> Handle_StepGeom_Plane

        returns Value as a Plane (Null if another type)

        :rtype: OCC.wrapper.StepGeom.Handle_StepGeom_Plane

        """
        return _StepVisual.StepVisual_CameraModelD3MultiClippingUnionSelect_Plane(self, *args)


    def CameraModelD3MultiClippingIntersection(self, *args):
        """
        CameraModelD3MultiClippingIntersection(StepVisual_CameraModelD3MultiClippingUnionSelect self) -> Handle_StepVisual_CameraModelD3MultiClippingIntersection

        returns Value as a CameraModelD3MultiClippingIntersection (Null if another type)

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_CameraModelD3MultiClippingIntersection

        """
        return _StepVisual.StepVisual_CameraModelD3MultiClippingUnionSelect_CameraModelD3MultiClippingIntersection(self, *args)

    __swig_destroy__ = _StepVisual.delete_StepVisual_CameraModelD3MultiClippingUnionSelect
StepVisual_CameraModelD3MultiClippingUnionSelect_swigregister = _StepVisual.StepVisual_CameraModelD3MultiClippingUnionSelect_swigregister
StepVisual_CameraModelD3MultiClippingUnionSelect_swigregister(StepVisual_CameraModelD3MultiClippingUnionSelect)

class Handle_StepVisual_CameraModelD3MultiClipping(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_CameraModelD3MultiClipping self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_CameraModelD3MultiClipping self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_CameraModelD3MultiClipping self, StepVisual_CameraModelD3MultiClipping thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_CameraModelD3MultiClipping self, Handle_StepVisual_CameraModelD3MultiClipping theHandle) -> Handle_StepVisual_CameraModelD3MultiClipping
        assign(Handle_StepVisual_CameraModelD3MultiClipping self, StepVisual_CameraModelD3MultiClipping thePtr) -> Handle_StepVisual_CameraModelD3MultiClipping
        assign(Handle_StepVisual_CameraModelD3MultiClipping self, Handle_StepVisual_CameraModelD3MultiClipping theHandle) -> Handle_StepVisual_CameraModelD3MultiClipping

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_CameraModelD3MultiClipping self) -> StepVisual_CameraModelD3MultiClipping

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_CameraModelD3MultiClipping self) -> StepVisual_CameraModelD3MultiClipping

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_CameraModelD3MultiClipping self) -> StepVisual_CameraModelD3MultiClipping

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_CameraModelD3MultiClipping(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_CameraModelD3MultiClipping

    def Init(self, *args):
        """
        Init(Handle_StepVisual_CameraModelD3MultiClipping self, Handle_TCollection_HAsciiString theName, Handle_StepGeom_Axis2Placement3d theViewReferenceSystem, Handle_StepVisual_ViewVolume thePerspectiveOfVolume, Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect theShapeClipping)

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theViewReferenceSystem: OCC.wrapper.StepVisual.Handle_StepGeom_Axis2Placement3d
        :type thePerspectiveOfVolume: OCC.wrapper.StepVisual.Handle_StepVisual_ViewVolume
        :type theShapeClipping: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_Init(self, *args)


    def SetShapeClipping(self, *args):
        """
        SetShapeClipping(Handle_StepVisual_CameraModelD3MultiClipping self, Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect theShapeClipping)

        :type theShapeClipping: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_SetShapeClipping(self, *args)


    def ShapeClipping(self, *args):
        """
        ShapeClipping(Handle_StepVisual_CameraModelD3MultiClipping self) -> Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfCameraModelD3MultiClippingInterectionSelect

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_ShapeClipping(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_CameraModelD3MultiClipping self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetViewReferenceSystem(self, *args):
        """
        SetViewReferenceSystem(Handle_StepVisual_CameraModelD3MultiClipping self, Handle_StepGeom_Axis2Placement3d aViewReferenceSystem)

        :type aViewReferenceSystem: OCC.wrapper.StepVisual.Handle_StepGeom_Axis2Placement3d

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_SetViewReferenceSystem(self, *args)


    def ViewReferenceSystem(self, *args):
        """
        ViewReferenceSystem(Handle_StepVisual_CameraModelD3MultiClipping self) -> Handle_StepGeom_Axis2Placement3d

        :rtype: OCC.wrapper.StepVisual.Handle_StepGeom_Axis2Placement3d

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_ViewReferenceSystem(self, *args)


    def SetPerspectiveOfVolume(self, *args):
        """
        SetPerspectiveOfVolume(Handle_StepVisual_CameraModelD3MultiClipping self, Handle_StepVisual_ViewVolume aPerspectiveOfVolume)

        :type aPerspectiveOfVolume: OCC.wrapper.StepVisual.Handle_StepVisual_ViewVolume

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_SetPerspectiveOfVolume(self, *args)


    def PerspectiveOfVolume(self, *args):
        """
        PerspectiveOfVolume(Handle_StepVisual_CameraModelD3MultiClipping self) -> Handle_StepVisual_ViewVolume

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_ViewVolume

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_PerspectiveOfVolume(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_CameraModelD3MultiClipping self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_CameraModelD3MultiClipping self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_CameraModelD3MultiClipping self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_CameraModelD3MultiClipping self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_CameraModelD3MultiClipping self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_CameraModelD3MultiClipping self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_CameraModelD3MultiClipping self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_CameraModelD3MultiClipping self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_CameraModelD3MultiClipping self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_CameraModelD3MultiClipping self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_CameraModelD3MultiClipping self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_DecrementRefCounter(self, *args)

Handle_StepVisual_CameraModelD3MultiClipping_swigregister = _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_swigregister
Handle_StepVisual_CameraModelD3MultiClipping_swigregister(Handle_StepVisual_CameraModelD3MultiClipping)

def Handle_StepVisual_CameraModelD3MultiClipping_DownCast(thing):
    return _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_DownCast(thing)
Handle_StepVisual_CameraModelD3MultiClipping_DownCast = _StepVisual.Handle_StepVisual_CameraModelD3MultiClipping_DownCast

class NCollection_Array1_StepVisual_SurfaceStyleElementSelect(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_StepVisual_SurfaceStyleElementSelect self) -> NCollection_Array1< StepVisual_SurfaceStyleElementSelect >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_SurfaceStyleElementSelect_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_StepVisual_SurfaceStyleElementSelect self) -> NCollection_Array1< StepVisual_SurfaceStyleElementSelect >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_SurfaceStyleElementSelect_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_StepVisual_SurfaceStyleElementSelect self) -> NCollection_Array1< StepVisual_SurfaceStyleElementSelect >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_SurfaceStyleElementSelect_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_StepVisual_SurfaceStyleElementSelect self) -> NCollection_Array1< StepVisual_SurfaceStyleElementSelect >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_SurfaceStyleElementSelect_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepVisual.new_NCollection_Array1_StepVisual_SurfaceStyleElementSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_StepVisual_SurfaceStyleElementSelect self, StepVisual_SurfaceStyleElementSelect theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_SurfaceStyleElementSelect_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_StepVisual_SurfaceStyleElementSelect self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_SurfaceStyleElementSelect_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_StepVisual_SurfaceStyleElementSelect self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_SurfaceStyleElementSelect_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_StepVisual_SurfaceStyleElementSelect self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_SurfaceStyleElementSelect_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_StepVisual_SurfaceStyleElementSelect self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_SurfaceStyleElementSelect_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_StepVisual_SurfaceStyleElementSelect self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_SurfaceStyleElementSelect_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_StepVisual_SurfaceStyleElementSelect self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_SurfaceStyleElementSelect_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_StepVisual_SurfaceStyleElementSelect self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_SurfaceStyleElementSelect_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_StepVisual_SurfaceStyleElementSelect self, NCollection_Array1_StepVisual_SurfaceStyleElementSelect theOther) -> NCollection_Array1_StepVisual_SurfaceStyleElementSelect

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_SurfaceStyleElementSelect_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_StepVisual_SurfaceStyleElementSelect self, NCollection_Array1_StepVisual_SurfaceStyleElementSelect theOther) -> NCollection_Array1_StepVisual_SurfaceStyleElementSelect

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_SurfaceStyleElementSelect_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_StepVisual_SurfaceStyleElementSelect self, NCollection_Array1_StepVisual_SurfaceStyleElementSelect theOther) -> NCollection_Array1_StepVisual_SurfaceStyleElementSelect
        assign(NCollection_Array1_StepVisual_SurfaceStyleElementSelect self, NCollection_Array1_StepVisual_SurfaceStyleElementSelect theOther) -> NCollection_Array1_StepVisual_SurfaceStyleElementSelect

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_SurfaceStyleElementSelect_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_SurfaceStyleElementSelect_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_StepVisual_SurfaceStyleElementSelect self) -> StepVisual_SurfaceStyleElementSelect

        @return first element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_SurfaceStyleElementSelect_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_SurfaceStyleElementSelect_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_StepVisual_SurfaceStyleElementSelect self) -> StepVisual_SurfaceStyleElementSelect

        @return last element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_SurfaceStyleElementSelect_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_SurfaceStyleElementSelect_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_StepVisual_SurfaceStyleElementSelect self, Standard_Integer const theIndex) -> StepVisual_SurfaceStyleElementSelect

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_SurfaceStyleElementSelect_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_SurfaceStyleElementSelect___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_SurfaceStyleElementSelect_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_StepVisual_SurfaceStyleElementSelect self, Standard_Integer const theIndex, StepVisual_SurfaceStyleElementSelect theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_SurfaceStyleElementSelect_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_StepVisual_SurfaceStyleElementSelect self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepVisual.NCollection_Array1_StepVisual_SurfaceStyleElementSelect_Resize(self, *args)

    __swig_destroy__ = _StepVisual.delete_NCollection_Array1_StepVisual_SurfaceStyleElementSelect
NCollection_Array1_StepVisual_SurfaceStyleElementSelect_swigregister = _StepVisual.NCollection_Array1_StepVisual_SurfaceStyleElementSelect_swigregister
NCollection_Array1_StepVisual_SurfaceStyleElementSelect_swigregister(NCollection_Array1_StepVisual_SurfaceStyleElementSelect)


try:
	StepVisual_Array1OfSurfaceStyleElementSelect = NCollection_Array1_StepVisual_SurfaceStyleElementSelect
except NameError:
	pass # does not exist, probably ignored

class Handle_StepVisual_ExternallyDefinedCurveFont(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_ExternallyDefinedCurveFont self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_ExternallyDefinedCurveFont self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_ExternallyDefinedCurveFont self, StepVisual_ExternallyDefinedCurveFont thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_ExternallyDefinedCurveFont self, Handle_StepVisual_ExternallyDefinedCurveFont theHandle) -> Handle_StepVisual_ExternallyDefinedCurveFont
        assign(Handle_StepVisual_ExternallyDefinedCurveFont self, StepVisual_ExternallyDefinedCurveFont thePtr) -> Handle_StepVisual_ExternallyDefinedCurveFont
        assign(Handle_StepVisual_ExternallyDefinedCurveFont self, Handle_StepVisual_ExternallyDefinedCurveFont theHandle) -> Handle_StepVisual_ExternallyDefinedCurveFont

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_ExternallyDefinedCurveFont self) -> StepVisual_ExternallyDefinedCurveFont

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_ExternallyDefinedCurveFont self) -> StepVisual_ExternallyDefinedCurveFont

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_ExternallyDefinedCurveFont self) -> StepVisual_ExternallyDefinedCurveFont

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_ExternallyDefinedCurveFont(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_ExternallyDefinedCurveFont

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_ExternallyDefinedCurveFont self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_ExternallyDefinedCurveFont self, StepBasic_SourceItem aItemId, Handle_StepBasic_ExternalSource aSource)

        Initialize all fields (own and inherited)

        :type aItemId: OCC.wrapper.StepBasic.StepBasic_SourceItem
        :type aSource: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont_Init(self, *args)


    def ItemId(self, *args):
        """
        ItemId(Handle_StepVisual_ExternallyDefinedCurveFont self) -> StepBasic_SourceItem

        Returns field ItemId

        :rtype: OCC.wrapper.StepBasic.StepBasic_SourceItem

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont_ItemId(self, *args)


    def SetItemId(self, *args):
        """
        SetItemId(Handle_StepVisual_ExternallyDefinedCurveFont self, StepBasic_SourceItem ItemId)

        Set field ItemId

        :type ItemId: OCC.wrapper.StepBasic.StepBasic_SourceItem

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont_SetItemId(self, *args)


    def Source(self, *args):
        """
        Source(Handle_StepVisual_ExternallyDefinedCurveFont self) -> Handle_StepBasic_ExternalSource

        Returns field Source

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont_Source(self, *args)


    def SetSource(self, *args):
        """
        SetSource(Handle_StepVisual_ExternallyDefinedCurveFont self, Handle_StepBasic_ExternalSource Source)

        Set field Source

        :type Source: OCC.wrapper.StepBasic.Handle_StepBasic_ExternalSource

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont_SetSource(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_ExternallyDefinedCurveFont self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_ExternallyDefinedCurveFont self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_ExternallyDefinedCurveFont self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_ExternallyDefinedCurveFont self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_ExternallyDefinedCurveFont self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_ExternallyDefinedCurveFont self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_ExternallyDefinedCurveFont self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_ExternallyDefinedCurveFont self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_ExternallyDefinedCurveFont self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont_DecrementRefCounter(self, *args)

Handle_StepVisual_ExternallyDefinedCurveFont_swigregister = _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont_swigregister
Handle_StepVisual_ExternallyDefinedCurveFont_swigregister(Handle_StepVisual_ExternallyDefinedCurveFont)

def Handle_StepVisual_ExternallyDefinedCurveFont_DownCast(thing):
    return _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont_DownCast(thing)
Handle_StepVisual_ExternallyDefinedCurveFont_DownCast = _StepVisual.Handle_StepVisual_ExternallyDefinedCurveFont_DownCast

class Handle_StepVisual_PlanarExtent(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_PlanarExtent self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_PlanarExtent_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_PlanarExtent self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_PlanarExtent_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_PlanarExtent self, StepVisual_PlanarExtent thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_PlanarExtent_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_PlanarExtent self, Handle_StepVisual_PlanarExtent theHandle) -> Handle_StepVisual_PlanarExtent
        assign(Handle_StepVisual_PlanarExtent self, StepVisual_PlanarExtent thePtr) -> Handle_StepVisual_PlanarExtent
        assign(Handle_StepVisual_PlanarExtent self, Handle_StepVisual_PlanarExtent theHandle) -> Handle_StepVisual_PlanarExtent

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_PlanarExtent_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_PlanarExtent self) -> StepVisual_PlanarExtent

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PlanarExtent_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_PlanarExtent self) -> StepVisual_PlanarExtent

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PlanarExtent___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_PlanarExtent self) -> StepVisual_PlanarExtent

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_PlanarExtent___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_PlanarExtent___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_PlanarExtent___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_PlanarExtent(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_PlanarExtent_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_PlanarExtent

    def Init(self, *args):
        """
        Init(Handle_StepVisual_PlanarExtent self, Handle_TCollection_HAsciiString aName, Standard_Real const aSizeInX, Standard_Real const aSizeInY)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aSizeInX: float
        :type aSizeInY: float

        """
        return _StepVisual.Handle_StepVisual_PlanarExtent_Init(self, *args)


    def SetSizeInX(self, *args):
        """
        SetSizeInX(Handle_StepVisual_PlanarExtent self, Standard_Real const aSizeInX)

        :type aSizeInX: float

        """
        return _StepVisual.Handle_StepVisual_PlanarExtent_SetSizeInX(self, *args)


    def SizeInX(self, *args):
        """
        SizeInX(Handle_StepVisual_PlanarExtent self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepVisual.Handle_StepVisual_PlanarExtent_SizeInX(self, *args)


    def SetSizeInY(self, *args):
        """
        SetSizeInY(Handle_StepVisual_PlanarExtent self, Standard_Real const aSizeInY)

        :type aSizeInY: float

        """
        return _StepVisual.Handle_StepVisual_PlanarExtent_SetSizeInY(self, *args)


    def SizeInY(self, *args):
        """
        SizeInY(Handle_StepVisual_PlanarExtent self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepVisual.Handle_StepVisual_PlanarExtent_SizeInY(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_PlanarExtent self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_PlanarExtent_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PlanarExtent_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PlanarExtent_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_PlanarExtent self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_PlanarExtent_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_PlanarExtent self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_PlanarExtent_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_PlanarExtent self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_PlanarExtent_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_PlanarExtent self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_PlanarExtent self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PlanarExtent_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_PlanarExtent self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_PlanarExtent self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PlanarExtent_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_PlanarExtent self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_PlanarExtent_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_PlanarExtent self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PlanarExtent_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_PlanarExtent self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_PlanarExtent_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_PlanarExtent self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PlanarExtent_DecrementRefCounter(self, *args)

Handle_StepVisual_PlanarExtent_swigregister = _StepVisual.Handle_StepVisual_PlanarExtent_swigregister
Handle_StepVisual_PlanarExtent_swigregister(Handle_StepVisual_PlanarExtent)

def Handle_StepVisual_PlanarExtent_DownCast(thing):
    return _StepVisual.Handle_StepVisual_PlanarExtent_DownCast(thing)
Handle_StepVisual_PlanarExtent_DownCast = _StepVisual.Handle_StepVisual_PlanarExtent_DownCast

class NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern self) -> NCollection_Array1< opencascade::handle< StepVisual_CurveStyleFontPattern > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern self) -> NCollection_Array1< opencascade::handle< StepVisual_CurveStyleFontPattern > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern self) -> NCollection_Array1< opencascade::handle< StepVisual_CurveStyleFontPattern > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern self) -> NCollection_Array1< opencascade::handle< StepVisual_CurveStyleFontPattern > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepVisual.new_NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern self, Handle_StepVisual_CurveStyleFontPattern theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern self, NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern theOther) -> NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern self, NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern theOther) -> NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern self, NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern theOther) -> NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern
        assign(NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern self, NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern theOther) -> NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern self) -> Handle_StepVisual_CurveStyleFontPattern

        @return first element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern self) -> Handle_StepVisual_CurveStyleFontPattern

        @return last element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern self, Standard_Integer const theIndex) -> Handle_StepVisual_CurveStyleFontPattern

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern self, Standard_Integer const theIndex, Handle_StepVisual_CurveStyleFontPattern theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepVisual.NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_Resize(self, *args)

    __swig_destroy__ = _StepVisual.delete_NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern
NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_swigregister = _StepVisual.NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_swigregister
NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern_swigregister(NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern)


try:
	StepVisual_Array1OfCurveStyleFontPattern = NCollection_Array1_Handle_StepVisual_CurveStyleFontPattern
except NameError:
	pass # does not exist, probably ignored

class StepVisual_PointStyle(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_PointStyle
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_PointStyle(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_PointStyle self) -> StepVisual_PointStyle

        Returns a PointStyle


        """
        this = _StepVisual.new_StepVisual_PointStyle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_PointStyle self, Handle_TCollection_HAsciiString aName, StepVisual_MarkerSelect aMarker, StepBasic_SizeSelect aMarkerSize, Handle_StepVisual_Colour aMarkerColour)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aMarker: OCC.wrapper.StepVisual.StepVisual_MarkerSelect
        :type aMarkerSize: OCC.wrapper.StepBasic.StepBasic_SizeSelect
        :type aMarkerColour: OCC.wrapper.StepVisual.Handle_StepVisual_Colour

        """
        return _StepVisual.StepVisual_PointStyle_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(StepVisual_PointStyle self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_PointStyle_SetName(self, *args)


    def Name(self, *args):
        """
        Name(StepVisual_PointStyle self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.StepVisual_PointStyle_Name(self, *args)


    def SetMarker(self, *args):
        """
        SetMarker(StepVisual_PointStyle self, StepVisual_MarkerSelect aMarker)

        :type aMarker: OCC.wrapper.StepVisual.StepVisual_MarkerSelect

        """
        return _StepVisual.StepVisual_PointStyle_SetMarker(self, *args)


    def Marker(self, *args):
        """
        Marker(StepVisual_PointStyle self) -> StepVisual_MarkerSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_MarkerSelect

        """
        return _StepVisual.StepVisual_PointStyle_Marker(self, *args)


    def SetMarkerSize(self, *args):
        """
        SetMarkerSize(StepVisual_PointStyle self, StepBasic_SizeSelect aMarkerSize)

        :type aMarkerSize: OCC.wrapper.StepBasic.StepBasic_SizeSelect

        """
        return _StepVisual.StepVisual_PointStyle_SetMarkerSize(self, *args)


    def MarkerSize(self, *args):
        """
        MarkerSize(StepVisual_PointStyle self) -> StepBasic_SizeSelect

        :rtype: OCC.wrapper.StepBasic.StepBasic_SizeSelect

        """
        return _StepVisual.StepVisual_PointStyle_MarkerSize(self, *args)


    def SetMarkerColour(self, *args):
        """
        SetMarkerColour(StepVisual_PointStyle self, Handle_StepVisual_Colour aMarkerColour)

        :type aMarkerColour: OCC.wrapper.StepVisual.Handle_StepVisual_Colour

        """
        return _StepVisual.StepVisual_PointStyle_SetMarkerColour(self, *args)


    def MarkerColour(self, *args):
        """
        MarkerColour(StepVisual_PointStyle self) -> Handle_StepVisual_Colour

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_Colour

        """
        return _StepVisual.StepVisual_PointStyle_MarkerColour(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_PointStyle_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_PointStyle_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_PointStyle_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_PointStyle
StepVisual_PointStyle_swigregister = _StepVisual.StepVisual_PointStyle_swigregister
StepVisual_PointStyle_swigregister(StepVisual_PointStyle)

def StepVisual_PointStyle_get_type_name(*args):
    """
    StepVisual_PointStyle_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_PointStyle_get_type_name(*args)

def StepVisual_PointStyle_get_type_descriptor(*args):
    """
    StepVisual_PointStyle_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_PointStyle_get_type_descriptor(*args)

class Handle_StepVisual_TessellatedAnnotationOccurrence(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_TessellatedAnnotationOccurrence self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_TessellatedAnnotationOccurrence self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_TessellatedAnnotationOccurrence self, StepVisual_TessellatedAnnotationOccurrence thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_TessellatedAnnotationOccurrence self, Handle_StepVisual_TessellatedAnnotationOccurrence theHandle) -> Handle_StepVisual_TessellatedAnnotationOccurrence
        assign(Handle_StepVisual_TessellatedAnnotationOccurrence self, StepVisual_TessellatedAnnotationOccurrence thePtr) -> Handle_StepVisual_TessellatedAnnotationOccurrence
        assign(Handle_StepVisual_TessellatedAnnotationOccurrence self, Handle_StepVisual_TessellatedAnnotationOccurrence theHandle) -> Handle_StepVisual_TessellatedAnnotationOccurrence

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_TessellatedAnnotationOccurrence self) -> StepVisual_TessellatedAnnotationOccurrence

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_TessellatedAnnotationOccurrence self) -> StepVisual_TessellatedAnnotationOccurrence

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_TessellatedAnnotationOccurrence self) -> StepVisual_TessellatedAnnotationOccurrence

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_TessellatedAnnotationOccurrence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_TessellatedAnnotationOccurrence

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_TessellatedAnnotationOccurrence self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_TessellatedAnnotationOccurrence self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_HArray1OfPresentationStyleAssignment aStyles, Handle_Standard_Transient aItem)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment
        :type aItem: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_Init(self, *args)


    def SetStyles(self, *args):
        """
        SetStyles(Handle_StepVisual_TessellatedAnnotationOccurrence self, Handle_StepVisual_HArray1OfPresentationStyleAssignment aStyles)

        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_SetStyles(self, *args)


    def Styles(self, *args):
        """
        Styles(Handle_StepVisual_TessellatedAnnotationOccurrence self) -> Handle_StepVisual_HArray1OfPresentationStyleAssignment

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_Styles(self, *args)


    def StylesValue(self, *args):
        """
        StylesValue(Handle_StepVisual_TessellatedAnnotationOccurrence self, Standard_Integer const num) -> Handle_StepVisual_PresentationStyleAssignment

        :type num: int
        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_StylesValue(self, *args)


    def NbStyles(self, *args):
        """
        NbStyles(Handle_StepVisual_TessellatedAnnotationOccurrence self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_NbStyles(self, *args)


    def SetItem(self, *args):
        """
        SetItem(Handle_StepVisual_TessellatedAnnotationOccurrence self, Handle_StepRepr_RepresentationItem aItem)
        SetItem(Handle_StepVisual_TessellatedAnnotationOccurrence self, StepVisual_StyledItemTarget aItem)

        :type aItem: OCC.wrapper.StepVisual.StepVisual_StyledItemTarget

        """
        return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_SetItem(self, *args)


    def Item(self, *args):
        """
        Item(Handle_StepVisual_TessellatedAnnotationOccurrence self) -> Handle_StepRepr_RepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_Item(self, *args)


    def ItemAP242(self, *args):
        """
        ItemAP242(Handle_StepVisual_TessellatedAnnotationOccurrence self) -> StepVisual_StyledItemTarget

        :rtype: OCC.wrapper.StepVisual.StepVisual_StyledItemTarget

        """
        return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_ItemAP242(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_TessellatedAnnotationOccurrence self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_TessellatedAnnotationOccurrence self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_TessellatedAnnotationOccurrence self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_TessellatedAnnotationOccurrence self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_TessellatedAnnotationOccurrence self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_TessellatedAnnotationOccurrence self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_TessellatedAnnotationOccurrence self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_TessellatedAnnotationOccurrence self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_TessellatedAnnotationOccurrence self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_TessellatedAnnotationOccurrence self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_TessellatedAnnotationOccurrence self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_DecrementRefCounter(self, *args)

Handle_StepVisual_TessellatedAnnotationOccurrence_swigregister = _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_swigregister
Handle_StepVisual_TessellatedAnnotationOccurrence_swigregister(Handle_StepVisual_TessellatedAnnotationOccurrence)

def Handle_StepVisual_TessellatedAnnotationOccurrence_DownCast(thing):
    return _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_DownCast(thing)
Handle_StepVisual_TessellatedAnnotationOccurrence_DownCast = _StepVisual.Handle_StepVisual_TessellatedAnnotationOccurrence_DownCast

class NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect self) -> NCollection_Array1< StepVisual_CameraModelD3MultiClippingUnionSelect >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect self) -> NCollection_Array1< StepVisual_CameraModelD3MultiClippingUnionSelect >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect self) -> NCollection_Array1< StepVisual_CameraModelD3MultiClippingUnionSelect >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect self) -> NCollection_Array1< StepVisual_CameraModelD3MultiClippingUnionSelect >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepVisual.new_NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect self, StepVisual_CameraModelD3MultiClippingUnionSelect theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect self, NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect theOther) -> NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect self, NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect theOther) -> NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect self, NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect theOther) -> NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect
        assign(NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect self, NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect theOther) -> NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect self) -> StepVisual_CameraModelD3MultiClippingUnionSelect

        @return first element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect self) -> StepVisual_CameraModelD3MultiClippingUnionSelect

        @return last element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect self, Standard_Integer const theIndex) -> StepVisual_CameraModelD3MultiClippingUnionSelect

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect self, Standard_Integer const theIndex, StepVisual_CameraModelD3MultiClippingUnionSelect theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_Resize(self, *args)

    __swig_destroy__ = _StepVisual.delete_NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect
NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_swigregister = _StepVisual.NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_swigregister
NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect_swigregister(NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect)


try:
	StepVisual_Array1OfCameraModelD3MultiClippingUnionSelect = NCollection_Array1_StepVisual_CameraModelD3MultiClippingUnionSelect
except NameError:
	pass # does not exist, probably ignored

class Handle_StepVisual_TextStyleWithBoxCharacteristics(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_TextStyleWithBoxCharacteristics self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_TextStyleWithBoxCharacteristics self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_TextStyleWithBoxCharacteristics self, StepVisual_TextStyleWithBoxCharacteristics thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_TextStyleWithBoxCharacteristics self, Handle_StepVisual_TextStyleWithBoxCharacteristics theHandle) -> Handle_StepVisual_TextStyleWithBoxCharacteristics
        assign(Handle_StepVisual_TextStyleWithBoxCharacteristics self, StepVisual_TextStyleWithBoxCharacteristics thePtr) -> Handle_StepVisual_TextStyleWithBoxCharacteristics
        assign(Handle_StepVisual_TextStyleWithBoxCharacteristics self, Handle_StepVisual_TextStyleWithBoxCharacteristics theHandle) -> Handle_StepVisual_TextStyleWithBoxCharacteristics

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_TextStyleWithBoxCharacteristics self) -> StepVisual_TextStyleWithBoxCharacteristics

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_TextStyleWithBoxCharacteristics self) -> StepVisual_TextStyleWithBoxCharacteristics

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_TextStyleWithBoxCharacteristics self) -> StepVisual_TextStyleWithBoxCharacteristics

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_TextStyleWithBoxCharacteristics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_TextStyleWithBoxCharacteristics

    def Init(self, *args):
        """
        Init(Handle_StepVisual_TextStyleWithBoxCharacteristics self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_TextStyleForDefinedFont aCharacterAppearance, Handle_StepVisual_HArray1OfBoxCharacteristicSelect aCharacteristics)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aCharacterAppearance: OCC.wrapper.StepVisual.Handle_StepVisual_TextStyleForDefinedFont
        :type aCharacteristics: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect

        """
        return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_Init(self, *args)


    def SetCharacteristics(self, *args):
        """
        SetCharacteristics(Handle_StepVisual_TextStyleWithBoxCharacteristics self, Handle_StepVisual_HArray1OfBoxCharacteristicSelect aCharacteristics)

        :type aCharacteristics: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect

        """
        return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_SetCharacteristics(self, *args)


    def Characteristics(self, *args):
        """
        Characteristics(Handle_StepVisual_TextStyleWithBoxCharacteristics self) -> Handle_StepVisual_HArray1OfBoxCharacteristicSelect

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect

        """
        return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_Characteristics(self, *args)


    def CharacteristicsValue(self, *args):
        """
        CharacteristicsValue(Handle_StepVisual_TextStyleWithBoxCharacteristics self, Standard_Integer const num) -> StepVisual_BoxCharacteristicSelect

        :type num: int
        :rtype: OCC.wrapper.StepVisual.StepVisual_BoxCharacteristicSelect

        """
        return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_CharacteristicsValue(self, *args)


    def NbCharacteristics(self, *args):
        """
        NbCharacteristics(Handle_StepVisual_TextStyleWithBoxCharacteristics self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_NbCharacteristics(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_TextStyleWithBoxCharacteristics self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_TextStyleWithBoxCharacteristics self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_TextStyleWithBoxCharacteristics self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_Name(self, *args)


    def SetCharacterAppearance(self, *args):
        """
        SetCharacterAppearance(Handle_StepVisual_TextStyleWithBoxCharacteristics self, Handle_StepVisual_TextStyleForDefinedFont aCharacterAppearance)

        :type aCharacterAppearance: OCC.wrapper.StepVisual.Handle_StepVisual_TextStyleForDefinedFont

        """
        return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_SetCharacterAppearance(self, *args)


    def CharacterAppearance(self, *args):
        """
        CharacterAppearance(Handle_StepVisual_TextStyleWithBoxCharacteristics self) -> Handle_StepVisual_TextStyleForDefinedFont

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_TextStyleForDefinedFont

        """
        return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_CharacterAppearance(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_TextStyleWithBoxCharacteristics self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_TextStyleWithBoxCharacteristics self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_TextStyleWithBoxCharacteristics self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_TextStyleWithBoxCharacteristics self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_TextStyleWithBoxCharacteristics self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_TextStyleWithBoxCharacteristics self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_TextStyleWithBoxCharacteristics self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_TextStyleWithBoxCharacteristics self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_TextStyleWithBoxCharacteristics self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_DecrementRefCounter(self, *args)

Handle_StepVisual_TextStyleWithBoxCharacteristics_swigregister = _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_swigregister
Handle_StepVisual_TextStyleWithBoxCharacteristics_swigregister(Handle_StepVisual_TextStyleWithBoxCharacteristics)

def Handle_StepVisual_TextStyleWithBoxCharacteristics_DownCast(thing):
    return _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_DownCast(thing)
Handle_StepVisual_TextStyleWithBoxCharacteristics_DownCast = _StepVisual.Handle_StepVisual_TextStyleWithBoxCharacteristics_DownCast

class Handle_StepVisual_PreDefinedCurveFont(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_PreDefinedCurveFont self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_PreDefinedCurveFont_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_PreDefinedCurveFont self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_PreDefinedCurveFont_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_PreDefinedCurveFont self, StepVisual_PreDefinedCurveFont thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_PreDefinedCurveFont_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_PreDefinedCurveFont self, Handle_StepVisual_PreDefinedCurveFont theHandle) -> Handle_StepVisual_PreDefinedCurveFont
        assign(Handle_StepVisual_PreDefinedCurveFont self, StepVisual_PreDefinedCurveFont thePtr) -> Handle_StepVisual_PreDefinedCurveFont
        assign(Handle_StepVisual_PreDefinedCurveFont self, Handle_StepVisual_PreDefinedCurveFont theHandle) -> Handle_StepVisual_PreDefinedCurveFont

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_PreDefinedCurveFont_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_PreDefinedCurveFont self) -> StepVisual_PreDefinedCurveFont

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PreDefinedCurveFont_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_PreDefinedCurveFont self) -> StepVisual_PreDefinedCurveFont

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PreDefinedCurveFont___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_PreDefinedCurveFont self) -> StepVisual_PreDefinedCurveFont

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_PreDefinedCurveFont___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_PreDefinedCurveFont___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_PreDefinedCurveFont___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_PreDefinedCurveFont(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_PreDefinedCurveFont_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_PreDefinedCurveFont

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_PreDefinedCurveFont self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_PreDefinedCurveFont_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PreDefinedCurveFont_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PreDefinedCurveFont_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_PreDefinedCurveFont self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_PreDefinedCurveFont_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_PreDefinedCurveFont self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_PreDefinedCurveFont_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_PreDefinedCurveFont self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_PreDefinedCurveFont_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_PreDefinedCurveFont self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_PreDefinedCurveFont_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_PreDefinedCurveFont self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_PreDefinedCurveFont self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PreDefinedCurveFont_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_PreDefinedCurveFont self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_PreDefinedCurveFont self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PreDefinedCurveFont_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_PreDefinedCurveFont self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_PreDefinedCurveFont_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_PreDefinedCurveFont self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PreDefinedCurveFont_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_PreDefinedCurveFont self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_PreDefinedCurveFont_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_PreDefinedCurveFont self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PreDefinedCurveFont_DecrementRefCounter(self, *args)

Handle_StepVisual_PreDefinedCurveFont_swigregister = _StepVisual.Handle_StepVisual_PreDefinedCurveFont_swigregister
Handle_StepVisual_PreDefinedCurveFont_swigregister(Handle_StepVisual_PreDefinedCurveFont)

def Handle_StepVisual_PreDefinedCurveFont_DownCast(thing):
    return _StepVisual.Handle_StepVisual_PreDefinedCurveFont_DownCast(thing)
Handle_StepVisual_PreDefinedCurveFont_DownCast = _StepVisual.Handle_StepVisual_PreDefinedCurveFont_DownCast

class Handle_StepVisual_HArray1OfBoxCharacteristicSelect(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_HArray1OfBoxCharacteristicSelect self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_HArray1OfBoxCharacteristicSelect self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_HArray1OfBoxCharacteristicSelect self, StepVisual_HArray1OfBoxCharacteristicSelect thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_HArray1OfBoxCharacteristicSelect self, Handle_StepVisual_HArray1OfBoxCharacteristicSelect theHandle) -> Handle_StepVisual_HArray1OfBoxCharacteristicSelect
        assign(Handle_StepVisual_HArray1OfBoxCharacteristicSelect self, StepVisual_HArray1OfBoxCharacteristicSelect thePtr) -> Handle_StepVisual_HArray1OfBoxCharacteristicSelect
        assign(Handle_StepVisual_HArray1OfBoxCharacteristicSelect self, Handle_StepVisual_HArray1OfBoxCharacteristicSelect theHandle) -> Handle_StepVisual_HArray1OfBoxCharacteristicSelect

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_HArray1OfBoxCharacteristicSelect self) -> StepVisual_HArray1OfBoxCharacteristicSelect

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_HArray1OfBoxCharacteristicSelect self) -> StepVisual_HArray1OfBoxCharacteristicSelect

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_HArray1OfBoxCharacteristicSelect self) -> StepVisual_HArray1OfBoxCharacteristicSelect

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_HArray1OfBoxCharacteristicSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_HArray1OfBoxCharacteristicSelect

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfBoxCharacteristicSelect

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepVisual_HArray1OfBoxCharacteristicSelect self) -> NCollection_Array1_StepVisual_BoxCharacteristicSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfBoxCharacteristicSelect

        """
        return _StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_HArray1OfBoxCharacteristicSelect self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_HArray1OfBoxCharacteristicSelect self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_HArray1OfBoxCharacteristicSelect self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_HArray1OfBoxCharacteristicSelect self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_HArray1OfBoxCharacteristicSelect self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_HArray1OfBoxCharacteristicSelect self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_HArray1OfBoxCharacteristicSelect self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_HArray1OfBoxCharacteristicSelect self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_HArray1OfBoxCharacteristicSelect self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_HArray1OfBoxCharacteristicSelect self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect_DecrementRefCounter(self, *args)

Handle_StepVisual_HArray1OfBoxCharacteristicSelect_swigregister = _StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect_swigregister
Handle_StepVisual_HArray1OfBoxCharacteristicSelect_swigregister(Handle_StepVisual_HArray1OfBoxCharacteristicSelect)

def Handle_StepVisual_HArray1OfBoxCharacteristicSelect_DownCast(thing):
    return _StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect_DownCast(thing)
Handle_StepVisual_HArray1OfBoxCharacteristicSelect_DownCast = _StepVisual.Handle_StepVisual_HArray1OfBoxCharacteristicSelect_DownCast

class Handle_StepVisual_DraughtingCallout(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_DraughtingCallout self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_DraughtingCallout_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_DraughtingCallout self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_DraughtingCallout_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_DraughtingCallout self, StepVisual_DraughtingCallout thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_DraughtingCallout_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_DraughtingCallout self, Handle_StepVisual_DraughtingCallout theHandle) -> Handle_StepVisual_DraughtingCallout
        assign(Handle_StepVisual_DraughtingCallout self, StepVisual_DraughtingCallout thePtr) -> Handle_StepVisual_DraughtingCallout
        assign(Handle_StepVisual_DraughtingCallout self, Handle_StepVisual_DraughtingCallout theHandle) -> Handle_StepVisual_DraughtingCallout

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_DraughtingCallout_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_DraughtingCallout self) -> StepVisual_DraughtingCallout

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_DraughtingCallout_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_DraughtingCallout self) -> StepVisual_DraughtingCallout

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_DraughtingCallout___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_DraughtingCallout self) -> StepVisual_DraughtingCallout

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_DraughtingCallout___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_DraughtingCallout___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_DraughtingCallout___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_DraughtingCallout(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_DraughtingCallout_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_DraughtingCallout

    def Init(self, *args):
        """
        Init(Handle_StepVisual_DraughtingCallout self, Handle_TCollection_HAsciiString theName, Handle_StepVisual_HArray1OfDraughtingCalloutElement theContents)

        Init

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theContents: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement

        """
        return _StepVisual.Handle_StepVisual_DraughtingCallout_Init(self, *args)


    def Contents(self, *args):
        """
        Contents(Handle_StepVisual_DraughtingCallout self) -> Handle_StepVisual_HArray1OfDraughtingCalloutElement

        Returns field Contents

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement

        """
        return _StepVisual.Handle_StepVisual_DraughtingCallout_Contents(self, *args)


    def SetContents(self, *args):
        """
        SetContents(Handle_StepVisual_DraughtingCallout self, Handle_StepVisual_HArray1OfDraughtingCalloutElement theContents)

        Set field Contents

        :type theContents: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfDraughtingCalloutElement

        """
        return _StepVisual.Handle_StepVisual_DraughtingCallout_SetContents(self, *args)


    def NbContents(self, *args):
        """
        NbContents(Handle_StepVisual_DraughtingCallout self) -> Standard_Integer

        Returns number of Contents

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_DraughtingCallout_NbContents(self, *args)


    def ContentsValue(self, *args):
        """
        ContentsValue(Handle_StepVisual_DraughtingCallout self, Standard_Integer const theNum) -> StepVisual_DraughtingCalloutElement

        Returns Contents with the given number

        :type theNum: int
        :rtype: OCC.wrapper.StepVisual.StepVisual_DraughtingCalloutElement

        """
        return _StepVisual.Handle_StepVisual_DraughtingCallout_ContentsValue(self, *args)


    def SetContentsValue(self, *args):
        """
        SetContentsValue(Handle_StepVisual_DraughtingCallout self, Standard_Integer const theNum, StepVisual_DraughtingCalloutElement theItem)

        Sets Contents with given number

        :type theNum: int
        :type theItem: OCC.wrapper.StepVisual.StepVisual_DraughtingCalloutElement

        """
        return _StepVisual.Handle_StepVisual_DraughtingCallout_SetContentsValue(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_DraughtingCallout self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_DraughtingCallout_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_DraughtingCallout_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_DraughtingCallout_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_DraughtingCallout self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_DraughtingCallout_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_DraughtingCallout self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_DraughtingCallout_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_DraughtingCallout self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_DraughtingCallout_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_DraughtingCallout self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_DraughtingCallout self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_DraughtingCallout_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_DraughtingCallout self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_DraughtingCallout self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_DraughtingCallout_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_DraughtingCallout self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_DraughtingCallout_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_DraughtingCallout self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_DraughtingCallout_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_DraughtingCallout self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_DraughtingCallout_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_DraughtingCallout self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_DraughtingCallout_DecrementRefCounter(self, *args)

Handle_StepVisual_DraughtingCallout_swigregister = _StepVisual.Handle_StepVisual_DraughtingCallout_swigregister
Handle_StepVisual_DraughtingCallout_swigregister(Handle_StepVisual_DraughtingCallout)

def Handle_StepVisual_DraughtingCallout_DownCast(thing):
    return _StepVisual.Handle_StepVisual_DraughtingCallout_DownCast(thing)
Handle_StepVisual_DraughtingCallout_DownCast = _StepVisual.Handle_StepVisual_DraughtingCallout_DownCast

class Handle_StepVisual_PresentationArea(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_PresentationArea self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_PresentationArea_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_PresentationArea self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_PresentationArea_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_PresentationArea self, StepVisual_PresentationArea thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationArea_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_PresentationArea self, Handle_StepVisual_PresentationArea theHandle) -> Handle_StepVisual_PresentationArea
        assign(Handle_StepVisual_PresentationArea self, StepVisual_PresentationArea thePtr) -> Handle_StepVisual_PresentationArea
        assign(Handle_StepVisual_PresentationArea self, Handle_StepVisual_PresentationArea theHandle) -> Handle_StepVisual_PresentationArea

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_PresentationArea_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_PresentationArea self) -> StepVisual_PresentationArea

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationArea_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_PresentationArea self) -> StepVisual_PresentationArea

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PresentationArea___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_PresentationArea self) -> StepVisual_PresentationArea

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_PresentationArea___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_PresentationArea___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_PresentationArea___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_PresentationArea(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_PresentationArea_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_PresentationArea

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_PresentationArea self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_PresentationArea_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PresentationArea_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PresentationArea_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_PresentationArea self, Handle_TCollection_HAsciiString aName, Handle_StepRepr_HArray1OfRepresentationItem aItems, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepVisual.Handle_StepVisual_PresentationArea_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_PresentationArea self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_PresentationArea_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_PresentationArea self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_PresentationArea_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepVisual_PresentationArea self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepVisual.Handle_StepVisual_PresentationArea_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepVisual_PresentationArea self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepVisual.Handle_StepVisual_PresentationArea_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepVisual_PresentationArea self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_PresentationArea_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepVisual_PresentationArea self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentationArea_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepVisual_PresentationArea self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepVisual.Handle_StepVisual_PresentationArea_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepVisual_PresentationArea self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepVisual.Handle_StepVisual_PresentationArea_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_PresentationArea self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_PresentationArea_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_PresentationArea self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_PresentationArea self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PresentationArea_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_PresentationArea self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_PresentationArea self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PresentationArea_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_PresentationArea self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_PresentationArea_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_PresentationArea self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentationArea_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_PresentationArea self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_PresentationArea_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_PresentationArea self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PresentationArea_DecrementRefCounter(self, *args)

Handle_StepVisual_PresentationArea_swigregister = _StepVisual.Handle_StepVisual_PresentationArea_swigregister
Handle_StepVisual_PresentationArea_swigregister(Handle_StepVisual_PresentationArea)

def Handle_StepVisual_PresentationArea_DownCast(thing):
    return _StepVisual.Handle_StepVisual_PresentationArea_DownCast(thing)
Handle_StepVisual_PresentationArea_DownCast = _StepVisual.Handle_StepVisual_PresentationArea_DownCast

class StepVisual_ContextDependentOverRidingStyledItem(StepVisual_OverRidingStyledItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_ContextDependentOverRidingStyledItem
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_ContextDependentOverRidingStyledItem(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_ContextDependentOverRidingStyledItem self) -> StepVisual_ContextDependentOverRidingStyledItem

        Returns a ContextDependentOverRidingStyledItem


        """
        this = _StepVisual.new_StepVisual_ContextDependentOverRidingStyledItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_ContextDependentOverRidingStyledItem self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_HArray1OfPresentationStyleAssignment aStyles, Handle_Standard_Transient aItem, Handle_StepVisual_StyledItem aOverRiddenStyle, Handle_StepVisual_HArray1OfStyleContextSelect aStyleContext)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment
        :type aItem: OCC.wrapper.Standard.Handle_Standard_Transient
        :type aOverRiddenStyle: OCC.wrapper.StepVisual.Handle_StepVisual_StyledItem
        :type aStyleContext: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect

        """
        return _StepVisual.StepVisual_ContextDependentOverRidingStyledItem_Init(self, *args)


    def SetStyleContext(self, *args):
        """
        SetStyleContext(StepVisual_ContextDependentOverRidingStyledItem self, Handle_StepVisual_HArray1OfStyleContextSelect aStyleContext)

        :type aStyleContext: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect

        """
        return _StepVisual.StepVisual_ContextDependentOverRidingStyledItem_SetStyleContext(self, *args)


    def StyleContext(self, *args):
        """
        StyleContext(StepVisual_ContextDependentOverRidingStyledItem self) -> Handle_StepVisual_HArray1OfStyleContextSelect

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect

        """
        return _StepVisual.StepVisual_ContextDependentOverRidingStyledItem_StyleContext(self, *args)


    def StyleContextValue(self, *args):
        """
        StyleContextValue(StepVisual_ContextDependentOverRidingStyledItem self, Standard_Integer const num) -> StepVisual_StyleContextSelect

        :type num: int
        :rtype: OCC.wrapper.StepVisual.StepVisual_StyleContextSelect

        """
        return _StepVisual.StepVisual_ContextDependentOverRidingStyledItem_StyleContextValue(self, *args)


    def NbStyleContext(self, *args):
        """
        NbStyleContext(StepVisual_ContextDependentOverRidingStyledItem self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_ContextDependentOverRidingStyledItem_NbStyleContext(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_ContextDependentOverRidingStyledItem_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_ContextDependentOverRidingStyledItem_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_ContextDependentOverRidingStyledItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_ContextDependentOverRidingStyledItem
StepVisual_ContextDependentOverRidingStyledItem_swigregister = _StepVisual.StepVisual_ContextDependentOverRidingStyledItem_swigregister
StepVisual_ContextDependentOverRidingStyledItem_swigregister(StepVisual_ContextDependentOverRidingStyledItem)

def StepVisual_ContextDependentOverRidingStyledItem_get_type_name(*args):
    """
    StepVisual_ContextDependentOverRidingStyledItem_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_ContextDependentOverRidingStyledItem_get_type_name(*args)

def StepVisual_ContextDependentOverRidingStyledItem_get_type_descriptor(*args):
    """
    StepVisual_ContextDependentOverRidingStyledItem_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_ContextDependentOverRidingStyledItem_get_type_descriptor(*args)

class StepVisual_SurfaceStyleFillArea(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_SurfaceStyleFillArea
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_SurfaceStyleFillArea(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_SurfaceStyleFillArea self) -> StepVisual_SurfaceStyleFillArea

        Returns a SurfaceStyleFillArea


        """
        this = _StepVisual.new_StepVisual_SurfaceStyleFillArea(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_SurfaceStyleFillArea self, Handle_StepVisual_FillAreaStyle aFillArea)

        :type aFillArea: OCC.wrapper.StepVisual.Handle_StepVisual_FillAreaStyle

        """
        return _StepVisual.StepVisual_SurfaceStyleFillArea_Init(self, *args)


    def SetFillArea(self, *args):
        """
        SetFillArea(StepVisual_SurfaceStyleFillArea self, Handle_StepVisual_FillAreaStyle aFillArea)

        :type aFillArea: OCC.wrapper.StepVisual.Handle_StepVisual_FillAreaStyle

        """
        return _StepVisual.StepVisual_SurfaceStyleFillArea_SetFillArea(self, *args)


    def FillArea(self, *args):
        """
        FillArea(StepVisual_SurfaceStyleFillArea self) -> Handle_StepVisual_FillAreaStyle

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_FillAreaStyle

        """
        return _StepVisual.StepVisual_SurfaceStyleFillArea_FillArea(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_SurfaceStyleFillArea_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_SurfaceStyleFillArea_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_SurfaceStyleFillArea_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_SurfaceStyleFillArea
StepVisual_SurfaceStyleFillArea_swigregister = _StepVisual.StepVisual_SurfaceStyleFillArea_swigregister
StepVisual_SurfaceStyleFillArea_swigregister(StepVisual_SurfaceStyleFillArea)

def StepVisual_SurfaceStyleFillArea_get_type_name(*args):
    """
    StepVisual_SurfaceStyleFillArea_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_SurfaceStyleFillArea_get_type_name(*args)

def StepVisual_SurfaceStyleFillArea_get_type_descriptor(*args):
    """
    StepVisual_SurfaceStyleFillArea_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_SurfaceStyleFillArea_get_type_descriptor(*args)

class StepVisual_SurfaceStyleSegmentationCurve(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_SurfaceStyleSegmentationCurve
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_SurfaceStyleSegmentationCurve(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_SurfaceStyleSegmentationCurve self) -> StepVisual_SurfaceStyleSegmentationCurve

        Returns a SurfaceStyleSegmentationCurve


        """
        this = _StepVisual.new_StepVisual_SurfaceStyleSegmentationCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_SurfaceStyleSegmentationCurve self, Handle_StepVisual_CurveStyle aStyleOfSegmentationCurve)

        :type aStyleOfSegmentationCurve: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.StepVisual_SurfaceStyleSegmentationCurve_Init(self, *args)


    def SetStyleOfSegmentationCurve(self, *args):
        """
        SetStyleOfSegmentationCurve(StepVisual_SurfaceStyleSegmentationCurve self, Handle_StepVisual_CurveStyle aStyleOfSegmentationCurve)

        :type aStyleOfSegmentationCurve: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.StepVisual_SurfaceStyleSegmentationCurve_SetStyleOfSegmentationCurve(self, *args)


    def StyleOfSegmentationCurve(self, *args):
        """
        StyleOfSegmentationCurve(StepVisual_SurfaceStyleSegmentationCurve self) -> Handle_StepVisual_CurveStyle

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.StepVisual_SurfaceStyleSegmentationCurve_StyleOfSegmentationCurve(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_SurfaceStyleSegmentationCurve_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_SurfaceStyleSegmentationCurve_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_SurfaceStyleSegmentationCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_SurfaceStyleSegmentationCurve
StepVisual_SurfaceStyleSegmentationCurve_swigregister = _StepVisual.StepVisual_SurfaceStyleSegmentationCurve_swigregister
StepVisual_SurfaceStyleSegmentationCurve_swigregister(StepVisual_SurfaceStyleSegmentationCurve)

def StepVisual_SurfaceStyleSegmentationCurve_get_type_name(*args):
    """
    StepVisual_SurfaceStyleSegmentationCurve_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_SurfaceStyleSegmentationCurve_get_type_name(*args)

def StepVisual_SurfaceStyleSegmentationCurve_get_type_descriptor(*args):
    """
    StepVisual_SurfaceStyleSegmentationCurve_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_SurfaceStyleSegmentationCurve_get_type_descriptor(*args)

class Handle_StepVisual_CameraModelD3(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_CameraModelD3 self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_CameraModelD3_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_CameraModelD3 self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_CameraModelD3 self, StepVisual_CameraModelD3 thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_CameraModelD3 self, Handle_StepVisual_CameraModelD3 theHandle) -> Handle_StepVisual_CameraModelD3
        assign(Handle_StepVisual_CameraModelD3 self, StepVisual_CameraModelD3 thePtr) -> Handle_StepVisual_CameraModelD3
        assign(Handle_StepVisual_CameraModelD3 self, Handle_StepVisual_CameraModelD3 theHandle) -> Handle_StepVisual_CameraModelD3

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_CameraModelD3 self) -> StepVisual_CameraModelD3

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_CameraModelD3 self) -> StepVisual_CameraModelD3

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_CameraModelD3 self) -> StepVisual_CameraModelD3

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_CameraModelD3___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_CameraModelD3___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_CameraModelD3(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_CameraModelD3_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_CameraModelD3

    def Init(self, *args):
        """
        Init(Handle_StepVisual_CameraModelD3 self, Handle_TCollection_HAsciiString aName, Handle_StepGeom_Axis2Placement3d aViewReferenceSystem, Handle_StepVisual_ViewVolume aPerspectiveOfVolume)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aViewReferenceSystem: OCC.wrapper.StepVisual.Handle_StepGeom_Axis2Placement3d
        :type aPerspectiveOfVolume: OCC.wrapper.StepVisual.Handle_StepVisual_ViewVolume

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3_Init(self, *args)


    def SetViewReferenceSystem(self, *args):
        """
        SetViewReferenceSystem(Handle_StepVisual_CameraModelD3 self, Handle_StepGeom_Axis2Placement3d aViewReferenceSystem)

        :type aViewReferenceSystem: OCC.wrapper.StepVisual.Handle_StepGeom_Axis2Placement3d

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3_SetViewReferenceSystem(self, *args)


    def ViewReferenceSystem(self, *args):
        """
        ViewReferenceSystem(Handle_StepVisual_CameraModelD3 self) -> Handle_StepGeom_Axis2Placement3d

        :rtype: OCC.wrapper.StepVisual.Handle_StepGeom_Axis2Placement3d

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3_ViewReferenceSystem(self, *args)


    def SetPerspectiveOfVolume(self, *args):
        """
        SetPerspectiveOfVolume(Handle_StepVisual_CameraModelD3 self, Handle_StepVisual_ViewVolume aPerspectiveOfVolume)

        :type aPerspectiveOfVolume: OCC.wrapper.StepVisual.Handle_StepVisual_ViewVolume

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3_SetPerspectiveOfVolume(self, *args)


    def PerspectiveOfVolume(self, *args):
        """
        PerspectiveOfVolume(Handle_StepVisual_CameraModelD3 self) -> Handle_StepVisual_ViewVolume

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_ViewVolume

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3_PerspectiveOfVolume(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_CameraModelD3 self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CameraModelD3_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CameraModelD3_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_CameraModelD3 self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_CameraModelD3 self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_CameraModelD3 self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_CameraModelD3_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_CameraModelD3 self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_CameraModelD3 self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_CameraModelD3 self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_CameraModelD3 self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_CameraModelD3 self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_CameraModelD3 self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_CameraModelD3 self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_CameraModelD3_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_CameraModelD3 self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CameraModelD3_DecrementRefCounter(self, *args)

Handle_StepVisual_CameraModelD3_swigregister = _StepVisual.Handle_StepVisual_CameraModelD3_swigregister
Handle_StepVisual_CameraModelD3_swigregister(Handle_StepVisual_CameraModelD3)

def Handle_StepVisual_CameraModelD3_DownCast(thing):
    return _StepVisual.Handle_StepVisual_CameraModelD3_DownCast(thing)
Handle_StepVisual_CameraModelD3_DownCast = _StepVisual.Handle_StepVisual_CameraModelD3_DownCast

class Handle_StepVisual_AnnotationCurveOccurrence(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_AnnotationCurveOccurrence self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_AnnotationCurveOccurrence self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_AnnotationCurveOccurrence self, StepVisual_AnnotationCurveOccurrence thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_AnnotationCurveOccurrence self, Handle_StepVisual_AnnotationCurveOccurrence theHandle) -> Handle_StepVisual_AnnotationCurveOccurrence
        assign(Handle_StepVisual_AnnotationCurveOccurrence self, StepVisual_AnnotationCurveOccurrence thePtr) -> Handle_StepVisual_AnnotationCurveOccurrence
        assign(Handle_StepVisual_AnnotationCurveOccurrence self, Handle_StepVisual_AnnotationCurveOccurrence theHandle) -> Handle_StepVisual_AnnotationCurveOccurrence

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_AnnotationCurveOccurrence self) -> StepVisual_AnnotationCurveOccurrence

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_AnnotationCurveOccurrence self) -> StepVisual_AnnotationCurveOccurrence

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_AnnotationCurveOccurrence self) -> StepVisual_AnnotationCurveOccurrence

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_AnnotationCurveOccurrence(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_AnnotationCurveOccurrence

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_AnnotationCurveOccurrence self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_AnnotationCurveOccurrence self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_HArray1OfPresentationStyleAssignment aStyles, Handle_Standard_Transient aItem)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment
        :type aItem: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_Init(self, *args)


    def SetStyles(self, *args):
        """
        SetStyles(Handle_StepVisual_AnnotationCurveOccurrence self, Handle_StepVisual_HArray1OfPresentationStyleAssignment aStyles)

        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_SetStyles(self, *args)


    def Styles(self, *args):
        """
        Styles(Handle_StepVisual_AnnotationCurveOccurrence self) -> Handle_StepVisual_HArray1OfPresentationStyleAssignment

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_Styles(self, *args)


    def StylesValue(self, *args):
        """
        StylesValue(Handle_StepVisual_AnnotationCurveOccurrence self, Standard_Integer const num) -> Handle_StepVisual_PresentationStyleAssignment

        :type num: int
        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_StylesValue(self, *args)


    def NbStyles(self, *args):
        """
        NbStyles(Handle_StepVisual_AnnotationCurveOccurrence self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_NbStyles(self, *args)


    def SetItem(self, *args):
        """
        SetItem(Handle_StepVisual_AnnotationCurveOccurrence self, Handle_StepRepr_RepresentationItem aItem)
        SetItem(Handle_StepVisual_AnnotationCurveOccurrence self, StepVisual_StyledItemTarget aItem)

        :type aItem: OCC.wrapper.StepVisual.StepVisual_StyledItemTarget

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_SetItem(self, *args)


    def Item(self, *args):
        """
        Item(Handle_StepVisual_AnnotationCurveOccurrence self) -> Handle_StepRepr_RepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_Item(self, *args)


    def ItemAP242(self, *args):
        """
        ItemAP242(Handle_StepVisual_AnnotationCurveOccurrence self) -> StepVisual_StyledItemTarget

        :rtype: OCC.wrapper.StepVisual.StepVisual_StyledItemTarget

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_ItemAP242(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_AnnotationCurveOccurrence self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_AnnotationCurveOccurrence self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_AnnotationCurveOccurrence self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_AnnotationCurveOccurrence self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_AnnotationCurveOccurrence self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_AnnotationCurveOccurrence self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_AnnotationCurveOccurrence self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_AnnotationCurveOccurrence self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_AnnotationCurveOccurrence self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_AnnotationCurveOccurrence self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_AnnotationCurveOccurrence self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_DecrementRefCounter(self, *args)

Handle_StepVisual_AnnotationCurveOccurrence_swigregister = _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_swigregister
Handle_StepVisual_AnnotationCurveOccurrence_swigregister(Handle_StepVisual_AnnotationCurveOccurrence)

def Handle_StepVisual_AnnotationCurveOccurrence_DownCast(thing):
    return _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_DownCast(thing)
Handle_StepVisual_AnnotationCurveOccurrence_DownCast = _StepVisual.Handle_StepVisual_AnnotationCurveOccurrence_DownCast

class Handle_StepVisual_TessellatedCurveSet(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_TessellatedCurveSet self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_TessellatedCurveSet_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_TessellatedCurveSet self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_TessellatedCurveSet_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_TessellatedCurveSet self, StepVisual_TessellatedCurveSet thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_TessellatedCurveSet_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_TessellatedCurveSet self, Handle_StepVisual_TessellatedCurveSet theHandle) -> Handle_StepVisual_TessellatedCurveSet
        assign(Handle_StepVisual_TessellatedCurveSet self, StepVisual_TessellatedCurveSet thePtr) -> Handle_StepVisual_TessellatedCurveSet
        assign(Handle_StepVisual_TessellatedCurveSet self, Handle_StepVisual_TessellatedCurveSet theHandle) -> Handle_StepVisual_TessellatedCurveSet

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_TessellatedCurveSet_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_TessellatedCurveSet self) -> StepVisual_TessellatedCurveSet

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_TessellatedCurveSet_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_TessellatedCurveSet self) -> StepVisual_TessellatedCurveSet

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_TessellatedCurveSet___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_TessellatedCurveSet self) -> StepVisual_TessellatedCurveSet

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_TessellatedCurveSet___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_TessellatedCurveSet___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_TessellatedCurveSet___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_TessellatedCurveSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_TessellatedCurveSet_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_TessellatedCurveSet

    def Init(self, *args):
        """
        Init(Handle_StepVisual_TessellatedCurveSet self, Handle_TCollection_HAsciiString theName, Handle_StepVisual_CoordinatesList theCoordList, NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger theCurves)

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type theCoordList: OCC.wrapper.StepVisual.Handle_StepVisual_CoordinatesList
        :type theCurves: OCC.wrapper.StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger

        """
        return _StepVisual.Handle_StepVisual_TessellatedCurveSet_Init(self, *args)


    def CoordList(self, *args):
        """
        CoordList(Handle_StepVisual_TessellatedCurveSet self) -> Handle_StepVisual_CoordinatesList

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_CoordinatesList

        """
        return _StepVisual.Handle_StepVisual_TessellatedCurveSet_CoordList(self, *args)


    def Curves(self, *args):
        """
        Curves(Handle_StepVisual_TessellatedCurveSet self) -> NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger

        :rtype: OCC.wrapper.StepVisual.NCollection_Handle_StepVisual_VectorOfHSequenceOfInteger

        """
        return _StepVisual.Handle_StepVisual_TessellatedCurveSet_Curves(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_TessellatedCurveSet self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_TessellatedCurveSet_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_TessellatedCurveSet_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_TessellatedCurveSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_TessellatedCurveSet self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_TessellatedCurveSet_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_TessellatedCurveSet self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_TessellatedCurveSet_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_TessellatedCurveSet self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_TessellatedCurveSet_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_TessellatedCurveSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_TessellatedCurveSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_TessellatedCurveSet_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_TessellatedCurveSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_TessellatedCurveSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_TessellatedCurveSet_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_TessellatedCurveSet self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_TessellatedCurveSet_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_TessellatedCurveSet self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_TessellatedCurveSet_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_TessellatedCurveSet self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_TessellatedCurveSet_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_TessellatedCurveSet self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_TessellatedCurveSet_DecrementRefCounter(self, *args)

Handle_StepVisual_TessellatedCurveSet_swigregister = _StepVisual.Handle_StepVisual_TessellatedCurveSet_swigregister
Handle_StepVisual_TessellatedCurveSet_swigregister(Handle_StepVisual_TessellatedCurveSet)

def Handle_StepVisual_TessellatedCurveSet_DownCast(thing):
    return _StepVisual.Handle_StepVisual_TessellatedCurveSet_DownCast(thing)
Handle_StepVisual_TessellatedCurveSet_DownCast = _StepVisual.Handle_StepVisual_TessellatedCurveSet_DownCast

class Handle_StepVisual_HArray1OfTextOrCharacter(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_HArray1OfTextOrCharacter self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_HArray1OfTextOrCharacter self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_HArray1OfTextOrCharacter self, StepVisual_HArray1OfTextOrCharacter thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_HArray1OfTextOrCharacter self, Handle_StepVisual_HArray1OfTextOrCharacter theHandle) -> Handle_StepVisual_HArray1OfTextOrCharacter
        assign(Handle_StepVisual_HArray1OfTextOrCharacter self, StepVisual_HArray1OfTextOrCharacter thePtr) -> Handle_StepVisual_HArray1OfTextOrCharacter
        assign(Handle_StepVisual_HArray1OfTextOrCharacter self, Handle_StepVisual_HArray1OfTextOrCharacter theHandle) -> Handle_StepVisual_HArray1OfTextOrCharacter

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_HArray1OfTextOrCharacter self) -> StepVisual_HArray1OfTextOrCharacter

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_HArray1OfTextOrCharacter self) -> StepVisual_HArray1OfTextOrCharacter

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_HArray1OfTextOrCharacter self) -> StepVisual_HArray1OfTextOrCharacter

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_HArray1OfTextOrCharacter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_HArray1OfTextOrCharacter

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfTextOrCharacter

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepVisual_HArray1OfTextOrCharacter self) -> NCollection_Array1_StepVisual_TextOrCharacter

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfTextOrCharacter

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_HArray1OfTextOrCharacter self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def begin(self, *args):
        """
        begin(Handle_StepVisual_HArray1OfTextOrCharacter self) -> NCollection_Array1< StepVisual_TextOrCharacter >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_begin(self, *args)


    def end(self, *args):
        """
        end(Handle_StepVisual_HArray1OfTextOrCharacter self) -> NCollection_Array1< StepVisual_TextOrCharacter >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(Handle_StepVisual_HArray1OfTextOrCharacter self) -> NCollection_Array1< StepVisual_TextOrCharacter >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(Handle_StepVisual_HArray1OfTextOrCharacter self) -> NCollection_Array1< StepVisual_TextOrCharacter >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_cend(self, *args)


    def Init(self, *args):
        """
        Init(Handle_StepVisual_HArray1OfTextOrCharacter self, StepVisual_TextOrCharacter theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_Init(self, *args)


    def Size(self, *args):
        """
        Size(Handle_StepVisual_HArray1OfTextOrCharacter self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_Size(self, *args)


    def Length(self, *args):
        """
        Length(Handle_StepVisual_HArray1OfTextOrCharacter self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_StepVisual_HArray1OfTextOrCharacter self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(Handle_StepVisual_HArray1OfTextOrCharacter self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(Handle_StepVisual_HArray1OfTextOrCharacter self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(Handle_StepVisual_HArray1OfTextOrCharacter self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(Handle_StepVisual_HArray1OfTextOrCharacter self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(Handle_StepVisual_HArray1OfTextOrCharacter self, NCollection_Array1_StepVisual_TextOrCharacter theOther) -> NCollection_Array1_StepVisual_TextOrCharacter

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_Assign(self, *args)


    def Move(self, *args):
        """
        Move(Handle_StepVisual_HArray1OfTextOrCharacter self, NCollection_Array1_StepVisual_TextOrCharacter theOther) -> NCollection_Array1_StepVisual_TextOrCharacter

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_Move(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(Handle_StepVisual_HArray1OfTextOrCharacter self) -> StepVisual_TextOrCharacter

        @return first element

        :rtype: TheItemType &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(Handle_StepVisual_HArray1OfTextOrCharacter self) -> StepVisual_TextOrCharacter

        @return last element

        :rtype: TheItemType &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(Handle_StepVisual_HArray1OfTextOrCharacter self, Standard_Integer const theIndex) -> StepVisual_TextOrCharacter

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_StepVisual_HArray1OfTextOrCharacter self, Standard_Integer const theIndex, StepVisual_TextOrCharacter theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(Handle_StepVisual_HArray1OfTextOrCharacter self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_Resize(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_HArray1OfTextOrCharacter self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_HArray1OfTextOrCharacter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_HArray1OfTextOrCharacter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_HArray1OfTextOrCharacter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_HArray1OfTextOrCharacter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_HArray1OfTextOrCharacter self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_HArray1OfTextOrCharacter self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_HArray1OfTextOrCharacter self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_HArray1OfTextOrCharacter self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_DecrementRefCounter(self, *args)

Handle_StepVisual_HArray1OfTextOrCharacter_swigregister = _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_swigregister
Handle_StepVisual_HArray1OfTextOrCharacter_swigregister(Handle_StepVisual_HArray1OfTextOrCharacter)

def Handle_StepVisual_HArray1OfTextOrCharacter_DownCast(thing):
    return _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_DownCast(thing)
Handle_StepVisual_HArray1OfTextOrCharacter_DownCast = _StepVisual.Handle_StepVisual_HArray1OfTextOrCharacter_DownCast

class Handle_StepVisual_SurfaceStyleFillArea(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_SurfaceStyleFillArea self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleFillArea_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_SurfaceStyleFillArea self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleFillArea_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_SurfaceStyleFillArea self, StepVisual_SurfaceStyleFillArea thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleFillArea_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_SurfaceStyleFillArea self, Handle_StepVisual_SurfaceStyleFillArea theHandle) -> Handle_StepVisual_SurfaceStyleFillArea
        assign(Handle_StepVisual_SurfaceStyleFillArea self, StepVisual_SurfaceStyleFillArea thePtr) -> Handle_StepVisual_SurfaceStyleFillArea
        assign(Handle_StepVisual_SurfaceStyleFillArea self, Handle_StepVisual_SurfaceStyleFillArea theHandle) -> Handle_StepVisual_SurfaceStyleFillArea

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleFillArea_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_SurfaceStyleFillArea self) -> StepVisual_SurfaceStyleFillArea

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleFillArea_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_SurfaceStyleFillArea self) -> StepVisual_SurfaceStyleFillArea

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleFillArea___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_SurfaceStyleFillArea self) -> StepVisual_SurfaceStyleFillArea

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleFillArea___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_SurfaceStyleFillArea___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_SurfaceStyleFillArea___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_SurfaceStyleFillArea(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_SurfaceStyleFillArea_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_SurfaceStyleFillArea

    def Init(self, *args):
        """
        Init(Handle_StepVisual_SurfaceStyleFillArea self, Handle_StepVisual_FillAreaStyle aFillArea)

        :type aFillArea: OCC.wrapper.StepVisual.Handle_StepVisual_FillAreaStyle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleFillArea_Init(self, *args)


    def SetFillArea(self, *args):
        """
        SetFillArea(Handle_StepVisual_SurfaceStyleFillArea self, Handle_StepVisual_FillAreaStyle aFillArea)

        :type aFillArea: OCC.wrapper.StepVisual.Handle_StepVisual_FillAreaStyle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleFillArea_SetFillArea(self, *args)


    def FillArea(self, *args):
        """
        FillArea(Handle_StepVisual_SurfaceStyleFillArea self) -> Handle_StepVisual_FillAreaStyle

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_FillAreaStyle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleFillArea_FillArea(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_SurfaceStyleFillArea self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleFillArea_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_SurfaceStyleFillArea_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_SurfaceStyleFillArea_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_SurfaceStyleFillArea self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleFillArea_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_SurfaceStyleFillArea self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_SurfaceStyleFillArea self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleFillArea_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_SurfaceStyleFillArea self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_SurfaceStyleFillArea self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleFillArea_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_SurfaceStyleFillArea self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleFillArea_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_SurfaceStyleFillArea self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleFillArea_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_SurfaceStyleFillArea self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleFillArea_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_SurfaceStyleFillArea self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleFillArea_DecrementRefCounter(self, *args)

Handle_StepVisual_SurfaceStyleFillArea_swigregister = _StepVisual.Handle_StepVisual_SurfaceStyleFillArea_swigregister
Handle_StepVisual_SurfaceStyleFillArea_swigregister(Handle_StepVisual_SurfaceStyleFillArea)

def Handle_StepVisual_SurfaceStyleFillArea_DownCast(thing):
    return _StepVisual.Handle_StepVisual_SurfaceStyleFillArea_DownCast(thing)
Handle_StepVisual_SurfaceStyleFillArea_DownCast = _StepVisual.Handle_StepVisual_SurfaceStyleFillArea_DownCast

class Handle_StepVisual_NullStyleMember(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_NullStyleMember self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_NullStyleMember self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_NullStyleMember self, StepVisual_NullStyleMember thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_NullStyleMember self, Handle_StepVisual_NullStyleMember theHandle) -> Handle_StepVisual_NullStyleMember
        assign(Handle_StepVisual_NullStyleMember self, StepVisual_NullStyleMember thePtr) -> Handle_StepVisual_NullStyleMember
        assign(Handle_StepVisual_NullStyleMember self, Handle_StepVisual_NullStyleMember theHandle) -> Handle_StepVisual_NullStyleMember

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_NullStyleMember self) -> StepVisual_NullStyleMember

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_NullStyleMember self) -> StepVisual_NullStyleMember

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_NullStyleMember self) -> StepVisual_NullStyleMember

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_NullStyleMember___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_NullStyleMember___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_NullStyleMember(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_NullStyleMember_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_NullStyleMember

    def HasName(self, *args):
        """
        HasName(Handle_StepVisual_NullStyleMember self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_HasName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_NullStyleMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_NullStyleMember self, Standard_CString const arg2) -> Standard_Boolean

        :type : OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_SetName(self, *args)


    def Kind(self, *args):
        """
        Kind(Handle_StepVisual_NullStyleMember self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_Kind(self, *args)


    def EnumText(self, *args):
        """
        EnumText(Handle_StepVisual_NullStyleMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_EnumText(self, *args)


    def SetEnumText(self, *args):
        """
        SetEnumText(Handle_StepVisual_NullStyleMember self, Standard_Integer const theValue, Standard_CString const theText)

        :type theValue: int
        :type theText: OCC.wrapper.Standard.Standard_CString

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_SetEnumText(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_StepVisual_NullStyleMember self, StepVisual_NullStyle const theValue)

        :type theValue: OCC.wrapper.StepVisual.StepVisual_NullStyle

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_SetValue(self, *args)


    def Value(self, *args):
        """
        Value(Handle_StepVisual_NullStyleMember self) -> StepVisual_NullStyle

        :rtype: OCC.wrapper.StepVisual.StepVisual_NullStyle

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_Value(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_NullStyleMember self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_NullStyleMember_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_NullStyleMember_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetKind(self, *args):
        """
        SetKind(Handle_StepVisual_NullStyleMember self, Standard_Integer const kind)

        :type kind: int

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_SetKind(self, *args)


    def Int(self, *args):
        """
        Int(Handle_StepVisual_NullStyleMember self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_Int(self, *args)


    def SetInt(self, *args):
        """
        SetInt(Handle_StepVisual_NullStyleMember self, Standard_Integer const val)

        :type val: int

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_SetInt(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_StepVisual_NullStyleMember self, Standard_CString const name) -> Standard_Boolean

        Tells if the name of a SelectMember matches a given one
        By default, compares the strings, can be redefined (optimised)

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_Matches(self, *args)


    def ParamType(self, *args):
        """
        ParamType(Handle_StepVisual_NullStyleMember self) -> Interface_ParamType

        Returns the Kind of the SelectMember, under the form of an
        enum ParamType

        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_ParamType(self, *args)


    def Integer(self, *args):
        """
        Integer(Handle_StepVisual_NullStyleMember self) -> Standard_Integer

        Gets the value as an Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_Integer(self, *args)


    def SetInteger(self, *args):
        """
        SetInteger(Handle_StepVisual_NullStyleMember self, Standard_Integer const val)

        :type val: int

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_SetInteger(self, *args)


    def Boolean(self, *args):
        """
        Boolean(Handle_StepVisual_NullStyleMember self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_Boolean(self, *args)


    def SetBoolean(self, *args):
        """
        SetBoolean(Handle_StepVisual_NullStyleMember self, Standard_Boolean const val)

        :type val: bool

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_SetBoolean(self, *args)


    def Logical(self, *args):
        """
        Logical(Handle_StepVisual_NullStyleMember self) -> StepData_Logical

        :rtype: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_Logical(self, *args)


    def SetLogical(self, *args):
        """
        SetLogical(Handle_StepVisual_NullStyleMember self, StepData_Logical const val)

        :type val: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_SetLogical(self, *args)


    def Real(self, *args):
        """
        Real(Handle_StepVisual_NullStyleMember self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_Real(self, *args)


    def SetReal(self, *args):
        """
        SetReal(Handle_StepVisual_NullStyleMember self, Standard_Real const val)

        :type val: float

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_SetReal(self, *args)


    def String(self, *args):
        """
        String(Handle_StepVisual_NullStyleMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_String(self, *args)


    def SetString(self, *args):
        """
        SetString(Handle_StepVisual_NullStyleMember self, Standard_CString const val)

        :type val: OCC.wrapper.Standard.Standard_CString

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_SetString(self, *args)


    def Enum(self, *args):
        """
        Enum(Handle_StepVisual_NullStyleMember self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_Enum(self, *args)


    def SetEnum(self, *args):
        """
        SetEnum(Handle_StepVisual_NullStyleMember self, Standard_Integer const val, Standard_CString const text)

        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_SetEnum(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_NullStyleMember self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_NullStyleMember self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_NullStyleMember self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_NullStyleMember self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_NullStyleMember self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_NullStyleMember self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_NullStyleMember self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_NullStyleMember self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_NullStyleMember self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_NullStyleMember_DecrementRefCounter(self, *args)

Handle_StepVisual_NullStyleMember_swigregister = _StepVisual.Handle_StepVisual_NullStyleMember_swigregister
Handle_StepVisual_NullStyleMember_swigregister(Handle_StepVisual_NullStyleMember)

def Handle_StepVisual_NullStyleMember_DownCast(thing):
    return _StepVisual.Handle_StepVisual_NullStyleMember_DownCast(thing)
Handle_StepVisual_NullStyleMember_DownCast = _StepVisual.Handle_StepVisual_NullStyleMember_DownCast

class StepVisual_HArray1OfInvisibleItem(NCollection_Array1_StepVisual_InvisibleItem, Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_HArray1OfInvisibleItem
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_HArray1OfInvisibleItem(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_HArray1OfInvisibleItem self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepVisual_HArray1OfInvisibleItem
        __init__(StepVisual_HArray1OfInvisibleItem self, Standard_Integer const theLower, Standard_Integer const theUpper, StepVisual_InvisibleItem theValue) -> StepVisual_HArray1OfInvisibleItem
        __init__(StepVisual_HArray1OfInvisibleItem self, NCollection_Array1_StepVisual_InvisibleItem theOther) -> StepVisual_HArray1OfInvisibleItem

        :type theOther: OCC.wrapper.StepVisual.StepVisual_Array1OfInvisibleItem

        """
        this = _StepVisual.new_StepVisual_HArray1OfInvisibleItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfInvisibleItem

        """
        res = _StepVisual.StepVisual_HArray1OfInvisibleItem_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepVisual_HArray1OfInvisibleItem self) -> NCollection_Array1_StepVisual_InvisibleItem

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfInvisibleItem

        """
        return _StepVisual.StepVisual_HArray1OfInvisibleItem_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_HArray1OfInvisibleItem_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_HArray1OfInvisibleItem_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_HArray1OfInvisibleItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_HArray1OfInvisibleItem
StepVisual_HArray1OfInvisibleItem_swigregister = _StepVisual.StepVisual_HArray1OfInvisibleItem_swigregister
StepVisual_HArray1OfInvisibleItem_swigregister(StepVisual_HArray1OfInvisibleItem)

def StepVisual_HArray1OfInvisibleItem_get_type_name(*args):
    """
    StepVisual_HArray1OfInvisibleItem_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_HArray1OfInvisibleItem_get_type_name(*args)

def StepVisual_HArray1OfInvisibleItem_get_type_descriptor(*args):
    """
    StepVisual_HArray1OfInvisibleItem_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_HArray1OfInvisibleItem_get_type_descriptor(*args)

class StepVisual_CoordinatesList(StepVisual_TessellatedItem):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepVisual_CoordinatesList
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepVisual_CoordinatesList(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepVisual_CoordinatesList self) -> StepVisual_CoordinatesList

        Returns a coordinate list


        """
        this = _StepVisual.new_StepVisual_CoordinatesList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepVisual_CoordinatesList self, Handle_TCollection_HAsciiString theName, Handle_TColgp_HArray1OfXYZ thePoints)

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type thePoints: OCC.wrapper.TColgp.Handle_TColgp_HArray1OfXYZ

        """
        return _StepVisual.StepVisual_CoordinatesList_Init(self, *args)


    def Points(self, *args):
        """
        Points(StepVisual_CoordinatesList self) -> Handle_TColgp_HArray1OfXYZ

        :rtype: OCC.wrapper.TColgp.Handle_TColgp_HArray1OfXYZ

        """
        return _StepVisual.StepVisual_CoordinatesList_Points(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepVisual.StepVisual_CoordinatesList_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepVisual.StepVisual_CoordinatesList_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.StepVisual_CoordinatesList_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepVisual.delete_StepVisual_CoordinatesList
StepVisual_CoordinatesList_swigregister = _StepVisual.StepVisual_CoordinatesList_swigregister
StepVisual_CoordinatesList_swigregister(StepVisual_CoordinatesList)

def StepVisual_CoordinatesList_get_type_name(*args):
    """
    StepVisual_CoordinatesList_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepVisual.StepVisual_CoordinatesList_get_type_name(*args)

def StepVisual_CoordinatesList_get_type_descriptor(*args):
    """
    StepVisual_CoordinatesList_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepVisual.StepVisual_CoordinatesList_get_type_descriptor(*args)

class NCollection_Array1_StepVisual_BoxCharacteristicSelect(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_StepVisual_BoxCharacteristicSelect self) -> NCollection_Array1< StepVisual_BoxCharacteristicSelect >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_BoxCharacteristicSelect_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_StepVisual_BoxCharacteristicSelect self) -> NCollection_Array1< StepVisual_BoxCharacteristicSelect >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_BoxCharacteristicSelect_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_StepVisual_BoxCharacteristicSelect self) -> NCollection_Array1< StepVisual_BoxCharacteristicSelect >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_BoxCharacteristicSelect_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_StepVisual_BoxCharacteristicSelect self) -> NCollection_Array1< StepVisual_BoxCharacteristicSelect >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.NCollection_Array1_StepVisual_BoxCharacteristicSelect_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepVisual.new_NCollection_Array1_StepVisual_BoxCharacteristicSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_StepVisual_BoxCharacteristicSelect self, StepVisual_BoxCharacteristicSelect theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_BoxCharacteristicSelect_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_StepVisual_BoxCharacteristicSelect self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_BoxCharacteristicSelect_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_StepVisual_BoxCharacteristicSelect self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_BoxCharacteristicSelect_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_StepVisual_BoxCharacteristicSelect self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_BoxCharacteristicSelect_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_StepVisual_BoxCharacteristicSelect self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_BoxCharacteristicSelect_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_StepVisual_BoxCharacteristicSelect self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.NCollection_Array1_StepVisual_BoxCharacteristicSelect_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_StepVisual_BoxCharacteristicSelect self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_BoxCharacteristicSelect_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_StepVisual_BoxCharacteristicSelect self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.NCollection_Array1_StepVisual_BoxCharacteristicSelect_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_StepVisual_BoxCharacteristicSelect self, NCollection_Array1_StepVisual_BoxCharacteristicSelect theOther) -> NCollection_Array1_StepVisual_BoxCharacteristicSelect

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_BoxCharacteristicSelect_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_StepVisual_BoxCharacteristicSelect self, NCollection_Array1_StepVisual_BoxCharacteristicSelect theOther) -> NCollection_Array1_StepVisual_BoxCharacteristicSelect

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_BoxCharacteristicSelect_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_StepVisual_BoxCharacteristicSelect self, NCollection_Array1_StepVisual_BoxCharacteristicSelect theOther) -> NCollection_Array1_StepVisual_BoxCharacteristicSelect
        assign(NCollection_Array1_StepVisual_BoxCharacteristicSelect self, NCollection_Array1_StepVisual_BoxCharacteristicSelect theOther) -> NCollection_Array1_StepVisual_BoxCharacteristicSelect

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.NCollection_Array1_StepVisual_BoxCharacteristicSelect_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_BoxCharacteristicSelect_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_StepVisual_BoxCharacteristicSelect self) -> StepVisual_BoxCharacteristicSelect

        @return first element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_BoxCharacteristicSelect_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_BoxCharacteristicSelect_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_StepVisual_BoxCharacteristicSelect self) -> StepVisual_BoxCharacteristicSelect

        @return last element

        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_BoxCharacteristicSelect_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_BoxCharacteristicSelect_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_StepVisual_BoxCharacteristicSelect self, Standard_Integer const theIndex) -> StepVisual_BoxCharacteristicSelect

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_BoxCharacteristicSelect_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_BoxCharacteristicSelect___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.NCollection_Array1_StepVisual_BoxCharacteristicSelect_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_StepVisual_BoxCharacteristicSelect self, Standard_Integer const theIndex, StepVisual_BoxCharacteristicSelect theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepVisual.NCollection_Array1_StepVisual_BoxCharacteristicSelect_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_StepVisual_BoxCharacteristicSelect self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepVisual.NCollection_Array1_StepVisual_BoxCharacteristicSelect_Resize(self, *args)

    __swig_destroy__ = _StepVisual.delete_NCollection_Array1_StepVisual_BoxCharacteristicSelect
NCollection_Array1_StepVisual_BoxCharacteristicSelect_swigregister = _StepVisual.NCollection_Array1_StepVisual_BoxCharacteristicSelect_swigregister
NCollection_Array1_StepVisual_BoxCharacteristicSelect_swigregister(NCollection_Array1_StepVisual_BoxCharacteristicSelect)


try:
	StepVisual_Array1OfBoxCharacteristicSelect = NCollection_Array1_StepVisual_BoxCharacteristicSelect
except NameError:
	pass # does not exist, probably ignored

class Handle_StepVisual_FillAreaStyle(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_FillAreaStyle self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_FillAreaStyle_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_FillAreaStyle self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyle_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_FillAreaStyle self, StepVisual_FillAreaStyle thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyle_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_FillAreaStyle self, Handle_StepVisual_FillAreaStyle theHandle) -> Handle_StepVisual_FillAreaStyle
        assign(Handle_StepVisual_FillAreaStyle self, StepVisual_FillAreaStyle thePtr) -> Handle_StepVisual_FillAreaStyle
        assign(Handle_StepVisual_FillAreaStyle self, Handle_StepVisual_FillAreaStyle theHandle) -> Handle_StepVisual_FillAreaStyle

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyle_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_FillAreaStyle self) -> StepVisual_FillAreaStyle

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyle_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_FillAreaStyle self) -> StepVisual_FillAreaStyle

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyle___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_FillAreaStyle self) -> StepVisual_FillAreaStyle

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyle___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_FillAreaStyle___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_FillAreaStyle___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_FillAreaStyle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_FillAreaStyle_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_FillAreaStyle

    def Init(self, *args):
        """
        Init(Handle_StepVisual_FillAreaStyle self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_HArray1OfFillStyleSelect aFillStyles)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFillStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyle_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_FillAreaStyle self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyle_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_FillAreaStyle self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyle_Name(self, *args)


    def SetFillStyles(self, *args):
        """
        SetFillStyles(Handle_StepVisual_FillAreaStyle self, Handle_StepVisual_HArray1OfFillStyleSelect aFillStyles)

        :type aFillStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyle_SetFillStyles(self, *args)


    def FillStyles(self, *args):
        """
        FillStyles(Handle_StepVisual_FillAreaStyle self) -> Handle_StepVisual_HArray1OfFillStyleSelect

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfFillStyleSelect

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyle_FillStyles(self, *args)


    def FillStylesValue(self, *args):
        """
        FillStylesValue(Handle_StepVisual_FillAreaStyle self, Standard_Integer const num) -> StepVisual_FillStyleSelect

        :type num: int
        :rtype: OCC.wrapper.StepVisual.StepVisual_FillStyleSelect

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyle_FillStylesValue(self, *args)


    def NbFillStyles(self, *args):
        """
        NbFillStyles(Handle_StepVisual_FillAreaStyle self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyle_NbFillStyles(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_FillAreaStyle self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyle_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_FillAreaStyle_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_FillAreaStyle_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_FillAreaStyle self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_FillAreaStyle_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_FillAreaStyle self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_FillAreaStyle self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyle_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_FillAreaStyle self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_FillAreaStyle self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyle_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_FillAreaStyle self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyle_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_FillAreaStyle self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyle_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_FillAreaStyle self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_FillAreaStyle_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_FillAreaStyle self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_FillAreaStyle_DecrementRefCounter(self, *args)

Handle_StepVisual_FillAreaStyle_swigregister = _StepVisual.Handle_StepVisual_FillAreaStyle_swigregister
Handle_StepVisual_FillAreaStyle_swigregister(Handle_StepVisual_FillAreaStyle)

def Handle_StepVisual_FillAreaStyle_DownCast(thing):
    return _StepVisual.Handle_StepVisual_FillAreaStyle_DownCast(thing)
Handle_StepVisual_FillAreaStyle_DownCast = _StepVisual.Handle_StepVisual_FillAreaStyle_DownCast

class Handle_StepVisual_PointStyle(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_PointStyle self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_PointStyle_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_PointStyle self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_PointStyle_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_PointStyle self, StepVisual_PointStyle thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_PointStyle_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_PointStyle self, Handle_StepVisual_PointStyle theHandle) -> Handle_StepVisual_PointStyle
        assign(Handle_StepVisual_PointStyle self, StepVisual_PointStyle thePtr) -> Handle_StepVisual_PointStyle
        assign(Handle_StepVisual_PointStyle self, Handle_StepVisual_PointStyle theHandle) -> Handle_StepVisual_PointStyle

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_PointStyle_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_PointStyle self) -> StepVisual_PointStyle

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PointStyle_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_PointStyle self) -> StepVisual_PointStyle

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PointStyle___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_PointStyle self) -> StepVisual_PointStyle

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_PointStyle___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_PointStyle___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_PointStyle___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_PointStyle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_PointStyle_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_PointStyle

    def Init(self, *args):
        """
        Init(Handle_StepVisual_PointStyle self, Handle_TCollection_HAsciiString aName, StepVisual_MarkerSelect aMarker, StepBasic_SizeSelect aMarkerSize, Handle_StepVisual_Colour aMarkerColour)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aMarker: OCC.wrapper.StepVisual.StepVisual_MarkerSelect
        :type aMarkerSize: OCC.wrapper.StepBasic.StepBasic_SizeSelect
        :type aMarkerColour: OCC.wrapper.StepVisual.Handle_StepVisual_Colour

        """
        return _StepVisual.Handle_StepVisual_PointStyle_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_PointStyle self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_PointStyle_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_PointStyle self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_PointStyle_Name(self, *args)


    def SetMarker(self, *args):
        """
        SetMarker(Handle_StepVisual_PointStyle self, StepVisual_MarkerSelect aMarker)

        :type aMarker: OCC.wrapper.StepVisual.StepVisual_MarkerSelect

        """
        return _StepVisual.Handle_StepVisual_PointStyle_SetMarker(self, *args)


    def Marker(self, *args):
        """
        Marker(Handle_StepVisual_PointStyle self) -> StepVisual_MarkerSelect

        :rtype: OCC.wrapper.StepVisual.StepVisual_MarkerSelect

        """
        return _StepVisual.Handle_StepVisual_PointStyle_Marker(self, *args)


    def SetMarkerSize(self, *args):
        """
        SetMarkerSize(Handle_StepVisual_PointStyle self, StepBasic_SizeSelect aMarkerSize)

        :type aMarkerSize: OCC.wrapper.StepBasic.StepBasic_SizeSelect

        """
        return _StepVisual.Handle_StepVisual_PointStyle_SetMarkerSize(self, *args)


    def MarkerSize(self, *args):
        """
        MarkerSize(Handle_StepVisual_PointStyle self) -> StepBasic_SizeSelect

        :rtype: OCC.wrapper.StepBasic.StepBasic_SizeSelect

        """
        return _StepVisual.Handle_StepVisual_PointStyle_MarkerSize(self, *args)


    def SetMarkerColour(self, *args):
        """
        SetMarkerColour(Handle_StepVisual_PointStyle self, Handle_StepVisual_Colour aMarkerColour)

        :type aMarkerColour: OCC.wrapper.StepVisual.Handle_StepVisual_Colour

        """
        return _StepVisual.Handle_StepVisual_PointStyle_SetMarkerColour(self, *args)


    def MarkerColour(self, *args):
        """
        MarkerColour(Handle_StepVisual_PointStyle self) -> Handle_StepVisual_Colour

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_Colour

        """
        return _StepVisual.Handle_StepVisual_PointStyle_MarkerColour(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_PointStyle self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_PointStyle_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PointStyle_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PointStyle_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_PointStyle self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_PointStyle_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_PointStyle self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_PointStyle self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PointStyle_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_PointStyle self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_PointStyle self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PointStyle_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_PointStyle self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_PointStyle_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_PointStyle self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PointStyle_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_PointStyle self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_PointStyle_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_PointStyle self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PointStyle_DecrementRefCounter(self, *args)

Handle_StepVisual_PointStyle_swigregister = _StepVisual.Handle_StepVisual_PointStyle_swigregister
Handle_StepVisual_PointStyle_swigregister(Handle_StepVisual_PointStyle)

def Handle_StepVisual_PointStyle_DownCast(thing):
    return _StepVisual.Handle_StepVisual_PointStyle_DownCast(thing)
Handle_StepVisual_PointStyle_DownCast = _StepVisual.Handle_StepVisual_PointStyle_DownCast

class Handle_StepVisual_HArray1OfLayeredItem(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_HArray1OfLayeredItem self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_HArray1OfLayeredItem self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_HArray1OfLayeredItem self, StepVisual_HArray1OfLayeredItem thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_HArray1OfLayeredItem self, Handle_StepVisual_HArray1OfLayeredItem theHandle) -> Handle_StepVisual_HArray1OfLayeredItem
        assign(Handle_StepVisual_HArray1OfLayeredItem self, StepVisual_HArray1OfLayeredItem thePtr) -> Handle_StepVisual_HArray1OfLayeredItem
        assign(Handle_StepVisual_HArray1OfLayeredItem self, Handle_StepVisual_HArray1OfLayeredItem theHandle) -> Handle_StepVisual_HArray1OfLayeredItem

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_HArray1OfLayeredItem self) -> StepVisual_HArray1OfLayeredItem

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_HArray1OfLayeredItem self) -> StepVisual_HArray1OfLayeredItem

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_HArray1OfLayeredItem self) -> StepVisual_HArray1OfLayeredItem

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_HArray1OfLayeredItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_HArray1OfLayeredItem_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_HArray1OfLayeredItem

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfLayeredItem

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepVisual_HArray1OfLayeredItem self) -> NCollection_Array1_StepVisual_LayeredItem

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfLayeredItem

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_HArray1OfLayeredItem self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def begin(self, *args):
        """
        begin(Handle_StepVisual_HArray1OfLayeredItem self) -> NCollection_Array1< StepVisual_LayeredItem >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_begin(self, *args)


    def end(self, *args):
        """
        end(Handle_StepVisual_HArray1OfLayeredItem self) -> NCollection_Array1< StepVisual_LayeredItem >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(Handle_StepVisual_HArray1OfLayeredItem self) -> NCollection_Array1< StepVisual_LayeredItem >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(Handle_StepVisual_HArray1OfLayeredItem self) -> NCollection_Array1< StepVisual_LayeredItem >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_cend(self, *args)


    def Init(self, *args):
        """
        Init(Handle_StepVisual_HArray1OfLayeredItem self, StepVisual_LayeredItem theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_Init(self, *args)


    def Size(self, *args):
        """
        Size(Handle_StepVisual_HArray1OfLayeredItem self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_Size(self, *args)


    def Length(self, *args):
        """
        Length(Handle_StepVisual_HArray1OfLayeredItem self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_StepVisual_HArray1OfLayeredItem self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(Handle_StepVisual_HArray1OfLayeredItem self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(Handle_StepVisual_HArray1OfLayeredItem self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(Handle_StepVisual_HArray1OfLayeredItem self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(Handle_StepVisual_HArray1OfLayeredItem self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(Handle_StepVisual_HArray1OfLayeredItem self, NCollection_Array1_StepVisual_LayeredItem theOther) -> NCollection_Array1_StepVisual_LayeredItem

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_Assign(self, *args)


    def Move(self, *args):
        """
        Move(Handle_StepVisual_HArray1OfLayeredItem self, NCollection_Array1_StepVisual_LayeredItem theOther) -> NCollection_Array1_StepVisual_LayeredItem

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_Move(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(Handle_StepVisual_HArray1OfLayeredItem self) -> StepVisual_LayeredItem

        @return first element

        :rtype: TheItemType &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(Handle_StepVisual_HArray1OfLayeredItem self) -> StepVisual_LayeredItem

        @return last element

        :rtype: TheItemType &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfLayeredItem___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(Handle_StepVisual_HArray1OfLayeredItem self, Standard_Integer const theIndex) -> StepVisual_LayeredItem

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_StepVisual_HArray1OfLayeredItem self, Standard_Integer const theIndex, StepVisual_LayeredItem theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(Handle_StepVisual_HArray1OfLayeredItem self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_Resize(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_HArray1OfLayeredItem self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_HArray1OfLayeredItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_HArray1OfLayeredItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_HArray1OfLayeredItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_HArray1OfLayeredItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_HArray1OfLayeredItem self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_HArray1OfLayeredItem self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_HArray1OfLayeredItem self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_HArray1OfLayeredItem self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_DecrementRefCounter(self, *args)

Handle_StepVisual_HArray1OfLayeredItem_swigregister = _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_swigregister
Handle_StepVisual_HArray1OfLayeredItem_swigregister(Handle_StepVisual_HArray1OfLayeredItem)

def Handle_StepVisual_HArray1OfLayeredItem_DownCast(thing):
    return _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_DownCast(thing)
Handle_StepVisual_HArray1OfLayeredItem_DownCast = _StepVisual.Handle_StepVisual_HArray1OfLayeredItem_DownCast

class Handle_StepVisual_CoordinatesList(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_CoordinatesList self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_CoordinatesList_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_CoordinatesList self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_CoordinatesList_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_CoordinatesList self, StepVisual_CoordinatesList thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_CoordinatesList_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_CoordinatesList self, Handle_StepVisual_CoordinatesList theHandle) -> Handle_StepVisual_CoordinatesList
        assign(Handle_StepVisual_CoordinatesList self, StepVisual_CoordinatesList thePtr) -> Handle_StepVisual_CoordinatesList
        assign(Handle_StepVisual_CoordinatesList self, Handle_StepVisual_CoordinatesList theHandle) -> Handle_StepVisual_CoordinatesList

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_CoordinatesList_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_CoordinatesList self) -> StepVisual_CoordinatesList

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CoordinatesList_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_CoordinatesList self) -> StepVisual_CoordinatesList

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CoordinatesList___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_CoordinatesList self) -> StepVisual_CoordinatesList

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_CoordinatesList___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_CoordinatesList___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_CoordinatesList___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_CoordinatesList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_CoordinatesList_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_CoordinatesList

    def Init(self, *args):
        """
        Init(Handle_StepVisual_CoordinatesList self, Handle_TCollection_HAsciiString theName, Handle_TColgp_HArray1OfXYZ thePoints)

        :type theName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type thePoints: OCC.wrapper.TColgp.Handle_TColgp_HArray1OfXYZ

        """
        return _StepVisual.Handle_StepVisual_CoordinatesList_Init(self, *args)


    def Points(self, *args):
        """
        Points(Handle_StepVisual_CoordinatesList self) -> Handle_TColgp_HArray1OfXYZ

        :rtype: OCC.wrapper.TColgp.Handle_TColgp_HArray1OfXYZ

        """
        return _StepVisual.Handle_StepVisual_CoordinatesList_Points(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_CoordinatesList self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_CoordinatesList_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CoordinatesList_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CoordinatesList_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_CoordinatesList self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CoordinatesList_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_CoordinatesList self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CoordinatesList_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_CoordinatesList self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_CoordinatesList_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_CoordinatesList self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_CoordinatesList self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CoordinatesList_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_CoordinatesList self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_CoordinatesList self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CoordinatesList_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_CoordinatesList self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_CoordinatesList_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_CoordinatesList self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CoordinatesList_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_CoordinatesList self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_CoordinatesList_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_CoordinatesList self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CoordinatesList_DecrementRefCounter(self, *args)

Handle_StepVisual_CoordinatesList_swigregister = _StepVisual.Handle_StepVisual_CoordinatesList_swigregister
Handle_StepVisual_CoordinatesList_swigregister(Handle_StepVisual_CoordinatesList)

def Handle_StepVisual_CoordinatesList_DownCast(thing):
    return _StepVisual.Handle_StepVisual_CoordinatesList_DownCast(thing)
Handle_StepVisual_CoordinatesList_DownCast = _StepVisual.Handle_StepVisual_CoordinatesList_DownCast

class Handle_StepVisual_SurfaceStyleSegmentationCurve(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_SurfaceStyleSegmentationCurve self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSegmentationCurve_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_SurfaceStyleSegmentationCurve self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSegmentationCurve_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_SurfaceStyleSegmentationCurve self, StepVisual_SurfaceStyleSegmentationCurve thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSegmentationCurve_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_SurfaceStyleSegmentationCurve self, Handle_StepVisual_SurfaceStyleSegmentationCurve theHandle) -> Handle_StepVisual_SurfaceStyleSegmentationCurve
        assign(Handle_StepVisual_SurfaceStyleSegmentationCurve self, StepVisual_SurfaceStyleSegmentationCurve thePtr) -> Handle_StepVisual_SurfaceStyleSegmentationCurve
        assign(Handle_StepVisual_SurfaceStyleSegmentationCurve self, Handle_StepVisual_SurfaceStyleSegmentationCurve theHandle) -> Handle_StepVisual_SurfaceStyleSegmentationCurve

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSegmentationCurve_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_SurfaceStyleSegmentationCurve self) -> StepVisual_SurfaceStyleSegmentationCurve

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSegmentationCurve_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_SurfaceStyleSegmentationCurve self) -> StepVisual_SurfaceStyleSegmentationCurve

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSegmentationCurve___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_SurfaceStyleSegmentationCurve self) -> StepVisual_SurfaceStyleSegmentationCurve

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSegmentationCurve___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_SurfaceStyleSegmentationCurve___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_SurfaceStyleSegmentationCurve___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_SurfaceStyleSegmentationCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_SurfaceStyleSegmentationCurve_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_SurfaceStyleSegmentationCurve

    def Init(self, *args):
        """
        Init(Handle_StepVisual_SurfaceStyleSegmentationCurve self, Handle_StepVisual_CurveStyle aStyleOfSegmentationCurve)

        :type aStyleOfSegmentationCurve: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSegmentationCurve_Init(self, *args)


    def SetStyleOfSegmentationCurve(self, *args):
        """
        SetStyleOfSegmentationCurve(Handle_StepVisual_SurfaceStyleSegmentationCurve self, Handle_StepVisual_CurveStyle aStyleOfSegmentationCurve)

        :type aStyleOfSegmentationCurve: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSegmentationCurve_SetStyleOfSegmentationCurve(self, *args)


    def StyleOfSegmentationCurve(self, *args):
        """
        StyleOfSegmentationCurve(Handle_StepVisual_SurfaceStyleSegmentationCurve self) -> Handle_StepVisual_CurveStyle

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_CurveStyle

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSegmentationCurve_StyleOfSegmentationCurve(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_SurfaceStyleSegmentationCurve self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSegmentationCurve_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_SurfaceStyleSegmentationCurve_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_SurfaceStyleSegmentationCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_SurfaceStyleSegmentationCurve self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSegmentationCurve_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_SurfaceStyleSegmentationCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_SurfaceStyleSegmentationCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSegmentationCurve_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_SurfaceStyleSegmentationCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_SurfaceStyleSegmentationCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSegmentationCurve_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_SurfaceStyleSegmentationCurve self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSegmentationCurve_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_SurfaceStyleSegmentationCurve self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSegmentationCurve_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_SurfaceStyleSegmentationCurve self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSegmentationCurve_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_SurfaceStyleSegmentationCurve self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_SurfaceStyleSegmentationCurve_DecrementRefCounter(self, *args)

Handle_StepVisual_SurfaceStyleSegmentationCurve_swigregister = _StepVisual.Handle_StepVisual_SurfaceStyleSegmentationCurve_swigregister
Handle_StepVisual_SurfaceStyleSegmentationCurve_swigregister(Handle_StepVisual_SurfaceStyleSegmentationCurve)

def Handle_StepVisual_SurfaceStyleSegmentationCurve_DownCast(thing):
    return _StepVisual.Handle_StepVisual_SurfaceStyleSegmentationCurve_DownCast(thing)
Handle_StepVisual_SurfaceStyleSegmentationCurve_DownCast = _StepVisual.Handle_StepVisual_SurfaceStyleSegmentationCurve_DownCast

class Handle_StepVisual_BackgroundColour(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_BackgroundColour self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_BackgroundColour_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_BackgroundColour self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_BackgroundColour_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_BackgroundColour self, StepVisual_BackgroundColour thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_BackgroundColour_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_BackgroundColour self, Handle_StepVisual_BackgroundColour theHandle) -> Handle_StepVisual_BackgroundColour
        assign(Handle_StepVisual_BackgroundColour self, StepVisual_BackgroundColour thePtr) -> Handle_StepVisual_BackgroundColour
        assign(Handle_StepVisual_BackgroundColour self, Handle_StepVisual_BackgroundColour theHandle) -> Handle_StepVisual_BackgroundColour

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_BackgroundColour_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_BackgroundColour self) -> StepVisual_BackgroundColour

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_BackgroundColour_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_BackgroundColour self) -> StepVisual_BackgroundColour

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_BackgroundColour___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_BackgroundColour self) -> StepVisual_BackgroundColour

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_BackgroundColour___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_BackgroundColour___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_BackgroundColour___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_BackgroundColour(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_BackgroundColour_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_BackgroundColour

    def Init(self, *args):
        """
        Init(Handle_StepVisual_BackgroundColour self, StepVisual_AreaOrView aPresentation)

        :type aPresentation: OCC.wrapper.StepVisual.StepVisual_AreaOrView

        """
        return _StepVisual.Handle_StepVisual_BackgroundColour_Init(self, *args)


    def SetPresentation(self, *args):
        """
        SetPresentation(Handle_StepVisual_BackgroundColour self, StepVisual_AreaOrView aPresentation)

        :type aPresentation: OCC.wrapper.StepVisual.StepVisual_AreaOrView

        """
        return _StepVisual.Handle_StepVisual_BackgroundColour_SetPresentation(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_StepVisual_BackgroundColour self) -> StepVisual_AreaOrView

        :rtype: OCC.wrapper.StepVisual.StepVisual_AreaOrView

        """
        return _StepVisual.Handle_StepVisual_BackgroundColour_Presentation(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_BackgroundColour self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_BackgroundColour_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_BackgroundColour_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_BackgroundColour_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_BackgroundColour self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_BackgroundColour_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_BackgroundColour self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_BackgroundColour self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_BackgroundColour_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_BackgroundColour self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_BackgroundColour self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_BackgroundColour_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_BackgroundColour self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_BackgroundColour_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_BackgroundColour self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_BackgroundColour_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_BackgroundColour self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_BackgroundColour_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_BackgroundColour self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_BackgroundColour_DecrementRefCounter(self, *args)

Handle_StepVisual_BackgroundColour_swigregister = _StepVisual.Handle_StepVisual_BackgroundColour_swigregister
Handle_StepVisual_BackgroundColour_swigregister(Handle_StepVisual_BackgroundColour)

def Handle_StepVisual_BackgroundColour_DownCast(thing):
    return _StepVisual.Handle_StepVisual_BackgroundColour_DownCast(thing)
Handle_StepVisual_BackgroundColour_DownCast = _StepVisual.Handle_StepVisual_BackgroundColour_DownCast

class Handle_StepVisual_PlanarBox(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_PlanarBox self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_PlanarBox_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_PlanarBox self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_PlanarBox_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_PlanarBox self, StepVisual_PlanarBox thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_PlanarBox_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_PlanarBox self, Handle_StepVisual_PlanarBox theHandle) -> Handle_StepVisual_PlanarBox
        assign(Handle_StepVisual_PlanarBox self, StepVisual_PlanarBox thePtr) -> Handle_StepVisual_PlanarBox
        assign(Handle_StepVisual_PlanarBox self, Handle_StepVisual_PlanarBox theHandle) -> Handle_StepVisual_PlanarBox

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_PlanarBox_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_PlanarBox self) -> StepVisual_PlanarBox

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PlanarBox_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_PlanarBox self) -> StepVisual_PlanarBox

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_PlanarBox___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_PlanarBox self) -> StepVisual_PlanarBox

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_PlanarBox___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_PlanarBox___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_PlanarBox___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_PlanarBox(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_PlanarBox_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_PlanarBox

    def Init(self, *args):
        """
        Init(Handle_StepVisual_PlanarBox self, Handle_TCollection_HAsciiString aName, Standard_Real const aSizeInX, Standard_Real const aSizeInY, StepGeom_Axis2Placement aPlacement)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aSizeInX: float
        :type aSizeInY: float
        :type aPlacement: OCC.wrapper.StepGeom.StepGeom_Axis2Placement

        """
        return _StepVisual.Handle_StepVisual_PlanarBox_Init(self, *args)


    def SetPlacement(self, *args):
        """
        SetPlacement(Handle_StepVisual_PlanarBox self, StepGeom_Axis2Placement aPlacement)

        :type aPlacement: OCC.wrapper.StepGeom.StepGeom_Axis2Placement

        """
        return _StepVisual.Handle_StepVisual_PlanarBox_SetPlacement(self, *args)


    def Placement(self, *args):
        """
        Placement(Handle_StepVisual_PlanarBox self) -> StepGeom_Axis2Placement

        :rtype: OCC.wrapper.StepGeom.StepGeom_Axis2Placement

        """
        return _StepVisual.Handle_StepVisual_PlanarBox_Placement(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_PlanarBox self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_PlanarBox_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PlanarBox_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_PlanarBox_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSizeInX(self, *args):
        """
        SetSizeInX(Handle_StepVisual_PlanarBox self, Standard_Real const aSizeInX)

        :type aSizeInX: float

        """
        return _StepVisual.Handle_StepVisual_PlanarBox_SetSizeInX(self, *args)


    def SizeInX(self, *args):
        """
        SizeInX(Handle_StepVisual_PlanarBox self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepVisual.Handle_StepVisual_PlanarBox_SizeInX(self, *args)


    def SetSizeInY(self, *args):
        """
        SetSizeInY(Handle_StepVisual_PlanarBox self, Standard_Real const aSizeInY)

        :type aSizeInY: float

        """
        return _StepVisual.Handle_StepVisual_PlanarBox_SetSizeInY(self, *args)


    def SizeInY(self, *args):
        """
        SizeInY(Handle_StepVisual_PlanarBox self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepVisual.Handle_StepVisual_PlanarBox_SizeInY(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_PlanarBox self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_PlanarBox_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_PlanarBox self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_PlanarBox_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_PlanarBox self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_PlanarBox_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_PlanarBox self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_PlanarBox self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PlanarBox_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_PlanarBox self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_PlanarBox self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_PlanarBox_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_PlanarBox self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_PlanarBox_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_PlanarBox self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PlanarBox_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_PlanarBox self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_PlanarBox_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_PlanarBox self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_PlanarBox_DecrementRefCounter(self, *args)

Handle_StepVisual_PlanarBox_swigregister = _StepVisual.Handle_StepVisual_PlanarBox_swigregister
Handle_StepVisual_PlanarBox_swigregister(Handle_StepVisual_PlanarBox)

def Handle_StepVisual_PlanarBox_DownCast(thing):
    return _StepVisual.Handle_StepVisual_PlanarBox_DownCast(thing)
Handle_StepVisual_PlanarBox_DownCast = _StepVisual.Handle_StepVisual_PlanarBox_DownCast

class Handle_StepVisual_CameraModel(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_CameraModel self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_CameraModel_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_CameraModel self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_CameraModel_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_CameraModel self, StepVisual_CameraModel thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_CameraModel_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_CameraModel self, Handle_StepVisual_CameraModel theHandle) -> Handle_StepVisual_CameraModel
        assign(Handle_StepVisual_CameraModel self, StepVisual_CameraModel thePtr) -> Handle_StepVisual_CameraModel
        assign(Handle_StepVisual_CameraModel self, Handle_StepVisual_CameraModel theHandle) -> Handle_StepVisual_CameraModel

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_CameraModel_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_CameraModel self) -> StepVisual_CameraModel

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CameraModel_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_CameraModel self) -> StepVisual_CameraModel

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CameraModel___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_CameraModel self) -> StepVisual_CameraModel

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_CameraModel___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_CameraModel___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_CameraModel___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_CameraModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_CameraModel_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_CameraModel

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_CameraModel self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_CameraModel_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CameraModel_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CameraModel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_CameraModel self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CameraModel_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_CameraModel self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CameraModel_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_CameraModel self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CameraModel_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_CameraModel self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_CameraModel_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_CameraModel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_CameraModel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CameraModel_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_CameraModel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_CameraModel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CameraModel_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_CameraModel self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_CameraModel_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_CameraModel self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CameraModel_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_CameraModel self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_CameraModel_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_CameraModel self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CameraModel_DecrementRefCounter(self, *args)

Handle_StepVisual_CameraModel_swigregister = _StepVisual.Handle_StepVisual_CameraModel_swigregister
Handle_StepVisual_CameraModel_swigregister(Handle_StepVisual_CameraModel)

def Handle_StepVisual_CameraModel_DownCast(thing):
    return _StepVisual.Handle_StepVisual_CameraModel_DownCast(thing)
Handle_StepVisual_CameraModel_DownCast = _StepVisual.Handle_StepVisual_CameraModel_DownCast

class StepVisual_MarkerSelect(StepData.StepData_SelectType):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepVisual_MarkerSelect self) -> StepVisual_MarkerSelect

        Returns a MarkerSelect SelectType


        """
        this = _StepVisual.new_StepVisual_MarkerSelect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepVisual_MarkerSelect self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a MarkerSelect Kind Entity that is :
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_MarkerSelect_CaseNum(self, *args)


    def NewMember(self, *args):
        """
        NewMember(StepVisual_MarkerSelect self) -> Handle_StepData_SelectMember

        Returns a new MarkerMember

        :rtype: OCC.wrapper.StepData.Handle_StepData_SelectMember

        """
        return _StepVisual.StepVisual_MarkerSelect_NewMember(self, *args)


    def CaseMem(self, *args):
        """
        CaseMem(StepVisual_MarkerSelect self, Handle_StepData_SelectMember sm) -> Standard_Integer

        Returns 1 for a SelectMember enum, named MARKER_TYPE

        :type sm: OCC.wrapper.StepData.Handle_StepData_SelectMember
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.StepVisual_MarkerSelect_CaseMem(self, *args)


    def MarkerMember(self, *args):
        """
        MarkerMember(StepVisual_MarkerSelect self) -> Handle_StepVisual_MarkerMember

        Gives access to the MarkerMember in order to get/set its value

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_MarkerMember

        """
        return _StepVisual.StepVisual_MarkerSelect_MarkerMember(self, *args)

    __swig_destroy__ = _StepVisual.delete_StepVisual_MarkerSelect
StepVisual_MarkerSelect_swigregister = _StepVisual.StepVisual_MarkerSelect_swigregister
StepVisual_MarkerSelect_swigregister(StepVisual_MarkerSelect)

class Handle_StepVisual_Invisibility(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_Invisibility self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_Invisibility_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_Invisibility self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_Invisibility_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_Invisibility self, StepVisual_Invisibility thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_Invisibility_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_Invisibility self, Handle_StepVisual_Invisibility theHandle) -> Handle_StepVisual_Invisibility
        assign(Handle_StepVisual_Invisibility self, StepVisual_Invisibility thePtr) -> Handle_StepVisual_Invisibility
        assign(Handle_StepVisual_Invisibility self, Handle_StepVisual_Invisibility theHandle) -> Handle_StepVisual_Invisibility

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_Invisibility_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_Invisibility self) -> StepVisual_Invisibility

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_Invisibility_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_Invisibility self) -> StepVisual_Invisibility

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_Invisibility___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_Invisibility self) -> StepVisual_Invisibility

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_Invisibility___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_Invisibility___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_Invisibility___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_Invisibility(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_Invisibility_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_Invisibility

    def Init(self, *args):
        """
        Init(Handle_StepVisual_Invisibility self, Handle_StepVisual_HArray1OfInvisibleItem aInvisibleItems)

        :type aInvisibleItems: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfInvisibleItem

        """
        return _StepVisual.Handle_StepVisual_Invisibility_Init(self, *args)


    def SetInvisibleItems(self, *args):
        """
        SetInvisibleItems(Handle_StepVisual_Invisibility self, Handle_StepVisual_HArray1OfInvisibleItem aInvisibleItems)

        :type aInvisibleItems: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfInvisibleItem

        """
        return _StepVisual.Handle_StepVisual_Invisibility_SetInvisibleItems(self, *args)


    def InvisibleItems(self, *args):
        """
        InvisibleItems(Handle_StepVisual_Invisibility self) -> Handle_StepVisual_HArray1OfInvisibleItem

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfInvisibleItem

        """
        return _StepVisual.Handle_StepVisual_Invisibility_InvisibleItems(self, *args)


    def InvisibleItemsValue(self, *args):
        """
        InvisibleItemsValue(Handle_StepVisual_Invisibility self, Standard_Integer const num) -> StepVisual_InvisibleItem

        :type num: int
        :rtype: OCC.wrapper.StepVisual.StepVisual_InvisibleItem

        """
        return _StepVisual.Handle_StepVisual_Invisibility_InvisibleItemsValue(self, *args)


    def NbInvisibleItems(self, *args):
        """
        NbInvisibleItems(Handle_StepVisual_Invisibility self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_Invisibility_NbInvisibleItems(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_Invisibility self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_Invisibility_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_Invisibility_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_Invisibility_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_Invisibility self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_Invisibility_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_Invisibility self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_Invisibility self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_Invisibility_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_Invisibility self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_Invisibility self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_Invisibility_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_Invisibility self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_Invisibility_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_Invisibility self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_Invisibility_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_Invisibility self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_Invisibility_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_Invisibility self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_Invisibility_DecrementRefCounter(self, *args)

Handle_StepVisual_Invisibility_swigregister = _StepVisual.Handle_StepVisual_Invisibility_swigregister
Handle_StepVisual_Invisibility_swigregister(Handle_StepVisual_Invisibility)

def Handle_StepVisual_Invisibility_DownCast(thing):
    return _StepVisual.Handle_StepVisual_Invisibility_DownCast(thing)
Handle_StepVisual_Invisibility_DownCast = _StepVisual.Handle_StepVisual_Invisibility_DownCast

class Handle_StepVisual_HArray1OfInvisibleItem(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_HArray1OfInvisibleItem self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_HArray1OfInvisibleItem self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_HArray1OfInvisibleItem self, StepVisual_HArray1OfInvisibleItem thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_HArray1OfInvisibleItem self, Handle_StepVisual_HArray1OfInvisibleItem theHandle) -> Handle_StepVisual_HArray1OfInvisibleItem
        assign(Handle_StepVisual_HArray1OfInvisibleItem self, StepVisual_HArray1OfInvisibleItem thePtr) -> Handle_StepVisual_HArray1OfInvisibleItem
        assign(Handle_StepVisual_HArray1OfInvisibleItem self, Handle_StepVisual_HArray1OfInvisibleItem theHandle) -> Handle_StepVisual_HArray1OfInvisibleItem

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_HArray1OfInvisibleItem self) -> StepVisual_HArray1OfInvisibleItem

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_HArray1OfInvisibleItem self) -> StepVisual_HArray1OfInvisibleItem

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_HArray1OfInvisibleItem self) -> StepVisual_HArray1OfInvisibleItem

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_HArray1OfInvisibleItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_HArray1OfInvisibleItem

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfInvisibleItem

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepVisual_HArray1OfInvisibleItem self) -> NCollection_Array1_StepVisual_InvisibleItem

        :rtype: OCC.wrapper.StepVisual.StepVisual_Array1OfInvisibleItem

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_HArray1OfInvisibleItem self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def begin(self, *args):
        """
        begin(Handle_StepVisual_HArray1OfInvisibleItem self) -> NCollection_Array1< StepVisual_InvisibleItem >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_begin(self, *args)


    def end(self, *args):
        """
        end(Handle_StepVisual_HArray1OfInvisibleItem self) -> NCollection_Array1< StepVisual_InvisibleItem >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(Handle_StepVisual_HArray1OfInvisibleItem self) -> NCollection_Array1< StepVisual_InvisibleItem >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(Handle_StepVisual_HArray1OfInvisibleItem self) -> NCollection_Array1< StepVisual_InvisibleItem >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_cend(self, *args)


    def Init(self, *args):
        """
        Init(Handle_StepVisual_HArray1OfInvisibleItem self, StepVisual_InvisibleItem theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_Init(self, *args)


    def Size(self, *args):
        """
        Size(Handle_StepVisual_HArray1OfInvisibleItem self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_Size(self, *args)


    def Length(self, *args):
        """
        Length(Handle_StepVisual_HArray1OfInvisibleItem self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_StepVisual_HArray1OfInvisibleItem self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(Handle_StepVisual_HArray1OfInvisibleItem self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(Handle_StepVisual_HArray1OfInvisibleItem self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(Handle_StepVisual_HArray1OfInvisibleItem self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(Handle_StepVisual_HArray1OfInvisibleItem self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(Handle_StepVisual_HArray1OfInvisibleItem self, NCollection_Array1_StepVisual_InvisibleItem theOther) -> NCollection_Array1_StepVisual_InvisibleItem

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_Assign(self, *args)


    def Move(self, *args):
        """
        Move(Handle_StepVisual_HArray1OfInvisibleItem self, NCollection_Array1_StepVisual_InvisibleItem theOther) -> NCollection_Array1_StepVisual_InvisibleItem

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_Move(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(Handle_StepVisual_HArray1OfInvisibleItem self) -> StepVisual_InvisibleItem

        @return first element

        :rtype: TheItemType &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(Handle_StepVisual_HArray1OfInvisibleItem self) -> StepVisual_InvisibleItem

        @return last element

        :rtype: TheItemType &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(Handle_StepVisual_HArray1OfInvisibleItem self, Standard_Integer const theIndex) -> StepVisual_InvisibleItem

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_StepVisual_HArray1OfInvisibleItem self, Standard_Integer const theIndex, StepVisual_InvisibleItem theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(Handle_StepVisual_HArray1OfInvisibleItem self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_Resize(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_HArray1OfInvisibleItem self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_HArray1OfInvisibleItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_HArray1OfInvisibleItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_HArray1OfInvisibleItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_HArray1OfInvisibleItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_HArray1OfInvisibleItem self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_HArray1OfInvisibleItem self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_HArray1OfInvisibleItem self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_HArray1OfInvisibleItem self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_DecrementRefCounter(self, *args)

Handle_StepVisual_HArray1OfInvisibleItem_swigregister = _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_swigregister
Handle_StepVisual_HArray1OfInvisibleItem_swigregister(Handle_StepVisual_HArray1OfInvisibleItem)

def Handle_StepVisual_HArray1OfInvisibleItem_DownCast(thing):
    return _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_DownCast(thing)
Handle_StepVisual_HArray1OfInvisibleItem_DownCast = _StepVisual.Handle_StepVisual_HArray1OfInvisibleItem_DownCast

class Handle_StepVisual_ContextDependentOverRidingStyledItem(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_ContextDependentOverRidingStyledItem self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_ContextDependentOverRidingStyledItem self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_ContextDependentOverRidingStyledItem self, StepVisual_ContextDependentOverRidingStyledItem thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_ContextDependentOverRidingStyledItem self, Handle_StepVisual_ContextDependentOverRidingStyledItem theHandle) -> Handle_StepVisual_ContextDependentOverRidingStyledItem
        assign(Handle_StepVisual_ContextDependentOverRidingStyledItem self, StepVisual_ContextDependentOverRidingStyledItem thePtr) -> Handle_StepVisual_ContextDependentOverRidingStyledItem
        assign(Handle_StepVisual_ContextDependentOverRidingStyledItem self, Handle_StepVisual_ContextDependentOverRidingStyledItem theHandle) -> Handle_StepVisual_ContextDependentOverRidingStyledItem

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_ContextDependentOverRidingStyledItem self) -> StepVisual_ContextDependentOverRidingStyledItem

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_ContextDependentOverRidingStyledItem self) -> StepVisual_ContextDependentOverRidingStyledItem

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_ContextDependentOverRidingStyledItem self) -> StepVisual_ContextDependentOverRidingStyledItem

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_ContextDependentOverRidingStyledItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_ContextDependentOverRidingStyledItem

    def Init(self, *args):
        """
        Init(Handle_StepVisual_ContextDependentOverRidingStyledItem self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_HArray1OfPresentationStyleAssignment aStyles, Handle_Standard_Transient aItem, Handle_StepVisual_StyledItem aOverRiddenStyle, Handle_StepVisual_HArray1OfStyleContextSelect aStyleContext)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment
        :type aItem: OCC.wrapper.Standard.Handle_Standard_Transient
        :type aOverRiddenStyle: OCC.wrapper.StepVisual.Handle_StepVisual_StyledItem
        :type aStyleContext: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_Init(self, *args)


    def SetStyleContext(self, *args):
        """
        SetStyleContext(Handle_StepVisual_ContextDependentOverRidingStyledItem self, Handle_StepVisual_HArray1OfStyleContextSelect aStyleContext)

        :type aStyleContext: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_SetStyleContext(self, *args)


    def StyleContext(self, *args):
        """
        StyleContext(Handle_StepVisual_ContextDependentOverRidingStyledItem self) -> Handle_StepVisual_HArray1OfStyleContextSelect

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfStyleContextSelect

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_StyleContext(self, *args)


    def StyleContextValue(self, *args):
        """
        StyleContextValue(Handle_StepVisual_ContextDependentOverRidingStyledItem self, Standard_Integer const num) -> StepVisual_StyleContextSelect

        :type num: int
        :rtype: OCC.wrapper.StepVisual.StepVisual_StyleContextSelect

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_StyleContextValue(self, *args)


    def NbStyleContext(self, *args):
        """
        NbStyleContext(Handle_StepVisual_ContextDependentOverRidingStyledItem self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_NbStyleContext(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_ContextDependentOverRidingStyledItem self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetOverRiddenStyle(self, *args):
        """
        SetOverRiddenStyle(Handle_StepVisual_ContextDependentOverRidingStyledItem self, Handle_StepVisual_StyledItem aOverRiddenStyle)

        :type aOverRiddenStyle: OCC.wrapper.StepVisual.Handle_StepVisual_StyledItem

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_SetOverRiddenStyle(self, *args)


    def OverRiddenStyle(self, *args):
        """
        OverRiddenStyle(Handle_StepVisual_ContextDependentOverRidingStyledItem self) -> Handle_StepVisual_StyledItem

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_StyledItem

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_OverRiddenStyle(self, *args)


    def SetStyles(self, *args):
        """
        SetStyles(Handle_StepVisual_ContextDependentOverRidingStyledItem self, Handle_StepVisual_HArray1OfPresentationStyleAssignment aStyles)

        :type aStyles: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_SetStyles(self, *args)


    def Styles(self, *args):
        """
        Styles(Handle_StepVisual_ContextDependentOverRidingStyledItem self) -> Handle_StepVisual_HArray1OfPresentationStyleAssignment

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_HArray1OfPresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_Styles(self, *args)


    def StylesValue(self, *args):
        """
        StylesValue(Handle_StepVisual_ContextDependentOverRidingStyledItem self, Standard_Integer const num) -> Handle_StepVisual_PresentationStyleAssignment

        :type num: int
        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationStyleAssignment

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_StylesValue(self, *args)


    def NbStyles(self, *args):
        """
        NbStyles(Handle_StepVisual_ContextDependentOverRidingStyledItem self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_NbStyles(self, *args)


    def SetItem(self, *args):
        """
        SetItem(Handle_StepVisual_ContextDependentOverRidingStyledItem self, Handle_StepRepr_RepresentationItem aItem)
        SetItem(Handle_StepVisual_ContextDependentOverRidingStyledItem self, StepVisual_StyledItemTarget aItem)

        :type aItem: OCC.wrapper.StepVisual.StepVisual_StyledItemTarget

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_SetItem(self, *args)


    def Item(self, *args):
        """
        Item(Handle_StepVisual_ContextDependentOverRidingStyledItem self) -> Handle_StepRepr_RepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_Item(self, *args)


    def ItemAP242(self, *args):
        """
        ItemAP242(Handle_StepVisual_ContextDependentOverRidingStyledItem self) -> StepVisual_StyledItemTarget

        :rtype: OCC.wrapper.StepVisual.StepVisual_StyledItemTarget

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_ItemAP242(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_ContextDependentOverRidingStyledItem self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_ContextDependentOverRidingStyledItem self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_ContextDependentOverRidingStyledItem self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_ContextDependentOverRidingStyledItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_ContextDependentOverRidingStyledItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_ContextDependentOverRidingStyledItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_ContextDependentOverRidingStyledItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_ContextDependentOverRidingStyledItem self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_ContextDependentOverRidingStyledItem self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_ContextDependentOverRidingStyledItem self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_ContextDependentOverRidingStyledItem self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_DecrementRefCounter(self, *args)

Handle_StepVisual_ContextDependentOverRidingStyledItem_swigregister = _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_swigregister
Handle_StepVisual_ContextDependentOverRidingStyledItem_swigregister(Handle_StepVisual_ContextDependentOverRidingStyledItem)

def Handle_StepVisual_ContextDependentOverRidingStyledItem_DownCast(thing):
    return _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_DownCast(thing)
Handle_StepVisual_ContextDependentOverRidingStyledItem_DownCast = _StepVisual.Handle_StepVisual_ContextDependentOverRidingStyledItem_DownCast

class Handle_StepVisual_AnnotationFillArea(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_AnnotationFillArea self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_AnnotationFillArea_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_AnnotationFillArea self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillArea_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_AnnotationFillArea self, StepVisual_AnnotationFillArea thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillArea_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_AnnotationFillArea self, Handle_StepVisual_AnnotationFillArea theHandle) -> Handle_StepVisual_AnnotationFillArea
        assign(Handle_StepVisual_AnnotationFillArea self, StepVisual_AnnotationFillArea thePtr) -> Handle_StepVisual_AnnotationFillArea
        assign(Handle_StepVisual_AnnotationFillArea self, Handle_StepVisual_AnnotationFillArea theHandle) -> Handle_StepVisual_AnnotationFillArea

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillArea_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_AnnotationFillArea self) -> StepVisual_AnnotationFillArea

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillArea_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_AnnotationFillArea self) -> StepVisual_AnnotationFillArea

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillArea___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_AnnotationFillArea self) -> StepVisual_AnnotationFillArea

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillArea___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_AnnotationFillArea___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_AnnotationFillArea___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_AnnotationFillArea(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_AnnotationFillArea_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_AnnotationFillArea

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_AnnotationFillArea self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillArea_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_AnnotationFillArea_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_AnnotationFillArea_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepVisual_AnnotationFillArea self, Handle_TCollection_HAsciiString aName, Handle_StepShape_HArray1OfGeometricSetSelect aElements)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aElements: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfGeometricSetSelect

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillArea_Init(self, *args)


    def SetElements(self, *args):
        """
        SetElements(Handle_StepVisual_AnnotationFillArea self, Handle_StepShape_HArray1OfGeometricSetSelect aElements)

        :type aElements: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfGeometricSetSelect

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillArea_SetElements(self, *args)


    def Elements(self, *args):
        """
        Elements(Handle_StepVisual_AnnotationFillArea self) -> Handle_StepShape_HArray1OfGeometricSetSelect

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_HArray1OfGeometricSetSelect

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillArea_Elements(self, *args)


    def ElementsValue(self, *args):
        """
        ElementsValue(Handle_StepVisual_AnnotationFillArea self, Standard_Integer const num) -> StepShape_GeometricSetSelect

        :type num: int
        :rtype: OCC.wrapper.StepShape.StepShape_GeometricSetSelect

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillArea_ElementsValue(self, *args)


    def NbElements(self, *args):
        """
        NbElements(Handle_StepVisual_AnnotationFillArea self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillArea_NbElements(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_AnnotationFillArea self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillArea_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_AnnotationFillArea self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillArea_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_AnnotationFillArea self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_AnnotationFillArea_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_AnnotationFillArea self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_AnnotationFillArea self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillArea_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_AnnotationFillArea self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_AnnotationFillArea self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillArea_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_AnnotationFillArea self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillArea_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_AnnotationFillArea self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillArea_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_AnnotationFillArea self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_AnnotationFillArea_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_AnnotationFillArea self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_AnnotationFillArea_DecrementRefCounter(self, *args)

Handle_StepVisual_AnnotationFillArea_swigregister = _StepVisual.Handle_StepVisual_AnnotationFillArea_swigregister
Handle_StepVisual_AnnotationFillArea_swigregister(Handle_StepVisual_AnnotationFillArea)

def Handle_StepVisual_AnnotationFillArea_DownCast(thing):
    return _StepVisual.Handle_StepVisual_AnnotationFillArea_DownCast(thing)
Handle_StepVisual_AnnotationFillArea_DownCast = _StepVisual.Handle_StepVisual_AnnotationFillArea_DownCast

class Handle_StepVisual_CameraModelD2(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepVisual_CameraModelD2 self)

        Nullify the handle


        """
        return _StepVisual.Handle_StepVisual_CameraModelD2_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepVisual_CameraModelD2 self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepVisual.Handle_StepVisual_CameraModelD2_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepVisual_CameraModelD2 self, StepVisual_CameraModelD2 thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepVisual.Handle_StepVisual_CameraModelD2_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepVisual_CameraModelD2 self, Handle_StepVisual_CameraModelD2 theHandle) -> Handle_StepVisual_CameraModelD2
        assign(Handle_StepVisual_CameraModelD2 self, StepVisual_CameraModelD2 thePtr) -> Handle_StepVisual_CameraModelD2
        assign(Handle_StepVisual_CameraModelD2 self, Handle_StepVisual_CameraModelD2 theHandle) -> Handle_StepVisual_CameraModelD2

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepVisual.Handle_StepVisual_CameraModelD2_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepVisual_CameraModelD2 self) -> StepVisual_CameraModelD2

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CameraModelD2_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepVisual_CameraModelD2 self) -> StepVisual_CameraModelD2

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepVisual.Handle_StepVisual_CameraModelD2___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepVisual_CameraModelD2 self) -> StepVisual_CameraModelD2

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepVisual.Handle_StepVisual_CameraModelD2___ref__(self, *args)


    def __hash__(self):
        return _StepVisual.Handle_StepVisual_CameraModelD2___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepVisual.Handle_StepVisual_CameraModelD2___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepVisual.new_Handle_StepVisual_CameraModelD2(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepVisual.Handle_StepVisual_CameraModelD2_DownCast)
    __swig_destroy__ = _StepVisual.delete_Handle_StepVisual_CameraModelD2

    def Init(self, *args):
        """
        Init(Handle_StepVisual_CameraModelD2 self, Handle_TCollection_HAsciiString aName, Handle_StepVisual_PlanarBox aViewWindow, Standard_Boolean const aViewWindowClipping)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aViewWindow: OCC.wrapper.StepVisual.Handle_StepVisual_PlanarBox
        :type aViewWindowClipping: bool

        """
        return _StepVisual.Handle_StepVisual_CameraModelD2_Init(self, *args)


    def SetViewWindow(self, *args):
        """
        SetViewWindow(Handle_StepVisual_CameraModelD2 self, Handle_StepVisual_PlanarBox aViewWindow)

        :type aViewWindow: OCC.wrapper.StepVisual.Handle_StepVisual_PlanarBox

        """
        return _StepVisual.Handle_StepVisual_CameraModelD2_SetViewWindow(self, *args)


    def ViewWindow(self, *args):
        """
        ViewWindow(Handle_StepVisual_CameraModelD2 self) -> Handle_StepVisual_PlanarBox

        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PlanarBox

        """
        return _StepVisual.Handle_StepVisual_CameraModelD2_ViewWindow(self, *args)


    def SetViewWindowClipping(self, *args):
        """
        SetViewWindowClipping(Handle_StepVisual_CameraModelD2 self, Standard_Boolean const aViewWindowClipping)

        :type aViewWindowClipping: bool

        """
        return _StepVisual.Handle_StepVisual_CameraModelD2_SetViewWindowClipping(self, *args)


    def ViewWindowClipping(self, *args):
        """
        ViewWindowClipping(Handle_StepVisual_CameraModelD2 self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CameraModelD2_ViewWindowClipping(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepVisual_CameraModelD2 self) -> char const *

        :rtype: const char *

        """
        return _StepVisual.Handle_StepVisual_CameraModelD2_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CameraModelD2_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepVisual.Handle_StepVisual_CameraModelD2_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepVisual_CameraModelD2 self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CameraModelD2_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepVisual_CameraModelD2 self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepVisual.Handle_StepVisual_CameraModelD2_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepVisual_CameraModelD2 self)

        Memory deallocator for transient classes


        """
        return _StepVisual.Handle_StepVisual_CameraModelD2_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepVisual_CameraModelD2 self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepVisual_CameraModelD2 self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CameraModelD2_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepVisual_CameraModelD2 self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepVisual_CameraModelD2 self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepVisual.Handle_StepVisual_CameraModelD2_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepVisual_CameraModelD2 self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepVisual.Handle_StepVisual_CameraModelD2_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepVisual_CameraModelD2 self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CameraModelD2_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepVisual_CameraModelD2 self)

        Increments the reference counter of this object


        """
        return _StepVisual.Handle_StepVisual_CameraModelD2_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepVisual_CameraModelD2 self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepVisual.Handle_StepVisual_CameraModelD2_DecrementRefCounter(self, *args)

Handle_StepVisual_CameraModelD2_swigregister = _StepVisual.Handle_StepVisual_CameraModelD2_swigregister
Handle_StepVisual_CameraModelD2_swigregister(Handle_StepVisual_CameraModelD2)

def Handle_StepVisual_CameraModelD2_DownCast(thing):
    return _StepVisual.Handle_StepVisual_CameraModelD2_DownCast(thing)
Handle_StepVisual_CameraModelD2_DownCast = _StepVisual.Handle_StepVisual_CameraModelD2_DownCast




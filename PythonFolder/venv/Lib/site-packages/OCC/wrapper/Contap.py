# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Contap')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Contap')
    _Contap = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Contap', [dirname(__file__)])
        except ImportError:
            import _Contap
            return _Contap
        try:
            _mod = imp.load_module('_Contap', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Contap = swig_import_helper()
    del swig_import_helper
else:
    import _Contap
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Contap.delete_SwigPyIterator

    def value(self):
        return _Contap.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Contap.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Contap.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Contap.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Contap.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Contap.SwigPyIterator_copy(self)

    def next(self):
        return _Contap.SwigPyIterator_next(self)

    def __next__(self):
        return _Contap.SwigPyIterator___next__(self)

    def previous(self):
        return _Contap.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Contap.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Contap.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Contap.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Contap.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Contap.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Contap.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Contap.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Contap.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Contap.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Contap.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Contap.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Contap.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Contap.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Contap.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Contap.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Contap.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Contap.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Contap.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Contap.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Contap.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Contap.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Contap.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Contap.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Contap.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Contap.ptr_to_number(item)
ptr_to_number = _Contap.ptr_to_number

def HashCode(*args):
    return _Contap.HashCode(*args)
HashCode = _Contap.HashCode

def ptr_equal(a, b):
    return _Contap.ptr_equal(a, b)
ptr_equal = _Contap.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntWalk
else:
    import IntWalk
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntImp
else:
    import IntImp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntSurf
else:
    import IntSurf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
Contap_ContourStd = _Contap.Contap_ContourStd
Contap_ContourPrs = _Contap.Contap_ContourPrs
Contap_DraftStd = _Contap.Contap_DraftStd
Contap_DraftPrs = _Contap.Contap_DraftPrs
Contap_Lin = _Contap.Contap_Lin
Contap_Circle = _Contap.Contap_Circle
Contap_Walking = _Contap.Contap_Walking
Contap_Restriction = _Contap.Contap_Restriction
class Contap_TheSegmentOfTheSearch(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Contap_TheSegmentOfTheSearch self) -> Contap_TheSegmentOfTheSearch

        Empty constructor.


        """
        this = _Contap.new_Contap_TheSegmentOfTheSearch(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetValue(self, *args):
        """
        SetValue(Contap_TheSegmentOfTheSearch self, Handle_Adaptor2d_HCurve2d A)

        Defines the concerned arc.

        :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _Contap.Contap_TheSegmentOfTheSearch_SetValue(self, *args)


    def SetLimitPoint(self, *args):
        """
        SetLimitPoint(Contap_TheSegmentOfTheSearch self, Contap_ThePathPointOfTheSearch V, Standard_Boolean const First)

        Defines the first point or the last point,
        depending on the value of the boolean First.

        :type V: OCC.wrapper.Contap.Contap_ThePathPointOfTheSearch
        :type First: bool

        """
        return _Contap.Contap_TheSegmentOfTheSearch_SetLimitPoint(self, *args)


    def Curve(self, *args):
        """
        Returns the geometric curve on the surface 's domain
        which is solution.

        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        res = _Contap.Contap_TheSegmentOfTheSearch_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasFirstPoint(self, *args):
        """
        HasFirstPoint(Contap_TheSegmentOfTheSearch self) -> Standard_Boolean

        Returns True if there is a vertex (ThePathPoint) defining
        the lowest valid parameter on the arc.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_TheSegmentOfTheSearch_HasFirstPoint(self, *args)


    def FirstPoint(self, *args):
        """
        Returns the first point.

        :rtype: OCC.wrapper.Contap.Contap_ThePathPointOfTheSearch

        """
        res = _Contap.Contap_TheSegmentOfTheSearch_FirstPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasLastPoint(self, *args):
        """
        HasLastPoint(Contap_TheSegmentOfTheSearch self) -> Standard_Boolean

        Returns True if there is a vertex (ThePathPoint) defining
        the greatest valid parameter on the arc.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_TheSegmentOfTheSearch_HasLastPoint(self, *args)


    def LastPoint(self, *args):
        """
        Returns the last point.

        :rtype: OCC.wrapper.Contap.Contap_ThePathPointOfTheSearch

        """
        res = _Contap.Contap_TheSegmentOfTheSearch_LastPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Contap.delete_Contap_TheSegmentOfTheSearch
Contap_TheSegmentOfTheSearch_swigregister = _Contap.Contap_TheSegmentOfTheSearch_swigregister
Contap_TheSegmentOfTheSearch_swigregister(Contap_TheSegmentOfTheSearch)

class Contap_HContTool(object):
    """
    Tool for the intersection between 2 surfaces.
    Regroupe pour l instant les methodes hors Adaptor3d...
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def NbSamplesU(*args):
        """
        NbSamplesU(Handle_Adaptor3d_HSurface S, Standard_Real const u1, Standard_Real const u2) -> Standard_Integer

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type u1: float
        :type u2: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Contap_HContTool_NbSamplesU(*args)

    NbSamplesU = staticmethod(NbSamplesU)

    def NbSamplesV(*args):
        """
        NbSamplesV(Handle_Adaptor3d_HSurface S, Standard_Real const v1, Standard_Real const v2) -> Standard_Integer

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type v1: float
        :type v2: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Contap_HContTool_NbSamplesV(*args)

    NbSamplesV = staticmethod(NbSamplesV)

    def NbSamplePoints(*args):
        """
        NbSamplePoints(Handle_Adaptor3d_HSurface S) -> Standard_Integer

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Contap_HContTool_NbSamplePoints(*args)

    NbSamplePoints = staticmethod(NbSamplePoints)

    def SamplePoint(*args):
        """
        SamplePoint(Handle_Adaptor3d_HSurface S, Standard_Integer const Index)

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Index: int
        :type U: float
        :type V: float

        """
        return _Contap.Contap_HContTool_SamplePoint(*args)

    SamplePoint = staticmethod(SamplePoint)

    def HasBeenSeen(*args):
        """
        HasBeenSeen(Handle_Adaptor2d_HCurve2d C) -> Standard_Boolean

        Returns True if all the intersection point and edges
        are known on the Arc.
        The intersection point are given as vertices.
        The intersection edges are given as intervals between
        two vertices.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_HContTool_HasBeenSeen(*args)

    HasBeenSeen = staticmethod(HasBeenSeen)

    def NbSamplesOnArc(*args):
        """
        NbSamplesOnArc(Handle_Adaptor2d_HCurve2d A) -> Standard_Integer

        returns the number of points which is used to make
        a sample on the arc. this number is a function of
        the Surface and the CurveOnSurface complexity.

        :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Contap_HContTool_NbSamplesOnArc(*args)

    NbSamplesOnArc = staticmethod(NbSamplesOnArc)

    def Bounds(*args):
        """
        Bounds(Handle_Adaptor2d_HCurve2d C)

        Returns the parametric limits on the arc C.
        These limits must be finite : they are either
        the real limits of the arc, for a finite arc,
        or a bounding box for an infinite arc.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Ufirst: float
        :type Ulast: float

        """
        return _Contap.Contap_HContTool_Bounds(*args)

    Bounds = staticmethod(Bounds)

    def Project(*args):
        """
        Project(Handle_Adaptor2d_HCurve2d C, gp_Pnt2d P, gp_Pnt2d Ptproj) -> Standard_Boolean

        Projects the point P on the arc C.
        If the methods returns Standard_True, the projection is
        successful, and Paramproj is the parameter on the arc
        of the projected point, Ptproj is the projected Point.
        If the method returns Standard_False, Param proj and Ptproj
        are not significant.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Paramproj: float
        :type Ptproj: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_HContTool_Project(*args)

    Project = staticmethod(Project)

    def Tolerance(*args):
        """
        Tolerance(Handle_Adaptor3d_HVertex V, Handle_Adaptor2d_HCurve2d C) -> Standard_Real

        Returns the parametric tolerance used to consider
        that the vertex and another point meet, i-e
        if Abs(parameter(Vertex) - parameter(OtherPnt))<=
        Tolerance, the points are "merged".

        :type V: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex
        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Contap.Contap_HContTool_Tolerance(*args)

    Tolerance = staticmethod(Tolerance)

    def Parameter(*args):
        """
        Parameter(Handle_Adaptor3d_HVertex V, Handle_Adaptor2d_HCurve2d C) -> Standard_Real

        Returns the parameter of the vertex V on the arc A.

        :type V: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex
        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Contap.Contap_HContTool_Parameter(*args)

    Parameter = staticmethod(Parameter)

    def NbPoints(*args):
        """
        NbPoints(Handle_Adaptor2d_HCurve2d C) -> Standard_Integer

        Returns the number of intersection points on the arc A.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Contap_HContTool_NbPoints(*args)

    NbPoints = staticmethod(NbPoints)

    def Value(*args):
        """
        Value(Handle_Adaptor2d_HCurve2d C, Standard_Integer const Index, gp_Pnt Pt)

        Returns the value (Pt), the tolerance (Tol), and
        the parameter (U) on the arc A , of the intersection
        point of range Index.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Index: int
        :type Pt: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :type U: float

        """
        return _Contap.Contap_HContTool_Value(*args)

    Value = staticmethod(Value)

    def IsVertex(*args):
        """
        IsVertex(Handle_Adaptor2d_HCurve2d C, Standard_Integer const Index) -> Standard_Boolean

        Returns True if the intersection point of range Index
        corresponds with a vertex on the arc A.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_HContTool_IsVertex(*args)

    IsVertex = staticmethod(IsVertex)

    def Vertex(*args):
        """
        Vertex(Handle_Adaptor2d_HCurve2d C, Standard_Integer const Index, Handle_Adaptor3d_HVertex V)

        When IsVertex returns True, this method returns the
        vertex on the arc A.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Index: int
        :type V: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex

        """
        return _Contap.Contap_HContTool_Vertex(*args)

    Vertex = staticmethod(Vertex)

    def NbSegments(*args):
        """
        NbSegments(Handle_Adaptor2d_HCurve2d C) -> Standard_Integer

        returns the number of part of A solution of the
        of intersection problem.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Contap_HContTool_NbSegments(*args)

    NbSegments = staticmethod(NbSegments)

    def HasFirstPoint(*args):
        """
        HasFirstPoint(Handle_Adaptor2d_HCurve2d C, Standard_Integer const Index) -> Standard_Boolean

        Returns True when the segment of range Index is not
        open at the left side. In that case, IndFirst is the
        range in the list intersection points (see NbPoints)
        of the one which defines the left bound of the segment.
        Otherwise, the method has to return False, and IndFirst
        has no meaning.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Index: int
        :type IndFirst: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_HContTool_HasFirstPoint(*args)

    HasFirstPoint = staticmethod(HasFirstPoint)

    def HasLastPoint(*args):
        """
        HasLastPoint(Handle_Adaptor2d_HCurve2d C, Standard_Integer const Index) -> Standard_Boolean

        Returns True when the segment of range Index is not
        open at the right side. In that case, IndLast is the
        range in the list intersection points (see NbPoints)
        of the one which defines the right bound of the segment.
        Otherwise, the method has to return False, and IndLast
        has no meaning.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Index: int
        :type IndLast: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_HContTool_HasLastPoint(*args)

    HasLastPoint = staticmethod(HasLastPoint)

    def IsAllSolution(*args):
        """
        IsAllSolution(Handle_Adaptor2d_HCurve2d C) -> Standard_Boolean

        Returns True when the whole restriction is solution
        of the intersection problem.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_HContTool_IsAllSolution(*args)

    IsAllSolution = staticmethod(IsAllSolution)

    def __init__(self):
        """
        Tool for the intersection between 2 surfaces.
        Regroupe pour l instant les methodes hors Adaptor3d...
        """
        this = _Contap.new_Contap_HContTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Contap.delete_Contap_HContTool
Contap_HContTool_swigregister = _Contap.Contap_HContTool_swigregister
Contap_HContTool_swigregister(Contap_HContTool)

def Contap_HContTool_NbSamplesU(*args):
    """
    Contap_HContTool_NbSamplesU(Handle_Adaptor3d_HSurface S, Standard_Real const u1, Standard_Real const u2) -> Standard_Integer

    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type u1: float
    :type u2: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Contap.Contap_HContTool_NbSamplesU(*args)

def Contap_HContTool_NbSamplesV(*args):
    """
    Contap_HContTool_NbSamplesV(Handle_Adaptor3d_HSurface S, Standard_Real const v1, Standard_Real const v2) -> Standard_Integer

    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type v1: float
    :type v2: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Contap.Contap_HContTool_NbSamplesV(*args)

def Contap_HContTool_NbSamplePoints(*args):
    """
    Contap_HContTool_NbSamplePoints(Handle_Adaptor3d_HSurface S) -> Standard_Integer

    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Contap.Contap_HContTool_NbSamplePoints(*args)

def Contap_HContTool_SamplePoint(*args):
    """
    Contap_HContTool_SamplePoint(Handle_Adaptor3d_HSurface S, Standard_Integer const Index)

    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type Index: int
    :type U: float
    :type V: float

    """
    return _Contap.Contap_HContTool_SamplePoint(*args)

def Contap_HContTool_HasBeenSeen(*args):
    """
    Contap_HContTool_HasBeenSeen(Handle_Adaptor2d_HCurve2d C) -> Standard_Boolean

    Returns True if all the intersection point and edges
    are known on the Arc.
    The intersection point are given as vertices.
    The intersection edges are given as intervals between
    two vertices.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Contap.Contap_HContTool_HasBeenSeen(*args)

def Contap_HContTool_NbSamplesOnArc(*args):
    """
    Contap_HContTool_NbSamplesOnArc(Handle_Adaptor2d_HCurve2d A) -> Standard_Integer

    returns the number of points which is used to make
    a sample on the arc. this number is a function of
    the Surface and the CurveOnSurface complexity.

    :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Contap.Contap_HContTool_NbSamplesOnArc(*args)

def Contap_HContTool_Bounds(*args):
    """
    Contap_HContTool_Bounds(Handle_Adaptor2d_HCurve2d C)

    Returns the parametric limits on the arc C.
    These limits must be finite : they are either
    the real limits of the arc, for a finite arc,
    or a bounding box for an infinite arc.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type Ufirst: float
    :type Ulast: float

    """
    return _Contap.Contap_HContTool_Bounds(*args)

def Contap_HContTool_Project(*args):
    """
    Contap_HContTool_Project(Handle_Adaptor2d_HCurve2d C, gp_Pnt2d P, gp_Pnt2d Ptproj) -> Standard_Boolean

    Projects the point P on the arc C.
    If the methods returns Standard_True, the projection is
    successful, and Paramproj is the parameter on the arc
    of the projected point, Ptproj is the projected Point.
    If the method returns Standard_False, Param proj and Ptproj
    are not significant.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type Paramproj: float
    :type Ptproj: OCC.wrapper.gp.gp_Pnt2d
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Contap.Contap_HContTool_Project(*args)

def Contap_HContTool_Tolerance(*args):
    """
    Contap_HContTool_Tolerance(Handle_Adaptor3d_HVertex V, Handle_Adaptor2d_HCurve2d C) -> Standard_Real

    Returns the parametric tolerance used to consider
    that the vertex and another point meet, i-e
    if Abs(parameter(Vertex) - parameter(OtherPnt))<=
    Tolerance, the points are "merged".

    :type V: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex
    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Contap.Contap_HContTool_Tolerance(*args)

def Contap_HContTool_Parameter(*args):
    """
    Contap_HContTool_Parameter(Handle_Adaptor3d_HVertex V, Handle_Adaptor2d_HCurve2d C) -> Standard_Real

    Returns the parameter of the vertex V on the arc A.

    :type V: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex
    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Contap.Contap_HContTool_Parameter(*args)

def Contap_HContTool_NbPoints(*args):
    """
    Contap_HContTool_NbPoints(Handle_Adaptor2d_HCurve2d C) -> Standard_Integer

    Returns the number of intersection points on the arc A.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Contap.Contap_HContTool_NbPoints(*args)

def Contap_HContTool_Value(*args):
    """
    Contap_HContTool_Value(Handle_Adaptor2d_HCurve2d C, Standard_Integer const Index, gp_Pnt Pt)

    Returns the value (Pt), the tolerance (Tol), and
    the parameter (U) on the arc A , of the intersection
    point of range Index.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type Index: int
    :type Pt: OCC.wrapper.gp.gp_Pnt
    :type Tol: float
    :type U: float

    """
    return _Contap.Contap_HContTool_Value(*args)

def Contap_HContTool_IsVertex(*args):
    """
    Contap_HContTool_IsVertex(Handle_Adaptor2d_HCurve2d C, Standard_Integer const Index) -> Standard_Boolean

    Returns True if the intersection point of range Index
    corresponds with a vertex on the arc A.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type Index: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Contap.Contap_HContTool_IsVertex(*args)

def Contap_HContTool_Vertex(*args):
    """
    Contap_HContTool_Vertex(Handle_Adaptor2d_HCurve2d C, Standard_Integer const Index, Handle_Adaptor3d_HVertex V)

    When IsVertex returns True, this method returns the
    vertex on the arc A.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type Index: int
    :type V: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex

    """
    return _Contap.Contap_HContTool_Vertex(*args)

def Contap_HContTool_NbSegments(*args):
    """
    Contap_HContTool_NbSegments(Handle_Adaptor2d_HCurve2d C) -> Standard_Integer

    returns the number of part of A solution of the
    of intersection problem.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Contap.Contap_HContTool_NbSegments(*args)

def Contap_HContTool_HasFirstPoint(*args):
    """
    Contap_HContTool_HasFirstPoint(Handle_Adaptor2d_HCurve2d C, Standard_Integer const Index) -> Standard_Boolean

    Returns True when the segment of range Index is not
    open at the left side. In that case, IndFirst is the
    range in the list intersection points (see NbPoints)
    of the one which defines the left bound of the segment.
    Otherwise, the method has to return False, and IndFirst
    has no meaning.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type Index: int
    :type IndFirst: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Contap.Contap_HContTool_HasFirstPoint(*args)

def Contap_HContTool_HasLastPoint(*args):
    """
    Contap_HContTool_HasLastPoint(Handle_Adaptor2d_HCurve2d C, Standard_Integer const Index) -> Standard_Boolean

    Returns True when the segment of range Index is not
    open at the right side. In that case, IndLast is the
    range in the list intersection points (see NbPoints)
    of the one which defines the right bound of the segment.
    Otherwise, the method has to return False, and IndLast
    has no meaning.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type Index: int
    :type IndLast: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Contap.Contap_HContTool_HasLastPoint(*args)

def Contap_HContTool_IsAllSolution(*args):
    """
    Contap_HContTool_IsAllSolution(Handle_Adaptor2d_HCurve2d C) -> Standard_Boolean

    Returns True when the whole restriction is solution
    of the intersection problem.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Contap.Contap_HContTool_IsAllSolution(*args)

class Contap_SurfProps(object):
    """
    Internal tool used  to compute the  normal and its
    derivatives.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Normale(*args):
        """
        Normale(Handle_Adaptor3d_HSurface S, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec N)

        Computes  the point <P>, and  normal vector <N> on
        <S> at parameters U,V.

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type N: OCC.wrapper.gp.gp_Vec

        """
        return _Contap.Contap_SurfProps_Normale(*args)

    Normale = staticmethod(Normale)

    def DerivAndNorm(*args):
        """
        DerivAndNorm(Handle_Adaptor3d_HSurface S, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec d1u, gp_Vec d1v, gp_Vec N)

        Computes  the point <P>, and  normal vector <N> on
        <S> at parameters U,V.

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type d1u: OCC.wrapper.gp.gp_Vec
        :type d1v: OCC.wrapper.gp.gp_Vec
        :type N: OCC.wrapper.gp.gp_Vec

        """
        return _Contap.Contap_SurfProps_DerivAndNorm(*args)

    DerivAndNorm = staticmethod(DerivAndNorm)

    def NormAndDn(*args):
        """
        NormAndDn(Handle_Adaptor3d_HSurface S, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec N, gp_Vec Dnu, gp_Vec Dnv)

        Computes the point <P>, normal vector <N>, and its
        derivatives <Dnu> and <Dnv> on <S> at parameters U,V.

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type U: float
        :type V: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type N: OCC.wrapper.gp.gp_Vec
        :type Dnu: OCC.wrapper.gp.gp_Vec
        :type Dnv: OCC.wrapper.gp.gp_Vec

        """
        return _Contap.Contap_SurfProps_NormAndDn(*args)

    NormAndDn = staticmethod(NormAndDn)

    def __init__(self):
        """
        Internal tool used  to compute the  normal and its
        derivatives.
        """
        this = _Contap.new_Contap_SurfProps()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Contap.delete_Contap_SurfProps
Contap_SurfProps_swigregister = _Contap.Contap_SurfProps_swigregister
Contap_SurfProps_swigregister(Contap_SurfProps)

def Contap_SurfProps_Normale(*args):
    """
    Contap_SurfProps_Normale(Handle_Adaptor3d_HSurface S, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec N)

    Computes  the point <P>, and  normal vector <N> on
    <S> at parameters U,V.

    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type U: float
    :type V: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type N: OCC.wrapper.gp.gp_Vec

    """
    return _Contap.Contap_SurfProps_Normale(*args)

def Contap_SurfProps_DerivAndNorm(*args):
    """
    Contap_SurfProps_DerivAndNorm(Handle_Adaptor3d_HSurface S, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec d1u, gp_Vec d1v, gp_Vec N)

    Computes  the point <P>, and  normal vector <N> on
    <S> at parameters U,V.

    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type U: float
    :type V: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type d1u: OCC.wrapper.gp.gp_Vec
    :type d1v: OCC.wrapper.gp.gp_Vec
    :type N: OCC.wrapper.gp.gp_Vec

    """
    return _Contap.Contap_SurfProps_DerivAndNorm(*args)

def Contap_SurfProps_NormAndDn(*args):
    """
    Contap_SurfProps_NormAndDn(Handle_Adaptor3d_HSurface S, Standard_Real const U, Standard_Real const V, gp_Pnt P, gp_Vec N, gp_Vec Dnu, gp_Vec Dnv)

    Computes the point <P>, normal vector <N>, and its
    derivatives <Dnu> and <Dnv> on <S> at parameters U,V.

    :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type U: float
    :type V: float
    :type P: OCC.wrapper.gp.gp_Pnt
    :type N: OCC.wrapper.gp.gp_Vec
    :type Dnu: OCC.wrapper.gp.gp_Vec
    :type Dnv: OCC.wrapper.gp.gp_Vec

    """
    return _Contap.Contap_SurfProps_NormAndDn(*args)

class Contap_TheHSequenceOfPoint(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Contap_TheHSequenceOfPoint
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Contap_TheHSequenceOfPoint(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Contap_TheHSequenceOfPoint self) -> Contap_TheHSequenceOfPoint
        __init__(Contap_TheHSequenceOfPoint self, NCollection_Sequence_Contap_Point theOther) -> Contap_TheHSequenceOfPoint

        :type theOther: OCC.wrapper.Contap.Contap_TheSequenceOfPoint

        """
        this = _Contap.new_Contap_TheHSequenceOfPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.Contap.Contap_TheSequenceOfPoint

        """
        res = _Contap.Contap_TheHSequenceOfPoint_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Contap_TheHSequenceOfPoint self, Contap_Point theItem)
        Append(Contap_TheHSequenceOfPoint self, NCollection_Sequence_Contap_Point theSequence)

        :type theSequence: OCC.wrapper.Contap.Contap_TheSequenceOfPoint

        """
        return _Contap.Contap_TheHSequenceOfPoint_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Contap_TheHSequenceOfPoint self) -> NCollection_Sequence_Contap_Point

        :rtype: OCC.wrapper.Contap.Contap_TheSequenceOfPoint

        """
        return _Contap.Contap_TheHSequenceOfPoint_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Contap.Contap_TheHSequenceOfPoint_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Contap.Contap_TheHSequenceOfPoint_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Contap.Contap_TheHSequenceOfPoint_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Contap.delete_Contap_TheHSequenceOfPoint
Contap_TheHSequenceOfPoint_swigregister = _Contap.Contap_TheHSequenceOfPoint_swigregister
Contap_TheHSequenceOfPoint_swigregister(Contap_TheHSequenceOfPoint)

def Contap_TheHSequenceOfPoint_get_type_name(*args):
    """
    Contap_TheHSequenceOfPoint_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Contap.Contap_TheHSequenceOfPoint_get_type_name(*args)

def Contap_TheHSequenceOfPoint_get_type_descriptor(*args):
    """
    Contap_TheHSequenceOfPoint_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Contap.Contap_TheHSequenceOfPoint_get_type_descriptor(*args)

class Contap_SurfFunction(math.math_FunctionSetWithDerivatives):
    """
    This class describes the function on a parametric surface.
    the form of the function is F(u,v) = 0 where u and v are
    the parameteric coordinates of a point on the surface,
    to compute the contours of the surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Contap_SurfFunction self) -> Contap_SurfFunction

        This class describes the function on a parametric surface.
        the form of the function is F(u,v) = 0 where u and v are
        the parameteric coordinates of a point on the surface,
        to compute the contours of the surface.
        """
        this = _Contap.new_Contap_SurfFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Set(self, *args):
        """
        Set(Contap_SurfFunction self, Handle_Adaptor3d_HSurface S)
        Set(Contap_SurfFunction self, gp_Pnt Eye)
        Set(Contap_SurfFunction self, gp_Dir Dir)
        Set(Contap_SurfFunction self, gp_Dir Dir, Standard_Real const Angle)
        Set(Contap_SurfFunction self, gp_Pnt Eye, Standard_Real const Angle)
        Set(Contap_SurfFunction self, Standard_Real const Tolerance)

        :type Tolerance: float

        """
        return _Contap.Contap_SurfFunction_Set(self, *args)


    def NbVariables(self, *args):
        """
        NbVariables(Contap_SurfFunction self) -> Standard_Integer

        This method has to return 2.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Contap_SurfFunction_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(Contap_SurfFunction self) -> Standard_Integer

        This method has to return 1.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Contap_SurfFunction_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(Contap_SurfFunction self, math_Vector X, math_Vector F) -> Standard_Boolean

        The dimension of F is 1.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_SurfFunction_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(Contap_SurfFunction self, math_Vector X, math_Matrix D) -> Standard_Boolean

        The dimension of D is (1,2).

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_SurfFunction_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(Contap_SurfFunction self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_SurfFunction_Values(self, *args)


    def Root(self, *args):
        """
        Root(Contap_SurfFunction self) -> Standard_Real

        Root is the value of the function at the solution.
        It is a vector of dimension 1, i-e a real.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Contap.Contap_SurfFunction_Root(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(Contap_SurfFunction self) -> Standard_Real

        Returns the value Tol so that if Abs(Func.Root())<Tol
        the function is considered null.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Contap.Contap_SurfFunction_Tolerance(self, *args)


    def Point(self, *args):
        """
        Returns the value of the solution point on the surface.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Contap.Contap_SurfFunction_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsTangent(self, *args):
        """
        IsTangent(Contap_SurfFunction self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_SurfFunction_IsTangent(self, *args)


    def Direction3d(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _Contap.Contap_SurfFunction_Direction3d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Direction2d(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        res = _Contap.Contap_SurfFunction_Direction2d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FunctionType(self, *args):
        """
        FunctionType(Contap_SurfFunction self) -> Contap_TFunction

        :rtype: OCC.wrapper.Contap.Contap_TFunction

        """
        return _Contap.Contap_SurfFunction_FunctionType(self, *args)


    def Eye(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Contap.Contap_SurfFunction_Eye(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Direction(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _Contap.Contap_SurfFunction_Direction(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Angle(self, *args):
        """
        Angle(Contap_SurfFunction self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Contap.Contap_SurfFunction_Angle(self, *args)


    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        res = _Contap.Contap_SurfFunction_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Contap.delete_Contap_SurfFunction
Contap_SurfFunction_swigregister = _Contap.Contap_SurfFunction_swigregister
Contap_SurfFunction_swigregister(Contap_SurfFunction)

class Contap_ContAna(object):
    """
    This class provides the computation of the contours
    for quadric surfaces.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Contap_ContAna self) -> Contap_ContAna

        This class provides the computation of the contours
        for quadric surfaces.
        """
        this = _Contap.new_Contap_ContAna(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Contap_ContAna self, gp_Sphere S, gp_Dir D)
        Perform(Contap_ContAna self, gp_Sphere S, gp_Dir D, Standard_Real const Ang)
        Perform(Contap_ContAna self, gp_Sphere S, gp_Pnt Eye)
        Perform(Contap_ContAna self, gp_Cylinder C, gp_Dir D)
        Perform(Contap_ContAna self, gp_Cylinder C, gp_Dir D, Standard_Real const Ang)
        Perform(Contap_ContAna self, gp_Cylinder C, gp_Pnt Eye)
        Perform(Contap_ContAna self, gp_Cone C, gp_Dir D)
        Perform(Contap_ContAna self, gp_Cone C, gp_Dir D, Standard_Real const Ang)
        Perform(Contap_ContAna self, gp_Cone C, gp_Pnt Eye)

        :type C: OCC.wrapper.gp.gp_Cone
        :type Eye: OCC.wrapper.gp.gp_Pnt

        """
        return _Contap.Contap_ContAna_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Contap_ContAna self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_ContAna_IsDone(self, *args)


    def NbContours(self, *args):
        """
        NbContours(Contap_ContAna self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Contap_ContAna_NbContours(self, *args)


    def TypeContour(self, *args):
        """
        TypeContour(Contap_ContAna self) -> GeomAbs_CurveType

        Returns GeomAbs_Line or GeomAbs_Circle, when
        IsDone() returns True.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _Contap.Contap_ContAna_TypeContour(self, *args)


    def Circle(self, *args):
        """
        Circle(Contap_ContAna self) -> gp_Circ

        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _Contap.Contap_ContAna_Circle(self, *args)


    def Line(self, *args):
        """
        Line(Contap_ContAna self, Standard_Integer const Index) -> gp_Lin

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _Contap.Contap_ContAna_Line(self, *args)

    __swig_destroy__ = _Contap.delete_Contap_ContAna
Contap_ContAna_swigregister = _Contap.Contap_ContAna_swigregister
Contap_ContAna_swigregister(Contap_ContAna)

class Contap_Line(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(Contap_Line self) -> Contap_Line"""
        this = _Contap.new_Contap_Line(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetLineOn2S(self, *args):
        """
        SetLineOn2S(Contap_Line self, Handle_IntSurf_LineOn2S L)

        :type L: OCC.wrapper.IntSurf.Handle_IntSurf_LineOn2S

        """
        return _Contap.Contap_Line_SetLineOn2S(self, *args)


    def Clear(self, *args):
        """Clear(Contap_Line self)"""
        return _Contap.Contap_Line_Clear(self, *args)


    def LineOn2S(self, *args):
        """
        :rtype: OCC.wrapper.IntSurf.Handle_IntSurf_LineOn2S

        """
        res = _Contap.Contap_Line_LineOn2S(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ResetSeqOfVertex(self, *args):
        """ResetSeqOfVertex(Contap_Line self)"""
        return _Contap.Contap_Line_ResetSeqOfVertex(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Contap_Line self, gp_Lin L)
        SetValue(Contap_Line self, gp_Circ C)
        SetValue(Contap_Line self, Handle_Adaptor2d_HCurve2d A)

        :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _Contap.Contap_Line_SetValue(self, *args)


    def Add(self, *args):
        """
        Add(Contap_Line self, IntSurf_PntOn2S P)
        Add(Contap_Line self, Contap_Point P)

        :type P: OCC.wrapper.Contap.Contap_Point

        """
        return _Contap.Contap_Line_Add(self, *args)


    def NbVertex(self, *args):
        """
        NbVertex(Contap_Line self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Contap_Line_NbVertex(self, *args)


    def Vertex(self, *args):
        """
        Vertex(Contap_Line self, Standard_Integer const Index) -> Contap_Point

        :type Index: int
        :rtype: OCC.wrapper.Contap.Contap_Point

        """
        return _Contap.Contap_Line_Vertex(self, *args)


    def TypeContour(self, *args):
        """
        TypeContour(Contap_Line self) -> Contap_IType

        Returns Contap_Lin for a line, Contap_Circle for
        a circle, and Contap_Walking for a Walking line,
        Contap_Restriction for a part of  boundarie.

        :rtype: OCC.wrapper.Contap.Contap_IType

        """
        return _Contap.Contap_Line_TypeContour(self, *args)


    def NbPnts(self, *args):
        """
        NbPnts(Contap_Line self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Contap_Line_NbPnts(self, *args)


    def Point(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        res = _Contap.Contap_Line_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Line(self, *args):
        """
        Line(Contap_Line self) -> gp_Lin

        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _Contap.Contap_Line_Line(self, *args)


    def Circle(self, *args):
        """
        Circle(Contap_Line self) -> gp_Circ

        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _Contap.Contap_Line_Circle(self, *args)


    def Arc(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        res = _Contap.Contap_Line_Arc(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTransitionOnS(self, *args):
        """
        SetTransitionOnS(Contap_Line self, IntSurf_TypeTrans const T)

        Set The Tansition of the line.

        :type T: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _Contap.Contap_Line_SetTransitionOnS(self, *args)


    def TransitionOnS(self, *args):
        """
        TransitionOnS(Contap_Line self) -> IntSurf_TypeTrans

        returns IN if at the "left" of the line, the normale of the
        surface is oriented to the observator.

        :rtype: OCC.wrapper.IntSurf.IntSurf_TypeTrans

        """
        return _Contap.Contap_Line_TransitionOnS(self, *args)

    __swig_destroy__ = _Contap.delete_Contap_Line
Contap_Line_swigregister = _Contap.Contap_Line_swigregister
Contap_Line_swigregister(Contap_Line)

class Contap_TheSearchInside(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Contap_TheSearchInside self) -> Contap_TheSearchInside
        __init__(Contap_TheSearchInside self, Contap_SurfFunction F, Handle_Adaptor3d_HSurface Surf, Handle_Adaptor3d_TopolTool T, Standard_Real const Epsilon) -> Contap_TheSearchInside

        :type F: OCC.wrapper.Contap.Contap_SurfFunction
        :type Surf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type T: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type Epsilon: float

        """
        this = _Contap.new_Contap_TheSearchInside(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Contap_TheSearchInside self, Contap_SurfFunction F, Handle_Adaptor3d_HSurface Surf, Handle_Adaptor3d_TopolTool T, Standard_Real const Epsilon)
        Perform(Contap_TheSearchInside self, Contap_SurfFunction F, Handle_Adaptor3d_HSurface Surf, Standard_Real const UStart, Standard_Real const VStart)

        :type F: OCC.wrapper.Contap.Contap_SurfFunction
        :type Surf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type UStart: float
        :type VStart: float

        """
        return _Contap.Contap_TheSearchInside_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Contap_TheSearchInside self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_TheSearchInside_IsDone(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(Contap_TheSearchInside self) -> Standard_Integer

        Returns the number of points.
        The exception NotDone if raised if IsDone
        returns False.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Contap_TheSearchInside_NbPoints(self, *args)


    def Value(self, *args):
        """
        Returns the point of range Index.
        The exception NotDone if raised if IsDone
        returns False.
        The exception OutOfRange if raised if
        Index <= 0 or Index > NbPoints.

        :type Index: int
        :rtype: OCC.wrapper.IntSurf.IntSurf_InteriorPoint

        """
        res = _Contap.Contap_TheSearchInside_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Contap.delete_Contap_TheSearchInside
Contap_TheSearchInside_swigregister = _Contap.Contap_TheSearchInside_swigregister
Contap_TheSearchInside_swigregister(Contap_TheSearchInside)

class NCollection_Sequence_Contap_TheSegmentOfTheSearch(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Contap_TheSegmentOfTheSearch self) -> NCollection_Sequence< Contap_TheSegmentOfTheSearch >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Contap_TheSegmentOfTheSearch self) -> NCollection_Sequence< Contap_TheSegmentOfTheSearch >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Contap_TheSegmentOfTheSearch self) -> NCollection_Sequence< Contap_TheSegmentOfTheSearch >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Contap_TheSegmentOfTheSearch self) -> NCollection_Sequence< Contap_TheSegmentOfTheSearch >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Contap.new_NCollection_Sequence_Contap_TheSegmentOfTheSearch(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Contap_TheSegmentOfTheSearch self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Contap_TheSegmentOfTheSearch self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Contap_TheSegmentOfTheSearch self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Contap_TheSegmentOfTheSearch self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Contap_TheSegmentOfTheSearch self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Contap_TheSegmentOfTheSearch self)

        Reverse sequence


        """
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Contap_TheSegmentOfTheSearch self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Contap_TheSegmentOfTheSearch self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Contap_TheSegmentOfTheSearch self, NCollection_Sequence_Contap_TheSegmentOfTheSearch theOther) -> NCollection_Sequence_Contap_TheSegmentOfTheSearch

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Contap_TheSegmentOfTheSearch self, NCollection_Sequence_Contap_TheSegmentOfTheSearch theOther) -> NCollection_Sequence_Contap_TheSegmentOfTheSearch

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Contap_TheSegmentOfTheSearch self, NCollection_Sequence< Contap_TheSegmentOfTheSearch >::Iterator & thePosition)
        Remove(NCollection_Sequence_Contap_TheSegmentOfTheSearch self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Contap_TheSegmentOfTheSearch self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Contap_TheSegmentOfTheSearch self, Contap_TheSegmentOfTheSearch theItem)
        Append(NCollection_Sequence_Contap_TheSegmentOfTheSearch self, NCollection_Sequence_Contap_TheSegmentOfTheSearch theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Contap_TheSegmentOfTheSearch self, Contap_TheSegmentOfTheSearch theItem)
        Prepend(NCollection_Sequence_Contap_TheSegmentOfTheSearch self, NCollection_Sequence_Contap_TheSegmentOfTheSearch theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Contap_TheSegmentOfTheSearch self, Standard_Integer const theIndex, Contap_TheSegmentOfTheSearch theItem)
        InsertBefore(NCollection_Sequence_Contap_TheSegmentOfTheSearch self, Standard_Integer const theIndex, NCollection_Sequence_Contap_TheSegmentOfTheSearch theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Contap_TheSegmentOfTheSearch self, NCollection_Sequence< Contap_TheSegmentOfTheSearch >::Iterator & thePosition, Contap_TheSegmentOfTheSearch theItem)
        InsertAfter(NCollection_Sequence_Contap_TheSegmentOfTheSearch self, Standard_Integer const theIndex, NCollection_Sequence_Contap_TheSegmentOfTheSearch theSeq)
        InsertAfter(NCollection_Sequence_Contap_TheSegmentOfTheSearch self, Standard_Integer const theIndex, Contap_TheSegmentOfTheSearch theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Contap_TheSegmentOfTheSearch self, Standard_Integer const theIndex, NCollection_Sequence_Contap_TheSegmentOfTheSearch theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Contap_TheSegmentOfTheSearch self) -> Contap_TheSegmentOfTheSearch

        First item access

        :rtype: TheItemType &

        """
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Contap_TheSegmentOfTheSearch self) -> Contap_TheSegmentOfTheSearch

        Last item access

        :rtype: TheItemType &

        """
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Contap_TheSegmentOfTheSearch self, Standard_Integer const theIndex) -> Contap_TheSegmentOfTheSearch

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Contap_TheSegmentOfTheSearch self, Standard_Integer const theIndex, Contap_TheSegmentOfTheSearch theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_SetValue(self, *args)


    def __iter__(self):
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch___iter__(self)
    __swig_destroy__ = _Contap.delete_NCollection_Sequence_Contap_TheSegmentOfTheSearch
NCollection_Sequence_Contap_TheSegmentOfTheSearch_swigregister = _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_swigregister
NCollection_Sequence_Contap_TheSegmentOfTheSearch_swigregister(NCollection_Sequence_Contap_TheSegmentOfTheSearch)

def NCollection_Sequence_Contap_TheSegmentOfTheSearch_delNode(*args):
    """
    NCollection_Sequence_Contap_TheSegmentOfTheSearch_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_delNode(*args)

class NCollection_Sequence_Contap_TheSegmentOfTheSearch_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Contap.new_NCollection_Sequence_Contap_TheSegmentOfTheSearch_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Contap.delete_NCollection_Sequence_Contap_TheSegmentOfTheSearch_IteratorHelper

    def __next__(self):
        return _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_IteratorHelper___next__(self)
NCollection_Sequence_Contap_TheSegmentOfTheSearch_IteratorHelper_swigregister = _Contap.NCollection_Sequence_Contap_TheSegmentOfTheSearch_IteratorHelper_swigregister
NCollection_Sequence_Contap_TheSegmentOfTheSearch_IteratorHelper_swigregister(NCollection_Sequence_Contap_TheSegmentOfTheSearch_IteratorHelper)


try:
	Contap_SequenceOfSegmentOfTheSearch = NCollection_Sequence_Contap_TheSegmentOfTheSearch
except NameError:
	pass # does not exist, probably ignored

class Contap_Point(object):
    """
    Definition of a vertex on the contour line.
    Most of the time, such a point is an intersection
    between the contour and a restriction of the surface.
    When it is not tyhe method IsOnArc return False.
    Such a point is contains geometrical informations (see
    the Value method) and logical informations.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Contap_Point self) -> Contap_Point
        __init__(Contap_Point self, gp_Pnt Pt, Standard_Real const U, Standard_Real const V) -> Contap_Point

        Creates a point.

        :type Pt: OCC.wrapper.gp.gp_Pnt
        :type U: float
        :type V: float

        """
        this = _Contap.new_Contap_Point(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetValue(self, *args):
        """
        SetValue(Contap_Point self, gp_Pnt Pt, Standard_Real const U, Standard_Real const V)

        Sets the values for a point.

        :type Pt: OCC.wrapper.gp.gp_Pnt
        :type U: float
        :type V: float

        """
        return _Contap.Contap_Point_SetValue(self, *args)


    def SetParameter(self, *args):
        """
        SetParameter(Contap_Point self, Standard_Real const Para)

        Set the value of the parameter on the intersection line.

        :type Para: float

        """
        return _Contap.Contap_Point_SetParameter(self, *args)


    def SetVertex(self, *args):
        """
        SetVertex(Contap_Point self, Handle_Adaptor3d_HVertex V)

        Sets the values of a point which is a vertex on
        the initial facet of restriction of one
        of the surface.

        :type V: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex

        """
        return _Contap.Contap_Point_SetVertex(self, *args)


    def SetArc(self, *args):
        """
        SetArc(Contap_Point self, Handle_Adaptor2d_HCurve2d A, Standard_Real const Param, IntSurf_Transition TLine, IntSurf_Transition TArc)

        Sets the value of the arc and of the parameter on
        this arc of the point.

        :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Param: float
        :type TLine: OCC.wrapper.IntSurf.IntSurf_Transition
        :type TArc: OCC.wrapper.IntSurf.IntSurf_Transition

        """
        return _Contap.Contap_Point_SetArc(self, *args)


    def SetMultiple(self, *args):
        """SetMultiple(Contap_Point self)"""
        return _Contap.Contap_Point_SetMultiple(self, *args)


    def SetInternal(self, *args):
        """SetInternal(Contap_Point self)"""
        return _Contap.Contap_Point_SetInternal(self, *args)


    def Value(self, *args):
        """
        Returns the intersection point (geometric information).

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Contap.Contap_Point_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParameterOnLine(self, *args):
        """
        ParameterOnLine(Contap_Point self) -> Standard_Real

        This method returns the parameter of the point
        on the intersection line.
        If the points does not belong to an intersection line,
        the value returned does not have any sens.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Contap.Contap_Point_ParameterOnLine(self, *args)


    def Parameters(self, *args):
        """
        Parameters(Contap_Point self)

        Returns the parameters on the surface of the point.

        :type U1: float
        :type V1: float

        """
        return _Contap.Contap_Point_Parameters(self, *args)


    def IsOnArc(self, *args):
        """
        IsOnArc(Contap_Point self) -> Standard_Boolean

        Returns True when the point is an intersection between
        the contour and a restriction.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_Point_IsOnArc(self, *args)


    def Arc(self, *args):
        """
        Returns the arc of restriction containing the
        vertex.

        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        res = _Contap.Contap_Point_Arc(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParameterOnArc(self, *args):
        """
        ParameterOnArc(Contap_Point self) -> Standard_Real

        Returns the parameter of the point on the
        arc returned by the method Arc().

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Contap.Contap_Point_ParameterOnArc(self, *args)


    def TransitionOnLine(self, *args):
        """
        Returns the transition of the point on the contour.

        :rtype: OCC.wrapper.IntSurf.IntSurf_Transition

        """
        res = _Contap.Contap_Point_TransitionOnLine(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransitionOnArc(self, *args):
        """
        Returns the transition of the point on the arc.

        :rtype: OCC.wrapper.IntSurf.IntSurf_Transition

        """
        res = _Contap.Contap_Point_TransitionOnArc(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsVertex(self, *args):
        """
        IsVertex(Contap_Point self) -> Standard_Boolean

        Returns TRUE if the point is a vertex on the initial
        restriction facet of the surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_Point_IsVertex(self, *args)


    def Vertex(self, *args):
        """
        Returns the information about the point when it is
        on the domain of the patch, i-e when the function
        IsVertex returns True.
        Otherwise, an exception is raised.

        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex

        """
        res = _Contap.Contap_Point_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsMultiple(self, *args):
        """
        IsMultiple(Contap_Point self) -> Standard_Boolean

        Returns True if the point belongs to several
        lines.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_Point_IsMultiple(self, *args)


    def IsInternal(self, *args):
        """
        IsInternal(Contap_Point self) -> Standard_Boolean

        Returns True if the point  is an internal one, i.e
        if the  tangent to the line on  the point  and the
        eye direction are parallel.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_Point_IsInternal(self, *args)

    __swig_destroy__ = _Contap.delete_Contap_Point
Contap_Point_swigregister = _Contap.Contap_Point_swigregister
Contap_Point_swigregister(Contap_Point)

class Handle_Contap_TheHSequenceOfPoint(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Contap_TheHSequenceOfPoint self)

        Nullify the handle


        """
        return _Contap.Handle_Contap_TheHSequenceOfPoint_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Contap_TheHSequenceOfPoint self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Contap.Handle_Contap_TheHSequenceOfPoint_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Contap_TheHSequenceOfPoint self, Contap_TheHSequenceOfPoint thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Contap.Handle_Contap_TheHSequenceOfPoint_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Contap_TheHSequenceOfPoint self, Handle_Contap_TheHSequenceOfPoint theHandle) -> Handle_Contap_TheHSequenceOfPoint
        assign(Handle_Contap_TheHSequenceOfPoint self, Contap_TheHSequenceOfPoint thePtr) -> Handle_Contap_TheHSequenceOfPoint
        assign(Handle_Contap_TheHSequenceOfPoint self, Handle_Contap_TheHSequenceOfPoint theHandle) -> Handle_Contap_TheHSequenceOfPoint

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Contap.Handle_Contap_TheHSequenceOfPoint_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Contap_TheHSequenceOfPoint self) -> Contap_TheHSequenceOfPoint

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Contap.Handle_Contap_TheHSequenceOfPoint_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Contap_TheHSequenceOfPoint self) -> Contap_TheHSequenceOfPoint

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Contap.Handle_Contap_TheHSequenceOfPoint___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Contap_TheHSequenceOfPoint self) -> Contap_TheHSequenceOfPoint

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Contap.Handle_Contap_TheHSequenceOfPoint___ref__(self, *args)


    def __hash__(self):
        return _Contap.Handle_Contap_TheHSequenceOfPoint___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Contap.Handle_Contap_TheHSequenceOfPoint___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Contap.new_Handle_Contap_TheHSequenceOfPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Contap.Handle_Contap_TheHSequenceOfPoint_DownCast)
    __swig_destroy__ = _Contap.delete_Handle_Contap_TheHSequenceOfPoint

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.Contap.Contap_TheSequenceOfPoint

        """
        res = _Contap.Handle_Contap_TheHSequenceOfPoint_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_Contap_TheHSequenceOfPoint self, Contap_Point theItem)
        Append(Handle_Contap_TheHSequenceOfPoint self, NCollection_Sequence_Contap_Point theSequence)

        :type theSequence: OCC.wrapper.Contap.Contap_TheSequenceOfPoint

        """
        return _Contap.Handle_Contap_TheHSequenceOfPoint_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_Contap_TheHSequenceOfPoint self) -> NCollection_Sequence_Contap_Point

        :rtype: OCC.wrapper.Contap.Contap_TheSequenceOfPoint

        """
        return _Contap.Handle_Contap_TheHSequenceOfPoint_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Contap_TheHSequenceOfPoint self) -> char const *

        :rtype: const char *

        """
        return _Contap.Handle_Contap_TheHSequenceOfPoint_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Contap.Handle_Contap_TheHSequenceOfPoint_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Contap.Handle_Contap_TheHSequenceOfPoint_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Contap_TheHSequenceOfPoint self)

        Memory deallocator for transient classes


        """
        return _Contap.Handle_Contap_TheHSequenceOfPoint_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Contap_TheHSequenceOfPoint self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Contap_TheHSequenceOfPoint self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Handle_Contap_TheHSequenceOfPoint_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Contap_TheHSequenceOfPoint self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Contap_TheHSequenceOfPoint self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Handle_Contap_TheHSequenceOfPoint_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Contap_TheHSequenceOfPoint self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Contap.Handle_Contap_TheHSequenceOfPoint_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Contap_TheHSequenceOfPoint self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Handle_Contap_TheHSequenceOfPoint_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Contap_TheHSequenceOfPoint self)

        Increments the reference counter of this object


        """
        return _Contap.Handle_Contap_TheHSequenceOfPoint_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Contap_TheHSequenceOfPoint self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Handle_Contap_TheHSequenceOfPoint_DecrementRefCounter(self, *args)

Handle_Contap_TheHSequenceOfPoint_swigregister = _Contap.Handle_Contap_TheHSequenceOfPoint_swigregister
Handle_Contap_TheHSequenceOfPoint_swigregister(Handle_Contap_TheHSequenceOfPoint)

def Handle_Contap_TheHSequenceOfPoint_DownCast(thing):
    return _Contap.Handle_Contap_TheHSequenceOfPoint_DownCast(thing)
Handle_Contap_TheHSequenceOfPoint_DownCast = _Contap.Handle_Contap_TheHSequenceOfPoint_DownCast

class Contap_TheIWLineOfTheIWalking(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Contap_TheIWLineOfTheIWalking
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Contap_TheIWLineOfTheIWalking(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Contap_TheIWLineOfTheIWalking self, Handle_NCollection_BaseAllocator theAllocator=0) -> Contap_TheIWLineOfTheIWalking

        :type theAllocator: OCC.wrapper.IntSurf.IntSurf_Allocator

        """
        this = _Contap.new_Contap_TheIWLineOfTheIWalking(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Reverse(self, *args):
        """
        Reverse(Contap_TheIWLineOfTheIWalking self)

        reverse the points in the line. Hasfirst, HasLast are kept.


        """
        return _Contap.Contap_TheIWLineOfTheIWalking_Reverse(self, *args)


    def Cut(self, *args):
        """
        Cut(Contap_TheIWLineOfTheIWalking self, Standard_Integer const Index)

        Cut the line at the point of rank Index.

        :type Index: int

        """
        return _Contap.Contap_TheIWLineOfTheIWalking_Cut(self, *args)


    def AddPoint(self, *args):
        """
        AddPoint(Contap_TheIWLineOfTheIWalking self, IntSurf_PntOn2S P)

        Add a point in the line.

        :type P: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        return _Contap.Contap_TheIWLineOfTheIWalking_AddPoint(self, *args)


    def AddStatusFirst(self, *args):
        """
        AddStatusFirst(Contap_TheIWLineOfTheIWalking self, Standard_Boolean const Closed, Standard_Boolean const HasFirst)
        AddStatusFirst(Contap_TheIWLineOfTheIWalking self, Standard_Boolean const Closed, Standard_Boolean const HasLast, Standard_Integer const Index, IntSurf_PathPoint P)

        :type Closed: bool
        :type HasLast: bool
        :type Index: int
        :type P: OCC.wrapper.IntSurf.IntSurf_PathPoint

        """
        return _Contap.Contap_TheIWLineOfTheIWalking_AddStatusFirst(self, *args)


    def AddStatusFirstLast(self, *args):
        """
        AddStatusFirstLast(Contap_TheIWLineOfTheIWalking self, Standard_Boolean const Closed, Standard_Boolean const HasFirst, Standard_Boolean const HasLast)

        :type Closed: bool
        :type HasFirst: bool
        :type HasLast: bool

        """
        return _Contap.Contap_TheIWLineOfTheIWalking_AddStatusFirstLast(self, *args)


    def AddStatusLast(self, *args):
        """
        AddStatusLast(Contap_TheIWLineOfTheIWalking self, Standard_Boolean const HasLast)
        AddStatusLast(Contap_TheIWLineOfTheIWalking self, Standard_Boolean const HasLast, Standard_Integer const Index, IntSurf_PathPoint P)

        :type HasLast: bool
        :type Index: int
        :type P: OCC.wrapper.IntSurf.IntSurf_PathPoint

        """
        return _Contap.Contap_TheIWLineOfTheIWalking_AddStatusLast(self, *args)


    def AddIndexPassing(self, *args):
        """
        AddIndexPassing(Contap_TheIWLineOfTheIWalking self, Standard_Integer const Index)

        associer a l 'indice du point sur la ligne l'indice du point
        passant dans l'iterateur de depart

        :type Index: int

        """
        return _Contap.Contap_TheIWLineOfTheIWalking_AddIndexPassing(self, *args)


    def SetTangentVector(self, *args):
        """
        SetTangentVector(Contap_TheIWLineOfTheIWalking self, gp_Vec V, Standard_Integer const Index)

        :type V: OCC.wrapper.gp.gp_Vec
        :type Index: int

        """
        return _Contap.Contap_TheIWLineOfTheIWalking_SetTangentVector(self, *args)


    def SetTangencyAtBegining(self, *args):
        """
        SetTangencyAtBegining(Contap_TheIWLineOfTheIWalking self, Standard_Boolean const IsTangent)

        :type IsTangent: bool

        """
        return _Contap.Contap_TheIWLineOfTheIWalking_SetTangencyAtBegining(self, *args)


    def SetTangencyAtEnd(self, *args):
        """
        SetTangencyAtEnd(Contap_TheIWLineOfTheIWalking self, Standard_Boolean const IsTangent)

        :type IsTangent: bool

        """
        return _Contap.Contap_TheIWLineOfTheIWalking_SetTangencyAtEnd(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(Contap_TheIWLineOfTheIWalking self) -> Standard_Integer

        Returns the number of points of the line (including first
        point and end point : see HasLastPoint and HasFirstPoint).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Contap_TheIWLineOfTheIWalking_NbPoints(self, *args)


    def Value(self, *args):
        """
        Returns the point of range Index.
        If index <= 0 or Index > NbPoints, an exception is raised.

        :type Index: int
        :rtype: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        res = _Contap.Contap_TheIWLineOfTheIWalking_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Line(self, *args):
        """
        Returns the LineOn2S contained in the walking line.

        :rtype: OCC.wrapper.IntSurf.Handle_IntSurf_LineOn2S

        """
        res = _Contap.Contap_TheIWLineOfTheIWalking_Line(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsClosed(self, *args):
        """
        IsClosed(Contap_TheIWLineOfTheIWalking self) -> Standard_Boolean

        Returns True if the line is closed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_TheIWLineOfTheIWalking_IsClosed(self, *args)


    def HasFirstPoint(self, *args):
        """
        HasFirstPoint(Contap_TheIWLineOfTheIWalking self) -> Standard_Boolean

        Returns True if the first point of the line is a
        marching point . when is HasFirstPoint==False ,the line
        begins on the natural bound of the surface.the line can be
        too long

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_TheIWLineOfTheIWalking_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args):
        """
        HasLastPoint(Contap_TheIWLineOfTheIWalking self) -> Standard_Boolean

        Returns True if the end point of the line is a
        marching point (Point from IntWS).
        when is HasFirstPoint==False ,the line ends
        on the natural bound of the surface.the line can be
        too long.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_TheIWLineOfTheIWalking_HasLastPoint(self, *args)


    def FirstPoint(self, *args):
        """
        Returns the first point of the line when it is a
        marching point.
        An exception is raised if HasFirstPoint returns False.

        :rtype: OCC.wrapper.IntSurf.IntSurf_PathPoint

        """
        res = _Contap.Contap_TheIWLineOfTheIWalking_FirstPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstPointIndex(self, *args):
        """
        FirstPointIndex(Contap_TheIWLineOfTheIWalking self) -> Standard_Integer

        Returns the Index of first point of the line when it is a
        marching point.This index is the index in the
        PointStartIterator.
        An exception is raised if HasFirstPoint returns False.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Contap_TheIWLineOfTheIWalking_FirstPointIndex(self, *args)


    def LastPoint(self, *args):
        """
        Returns the last point of the line when it is a
        marching point.
        An exception is raised if HasLastPoint returns False.

        :rtype: OCC.wrapper.IntSurf.IntSurf_PathPoint

        """
        res = _Contap.Contap_TheIWLineOfTheIWalking_LastPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastPointIndex(self, *args):
        """
        LastPointIndex(Contap_TheIWLineOfTheIWalking self) -> Standard_Integer

        Returns the index of last point of the line when it is a
        marching point.This index is the index in the
        PointStartIterator.
        An exception is raised if HasLastPoint returns False.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Contap_TheIWLineOfTheIWalking_LastPointIndex(self, *args)


    def NbPassingPoint(self, *args):
        """
        NbPassingPoint(Contap_TheIWLineOfTheIWalking self) -> Standard_Integer

        returns the number of points belonging to Pnts1 which are
        passing point.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Contap_TheIWLineOfTheIWalking_NbPassingPoint(self, *args)


    def PassingPoint(self, *args):
        """
        PassingPoint(Contap_TheIWLineOfTheIWalking self, Standard_Integer const Index)

        returns the index of the point belonging to the line which
        is associated to the passing point belonging to Pnts1
        an exception is raised if Index > NbPassingPoint()

        :type Index: int
        :type IndexLine: int
        :type IndexPnts: int

        """
        return _Contap.Contap_TheIWLineOfTheIWalking_PassingPoint(self, *args)


    def TangentVector(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _Contap.Contap_TheIWLineOfTheIWalking_TangentVector(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsTangentAtBegining(self, *args):
        """
        IsTangentAtBegining(Contap_TheIWLineOfTheIWalking self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_TheIWLineOfTheIWalking_IsTangentAtBegining(self, *args)


    def IsTangentAtEnd(self, *args):
        """
        IsTangentAtEnd(Contap_TheIWLineOfTheIWalking self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_TheIWLineOfTheIWalking_IsTangentAtEnd(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Contap.Contap_TheIWLineOfTheIWalking_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Contap.Contap_TheIWLineOfTheIWalking_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Contap.Contap_TheIWLineOfTheIWalking_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Contap.delete_Contap_TheIWLineOfTheIWalking
Contap_TheIWLineOfTheIWalking_swigregister = _Contap.Contap_TheIWLineOfTheIWalking_swigregister
Contap_TheIWLineOfTheIWalking_swigregister(Contap_TheIWLineOfTheIWalking)

def Contap_TheIWLineOfTheIWalking_get_type_name(*args):
    """
    Contap_TheIWLineOfTheIWalking_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Contap.Contap_TheIWLineOfTheIWalking_get_type_name(*args)

def Contap_TheIWLineOfTheIWalking_get_type_descriptor(*args):
    """
    Contap_TheIWLineOfTheIWalking_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Contap.Contap_TheIWLineOfTheIWalking_get_type_descriptor(*args)

class NCollection_Sequence_Contap_Line(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Contap_Line self) -> NCollection_Sequence< Contap_Line >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Contap.NCollection_Sequence_Contap_Line_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Contap_Line self) -> NCollection_Sequence< Contap_Line >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Contap.NCollection_Sequence_Contap_Line_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Contap_Line self) -> NCollection_Sequence< Contap_Line >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Contap.NCollection_Sequence_Contap_Line_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Contap_Line self) -> NCollection_Sequence< Contap_Line >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Contap.NCollection_Sequence_Contap_Line_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Contap.new_NCollection_Sequence_Contap_Line(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Contap_Line self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.NCollection_Sequence_Contap_Line_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Contap_Line self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.NCollection_Sequence_Contap_Line_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Contap_Line self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.NCollection_Sequence_Contap_Line_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Contap_Line self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.NCollection_Sequence_Contap_Line_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Contap_Line self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.NCollection_Sequence_Contap_Line_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Contap_Line self)

        Reverse sequence


        """
        return _Contap.NCollection_Sequence_Contap_Line_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Contap_Line self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Contap.NCollection_Sequence_Contap_Line_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Contap.NCollection_Sequence_Contap_Line_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Contap_Line self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Contap.NCollection_Sequence_Contap_Line_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Contap_Line self, NCollection_Sequence_Contap_Line theOther) -> NCollection_Sequence_Contap_Line

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Contap_Line_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Contap_Line self, NCollection_Sequence_Contap_Line theOther) -> NCollection_Sequence_Contap_Line

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Contap_Line_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Contap_Line self, NCollection_Sequence< Contap_Line >::Iterator & thePosition)
        Remove(NCollection_Sequence_Contap_Line self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Contap_Line self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Contap.NCollection_Sequence_Contap_Line_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Contap_Line self, Contap_Line theItem)
        Append(NCollection_Sequence_Contap_Line self, NCollection_Sequence_Contap_Line theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Contap_Line_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Contap_Line self, Contap_Line theItem)
        Prepend(NCollection_Sequence_Contap_Line self, NCollection_Sequence_Contap_Line theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Contap_Line_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Contap_Line self, Standard_Integer const theIndex, Contap_Line theItem)
        InsertBefore(NCollection_Sequence_Contap_Line self, Standard_Integer const theIndex, NCollection_Sequence_Contap_Line theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Contap_Line_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Contap_Line self, NCollection_Sequence< Contap_Line >::Iterator & thePosition, Contap_Line theItem)
        InsertAfter(NCollection_Sequence_Contap_Line self, Standard_Integer const theIndex, NCollection_Sequence_Contap_Line theSeq)
        InsertAfter(NCollection_Sequence_Contap_Line self, Standard_Integer const theIndex, Contap_Line theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Contap.NCollection_Sequence_Contap_Line_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Contap_Line self, Standard_Integer const theIndex, NCollection_Sequence_Contap_Line theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Contap_Line_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Contap.NCollection_Sequence_Contap_Line_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Contap_Line self) -> Contap_Line

        First item access

        :rtype: TheItemType &

        """
        return _Contap.NCollection_Sequence_Contap_Line_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Contap.NCollection_Sequence_Contap_Line_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Contap_Line self) -> Contap_Line

        Last item access

        :rtype: TheItemType &

        """
        return _Contap.NCollection_Sequence_Contap_Line_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Contap.NCollection_Sequence_Contap_Line_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Contap_Line self, Standard_Integer const theIndex) -> Contap_Line

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Contap.NCollection_Sequence_Contap_Line_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Contap.NCollection_Sequence_Contap_Line___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Contap_Line self, Standard_Integer const theIndex, Contap_Line theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Contap.NCollection_Sequence_Contap_Line_SetValue(self, *args)


    def __iter__(self):
        return _Contap.NCollection_Sequence_Contap_Line___iter__(self)
    __swig_destroy__ = _Contap.delete_NCollection_Sequence_Contap_Line
NCollection_Sequence_Contap_Line_swigregister = _Contap.NCollection_Sequence_Contap_Line_swigregister
NCollection_Sequence_Contap_Line_swigregister(NCollection_Sequence_Contap_Line)

def NCollection_Sequence_Contap_Line_delNode(*args):
    """
    NCollection_Sequence_Contap_Line_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Contap.NCollection_Sequence_Contap_Line_delNode(*args)

class NCollection_Sequence_Contap_Line_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Contap.new_NCollection_Sequence_Contap_Line_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Contap.delete_NCollection_Sequence_Contap_Line_IteratorHelper

    def __next__(self):
        return _Contap.NCollection_Sequence_Contap_Line_IteratorHelper___next__(self)
NCollection_Sequence_Contap_Line_IteratorHelper_swigregister = _Contap.NCollection_Sequence_Contap_Line_IteratorHelper_swigregister
NCollection_Sequence_Contap_Line_IteratorHelper_swigregister(NCollection_Sequence_Contap_Line_IteratorHelper)


try:
	Contap_TheSequenceOfLine = NCollection_Sequence_Contap_Line
except NameError:
	pass # does not exist, probably ignored

class Handle_Contap_TheIWLineOfTheIWalking(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Contap_TheIWLineOfTheIWalking self)

        Nullify the handle


        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Contap_TheIWLineOfTheIWalking self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Contap_TheIWLineOfTheIWalking self, Contap_TheIWLineOfTheIWalking thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Contap_TheIWLineOfTheIWalking self, Handle_Contap_TheIWLineOfTheIWalking theHandle) -> Handle_Contap_TheIWLineOfTheIWalking
        assign(Handle_Contap_TheIWLineOfTheIWalking self, Contap_TheIWLineOfTheIWalking thePtr) -> Handle_Contap_TheIWLineOfTheIWalking
        assign(Handle_Contap_TheIWLineOfTheIWalking self, Handle_Contap_TheIWLineOfTheIWalking theHandle) -> Handle_Contap_TheIWLineOfTheIWalking

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Contap_TheIWLineOfTheIWalking self) -> Contap_TheIWLineOfTheIWalking

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Contap_TheIWLineOfTheIWalking self) -> Contap_TheIWLineOfTheIWalking

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Contap_TheIWLineOfTheIWalking self) -> Contap_TheIWLineOfTheIWalking

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking___ref__(self, *args)


    def __hash__(self):
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Contap.Handle_Contap_TheIWLineOfTheIWalking___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Contap.new_Handle_Contap_TheIWLineOfTheIWalking(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Contap.Handle_Contap_TheIWLineOfTheIWalking_DownCast)
    __swig_destroy__ = _Contap.delete_Handle_Contap_TheIWLineOfTheIWalking

    def Reverse(self, *args):
        """
        Reverse(Handle_Contap_TheIWLineOfTheIWalking self)

        reverse the points in the line. Hasfirst, HasLast are kept.


        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_Reverse(self, *args)


    def Cut(self, *args):
        """
        Cut(Handle_Contap_TheIWLineOfTheIWalking self, Standard_Integer const Index)

        Cut the line at the point of rank Index.

        :type Index: int

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_Cut(self, *args)


    def AddPoint(self, *args):
        """
        AddPoint(Handle_Contap_TheIWLineOfTheIWalking self, IntSurf_PntOn2S P)

        Add a point in the line.

        :type P: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_AddPoint(self, *args)


    def AddStatusFirst(self, *args):
        """
        AddStatusFirst(Handle_Contap_TheIWLineOfTheIWalking self, Standard_Boolean const Closed, Standard_Boolean const HasFirst)
        AddStatusFirst(Handle_Contap_TheIWLineOfTheIWalking self, Standard_Boolean const Closed, Standard_Boolean const HasLast, Standard_Integer const Index, IntSurf_PathPoint P)

        :type Closed: bool
        :type HasLast: bool
        :type Index: int
        :type P: OCC.wrapper.IntSurf.IntSurf_PathPoint

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_AddStatusFirst(self, *args)


    def AddStatusFirstLast(self, *args):
        """
        AddStatusFirstLast(Handle_Contap_TheIWLineOfTheIWalking self, Standard_Boolean const Closed, Standard_Boolean const HasFirst, Standard_Boolean const HasLast)

        :type Closed: bool
        :type HasFirst: bool
        :type HasLast: bool

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_AddStatusFirstLast(self, *args)


    def AddStatusLast(self, *args):
        """
        AddStatusLast(Handle_Contap_TheIWLineOfTheIWalking self, Standard_Boolean const HasLast)
        AddStatusLast(Handle_Contap_TheIWLineOfTheIWalking self, Standard_Boolean const HasLast, Standard_Integer const Index, IntSurf_PathPoint P)

        :type HasLast: bool
        :type Index: int
        :type P: OCC.wrapper.IntSurf.IntSurf_PathPoint

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_AddStatusLast(self, *args)


    def AddIndexPassing(self, *args):
        """
        AddIndexPassing(Handle_Contap_TheIWLineOfTheIWalking self, Standard_Integer const Index)

        associer a l 'indice du point sur la ligne l'indice du point
        passant dans l'iterateur de depart

        :type Index: int

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_AddIndexPassing(self, *args)


    def SetTangentVector(self, *args):
        """
        SetTangentVector(Handle_Contap_TheIWLineOfTheIWalking self, gp_Vec V, Standard_Integer const Index)

        :type V: OCC.wrapper.gp.gp_Vec
        :type Index: int

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_SetTangentVector(self, *args)


    def SetTangencyAtBegining(self, *args):
        """
        SetTangencyAtBegining(Handle_Contap_TheIWLineOfTheIWalking self, Standard_Boolean const IsTangent)

        :type IsTangent: bool

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_SetTangencyAtBegining(self, *args)


    def SetTangencyAtEnd(self, *args):
        """
        SetTangencyAtEnd(Handle_Contap_TheIWLineOfTheIWalking self, Standard_Boolean const IsTangent)

        :type IsTangent: bool

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_SetTangencyAtEnd(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(Handle_Contap_TheIWLineOfTheIWalking self) -> Standard_Integer

        Returns the number of points of the line (including first
        point and end point : see HasLastPoint and HasFirstPoint).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_NbPoints(self, *args)


    def Value(self, *args):
        """
        Returns the point of range Index.
        If index <= 0 or Index > NbPoints, an exception is raised.

        :type Index: int
        :rtype: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        res = _Contap.Handle_Contap_TheIWLineOfTheIWalking_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Line(self, *args):
        """
        Returns the LineOn2S contained in the walking line.

        :rtype: OCC.wrapper.IntSurf.Handle_IntSurf_LineOn2S

        """
        res = _Contap.Handle_Contap_TheIWLineOfTheIWalking_Line(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsClosed(self, *args):
        """
        IsClosed(Handle_Contap_TheIWLineOfTheIWalking self) -> Standard_Boolean

        Returns True if the line is closed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_IsClosed(self, *args)


    def HasFirstPoint(self, *args):
        """
        HasFirstPoint(Handle_Contap_TheIWLineOfTheIWalking self) -> Standard_Boolean

        Returns True if the first point of the line is a
        marching point . when is HasFirstPoint==False ,the line
        begins on the natural bound of the surface.the line can be
        too long

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_HasFirstPoint(self, *args)


    def HasLastPoint(self, *args):
        """
        HasLastPoint(Handle_Contap_TheIWLineOfTheIWalking self) -> Standard_Boolean

        Returns True if the end point of the line is a
        marching point (Point from IntWS).
        when is HasFirstPoint==False ,the line ends
        on the natural bound of the surface.the line can be
        too long.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_HasLastPoint(self, *args)


    def FirstPoint(self, *args):
        """
        Returns the first point of the line when it is a
        marching point.
        An exception is raised if HasFirstPoint returns False.

        :rtype: OCC.wrapper.IntSurf.IntSurf_PathPoint

        """
        res = _Contap.Handle_Contap_TheIWLineOfTheIWalking_FirstPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstPointIndex(self, *args):
        """
        FirstPointIndex(Handle_Contap_TheIWLineOfTheIWalking self) -> Standard_Integer

        Returns the Index of first point of the line when it is a
        marching point.This index is the index in the
        PointStartIterator.
        An exception is raised if HasFirstPoint returns False.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_FirstPointIndex(self, *args)


    def LastPoint(self, *args):
        """
        Returns the last point of the line when it is a
        marching point.
        An exception is raised if HasLastPoint returns False.

        :rtype: OCC.wrapper.IntSurf.IntSurf_PathPoint

        """
        res = _Contap.Handle_Contap_TheIWLineOfTheIWalking_LastPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastPointIndex(self, *args):
        """
        LastPointIndex(Handle_Contap_TheIWLineOfTheIWalking self) -> Standard_Integer

        Returns the index of last point of the line when it is a
        marching point.This index is the index in the
        PointStartIterator.
        An exception is raised if HasLastPoint returns False.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_LastPointIndex(self, *args)


    def NbPassingPoint(self, *args):
        """
        NbPassingPoint(Handle_Contap_TheIWLineOfTheIWalking self) -> Standard_Integer

        returns the number of points belonging to Pnts1 which are
        passing point.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_NbPassingPoint(self, *args)


    def PassingPoint(self, *args):
        """
        PassingPoint(Handle_Contap_TheIWLineOfTheIWalking self, Standard_Integer const Index)

        returns the index of the point belonging to the line which
        is associated to the passing point belonging to Pnts1
        an exception is raised if Index > NbPassingPoint()

        :type Index: int
        :type IndexLine: int
        :type IndexPnts: int

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_PassingPoint(self, *args)


    def TangentVector(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _Contap.Handle_Contap_TheIWLineOfTheIWalking_TangentVector(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsTangentAtBegining(self, *args):
        """
        IsTangentAtBegining(Handle_Contap_TheIWLineOfTheIWalking self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_IsTangentAtBegining(self, *args)


    def IsTangentAtEnd(self, *args):
        """
        IsTangentAtEnd(Handle_Contap_TheIWLineOfTheIWalking self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_IsTangentAtEnd(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Contap_TheIWLineOfTheIWalking self) -> char const *

        :rtype: const char *

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Contap.Handle_Contap_TheIWLineOfTheIWalking_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Contap.Handle_Contap_TheIWLineOfTheIWalking_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Contap_TheIWLineOfTheIWalking self)

        Memory deallocator for transient classes


        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Contap_TheIWLineOfTheIWalking self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Contap_TheIWLineOfTheIWalking self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Contap_TheIWLineOfTheIWalking self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Contap_TheIWLineOfTheIWalking self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Contap_TheIWLineOfTheIWalking self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Contap_TheIWLineOfTheIWalking self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Contap_TheIWLineOfTheIWalking self)

        Increments the reference counter of this object


        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Contap_TheIWLineOfTheIWalking self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Handle_Contap_TheIWLineOfTheIWalking_DecrementRefCounter(self, *args)

Handle_Contap_TheIWLineOfTheIWalking_swigregister = _Contap.Handle_Contap_TheIWLineOfTheIWalking_swigregister
Handle_Contap_TheIWLineOfTheIWalking_swigregister(Handle_Contap_TheIWLineOfTheIWalking)

def Handle_Contap_TheIWLineOfTheIWalking_DownCast(thing):
    return _Contap.Handle_Contap_TheIWLineOfTheIWalking_DownCast(thing)
Handle_Contap_TheIWLineOfTheIWalking_DownCast = _Contap.Handle_Contap_TheIWLineOfTheIWalking_DownCast

class Contap_Contour(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Contap_Contour self) -> Contap_Contour
        __init__(Contap_Contour self, gp_Vec Direction) -> Contap_Contour
        __init__(Contap_Contour self, gp_Vec Direction, Standard_Real const Angle) -> Contap_Contour
        __init__(Contap_Contour self, gp_Pnt Eye) -> Contap_Contour
        __init__(Contap_Contour self, Handle_Adaptor3d_HSurface Surf, Handle_Adaptor3d_TopolTool Domain, gp_Vec Direction) -> Contap_Contour
        __init__(Contap_Contour self, Handle_Adaptor3d_HSurface Surf, Handle_Adaptor3d_TopolTool Domain, gp_Vec Direction, Standard_Real const Angle) -> Contap_Contour
        __init__(Contap_Contour self, Handle_Adaptor3d_HSurface Surf, Handle_Adaptor3d_TopolTool Domain, gp_Pnt Eye) -> Contap_Contour

        Creates the contour for a perspective view.

        :type Surf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Domain: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type Eye: OCC.wrapper.gp.gp_Pnt

        """
        this = _Contap.new_Contap_Contour(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Contap_Contour self, Handle_Adaptor3d_HSurface Surf, Handle_Adaptor3d_TopolTool Domain)
        Perform(Contap_Contour self, Handle_Adaptor3d_HSurface Surf, Handle_Adaptor3d_TopolTool Domain, gp_Vec Direction)
        Perform(Contap_Contour self, Handle_Adaptor3d_HSurface Surf, Handle_Adaptor3d_TopolTool Domain, gp_Vec Direction, Standard_Real const Angle)
        Perform(Contap_Contour self, Handle_Adaptor3d_HSurface Surf, Handle_Adaptor3d_TopolTool Domain, gp_Pnt Eye)

        Creates the contour for a perspective view.

        :type Surf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Domain: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type Eye: OCC.wrapper.gp.gp_Pnt

        """
        return _Contap.Contap_Contour_Perform(self, *args)


    def Init(self, *args):
        """
        Init(Contap_Contour self, gp_Vec Direction)
        Init(Contap_Contour self, gp_Vec Direction, Standard_Real const Angle)
        Init(Contap_Contour self, gp_Pnt Eye)

        :type Eye: OCC.wrapper.gp.gp_Pnt

        """
        return _Contap.Contap_Contour_Init(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Contap_Contour self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_Contour_IsDone(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Contap_Contour self) -> Standard_Boolean

        Returns true if the is no line.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_Contour_IsEmpty(self, *args)


    def NbLines(self, *args):
        """
        NbLines(Contap_Contour self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Contap_Contour_NbLines(self, *args)


    def Line(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.Contap.Contap_Line

        """
        res = _Contap.Contap_Contour_Line(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfaceFunction(self, *args):
        """
        SurfaceFunction(Contap_Contour self) -> Contap_SurfFunction

        Returns    a     reference   on     the   internal
        SurfaceFunction.  This is used to compute tangents
        on the lines.

        :rtype: OCC.wrapper.Contap.Contap_SurfFunction

        """
        return _Contap.Contap_Contour_SurfaceFunction(self, *args)

    __swig_destroy__ = _Contap.delete_Contap_Contour
Contap_Contour_swigregister = _Contap.Contap_Contour_swigregister
Contap_Contour_swigregister(Contap_Contour)

class Contap_ArcFunction(math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(Contap_ArcFunction self) -> Contap_ArcFunction"""
        this = _Contap.new_Contap_ArcFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Set(self, *args):
        """
        Set(Contap_ArcFunction self, Handle_Adaptor3d_HSurface S)
        Set(Contap_ArcFunction self, gp_Dir Direction)
        Set(Contap_ArcFunction self, gp_Dir Direction, Standard_Real const Angle)
        Set(Contap_ArcFunction self, gp_Pnt Eye)
        Set(Contap_ArcFunction self, gp_Pnt Eye, Standard_Real const Angle)
        Set(Contap_ArcFunction self, Handle_Adaptor2d_HCurve2d A)

        :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _Contap.Contap_ArcFunction_Set(self, *args)


    def Value(self, *args):
        """
        Value(Contap_ArcFunction self, Standard_Real const X) -> Standard_Boolean

        :type X: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_ArcFunction_Value(self, *args)


    def Derivative(self, *args):
        """
        Derivative(Contap_ArcFunction self, Standard_Real const X) -> Standard_Boolean

        :type X: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_ArcFunction_Derivative(self, *args)


    def Values(self, *args):
        """
        Values(Contap_ArcFunction self, Standard_Real const X) -> Standard_Boolean

        :type X: float
        :type F: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_ArcFunction_Values(self, *args)


    def NbSamples(self, *args):
        """
        NbSamples(Contap_ArcFunction self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Contap_ArcFunction_NbSamples(self, *args)


    def GetStateNumber(self, *args):
        """
        GetStateNumber(Contap_ArcFunction self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Contap_ArcFunction_GetStateNumber(self, *args)


    def Valpoint(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Contap.Contap_ArcFunction_Valpoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Quadric(self, *args):
        """
        :rtype: OCC.wrapper.IntSurf.IntSurf_Quadric

        """
        res = _Contap.Contap_ArcFunction_Quadric(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface(self, *args):
        """
        Returns mySurf field

        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        res = _Contap.Contap_ArcFunction_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastComputedPoint(self, *args):
        """
        Returns the point, which has been computed
        while the last calling Value() method

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Contap.Contap_ArcFunction_LastComputedPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Contap.delete_Contap_ArcFunction
Contap_ArcFunction_swigregister = _Contap.Contap_ArcFunction_swigregister
Contap_ArcFunction_swigregister(Contap_ArcFunction)

class NCollection_Sequence_Contap_Point(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Contap_Point self) -> NCollection_Sequence< Contap_Point >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Contap.NCollection_Sequence_Contap_Point_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Contap_Point self) -> NCollection_Sequence< Contap_Point >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Contap.NCollection_Sequence_Contap_Point_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Contap_Point self) -> NCollection_Sequence< Contap_Point >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Contap.NCollection_Sequence_Contap_Point_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Contap_Point self) -> NCollection_Sequence< Contap_Point >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Contap.NCollection_Sequence_Contap_Point_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Contap.new_NCollection_Sequence_Contap_Point(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Contap_Point self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.NCollection_Sequence_Contap_Point_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Contap_Point self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.NCollection_Sequence_Contap_Point_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Contap_Point self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.NCollection_Sequence_Contap_Point_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Contap_Point self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.NCollection_Sequence_Contap_Point_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Contap_Point self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.NCollection_Sequence_Contap_Point_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Contap_Point self)

        Reverse sequence


        """
        return _Contap.NCollection_Sequence_Contap_Point_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Contap_Point self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Contap.NCollection_Sequence_Contap_Point_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Contap.NCollection_Sequence_Contap_Point_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Contap_Point self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Contap.NCollection_Sequence_Contap_Point_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Contap_Point self, NCollection_Sequence_Contap_Point theOther) -> NCollection_Sequence_Contap_Point

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Contap_Point_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Contap_Point self, NCollection_Sequence_Contap_Point theOther) -> NCollection_Sequence_Contap_Point

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Contap_Point_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Contap_Point self, NCollection_Sequence< Contap_Point >::Iterator & thePosition)
        Remove(NCollection_Sequence_Contap_Point self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Contap_Point self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Contap.NCollection_Sequence_Contap_Point_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Contap_Point self, Contap_Point theItem)
        Append(NCollection_Sequence_Contap_Point self, NCollection_Sequence_Contap_Point theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Contap_Point_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Contap_Point self, Contap_Point theItem)
        Prepend(NCollection_Sequence_Contap_Point self, NCollection_Sequence_Contap_Point theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Contap_Point_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Contap_Point self, Standard_Integer const theIndex, Contap_Point theItem)
        InsertBefore(NCollection_Sequence_Contap_Point self, Standard_Integer const theIndex, NCollection_Sequence_Contap_Point theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Contap_Point_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Contap_Point self, NCollection_Sequence< Contap_Point >::Iterator & thePosition, Contap_Point theItem)
        InsertAfter(NCollection_Sequence_Contap_Point self, Standard_Integer const theIndex, NCollection_Sequence_Contap_Point theSeq)
        InsertAfter(NCollection_Sequence_Contap_Point self, Standard_Integer const theIndex, Contap_Point theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Contap.NCollection_Sequence_Contap_Point_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Contap_Point self, Standard_Integer const theIndex, NCollection_Sequence_Contap_Point theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Contap_Point_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Contap.NCollection_Sequence_Contap_Point_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Contap_Point self) -> Contap_Point

        First item access

        :rtype: TheItemType &

        """
        return _Contap.NCollection_Sequence_Contap_Point_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Contap.NCollection_Sequence_Contap_Point_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Contap_Point self) -> Contap_Point

        Last item access

        :rtype: TheItemType &

        """
        return _Contap.NCollection_Sequence_Contap_Point_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Contap.NCollection_Sequence_Contap_Point_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Contap_Point self, Standard_Integer const theIndex) -> Contap_Point

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Contap.NCollection_Sequence_Contap_Point_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Contap.NCollection_Sequence_Contap_Point___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Contap_Point self, Standard_Integer const theIndex, Contap_Point theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Contap.NCollection_Sequence_Contap_Point_SetValue(self, *args)


    def __iter__(self):
        return _Contap.NCollection_Sequence_Contap_Point___iter__(self)
    __swig_destroy__ = _Contap.delete_NCollection_Sequence_Contap_Point
NCollection_Sequence_Contap_Point_swigregister = _Contap.NCollection_Sequence_Contap_Point_swigregister
NCollection_Sequence_Contap_Point_swigregister(NCollection_Sequence_Contap_Point)

def NCollection_Sequence_Contap_Point_delNode(*args):
    """
    NCollection_Sequence_Contap_Point_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Contap.NCollection_Sequence_Contap_Point_delNode(*args)

class NCollection_Sequence_Contap_Point_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Contap.new_NCollection_Sequence_Contap_Point_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Contap.delete_NCollection_Sequence_Contap_Point_IteratorHelper

    def __next__(self):
        return _Contap.NCollection_Sequence_Contap_Point_IteratorHelper___next__(self)
NCollection_Sequence_Contap_Point_IteratorHelper_swigregister = _Contap.NCollection_Sequence_Contap_Point_IteratorHelper_swigregister
NCollection_Sequence_Contap_Point_IteratorHelper_swigregister(NCollection_Sequence_Contap_Point_IteratorHelper)


try:
	Contap_TheSequenceOfPoint = NCollection_Sequence_Contap_Point
except NameError:
	pass # does not exist, probably ignored

class Contap_TheSearch(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Contap_TheSearch self) -> Contap_TheSearch

        Empty constructor.


        """
        this = _Contap.new_Contap_TheSearch(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Contap_TheSearch self, Contap_ArcFunction F, Handle_Adaptor3d_TopolTool Domain, Standard_Real const TolBoundary, Standard_Real const TolTangency, Standard_Boolean const RecheckOnRegularity)

        Algorithm to find the points and parts of curves of Domain
        (domain of of restriction of a surface) which verify
        F = 0.
        TolBoundary defines if a curve is on Q.
        TolTangency defines if a point is on Q.

        :type F: OCC.wrapper.Contap.Contap_ArcFunction
        :type Domain: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_TopolTool
        :type TolBoundary: float
        :type TolTangency: float
        :type RecheckOnRegularity: bool

        """
        return _Contap.Contap_TheSearch_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Contap_TheSearch self) -> Standard_Boolean

        Returns True if the calculus was successful.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_TheSearch_IsDone(self, *args)


    def AllArcSolution(self, *args):
        """
        AllArcSolution(Contap_TheSearch self) -> Standard_Boolean

        Returns true if all arc of the Arcs are solution (inside
        the surface).
        An exception is raised if IsDone returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_TheSearch_AllArcSolution(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(Contap_TheSearch self) -> Standard_Integer

        Returns the number of resulting points.
        An exception is raised if IsDone returns False (NotDone).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Contap_TheSearch_NbPoints(self, *args)


    def Point(self, *args):
        """
        Returns the resulting point of range Index.
        The exception NotDone is raised if IsDone() returns
        False.
        The exception OutOfRange is raised if
        Index <= 0 or Index > NbPoints.

        :type Index: int
        :rtype: OCC.wrapper.Contap.Contap_ThePathPointOfTheSearch

        """
        res = _Contap.Contap_TheSearch_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbSegments(self, *args):
        """
        NbSegments(Contap_TheSearch self) -> Standard_Integer

        Returns the number of the resulting segments.
        An exception is raised if IsDone returns False (NotDone).

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Contap_TheSearch_NbSegments(self, *args)


    def Segment(self, *args):
        """
        Returns the resulting segment of range Index.
        The exception NotDone is raised if IsDone() returns
        False.
        The exception OutOfRange is raised if
        Index <= 0 or Index > NbPoints.

        :type Index: int
        :rtype: OCC.wrapper.Contap.Contap_TheSegmentOfTheSearch

        """
        res = _Contap.Contap_TheSearch_Segment(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Contap.delete_Contap_TheSearch
Contap_TheSearch_swigregister = _Contap.Contap_TheSearch_swigregister
Contap_TheSearch_swigregister(Contap_TheSearch)

class Contap_HCurve2dTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FirstParameter(*args):
        """
        FirstParameter(Handle_Adaptor2d_HCurve2d C) -> Standard_Real

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Contap.Contap_HCurve2dTool_FirstParameter(*args)

    FirstParameter = staticmethod(FirstParameter)

    def LastParameter(*args):
        """
        LastParameter(Handle_Adaptor2d_HCurve2d C) -> Standard_Real

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Contap.Contap_HCurve2dTool_LastParameter(*args)

    LastParameter = staticmethod(LastParameter)

    def Continuity(*args):
        """
        Continuity(Handle_Adaptor2d_HCurve2d C) -> GeomAbs_Shape

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Contap.Contap_HCurve2dTool_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def NbIntervals(*args):
        """
        NbIntervals(Handle_Adaptor2d_HCurve2d C, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(myclass) >= <S>

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Contap_HCurve2dTool_NbIntervals(*args)

    NbIntervals = staticmethod(NbIntervals)

    def Intervals(*args):
        """
        Intervals(Handle_Adaptor2d_HCurve2d C, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Contap.Contap_HCurve2dTool_Intervals(*args)

    Intervals = staticmethod(Intervals)

    def IsClosed(*args):
        """
        IsClosed(Handle_Adaptor2d_HCurve2d C) -> Standard_Boolean

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_HCurve2dTool_IsClosed(*args)

    IsClosed = staticmethod(IsClosed)

    def IsPeriodic(*args):
        """
        IsPeriodic(Handle_Adaptor2d_HCurve2d C) -> Standard_Boolean

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_HCurve2dTool_IsPeriodic(*args)

    IsPeriodic = staticmethod(IsPeriodic)

    def Period(*args):
        """
        Period(Handle_Adaptor2d_HCurve2d C) -> Standard_Real

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Contap.Contap_HCurve2dTool_Period(*args)

    Period = staticmethod(Period)

    def Value(*args):
        """
        Value(Handle_Adaptor2d_HCurve2d C, Standard_Real const U) -> gp_Pnt2d

        Computes the point of parameter U on the curve.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Contap.Contap_HCurve2dTool_Value(*args)

    Value = staticmethod(Value)

    def D0(*args):
        """
        D0(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, gp_Pnt2d P)

        Computes the point of parameter U on the curve.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Contap.Contap_HCurve2dTool_D0(*args)

    D0 = staticmethod(D0)

    def D1(*args):
        """
        D1(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V)

        Computes the point of parameter U on the curve with its
        first derivative.
        Raised if the continuity of the current interval
        is not C1.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V: OCC.wrapper.gp.gp_Vec2d

        """
        return _Contap.Contap_HCurve2dTool_D1(*args)

    D1 = staticmethod(D1)

    def D2(*args):
        """
        D2(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.
        Raised if the continuity of the current interval
        is not C2.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Contap.Contap_HCurve2dTool_D2(*args)

    D2 = staticmethod(D2)

    def D3(*args):
        """
        D3(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Returns the point P of parameter U, the first, the second
        and the third derivative.
        Raised if the continuity of the current interval
        is not C3.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Contap.Contap_HCurve2dTool_D3(*args)

    D3 = staticmethod(D3)

    def DN(*args):
        """
        DN(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        The returned vector gives the value of the derivative for the
        order of derivation N.
        Raised if the continuity of the current interval
        is not CN.
        Raised if N < 1.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Contap.Contap_HCurve2dTool_DN(*args)

    DN = staticmethod(DN)

    def Resolution(*args):
        """
        Resolution(Handle_Adaptor2d_HCurve2d C, Standard_Real const R3d) -> Standard_Real

        Returns the parametric  resolution corresponding
        to the real space resolution <R3d>.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Contap.Contap_HCurve2dTool_Resolution(*args)

    Resolution = staticmethod(Resolution)

    def GetType(*args):
        """
        GetType(Handle_Adaptor2d_HCurve2d C) -> GeomAbs_CurveType

        Returns  the  type of the   curve  in the  current
        interval :   Line,   Circle,   Ellipse, Hyperbola,
        Parabola, BezierCurve, BSplineCurve, OtherCurve.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _Contap.Contap_HCurve2dTool_GetType(*args)

    GetType = staticmethod(GetType)

    def Line(*args):
        """
        Line(Handle_Adaptor2d_HCurve2d C) -> gp_Lin2d

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _Contap.Contap_HCurve2dTool_Line(*args)

    Line = staticmethod(Line)

    def Circle(*args):
        """
        Circle(Handle_Adaptor2d_HCurve2d C) -> gp_Circ2d

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _Contap.Contap_HCurve2dTool_Circle(*args)

    Circle = staticmethod(Circle)

    def Ellipse(*args):
        """
        Ellipse(Handle_Adaptor2d_HCurve2d C) -> gp_Elips2d

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.gp.gp_Elips2d

        """
        return _Contap.Contap_HCurve2dTool_Ellipse(*args)

    Ellipse = staticmethod(Ellipse)

    def Hyperbola(*args):
        """
        Hyperbola(Handle_Adaptor2d_HCurve2d C) -> gp_Hypr2d

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _Contap.Contap_HCurve2dTool_Hyperbola(*args)

    Hyperbola = staticmethod(Hyperbola)

    def Parabola(*args):
        """
        Parabola(Handle_Adaptor2d_HCurve2d C) -> gp_Parab2d

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.gp.gp_Parab2d

        """
        return _Contap.Contap_HCurve2dTool_Parabola(*args)

    Parabola = staticmethod(Parabola)

    def Bezier(*args):
        """
        Bezier(Handle_Adaptor2d_HCurve2d C) -> Handle_Geom2d_BezierCurve

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BezierCurve

        """
        return _Contap.Contap_HCurve2dTool_Bezier(*args)

    Bezier = staticmethod(Bezier)

    def BSpline(*args):
        """
        BSpline(Handle_Adaptor2d_HCurve2d C) -> Handle_Geom2d_BSplineCurve

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _Contap.Contap_HCurve2dTool_BSpline(*args)

    BSpline = staticmethod(BSpline)

    def NbSamples(*args):
        """
        NbSamples(Handle_Adaptor2d_HCurve2d C, Standard_Real const U0, Standard_Real const U1) -> Standard_Integer

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type U0: float
        :type U1: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Contap_HCurve2dTool_NbSamples(*args)

    NbSamples = staticmethod(NbSamples)

    def __init__(self):
        this = _Contap.new_Contap_HCurve2dTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Contap.delete_Contap_HCurve2dTool
Contap_HCurve2dTool_swigregister = _Contap.Contap_HCurve2dTool_swigregister
Contap_HCurve2dTool_swigregister(Contap_HCurve2dTool)

def Contap_HCurve2dTool_FirstParameter(*args):
    """
    Contap_HCurve2dTool_FirstParameter(Handle_Adaptor2d_HCurve2d C) -> Standard_Real

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Contap.Contap_HCurve2dTool_FirstParameter(*args)

def Contap_HCurve2dTool_LastParameter(*args):
    """
    Contap_HCurve2dTool_LastParameter(Handle_Adaptor2d_HCurve2d C) -> Standard_Real

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Contap.Contap_HCurve2dTool_LastParameter(*args)

def Contap_HCurve2dTool_Continuity(*args):
    """
    Contap_HCurve2dTool_Continuity(Handle_Adaptor2d_HCurve2d C) -> GeomAbs_Shape

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _Contap.Contap_HCurve2dTool_Continuity(*args)

def Contap_HCurve2dTool_NbIntervals(*args):
    """
    Contap_HCurve2dTool_NbIntervals(Handle_Adaptor2d_HCurve2d C, GeomAbs_Shape const S) -> Standard_Integer

    Returns  the number  of  intervals for  continuity
    <S>. May be one if Continuity(myclass) >= <S>

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Contap.Contap_HCurve2dTool_NbIntervals(*args)

def Contap_HCurve2dTool_Intervals(*args):
    """
    Contap_HCurve2dTool_Intervals(Handle_Adaptor2d_HCurve2d C, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

    Stores in <T> the  parameters bounding the intervals
    of continuity <S>.

    The array must provide  enough room to  accomodate
    for the parameters. i.e. T.Length() > NbIntervals()

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _Contap.Contap_HCurve2dTool_Intervals(*args)

def Contap_HCurve2dTool_IsClosed(*args):
    """
    Contap_HCurve2dTool_IsClosed(Handle_Adaptor2d_HCurve2d C) -> Standard_Boolean

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Contap.Contap_HCurve2dTool_IsClosed(*args)

def Contap_HCurve2dTool_IsPeriodic(*args):
    """
    Contap_HCurve2dTool_IsPeriodic(Handle_Adaptor2d_HCurve2d C) -> Standard_Boolean

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Contap.Contap_HCurve2dTool_IsPeriodic(*args)

def Contap_HCurve2dTool_Period(*args):
    """
    Contap_HCurve2dTool_Period(Handle_Adaptor2d_HCurve2d C) -> Standard_Real

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Contap.Contap_HCurve2dTool_Period(*args)

def Contap_HCurve2dTool_Value(*args):
    """
    Contap_HCurve2dTool_Value(Handle_Adaptor2d_HCurve2d C, Standard_Real const U) -> gp_Pnt2d

    Computes the point of parameter U on the curve.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type U: float
    :rtype: OCC.wrapper.gp.gp_Pnt2d

    """
    return _Contap.Contap_HCurve2dTool_Value(*args)

def Contap_HCurve2dTool_D0(*args):
    """
    Contap_HCurve2dTool_D0(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, gp_Pnt2d P)

    Computes the point of parameter U on the curve.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d

    """
    return _Contap.Contap_HCurve2dTool_D0(*args)

def Contap_HCurve2dTool_D1(*args):
    """
    Contap_HCurve2dTool_D1(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V)

    Computes the point of parameter U on the curve with its
    first derivative.
    Raised if the continuity of the current interval
    is not C1.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V: OCC.wrapper.gp.gp_Vec2d

    """
    return _Contap.Contap_HCurve2dTool_D1(*args)

def Contap_HCurve2dTool_D2(*args):
    """
    Contap_HCurve2dTool_D2(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

    Returns the point P of parameter U, the first and second
    derivatives V1 and V2.
    Raised if the continuity of the current interval
    is not C2.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d
    :type V2: OCC.wrapper.gp.gp_Vec2d

    """
    return _Contap.Contap_HCurve2dTool_D2(*args)

def Contap_HCurve2dTool_D3(*args):
    """
    Contap_HCurve2dTool_D3(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

    Returns the point P of parameter U, the first, the second
    and the third derivative.
    Raised if the continuity of the current interval
    is not C3.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type U: float
    :type P: OCC.wrapper.gp.gp_Pnt2d
    :type V1: OCC.wrapper.gp.gp_Vec2d
    :type V2: OCC.wrapper.gp.gp_Vec2d
    :type V3: OCC.wrapper.gp.gp_Vec2d

    """
    return _Contap.Contap_HCurve2dTool_D3(*args)

def Contap_HCurve2dTool_DN(*args):
    """
    Contap_HCurve2dTool_DN(Handle_Adaptor2d_HCurve2d C, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

    The returned vector gives the value of the derivative for the
    order of derivation N.
    Raised if the continuity of the current interval
    is not CN.
    Raised if N < 1.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type U: float
    :type N: int
    :rtype: OCC.wrapper.gp.gp_Vec2d

    """
    return _Contap.Contap_HCurve2dTool_DN(*args)

def Contap_HCurve2dTool_Resolution(*args):
    """
    Contap_HCurve2dTool_Resolution(Handle_Adaptor2d_HCurve2d C, Standard_Real const R3d) -> Standard_Real

    Returns the parametric  resolution corresponding
    to the real space resolution <R3d>.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type R3d: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Contap.Contap_HCurve2dTool_Resolution(*args)

def Contap_HCurve2dTool_GetType(*args):
    """
    Contap_HCurve2dTool_GetType(Handle_Adaptor2d_HCurve2d C) -> GeomAbs_CurveType

    Returns  the  type of the   curve  in the  current
    interval :   Line,   Circle,   Ellipse, Hyperbola,
    Parabola, BezierCurve, BSplineCurve, OtherCurve.

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

    """
    return _Contap.Contap_HCurve2dTool_GetType(*args)

def Contap_HCurve2dTool_Line(*args):
    """
    Contap_HCurve2dTool_Line(Handle_Adaptor2d_HCurve2d C) -> gp_Lin2d

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.gp.gp_Lin2d

    """
    return _Contap.Contap_HCurve2dTool_Line(*args)

def Contap_HCurve2dTool_Circle(*args):
    """
    Contap_HCurve2dTool_Circle(Handle_Adaptor2d_HCurve2d C) -> gp_Circ2d

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.gp.gp_Circ2d

    """
    return _Contap.Contap_HCurve2dTool_Circle(*args)

def Contap_HCurve2dTool_Ellipse(*args):
    """
    Contap_HCurve2dTool_Ellipse(Handle_Adaptor2d_HCurve2d C) -> gp_Elips2d

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.gp.gp_Elips2d

    """
    return _Contap.Contap_HCurve2dTool_Ellipse(*args)

def Contap_HCurve2dTool_Hyperbola(*args):
    """
    Contap_HCurve2dTool_Hyperbola(Handle_Adaptor2d_HCurve2d C) -> gp_Hypr2d

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.gp.gp_Hypr2d

    """
    return _Contap.Contap_HCurve2dTool_Hyperbola(*args)

def Contap_HCurve2dTool_Parabola(*args):
    """
    Contap_HCurve2dTool_Parabola(Handle_Adaptor2d_HCurve2d C) -> gp_Parab2d

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.gp.gp_Parab2d

    """
    return _Contap.Contap_HCurve2dTool_Parabola(*args)

def Contap_HCurve2dTool_Bezier(*args):
    """
    Contap_HCurve2dTool_Bezier(Handle_Adaptor2d_HCurve2d C) -> Handle_Geom2d_BezierCurve

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BezierCurve

    """
    return _Contap.Contap_HCurve2dTool_Bezier(*args)

def Contap_HCurve2dTool_BSpline(*args):
    """
    Contap_HCurve2dTool_BSpline(Handle_Adaptor2d_HCurve2d C) -> Handle_Geom2d_BSplineCurve

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

    """
    return _Contap.Contap_HCurve2dTool_BSpline(*args)

def Contap_HCurve2dTool_NbSamples(*args):
    """
    Contap_HCurve2dTool_NbSamples(Handle_Adaptor2d_HCurve2d C, Standard_Real const U0, Standard_Real const U1) -> Standard_Integer

    :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
    :type U0: float
    :type U1: float
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _Contap.Contap_HCurve2dTool_NbSamples(*args)

class NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self) -> NCollection_Sequence< opencascade::handle< Contap_TheIWLineOfTheIWalking > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self) -> NCollection_Sequence< opencascade::handle< Contap_TheIWLineOfTheIWalking > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self) -> NCollection_Sequence< opencascade::handle< Contap_TheIWLineOfTheIWalking > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self) -> NCollection_Sequence< opencascade::handle< Contap_TheIWLineOfTheIWalking > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Contap.new_NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self)

        Reverse sequence


        """
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self, NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking theOther) -> NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self, NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking theOther) -> NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self, NCollection_Sequence< opencascade::handle< Contap_TheIWLineOfTheIWalking > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self, Handle_Contap_TheIWLineOfTheIWalking theItem)
        Append(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self, NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self, Handle_Contap_TheIWLineOfTheIWalking theItem)
        Prepend(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self, NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self, Standard_Integer const theIndex, Handle_Contap_TheIWLineOfTheIWalking theItem)
        InsertBefore(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self, NCollection_Sequence< opencascade::handle< Contap_TheIWLineOfTheIWalking > >::Iterator & thePosition, Handle_Contap_TheIWLineOfTheIWalking theItem)
        InsertAfter(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking theSeq)
        InsertAfter(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self, Standard_Integer const theIndex, Handle_Contap_TheIWLineOfTheIWalking theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self) -> Handle_Contap_TheIWLineOfTheIWalking

        First item access

        :rtype: TheItemType &

        """
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self) -> Handle_Contap_TheIWLineOfTheIWalking

        Last item access

        :rtype: TheItemType &

        """
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self, Standard_Integer const theIndex) -> Handle_Contap_TheIWLineOfTheIWalking

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking self, Standard_Integer const theIndex, Handle_Contap_TheIWLineOfTheIWalking theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_SetValue(self, *args)


    def __iter__(self):
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking___iter__(self)
    __swig_destroy__ = _Contap.delete_NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking
NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_swigregister = _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_swigregister
NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_swigregister(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking)

def NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_delNode(*args):
    """
    NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_delNode(*args)

class NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Contap.new_NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Contap.delete_NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_IteratorHelper

    def __next__(self):
        return _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_IteratorHelper___next__(self)
NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_IteratorHelper_swigregister = _Contap.NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_IteratorHelper_swigregister
NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_IteratorHelper_swigregister(NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking_IteratorHelper)


try:
	Contap_SequenceOfIWLineOfTheIWalking = NCollection_Sequence_Handle_Contap_TheIWLineOfTheIWalking
except NameError:
	pass # does not exist, probably ignored

class Contap_ThePathPointOfTheSearch(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Contap_ThePathPointOfTheSearch self) -> Contap_ThePathPointOfTheSearch
        __init__(Contap_ThePathPointOfTheSearch self, gp_Pnt P, Standard_Real const Tol, Handle_Adaptor3d_HVertex V, Handle_Adaptor2d_HCurve2d A, Standard_Real const Parameter) -> Contap_ThePathPointOfTheSearch
        __init__(Contap_ThePathPointOfTheSearch self, gp_Pnt P, Standard_Real const Tol, Handle_Adaptor2d_HCurve2d A, Standard_Real const Parameter) -> Contap_ThePathPointOfTheSearch

        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Parameter: float

        """
        this = _Contap.new_Contap_ThePathPointOfTheSearch(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetValue(self, *args):
        """
        SetValue(Contap_ThePathPointOfTheSearch self, gp_Pnt P, Standard_Real const Tol, Handle_Adaptor3d_HVertex V, Handle_Adaptor2d_HCurve2d A, Standard_Real const Parameter)
        SetValue(Contap_ThePathPointOfTheSearch self, gp_Pnt P, Standard_Real const Tol, Handle_Adaptor2d_HCurve2d A, Standard_Real const Parameter)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :type A: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Parameter: float

        """
        return _Contap.Contap_ThePathPointOfTheSearch_SetValue(self, *args)


    def Value(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Contap.Contap_ThePathPointOfTheSearch_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tolerance(self, *args):
        """
        Tolerance(Contap_ThePathPointOfTheSearch self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Contap.Contap_ThePathPointOfTheSearch_Tolerance(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Contap_ThePathPointOfTheSearch self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_ThePathPointOfTheSearch_IsNew(self, *args)


    def Vertex(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HVertex

        """
        res = _Contap.Contap_ThePathPointOfTheSearch_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Arc(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        res = _Contap.Contap_ThePathPointOfTheSearch_Arc(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Parameter(self, *args):
        """
        Parameter(Contap_ThePathPointOfTheSearch self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Contap.Contap_ThePathPointOfTheSearch_Parameter(self, *args)

    __swig_destroy__ = _Contap.delete_Contap_ThePathPointOfTheSearch
Contap_ThePathPointOfTheSearch_swigregister = _Contap.Contap_ThePathPointOfTheSearch_swigregister
Contap_ThePathPointOfTheSearch_swigregister(Contap_ThePathPointOfTheSearch)

class Contap_TheIWalking(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Contap_TheIWalking self, Standard_Real const Epsilon, Standard_Real const Deflection, Standard_Real const Step, Standard_Boolean const theToFillHoles) -> Contap_TheIWalking

        Deflection is the maximum deflection admitted between two
        consecutive points on a resulting polyline.
        Step is the maximum increment admitted between two
        consecutive points (in 2d space).
        Epsilon is the tolerance beyond which 2 points
        are confused.
        theToFillHoles is the flag defining whether possible holes
        between resulting curves are filled or not
        in case of Contap walking theToFillHoles is True

        :type Epsilon: float
        :type Deflection: float
        :type Step: float
        :type theToFillHoles: bool

        """
        this = _Contap.new_Contap_TheIWalking(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetTolerance(self, *args):
        """
        SetTolerance(Contap_TheIWalking self, Standard_Real const Epsilon, Standard_Real const Deflection, Standard_Real const Step)

        Deflection is the maximum deflection admitted between two
        consecutive points on a resulting polyline.
        Step is the maximum increment admitted between two
        consecutive points (in 2d space).
        Epsilon is the tolerance beyond which 2 points
        are confused

        :type Epsilon: float
        :type Deflection: float
        :type Step: float

        """
        return _Contap.Contap_TheIWalking_SetTolerance(self, *args)


    def Perform(self, *args):
        """
        Perform(Contap_TheIWalking self, NCollection_Sequence_IntSurf_PathPoint Pnts1, NCollection_Sequence_IntSurf_InteriorPoint Pnts2, Contap_SurfFunction Func, Handle_Adaptor3d_HSurface S, Standard_Boolean const Reversed)
        Perform(Contap_TheIWalking self, NCollection_Sequence_IntSurf_PathPoint Pnts1, Contap_SurfFunction Func, Handle_Adaptor3d_HSurface S, Standard_Boolean const Reversed)

        Searches a set of polylines starting on a point of Pnts1.
        Each point on a resulting polyline verifies F(u,v)=0

        :type Pnts1: OCC.wrapper.IntSurf.IntSurf_SequenceOfPathPoint
        :type Func: OCC.wrapper.Contap.Contap_SurfFunction
        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Reversed: bool

        """
        return _Contap.Contap_TheIWalking_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Contap_TheIWalking self) -> Standard_Boolean

        Returns true if the calculus was successful.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.Contap_TheIWalking_IsDone(self, *args)


    def NbLines(self, *args):
        """
        NbLines(Contap_TheIWalking self) -> Standard_Integer

        Returns the number of resulting polylines.
        An exception is raised if IsDone returns False.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Contap_TheIWalking_NbLines(self, *args)


    def Value(self, *args):
        """
        Returns the polyline of range Index.
        An exception is raised if IsDone is False.
        An exception is raised if Index<=0 or Index>NbLines.

        :type Index: int
        :rtype: OCC.wrapper.Contap.Handle_Contap_TheIWLineOfTheIWalking

        """
        res = _Contap.Contap_TheIWalking_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbSinglePnts(self, *args):
        """
        NbSinglePnts(Contap_TheIWalking self) -> Standard_Integer

        Returns the number of points belonging to Pnts on which no
        line starts or ends.
        An exception is raised if IsDone returns False.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.Contap_TheIWalking_NbSinglePnts(self, *args)


    def SinglePnt(self, *args):
        """
        Returns the point of range Index .
        An exception is raised if IsDone returns False.
        An exception is raised if Index<=0 or
        Index > NbSinglePnts.

        :type Index: int
        :rtype: OCC.wrapper.IntSurf.IntSurf_PathPoint

        """
        res = _Contap.Contap_TheIWalking_SinglePnt(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Contap.delete_Contap_TheIWalking
Contap_TheIWalking_swigregister = _Contap.Contap_TheIWalking_swigregister
Contap_TheIWalking_swigregister(Contap_TheIWalking)

class NCollection_Sequence_Contap_ThePathPointOfTheSearch(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Contap_ThePathPointOfTheSearch self) -> NCollection_Sequence< Contap_ThePathPointOfTheSearch >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Contap_ThePathPointOfTheSearch self) -> NCollection_Sequence< Contap_ThePathPointOfTheSearch >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Contap_ThePathPointOfTheSearch self) -> NCollection_Sequence< Contap_ThePathPointOfTheSearch >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Contap_ThePathPointOfTheSearch self) -> NCollection_Sequence< Contap_ThePathPointOfTheSearch >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Contap.new_NCollection_Sequence_Contap_ThePathPointOfTheSearch(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Contap_ThePathPointOfTheSearch self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Contap_ThePathPointOfTheSearch self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Contap_ThePathPointOfTheSearch self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Contap_ThePathPointOfTheSearch self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Contap_ThePathPointOfTheSearch self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Contap_ThePathPointOfTheSearch self)

        Reverse sequence


        """
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Contap_ThePathPointOfTheSearch self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Contap_ThePathPointOfTheSearch self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Contap_ThePathPointOfTheSearch self, NCollection_Sequence_Contap_ThePathPointOfTheSearch theOther) -> NCollection_Sequence_Contap_ThePathPointOfTheSearch

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Contap_ThePathPointOfTheSearch self, NCollection_Sequence_Contap_ThePathPointOfTheSearch theOther) -> NCollection_Sequence_Contap_ThePathPointOfTheSearch

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Contap_ThePathPointOfTheSearch self, NCollection_Sequence< Contap_ThePathPointOfTheSearch >::Iterator & thePosition)
        Remove(NCollection_Sequence_Contap_ThePathPointOfTheSearch self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Contap_ThePathPointOfTheSearch self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Contap_ThePathPointOfTheSearch self, Contap_ThePathPointOfTheSearch theItem)
        Append(NCollection_Sequence_Contap_ThePathPointOfTheSearch self, NCollection_Sequence_Contap_ThePathPointOfTheSearch theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Contap_ThePathPointOfTheSearch self, Contap_ThePathPointOfTheSearch theItem)
        Prepend(NCollection_Sequence_Contap_ThePathPointOfTheSearch self, NCollection_Sequence_Contap_ThePathPointOfTheSearch theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Contap_ThePathPointOfTheSearch self, Standard_Integer const theIndex, Contap_ThePathPointOfTheSearch theItem)
        InsertBefore(NCollection_Sequence_Contap_ThePathPointOfTheSearch self, Standard_Integer const theIndex, NCollection_Sequence_Contap_ThePathPointOfTheSearch theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Contap_ThePathPointOfTheSearch self, NCollection_Sequence< Contap_ThePathPointOfTheSearch >::Iterator & thePosition, Contap_ThePathPointOfTheSearch theItem)
        InsertAfter(NCollection_Sequence_Contap_ThePathPointOfTheSearch self, Standard_Integer const theIndex, NCollection_Sequence_Contap_ThePathPointOfTheSearch theSeq)
        InsertAfter(NCollection_Sequence_Contap_ThePathPointOfTheSearch self, Standard_Integer const theIndex, Contap_ThePathPointOfTheSearch theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Contap_ThePathPointOfTheSearch self, Standard_Integer const theIndex, NCollection_Sequence_Contap_ThePathPointOfTheSearch theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Contap_ThePathPointOfTheSearch self) -> Contap_ThePathPointOfTheSearch

        First item access

        :rtype: TheItemType &

        """
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Contap_ThePathPointOfTheSearch self) -> Contap_ThePathPointOfTheSearch

        Last item access

        :rtype: TheItemType &

        """
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Contap_ThePathPointOfTheSearch self, Standard_Integer const theIndex) -> Contap_ThePathPointOfTheSearch

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Contap_ThePathPointOfTheSearch self, Standard_Integer const theIndex, Contap_ThePathPointOfTheSearch theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_SetValue(self, *args)


    def __iter__(self):
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch___iter__(self)
    __swig_destroy__ = _Contap.delete_NCollection_Sequence_Contap_ThePathPointOfTheSearch
NCollection_Sequence_Contap_ThePathPointOfTheSearch_swigregister = _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_swigregister
NCollection_Sequence_Contap_ThePathPointOfTheSearch_swigregister(NCollection_Sequence_Contap_ThePathPointOfTheSearch)

def NCollection_Sequence_Contap_ThePathPointOfTheSearch_delNode(*args):
    """
    NCollection_Sequence_Contap_ThePathPointOfTheSearch_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_delNode(*args)

class NCollection_Sequence_Contap_ThePathPointOfTheSearch_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Contap.new_NCollection_Sequence_Contap_ThePathPointOfTheSearch_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Contap.delete_NCollection_Sequence_Contap_ThePathPointOfTheSearch_IteratorHelper

    def __next__(self):
        return _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_IteratorHelper___next__(self)
NCollection_Sequence_Contap_ThePathPointOfTheSearch_IteratorHelper_swigregister = _Contap.NCollection_Sequence_Contap_ThePathPointOfTheSearch_IteratorHelper_swigregister
NCollection_Sequence_Contap_ThePathPointOfTheSearch_IteratorHelper_swigregister(NCollection_Sequence_Contap_ThePathPointOfTheSearch_IteratorHelper)


try:
	Contap_SequenceOfPathPointOfTheSearch = NCollection_Sequence_Contap_ThePathPointOfTheSearch
except NameError:
	pass # does not exist, probably ignored




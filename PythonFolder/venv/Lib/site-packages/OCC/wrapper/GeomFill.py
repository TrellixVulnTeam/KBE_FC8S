# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_GeomFill')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_GeomFill')
    _GeomFill = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_GeomFill', [dirname(__file__)])
        except ImportError:
            import _GeomFill
            return _GeomFill
        try:
            _mod = imp.load_module('_GeomFill', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _GeomFill = swig_import_helper()
    del swig_import_helper
else:
    import _GeomFill
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _GeomFill.delete_SwigPyIterator

    def value(self):
        return _GeomFill.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _GeomFill.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _GeomFill.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _GeomFill.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _GeomFill.SwigPyIterator_equal(self, x)

    def copy(self):
        return _GeomFill.SwigPyIterator_copy(self)

    def next(self):
        return _GeomFill.SwigPyIterator_next(self)

    def __next__(self):
        return _GeomFill.SwigPyIterator___next__(self)

    def previous(self):
        return _GeomFill.SwigPyIterator_previous(self)

    def advance(self, n):
        return _GeomFill.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _GeomFill.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _GeomFill.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _GeomFill.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _GeomFill.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _GeomFill.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _GeomFill.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _GeomFill.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _GeomFill.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_GeomFill.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _GeomFill.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _GeomFill.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GeomFill.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _GeomFill.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _GeomFill.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _GeomFill.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _GeomFill.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_GeomFill.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _GeomFill.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _GeomFill.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GeomFill.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _GeomFill.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _GeomFill.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _GeomFill.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _GeomFill.ptr_to_number(item)
ptr_to_number = _GeomFill.ptr_to_number

def HashCode(*args):
    return _GeomFill.HashCode(*args)
HashCode = _GeomFill.HashCode

def ptr_equal(a, b):
    return _GeomFill.ptr_equal(a, b)
ptr_equal = _GeomFill.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Convert
else:
    import Convert
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Approx
else:
    import Approx
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppCont
else:
    import AppCont
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppParCurves
else:
    import AppParCurves
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AdvApprox
else:
    import AdvApprox
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PLib
else:
    import PLib
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppBlend
else:
    import AppBlend
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColGeom
else:
    import TColGeom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Law
else:
    import Law
del _swig_python_version_info
GeomFill_Section = _GeomFill.GeomFill_Section
GeomFill_Location = _GeomFill.GeomFill_Location
GeomFill_PipeOk = _GeomFill.GeomFill_PipeOk
GeomFill_PipeNotOk = _GeomFill.GeomFill_PipeNotOk
GeomFill_PlaneNotIntersectGuide = _GeomFill.GeomFill_PlaneNotIntersectGuide
GeomFill_ImpossibleContact = _GeomFill.GeomFill_ImpossibleContact
GeomFill_StretchStyle = _GeomFill.GeomFill_StretchStyle
GeomFill_CoonsStyle = _GeomFill.GeomFill_CoonsStyle
GeomFill_CurvedStyle = _GeomFill.GeomFill_CurvedStyle
GeomFill_IsCorrectedFrenet = _GeomFill.GeomFill_IsCorrectedFrenet
GeomFill_IsFixed = _GeomFill.GeomFill_IsFixed
GeomFill_IsFrenet = _GeomFill.GeomFill_IsFrenet
GeomFill_IsConstantNormal = _GeomFill.GeomFill_IsConstantNormal
GeomFill_IsDarboux = _GeomFill.GeomFill_IsDarboux
GeomFill_IsGuideAC = _GeomFill.GeomFill_IsGuideAC
GeomFill_IsGuidePlan = _GeomFill.GeomFill_IsGuidePlan
GeomFill_IsGuideACWithContact = _GeomFill.GeomFill_IsGuideACWithContact
GeomFill_IsGuidePlanWithContact = _GeomFill.GeomFill_IsGuidePlanWithContact
GeomFill_IsDiscreteTrihedron = _GeomFill.GeomFill_IsDiscreteTrihedron
class GeomFill_TgtField(Standard.Standard_Transient):
    """
    Root class defining the methods we need to make an
    algorithmic tangents field.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_TgtField
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_TgtField(self) 
            return h


    def IsScalable(self, *args):
        """
        IsScalable(GeomFill_TgtField self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_TgtField_IsScalable(self, *args)


    def Scale(self, *args):
        """
        Scale(GeomFill_TgtField self, Handle_Law_BSpline Func)

        :type Func: OCC.wrapper.Law.Handle_Law_BSpline

        """
        return _GeomFill.GeomFill_TgtField_Scale(self, *args)


    def Value(self, *args):
        """
        Value(GeomFill_TgtField self, Standard_Real const W) -> gp_Vec

        Computes  the value  of the    field of tangency    at
        parameter W.

        :type W: float
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_TgtField_Value(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_TgtField self, Standard_Real const W) -> gp_Vec
        D1(GeomFill_TgtField self, Standard_Real const W, gp_Vec V, gp_Vec DV)

        Computes the value and the  derivative of the field of
        tangency at parameter W.

        :type W: float
        :type V: OCC.wrapper.gp.gp_Vec
        :type DV: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_TgtField_D1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_TgtField_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_TgtField_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_TgtField_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_TgtField
GeomFill_TgtField_swigregister = _GeomFill.GeomFill_TgtField_swigregister
GeomFill_TgtField_swigregister(GeomFill_TgtField)

def GeomFill_TgtField_get_type_name(*args):
    """
    GeomFill_TgtField_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_TgtField_get_type_name(*args)

def GeomFill_TgtField_get_type_descriptor(*args):
    """
    GeomFill_TgtField_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_TgtField_get_type_descriptor(*args)

class GeomFill_SectionLaw(Standard.Standard_Transient):
    """To define section law in  sweeping"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_SectionLaw
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_SectionLaw(self) 
            return h


    def D0(self, *args):
        """
        D0(GeomFill_SectionLaw self, Standard_Real const Param, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weigths) -> Standard_Boolean

        compute the section for v = param

        :type Param: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_SectionLaw_D0(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_SectionLaw self, Standard_Real const Param, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean

        compute the first  derivative in v direction  of the
        section for v =  param
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_SectionLaw_D1(self, *args)


    def D2(self, *args):
        """
        D2(GeomFill_SectionLaw self, Standard_Real const Param, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        compute the second derivative  in v direction of the
        section  for v = param
        Warning : It used only for C2 aproximation

        :type Param: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_SectionLaw_D2(self, *args)


    def BSplineSurface(self, *args):
        """
        BSplineSurface(GeomFill_SectionLaw self) -> Handle_Geom_BSplineSurface

        give if possible an bspline Surface, like iso-v are the
        section.   If it is  not possible this  methode have to
        get an Null Surface. It is the default  implementation.

        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

        """
        return _GeomFill.GeomFill_SectionLaw_BSplineSurface(self, *args)


    def SectionShape(self, *args):
        """
        SectionShape(GeomFill_SectionLaw self)

        get the format of an  section

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int

        """
        return _GeomFill.GeomFill_SectionLaw_SectionShape(self, *args)


    def Knots(self, *args):
        """
        Knots(GeomFill_SectionLaw self, NCollection_Array1_Standard_Real TKnots)

        get the Knots of the section

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_SectionLaw_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(GeomFill_SectionLaw self, NCollection_Array1_Standard_Integer TMults)

        get the Multplicities of the section

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _GeomFill.GeomFill_SectionLaw_Mults(self, *args)


    def IsRational(self, *args):
        """
        IsRational(GeomFill_SectionLaw self) -> Standard_Boolean

        Returns if the sections are rationnal or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_SectionLaw_IsRational(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(GeomFill_SectionLaw self) -> Standard_Boolean

        Returns if the sections are periodic or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_SectionLaw_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(GeomFill_SectionLaw self) -> Standard_Boolean

        Returns if law is periodic or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_SectionLaw_IsVPeriodic(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(GeomFill_SectionLaw self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_SectionLaw_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(GeomFill_SectionLaw self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.GeomFill_SectionLaw_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(GeomFill_SectionLaw self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_SectionLaw_SetInterval(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(GeomFill_SectionLaw self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_SectionLaw_GetInterval(self, *args)


    def GetDomain(self, *args):
        """
        GetDomain(GeomFill_SectionLaw self)

        Gets the bounds of the function parametric domain.
        Warning: This domain it is  not modified by the
        SetValue method

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_SectionLaw_GetDomain(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(GeomFill_SectionLaw self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, NCollection_Array1_Standard_Real Tol3d)

        Returns the tolerances associated at each poles to
        reach  in approximation, to satisfy: BoundTol error
        at the   Boundary  AngleTol tangent error  at  the
        Boundary  (in radian)  SurfTol   error inside the
        surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_SectionLaw_GetTolerance(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(GeomFill_SectionLaw self, Standard_Real const Tol3d, Standard_Real const Tol2d)

        Is  usefull, if (me)  have to run  numerical
        algorithm  to perform D0,  D1 or D2
        The default implementation make nothing.

        :type Tol3d: float
        :type Tol2d: float

        """
        return _GeomFill.GeomFill_SectionLaw_SetTolerance(self, *args)


    def BarycentreOfSurf(self, *args):
        """
        BarycentreOfSurf(GeomFill_SectionLaw self) -> gp_Pnt

        Get the barycentre of Surface.
        An   very  poor estimation is sufficent.
        This information is usefull to perform well
        conditioned rational approximation.
        Warning: Used only if <me> IsRational

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.GeomFill_SectionLaw_BarycentreOfSurf(self, *args)


    def MaximalSection(self, *args):
        """
        MaximalSection(GeomFill_SectionLaw self) -> Standard_Real

        Returns the   length of the greater section. This
        information is usefull to G1's control.
        Warning: With an little value, approximation can be slower.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_SectionLaw_MaximalSection(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(GeomFill_SectionLaw self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        in all  sections.
        This information is  usefull to control error
        in rational approximation.
        Warning: Used only if <me> IsRational

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_SectionLaw_GetMinimalWeight(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(GeomFill_SectionLaw self) -> Standard_Boolean

        Say if all sections are equals

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_SectionLaw_IsConstant(self, *args)


    def ConstantSection(self, *args):
        """
        ConstantSection(GeomFill_SectionLaw self) -> Handle_Geom_Curve

        Return a  copy of the  constant Section,  if me
        IsConstant

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _GeomFill.GeomFill_SectionLaw_ConstantSection(self, *args)


    def IsConicalLaw(self, *args):
        """
        IsConicalLaw(GeomFill_SectionLaw self) -> Standard_Boolean

        Returns True if all section  are circle, with same
        plane,same center and  linear  radius  evolution
        Return False by Default.

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_SectionLaw_IsConicalLaw(self, *args)


    def CirclSection(self, *args):
        """
        CirclSection(GeomFill_SectionLaw self, Standard_Real const Param) -> Handle_Geom_Curve

        Return the circle section  at parameter <Param>, if
        <me> a  IsConicalLaw

        :type Param: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _GeomFill.GeomFill_SectionLaw_CirclSection(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_SectionLaw_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_SectionLaw_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_SectionLaw_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_SectionLaw
GeomFill_SectionLaw_swigregister = _GeomFill.GeomFill_SectionLaw_swigregister
GeomFill_SectionLaw_swigregister(GeomFill_SectionLaw)

def GeomFill_SectionLaw_get_type_name(*args):
    """
    GeomFill_SectionLaw_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_SectionLaw_get_type_name(*args)

def GeomFill_SectionLaw_get_type_descriptor(*args):
    """
    GeomFill_SectionLaw_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_SectionLaw_get_type_descriptor(*args)

class GeomFill_Boundary(Standard.Standard_Transient):
    """
    Root class to define a boundary  which will form part of a
    contour around a gap requiring filling.
    Any  new type  of  constrained boundary must inherit this class.
    The GeomFill package provides two classes to define constrained boundaries:
    -   GeomFill_SimpleBound to define an unattached boundary
    -   GeomFill_BoundWithSurf to define a boundary attached to a surface.
    These objects are used to define the boundaries for a
    GeomFill_ConstrainedFilling framework.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_Boundary
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_Boundary(self) 
            return h


    def Value(self, *args):
        """
        Value(GeomFill_Boundary self, Standard_Real const U) -> gp_Pnt

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.GeomFill_Boundary_Value(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_Boundary self, Standard_Real const U, gp_Pnt P, gp_Vec V)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_Boundary_D1(self, *args)


    def HasNormals(self, *args):
        """
        HasNormals(GeomFill_Boundary self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_Boundary_HasNormals(self, *args)


    def Norm(self, *args):
        """
        Norm(GeomFill_Boundary self, Standard_Real const U) -> gp_Vec

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_Boundary_Norm(self, *args)


    def D1Norm(self, *args):
        """
        D1Norm(GeomFill_Boundary self, Standard_Real const U, gp_Vec N, gp_Vec DN)

        :type U: float
        :type N: OCC.wrapper.gp.gp_Vec
        :type DN: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_Boundary_D1Norm(self, *args)


    def Reparametrize(self, *args):
        """
        Reparametrize(GeomFill_Boundary self, Standard_Real const First, Standard_Real const Last, Standard_Boolean const HasDF, Standard_Boolean const HasDL, Standard_Real const DF, Standard_Real const DL, Standard_Boolean const Rev)

        :type First: float
        :type Last: float
        :type HasDF: bool
        :type HasDL: bool
        :type DF: float
        :type DL: float
        :type Rev: bool

        """
        return _GeomFill.GeomFill_Boundary_Reparametrize(self, *args)


    def Points(self, *args):
        """
        Points(GeomFill_Boundary self, gp_Pnt PFirst, gp_Pnt PLast)

        :type PFirst: OCC.wrapper.gp.gp_Pnt
        :type PLast: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.GeomFill_Boundary_Points(self, *args)


    def Bounds(self, *args):
        """
        Bounds(GeomFill_Boundary self)

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_Boundary_Bounds(self, *args)


    def IsDegenerated(self, *args):
        """
        IsDegenerated(GeomFill_Boundary self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_Boundary_IsDegenerated(self, *args)


    def Tol3d(self, *args):
        """
        Tol3d(GeomFill_Boundary self) -> Standard_Real
        Tol3d(GeomFill_Boundary self, Standard_Real const Tol)

        :type Tol: float

        """
        return _GeomFill.GeomFill_Boundary_Tol3d(self, *args)


    def Tolang(self, *args):
        """
        Tolang(GeomFill_Boundary self) -> Standard_Real
        Tolang(GeomFill_Boundary self, Standard_Real const Tol)

        :type Tol: float

        """
        return _GeomFill.GeomFill_Boundary_Tolang(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_Boundary_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_Boundary_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_Boundary_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_Boundary
GeomFill_Boundary_swigregister = _GeomFill.GeomFill_Boundary_swigregister
GeomFill_Boundary_swigregister(GeomFill_Boundary)

def GeomFill_Boundary_get_type_name(*args):
    """
    GeomFill_Boundary_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_Boundary_get_type_name(*args)

def GeomFill_Boundary_get_type_descriptor(*args):
    """
    GeomFill_Boundary_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_Boundary_get_type_descriptor(*args)

class GeomFill_HArray1OfLocationLaw(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_HArray1OfLocationLaw
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_HArray1OfLocationLaw(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GeomFill_HArray1OfLocationLaw self, Standard_Integer const theLower, Standard_Integer const theUpper) -> GeomFill_HArray1OfLocationLaw
        __init__(GeomFill_HArray1OfLocationLaw self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_GeomFill_LocationLaw theValue) -> GeomFill_HArray1OfLocationLaw
        __init__(GeomFill_HArray1OfLocationLaw self, NCollection_Array1_Handle_GeomFill_LocationLaw theOther) -> GeomFill_HArray1OfLocationLaw

        :type theOther: OCC.wrapper.GeomFill.GeomFill_Array1OfLocationLaw

        """
        this = _GeomFill.new_GeomFill_HArray1OfLocationLaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.GeomFill.GeomFill_Array1OfLocationLaw

        """
        res = _GeomFill.GeomFill_HArray1OfLocationLaw_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(GeomFill_HArray1OfLocationLaw self) -> NCollection_Array1_Handle_GeomFill_LocationLaw

        :rtype: OCC.wrapper.GeomFill.GeomFill_Array1OfLocationLaw

        """
        return _GeomFill.GeomFill_HArray1OfLocationLaw_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_HArray1OfLocationLaw_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_HArray1OfLocationLaw_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_HArray1OfLocationLaw_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_HArray1OfLocationLaw
GeomFill_HArray1OfLocationLaw_swigregister = _GeomFill.GeomFill_HArray1OfLocationLaw_swigregister
GeomFill_HArray1OfLocationLaw_swigregister(GeomFill_HArray1OfLocationLaw)

def GeomFill_HArray1OfLocationLaw_get_type_name(*args):
    """
    GeomFill_HArray1OfLocationLaw_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_HArray1OfLocationLaw_get_type_name(*args)

def GeomFill_HArray1OfLocationLaw_get_type_descriptor(*args):
    """
    GeomFill_HArray1OfLocationLaw_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_HArray1OfLocationLaw_get_type_descriptor(*args)

class GeomFill_NSections(GeomFill_SectionLaw):
    """Define a Section Law by N Sections"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_NSections
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_NSections(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GeomFill_NSections self, NCollection_Sequence_Handle_Geom_Curve NC) -> GeomFill_NSections
        __init__(GeomFill_NSections self, NCollection_Sequence_Handle_Geom_Curve NC, NCollection_Sequence_Standard_Real NP) -> GeomFill_NSections
        __init__(GeomFill_NSections self, NCollection_Sequence_Handle_Geom_Curve NC, NCollection_Sequence_Standard_Real NP, Standard_Real const UF, Standard_Real const UL, Standard_Real const VF, Standard_Real const VL) -> GeomFill_NSections
        __init__(GeomFill_NSections self, NCollection_Sequence_Handle_Geom_Curve NC, NCollection_Sequence_gp_Trsf Trsfs, NCollection_Sequence_Standard_Real NP, Standard_Real const UF, Standard_Real const UL, Standard_Real const VF, Standard_Real const VL, Handle_Geom_BSplineSurface Surf) -> GeomFill_NSections

        Make a SectionLaw with N Curves and N associated parameters.
        UF and UL are the parametric bounds of the NSections
        VF and VL are the parametric bounds of the path
        UF and UL are the parametric bounds of the NSections
        Surf is a reference surface used by BRepFill_NSections

        :type NC: OCC.wrapper.TColGeom.TColGeom_SequenceOfCurve
        :type Trsfs: OCC.wrapper.GeomFill.GeomFill_SequenceOfTrsf
        :type NP: OCC.wrapper.TColStd.TColStd_SequenceOfReal
        :type UF: float
        :type UL: float
        :type VF: float
        :type VL: float
        :type Surf: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

        """
        this = _GeomFill.new_GeomFill_NSections(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def D0(self, *args):
        """
        D0(GeomFill_NSections self, Standard_Real const Param, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weigths) -> Standard_Boolean

        compute the section for v = param

        :type Param: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_NSections_D0(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_NSections self, Standard_Real const Param, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean

        compute the first  derivative in v direction  of the
        section for v =  param
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_NSections_D1(self, *args)


    def D2(self, *args):
        """
        D2(GeomFill_NSections self, Standard_Real const Param, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        compute the second derivative  in v direction of the
        section  for v = param
        Warning : It used only for C2 aproximation

        :type Param: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_NSections_D2(self, *args)


    def SetSurface(self, *args):
        """
        SetSurface(GeomFill_NSections self, Handle_Geom_BSplineSurface RefSurf)

        Sets the reference surface

        :type RefSurf: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

        """
        return _GeomFill.GeomFill_NSections_SetSurface(self, *args)


    def ComputeSurface(self, *args):
        """
        ComputeSurface(GeomFill_NSections self)

        Computes the surface


        """
        return _GeomFill.GeomFill_NSections_ComputeSurface(self, *args)


    def BSplineSurface(self, *args):
        """
        BSplineSurface(GeomFill_NSections self) -> Handle_Geom_BSplineSurface

        give if possible an bspline Surface, like iso-v are the
        section.  If it is  not possible  this methode have  to
        get an Null Surface.  Is it the default implementation.

        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

        """
        return _GeomFill.GeomFill_NSections_BSplineSurface(self, *args)


    def SectionShape(self, *args):
        """
        SectionShape(GeomFill_NSections self)

        get the format of an  section

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int

        """
        return _GeomFill.GeomFill_NSections_SectionShape(self, *args)


    def Knots(self, *args):
        """
        Knots(GeomFill_NSections self, NCollection_Array1_Standard_Real TKnots)

        get the Knots of the section

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_NSections_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(GeomFill_NSections self, NCollection_Array1_Standard_Integer TMults)

        get the Multplicities of the section

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _GeomFill.GeomFill_NSections_Mults(self, *args)


    def IsRational(self, *args):
        """
        IsRational(GeomFill_NSections self) -> Standard_Boolean

        Returns if the sections are rationnal or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_NSections_IsRational(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(GeomFill_NSections self) -> Standard_Boolean

        Returns if the sections are periodic or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_NSections_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(GeomFill_NSections self) -> Standard_Boolean

        Returns if the law  isperiodic or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_NSections_IsVPeriodic(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(GeomFill_NSections self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_NSections_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(GeomFill_NSections self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.GeomFill_NSections_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(GeomFill_NSections self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_NSections_SetInterval(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(GeomFill_NSections self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_NSections_GetInterval(self, *args)


    def GetDomain(self, *args):
        """
        GetDomain(GeomFill_NSections self)

        Gets the bounds of the function parametric domain.
        Warning: This domain it is  not modified by the
        SetValue method

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_NSections_GetDomain(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(GeomFill_NSections self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, NCollection_Array1_Standard_Real Tol3d)

        Returns the tolerances associated at each poles to
        reach  in approximation, to satisfy: BoundTol error
        at the   Boundary  AngleTol tangent error  at  the
        Boundary  (in radian)  SurfTol   error inside the
        surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_NSections_GetTolerance(self, *args)


    def BarycentreOfSurf(self, *args):
        """
        BarycentreOfSurf(GeomFill_NSections self) -> gp_Pnt

        Get the barycentre of Surface.
        An   very  poor estimation is sufficent.
        This information is usefull to perform well
        conditioned rational approximation.
        Warning: Used only if <me> IsRational

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.GeomFill_NSections_BarycentreOfSurf(self, *args)


    def MaximalSection(self, *args):
        """
        MaximalSection(GeomFill_NSections self) -> Standard_Real

        Returns the   length of the greater section. This
        information is usefull to G1's control.
        Warning: With an little value, approximation can be slower.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_NSections_MaximalSection(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(GeomFill_NSections self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        in all  sections.
        This information is  usefull to control error
        in rational approximation.
        Warning: Used only if <me> IsRational

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_NSections_GetMinimalWeight(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(GeomFill_NSections self) -> Standard_Boolean

        return True If the Law isConstant

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_NSections_IsConstant(self, *args)


    def ConstantSection(self, *args):
        """
        ConstantSection(GeomFill_NSections self) -> Handle_Geom_Curve

        Return the constant Section if <me>  IsConstant.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _GeomFill.GeomFill_NSections_ConstantSection(self, *args)


    def IsConicalLaw(self, *args):
        """
        IsConicalLaw(GeomFill_NSections self) -> Standard_Boolean

        Returns True if all section  are circle, with same
        plane,same center and  linear  radius  evolution
        Return False by Default.

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_NSections_IsConicalLaw(self, *args)


    def CirclSection(self, *args):
        """
        CirclSection(GeomFill_NSections self, Standard_Real const Param) -> Handle_Geom_Curve

        Return the circle section  at parameter <Param>, if
        <me> a  IsConicalLaw

        :type Param: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _GeomFill.GeomFill_NSections_CirclSection(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_NSections_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_NSections_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_NSections_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_NSections
GeomFill_NSections_swigregister = _GeomFill.GeomFill_NSections_swigregister
GeomFill_NSections_swigregister(GeomFill_NSections)

def GeomFill_NSections_get_type_name(*args):
    """
    GeomFill_NSections_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_NSections_get_type_name(*args)

def GeomFill_NSections_get_type_descriptor(*args):
    """
    GeomFill_NSections_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_NSections_get_type_descriptor(*args)

class GeomFill_TrihedronLaw(Standard.Standard_Transient):
    """To define Trihedron along one Curve"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_TrihedronLaw
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_TrihedronLaw(self) 
            return h


    def SetCurve(self, *args):
        """
        SetCurve(GeomFill_TrihedronLaw self, Handle_Adaptor3d_HCurve C)

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.GeomFill_TrihedronLaw_SetCurve(self, *args)


    def Copy(self, *args):
        """
        Copy(GeomFill_TrihedronLaw self) -> Handle_GeomFill_TrihedronLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_TrihedronLaw

        """
        return _GeomFill.GeomFill_TrihedronLaw_Copy(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(GeomFill_TrihedronLaw self) -> GeomFill_PipeError

        Give a status to the Law
        Returns PipeOk (default implementation)

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _GeomFill.GeomFill_TrihedronLaw_ErrorStatus(self, *args)


    def D0(self, *args):
        """
        D0(GeomFill_TrihedronLaw self, Standard_Real const Param, gp_Vec Tangent, gp_Vec Normal, gp_Vec BiNormal) -> Standard_Boolean

        compute Triedrhon on curve at parameter <Param>

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_TrihedronLaw_D0(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_TrihedronLaw self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec BiNormal, gp_Vec DBiNormal) -> Standard_Boolean

        compute Triedrhon and  derivative Trihedron  on curve
        at parameter <Param>
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_TrihedronLaw_D1(self, *args)


    def D2(self, *args):
        """
        D2(GeomFill_TrihedronLaw self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec D2Tangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec D2Normal, gp_Vec BiNormal, gp_Vec DBiNormal, gp_Vec D2BiNormal) -> Standard_Boolean

        compute  Trihedron on curve
        first and seconde  derivatives.
        Warning : It used only for C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type D2Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type D2Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :type D2BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_TrihedronLaw_D2(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(GeomFill_TrihedronLaw self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_TrihedronLaw_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(GeomFill_TrihedronLaw self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.GeomFill_TrihedronLaw_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(GeomFill_TrihedronLaw self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_TrihedronLaw_SetInterval(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(GeomFill_TrihedronLaw self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_TrihedronLaw_GetInterval(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(GeomFill_TrihedronLaw self, gp_Vec ATangent, gp_Vec ANormal, gp_Vec ABiNormal)

        Get average value of M(t) and V(t) it is usfull to
        make fast approximation of rational  surfaces.

        :type ATangent: OCC.wrapper.gp.gp_Vec
        :type ANormal: OCC.wrapper.gp.gp_Vec
        :type ABiNormal: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_TrihedronLaw_GetAverageLaw(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(GeomFill_TrihedronLaw self) -> Standard_Boolean

        Say if the law is Constant

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_TrihedronLaw_IsConstant(self, *args)


    def IsOnlyBy3dCurve(self, *args):
        """
        IsOnlyBy3dCurve(GeomFill_TrihedronLaw self) -> Standard_Boolean

        Say if the law is defined, only by the 3d Geometry of
        the setted Curve
        Return False by Default.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_TrihedronLaw_IsOnlyBy3dCurve(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_TrihedronLaw_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_TrihedronLaw_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_TrihedronLaw_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_TrihedronLaw
GeomFill_TrihedronLaw_swigregister = _GeomFill.GeomFill_TrihedronLaw_swigregister
GeomFill_TrihedronLaw_swigregister(GeomFill_TrihedronLaw)

def GeomFill_TrihedronLaw_get_type_name(*args):
    """
    GeomFill_TrihedronLaw_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_TrihedronLaw_get_type_name(*args)

def GeomFill_TrihedronLaw_get_type_descriptor(*args):
    """
    GeomFill_TrihedronLaw_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_TrihedronLaw_get_type_descriptor(*args)

class GeomFill_DiscreteTrihedron(GeomFill_TrihedronLaw):
    """
    Defined Discrete Trihedron Law.
    The requirement for path curve is only G1.
    The result is C0-continuous surface
    that can be later approximated to C1.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_DiscreteTrihedron
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_DiscreteTrihedron(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GeomFill_DiscreteTrihedron self) -> GeomFill_DiscreteTrihedron

        Defined Discrete Trihedron Law.
        The requirement for path curve is only G1.
        The result is C0-continuous surface
        that can be later approximated to C1.
        """
        this = _GeomFill.new_GeomFill_DiscreteTrihedron(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Copy(self, *args):
        """
        Copy(GeomFill_DiscreteTrihedron self) -> Handle_GeomFill_TrihedronLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_TrihedronLaw

        """
        return _GeomFill.GeomFill_DiscreteTrihedron_Copy(self, *args)


    def Init(self, *args):
        """Init(GeomFill_DiscreteTrihedron self)"""
        return _GeomFill.GeomFill_DiscreteTrihedron_Init(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(GeomFill_DiscreteTrihedron self, Handle_Adaptor3d_HCurve C)

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.GeomFill_DiscreteTrihedron_SetCurve(self, *args)


    def D0(self, *args):
        """
        D0(GeomFill_DiscreteTrihedron self, Standard_Real const Param, gp_Vec Tangent, gp_Vec Normal, gp_Vec BiNormal) -> Standard_Boolean

        compute Trihedron on curve at parameter <Param>

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_DiscreteTrihedron_D0(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_DiscreteTrihedron self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec BiNormal, gp_Vec DBiNormal) -> Standard_Boolean

        compute Trihedron and  derivative Trihedron  on curve
        at parameter <Param>
        Warning : It used only for C1 or C2 aproximation
        For the moment it returns null values for DTangent, DNormal
        and DBiNormal.

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_DiscreteTrihedron_D1(self, *args)


    def D2(self, *args):
        """
        D2(GeomFill_DiscreteTrihedron self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec D2Tangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec D2Normal, gp_Vec BiNormal, gp_Vec DBiNormal, gp_Vec D2BiNormal) -> Standard_Boolean

        compute  Trihedron on curve
        first and seconde  derivatives.
        Warning : It used only for C2 aproximation
        For the moment it returns null values for DTangent, DNormal
        DBiNormal, D2Tangent, D2Normal, D2BiNormal.

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type D2Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type D2Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :type D2BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_DiscreteTrihedron_D2(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(GeomFill_DiscreteTrihedron self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_DiscreteTrihedron_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(GeomFill_DiscreteTrihedron self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.GeomFill_DiscreteTrihedron_Intervals(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(GeomFill_DiscreteTrihedron self, gp_Vec ATangent, gp_Vec ANormal, gp_Vec ABiNormal)

        Get average value of Tangent(t) and Normal(t) it is usful to
        make fast approximation of rational  surfaces.

        :type ATangent: OCC.wrapper.gp.gp_Vec
        :type ANormal: OCC.wrapper.gp.gp_Vec
        :type ABiNormal: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_DiscreteTrihedron_GetAverageLaw(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(GeomFill_DiscreteTrihedron self) -> Standard_Boolean

        Say if the law is Constant.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_DiscreteTrihedron_IsConstant(self, *args)


    def IsOnlyBy3dCurve(self, *args):
        """
        IsOnlyBy3dCurve(GeomFill_DiscreteTrihedron self) -> Standard_Boolean

        Return True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_DiscreteTrihedron_IsOnlyBy3dCurve(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_DiscreteTrihedron_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_DiscreteTrihedron_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_DiscreteTrihedron_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_DiscreteTrihedron
GeomFill_DiscreteTrihedron_swigregister = _GeomFill.GeomFill_DiscreteTrihedron_swigregister
GeomFill_DiscreteTrihedron_swigregister(GeomFill_DiscreteTrihedron)

def GeomFill_DiscreteTrihedron_get_type_name(*args):
    """
    GeomFill_DiscreteTrihedron_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_DiscreteTrihedron_get_type_name(*args)

def GeomFill_DiscreteTrihedron_get_type_descriptor(*args):
    """
    GeomFill_DiscreteTrihedron_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_DiscreteTrihedron_get_type_descriptor(*args)

class GeomFill_Profiler(object):
    """
    Evaluation of the common BSplineProfile of a group
    of curves  from Geom. All the curves will have the
    same  degree,  the same knot-vector, so  the  same
    number of poles.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomFill_Profiler self) -> GeomFill_Profiler

        Evaluation of the common BSplineProfile of a group
        of curves  from Geom. All the curves will have the
        same  degree,  the same knot-vector, so  the  same
        number of poles.
        """
        this = _GeomFill.new_GeomFill_Profiler(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddCurve(self, *args):
        """
        AddCurve(GeomFill_Profiler self, Handle_Geom_Curve Curve)

        :type Curve: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _GeomFill.GeomFill_Profiler_AddCurve(self, *args)


    def Perform(self, *args):
        """
        Perform(GeomFill_Profiler self, Standard_Real const PTol)

        Converts all curves to BSplineCurves.
        Set them to the common profile.
        <PTol> is used to compare 2 knots.

        :type PTol: float

        """
        return _GeomFill.GeomFill_Profiler_Perform(self, *args)


    def Degree(self, *args):
        """
        Degree(GeomFill_Profiler self) -> Standard_Integer

        Raises if not yet perform

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_Profiler_Degree(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(GeomFill_Profiler self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_Profiler_IsPeriodic(self, *args)


    def NbPoles(self, *args):
        """
        NbPoles(GeomFill_Profiler self) -> Standard_Integer

        Raises if not yet perform

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_Profiler_NbPoles(self, *args)


    def Poles(self, *args):
        """
        Poles(GeomFill_Profiler self, Standard_Integer const Index, NCollection_Array1_gp_Pnt Poles)

        returns in <Poles> the  poles  of the BSplineCurve
        from index <Index> adjusting to the current profile.
        Raises if not yet perform
        Raises if <Index> not in the range [1,NbCurves]
        if  the  length  of  <Poles>  is  not  equal  to
        NbPoles().

        :type Index: int
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt

        """
        return _GeomFill.GeomFill_Profiler_Poles(self, *args)


    def Weights(self, *args):
        """
        Weights(GeomFill_Profiler self, Standard_Integer const Index, NCollection_Array1_Standard_Real Weights)

        returns in <Weights> the weights of the BSplineCurve
        from index <Index> adjusting to the current profile.
        Raises if not yet perform
        Raises if <Index> not in the range [1,NbCurves] or
        if  the  length  of  <Weights>  is  not  equal  to
        NbPoles().

        :type Index: int
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_Profiler_Weights(self, *args)


    def NbKnots(self, *args):
        """
        NbKnots(GeomFill_Profiler self) -> Standard_Integer

        Raises if not yet perform

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_Profiler_NbKnots(self, *args)


    def KnotsAndMults(self, *args):
        """
        KnotsAndMults(GeomFill_Profiler self, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults)

        Raises if not yet perform
        Raises if  the lengthes of <Knots> and <Mults> are
        not equal to NbKnots().

        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _GeomFill.GeomFill_Profiler_KnotsAndMults(self, *args)


    def Curve(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _GeomFill.GeomFill_Profiler_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_Profiler
GeomFill_Profiler_swigregister = _GeomFill.GeomFill_Profiler_swigregister
GeomFill_Profiler_swigregister(GeomFill_Profiler)

class GeomFill_TgtOnCoons(GeomFill_TgtField):
    """
    Defines   an   algorithmic  tangents  field   on a
    boundary of a CoonsAlgPatch.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_TgtOnCoons
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_TgtOnCoons(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GeomFill_TgtOnCoons self, Handle_GeomFill_CoonsAlgPatch K, Standard_Integer const I) -> GeomFill_TgtOnCoons

        :type K: OCC.wrapper.GeomFill.Handle_GeomFill_CoonsAlgPatch
        :type I: int

        """
        this = _GeomFill.new_GeomFill_TgtOnCoons(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Value(self, *args):
        """
        Value(GeomFill_TgtOnCoons self, Standard_Real const W) -> gp_Vec

        Computes  the value  of the    field of tangency    at
        parameter W.

        :type W: float
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_TgtOnCoons_Value(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_TgtOnCoons self, Standard_Real const W) -> gp_Vec
        D1(GeomFill_TgtOnCoons self, Standard_Real const W, gp_Vec T, gp_Vec DT)

        Computes the value and the  derivative of the field of
        tangency at parameter W.

        :type W: float
        :type T: OCC.wrapper.gp.gp_Vec
        :type DT: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_TgtOnCoons_D1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_TgtOnCoons_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_TgtOnCoons_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_TgtOnCoons_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_TgtOnCoons
GeomFill_TgtOnCoons_swigregister = _GeomFill.GeomFill_TgtOnCoons_swigregister
GeomFill_TgtOnCoons_swigregister(GeomFill_TgtOnCoons)

def GeomFill_TgtOnCoons_get_type_name(*args):
    """
    GeomFill_TgtOnCoons_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_TgtOnCoons_get_type_name(*args)

def GeomFill_TgtOnCoons_get_type_descriptor(*args):
    """
    GeomFill_TgtOnCoons_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_TgtOnCoons_get_type_descriptor(*args)

class GeomFill_Frenet(GeomFill_TrihedronLaw):
    """Defined Frenet Trihedron  Law"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_Frenet
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_Frenet(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GeomFill_Frenet self) -> GeomFill_Frenet

        Defined Frenet Trihedron  Law
        """
        this = _GeomFill.new_GeomFill_Frenet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Copy(self, *args):
        """
        Copy(GeomFill_Frenet self) -> Handle_GeomFill_TrihedronLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_TrihedronLaw

        """
        return _GeomFill.GeomFill_Frenet_Copy(self, *args)


    def Init(self, *args):
        """Init(GeomFill_Frenet self)"""
        return _GeomFill.GeomFill_Frenet_Init(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(GeomFill_Frenet self, Handle_Adaptor3d_HCurve C)

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.GeomFill_Frenet_SetCurve(self, *args)


    def D0(self, *args):
        """
        D0(GeomFill_Frenet self, Standard_Real const Param, gp_Vec Tangent, gp_Vec Normal, gp_Vec BiNormal) -> Standard_Boolean

        compute Triedrhon on curve at parameter <Param>

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_Frenet_D0(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_Frenet self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec BiNormal, gp_Vec DBiNormal) -> Standard_Boolean

        compute Triedrhon and  derivative Trihedron  on curve
        at parameter <Param>
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_Frenet_D1(self, *args)


    def D2(self, *args):
        """
        D2(GeomFill_Frenet self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec D2Tangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec D2Normal, gp_Vec BiNormal, gp_Vec DBiNormal, gp_Vec D2BiNormal) -> Standard_Boolean

        compute  Trihedron on curve
        first and seconde  derivatives.
        Warning : It used only for C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type D2Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type D2Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :type D2BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_Frenet_D2(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(GeomFill_Frenet self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_Frenet_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(GeomFill_Frenet self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.GeomFill_Frenet_Intervals(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(GeomFill_Frenet self, gp_Vec ATangent, gp_Vec ANormal, gp_Vec ABiNormal)

        Get average value of Tangent(t) and Normal(t) it is usfull to
        make fast approximation of rational  surfaces.

        :type ATangent: OCC.wrapper.gp.gp_Vec
        :type ANormal: OCC.wrapper.gp.gp_Vec
        :type ABiNormal: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_Frenet_GetAverageLaw(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(GeomFill_Frenet self) -> Standard_Boolean

        Say if the law is Constant.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_Frenet_IsConstant(self, *args)


    def IsOnlyBy3dCurve(self, *args):
        """
        IsOnlyBy3dCurve(GeomFill_Frenet self) -> Standard_Boolean

        Return True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_Frenet_IsOnlyBy3dCurve(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_Frenet_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_Frenet_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_Frenet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_Frenet
GeomFill_Frenet_swigregister = _GeomFill.GeomFill_Frenet_swigregister
GeomFill_Frenet_swigregister(GeomFill_Frenet)

def GeomFill_Frenet_get_type_name(*args):
    """
    GeomFill_Frenet_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_Frenet_get_type_name(*args)

def GeomFill_Frenet_get_type_descriptor(*args):
    """
    GeomFill_Frenet_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_Frenet_get_type_descriptor(*args)

class GeomFill_CoonsAlgPatch(Standard.Standard_Transient):
    """
    Provides  evaluation   methods on an   algorithmic
    patch (based on 4 Curves) defined by  its   boundaries and  blending
    functions.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_CoonsAlgPatch
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_CoonsAlgPatch(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GeomFill_CoonsAlgPatch self, Handle_GeomFill_Boundary B1, Handle_GeomFill_Boundary B2, Handle_GeomFill_Boundary B3, Handle_GeomFill_Boundary B4) -> GeomFill_CoonsAlgPatch

        Constructs the  algorithmic   patch. By   Default  the
        constructed blending functions are linear.
        Warning: No control is done on the bounds.
        B1/B3 and B2/B4 must be same range and well oriented.

        :type B1: OCC.wrapper.GeomFill.Handle_GeomFill_Boundary
        :type B2: OCC.wrapper.GeomFill.Handle_GeomFill_Boundary
        :type B3: OCC.wrapper.GeomFill.Handle_GeomFill_Boundary
        :type B4: OCC.wrapper.GeomFill.Handle_GeomFill_Boundary

        """
        this = _GeomFill.new_GeomFill_CoonsAlgPatch(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetFunc(self, *args):
        """
        SetFunc(GeomFill_CoonsAlgPatch self, Handle_Law_Function f1, Handle_Law_Function f2)

        Set the blending functions.

        :type f1: OCC.wrapper.Law.Handle_Law_Function
        :type f2: OCC.wrapper.Law.Handle_Law_Function

        """
        return _GeomFill.GeomFill_CoonsAlgPatch_SetFunc(self, *args)


    def Value(self, *args):
        """
        Value(GeomFill_CoonsAlgPatch self, Standard_Real const U, Standard_Real const V) -> gp_Pnt

        Computes  the  value   on the  algorithmic    patch at
        parameters U and V.

        :type U: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.GeomFill_CoonsAlgPatch_Value(self, *args)


    def D1U(self, *args):
        """
        D1U(GeomFill_CoonsAlgPatch self, Standard_Real const U, Standard_Real const V) -> gp_Vec

        Computes   the  d/dU   partial   derivative  on    the
        algorithmic patch at parameters U and V.

        :type U: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_CoonsAlgPatch_D1U(self, *args)


    def D1V(self, *args):
        """
        D1V(GeomFill_CoonsAlgPatch self, Standard_Real const U, Standard_Real const V) -> gp_Vec

        Computes    the  d/dV    partial    derivative on  the
        algorithmic patch at parameters U and V.

        :type U: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_CoonsAlgPatch_D1V(self, *args)


    def DUV(self, *args):
        """
        DUV(GeomFill_CoonsAlgPatch self, Standard_Real const U, Standard_Real const V) -> gp_Vec

        Computes the   d2/dUdV  partial  derivative   on   the
        algorithmic  patch made with linear blending functions
        at parameter U and V.

        :type U: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_CoonsAlgPatch_DUV(self, *args)


    def Corner(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _GeomFill.GeomFill_CoonsAlgPatch_Corner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Bound(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_Boundary

        """
        res = _GeomFill.GeomFill_CoonsAlgPatch_Bound(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Func(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.Law.Handle_Law_Function

        """
        res = _GeomFill.GeomFill_CoonsAlgPatch_Func(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_CoonsAlgPatch_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_CoonsAlgPatch_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_CoonsAlgPatch_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_CoonsAlgPatch
GeomFill_CoonsAlgPatch_swigregister = _GeomFill.GeomFill_CoonsAlgPatch_swigregister
GeomFill_CoonsAlgPatch_swigregister(GeomFill_CoonsAlgPatch)

def GeomFill_CoonsAlgPatch_get_type_name(*args):
    """
    GeomFill_CoonsAlgPatch_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_CoonsAlgPatch_get_type_name(*args)

def GeomFill_CoonsAlgPatch_get_type_descriptor(*args):
    """
    GeomFill_CoonsAlgPatch_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_CoonsAlgPatch_get_type_descriptor(*args)

class GeomFill_Fixed(GeomFill_TrihedronLaw):
    """Defined an constant TrihedronLaw"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_Fixed
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_Fixed(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GeomFill_Fixed self, gp_Vec Tangent, gp_Vec Normal) -> GeomFill_Fixed

        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec

        """
        this = _GeomFill.new_GeomFill_Fixed(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Copy(self, *args):
        """
        Copy(GeomFill_Fixed self) -> Handle_GeomFill_TrihedronLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_TrihedronLaw

        """
        return _GeomFill.GeomFill_Fixed_Copy(self, *args)


    def D0(self, *args):
        """
        D0(GeomFill_Fixed self, Standard_Real const Param, gp_Vec Tangent, gp_Vec Normal, gp_Vec BiNormal) -> Standard_Boolean

        compute Triedrhon on curve at parameter <Param>

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_Fixed_D0(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_Fixed self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec BiNormal, gp_Vec DBiNormal) -> Standard_Boolean

        compute Triedrhon and  derivative Trihedron  on curve
        at parameter <Param>
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_Fixed_D1(self, *args)


    def D2(self, *args):
        """
        D2(GeomFill_Fixed self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec D2Tangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec D2Normal, gp_Vec BiNormal, gp_Vec DBiNormal, gp_Vec D2BiNormal) -> Standard_Boolean

        compute  Trihedron on curve
        first and seconde  derivatives.
        Warning : It used only for C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type D2Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type D2Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :type D2BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_Fixed_D2(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(GeomFill_Fixed self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_Fixed_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(GeomFill_Fixed self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.GeomFill_Fixed_Intervals(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(GeomFill_Fixed self, gp_Vec ATangent, gp_Vec ANormal, gp_Vec ABiNormal)

        Get average value of Tangent(t) and Normal(t) it is usfull to
        make fast approximation of rational  surfaces.

        :type ATangent: OCC.wrapper.gp.gp_Vec
        :type ANormal: OCC.wrapper.gp.gp_Vec
        :type ABiNormal: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_Fixed_GetAverageLaw(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(GeomFill_Fixed self) -> Standard_Boolean

        Return True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_Fixed_IsConstant(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_Fixed_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_Fixed_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_Fixed_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_Fixed
GeomFill_Fixed_swigregister = _GeomFill.GeomFill_Fixed_swigregister
GeomFill_Fixed_swigregister(GeomFill_Fixed)

def GeomFill_Fixed_get_type_name(*args):
    """
    GeomFill_Fixed_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_Fixed_get_type_name(*args)

def GeomFill_Fixed_get_type_descriptor(*args):
    """
    GeomFill_Fixed_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_Fixed_get_type_descriptor(*args)

class GeomFill_DraftTrihedron(GeomFill_TrihedronLaw):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_DraftTrihedron
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_DraftTrihedron(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GeomFill_DraftTrihedron self, gp_Vec BiNormal, Standard_Real const Angle) -> GeomFill_DraftTrihedron

        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type Angle: float

        """
        this = _GeomFill.new_GeomFill_DraftTrihedron(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetAngle(self, *args):
        """
        SetAngle(GeomFill_DraftTrihedron self, Standard_Real const Angle)

        :type Angle: float

        """
        return _GeomFill.GeomFill_DraftTrihedron_SetAngle(self, *args)


    def Copy(self, *args):
        """
        Copy(GeomFill_DraftTrihedron self) -> Handle_GeomFill_TrihedronLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_TrihedronLaw

        """
        return _GeomFill.GeomFill_DraftTrihedron_Copy(self, *args)


    def D0(self, *args):
        """
        D0(GeomFill_DraftTrihedron self, Standard_Real const Param, gp_Vec Tangent, gp_Vec Normal, gp_Vec BiNormal) -> Standard_Boolean

        compute Triedrhon and derivative Trihedron on curve at
        parameter <Param>
        Warning : It used  only for C1 or C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_DraftTrihedron_D0(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_DraftTrihedron self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec BiNormal, gp_Vec DBiNormal) -> Standard_Boolean

        compute Trihedron on curve
        first and seconde  derivatives.
        Warning : It used only for C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_DraftTrihedron_D1(self, *args)


    def D2(self, *args):
        """
        D2(GeomFill_DraftTrihedron self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec D2Tangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec D2Normal, gp_Vec BiNormal, gp_Vec DBiNormal, gp_Vec D2BiNormal) -> Standard_Boolean

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type D2Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type D2Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :type D2BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_DraftTrihedron_D2(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(GeomFill_DraftTrihedron self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_DraftTrihedron_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(GeomFill_DraftTrihedron self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.GeomFill_DraftTrihedron_Intervals(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(GeomFill_DraftTrihedron self, gp_Vec ATangent, gp_Vec ANormal, gp_Vec ABiNormal)

        Get average value of Tangent(t) and Normal(t) it is usefull to
        make fast approximation of rational  surfaces.

        :type ATangent: OCC.wrapper.gp.gp_Vec
        :type ANormal: OCC.wrapper.gp.gp_Vec
        :type ABiNormal: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_DraftTrihedron_GetAverageLaw(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(GeomFill_DraftTrihedron self) -> Standard_Boolean

        Say if the law is Constant.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_DraftTrihedron_IsConstant(self, *args)


    def IsOnlyBy3dCurve(self, *args):
        """
        IsOnlyBy3dCurve(GeomFill_DraftTrihedron self) -> Standard_Boolean

        Return True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_DraftTrihedron_IsOnlyBy3dCurve(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_DraftTrihedron_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_DraftTrihedron_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_DraftTrihedron_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_DraftTrihedron
GeomFill_DraftTrihedron_swigregister = _GeomFill.GeomFill_DraftTrihedron_swigregister
GeomFill_DraftTrihedron_swigregister(GeomFill_DraftTrihedron)

def GeomFill_DraftTrihedron_get_type_name(*args):
    """
    GeomFill_DraftTrihedron_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_DraftTrihedron_get_type_name(*args)

def GeomFill_DraftTrihedron_get_type_descriptor(*args):
    """
    GeomFill_DraftTrihedron_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_DraftTrihedron_get_type_descriptor(*args)

class GeomFill_HSequenceOfAx2(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_HSequenceOfAx2
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_HSequenceOfAx2(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GeomFill_HSequenceOfAx2 self) -> GeomFill_HSequenceOfAx2
        __init__(GeomFill_HSequenceOfAx2 self, NCollection_Sequence_gp_Ax2 theOther) -> GeomFill_HSequenceOfAx2

        :type theOther: OCC.wrapper.GeomFill.GeomFill_SequenceOfAx2

        """
        this = _GeomFill.new_GeomFill_HSequenceOfAx2(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.GeomFill.GeomFill_SequenceOfAx2

        """
        res = _GeomFill.GeomFill_HSequenceOfAx2_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(GeomFill_HSequenceOfAx2 self, gp_Ax2 theItem)
        Append(GeomFill_HSequenceOfAx2 self, NCollection_Sequence_gp_Ax2 theSequence)

        :type theSequence: OCC.wrapper.GeomFill.GeomFill_SequenceOfAx2

        """
        return _GeomFill.GeomFill_HSequenceOfAx2_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(GeomFill_HSequenceOfAx2 self) -> NCollection_Sequence_gp_Ax2

        :rtype: OCC.wrapper.GeomFill.GeomFill_SequenceOfAx2

        """
        return _GeomFill.GeomFill_HSequenceOfAx2_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_HSequenceOfAx2_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_HSequenceOfAx2_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_HSequenceOfAx2_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_HSequenceOfAx2
GeomFill_HSequenceOfAx2_swigregister = _GeomFill.GeomFill_HSequenceOfAx2_swigregister
GeomFill_HSequenceOfAx2_swigregister(GeomFill_HSequenceOfAx2)

def GeomFill_HSequenceOfAx2_get_type_name(*args):
    """
    GeomFill_HSequenceOfAx2_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_HSequenceOfAx2_get_type_name(*args)

def GeomFill_HSequenceOfAx2_get_type_descriptor(*args):
    """
    GeomFill_HSequenceOfAx2_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_HSequenceOfAx2_get_type_descriptor(*args)

class GeomFill_ConstantBiNormal(GeomFill_TrihedronLaw):
    """Defined an Trihedron Law  where the BiNormal, is fixed"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_ConstantBiNormal
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_ConstantBiNormal(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GeomFill_ConstantBiNormal self, gp_Dir BiNormal) -> GeomFill_ConstantBiNormal

        :type BiNormal: OCC.wrapper.gp.gp_Dir

        """
        this = _GeomFill.new_GeomFill_ConstantBiNormal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Copy(self, *args):
        """
        Copy(GeomFill_ConstantBiNormal self) -> Handle_GeomFill_TrihedronLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_TrihedronLaw

        """
        return _GeomFill.GeomFill_ConstantBiNormal_Copy(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(GeomFill_ConstantBiNormal self, Handle_Adaptor3d_HCurve C)

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.GeomFill_ConstantBiNormal_SetCurve(self, *args)


    def D0(self, *args):
        """
        D0(GeomFill_ConstantBiNormal self, Standard_Real const Param, gp_Vec Tangent, gp_Vec Normal, gp_Vec BiNormal) -> Standard_Boolean

        Computes Triedrhon on curve at parameter <Param>

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_ConstantBiNormal_D0(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_ConstantBiNormal self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec BiNormal, gp_Vec DBiNormal) -> Standard_Boolean

        Computes Triedrhon and  derivative Trihedron  on curve
        at parameter <Param>
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_ConstantBiNormal_D1(self, *args)


    def D2(self, *args):
        """
        D2(GeomFill_ConstantBiNormal self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec D2Tangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec D2Normal, gp_Vec BiNormal, gp_Vec DBiNormal, gp_Vec D2BiNormal) -> Standard_Boolean

        compute  Trihedron on curve
        first and seconde  derivatives.
        Warning : It used only for C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type D2Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type D2Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :type D2BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_ConstantBiNormal_D2(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(GeomFill_ConstantBiNormal self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_ConstantBiNormal_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(GeomFill_ConstantBiNormal self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.GeomFill_ConstantBiNormal_Intervals(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(GeomFill_ConstantBiNormal self, gp_Vec ATangent, gp_Vec ANormal, gp_Vec ABiNormal)

        Gets average value of Tangent(t) and Normal(t) it is usfull to
        make fast approximation of rational  surfaces.

        :type ATangent: OCC.wrapper.gp.gp_Vec
        :type ANormal: OCC.wrapper.gp.gp_Vec
        :type ABiNormal: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_ConstantBiNormal_GetAverageLaw(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(GeomFill_ConstantBiNormal self) -> Standard_Boolean

        Says if the law is Constant.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_ConstantBiNormal_IsConstant(self, *args)


    def IsOnlyBy3dCurve(self, *args):
        """
        IsOnlyBy3dCurve(GeomFill_ConstantBiNormal self) -> Standard_Boolean

        Return True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_ConstantBiNormal_IsOnlyBy3dCurve(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_ConstantBiNormal_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_ConstantBiNormal_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_ConstantBiNormal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_ConstantBiNormal
GeomFill_ConstantBiNormal_swigregister = _GeomFill.GeomFill_ConstantBiNormal_swigregister
GeomFill_ConstantBiNormal_swigregister(GeomFill_ConstantBiNormal)

def GeomFill_ConstantBiNormal_get_type_name(*args):
    """
    GeomFill_ConstantBiNormal_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_ConstantBiNormal_get_type_name(*args)

def GeomFill_ConstantBiNormal_get_type_descriptor(*args):
    """
    GeomFill_ConstantBiNormal_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_ConstantBiNormal_get_type_descriptor(*args)

class GeomFill_LocationLaw(Standard.Standard_Transient):
    """
    To define location  law in Sweeping location is --
    defined   by an  Matrix  M and  an Vector  V,  and
    transform an point P in MP+V.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_LocationLaw
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_LocationLaw(self) 
            return h


    def SetCurve(self, *args):
        """
        SetCurve(GeomFill_LocationLaw self, Handle_Adaptor3d_HCurve C)

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.GeomFill_LocationLaw_SetCurve(self, *args)


    def GetCurve(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        res = _GeomFill.GeomFill_LocationLaw_GetCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTrsf(self, *args):
        """
        SetTrsf(GeomFill_LocationLaw self, gp_Mat Transfo)

        Set a transformation Matrix like   the law M(t) become
        Mat * M(t)

        :type Transfo: OCC.wrapper.gp.gp_Mat

        """
        return _GeomFill.GeomFill_LocationLaw_SetTrsf(self, *args)


    def Copy(self, *args):
        """
        Copy(GeomFill_LocationLaw self) -> Handle_GeomFill_LocationLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_LocationLaw

        """
        return _GeomFill.GeomFill_LocationLaw_Copy(self, *args)


    def D0(self, *args):
        """
        D0(GeomFill_LocationLaw self, Standard_Real const Param, gp_Mat M, gp_Vec V) -> Standard_Boolean
        D0(GeomFill_LocationLaw self, Standard_Real const Param, gp_Mat M, gp_Vec V, NCollection_Array1_gp_Pnt2d Poles2d) -> Standard_Boolean

        compute Location and 2d points

        :type Param: float
        :type M: OCC.wrapper.gp.gp_Mat
        :type V: OCC.wrapper.gp.gp_Vec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_LocationLaw_D0(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_LocationLaw self, Standard_Real const Param, gp_Mat M, gp_Vec V, gp_Mat DM, gp_Vec DV, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d) -> Standard_Boolean

        compute location 2d  points and  associated
        first derivatives.
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type M: OCC.wrapper.gp.gp_Mat
        :type V: OCC.wrapper.gp.gp_Vec
        :type DM: OCC.wrapper.gp.gp_Mat
        :type DV: OCC.wrapper.gp.gp_Vec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_LocationLaw_D1(self, *args)


    def D2(self, *args):
        """
        D2(GeomFill_LocationLaw self, Standard_Real const Param, gp_Mat M, gp_Vec V, gp_Mat DM, gp_Vec DV, gp_Mat D2M, gp_Vec D2V, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d) -> Standard_Boolean

        compute location 2d  points and associated
        first and seconde  derivatives.
        Warning : It used only for C2 aproximation

        :type Param: float
        :type M: OCC.wrapper.gp.gp_Mat
        :type V: OCC.wrapper.gp.gp_Vec
        :type DM: OCC.wrapper.gp.gp_Mat
        :type DV: OCC.wrapper.gp.gp_Vec
        :type D2M: OCC.wrapper.gp.gp_Mat
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type D2Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_LocationLaw_D2(self, *args)


    def Nb2dCurves(self, *args):
        """
        Nb2dCurves(GeomFill_LocationLaw self) -> Standard_Integer

        get the number of  2d  curves (Restrictions  +  Traces)
        to approximate.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_LocationLaw_Nb2dCurves(self, *args)


    def HasFirstRestriction(self, *args):
        """
        HasFirstRestriction(GeomFill_LocationLaw self) -> Standard_Boolean

        Say if the first restriction is defined in this class.
        If it  is true the  first element  of poles array   in
        D0,D1,D2... Correspond to this restriction.
        Returns Standard_False (default implementation)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_LocationLaw_HasFirstRestriction(self, *args)


    def HasLastRestriction(self, *args):
        """
        HasLastRestriction(GeomFill_LocationLaw self) -> Standard_Boolean

        Say if the last restriction is defined in this class.
        If it is  true the  last element  of poles array in
        D0,D1,D2... Correspond to this restriction.
        Returns Standard_False (default implementation)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_LocationLaw_HasLastRestriction(self, *args)


    def TraceNumber(self, *args):
        """
        TraceNumber(GeomFill_LocationLaw self) -> Standard_Integer

        Give the number of trace (Curves 2d wich are not restriction)
        Returns 0 (default implementation)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_LocationLaw_TraceNumber(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(GeomFill_LocationLaw self) -> GeomFill_PipeError

        Give a status to the Law
        Returns PipeOk (default implementation)

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _GeomFill.GeomFill_LocationLaw_ErrorStatus(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(GeomFill_LocationLaw self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_LocationLaw_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(GeomFill_LocationLaw self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.GeomFill_LocationLaw_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(GeomFill_LocationLaw self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_LocationLaw_SetInterval(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(GeomFill_LocationLaw self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_LocationLaw_GetInterval(self, *args)


    def GetDomain(self, *args):
        """
        GetDomain(GeomFill_LocationLaw self)

        Gets the bounds of the function parametric domain.
        Warning: This domain it is  not modified by the
        SetValue method

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_LocationLaw_GetDomain(self, *args)


    def Resolution(self, *args):
        """
        Resolution(GeomFill_LocationLaw self, Standard_Integer const Index, Standard_Real const Tol)

        Returns the resolutions in the  sub-space 2d <Index>
        This information is usfull to find an good tolerance in
        2d approximation.

        :type Index: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _GeomFill.GeomFill_LocationLaw_Resolution(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(GeomFill_LocationLaw self, Standard_Real const Tol3d, Standard_Real const Tol2d)

        Is usefull, if (me) have to run numerical
        algorithm to perform D0, D1 or D2
        The default implementation make nothing.

        :type Tol3d: float
        :type Tol2d: float

        """
        return _GeomFill.GeomFill_LocationLaw_SetTolerance(self, *args)


    def GetMaximalNorm(self, *args):
        """
        GetMaximalNorm(GeomFill_LocationLaw self) -> Standard_Real

        Get the maximum Norm  of the matrix-location part.  It
        is usful to find an good Tolerance to approx M(t).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_LocationLaw_GetMaximalNorm(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(GeomFill_LocationLaw self, gp_Mat AM, gp_Vec AV)

        Get average value of M(t) and V(t) it is usfull to
        make fast approximation of rational surfaces.

        :type AM: OCC.wrapper.gp.gp_Mat
        :type AV: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_LocationLaw_GetAverageLaw(self, *args)


    def IsTranslation(self, *args):
        """
        IsTranslation(GeomFill_LocationLaw self) -> Standard_Boolean

        Say if the Location  Law, is an translation of  Location
        The default implementation is " returns False ".

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_LocationLaw_IsTranslation(self, *args)


    def IsRotation(self, *args):
        """
        IsRotation(GeomFill_LocationLaw self) -> Standard_Boolean

        Say if the Location  Law, is a rotation of Location
        The default implementation is " returns False ".

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_LocationLaw_IsRotation(self, *args)


    def Rotation(self, *args):
        """
        Rotation(GeomFill_LocationLaw self, gp_Pnt Center)

        :type Center: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.GeomFill_LocationLaw_Rotation(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_LocationLaw_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_LocationLaw_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_LocationLaw_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_LocationLaw
GeomFill_LocationLaw_swigregister = _GeomFill.GeomFill_LocationLaw_swigregister
GeomFill_LocationLaw_swigregister(GeomFill_LocationLaw)

def GeomFill_LocationLaw_get_type_name(*args):
    """
    GeomFill_LocationLaw_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_LocationLaw_get_type_name(*args)

def GeomFill_LocationLaw_get_type_descriptor(*args):
    """
    GeomFill_LocationLaw_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_LocationLaw_get_type_descriptor(*args)

class GeomFill_Filling(object):
    """Root class for Filling;"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomFill_Filling self) -> GeomFill_Filling

        Root class for Filling;
        """
        this = _GeomFill.new_GeomFill_Filling(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbUPoles(self, *args):
        """
        NbUPoles(GeomFill_Filling self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_Filling_NbUPoles(self, *args)


    def NbVPoles(self, *args):
        """
        NbVPoles(GeomFill_Filling self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_Filling_NbVPoles(self, *args)


    def Poles(self, *args):
        """
        Poles(GeomFill_Filling self, NCollection_Array2_gp_Pnt Poles)

        :type Poles: OCC.wrapper.TColgp.TColgp_Array2OfPnt

        """
        return _GeomFill.GeomFill_Filling_Poles(self, *args)


    def isRational(self, *args):
        """
        isRational(GeomFill_Filling self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_Filling_isRational(self, *args)


    def Weights(self, *args):
        """
        Weights(GeomFill_Filling self, NCollection_Array2_Standard_Real Weights)

        :type Weights: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        return _GeomFill.GeomFill_Filling_Weights(self, *args)

    __swig_destroy__ = _GeomFill.delete_GeomFill_Filling
GeomFill_Filling_swigregister = _GeomFill.GeomFill_Filling_swigregister
GeomFill_Filling_swigregister(GeomFill_Filling)

class GeomFill_LocationDraft(GeomFill_LocationLaw):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_LocationDraft
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_LocationDraft(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GeomFill_LocationDraft self, gp_Dir Direction, Standard_Real const Angle) -> GeomFill_LocationDraft

        :type Direction: OCC.wrapper.gp.gp_Dir
        :type Angle: float

        """
        this = _GeomFill.new_GeomFill_LocationDraft(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetStopSurf(self, *args):
        """
        SetStopSurf(GeomFill_LocationDraft self, Handle_Adaptor3d_HSurface Surf)

        :type Surf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        return _GeomFill.GeomFill_LocationDraft_SetStopSurf(self, *args)


    def SetAngle(self, *args):
        """
        SetAngle(GeomFill_LocationDraft self, Standard_Real const Angle)

        :type Angle: float

        """
        return _GeomFill.GeomFill_LocationDraft_SetAngle(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(GeomFill_LocationDraft self, Handle_Adaptor3d_HCurve C)

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.GeomFill_LocationDraft_SetCurve(self, *args)


    def GetCurve(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        res = _GeomFill.GeomFill_LocationDraft_GetCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTrsf(self, *args):
        """
        SetTrsf(GeomFill_LocationDraft self, gp_Mat Transfo)

        :type Transfo: OCC.wrapper.gp.gp_Mat

        """
        return _GeomFill.GeomFill_LocationDraft_SetTrsf(self, *args)


    def Copy(self, *args):
        """
        Copy(GeomFill_LocationDraft self) -> Handle_GeomFill_LocationLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_LocationLaw

        """
        return _GeomFill.GeomFill_LocationDraft_Copy(self, *args)


    def D0(self, *args):
        """
        D0(GeomFill_LocationDraft self, Standard_Real const Param, gp_Mat M, gp_Vec V) -> Standard_Boolean
        D0(GeomFill_LocationDraft self, Standard_Real const Param, gp_Mat M, gp_Vec V, NCollection_Array1_gp_Pnt2d Poles2d) -> Standard_Boolean

        compute Location and 2d points

        :type Param: float
        :type M: OCC.wrapper.gp.gp_Mat
        :type V: OCC.wrapper.gp.gp_Vec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_LocationDraft_D0(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_LocationDraft self, Standard_Real const Param, gp_Mat M, gp_Vec V, gp_Mat DM, gp_Vec DV, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d) -> Standard_Boolean

        compute location 2d  points and  associated
        first derivatives.
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type M: OCC.wrapper.gp.gp_Mat
        :type V: OCC.wrapper.gp.gp_Vec
        :type DM: OCC.wrapper.gp.gp_Mat
        :type DV: OCC.wrapper.gp.gp_Vec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_LocationDraft_D1(self, *args)


    def D2(self, *args):
        """
        D2(GeomFill_LocationDraft self, Standard_Real const Param, gp_Mat M, gp_Vec V, gp_Mat DM, gp_Vec DV, gp_Mat D2M, gp_Vec D2V, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d) -> Standard_Boolean

        compute location 2d  points and associated
        first and seconde  derivatives.
        Warning : It used only for C2 aproximation

        :type Param: float
        :type M: OCC.wrapper.gp.gp_Mat
        :type V: OCC.wrapper.gp.gp_Vec
        :type DM: OCC.wrapper.gp.gp_Mat
        :type DV: OCC.wrapper.gp.gp_Vec
        :type D2M: OCC.wrapper.gp.gp_Mat
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type D2Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_LocationDraft_D2(self, *args)


    def HasFirstRestriction(self, *args):
        """
        HasFirstRestriction(GeomFill_LocationDraft self) -> Standard_Boolean

        Say if the first restriction is defined in this class.
        If it  is true the  first element  of poles array   in
        D0,D1,D2... Correspond to this restriction.
        Returns Standard_False (default implementation)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_LocationDraft_HasFirstRestriction(self, *args)


    def HasLastRestriction(self, *args):
        """
        HasLastRestriction(GeomFill_LocationDraft self) -> Standard_Boolean

        Say if the last restriction is defined in this class.
        If it is  true the  last element  of poles array in
        D0,D1,D2... Correspond to this restriction.
        Returns Standard_False (default implementation)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_LocationDraft_HasLastRestriction(self, *args)


    def TraceNumber(self, *args):
        """
        TraceNumber(GeomFill_LocationDraft self) -> Standard_Integer

        Give the number of trace (Curves 2d wich are not restriction)
        Returns 1 (default implementation)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_LocationDraft_TraceNumber(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(GeomFill_LocationDraft self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_LocationDraft_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(GeomFill_LocationDraft self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.GeomFill_LocationDraft_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(GeomFill_LocationDraft self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_LocationDraft_SetInterval(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(GeomFill_LocationDraft self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_LocationDraft_GetInterval(self, *args)


    def GetDomain(self, *args):
        """
        GetDomain(GeomFill_LocationDraft self)

        Gets the bounds of the function parametric domain.
        Warning: This domain it is  not modified by the
        SetValue method

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_LocationDraft_GetDomain(self, *args)


    def Resolution(self, *args):
        """
        Resolution(GeomFill_LocationDraft self, Standard_Integer const Index, Standard_Real const Tol)

        Returns the resolutions in the  sub-space 2d <Index>
        This information is usfull to find an good tolerance in
        2d approximation.
        Warning: Used only if Nb2dCurve > 0

        :type Index: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _GeomFill.GeomFill_LocationDraft_Resolution(self, *args)


    def GetMaximalNorm(self, *args):
        """
        GetMaximalNorm(GeomFill_LocationDraft self) -> Standard_Real

        Get the maximum Norm  of the matrix-location part.  It
        is usful to find an good Tolerance to approx M(t).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_LocationDraft_GetMaximalNorm(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(GeomFill_LocationDraft self, gp_Mat AM, gp_Vec AV)

        Get average value of M(t) and V(t) it is usfull to
        make fast approximation of rational  surfaces.

        :type AM: OCC.wrapper.gp.gp_Mat
        :type AV: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_LocationDraft_GetAverageLaw(self, *args)


    def IsTranslation(self, *args):
        """
        IsTranslation(GeomFill_LocationDraft self) -> Standard_Boolean

        Say if the Location  Law, is an translation of  Location
        The default implementation is " returns False ".

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_LocationDraft_IsTranslation(self, *args)


    def IsRotation(self, *args):
        """
        IsRotation(GeomFill_LocationDraft self) -> Standard_Boolean

        Say if the Location  Law, is a rotation of Location
        The default implementation is " returns False ".

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_LocationDraft_IsRotation(self, *args)


    def Rotation(self, *args):
        """
        Rotation(GeomFill_LocationDraft self, gp_Pnt Center)

        :type Center: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.GeomFill_LocationDraft_Rotation(self, *args)


    def IsIntersec(self, *args):
        """
        IsIntersec(GeomFill_LocationDraft self) -> Standard_Boolean

        Say if the generatrice interset the surface

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_LocationDraft_IsIntersec(self, *args)


    def Direction(self, *args):
        """
        Direction(GeomFill_LocationDraft self) -> gp_Dir

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _GeomFill.GeomFill_LocationDraft_Direction(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_LocationDraft_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_LocationDraft_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_LocationDraft_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_LocationDraft
GeomFill_LocationDraft_swigregister = _GeomFill.GeomFill_LocationDraft_swigregister
GeomFill_LocationDraft_swigregister(GeomFill_LocationDraft)

def GeomFill_LocationDraft_get_type_name(*args):
    """
    GeomFill_LocationDraft_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_LocationDraft_get_type_name(*args)

def GeomFill_LocationDraft_get_type_descriptor(*args):
    """
    GeomFill_LocationDraft_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_LocationDraft_get_type_descriptor(*args)

class GeomFill_TrihedronWithGuide(GeomFill_TrihedronLaw):
    """To define Trihedron along one Curve with a guide"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_TrihedronWithGuide
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_TrihedronWithGuide(self) 
            return h


    def Guide(self, *args):
        """
        Guide(GeomFill_TrihedronWithGuide self) -> Handle_Adaptor3d_HCurve

        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.GeomFill_TrihedronWithGuide_Guide(self, *args)


    def Origine(self, *args):
        """
        Origine(GeomFill_TrihedronWithGuide self, Standard_Real const Param1, Standard_Real const Param2)

        :type Param1: float
        :type Param2: float

        """
        return _GeomFill.GeomFill_TrihedronWithGuide_Origine(self, *args)


    def CurrentPointOnGuide(self, *args):
        """
        CurrentPointOnGuide(GeomFill_TrihedronWithGuide self) -> gp_Pnt

        Returns the current point on guide
        found by D0, D1 or D2.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.GeomFill_TrihedronWithGuide_CurrentPointOnGuide(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_TrihedronWithGuide_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_TrihedronWithGuide_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_TrihedronWithGuide_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_TrihedronWithGuide
GeomFill_TrihedronWithGuide_swigregister = _GeomFill.GeomFill_TrihedronWithGuide_swigregister
GeomFill_TrihedronWithGuide_swigregister(GeomFill_TrihedronWithGuide)

def GeomFill_TrihedronWithGuide_get_type_name(*args):
    """
    GeomFill_TrihedronWithGuide_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_TrihedronWithGuide_get_type_name(*args)

def GeomFill_TrihedronWithGuide_get_type_descriptor(*args):
    """
    GeomFill_TrihedronWithGuide_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_TrihedronWithGuide_get_type_descriptor(*args)

class GeomFill_GuideTrihedronPlan(GeomFill_TrihedronWithGuide):
    """
    Trihedron in  the case of sweeping along a guide curve defined
    by the orthogonal  plan on  the trajectory
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_GuideTrihedronPlan
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_GuideTrihedronPlan(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GeomFill_GuideTrihedronPlan self, Handle_Adaptor3d_HCurve theGuide) -> GeomFill_GuideTrihedronPlan

        :type theGuide: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        this = _GeomFill.new_GeomFill_GuideTrihedronPlan(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetCurve(self, *args):
        """
        SetCurve(GeomFill_GuideTrihedronPlan self, Handle_Adaptor3d_HCurve thePath)

        :type thePath: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.GeomFill_GuideTrihedronPlan_SetCurve(self, *args)


    def Copy(self, *args):
        """
        Copy(GeomFill_GuideTrihedronPlan self) -> Handle_GeomFill_TrihedronLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_TrihedronLaw

        """
        return _GeomFill.GeomFill_GuideTrihedronPlan_Copy(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(GeomFill_GuideTrihedronPlan self) -> GeomFill_PipeError

        Give a status to the Law
        Returns PipeOk (default implementation)

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _GeomFill.GeomFill_GuideTrihedronPlan_ErrorStatus(self, *args)


    def Guide(self, *args):
        """
        Guide(GeomFill_GuideTrihedronPlan self) -> Handle_Adaptor3d_HCurve

        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.GeomFill_GuideTrihedronPlan_Guide(self, *args)


    def D0(self, *args):
        """
        D0(GeomFill_GuideTrihedronPlan self, Standard_Real const Param, gp_Vec Tangent, gp_Vec Normal, gp_Vec BiNormal) -> Standard_Boolean

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_GuideTrihedronPlan_D0(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_GuideTrihedronPlan self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec BiNormal, gp_Vec DBiNormal) -> Standard_Boolean

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_GuideTrihedronPlan_D1(self, *args)


    def D2(self, *args):
        """
        D2(GeomFill_GuideTrihedronPlan self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec D2Tangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec D2Normal, gp_Vec BiNormal, gp_Vec DBiNormal, gp_Vec D2BiNormal) -> Standard_Boolean

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type D2Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type D2Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :type D2BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_GuideTrihedronPlan_D2(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(GeomFill_GuideTrihedronPlan self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_GuideTrihedronPlan_SetInterval(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(GeomFill_GuideTrihedronPlan self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_GuideTrihedronPlan_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(GeomFill_GuideTrihedronPlan self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.GeomFill_GuideTrihedronPlan_Intervals(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(GeomFill_GuideTrihedronPlan self, gp_Vec ATangent, gp_Vec ANormal, gp_Vec ABiNormal)

        Get average value of M(t) and V(t) it is usfull to
        make fast approximation of rational  surfaces.

        :type ATangent: OCC.wrapper.gp.gp_Vec
        :type ANormal: OCC.wrapper.gp.gp_Vec
        :type ABiNormal: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_GuideTrihedronPlan_GetAverageLaw(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(GeomFill_GuideTrihedronPlan self) -> Standard_Boolean

        Say if the law is Constant

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_GuideTrihedronPlan_IsConstant(self, *args)


    def IsOnlyBy3dCurve(self, *args):
        """
        IsOnlyBy3dCurve(GeomFill_GuideTrihedronPlan self) -> Standard_Boolean

        Say if the law is defined, only by the 3d Geometry of
        the setted Curve
        Return False by Default.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_GuideTrihedronPlan_IsOnlyBy3dCurve(self, *args)


    def Origine(self, *args):
        """
        Origine(GeomFill_GuideTrihedronPlan self, Standard_Real const OrACR1, Standard_Real const OrACR2)

        :type OrACR1: float
        :type OrACR2: float

        """
        return _GeomFill.GeomFill_GuideTrihedronPlan_Origine(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_GuideTrihedronPlan_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_GuideTrihedronPlan_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_GuideTrihedronPlan_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_GuideTrihedronPlan
GeomFill_GuideTrihedronPlan_swigregister = _GeomFill.GeomFill_GuideTrihedronPlan_swigregister
GeomFill_GuideTrihedronPlan_swigregister(GeomFill_GuideTrihedronPlan)

def GeomFill_GuideTrihedronPlan_get_type_name(*args):
    """
    GeomFill_GuideTrihedronPlan_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_GuideTrihedronPlan_get_type_name(*args)

def GeomFill_GuideTrihedronPlan_get_type_descriptor(*args):
    """
    GeomFill_GuideTrihedronPlan_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_GuideTrihedronPlan_get_type_descriptor(*args)

class GeomFill_BoundWithSurf(GeomFill_Boundary):
    """
    Defines a 3d curve as a boundary for a
    GeomFill_ConstrainedFilling algorithm.
    This curve is attached to an existing surface.
    Defines a  constrained boundary for  filling
    the computations are done with a CurveOnSurf and a
    normals field  defined by the normalized normal to
    the surface along the PCurve.
    Contains fields  to allow a reparametrization of curve
    and normals field.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_BoundWithSurf
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_BoundWithSurf(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GeomFill_BoundWithSurf self, Adaptor3d_CurveOnSurface CurveOnSurf, Standard_Real const Tol3d, Standard_Real const Tolang) -> GeomFill_BoundWithSurf

        Constructs a boundary object defined by the 3d curve CurveOnSurf.
        The surface to be filled along this boundary will be in the
        tolerance range defined by Tol3d.
        What's more, at each point of CurveOnSurf, the angle
        between the normal to the surface to be filled along this
        boundary, and the normal to the surface on which
        CurveOnSurf lies, must not be greater than TolAng.
        This object is to be used as a boundary for a
        GeomFill_ConstrainedFilling framework.
        Warning
        CurveOnSurf is an adapted curve, that is, an object
        which is an interface between:
        -   the services provided by a curve lying on a surface from the package Geom
        -   and those required of the curve by the computation algorithm which uses it.
        The adapted curve is created in the following way:
        Handle(Geom_Surface) mySurface = ... ;
        Handle(Geom2d_Curve) myParamCurve = ... ;
        // where myParamCurve is a 2D curve in the parametric space of the surface mySurface
        Handle(GeomAdaptor_HSurface)
        Surface = new
        GeomAdaptor_HSurface(mySurface);
        Handle(Geom2dAdaptor_HCurve)
        ParamCurve = new
        Geom2dAdaptor_HCurve(myParamCurve);
        CurveOnSurf = Adaptor3d_CurveOnSurface(ParamCurve,Surface);
        The boundary is then constructed with the CurveOnSurf object:
        Standard_Real Tol = ... ;
        Standard_Real TolAng = ... ;
        myBoundary =  GeomFill_BoundWithSurf (
        CurveOnSurf, Tol, TolAng );

        :type CurveOnSurf: OCC.wrapper.Adaptor3d.Adaptor3d_CurveOnSurface
        :type Tol3d: float
        :type Tolang: float

        """
        this = _GeomFill.new_GeomFill_BoundWithSurf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Value(self, *args):
        """
        Value(GeomFill_BoundWithSurf self, Standard_Real const U) -> gp_Pnt

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.GeomFill_BoundWithSurf_Value(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_BoundWithSurf self, Standard_Real const U, gp_Pnt P, gp_Vec V)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_BoundWithSurf_D1(self, *args)


    def HasNormals(self, *args):
        """
        HasNormals(GeomFill_BoundWithSurf self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_BoundWithSurf_HasNormals(self, *args)


    def Norm(self, *args):
        """
        Norm(GeomFill_BoundWithSurf self, Standard_Real const U) -> gp_Vec

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_BoundWithSurf_Norm(self, *args)


    def D1Norm(self, *args):
        """
        D1Norm(GeomFill_BoundWithSurf self, Standard_Real const U, gp_Vec N, gp_Vec DN)

        :type U: float
        :type N: OCC.wrapper.gp.gp_Vec
        :type DN: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_BoundWithSurf_D1Norm(self, *args)


    def Reparametrize(self, *args):
        """
        Reparametrize(GeomFill_BoundWithSurf self, Standard_Real const First, Standard_Real const Last, Standard_Boolean const HasDF, Standard_Boolean const HasDL, Standard_Real const DF, Standard_Real const DL, Standard_Boolean const Rev)

        :type First: float
        :type Last: float
        :type HasDF: bool
        :type HasDL: bool
        :type DF: float
        :type DL: float
        :type Rev: bool

        """
        return _GeomFill.GeomFill_BoundWithSurf_Reparametrize(self, *args)


    def Bounds(self, *args):
        """
        Bounds(GeomFill_BoundWithSurf self)

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_BoundWithSurf_Bounds(self, *args)


    def IsDegenerated(self, *args):
        """
        IsDegenerated(GeomFill_BoundWithSurf self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_BoundWithSurf_IsDegenerated(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_BoundWithSurf_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_BoundWithSurf_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_BoundWithSurf_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_BoundWithSurf
GeomFill_BoundWithSurf_swigregister = _GeomFill.GeomFill_BoundWithSurf_swigregister
GeomFill_BoundWithSurf_swigregister(GeomFill_BoundWithSurf)

def GeomFill_BoundWithSurf_get_type_name(*args):
    """
    GeomFill_BoundWithSurf_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_BoundWithSurf_get_type_name(*args)

def GeomFill_BoundWithSurf_get_type_descriptor(*args):
    """
    GeomFill_BoundWithSurf_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_BoundWithSurf_get_type_descriptor(*args)

class GeomFill_LocationGuide(GeomFill_LocationLaw):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_LocationGuide
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_LocationGuide(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GeomFill_LocationGuide self, Handle_GeomFill_TrihedronWithGuide Triedre) -> GeomFill_LocationGuide

        :type Triedre: OCC.wrapper.GeomFill.Handle_GeomFill_TrihedronWithGuide

        """
        this = _GeomFill.new_GeomFill_LocationGuide(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Set(self, *args):
        """
        Set(GeomFill_LocationGuide self, Handle_GeomFill_SectionLaw Section, Standard_Boolean const rotat, Standard_Real const SFirst, Standard_Real const SLast, Standard_Real const PrecAngle)

        :type Section: OCC.wrapper.GeomFill.Handle_GeomFill_SectionLaw
        :type rotat: bool
        :type SFirst: float
        :type SLast: float
        :type PrecAngle: float
        :type LastAngle: float

        """
        return _GeomFill.GeomFill_LocationGuide_Set(self, *args)


    def EraseRotation(self, *args):
        """EraseRotation(GeomFill_LocationGuide self)"""
        return _GeomFill.GeomFill_LocationGuide_EraseRotation(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(GeomFill_LocationGuide self, Handle_Adaptor3d_HCurve C)

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.GeomFill_LocationGuide_SetCurve(self, *args)


    def GetCurve(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        res = _GeomFill.GeomFill_LocationGuide_GetCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTrsf(self, *args):
        """
        SetTrsf(GeomFill_LocationGuide self, gp_Mat Transfo)

        :type Transfo: OCC.wrapper.gp.gp_Mat

        """
        return _GeomFill.GeomFill_LocationGuide_SetTrsf(self, *args)


    def Copy(self, *args):
        """
        Copy(GeomFill_LocationGuide self) -> Handle_GeomFill_LocationLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_LocationLaw

        """
        return _GeomFill.GeomFill_LocationGuide_Copy(self, *args)


    def D0(self, *args):
        """
        D0(GeomFill_LocationGuide self, Standard_Real const Param, gp_Mat M, gp_Vec V) -> Standard_Boolean
        D0(GeomFill_LocationGuide self, Standard_Real const Param, gp_Mat M, gp_Vec V, NCollection_Array1_gp_Pnt2d Poles2d) -> Standard_Boolean

        compute Location and 2d points

        :type Param: float
        :type M: OCC.wrapper.gp.gp_Mat
        :type V: OCC.wrapper.gp.gp_Vec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_LocationGuide_D0(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_LocationGuide self, Standard_Real const Param, gp_Mat M, gp_Vec V, gp_Mat DM, gp_Vec DV, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d) -> Standard_Boolean

        compute location 2d  points and  associated
        first derivatives.
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type M: OCC.wrapper.gp.gp_Mat
        :type V: OCC.wrapper.gp.gp_Vec
        :type DM: OCC.wrapper.gp.gp_Mat
        :type DV: OCC.wrapper.gp.gp_Vec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_LocationGuide_D1(self, *args)


    def D2(self, *args):
        """
        D2(GeomFill_LocationGuide self, Standard_Real const Param, gp_Mat M, gp_Vec V, gp_Mat DM, gp_Vec DV, gp_Mat D2M, gp_Vec D2V, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d) -> Standard_Boolean

        compute location 2d  points and associated
        first and seconde  derivatives.
        Warning : It used only for C2 aproximation

        :type Param: float
        :type M: OCC.wrapper.gp.gp_Mat
        :type V: OCC.wrapper.gp.gp_Vec
        :type DM: OCC.wrapper.gp.gp_Mat
        :type DV: OCC.wrapper.gp.gp_Vec
        :type D2M: OCC.wrapper.gp.gp_Mat
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type D2Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_LocationGuide_D2(self, *args)


    def HasFirstRestriction(self, *args):
        """
        HasFirstRestriction(GeomFill_LocationGuide self) -> Standard_Boolean

        Say if the first restriction is defined in this class.
        If it  is true the  first element  of poles array   in
        D0,D1,D2... Correspond to this restriction.
        Returns Standard_False (default implementation)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_LocationGuide_HasFirstRestriction(self, *args)


    def HasLastRestriction(self, *args):
        """
        HasLastRestriction(GeomFill_LocationGuide self) -> Standard_Boolean

        Say if the last restriction is defined in this class.
        If it is  true the  last element  of poles array in
        D0,D1,D2... Correspond to this restriction.
        Returns Standard_False (default implementation)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_LocationGuide_HasLastRestriction(self, *args)


    def TraceNumber(self, *args):
        """
        TraceNumber(GeomFill_LocationGuide self) -> Standard_Integer

        Give the number of trace (Curves 2d wich are not restriction)
        Returns 1 (default implementation)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_LocationGuide_TraceNumber(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(GeomFill_LocationGuide self) -> GeomFill_PipeError

        Give a status to the Law
        Returns PipeOk (default implementation)

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _GeomFill.GeomFill_LocationGuide_ErrorStatus(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(GeomFill_LocationGuide self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_LocationGuide_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(GeomFill_LocationGuide self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.GeomFill_LocationGuide_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(GeomFill_LocationGuide self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_LocationGuide_SetInterval(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(GeomFill_LocationGuide self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_LocationGuide_GetInterval(self, *args)


    def GetDomain(self, *args):
        """
        GetDomain(GeomFill_LocationGuide self)

        Gets the bounds of the function parametric domain.
        Warning: This domain it is  not modified by the
        SetValue method

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_LocationGuide_GetDomain(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(GeomFill_LocationGuide self, Standard_Real const Tol3d, Standard_Real const Tol2d)

        Is usefull, if (me) have to run numerical
        algorithm to perform D0, D1 or D2
        The default implementation make nothing.

        :type Tol3d: float
        :type Tol2d: float

        """
        return _GeomFill.GeomFill_LocationGuide_SetTolerance(self, *args)


    def Resolution(self, *args):
        """
        Resolution(GeomFill_LocationGuide self, Standard_Integer const Index, Standard_Real const Tol)

        Returns the resolutions in the  sub-space 2d <Index>
        This information is usfull to find an good tolerance in
        2d approximation.
        Warning: Used only if Nb2dCurve > 0

        :type Index: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _GeomFill.GeomFill_LocationGuide_Resolution(self, *args)


    def GetMaximalNorm(self, *args):
        """
        GetMaximalNorm(GeomFill_LocationGuide self) -> Standard_Real

        Get the maximum Norm  of the matrix-location part.  It
        is usful to find an good Tolerance to approx M(t).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_LocationGuide_GetMaximalNorm(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(GeomFill_LocationGuide self, gp_Mat AM, gp_Vec AV)

        Get average value of M(t) and V(t) it is usfull to
        make fast approximation of rational  surfaces.

        :type AM: OCC.wrapper.gp.gp_Mat
        :type AV: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_LocationGuide_GetAverageLaw(self, *args)


    def IsTranslation(self, *args):
        """
        IsTranslation(GeomFill_LocationGuide self) -> Standard_Boolean

        Say if the Location  Law, is an translation of  Location
        The default implementation is " returns False ".

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_LocationGuide_IsTranslation(self, *args)


    def IsRotation(self, *args):
        """
        IsRotation(GeomFill_LocationGuide self) -> Standard_Boolean

        Say if the Location  Law, is a rotation of Location
        The default implementation is " returns False ".

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_LocationGuide_IsRotation(self, *args)


    def Rotation(self, *args):
        """
        Rotation(GeomFill_LocationGuide self, gp_Pnt Center)

        :type Center: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.GeomFill_LocationGuide_Rotation(self, *args)


    def Section(self, *args):
        """
        Section(GeomFill_LocationGuide self) -> Handle_Geom_Curve

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _GeomFill.GeomFill_LocationGuide_Section(self, *args)


    def Guide(self, *args):
        """
        Guide(GeomFill_LocationGuide self) -> Handle_Adaptor3d_HCurve

        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.GeomFill_LocationGuide_Guide(self, *args)


    def SetOrigine(self, *args):
        """
        SetOrigine(GeomFill_LocationGuide self, Standard_Real const Param1, Standard_Real const Param2)

        :type Param1: float
        :type Param2: float

        """
        return _GeomFill.GeomFill_LocationGuide_SetOrigine(self, *args)


    def ComputeAutomaticLaw(self, *args):
        """
        ComputeAutomaticLaw(GeomFill_LocationGuide self, Handle_TColgp_HArray1OfPnt2d ParAndRad) -> GeomFill_PipeError

        :type ParAndRad: OCC.wrapper.TColgp.Handle_TColgp_HArray1OfPnt2d
        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _GeomFill.GeomFill_LocationGuide_ComputeAutomaticLaw(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_LocationGuide_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_LocationGuide_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_LocationGuide_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_LocationGuide
GeomFill_LocationGuide_swigregister = _GeomFill.GeomFill_LocationGuide_swigregister
GeomFill_LocationGuide_swigregister(GeomFill_LocationGuide)

def GeomFill_LocationGuide_get_type_name(*args):
    """
    GeomFill_LocationGuide_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_LocationGuide_get_type_name(*args)

def GeomFill_LocationGuide_get_type_descriptor(*args):
    """
    GeomFill_LocationGuide_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_LocationGuide_get_type_descriptor(*args)

class GeomFill_UniformSection(GeomFill_SectionLaw):
    """Define an Constant Section Law"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_UniformSection
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_UniformSection(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GeomFill_UniformSection self, Handle_Geom_Curve C, Standard_Real const FirstParameter=0.0, Standard_Real const LastParameter=1.0) -> GeomFill_UniformSection

        Make an constant Law with C.
        [First, Last] define law definition domain

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type FirstParameter: float
        :type LastParameter: float

        """
        this = _GeomFill.new_GeomFill_UniformSection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def D0(self, *args):
        """
        D0(GeomFill_UniformSection self, Standard_Real const Param, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weigths) -> Standard_Boolean

        compute the section for v = param

        :type Param: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_UniformSection_D0(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_UniformSection self, Standard_Real const Param, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean

        compute the first  derivative in v direction  of the
        section for v =  param
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_UniformSection_D1(self, *args)


    def D2(self, *args):
        """
        D2(GeomFill_UniformSection self, Standard_Real const Param, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        compute the second derivative  in v direction of the
        section  for v = param
        Warning : It used only for C2 aproximation

        :type Param: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_UniformSection_D2(self, *args)


    def BSplineSurface(self, *args):
        """
        BSplineSurface(GeomFill_UniformSection self) -> Handle_Geom_BSplineSurface

        give if possible an bspline Surface, like iso-v are the
        section.  If it is  not possible  this methode have  to
        get an Null Surface.  Is it the default implementation.

        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

        """
        return _GeomFill.GeomFill_UniformSection_BSplineSurface(self, *args)


    def SectionShape(self, *args):
        """
        SectionShape(GeomFill_UniformSection self)

        get the format of an  section

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int

        """
        return _GeomFill.GeomFill_UniformSection_SectionShape(self, *args)


    def Knots(self, *args):
        """
        Knots(GeomFill_UniformSection self, NCollection_Array1_Standard_Real TKnots)

        get the Knots of the section

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_UniformSection_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(GeomFill_UniformSection self, NCollection_Array1_Standard_Integer TMults)

        get the Multplicities of the section

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _GeomFill.GeomFill_UniformSection_Mults(self, *args)


    def IsRational(self, *args):
        """
        IsRational(GeomFill_UniformSection self) -> Standard_Boolean

        Returns if the sections are rationnal or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_UniformSection_IsRational(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(GeomFill_UniformSection self) -> Standard_Boolean

        Returns if the sections are periodic or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_UniformSection_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(GeomFill_UniformSection self) -> Standard_Boolean

        Returns if the law  isperiodic or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_UniformSection_IsVPeriodic(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(GeomFill_UniformSection self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_UniformSection_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(GeomFill_UniformSection self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.GeomFill_UniformSection_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(GeomFill_UniformSection self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_UniformSection_SetInterval(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(GeomFill_UniformSection self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_UniformSection_GetInterval(self, *args)


    def GetDomain(self, *args):
        """
        GetDomain(GeomFill_UniformSection self)

        Gets the bounds of the function parametric domain.
        Warning: This domain it is  not modified by the
        SetValue method

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_UniformSection_GetDomain(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(GeomFill_UniformSection self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, NCollection_Array1_Standard_Real Tol3d)

        Returns the tolerances associated at each poles to
        reach  in approximation, to satisfy: BoundTol error
        at the   Boundary  AngleTol tangent error  at  the
        Boundary  (in radian)  SurfTol   error inside the
        surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_UniformSection_GetTolerance(self, *args)


    def BarycentreOfSurf(self, *args):
        """
        BarycentreOfSurf(GeomFill_UniformSection self) -> gp_Pnt

        Get the barycentre of Surface.
        An   very  poor estimation is sufficent.
        This information is usefull to perform well
        conditioned rational approximation.
        Warning: Used only if <me> IsRational

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.GeomFill_UniformSection_BarycentreOfSurf(self, *args)


    def MaximalSection(self, *args):
        """
        MaximalSection(GeomFill_UniformSection self) -> Standard_Real

        Returns the   length of the greater section. This
        information is usefull to G1's control.
        Warning: With an little value, approximation can be slower.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_UniformSection_MaximalSection(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(GeomFill_UniformSection self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        in all  sections.
        This information is  usefull to control error
        in rational approximation.
        Warning: Used only if <me> IsRational

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_UniformSection_GetMinimalWeight(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(GeomFill_UniformSection self) -> Standard_Boolean

        return True

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_UniformSection_IsConstant(self, *args)


    def ConstantSection(self, *args):
        """
        ConstantSection(GeomFill_UniformSection self) -> Handle_Geom_Curve

        Return the constant Section if <me>  IsConstant.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _GeomFill.GeomFill_UniformSection_ConstantSection(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_UniformSection_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_UniformSection_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_UniformSection_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_UniformSection
GeomFill_UniformSection_swigregister = _GeomFill.GeomFill_UniformSection_swigregister
GeomFill_UniformSection_swigregister(GeomFill_UniformSection)

def GeomFill_UniformSection_get_type_name(*args):
    """
    GeomFill_UniformSection_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_UniformSection_get_type_name(*args)

def GeomFill_UniformSection_get_type_descriptor(*args):
    """
    GeomFill_UniformSection_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_UniformSection_get_type_descriptor(*args)

class GeomFill_GuideTrihedronAC(GeomFill_TrihedronWithGuide):
    """
    Trihedron in  the  case of a sweeping along a guide  curve.
    defined by curviline  absciss
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_GuideTrihedronAC
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_GuideTrihedronAC(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GeomFill_GuideTrihedronAC self, Handle_Adaptor3d_HCurve guide) -> GeomFill_GuideTrihedronAC

        :type guide: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        this = _GeomFill.new_GeomFill_GuideTrihedronAC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetCurve(self, *args):
        """
        SetCurve(GeomFill_GuideTrihedronAC self, Handle_Adaptor3d_HCurve C)

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.GeomFill_GuideTrihedronAC_SetCurve(self, *args)


    def Copy(self, *args):
        """
        Copy(GeomFill_GuideTrihedronAC self) -> Handle_GeomFill_TrihedronLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_TrihedronLaw

        """
        return _GeomFill.GeomFill_GuideTrihedronAC_Copy(self, *args)


    def Guide(self, *args):
        """
        Guide(GeomFill_GuideTrihedronAC self) -> Handle_Adaptor3d_HCurve

        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.GeomFill_GuideTrihedronAC_Guide(self, *args)


    def D0(self, *args):
        """
        D0(GeomFill_GuideTrihedronAC self, Standard_Real const Param, gp_Vec Tangent, gp_Vec Normal, gp_Vec BiNormal) -> Standard_Boolean

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_GuideTrihedronAC_D0(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_GuideTrihedronAC self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec BiNormal, gp_Vec DBiNormal) -> Standard_Boolean

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_GuideTrihedronAC_D1(self, *args)


    def D2(self, *args):
        """
        D2(GeomFill_GuideTrihedronAC self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec D2Tangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec D2Normal, gp_Vec BiNormal, gp_Vec DBiNormal, gp_Vec D2BiNormal) -> Standard_Boolean

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type D2Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type D2Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :type D2BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_GuideTrihedronAC_D2(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(GeomFill_GuideTrihedronAC self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_GuideTrihedronAC_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(GeomFill_GuideTrihedronAC self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.GeomFill_GuideTrihedronAC_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(GeomFill_GuideTrihedronAC self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_GuideTrihedronAC_SetInterval(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(GeomFill_GuideTrihedronAC self, gp_Vec ATangent, gp_Vec ANormal, gp_Vec ABiNormal)

        Get average value of M(t) and V(t) it is usfull to
        make fast approximation of rational  surfaces.

        :type ATangent: OCC.wrapper.gp.gp_Vec
        :type ANormal: OCC.wrapper.gp.gp_Vec
        :type ABiNormal: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_GuideTrihedronAC_GetAverageLaw(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(GeomFill_GuideTrihedronAC self) -> Standard_Boolean

        Say if the law is Constant

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_GuideTrihedronAC_IsConstant(self, *args)


    def IsOnlyBy3dCurve(self, *args):
        """
        IsOnlyBy3dCurve(GeomFill_GuideTrihedronAC self) -> Standard_Boolean

        Say if the law is defined, only by the 3d Geometry of
        the setted Curve
        Return False by Default.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_GuideTrihedronAC_IsOnlyBy3dCurve(self, *args)


    def Origine(self, *args):
        """
        Origine(GeomFill_GuideTrihedronAC self, Standard_Real const OrACR1, Standard_Real const OrACR2)

        :type OrACR1: float
        :type OrACR2: float

        """
        return _GeomFill.GeomFill_GuideTrihedronAC_Origine(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_GuideTrihedronAC_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_GuideTrihedronAC_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_GuideTrihedronAC_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_GuideTrihedronAC
GeomFill_GuideTrihedronAC_swigregister = _GeomFill.GeomFill_GuideTrihedronAC_swigregister
GeomFill_GuideTrihedronAC_swigregister(GeomFill_GuideTrihedronAC)

def GeomFill_GuideTrihedronAC_get_type_name(*args):
    """
    GeomFill_GuideTrihedronAC_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_GuideTrihedronAC_get_type_name(*args)

def GeomFill_GuideTrihedronAC_get_type_descriptor(*args):
    """
    GeomFill_GuideTrihedronAC_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_GuideTrihedronAC_get_type_descriptor(*args)

class GeomFill_HArray1OfSectionLaw(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_HArray1OfSectionLaw
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_HArray1OfSectionLaw(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GeomFill_HArray1OfSectionLaw self, Standard_Integer const theLower, Standard_Integer const theUpper) -> GeomFill_HArray1OfSectionLaw
        __init__(GeomFill_HArray1OfSectionLaw self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_GeomFill_SectionLaw theValue) -> GeomFill_HArray1OfSectionLaw
        __init__(GeomFill_HArray1OfSectionLaw self, NCollection_Array1_Handle_GeomFill_SectionLaw theOther) -> GeomFill_HArray1OfSectionLaw

        :type theOther: OCC.wrapper.GeomFill.GeomFill_Array1OfSectionLaw

        """
        this = _GeomFill.new_GeomFill_HArray1OfSectionLaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.GeomFill.GeomFill_Array1OfSectionLaw

        """
        res = _GeomFill.GeomFill_HArray1OfSectionLaw_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(GeomFill_HArray1OfSectionLaw self) -> NCollection_Array1_Handle_GeomFill_SectionLaw

        :rtype: OCC.wrapper.GeomFill.GeomFill_Array1OfSectionLaw

        """
        return _GeomFill.GeomFill_HArray1OfSectionLaw_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_HArray1OfSectionLaw_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_HArray1OfSectionLaw_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_HArray1OfSectionLaw_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_HArray1OfSectionLaw
GeomFill_HArray1OfSectionLaw_swigregister = _GeomFill.GeomFill_HArray1OfSectionLaw_swigregister
GeomFill_HArray1OfSectionLaw_swigregister(GeomFill_HArray1OfSectionLaw)

def GeomFill_HArray1OfSectionLaw_get_type_name(*args):
    """
    GeomFill_HArray1OfSectionLaw_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_HArray1OfSectionLaw_get_type_name(*args)

def GeomFill_HArray1OfSectionLaw_get_type_descriptor(*args):
    """
    GeomFill_HArray1OfSectionLaw_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_HArray1OfSectionLaw_get_type_descriptor(*args)

class GeomFill_CircularBlendFunc(Approx.Approx_SweepFunction):
    """
    Circular     Blend Function  to    approximate by
    SweepApproximation from Approx
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_CircularBlendFunc
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_CircularBlendFunc(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GeomFill_CircularBlendFunc self, Handle_Adaptor3d_HCurve Path, Handle_Adaptor3d_HCurve Curve1, Handle_Adaptor3d_HCurve Curve2, Standard_Real const Radius, Standard_Boolean const Polynomial) -> GeomFill_CircularBlendFunc

        Create a Blend  with a  constant  radius with 2
        guide-line.   <FShape>  sets the type of  fillet
        surface. The --  default value is  Convert_TgtThetaOver2 (classical --
        nurbs    --   representation  of   circles).
        ChFi3d_QuasiAngular  --  corresponds  to a nurbs
        representation   of  circles     --     which
        parameterisation  matches  the  circle  one.  --
        ChFi3d_Polynomial corresponds to a polynomial --
        representation of circles.

        :type Path: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type Curve1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type Curve2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type Radius: float
        :type Polynomial: bool

        """
        this = _GeomFill.new_GeomFill_CircularBlendFunc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def D0(self, *args):
        """
        D0(GeomFill_CircularBlendFunc self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths) -> Standard_Boolean

        compute the section for v = param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_CircularBlendFunc_D0(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_CircularBlendFunc self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean

        compute the first  derivative in v direction  of the
        section for v =  param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_CircularBlendFunc_D1(self, *args)


    def D2(self, *args):
        """
        D2(GeomFill_CircularBlendFunc self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        compute the second derivative  in v direction of the
        section  for v = param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type D2Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_CircularBlendFunc_D2(self, *args)


    def Nb2dCurves(self, *args):
        """
        Nb2dCurves(GeomFill_CircularBlendFunc self) -> Standard_Integer

        get the number of 2d curves to  approximate.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_CircularBlendFunc_Nb2dCurves(self, *args)


    def SectionShape(self, *args):
        """
        SectionShape(GeomFill_CircularBlendFunc self)

        get the format of an  section

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int

        """
        return _GeomFill.GeomFill_CircularBlendFunc_SectionShape(self, *args)


    def Knots(self, *args):
        """
        Knots(GeomFill_CircularBlendFunc self, NCollection_Array1_Standard_Real TKnots)

        get the Knots of the section

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_CircularBlendFunc_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(GeomFill_CircularBlendFunc self, NCollection_Array1_Standard_Integer TMults)

        get the Multplicities of the section

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _GeomFill.GeomFill_CircularBlendFunc_Mults(self, *args)


    def IsRational(self, *args):
        """
        IsRational(GeomFill_CircularBlendFunc self) -> Standard_Boolean

        Returns if the section is rationnal or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_CircularBlendFunc_IsRational(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(GeomFill_CircularBlendFunc self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_CircularBlendFunc_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(GeomFill_CircularBlendFunc self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.GeomFill_CircularBlendFunc_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(GeomFill_CircularBlendFunc self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the fonction
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_CircularBlendFunc_SetInterval(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(GeomFill_CircularBlendFunc self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, NCollection_Array1_Standard_Real Tol3d)

        Returns the tolerance to reach in approximation
        to respecte
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary (in radian)
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_CircularBlendFunc_GetTolerance(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(GeomFill_CircularBlendFunc self, Standard_Real const Tol3d, Standard_Real const Tol2d)

        Is usfull, if (me) have to  be run numerical
        algorithme to perform D0, D1 or D2

        :type Tol3d: float
        :type Tol2d: float

        """
        return _GeomFill.GeomFill_CircularBlendFunc_SetTolerance(self, *args)


    def BarycentreOfSurf(self, *args):
        """
        BarycentreOfSurf(GeomFill_CircularBlendFunc self) -> gp_Pnt

        Get    the   barycentre of   Surface.   An   very  poor
        estimation is sufficent. This information is usefull
        to perform well conditionned rational approximation.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.GeomFill_CircularBlendFunc_BarycentreOfSurf(self, *args)


    def MaximalSection(self, *args):
        """
        MaximalSection(GeomFill_CircularBlendFunc self) -> Standard_Real

        Returns the   length of the maximum section. This
        information is usefull to perform well conditionned rational
        approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_CircularBlendFunc_MaximalSection(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(GeomFill_CircularBlendFunc self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        of all  sections.  This information is  usefull to
        perform well conditionned rational approximation.

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_CircularBlendFunc_GetMinimalWeight(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_CircularBlendFunc_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_CircularBlendFunc_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_CircularBlendFunc_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_CircularBlendFunc
GeomFill_CircularBlendFunc_swigregister = _GeomFill.GeomFill_CircularBlendFunc_swigregister
GeomFill_CircularBlendFunc_swigregister(GeomFill_CircularBlendFunc)

def GeomFill_CircularBlendFunc_get_type_name(*args):
    """
    GeomFill_CircularBlendFunc_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_CircularBlendFunc_get_type_name(*args)

def GeomFill_CircularBlendFunc_get_type_descriptor(*args):
    """
    GeomFill_CircularBlendFunc_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_CircularBlendFunc_get_type_descriptor(*args)

class GeomFill_SectionGenerator(GeomFill_Profiler):
    """
    gives  the  functions  needed  for  instantiation from
    AppSurf in AppBlend.   Allow  to  evaluate  a  surface
    passing by all the curves if the Profiler.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomFill_SectionGenerator self) -> GeomFill_SectionGenerator

        gives  the  functions  needed  for  instantiation from
        AppSurf in AppBlend.   Allow  to  evaluate  a  surface
        passing by all the curves if the Profiler.
        """
        this = _GeomFill.new_GeomFill_SectionGenerator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetParam(self, *args):
        """
        SetParam(GeomFill_SectionGenerator self, Handle_TColStd_HArray1OfReal Params)

        :type Params: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _GeomFill.GeomFill_SectionGenerator_SetParam(self, *args)


    def GetShape(self, *args):
        """
        GetShape(GeomFill_SectionGenerator self)

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int
        :type NbPoles2d: int

        """
        return _GeomFill.GeomFill_SectionGenerator_GetShape(self, *args)


    def Knots(self, *args):
        """
        Knots(GeomFill_SectionGenerator self, NCollection_Array1_Standard_Real TKnots)

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_SectionGenerator_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(GeomFill_SectionGenerator self, NCollection_Array1_Standard_Integer TMults)

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _GeomFill.GeomFill_SectionGenerator_Mults(self, *args)


    def Section(self, *args):
        """
        Section(GeomFill_SectionGenerator self, Standard_Integer const P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean
        Section(GeomFill_SectionGenerator self, Standard_Integer const P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths)

        :type P: int
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_SectionGenerator_Section(self, *args)


    def Parameter(self, *args):
        """
        Parameter(GeomFill_SectionGenerator self, Standard_Integer const P) -> Standard_Real

        Returns  the parameter of   Section<P>, to impose  it for the
        approximation.

        :type P: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_SectionGenerator_Parameter(self, *args)

    __swig_destroy__ = _GeomFill.delete_GeomFill_SectionGenerator
GeomFill_SectionGenerator_swigregister = _GeomFill.GeomFill_SectionGenerator_swigregister
GeomFill_SectionGenerator_swigregister(GeomFill_SectionGenerator)

class Handle_GeomFill_LocationDraft(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_LocationDraft self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_LocationDraft_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_LocationDraft self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_LocationDraft self, GeomFill_LocationDraft thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_LocationDraft self, Handle_GeomFill_LocationDraft theHandle) -> Handle_GeomFill_LocationDraft
        assign(Handle_GeomFill_LocationDraft self, GeomFill_LocationDraft thePtr) -> Handle_GeomFill_LocationDraft
        assign(Handle_GeomFill_LocationDraft self, Handle_GeomFill_LocationDraft theHandle) -> Handle_GeomFill_LocationDraft

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_LocationDraft self) -> GeomFill_LocationDraft

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_LocationDraft self) -> GeomFill_LocationDraft

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_LocationDraft___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_LocationDraft self) -> GeomFill_LocationDraft

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_LocationDraft___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_LocationDraft___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_LocationDraft___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_LocationDraft(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_LocationDraft_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_LocationDraft

    def SetStopSurf(self, *args):
        """
        SetStopSurf(Handle_GeomFill_LocationDraft self, Handle_Adaptor3d_HSurface Surf)

        :type Surf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_SetStopSurf(self, *args)


    def SetAngle(self, *args):
        """
        SetAngle(Handle_GeomFill_LocationDraft self, Standard_Real const Angle)

        :type Angle: float

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_SetAngle(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(Handle_GeomFill_LocationDraft self, Handle_Adaptor3d_HCurve C)

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_SetCurve(self, *args)


    def GetCurve(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        res = _GeomFill.Handle_GeomFill_LocationDraft_GetCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTrsf(self, *args):
        """
        SetTrsf(Handle_GeomFill_LocationDraft self, gp_Mat Transfo)

        :type Transfo: OCC.wrapper.gp.gp_Mat

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_SetTrsf(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_GeomFill_LocationDraft self) -> Handle_GeomFill_LocationLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_LocationLaw

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_Copy(self, *args)


    def D0(self, *args):
        """
        D0(Handle_GeomFill_LocationDraft self, Standard_Real const Param, gp_Mat M, gp_Vec V) -> Standard_Boolean
        D0(Handle_GeomFill_LocationDraft self, Standard_Real const Param, gp_Mat M, gp_Vec V, NCollection_Array1_gp_Pnt2d Poles2d) -> Standard_Boolean

        compute Location and 2d points

        :type Param: float
        :type M: OCC.wrapper.gp.gp_Mat
        :type V: OCC.wrapper.gp.gp_Vec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_LocationDraft self, Standard_Real const Param, gp_Mat M, gp_Vec V, gp_Mat DM, gp_Vec DV, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d) -> Standard_Boolean

        compute location 2d  points and  associated
        first derivatives.
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type M: OCC.wrapper.gp.gp_Mat
        :type V: OCC.wrapper.gp.gp_Vec
        :type DM: OCC.wrapper.gp.gp_Mat
        :type DV: OCC.wrapper.gp.gp_Vec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_GeomFill_LocationDraft self, Standard_Real const Param, gp_Mat M, gp_Vec V, gp_Mat DM, gp_Vec DV, gp_Mat D2M, gp_Vec D2V, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d) -> Standard_Boolean

        compute location 2d  points and associated
        first and seconde  derivatives.
        Warning : It used only for C2 aproximation

        :type Param: float
        :type M: OCC.wrapper.gp.gp_Mat
        :type V: OCC.wrapper.gp.gp_Vec
        :type DM: OCC.wrapper.gp.gp_Mat
        :type DV: OCC.wrapper.gp.gp_Vec
        :type D2M: OCC.wrapper.gp.gp_Mat
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type D2Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_D2(self, *args)


    def HasFirstRestriction(self, *args):
        """
        HasFirstRestriction(Handle_GeomFill_LocationDraft self) -> Standard_Boolean

        Say if the first restriction is defined in this class.
        If it  is true the  first element  of poles array   in
        D0,D1,D2... Correspond to this restriction.
        Returns Standard_False (default implementation)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_HasFirstRestriction(self, *args)


    def HasLastRestriction(self, *args):
        """
        HasLastRestriction(Handle_GeomFill_LocationDraft self) -> Standard_Boolean

        Say if the last restriction is defined in this class.
        If it is  true the  last element  of poles array in
        D0,D1,D2... Correspond to this restriction.
        Returns Standard_False (default implementation)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_HasLastRestriction(self, *args)


    def TraceNumber(self, *args):
        """
        TraceNumber(Handle_GeomFill_LocationDraft self) -> Standard_Integer

        Give the number of trace (Curves 2d wich are not restriction)
        Returns 1 (default implementation)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_TraceNumber(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_GeomFill_LocationDraft self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_GeomFill_LocationDraft self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Handle_GeomFill_LocationDraft self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_SetInterval(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(Handle_GeomFill_LocationDraft self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_GetInterval(self, *args)


    def GetDomain(self, *args):
        """
        GetDomain(Handle_GeomFill_LocationDraft self)

        Gets the bounds of the function parametric domain.
        Warning: This domain it is  not modified by the
        SetValue method

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_GetDomain(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Handle_GeomFill_LocationDraft self, Standard_Integer const Index, Standard_Real const Tol)

        Returns the resolutions in the  sub-space 2d <Index>
        This information is usfull to find an good tolerance in
        2d approximation.
        Warning: Used only if Nb2dCurve > 0

        :type Index: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_Resolution(self, *args)


    def GetMaximalNorm(self, *args):
        """
        GetMaximalNorm(Handle_GeomFill_LocationDraft self) -> Standard_Real

        Get the maximum Norm  of the matrix-location part.  It
        is usful to find an good Tolerance to approx M(t).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_GetMaximalNorm(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(Handle_GeomFill_LocationDraft self, gp_Mat AM, gp_Vec AV)

        Get average value of M(t) and V(t) it is usfull to
        make fast approximation of rational  surfaces.

        :type AM: OCC.wrapper.gp.gp_Mat
        :type AV: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_GetAverageLaw(self, *args)


    def IsTranslation(self, *args):
        """
        IsTranslation(Handle_GeomFill_LocationDraft self) -> Standard_Boolean

        Say if the Location  Law, is an translation of  Location
        The default implementation is " returns False ".

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_IsTranslation(self, *args)


    def IsRotation(self, *args):
        """
        IsRotation(Handle_GeomFill_LocationDraft self) -> Standard_Boolean

        Say if the Location  Law, is a rotation of Location
        The default implementation is " returns False ".

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_IsRotation(self, *args)


    def Rotation(self, *args):
        """
        Rotation(Handle_GeomFill_LocationDraft self, gp_Pnt Center)

        :type Center: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_Rotation(self, *args)


    def IsIntersec(self, *args):
        """
        IsIntersec(Handle_GeomFill_LocationDraft self) -> Standard_Boolean

        Say if the generatrice interset the surface

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_IsIntersec(self, *args)


    def Direction(self, *args):
        """
        Direction(Handle_GeomFill_LocationDraft self) -> gp_Dir

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_Direction(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_LocationDraft self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_LocationDraft_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_LocationDraft_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Nb2dCurves(self, *args):
        """
        Nb2dCurves(Handle_GeomFill_LocationDraft self) -> Standard_Integer

        get the number of  2d  curves (Restrictions  +  Traces)
        to approximate.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_Nb2dCurves(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_GeomFill_LocationDraft self) -> GeomFill_PipeError

        Give a status to the Law
        Returns PipeOk (default implementation)

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_ErrorStatus(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_GeomFill_LocationDraft self, Standard_Real const Tol3d, Standard_Real const Tol2d)

        Is usefull, if (me) have to run numerical
        algorithm to perform D0, D1 or D2
        The default implementation make nothing.

        :type Tol3d: float
        :type Tol2d: float

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_SetTolerance(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_LocationDraft self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_LocationDraft_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_LocationDraft self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_LocationDraft self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_LocationDraft self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_LocationDraft self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_LocationDraft self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_LocationDraft self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_LocationDraft self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_LocationDraft_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_LocationDraft self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_LocationDraft_DecrementRefCounter(self, *args)

Handle_GeomFill_LocationDraft_swigregister = _GeomFill.Handle_GeomFill_LocationDraft_swigregister
Handle_GeomFill_LocationDraft_swigregister(Handle_GeomFill_LocationDraft)

def Handle_GeomFill_LocationDraft_DownCast(thing):
    return _GeomFill.Handle_GeomFill_LocationDraft_DownCast(thing)
Handle_GeomFill_LocationDraft_DownCast = _GeomFill.Handle_GeomFill_LocationDraft_DownCast

class GeomFill_CurveAndTrihedron(GeomFill_LocationLaw):
    """
    Define location law with an TrihedronLaw and an
    curve
    Definition Location is :
    transformed  section   coordinates  in  (Curve(v)),
    (Normal(v),   BiNormal(v), Tangente(v))) systeme are
    the  same like section  shape coordinates in
    (O,(OX, OY, OZ)) systeme.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_CurveAndTrihedron
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_CurveAndTrihedron(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GeomFill_CurveAndTrihedron self, Handle_GeomFill_TrihedronLaw Trihedron) -> GeomFill_CurveAndTrihedron

        :type Trihedron: OCC.wrapper.GeomFill.Handle_GeomFill_TrihedronLaw

        """
        this = _GeomFill.new_GeomFill_CurveAndTrihedron(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetCurve(self, *args):
        """
        SetCurve(GeomFill_CurveAndTrihedron self, Handle_Adaptor3d_HCurve C)

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.GeomFill_CurveAndTrihedron_SetCurve(self, *args)


    def GetCurve(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        res = _GeomFill.GeomFill_CurveAndTrihedron_GetCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTrsf(self, *args):
        """
        SetTrsf(GeomFill_CurveAndTrihedron self, gp_Mat Transfo)

        Set a transformation Matrix like   the law M(t) become
        Mat * M(t)

        :type Transfo: OCC.wrapper.gp.gp_Mat

        """
        return _GeomFill.GeomFill_CurveAndTrihedron_SetTrsf(self, *args)


    def Copy(self, *args):
        """
        Copy(GeomFill_CurveAndTrihedron self) -> Handle_GeomFill_LocationLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_LocationLaw

        """
        return _GeomFill.GeomFill_CurveAndTrihedron_Copy(self, *args)


    def D0(self, *args):
        """
        D0(GeomFill_CurveAndTrihedron self, Standard_Real const Param, gp_Mat M, gp_Vec V) -> Standard_Boolean
        D0(GeomFill_CurveAndTrihedron self, Standard_Real const Param, gp_Mat M, gp_Vec V, NCollection_Array1_gp_Pnt2d Poles2d) -> Standard_Boolean

        compute Location and 2d points

        :type Param: float
        :type M: OCC.wrapper.gp.gp_Mat
        :type V: OCC.wrapper.gp.gp_Vec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_CurveAndTrihedron_D0(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_CurveAndTrihedron self, Standard_Real const Param, gp_Mat M, gp_Vec V, gp_Mat DM, gp_Vec DV, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d) -> Standard_Boolean

        compute location 2d  points and  associated
        first derivatives.
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type M: OCC.wrapper.gp.gp_Mat
        :type V: OCC.wrapper.gp.gp_Vec
        :type DM: OCC.wrapper.gp.gp_Mat
        :type DV: OCC.wrapper.gp.gp_Vec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_CurveAndTrihedron_D1(self, *args)


    def D2(self, *args):
        """
        D2(GeomFill_CurveAndTrihedron self, Standard_Real const Param, gp_Mat M, gp_Vec V, gp_Mat DM, gp_Vec DV, gp_Mat D2M, gp_Vec D2V, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d) -> Standard_Boolean

        compute location 2d  points and associated
        first and seconde  derivatives.
        Warning : It used only for C2 aproximation

        :type Param: float
        :type M: OCC.wrapper.gp.gp_Mat
        :type V: OCC.wrapper.gp.gp_Vec
        :type DM: OCC.wrapper.gp.gp_Mat
        :type DV: OCC.wrapper.gp.gp_Vec
        :type D2M: OCC.wrapper.gp.gp_Mat
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type D2Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_CurveAndTrihedron_D2(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(GeomFill_CurveAndTrihedron self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_CurveAndTrihedron_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(GeomFill_CurveAndTrihedron self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.GeomFill_CurveAndTrihedron_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(GeomFill_CurveAndTrihedron self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_CurveAndTrihedron_SetInterval(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(GeomFill_CurveAndTrihedron self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_CurveAndTrihedron_GetInterval(self, *args)


    def GetDomain(self, *args):
        """
        GetDomain(GeomFill_CurveAndTrihedron self)

        Gets the bounds of the function parametric domain.
        Warning: This domain it is  not modified by the
        SetValue method

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_CurveAndTrihedron_GetDomain(self, *args)


    def GetMaximalNorm(self, *args):
        """
        GetMaximalNorm(GeomFill_CurveAndTrihedron self) -> Standard_Real

        Get the maximum Norm  of the matrix-location part.  It
        is usful to find an good Tolerance to approx M(t).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_CurveAndTrihedron_GetMaximalNorm(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(GeomFill_CurveAndTrihedron self, gp_Mat AM, gp_Vec AV)

        Get average value of M(t) and V(t) it is usfull to
        make fast approximation of rational  surfaces.

        :type AM: OCC.wrapper.gp.gp_Mat
        :type AV: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_CurveAndTrihedron_GetAverageLaw(self, *args)


    def IsTranslation(self, *args):
        """
        IsTranslation(GeomFill_CurveAndTrihedron self) -> Standard_Boolean

        Say if the Location  Law, is an translation of  Location
        The default implementation is " returns False ".

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_CurveAndTrihedron_IsTranslation(self, *args)


    def IsRotation(self, *args):
        """
        IsRotation(GeomFill_CurveAndTrihedron self) -> Standard_Boolean

        Say if the Location  Law, is a rotation of Location
        The default implementation is " returns False ".

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_CurveAndTrihedron_IsRotation(self, *args)


    def Rotation(self, *args):
        """
        Rotation(GeomFill_CurveAndTrihedron self, gp_Pnt Center)

        :type Center: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.GeomFill_CurveAndTrihedron_Rotation(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_CurveAndTrihedron_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_CurveAndTrihedron_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_CurveAndTrihedron_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_CurveAndTrihedron
GeomFill_CurveAndTrihedron_swigregister = _GeomFill.GeomFill_CurveAndTrihedron_swigregister
GeomFill_CurveAndTrihedron_swigregister(GeomFill_CurveAndTrihedron)

def GeomFill_CurveAndTrihedron_get_type_name(*args):
    """
    GeomFill_CurveAndTrihedron_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_CurveAndTrihedron_get_type_name(*args)

def GeomFill_CurveAndTrihedron_get_type_descriptor(*args):
    """
    GeomFill_CurveAndTrihedron_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_CurveAndTrihedron_get_type_descriptor(*args)

class Handle_GeomFill_GuideTrihedronPlan(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_GuideTrihedronPlan self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_GuideTrihedronPlan self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_GuideTrihedronPlan self, GeomFill_GuideTrihedronPlan thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_GuideTrihedronPlan self, Handle_GeomFill_GuideTrihedronPlan theHandle) -> Handle_GeomFill_GuideTrihedronPlan
        assign(Handle_GeomFill_GuideTrihedronPlan self, GeomFill_GuideTrihedronPlan thePtr) -> Handle_GeomFill_GuideTrihedronPlan
        assign(Handle_GeomFill_GuideTrihedronPlan self, Handle_GeomFill_GuideTrihedronPlan theHandle) -> Handle_GeomFill_GuideTrihedronPlan

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_GuideTrihedronPlan self) -> GeomFill_GuideTrihedronPlan

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_GuideTrihedronPlan self) -> GeomFill_GuideTrihedronPlan

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_GuideTrihedronPlan self) -> GeomFill_GuideTrihedronPlan

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_GuideTrihedronPlan___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_GuideTrihedronPlan(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_GuideTrihedronPlan_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_GuideTrihedronPlan

    def SetCurve(self, *args):
        """
        SetCurve(Handle_GeomFill_GuideTrihedronPlan self, Handle_Adaptor3d_HCurve thePath)

        :type thePath: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_SetCurve(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_GeomFill_GuideTrihedronPlan self) -> Handle_GeomFill_TrihedronLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_TrihedronLaw

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_Copy(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_GeomFill_GuideTrihedronPlan self) -> GeomFill_PipeError

        Give a status to the Law
        Returns PipeOk (default implementation)

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_ErrorStatus(self, *args)


    def Guide(self, *args):
        """
        Guide(Handle_GeomFill_GuideTrihedronPlan self) -> Handle_Adaptor3d_HCurve

        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_Guide(self, *args)


    def D0(self, *args):
        """
        D0(Handle_GeomFill_GuideTrihedronPlan self, Standard_Real const Param, gp_Vec Tangent, gp_Vec Normal, gp_Vec BiNormal) -> Standard_Boolean

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_GuideTrihedronPlan self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec BiNormal, gp_Vec DBiNormal) -> Standard_Boolean

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_GeomFill_GuideTrihedronPlan self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec D2Tangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec D2Normal, gp_Vec BiNormal, gp_Vec DBiNormal, gp_Vec D2BiNormal) -> Standard_Boolean

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type D2Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type D2Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :type D2BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_D2(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Handle_GeomFill_GuideTrihedronPlan self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_SetInterval(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_GeomFill_GuideTrihedronPlan self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_GeomFill_GuideTrihedronPlan self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_Intervals(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(Handle_GeomFill_GuideTrihedronPlan self, gp_Vec ATangent, gp_Vec ANormal, gp_Vec ABiNormal)

        Get average value of M(t) and V(t) it is usfull to
        make fast approximation of rational  surfaces.

        :type ATangent: OCC.wrapper.gp.gp_Vec
        :type ANormal: OCC.wrapper.gp.gp_Vec
        :type ABiNormal: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_GetAverageLaw(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(Handle_GeomFill_GuideTrihedronPlan self) -> Standard_Boolean

        Say if the law is Constant

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_IsConstant(self, *args)


    def IsOnlyBy3dCurve(self, *args):
        """
        IsOnlyBy3dCurve(Handle_GeomFill_GuideTrihedronPlan self) -> Standard_Boolean

        Say if the law is defined, only by the 3d Geometry of
        the setted Curve
        Return False by Default.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_IsOnlyBy3dCurve(self, *args)


    def Origine(self, *args):
        """
        Origine(Handle_GeomFill_GuideTrihedronPlan self, Standard_Real const OrACR1, Standard_Real const OrACR2)

        :type OrACR1: float
        :type OrACR2: float

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_Origine(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_GuideTrihedronPlan self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_GuideTrihedronPlan_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_GuideTrihedronPlan_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CurrentPointOnGuide(self, *args):
        """
        CurrentPointOnGuide(Handle_GeomFill_GuideTrihedronPlan self) -> gp_Pnt

        Returns the current point on guide
        found by D0, D1 or D2.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_CurrentPointOnGuide(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(Handle_GeomFill_GuideTrihedronPlan self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_GetInterval(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_GuideTrihedronPlan self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_GuideTrihedronPlan self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_GuideTrihedronPlan self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_GuideTrihedronPlan self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_GuideTrihedronPlan self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_GuideTrihedronPlan self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_GuideTrihedronPlan self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_GuideTrihedronPlan self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_GuideTrihedronPlan self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_DecrementRefCounter(self, *args)

Handle_GeomFill_GuideTrihedronPlan_swigregister = _GeomFill.Handle_GeomFill_GuideTrihedronPlan_swigregister
Handle_GeomFill_GuideTrihedronPlan_swigregister(Handle_GeomFill_GuideTrihedronPlan)

def Handle_GeomFill_GuideTrihedronPlan_DownCast(thing):
    return _GeomFill.Handle_GeomFill_GuideTrihedronPlan_DownCast(thing)
Handle_GeomFill_GuideTrihedronPlan_DownCast = _GeomFill.Handle_GeomFill_GuideTrihedronPlan_DownCast

class GeomFill_FunctionDraft(math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomFill_FunctionDraft self, Handle_Adaptor3d_HSurface S, Handle_Adaptor3d_HCurve C) -> GeomFill_FunctionDraft

        :type S: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        this = _GeomFill.new_GeomFill_FunctionDraft(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(GeomFill_FunctionDraft self) -> Standard_Integer

        returns the number of variables of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_FunctionDraft_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(GeomFill_FunctionDraft self) -> Standard_Integer

        returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_FunctionDraft_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(GeomFill_FunctionDraft self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_FunctionDraft_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(GeomFill_FunctionDraft self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_FunctionDraft_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(GeomFill_FunctionDraft self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_FunctionDraft_Values(self, *args)


    def DerivT(self, *args):
        """
        DerivT(GeomFill_FunctionDraft self, Handle_Adaptor3d_HCurve C, Standard_Real const Param, Standard_Real const W, gp_Vec dN, Standard_Real const teta, math_Vector F) -> Standard_Boolean

        returns the values <F> of the T derivatives for
        the parameter Param .

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type Param: float
        :type W: float
        :type dN: OCC.wrapper.gp.gp_Vec
        :type teta: float
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_FunctionDraft_DerivT(self, *args)


    def Deriv2T(self, *args):
        """
        Deriv2T(GeomFill_FunctionDraft self, Handle_Adaptor3d_HCurve C, Standard_Real const Param, Standard_Real const W, gp_Vec d2N, Standard_Real const teta, math_Vector F) -> Standard_Boolean

        returns the values <F> of the T2 derivatives for
        the parameter Param .

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type Param: float
        :type W: float
        :type d2N: OCC.wrapper.gp.gp_Vec
        :type teta: float
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_FunctionDraft_Deriv2T(self, *args)


    def DerivTX(self, *args):
        """
        DerivTX(GeomFill_FunctionDraft self, gp_Vec dN, Standard_Real const teta, math_Matrix D) -> Standard_Boolean

        returns the values <D> of  the TX derivatives for
        the parameter Param .

        :type dN: OCC.wrapper.gp.gp_Vec
        :type teta: float
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_FunctionDraft_DerivTX(self, *args)


    def Deriv2X(self, *args):
        """
        Deriv2X(GeomFill_FunctionDraft self, math_Vector X, GeomFill_Tensor T) -> Standard_Boolean

        returns the values <T> of  the X2 derivatives for
        the parameter Param .

        :type X: OCC.wrapper.math.math_Vector
        :type T: OCC.wrapper.GeomFill.GeomFill_Tensor
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_FunctionDraft_Deriv2X(self, *args)

    __swig_destroy__ = _GeomFill.delete_GeomFill_FunctionDraft
GeomFill_FunctionDraft_swigregister = _GeomFill.GeomFill_FunctionDraft_swigregister
GeomFill_FunctionDraft_swigregister(GeomFill_FunctionDraft)

class Handle_GeomFill_SectionLaw(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_SectionLaw self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_SectionLaw_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_SectionLaw self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_SectionLaw self, GeomFill_SectionLaw thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_SectionLaw self, Handle_GeomFill_SectionLaw theHandle) -> Handle_GeomFill_SectionLaw
        assign(Handle_GeomFill_SectionLaw self, GeomFill_SectionLaw thePtr) -> Handle_GeomFill_SectionLaw
        assign(Handle_GeomFill_SectionLaw self, Handle_GeomFill_SectionLaw theHandle) -> Handle_GeomFill_SectionLaw

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_SectionLaw self) -> GeomFill_SectionLaw

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_SectionLaw self) -> GeomFill_SectionLaw

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_SectionLaw___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_SectionLaw self) -> GeomFill_SectionLaw

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_SectionLaw___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_SectionLaw___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_SectionLaw___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_SectionLaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_SectionLaw_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_SectionLaw

    def D0(self, *args):
        """
        D0(Handle_GeomFill_SectionLaw self, Standard_Real const Param, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weigths) -> Standard_Boolean

        compute the section for v = param

        :type Param: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_SectionLaw self, Standard_Real const Param, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean

        compute the first  derivative in v direction  of the
        section for v =  param
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_GeomFill_SectionLaw self, Standard_Real const Param, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        compute the second derivative  in v direction of the
        section  for v = param
        Warning : It used only for C2 aproximation

        :type Param: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_D2(self, *args)


    def BSplineSurface(self, *args):
        """
        BSplineSurface(Handle_GeomFill_SectionLaw self) -> Handle_Geom_BSplineSurface

        give if possible an bspline Surface, like iso-v are the
        section.   If it is  not possible this  methode have to
        get an Null Surface. It is the default  implementation.

        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_BSplineSurface(self, *args)


    def SectionShape(self, *args):
        """
        SectionShape(Handle_GeomFill_SectionLaw self)

        get the format of an  section

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_SectionShape(self, *args)


    def Knots(self, *args):
        """
        Knots(Handle_GeomFill_SectionLaw self, NCollection_Array1_Standard_Real TKnots)

        get the Knots of the section

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(Handle_GeomFill_SectionLaw self, NCollection_Array1_Standard_Integer TMults)

        get the Multplicities of the section

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_Mults(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Handle_GeomFill_SectionLaw self) -> Standard_Boolean

        Returns if the sections are rationnal or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_IsRational(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Handle_GeomFill_SectionLaw self) -> Standard_Boolean

        Returns if the sections are periodic or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Handle_GeomFill_SectionLaw self) -> Standard_Boolean

        Returns if law is periodic or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_IsVPeriodic(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_GeomFill_SectionLaw self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_GeomFill_SectionLaw self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Handle_GeomFill_SectionLaw self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_SetInterval(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(Handle_GeomFill_SectionLaw self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_GetInterval(self, *args)


    def GetDomain(self, *args):
        """
        GetDomain(Handle_GeomFill_SectionLaw self)

        Gets the bounds of the function parametric domain.
        Warning: This domain it is  not modified by the
        SetValue method

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_GetDomain(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(Handle_GeomFill_SectionLaw self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, NCollection_Array1_Standard_Real Tol3d)

        Returns the tolerances associated at each poles to
        reach  in approximation, to satisfy: BoundTol error
        at the   Boundary  AngleTol tangent error  at  the
        Boundary  (in radian)  SurfTol   error inside the
        surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_GetTolerance(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_GeomFill_SectionLaw self, Standard_Real const Tol3d, Standard_Real const Tol2d)

        Is  usefull, if (me)  have to run  numerical
        algorithm  to perform D0,  D1 or D2
        The default implementation make nothing.

        :type Tol3d: float
        :type Tol2d: float

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_SetTolerance(self, *args)


    def BarycentreOfSurf(self, *args):
        """
        BarycentreOfSurf(Handle_GeomFill_SectionLaw self) -> gp_Pnt

        Get the barycentre of Surface.
        An   very  poor estimation is sufficent.
        This information is usefull to perform well
        conditioned rational approximation.
        Warning: Used only if <me> IsRational

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_BarycentreOfSurf(self, *args)


    def MaximalSection(self, *args):
        """
        MaximalSection(Handle_GeomFill_SectionLaw self) -> Standard_Real

        Returns the   length of the greater section. This
        information is usefull to G1's control.
        Warning: With an little value, approximation can be slower.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_MaximalSection(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(Handle_GeomFill_SectionLaw self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        in all  sections.
        This information is  usefull to control error
        in rational approximation.
        Warning: Used only if <me> IsRational

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_GetMinimalWeight(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(Handle_GeomFill_SectionLaw self) -> Standard_Boolean

        Say if all sections are equals

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_IsConstant(self, *args)


    def ConstantSection(self, *args):
        """
        ConstantSection(Handle_GeomFill_SectionLaw self) -> Handle_Geom_Curve

        Return a  copy of the  constant Section,  if me
        IsConstant

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_ConstantSection(self, *args)


    def IsConicalLaw(self, *args):
        """
        IsConicalLaw(Handle_GeomFill_SectionLaw self) -> Standard_Boolean

        Returns True if all section  are circle, with same
        plane,same center and  linear  radius  evolution
        Return False by Default.

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_IsConicalLaw(self, *args)


    def CirclSection(self, *args):
        """
        CirclSection(Handle_GeomFill_SectionLaw self, Standard_Real const Param) -> Handle_Geom_Curve

        Return the circle section  at parameter <Param>, if
        <me> a  IsConicalLaw

        :type Param: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_CirclSection(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_SectionLaw self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_SectionLaw_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_SectionLaw_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_SectionLaw self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_SectionLaw_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_SectionLaw self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_SectionLaw self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_SectionLaw self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_SectionLaw self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_SectionLaw self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_SectionLaw self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_SectionLaw self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_SectionLaw_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_SectionLaw self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_SectionLaw_DecrementRefCounter(self, *args)

Handle_GeomFill_SectionLaw_swigregister = _GeomFill.Handle_GeomFill_SectionLaw_swigregister
Handle_GeomFill_SectionLaw_swigregister(Handle_GeomFill_SectionLaw)

def Handle_GeomFill_SectionLaw_DownCast(thing):
    return _GeomFill.Handle_GeomFill_SectionLaw_DownCast(thing)
Handle_GeomFill_SectionLaw_DownCast = _GeomFill.Handle_GeomFill_SectionLaw_DownCast

class GeomFill_Darboux(GeomFill_TrihedronLaw):
    """Defines Darboux case of Frenet Trihedron Law"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_Darboux
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_Darboux(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GeomFill_Darboux self) -> GeomFill_Darboux

        Defines Darboux case of Frenet Trihedron Law
        """
        this = _GeomFill.new_GeomFill_Darboux(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Copy(self, *args):
        """
        Copy(GeomFill_Darboux self) -> Handle_GeomFill_TrihedronLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_TrihedronLaw

        """
        return _GeomFill.GeomFill_Darboux_Copy(self, *args)


    def D0(self, *args):
        """
        D0(GeomFill_Darboux self, Standard_Real const Param, gp_Vec Tangent, gp_Vec Normal, gp_Vec BiNormal) -> Standard_Boolean

        compute Triedrhon on curve at parameter <Param>

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_Darboux_D0(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_Darboux self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec BiNormal, gp_Vec DBiNormal) -> Standard_Boolean

        compute Triedrhon and  derivative Trihedron  on curve
        at parameter <Param>
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_Darboux_D1(self, *args)


    def D2(self, *args):
        """
        D2(GeomFill_Darboux self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec D2Tangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec D2Normal, gp_Vec BiNormal, gp_Vec DBiNormal, gp_Vec D2BiNormal) -> Standard_Boolean

        compute  Trihedron on curve
        first and seconde  derivatives.
        Warning : It used only for C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type D2Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type D2Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :type D2BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_Darboux_D2(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(GeomFill_Darboux self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_Darboux_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(GeomFill_Darboux self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.GeomFill_Darboux_Intervals(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(GeomFill_Darboux self, gp_Vec ATangent, gp_Vec ANormal, gp_Vec ABiNormal)

        Get average value of Tangent(t) and Normal(t) it is usfull to
        make fast approximation of rational  surfaces.

        :type ATangent: OCC.wrapper.gp.gp_Vec
        :type ANormal: OCC.wrapper.gp.gp_Vec
        :type ABiNormal: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_Darboux_GetAverageLaw(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(GeomFill_Darboux self) -> Standard_Boolean

        Say if the law is Constant.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_Darboux_IsConstant(self, *args)


    def IsOnlyBy3dCurve(self, *args):
        """
        IsOnlyBy3dCurve(GeomFill_Darboux self) -> Standard_Boolean

        Return False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_Darboux_IsOnlyBy3dCurve(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_Darboux_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_Darboux_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_Darboux_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_Darboux
GeomFill_Darboux_swigregister = _GeomFill.GeomFill_Darboux_swigregister
GeomFill_Darboux_swigregister(GeomFill_Darboux)

def GeomFill_Darboux_get_type_name(*args):
    """
    GeomFill_Darboux_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_Darboux_get_type_name(*args)

def GeomFill_Darboux_get_type_descriptor(*args):
    """
    GeomFill_Darboux_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_Darboux_get_type_descriptor(*args)

class GeomFill_ConstrainedFilling(object):
    """
    An algorithm for constructing a BSpline surface filled
    from a series of boundaries which serve as path
    constraints and optionally, as tangency constraints.
    The algorithm accepts three or four curves as the
    boundaries of the target surface.
    The only FillingStyle used is Coons.
    A ConstrainedFilling object provides a framework for:
    -   defining the boundaries of the surface
    -   implementing the construction algorithm
    -   consulting the result.
    Warning
    This surface filling algorithm is specifically designed to
    be used in connection with fillets. Satisfactory results
    cannot be guaranteed for other uses.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomFill_ConstrainedFilling self, Standard_Integer const MaxDeg, Standard_Integer const MaxSeg) -> GeomFill_ConstrainedFilling

        Constructs an empty framework for filling a surface from boundaries.
        The boundaries of the surface will be defined, and the
        surface will be built by using the function Init.
        The surface will respect the following constraints:
        -   its degree will not be greater than MaxDeg
        -   the maximum number of segments MaxSeg which
        BSpline surfaces can have.

        :type MaxDeg: int
        :type MaxSeg: int

        """
        this = _GeomFill.new_GeomFill_ConstrainedFilling(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(GeomFill_ConstrainedFilling self, Handle_GeomFill_Boundary B1, Handle_GeomFill_Boundary B2, Handle_GeomFill_Boundary B3, Standard_Boolean const NoCheck)
        Init(GeomFill_ConstrainedFilling self, Handle_GeomFill_Boundary B1, Handle_GeomFill_Boundary B2, Handle_GeomFill_Boundary B3, Handle_GeomFill_Boundary B4, Standard_Boolean const NoCheck)

        Constructs a BSpline surface filled from the series of
        boundaries B1, B2, B3 and, if need be, B4, which serve:
        -   as path constraints
        -   and optionally, as tangency constraints if they are
        GeomFill_BoundWithSurf curves.
        The boundaries may be given in any order: they are
        classified and if necessary, reversed and reparameterized.
        The surface will also respect the following constraints:
        -   its degree will not be greater than the maximum
        degree defined at the time of construction of this framework, and
        -   the maximum number of segments MaxSeg which BSpline surfaces can have

        :type B1: OCC.wrapper.GeomFill.Handle_GeomFill_Boundary
        :type B2: OCC.wrapper.GeomFill.Handle_GeomFill_Boundary
        :type B3: OCC.wrapper.GeomFill.Handle_GeomFill_Boundary
        :type B4: OCC.wrapper.GeomFill.Handle_GeomFill_Boundary
        :type NoCheck: bool

        """
        return _GeomFill.GeomFill_ConstrainedFilling_Init(self, *args)


    def SetDomain(self, *args):
        """
        SetDomain(GeomFill_ConstrainedFilling self, Standard_Real const l, Handle_GeomFill_BoundWithSurf B)

        Allows to modify domain on witch the blending function
        associated to  the constrained boundary B  will propag
        the  influence   of the  field   of  tangency.  Can be
        usefull to  reduce  influence of boundaries  on whitch
        the Coons compatibility  conditions are not respected.
        l is a  relative value of  the parametric range of  B.
        Default value for l is 1 (used in Init).
        Warning: Must be called after  Init with a constrained boundary
        used in the call to Init.

        :type l: float
        :type B: OCC.wrapper.GeomFill.Handle_GeomFill_BoundWithSurf

        """
        return _GeomFill.GeomFill_ConstrainedFilling_SetDomain(self, *args)


    def ReBuild(self, *args):
        """
        ReBuild(GeomFill_ConstrainedFilling self)

        Computes the  new poles  of  the surface using the  new
        blending  functions set by several calls to SetDomain.


        """
        return _GeomFill.GeomFill_ConstrainedFilling_ReBuild(self, *args)


    def Boundary(self, *args):
        """
        Boundary(GeomFill_ConstrainedFilling self, Standard_Integer const I) -> Handle_GeomFill_Boundary

        Returns the bound of index i after sort.

        :type I: int
        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_Boundary

        """
        return _GeomFill.GeomFill_ConstrainedFilling_Boundary(self, *args)


    def Surface(self, *args):
        """
        Surface(GeomFill_ConstrainedFilling self) -> Handle_Geom_BSplineSurface

        Returns the BSpline surface after computation of the fill by this framework.

        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

        """
        return _GeomFill.GeomFill_ConstrainedFilling_Surface(self, *args)


    def Eval(self, *args):
        """
        Eval(GeomFill_ConstrainedFilling self, Standard_Real const W, Standard_Integer const Ord) -> Standard_Integer

        Internal use for Advmath approximation call.

        :type W: float
        :type Ord: int
        :type Result: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_ConstrainedFilling_Eval(self, *args)


    def CheckCoonsAlgPatch(self, *args):
        """
        CheckCoonsAlgPatch(GeomFill_ConstrainedFilling self, Standard_Integer const I)

        Computes the fields of tangents on 30 points along the
        bound  I, these  are  not the  constraint tangents but
        gives an idea of the coonsAlgPatch regularity.

        :type I: int

        """
        return _GeomFill.GeomFill_ConstrainedFilling_CheckCoonsAlgPatch(self, *args)


    def CheckTgteField(self, *args):
        """
        CheckTgteField(GeomFill_ConstrainedFilling self, Standard_Integer const I)

        Computes  the fields  of tangents  and  normals on  30
        points along the bound  I, draw them, and computes the
        max dot product that must be near than 0.

        :type I: int

        """
        return _GeomFill.GeomFill_ConstrainedFilling_CheckTgteField(self, *args)


    def CheckApprox(self, *args):
        """
        CheckApprox(GeomFill_ConstrainedFilling self, Standard_Integer const I)

        Computes  values  and normals  along  the bound  I and
        compare  them to the  approx  result curves (bound and
        tgte field) , draw  the normals and tangents.

        :type I: int

        """
        return _GeomFill.GeomFill_ConstrainedFilling_CheckApprox(self, *args)


    def CheckResult(self, *args):
        """
        CheckResult(GeomFill_ConstrainedFilling self, Standard_Integer const I)

        Computes values and normals along the  bound I on both
        constraint  surface    and result  surface,  draw  the
        normals, and  computes the max distance between values
        and the max angle  between normals.

        :type I: int

        """
        return _GeomFill.GeomFill_ConstrainedFilling_CheckResult(self, *args)

    __swig_destroy__ = _GeomFill.delete_GeomFill_ConstrainedFilling
GeomFill_ConstrainedFilling_swigregister = _GeomFill.GeomFill_ConstrainedFilling_swigregister
GeomFill_ConstrainedFilling_swigregister(GeomFill_ConstrainedFilling)

class GeomFill_SweepFunction(Approx.Approx_SweepFunction):
    """
    Function to approximate by SweepApproximation from
    Approx. To bulid general sweep Surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_SweepFunction
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_SweepFunction(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GeomFill_SweepFunction self, Handle_GeomFill_SectionLaw Section, Handle_GeomFill_LocationLaw Location, Standard_Real const FirstParameter, Standard_Real const FirstParameterOnS, Standard_Real const RatioParameterOnS) -> GeomFill_SweepFunction

        :type Section: OCC.wrapper.GeomFill.Handle_GeomFill_SectionLaw
        :type Location: OCC.wrapper.GeomFill.Handle_GeomFill_LocationLaw
        :type FirstParameter: float
        :type FirstParameterOnS: float
        :type RatioParameterOnS: float

        """
        this = _GeomFill.new_GeomFill_SweepFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def D0(self, *args):
        """
        D0(GeomFill_SweepFunction self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths) -> Standard_Boolean

        compute the section for v = param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_SweepFunction_D0(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_SweepFunction self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean

        compute the first  derivative in v direction  of the
        section for v =  param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_SweepFunction_D1(self, *args)


    def D2(self, *args):
        """
        D2(GeomFill_SweepFunction self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        compute the second derivative  in v direction of the
        section  for v = param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type D2Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_SweepFunction_D2(self, *args)


    def Nb2dCurves(self, *args):
        """
        Nb2dCurves(GeomFill_SweepFunction self) -> Standard_Integer

        get the number of 2d curves to  approximate.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_SweepFunction_Nb2dCurves(self, *args)


    def SectionShape(self, *args):
        """
        SectionShape(GeomFill_SweepFunction self)

        get the format of an  section

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int

        """
        return _GeomFill.GeomFill_SweepFunction_SectionShape(self, *args)


    def Knots(self, *args):
        """
        Knots(GeomFill_SweepFunction self, NCollection_Array1_Standard_Real TKnots)

        get the Knots of the section

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_SweepFunction_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(GeomFill_SweepFunction self, NCollection_Array1_Standard_Integer TMults)

        get the Multplicities of the section

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _GeomFill.GeomFill_SweepFunction_Mults(self, *args)


    def IsRational(self, *args):
        """
        IsRational(GeomFill_SweepFunction self) -> Standard_Boolean

        Returns if the section is rationnal or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_SweepFunction_IsRational(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(GeomFill_SweepFunction self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_SweepFunction_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(GeomFill_SweepFunction self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.GeomFill_SweepFunction_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(GeomFill_SweepFunction self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_SweepFunction_SetInterval(self, *args)


    def Resolution(self, *args):
        """
        Resolution(GeomFill_SweepFunction self, Standard_Integer const Index, Standard_Real const Tol)

        Returns the resolutions in the  sub-space 2d <Index>
        This information is usfull to find an good tolerance in
        2d approximation.
        Warning: Used only if Nb2dCurve > 0

        :type Index: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _GeomFill.GeomFill_SweepFunction_Resolution(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(GeomFill_SweepFunction self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, NCollection_Array1_Standard_Real Tol3d)

        Returns the tolerance to reach in approximation
        to respecte
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary (in radian)
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_SweepFunction_GetTolerance(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(GeomFill_SweepFunction self, Standard_Real const Tol3d, Standard_Real const Tol2d)

        Is usfull, if (me) have to  be run numerical
        algorithme to perform D0, D1 or D2

        :type Tol3d: float
        :type Tol2d: float

        """
        return _GeomFill.GeomFill_SweepFunction_SetTolerance(self, *args)


    def BarycentreOfSurf(self, *args):
        """
        BarycentreOfSurf(GeomFill_SweepFunction self) -> gp_Pnt

        Get    the   barycentre of   Surface.   An   very  poor
        estimation is sufficent. This information is usefull
        to perform well conditionned rational approximation.
        Warning: Used only if <me> IsRational

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.GeomFill_SweepFunction_BarycentreOfSurf(self, *args)


    def MaximalSection(self, *args):
        """
        MaximalSection(GeomFill_SweepFunction self) -> Standard_Real

        Returns the   length of the maximum section. This
        information is usefull to perform well conditionned rational
        approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_SweepFunction_MaximalSection(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(GeomFill_SweepFunction self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        of all  sections.  This information is  usefull to
        perform well conditionned rational approximation.
        Warning: Used only if <me> IsRational

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_SweepFunction_GetMinimalWeight(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_SweepFunction_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_SweepFunction_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_SweepFunction_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_SweepFunction
GeomFill_SweepFunction_swigregister = _GeomFill.GeomFill_SweepFunction_swigregister
GeomFill_SweepFunction_swigregister(GeomFill_SweepFunction)

def GeomFill_SweepFunction_get_type_name(*args):
    """
    GeomFill_SweepFunction_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_SweepFunction_get_type_name(*args)

def GeomFill_SweepFunction_get_type_descriptor(*args):
    """
    GeomFill_SweepFunction_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_SweepFunction_get_type_descriptor(*args)

class GeomFill_PlanFunc(math.math_FunctionWithDerivative):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomFill_PlanFunc self, gp_Pnt P, gp_Vec V, Handle_Adaptor3d_HCurve C) -> GeomFill_PlanFunc

        :type P: OCC.wrapper.gp.gp_Pnt
        :type V: OCC.wrapper.gp.gp_Vec
        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        this = _GeomFill.new_GeomFill_PlanFunc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Value(GeomFill_PlanFunc self, Standard_Real const X) -> Standard_Boolean

        computes the value <F>of the function for the variable <X>.
        Returns True if the calculation were successfully done,
        False otherwise.

        :type X: float
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_PlanFunc_Value(self, *args)


    def Derivative(self, *args):
        """
        Derivative(GeomFill_PlanFunc self, Standard_Real const X) -> Standard_Boolean

        computes the derivative <D> of the function
        for the variable <X>.
        Returns True if the calculation were successfully done,
        False otherwise.

        :type X: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_PlanFunc_Derivative(self, *args)


    def Values(self, *args):
        """
        Values(GeomFill_PlanFunc self, Standard_Real const X) -> Standard_Boolean

        computes the value <F> and the derivative <D> of the
        function for the variable <X>.
        Returns True if the calculation were successfully done,
        False otherwise.

        :type X: float
        :type F: float
        :type D: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_PlanFunc_Values(self, *args)


    def D2(self, *args):
        """
        D2(GeomFill_PlanFunc self, Standard_Real const X)

        :type X: float
        :type F: float
        :type D1: float
        :type D2: float

        """
        return _GeomFill.GeomFill_PlanFunc_D2(self, *args)


    def DEDT(self, *args):
        """
        DEDT(GeomFill_PlanFunc self, Standard_Real const X, gp_Vec DP, gp_Vec DV)

        :type X: float
        :type DP: OCC.wrapper.gp.gp_Vec
        :type DV: OCC.wrapper.gp.gp_Vec
        :type DF: float

        """
        return _GeomFill.GeomFill_PlanFunc_DEDT(self, *args)


    def D2E(self, *args):
        """
        D2E(GeomFill_PlanFunc self, Standard_Real const X, gp_Vec DP, gp_Vec D2P, gp_Vec DV, gp_Vec D2V)

        :type X: float
        :type DP: OCC.wrapper.gp.gp_Vec
        :type D2P: OCC.wrapper.gp.gp_Vec
        :type DV: OCC.wrapper.gp.gp_Vec
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type DFDT: float
        :type D2FDT2: float
        :type D2FDTDX: float

        """
        return _GeomFill.GeomFill_PlanFunc_D2E(self, *args)

    __swig_destroy__ = _GeomFill.delete_GeomFill_PlanFunc
GeomFill_PlanFunc_swigregister = _GeomFill.GeomFill_PlanFunc_swigregister
GeomFill_PlanFunc_swigregister(GeomFill_PlanFunc)

class GeomFill_Curved(GeomFill_Filling):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomFill_Curved self) -> GeomFill_Curved
        __init__(GeomFill_Curved self, NCollection_Array1_gp_Pnt P1, NCollection_Array1_gp_Pnt P2, NCollection_Array1_gp_Pnt P3, NCollection_Array1_gp_Pnt P4) -> GeomFill_Curved
        __init__(GeomFill_Curved self, NCollection_Array1_gp_Pnt P1, NCollection_Array1_gp_Pnt P2, NCollection_Array1_gp_Pnt P3, NCollection_Array1_gp_Pnt P4, NCollection_Array1_Standard_Real W1, NCollection_Array1_Standard_Real W2, NCollection_Array1_Standard_Real W3, NCollection_Array1_Standard_Real W4) -> GeomFill_Curved
        __init__(GeomFill_Curved self, NCollection_Array1_gp_Pnt P1, NCollection_Array1_gp_Pnt P2) -> GeomFill_Curved
        __init__(GeomFill_Curved self, NCollection_Array1_gp_Pnt P1, NCollection_Array1_gp_Pnt P2, NCollection_Array1_Standard_Real W1, NCollection_Array1_Standard_Real W2) -> GeomFill_Curved

        :type P1: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type P2: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type W1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type W2: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        this = _GeomFill.new_GeomFill_Curved(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(GeomFill_Curved self, NCollection_Array1_gp_Pnt P1, NCollection_Array1_gp_Pnt P2, NCollection_Array1_gp_Pnt P3, NCollection_Array1_gp_Pnt P4)
        Init(GeomFill_Curved self, NCollection_Array1_gp_Pnt P1, NCollection_Array1_gp_Pnt P2, NCollection_Array1_gp_Pnt P3, NCollection_Array1_gp_Pnt P4, NCollection_Array1_Standard_Real W1, NCollection_Array1_Standard_Real W2, NCollection_Array1_Standard_Real W3, NCollection_Array1_Standard_Real W4)
        Init(GeomFill_Curved self, NCollection_Array1_gp_Pnt P1, NCollection_Array1_gp_Pnt P2)
        Init(GeomFill_Curved self, NCollection_Array1_gp_Pnt P1, NCollection_Array1_gp_Pnt P2, NCollection_Array1_Standard_Real W1, NCollection_Array1_Standard_Real W2)

        :type P1: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type P2: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type W1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type W2: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_Curved_Init(self, *args)

    __swig_destroy__ = _GeomFill.delete_GeomFill_Curved
GeomFill_Curved_swigregister = _GeomFill.GeomFill_Curved_swigregister
GeomFill_Curved_swigregister(GeomFill_Curved)

class NCollection_Sequence_gp_Ax2(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_gp_Ax2 self) -> NCollection_Sequence< gp_Ax2 >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _GeomFill.NCollection_Sequence_gp_Ax2_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_gp_Ax2 self) -> NCollection_Sequence< gp_Ax2 >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _GeomFill.NCollection_Sequence_gp_Ax2_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_gp_Ax2 self) -> NCollection_Sequence< gp_Ax2 >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _GeomFill.NCollection_Sequence_gp_Ax2_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_gp_Ax2 self) -> NCollection_Sequence< gp_Ax2 >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _GeomFill.NCollection_Sequence_gp_Ax2_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _GeomFill.new_NCollection_Sequence_gp_Ax2(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_gp_Ax2 self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.NCollection_Sequence_gp_Ax2_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_gp_Ax2 self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.NCollection_Sequence_gp_Ax2_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_gp_Ax2 self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.NCollection_Sequence_gp_Ax2_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_gp_Ax2 self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.NCollection_Sequence_gp_Ax2_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_gp_Ax2 self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.NCollection_Sequence_gp_Ax2_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_gp_Ax2 self)

        Reverse sequence


        """
        return _GeomFill.NCollection_Sequence_gp_Ax2_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_gp_Ax2 self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _GeomFill.NCollection_Sequence_gp_Ax2_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _GeomFill.NCollection_Sequence_gp_Ax2_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_gp_Ax2 self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _GeomFill.NCollection_Sequence_gp_Ax2_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_gp_Ax2 self, NCollection_Sequence_gp_Ax2 theOther) -> NCollection_Sequence_gp_Ax2

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _GeomFill.NCollection_Sequence_gp_Ax2_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_gp_Ax2 self, NCollection_Sequence_gp_Ax2 theOther) -> NCollection_Sequence_gp_Ax2

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _GeomFill.NCollection_Sequence_gp_Ax2_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_gp_Ax2 self, NCollection_Sequence< gp_Ax2 >::Iterator & thePosition)
        Remove(NCollection_Sequence_gp_Ax2 self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_gp_Ax2 self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _GeomFill.NCollection_Sequence_gp_Ax2_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_gp_Ax2 self, gp_Ax2 theItem)
        Append(NCollection_Sequence_gp_Ax2 self, NCollection_Sequence_gp_Ax2 theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _GeomFill.NCollection_Sequence_gp_Ax2_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_gp_Ax2 self, gp_Ax2 theItem)
        Prepend(NCollection_Sequence_gp_Ax2 self, NCollection_Sequence_gp_Ax2 theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _GeomFill.NCollection_Sequence_gp_Ax2_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_gp_Ax2 self, Standard_Integer const theIndex, gp_Ax2 theItem)
        InsertBefore(NCollection_Sequence_gp_Ax2 self, Standard_Integer const theIndex, NCollection_Sequence_gp_Ax2 theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _GeomFill.NCollection_Sequence_gp_Ax2_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_gp_Ax2 self, NCollection_Sequence< gp_Ax2 >::Iterator & thePosition, gp_Ax2 theItem)
        InsertAfter(NCollection_Sequence_gp_Ax2 self, Standard_Integer const theIndex, NCollection_Sequence_gp_Ax2 theSeq)
        InsertAfter(NCollection_Sequence_gp_Ax2 self, Standard_Integer const theIndex, gp_Ax2 theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _GeomFill.NCollection_Sequence_gp_Ax2_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_gp_Ax2 self, Standard_Integer const theIndex, NCollection_Sequence_gp_Ax2 theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _GeomFill.NCollection_Sequence_gp_Ax2_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _GeomFill.NCollection_Sequence_gp_Ax2_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_gp_Ax2 self) -> gp_Ax2

        First item access

        :rtype: TheItemType &

        """
        return _GeomFill.NCollection_Sequence_gp_Ax2_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _GeomFill.NCollection_Sequence_gp_Ax2_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_gp_Ax2 self) -> gp_Ax2

        Last item access

        :rtype: TheItemType &

        """
        return _GeomFill.NCollection_Sequence_gp_Ax2_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GeomFill.NCollection_Sequence_gp_Ax2_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_gp_Ax2 self, Standard_Integer const theIndex) -> gp_Ax2

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _GeomFill.NCollection_Sequence_gp_Ax2_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GeomFill.NCollection_Sequence_gp_Ax2___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_gp_Ax2 self, Standard_Integer const theIndex, gp_Ax2 theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _GeomFill.NCollection_Sequence_gp_Ax2_SetValue(self, *args)


    def __iter__(self):
        return _GeomFill.NCollection_Sequence_gp_Ax2___iter__(self)
    __swig_destroy__ = _GeomFill.delete_NCollection_Sequence_gp_Ax2
NCollection_Sequence_gp_Ax2_swigregister = _GeomFill.NCollection_Sequence_gp_Ax2_swigregister
NCollection_Sequence_gp_Ax2_swigregister(NCollection_Sequence_gp_Ax2)

def NCollection_Sequence_gp_Ax2_delNode(*args):
    """
    NCollection_Sequence_gp_Ax2_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _GeomFill.NCollection_Sequence_gp_Ax2_delNode(*args)

class NCollection_Sequence_gp_Ax2_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _GeomFill.new_NCollection_Sequence_gp_Ax2_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GeomFill.delete_NCollection_Sequence_gp_Ax2_IteratorHelper

    def __next__(self):
        return _GeomFill.NCollection_Sequence_gp_Ax2_IteratorHelper___next__(self)
NCollection_Sequence_gp_Ax2_IteratorHelper_swigregister = _GeomFill.NCollection_Sequence_gp_Ax2_IteratorHelper_swigregister
NCollection_Sequence_gp_Ax2_IteratorHelper_swigregister(NCollection_Sequence_gp_Ax2_IteratorHelper)


try:
	GeomFill_SequenceOfAx2 = NCollection_Sequence_gp_Ax2
except NameError:
	pass # does not exist, probably ignored

class Handle_GeomFill_NSections(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_NSections self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_NSections_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_NSections self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_NSections_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_NSections self, GeomFill_NSections thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_NSections_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_NSections self, Handle_GeomFill_NSections theHandle) -> Handle_GeomFill_NSections
        assign(Handle_GeomFill_NSections self, GeomFill_NSections thePtr) -> Handle_GeomFill_NSections
        assign(Handle_GeomFill_NSections self, Handle_GeomFill_NSections theHandle) -> Handle_GeomFill_NSections

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_NSections_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_NSections self) -> GeomFill_NSections

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_NSections_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_NSections self) -> GeomFill_NSections

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_NSections___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_NSections self) -> GeomFill_NSections

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_NSections___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_NSections___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_NSections___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_NSections(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_NSections_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_NSections

    def D0(self, *args):
        """
        D0(Handle_GeomFill_NSections self, Standard_Real const Param, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weigths) -> Standard_Boolean

        compute the section for v = param

        :type Param: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_NSections_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_NSections self, Standard_Real const Param, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean

        compute the first  derivative in v direction  of the
        section for v =  param
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_NSections_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_GeomFill_NSections self, Standard_Real const Param, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        compute the second derivative  in v direction of the
        section  for v = param
        Warning : It used only for C2 aproximation

        :type Param: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_NSections_D2(self, *args)


    def SetSurface(self, *args):
        """
        SetSurface(Handle_GeomFill_NSections self, Handle_Geom_BSplineSurface RefSurf)

        Sets the reference surface

        :type RefSurf: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

        """
        return _GeomFill.Handle_GeomFill_NSections_SetSurface(self, *args)


    def ComputeSurface(self, *args):
        """
        ComputeSurface(Handle_GeomFill_NSections self)

        Computes the surface


        """
        return _GeomFill.Handle_GeomFill_NSections_ComputeSurface(self, *args)


    def BSplineSurface(self, *args):
        """
        BSplineSurface(Handle_GeomFill_NSections self) -> Handle_Geom_BSplineSurface

        give if possible an bspline Surface, like iso-v are the
        section.  If it is  not possible  this methode have  to
        get an Null Surface.  Is it the default implementation.

        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

        """
        return _GeomFill.Handle_GeomFill_NSections_BSplineSurface(self, *args)


    def SectionShape(self, *args):
        """
        SectionShape(Handle_GeomFill_NSections self)

        get the format of an  section

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int

        """
        return _GeomFill.Handle_GeomFill_NSections_SectionShape(self, *args)


    def Knots(self, *args):
        """
        Knots(Handle_GeomFill_NSections self, NCollection_Array1_Standard_Real TKnots)

        get the Knots of the section

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.Handle_GeomFill_NSections_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(Handle_GeomFill_NSections self, NCollection_Array1_Standard_Integer TMults)

        get the Multplicities of the section

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _GeomFill.Handle_GeomFill_NSections_Mults(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Handle_GeomFill_NSections self) -> Standard_Boolean

        Returns if the sections are rationnal or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_NSections_IsRational(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Handle_GeomFill_NSections self) -> Standard_Boolean

        Returns if the sections are periodic or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_NSections_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Handle_GeomFill_NSections self) -> Standard_Boolean

        Returns if the law  isperiodic or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_NSections_IsVPeriodic(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_GeomFill_NSections self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_NSections_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_GeomFill_NSections self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.Handle_GeomFill_NSections_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Handle_GeomFill_NSections self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_NSections_SetInterval(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(Handle_GeomFill_NSections self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_NSections_GetInterval(self, *args)


    def GetDomain(self, *args):
        """
        GetDomain(Handle_GeomFill_NSections self)

        Gets the bounds of the function parametric domain.
        Warning: This domain it is  not modified by the
        SetValue method

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_NSections_GetDomain(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(Handle_GeomFill_NSections self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, NCollection_Array1_Standard_Real Tol3d)

        Returns the tolerances associated at each poles to
        reach  in approximation, to satisfy: BoundTol error
        at the   Boundary  AngleTol tangent error  at  the
        Boundary  (in radian)  SurfTol   error inside the
        surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.Handle_GeomFill_NSections_GetTolerance(self, *args)


    def BarycentreOfSurf(self, *args):
        """
        BarycentreOfSurf(Handle_GeomFill_NSections self) -> gp_Pnt

        Get the barycentre of Surface.
        An   very  poor estimation is sufficent.
        This information is usefull to perform well
        conditioned rational approximation.
        Warning: Used only if <me> IsRational

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.Handle_GeomFill_NSections_BarycentreOfSurf(self, *args)


    def MaximalSection(self, *args):
        """
        MaximalSection(Handle_GeomFill_NSections self) -> Standard_Real

        Returns the   length of the greater section. This
        information is usefull to G1's control.
        Warning: With an little value, approximation can be slower.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.Handle_GeomFill_NSections_MaximalSection(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(Handle_GeomFill_NSections self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        in all  sections.
        This information is  usefull to control error
        in rational approximation.
        Warning: Used only if <me> IsRational

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.Handle_GeomFill_NSections_GetMinimalWeight(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(Handle_GeomFill_NSections self) -> Standard_Boolean

        return True If the Law isConstant

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_NSections_IsConstant(self, *args)


    def ConstantSection(self, *args):
        """
        ConstantSection(Handle_GeomFill_NSections self) -> Handle_Geom_Curve

        Return the constant Section if <me>  IsConstant.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _GeomFill.Handle_GeomFill_NSections_ConstantSection(self, *args)


    def IsConicalLaw(self, *args):
        """
        IsConicalLaw(Handle_GeomFill_NSections self) -> Standard_Boolean

        Returns True if all section  are circle, with same
        plane,same center and  linear  radius  evolution
        Return False by Default.

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_NSections_IsConicalLaw(self, *args)


    def CirclSection(self, *args):
        """
        CirclSection(Handle_GeomFill_NSections self, Standard_Real const Param) -> Handle_Geom_Curve

        Return the circle section  at parameter <Param>, if
        <me> a  IsConicalLaw

        :type Param: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _GeomFill.Handle_GeomFill_NSections_CirclSection(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_NSections self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_NSections_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_NSections_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_NSections_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_GeomFill_NSections self, Standard_Real const Tol3d, Standard_Real const Tol2d)

        Is  usefull, if (me)  have to run  numerical
        algorithm  to perform D0,  D1 or D2
        The default implementation make nothing.

        :type Tol3d: float
        :type Tol2d: float

        """
        return _GeomFill.Handle_GeomFill_NSections_SetTolerance(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_NSections self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_NSections_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_NSections self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_NSections self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_NSections_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_NSections self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_NSections self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_NSections_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_NSections self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_NSections_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_NSections self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_NSections_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_NSections self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_NSections_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_NSections self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_NSections_DecrementRefCounter(self, *args)

Handle_GeomFill_NSections_swigregister = _GeomFill.Handle_GeomFill_NSections_swigregister
Handle_GeomFill_NSections_swigregister(Handle_GeomFill_NSections)

def Handle_GeomFill_NSections_DownCast(thing):
    return _GeomFill.Handle_GeomFill_NSections_DownCast(thing)
Handle_GeomFill_NSections_DownCast = _GeomFill.Handle_GeomFill_NSections_DownCast

class GeomFill_DegeneratedBound(GeomFill_Boundary):
    """
    Description of a degenerated boundary (a point).
    Class defining  a degenerated  boundary   for   a
    constrained filling   with  a   point  and  no   other
    constraint. Only used to  simulate an  ordinary bound,
    may not be usefull and desapear soon.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_DegeneratedBound
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_DegeneratedBound(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GeomFill_DegeneratedBound self, gp_Pnt Point, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol3d, Standard_Real const Tolang) -> GeomFill_DegeneratedBound

        :type Point: OCC.wrapper.gp.gp_Pnt
        :type First: float
        :type Last: float
        :type Tol3d: float
        :type Tolang: float

        """
        this = _GeomFill.new_GeomFill_DegeneratedBound(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Value(self, *args):
        """
        Value(GeomFill_DegeneratedBound self, Standard_Real const U) -> gp_Pnt

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.GeomFill_DegeneratedBound_Value(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_DegeneratedBound self, Standard_Real const U, gp_Pnt P, gp_Vec V)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_DegeneratedBound_D1(self, *args)


    def Reparametrize(self, *args):
        """
        Reparametrize(GeomFill_DegeneratedBound self, Standard_Real const First, Standard_Real const Last, Standard_Boolean const HasDF, Standard_Boolean const HasDL, Standard_Real const DF, Standard_Real const DL, Standard_Boolean const Rev)

        :type First: float
        :type Last: float
        :type HasDF: bool
        :type HasDL: bool
        :type DF: float
        :type DL: float
        :type Rev: bool

        """
        return _GeomFill.GeomFill_DegeneratedBound_Reparametrize(self, *args)


    def Bounds(self, *args):
        """
        Bounds(GeomFill_DegeneratedBound self)

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_DegeneratedBound_Bounds(self, *args)


    def IsDegenerated(self, *args):
        """
        IsDegenerated(GeomFill_DegeneratedBound self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_DegeneratedBound_IsDegenerated(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_DegeneratedBound_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_DegeneratedBound_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_DegeneratedBound_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_DegeneratedBound
GeomFill_DegeneratedBound_swigregister = _GeomFill.GeomFill_DegeneratedBound_swigregister
GeomFill_DegeneratedBound_swigregister(GeomFill_DegeneratedBound)

def GeomFill_DegeneratedBound_get_type_name(*args):
    """
    GeomFill_DegeneratedBound_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_DegeneratedBound_get_type_name(*args)

def GeomFill_DegeneratedBound_get_type_descriptor(*args):
    """
    GeomFill_DegeneratedBound_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_DegeneratedBound_get_type_descriptor(*args)

class GeomFill_(object):
    """Tools and Data to filling Surface and Sweep Surfaces"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Surface(*args):
        """
        Surface(Handle_Geom_Curve Curve1, Handle_Geom_Curve Curve2) -> Handle_Geom_Surface

        Builds a ruled surface between the two curves, Curve1 and Curve2.

        :type Curve1: OCC.wrapper.Geom.Handle_Geom_Curve
        :type Curve2: OCC.wrapper.Geom.Handle_Geom_Curve
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _GeomFill.GeomFill__Surface(*args)

    Surface = staticmethod(Surface)

    def GetCircle(*args):
        """
        GetCircle(Convert_ParameterisationType const TConv, gp_Vec ns1, gp_Vec ns2, gp_Vec nplan, gp_Pnt pt1, gp_Pnt pt2, Standard_Real const Rayon, gp_Pnt Center, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weigths)
        GetCircle(Convert_ParameterisationType const TConv, gp_Vec ns1, gp_Vec ns2, gp_Vec dn1w, gp_Vec dn2w, gp_Vec nplan, gp_Vec dnplan, gp_Pnt pts1, gp_Pnt pts2, gp_Vec tang1, gp_Vec tang2, Standard_Real const Rayon, Standard_Real const DRayon, gp_Pnt Center, gp_Vec DCenter, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean
        GetCircle(Convert_ParameterisationType const TConv, gp_Vec ns1, gp_Vec ns2, gp_Vec dn1w, gp_Vec dn2w, gp_Vec d2n1w, gp_Vec d2n2w, gp_Vec nplan, gp_Vec dnplan, gp_Vec d2nplan, gp_Pnt pts1, gp_Pnt pts2, gp_Vec tang1, gp_Vec tang2, gp_Vec Dtang1, gp_Vec Dtang2, Standard_Real const Rayon, Standard_Real const DRayon, Standard_Real const D2Rayon, gp_Pnt Center, gp_Vec DCenter, gp_Vec D2Center, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        :type TConv: OCC.wrapper.Convert.Convert_ParameterisationType
        :type ns1: OCC.wrapper.gp.gp_Vec
        :type ns2: OCC.wrapper.gp.gp_Vec
        :type dn1w: OCC.wrapper.gp.gp_Vec
        :type dn2w: OCC.wrapper.gp.gp_Vec
        :type d2n1w: OCC.wrapper.gp.gp_Vec
        :type d2n2w: OCC.wrapper.gp.gp_Vec
        :type nplan: OCC.wrapper.gp.gp_Vec
        :type dnplan: OCC.wrapper.gp.gp_Vec
        :type d2nplan: OCC.wrapper.gp.gp_Vec
        :type pts1: OCC.wrapper.gp.gp_Pnt
        :type pts2: OCC.wrapper.gp.gp_Pnt
        :type tang1: OCC.wrapper.gp.gp_Vec
        :type tang2: OCC.wrapper.gp.gp_Vec
        :type Dtang1: OCC.wrapper.gp.gp_Vec
        :type Dtang2: OCC.wrapper.gp.gp_Vec
        :type Rayon: float
        :type DRayon: float
        :type D2Rayon: float
        :type Center: OCC.wrapper.gp.gp_Pnt
        :type DCenter: OCC.wrapper.gp.gp_Vec
        :type D2Center: OCC.wrapper.gp.gp_Vec
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill__GetCircle(*args)

    GetCircle = staticmethod(GetCircle)

    def GetShape(*args):
        """
        GetShape(Standard_Real const MaxAng)

        :type MaxAng: float
        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int
        :type TypeConv: OCC.wrapper.Convert.Convert_ParameterisationType

        """
        return _GeomFill.GeomFill__GetShape(*args)

    GetShape = staticmethod(GetShape)

    def Knots(*args):
        """
        Knots(Convert_ParameterisationType const TypeConv, NCollection_Array1_Standard_Real TKnots)

        :type TypeConv: OCC.wrapper.Convert.Convert_ParameterisationType
        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill__Knots(*args)

    Knots = staticmethod(Knots)

    def Mults(*args):
        """
        Mults(Convert_ParameterisationType const TypeConv, NCollection_Array1_Standard_Integer TMults)

        :type TypeConv: OCC.wrapper.Convert.Convert_ParameterisationType
        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _GeomFill.GeomFill__Mults(*args)

    Mults = staticmethod(Mults)

    def GetMinimalWeights(*args):
        """
        GetMinimalWeights(Convert_ParameterisationType const TConv, Standard_Real const AngleMin, Standard_Real const AngleMax, NCollection_Array1_Standard_Real Weigths)

        :type TConv: OCC.wrapper.Convert.Convert_ParameterisationType
        :type AngleMin: float
        :type AngleMax: float
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill__GetMinimalWeights(*args)

    GetMinimalWeights = staticmethod(GetMinimalWeights)

    def GetTolerance(*args):
        """
        GetTolerance(Convert_ParameterisationType const TConv, Standard_Real const AngleMin, Standard_Real const Radius, Standard_Real const AngularTol, Standard_Real const SpatialTol) -> Standard_Real

        Used  by  the  generical classes to determine
        Tolerance for approximation

        :type TConv: OCC.wrapper.Convert.Convert_ParameterisationType
        :type AngleMin: float
        :type Radius: float
        :type AngularTol: float
        :type SpatialTol: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill__GetTolerance(*args)

    GetTolerance = staticmethod(GetTolerance)

    def __init__(self):
        """Tools and Data to filling Surface and Sweep Surfaces"""
        this = _GeomFill.new_GeomFill_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GeomFill.delete_GeomFill_
GeomFill__swigregister = _GeomFill.GeomFill__swigregister
GeomFill__swigregister(GeomFill_)

def GeomFill__Surface(*args):
    """
    GeomFill__Surface(Handle_Geom_Curve Curve1, Handle_Geom_Curve Curve2) -> Handle_Geom_Surface

    Builds a ruled surface between the two curves, Curve1 and Curve2.

    :type Curve1: OCC.wrapper.Geom.Handle_Geom_Curve
    :type Curve2: OCC.wrapper.Geom.Handle_Geom_Curve
    :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

    """
    return _GeomFill.GeomFill__Surface(*args)

def GeomFill__GetCircle(*args):
    """
    GetCircle(Convert_ParameterisationType const TConv, gp_Vec ns1, gp_Vec ns2, gp_Vec nplan, gp_Pnt pt1, gp_Pnt pt2, Standard_Real const Rayon, gp_Pnt Center, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weigths)
    GetCircle(Convert_ParameterisationType const TConv, gp_Vec ns1, gp_Vec ns2, gp_Vec dn1w, gp_Vec dn2w, gp_Vec nplan, gp_Vec dnplan, gp_Pnt pts1, gp_Pnt pts2, gp_Vec tang1, gp_Vec tang2, Standard_Real const Rayon, Standard_Real const DRayon, gp_Pnt Center, gp_Vec DCenter, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean
    GeomFill__GetCircle(Convert_ParameterisationType const TConv, gp_Vec ns1, gp_Vec ns2, gp_Vec dn1w, gp_Vec dn2w, gp_Vec d2n1w, gp_Vec d2n2w, gp_Vec nplan, gp_Vec dnplan, gp_Vec d2nplan, gp_Pnt pts1, gp_Pnt pts2, gp_Vec tang1, gp_Vec tang2, gp_Vec Dtang1, gp_Vec Dtang2, Standard_Real const Rayon, Standard_Real const DRayon, Standard_Real const D2Rayon, gp_Pnt Center, gp_Vec DCenter, gp_Vec D2Center, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

    :type TConv: OCC.wrapper.Convert.Convert_ParameterisationType
    :type ns1: OCC.wrapper.gp.gp_Vec
    :type ns2: OCC.wrapper.gp.gp_Vec
    :type dn1w: OCC.wrapper.gp.gp_Vec
    :type dn2w: OCC.wrapper.gp.gp_Vec
    :type d2n1w: OCC.wrapper.gp.gp_Vec
    :type d2n2w: OCC.wrapper.gp.gp_Vec
    :type nplan: OCC.wrapper.gp.gp_Vec
    :type dnplan: OCC.wrapper.gp.gp_Vec
    :type d2nplan: OCC.wrapper.gp.gp_Vec
    :type pts1: OCC.wrapper.gp.gp_Pnt
    :type pts2: OCC.wrapper.gp.gp_Pnt
    :type tang1: OCC.wrapper.gp.gp_Vec
    :type tang2: OCC.wrapper.gp.gp_Vec
    :type Dtang1: OCC.wrapper.gp.gp_Vec
    :type Dtang2: OCC.wrapper.gp.gp_Vec
    :type Rayon: float
    :type DRayon: float
    :type D2Rayon: float
    :type Center: OCC.wrapper.gp.gp_Pnt
    :type DCenter: OCC.wrapper.gp.gp_Vec
    :type D2Center: OCC.wrapper.gp.gp_Vec
    :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
    :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
    :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
    :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _GeomFill.GeomFill__GetCircle(*args)

def GeomFill__GetShape(*args):
    """
    GeomFill__GetShape(Standard_Real const MaxAng)

    :type MaxAng: float
    :type NbPoles: int
    :type NbKnots: int
    :type Degree: int
    :type TypeConv: OCC.wrapper.Convert.Convert_ParameterisationType

    """
    return _GeomFill.GeomFill__GetShape(*args)

def GeomFill__Knots(*args):
    """
    GeomFill__Knots(Convert_ParameterisationType const TypeConv, NCollection_Array1_Standard_Real TKnots)

    :type TypeConv: OCC.wrapper.Convert.Convert_ParameterisationType
    :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

    """
    return _GeomFill.GeomFill__Knots(*args)

def GeomFill__Mults(*args):
    """
    GeomFill__Mults(Convert_ParameterisationType const TypeConv, NCollection_Array1_Standard_Integer TMults)

    :type TypeConv: OCC.wrapper.Convert.Convert_ParameterisationType
    :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

    """
    return _GeomFill.GeomFill__Mults(*args)

def GeomFill__GetMinimalWeights(*args):
    """
    GeomFill__GetMinimalWeights(Convert_ParameterisationType const TConv, Standard_Real const AngleMin, Standard_Real const AngleMax, NCollection_Array1_Standard_Real Weigths)

    :type TConv: OCC.wrapper.Convert.Convert_ParameterisationType
    :type AngleMin: float
    :type AngleMax: float
    :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

    """
    return _GeomFill.GeomFill__GetMinimalWeights(*args)

def GeomFill__GetTolerance(*args):
    """
    GeomFill__GetTolerance(Convert_ParameterisationType const TConv, Standard_Real const AngleMin, Standard_Real const Radius, Standard_Real const AngularTol, Standard_Real const SpatialTol) -> Standard_Real

    Used  by  the  generical classes to determine
    Tolerance for approximation

    :type TConv: OCC.wrapper.Convert.Convert_ParameterisationType
    :type AngleMin: float
    :type Radius: float
    :type AngularTol: float
    :type SpatialTol: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _GeomFill.GeomFill__GetTolerance(*args)

class Handle_GeomFill_CircularBlendFunc(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_CircularBlendFunc self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_CircularBlendFunc self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_CircularBlendFunc self, GeomFill_CircularBlendFunc thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_CircularBlendFunc self, Handle_GeomFill_CircularBlendFunc theHandle) -> Handle_GeomFill_CircularBlendFunc
        assign(Handle_GeomFill_CircularBlendFunc self, GeomFill_CircularBlendFunc thePtr) -> Handle_GeomFill_CircularBlendFunc
        assign(Handle_GeomFill_CircularBlendFunc self, Handle_GeomFill_CircularBlendFunc theHandle) -> Handle_GeomFill_CircularBlendFunc

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_CircularBlendFunc self) -> GeomFill_CircularBlendFunc

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_CircularBlendFunc self) -> GeomFill_CircularBlendFunc

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_CircularBlendFunc self) -> GeomFill_CircularBlendFunc

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_CircularBlendFunc___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_CircularBlendFunc___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_CircularBlendFunc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_CircularBlendFunc_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_CircularBlendFunc

    def D0(self, *args):
        """
        D0(Handle_GeomFill_CircularBlendFunc self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths) -> Standard_Boolean

        compute the section for v = param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_CircularBlendFunc self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean

        compute the first  derivative in v direction  of the
        section for v =  param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_GeomFill_CircularBlendFunc self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        compute the second derivative  in v direction of the
        section  for v = param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type D2Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_D2(self, *args)


    def Nb2dCurves(self, *args):
        """
        Nb2dCurves(Handle_GeomFill_CircularBlendFunc self) -> Standard_Integer

        get the number of 2d curves to  approximate.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_Nb2dCurves(self, *args)


    def SectionShape(self, *args):
        """
        SectionShape(Handle_GeomFill_CircularBlendFunc self)

        get the format of an  section

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_SectionShape(self, *args)


    def Knots(self, *args):
        """
        Knots(Handle_GeomFill_CircularBlendFunc self, NCollection_Array1_Standard_Real TKnots)

        get the Knots of the section

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(Handle_GeomFill_CircularBlendFunc self, NCollection_Array1_Standard_Integer TMults)

        get the Multplicities of the section

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_Mults(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Handle_GeomFill_CircularBlendFunc self) -> Standard_Boolean

        Returns if the section is rationnal or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_IsRational(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_GeomFill_CircularBlendFunc self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_GeomFill_CircularBlendFunc self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Handle_GeomFill_CircularBlendFunc self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the fonction
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_SetInterval(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(Handle_GeomFill_CircularBlendFunc self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, NCollection_Array1_Standard_Real Tol3d)

        Returns the tolerance to reach in approximation
        to respecte
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary (in radian)
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_GetTolerance(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_GeomFill_CircularBlendFunc self, Standard_Real const Tol3d, Standard_Real const Tol2d)

        Is usfull, if (me) have to  be run numerical
        algorithme to perform D0, D1 or D2

        :type Tol3d: float
        :type Tol2d: float

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_SetTolerance(self, *args)


    def BarycentreOfSurf(self, *args):
        """
        BarycentreOfSurf(Handle_GeomFill_CircularBlendFunc self) -> gp_Pnt

        Get    the   barycentre of   Surface.   An   very  poor
        estimation is sufficent. This information is usefull
        to perform well conditionned rational approximation.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_BarycentreOfSurf(self, *args)


    def MaximalSection(self, *args):
        """
        MaximalSection(Handle_GeomFill_CircularBlendFunc self) -> Standard_Real

        Returns the   length of the maximum section. This
        information is usefull to perform well conditionned rational
        approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_MaximalSection(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(Handle_GeomFill_CircularBlendFunc self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        of all  sections.  This information is  usefull to
        perform well conditionned rational approximation.

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_GetMinimalWeight(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_CircularBlendFunc self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_CircularBlendFunc_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_CircularBlendFunc_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Resolution(self, *args):
        """
        Resolution(Handle_GeomFill_CircularBlendFunc self, Standard_Integer const Index, Standard_Real const Tol)

        Returns the resolutions in the  sub-space 2d <Index>
        This information is usfull to find an good tolerance in
        2d approximation.

        :type Index: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_Resolution(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_CircularBlendFunc self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_CircularBlendFunc self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_CircularBlendFunc self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_CircularBlendFunc self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_CircularBlendFunc self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_CircularBlendFunc self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_CircularBlendFunc self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_CircularBlendFunc self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_CircularBlendFunc self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_CircularBlendFunc_DecrementRefCounter(self, *args)

Handle_GeomFill_CircularBlendFunc_swigregister = _GeomFill.Handle_GeomFill_CircularBlendFunc_swigregister
Handle_GeomFill_CircularBlendFunc_swigregister(Handle_GeomFill_CircularBlendFunc)

def Handle_GeomFill_CircularBlendFunc_DownCast(thing):
    return _GeomFill.Handle_GeomFill_CircularBlendFunc_DownCast(thing)
Handle_GeomFill_CircularBlendFunc_DownCast = _GeomFill.Handle_GeomFill_CircularBlendFunc_DownCast

class GeomFill_Generator(GeomFill_Profiler):
    """
    Create a surface using generating lines.  Inherits
    profiler.  The  surface will be  a  BSplineSurface
    passing  by   all  the  curves  described  in  the
    generator. The VDegree of the resulting surface is
    1.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomFill_Generator self) -> GeomFill_Generator

        Create a surface using generating lines.  Inherits
        profiler.  The  surface will be  a  BSplineSurface
        passing  by   all  the  curves  described  in  the
        generator. The VDegree of the resulting surface is
        1.
        """
        this = _GeomFill.new_GeomFill_Generator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(GeomFill_Generator self, Standard_Real const PTol)

        Converts all curves to BSplineCurves.
        Set them to the common profile.
        Compute the surface (degv = 1).
        <PTol> is used to compare 2 knots.

        :type PTol: float

        """
        return _GeomFill.GeomFill_Generator_Perform(self, *args)


    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _GeomFill.GeomFill_Generator_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_Generator
GeomFill_Generator_swigregister = _GeomFill.GeomFill_Generator_swigregister
GeomFill_Generator_swigregister(GeomFill_Generator)

class Handle_GeomFill_DiscreteTrihedron(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_DiscreteTrihedron self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_DiscreteTrihedron self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_DiscreteTrihedron self, GeomFill_DiscreteTrihedron thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_DiscreteTrihedron self, Handle_GeomFill_DiscreteTrihedron theHandle) -> Handle_GeomFill_DiscreteTrihedron
        assign(Handle_GeomFill_DiscreteTrihedron self, GeomFill_DiscreteTrihedron thePtr) -> Handle_GeomFill_DiscreteTrihedron
        assign(Handle_GeomFill_DiscreteTrihedron self, Handle_GeomFill_DiscreteTrihedron theHandle) -> Handle_GeomFill_DiscreteTrihedron

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_DiscreteTrihedron self) -> GeomFill_DiscreteTrihedron

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_DiscreteTrihedron self) -> GeomFill_DiscreteTrihedron

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_DiscreteTrihedron self) -> GeomFill_DiscreteTrihedron

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_DiscreteTrihedron___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_DiscreteTrihedron(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_DiscreteTrihedron_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_DiscreteTrihedron

    def Copy(self, *args):
        """
        Copy(Handle_GeomFill_DiscreteTrihedron self) -> Handle_GeomFill_TrihedronLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_TrihedronLaw

        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_Copy(self, *args)


    def Init(self, *args):
        """Init(Handle_GeomFill_DiscreteTrihedron self)"""
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_Init(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(Handle_GeomFill_DiscreteTrihedron self, Handle_Adaptor3d_HCurve C)

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_SetCurve(self, *args)


    def D0(self, *args):
        """
        D0(Handle_GeomFill_DiscreteTrihedron self, Standard_Real const Param, gp_Vec Tangent, gp_Vec Normal, gp_Vec BiNormal) -> Standard_Boolean

        compute Trihedron on curve at parameter <Param>

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_DiscreteTrihedron self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec BiNormal, gp_Vec DBiNormal) -> Standard_Boolean

        compute Trihedron and  derivative Trihedron  on curve
        at parameter <Param>
        Warning : It used only for C1 or C2 aproximation
        For the moment it returns null values for DTangent, DNormal
        and DBiNormal.

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_GeomFill_DiscreteTrihedron self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec D2Tangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec D2Normal, gp_Vec BiNormal, gp_Vec DBiNormal, gp_Vec D2BiNormal) -> Standard_Boolean

        compute  Trihedron on curve
        first and seconde  derivatives.
        Warning : It used only for C2 aproximation
        For the moment it returns null values for DTangent, DNormal
        DBiNormal, D2Tangent, D2Normal, D2BiNormal.

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type D2Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type D2Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :type D2BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_D2(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_GeomFill_DiscreteTrihedron self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_GeomFill_DiscreteTrihedron self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_Intervals(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(Handle_GeomFill_DiscreteTrihedron self, gp_Vec ATangent, gp_Vec ANormal, gp_Vec ABiNormal)

        Get average value of Tangent(t) and Normal(t) it is usful to
        make fast approximation of rational  surfaces.

        :type ATangent: OCC.wrapper.gp.gp_Vec
        :type ANormal: OCC.wrapper.gp.gp_Vec
        :type ABiNormal: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_GetAverageLaw(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(Handle_GeomFill_DiscreteTrihedron self) -> Standard_Boolean

        Say if the law is Constant.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_IsConstant(self, *args)


    def IsOnlyBy3dCurve(self, *args):
        """
        IsOnlyBy3dCurve(Handle_GeomFill_DiscreteTrihedron self) -> Standard_Boolean

        Return True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_IsOnlyBy3dCurve(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_DiscreteTrihedron self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_DiscreteTrihedron_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_DiscreteTrihedron_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_GeomFill_DiscreteTrihedron self) -> GeomFill_PipeError

        Give a status to the Law
        Returns PipeOk (default implementation)

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_ErrorStatus(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Handle_GeomFill_DiscreteTrihedron self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_SetInterval(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(Handle_GeomFill_DiscreteTrihedron self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_GetInterval(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_DiscreteTrihedron self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_DiscreteTrihedron self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_DiscreteTrihedron self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_DiscreteTrihedron self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_DiscreteTrihedron self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_DiscreteTrihedron self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_DiscreteTrihedron self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_DiscreteTrihedron self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_DiscreteTrihedron self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_DiscreteTrihedron_DecrementRefCounter(self, *args)

Handle_GeomFill_DiscreteTrihedron_swigregister = _GeomFill.Handle_GeomFill_DiscreteTrihedron_swigregister
Handle_GeomFill_DiscreteTrihedron_swigregister(Handle_GeomFill_DiscreteTrihedron)

def Handle_GeomFill_DiscreteTrihedron_DownCast(thing):
    return _GeomFill.Handle_GeomFill_DiscreteTrihedron_DownCast(thing)
Handle_GeomFill_DiscreteTrihedron_DownCast = _GeomFill.Handle_GeomFill_DiscreteTrihedron_DownCast

class Handle_GeomFill_LocationGuide(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_LocationGuide self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_LocationGuide_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_LocationGuide self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_LocationGuide self, GeomFill_LocationGuide thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_LocationGuide self, Handle_GeomFill_LocationGuide theHandle) -> Handle_GeomFill_LocationGuide
        assign(Handle_GeomFill_LocationGuide self, GeomFill_LocationGuide thePtr) -> Handle_GeomFill_LocationGuide
        assign(Handle_GeomFill_LocationGuide self, Handle_GeomFill_LocationGuide theHandle) -> Handle_GeomFill_LocationGuide

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_LocationGuide self) -> GeomFill_LocationGuide

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_LocationGuide self) -> GeomFill_LocationGuide

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_LocationGuide___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_LocationGuide self) -> GeomFill_LocationGuide

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_LocationGuide___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_LocationGuide___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_LocationGuide___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_LocationGuide(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_LocationGuide_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_LocationGuide

    def Set(self, *args):
        """
        Set(Handle_GeomFill_LocationGuide self, Handle_GeomFill_SectionLaw Section, Standard_Boolean const rotat, Standard_Real const SFirst, Standard_Real const SLast, Standard_Real const PrecAngle)

        :type Section: OCC.wrapper.GeomFill.Handle_GeomFill_SectionLaw
        :type rotat: bool
        :type SFirst: float
        :type SLast: float
        :type PrecAngle: float
        :type LastAngle: float

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_Set(self, *args)


    def EraseRotation(self, *args):
        """EraseRotation(Handle_GeomFill_LocationGuide self)"""
        return _GeomFill.Handle_GeomFill_LocationGuide_EraseRotation(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(Handle_GeomFill_LocationGuide self, Handle_Adaptor3d_HCurve C)

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_SetCurve(self, *args)


    def GetCurve(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        res = _GeomFill.Handle_GeomFill_LocationGuide_GetCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTrsf(self, *args):
        """
        SetTrsf(Handle_GeomFill_LocationGuide self, gp_Mat Transfo)

        :type Transfo: OCC.wrapper.gp.gp_Mat

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_SetTrsf(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_GeomFill_LocationGuide self) -> Handle_GeomFill_LocationLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_LocationLaw

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_Copy(self, *args)


    def D0(self, *args):
        """
        D0(Handle_GeomFill_LocationGuide self, Standard_Real const Param, gp_Mat M, gp_Vec V) -> Standard_Boolean
        D0(Handle_GeomFill_LocationGuide self, Standard_Real const Param, gp_Mat M, gp_Vec V, NCollection_Array1_gp_Pnt2d Poles2d) -> Standard_Boolean

        compute Location and 2d points

        :type Param: float
        :type M: OCC.wrapper.gp.gp_Mat
        :type V: OCC.wrapper.gp.gp_Vec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_LocationGuide self, Standard_Real const Param, gp_Mat M, gp_Vec V, gp_Mat DM, gp_Vec DV, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d) -> Standard_Boolean

        compute location 2d  points and  associated
        first derivatives.
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type M: OCC.wrapper.gp.gp_Mat
        :type V: OCC.wrapper.gp.gp_Vec
        :type DM: OCC.wrapper.gp.gp_Mat
        :type DV: OCC.wrapper.gp.gp_Vec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_GeomFill_LocationGuide self, Standard_Real const Param, gp_Mat M, gp_Vec V, gp_Mat DM, gp_Vec DV, gp_Mat D2M, gp_Vec D2V, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d) -> Standard_Boolean

        compute location 2d  points and associated
        first and seconde  derivatives.
        Warning : It used only for C2 aproximation

        :type Param: float
        :type M: OCC.wrapper.gp.gp_Mat
        :type V: OCC.wrapper.gp.gp_Vec
        :type DM: OCC.wrapper.gp.gp_Mat
        :type DV: OCC.wrapper.gp.gp_Vec
        :type D2M: OCC.wrapper.gp.gp_Mat
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type D2Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_D2(self, *args)


    def HasFirstRestriction(self, *args):
        """
        HasFirstRestriction(Handle_GeomFill_LocationGuide self) -> Standard_Boolean

        Say if the first restriction is defined in this class.
        If it  is true the  first element  of poles array   in
        D0,D1,D2... Correspond to this restriction.
        Returns Standard_False (default implementation)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_HasFirstRestriction(self, *args)


    def HasLastRestriction(self, *args):
        """
        HasLastRestriction(Handle_GeomFill_LocationGuide self) -> Standard_Boolean

        Say if the last restriction is defined in this class.
        If it is  true the  last element  of poles array in
        D0,D1,D2... Correspond to this restriction.
        Returns Standard_False (default implementation)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_HasLastRestriction(self, *args)


    def TraceNumber(self, *args):
        """
        TraceNumber(Handle_GeomFill_LocationGuide self) -> Standard_Integer

        Give the number of trace (Curves 2d wich are not restriction)
        Returns 1 (default implementation)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_TraceNumber(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_GeomFill_LocationGuide self) -> GeomFill_PipeError

        Give a status to the Law
        Returns PipeOk (default implementation)

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_ErrorStatus(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_GeomFill_LocationGuide self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_GeomFill_LocationGuide self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Handle_GeomFill_LocationGuide self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_SetInterval(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(Handle_GeomFill_LocationGuide self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_GetInterval(self, *args)


    def GetDomain(self, *args):
        """
        GetDomain(Handle_GeomFill_LocationGuide self)

        Gets the bounds of the function parametric domain.
        Warning: This domain it is  not modified by the
        SetValue method

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_GetDomain(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_GeomFill_LocationGuide self, Standard_Real const Tol3d, Standard_Real const Tol2d)

        Is usefull, if (me) have to run numerical
        algorithm to perform D0, D1 or D2
        The default implementation make nothing.

        :type Tol3d: float
        :type Tol2d: float

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_SetTolerance(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Handle_GeomFill_LocationGuide self, Standard_Integer const Index, Standard_Real const Tol)

        Returns the resolutions in the  sub-space 2d <Index>
        This information is usfull to find an good tolerance in
        2d approximation.
        Warning: Used only if Nb2dCurve > 0

        :type Index: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_Resolution(self, *args)


    def GetMaximalNorm(self, *args):
        """
        GetMaximalNorm(Handle_GeomFill_LocationGuide self) -> Standard_Real

        Get the maximum Norm  of the matrix-location part.  It
        is usful to find an good Tolerance to approx M(t).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_GetMaximalNorm(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(Handle_GeomFill_LocationGuide self, gp_Mat AM, gp_Vec AV)

        Get average value of M(t) and V(t) it is usfull to
        make fast approximation of rational  surfaces.

        :type AM: OCC.wrapper.gp.gp_Mat
        :type AV: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_GetAverageLaw(self, *args)


    def IsTranslation(self, *args):
        """
        IsTranslation(Handle_GeomFill_LocationGuide self) -> Standard_Boolean

        Say if the Location  Law, is an translation of  Location
        The default implementation is " returns False ".

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_IsTranslation(self, *args)


    def IsRotation(self, *args):
        """
        IsRotation(Handle_GeomFill_LocationGuide self) -> Standard_Boolean

        Say if the Location  Law, is a rotation of Location
        The default implementation is " returns False ".

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_IsRotation(self, *args)


    def Rotation(self, *args):
        """
        Rotation(Handle_GeomFill_LocationGuide self, gp_Pnt Center)

        :type Center: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_Rotation(self, *args)


    def Section(self, *args):
        """
        Section(Handle_GeomFill_LocationGuide self) -> Handle_Geom_Curve

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_Section(self, *args)


    def Guide(self, *args):
        """
        Guide(Handle_GeomFill_LocationGuide self) -> Handle_Adaptor3d_HCurve

        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_Guide(self, *args)


    def SetOrigine(self, *args):
        """
        SetOrigine(Handle_GeomFill_LocationGuide self, Standard_Real const Param1, Standard_Real const Param2)

        :type Param1: float
        :type Param2: float

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_SetOrigine(self, *args)


    def ComputeAutomaticLaw(self, *args):
        """
        ComputeAutomaticLaw(Handle_GeomFill_LocationGuide self, Handle_TColgp_HArray1OfPnt2d ParAndRad) -> GeomFill_PipeError

        :type ParAndRad: OCC.wrapper.TColgp.Handle_TColgp_HArray1OfPnt2d
        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_ComputeAutomaticLaw(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_LocationGuide self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_LocationGuide_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_LocationGuide_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Nb2dCurves(self, *args):
        """
        Nb2dCurves(Handle_GeomFill_LocationGuide self) -> Standard_Integer

        get the number of  2d  curves (Restrictions  +  Traces)
        to approximate.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_Nb2dCurves(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_LocationGuide self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_LocationGuide_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_LocationGuide self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_LocationGuide self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_LocationGuide self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_LocationGuide self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_LocationGuide self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_LocationGuide self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_LocationGuide self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_LocationGuide_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_LocationGuide self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_LocationGuide_DecrementRefCounter(self, *args)

Handle_GeomFill_LocationGuide_swigregister = _GeomFill.Handle_GeomFill_LocationGuide_swigregister
Handle_GeomFill_LocationGuide_swigregister(Handle_GeomFill_LocationGuide)

def Handle_GeomFill_LocationGuide_DownCast(thing):
    return _GeomFill.Handle_GeomFill_LocationGuide_DownCast(thing)
Handle_GeomFill_LocationGuide_DownCast = _GeomFill.Handle_GeomFill_LocationGuide_DownCast

class Handle_GeomFill_UniformSection(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_UniformSection self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_UniformSection_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_UniformSection self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_UniformSection_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_UniformSection self, GeomFill_UniformSection thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_UniformSection_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_UniformSection self, Handle_GeomFill_UniformSection theHandle) -> Handle_GeomFill_UniformSection
        assign(Handle_GeomFill_UniformSection self, GeomFill_UniformSection thePtr) -> Handle_GeomFill_UniformSection
        assign(Handle_GeomFill_UniformSection self, Handle_GeomFill_UniformSection theHandle) -> Handle_GeomFill_UniformSection

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_UniformSection_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_UniformSection self) -> GeomFill_UniformSection

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_UniformSection_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_UniformSection self) -> GeomFill_UniformSection

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_UniformSection___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_UniformSection self) -> GeomFill_UniformSection

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_UniformSection___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_UniformSection___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_UniformSection___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_UniformSection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_UniformSection_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_UniformSection

    def D0(self, *args):
        """
        D0(Handle_GeomFill_UniformSection self, Standard_Real const Param, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weigths) -> Standard_Boolean

        compute the section for v = param

        :type Param: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_UniformSection_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_UniformSection self, Standard_Real const Param, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean

        compute the first  derivative in v direction  of the
        section for v =  param
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_UniformSection_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_GeomFill_UniformSection self, Standard_Real const Param, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        compute the second derivative  in v direction of the
        section  for v = param
        Warning : It used only for C2 aproximation

        :type Param: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_UniformSection_D2(self, *args)


    def BSplineSurface(self, *args):
        """
        BSplineSurface(Handle_GeomFill_UniformSection self) -> Handle_Geom_BSplineSurface

        give if possible an bspline Surface, like iso-v are the
        section.  If it is  not possible  this methode have  to
        get an Null Surface.  Is it the default implementation.

        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

        """
        return _GeomFill.Handle_GeomFill_UniformSection_BSplineSurface(self, *args)


    def SectionShape(self, *args):
        """
        SectionShape(Handle_GeomFill_UniformSection self)

        get the format of an  section

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int

        """
        return _GeomFill.Handle_GeomFill_UniformSection_SectionShape(self, *args)


    def Knots(self, *args):
        """
        Knots(Handle_GeomFill_UniformSection self, NCollection_Array1_Standard_Real TKnots)

        get the Knots of the section

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.Handle_GeomFill_UniformSection_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(Handle_GeomFill_UniformSection self, NCollection_Array1_Standard_Integer TMults)

        get the Multplicities of the section

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _GeomFill.Handle_GeomFill_UniformSection_Mults(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Handle_GeomFill_UniformSection self) -> Standard_Boolean

        Returns if the sections are rationnal or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_UniformSection_IsRational(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Handle_GeomFill_UniformSection self) -> Standard_Boolean

        Returns if the sections are periodic or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_UniformSection_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Handle_GeomFill_UniformSection self) -> Standard_Boolean

        Returns if the law  isperiodic or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_UniformSection_IsVPeriodic(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_GeomFill_UniformSection self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_UniformSection_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_GeomFill_UniformSection self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.Handle_GeomFill_UniformSection_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Handle_GeomFill_UniformSection self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_UniformSection_SetInterval(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(Handle_GeomFill_UniformSection self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_UniformSection_GetInterval(self, *args)


    def GetDomain(self, *args):
        """
        GetDomain(Handle_GeomFill_UniformSection self)

        Gets the bounds of the function parametric domain.
        Warning: This domain it is  not modified by the
        SetValue method

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_UniformSection_GetDomain(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(Handle_GeomFill_UniformSection self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, NCollection_Array1_Standard_Real Tol3d)

        Returns the tolerances associated at each poles to
        reach  in approximation, to satisfy: BoundTol error
        at the   Boundary  AngleTol tangent error  at  the
        Boundary  (in radian)  SurfTol   error inside the
        surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.Handle_GeomFill_UniformSection_GetTolerance(self, *args)


    def BarycentreOfSurf(self, *args):
        """
        BarycentreOfSurf(Handle_GeomFill_UniformSection self) -> gp_Pnt

        Get the barycentre of Surface.
        An   very  poor estimation is sufficent.
        This information is usefull to perform well
        conditioned rational approximation.
        Warning: Used only if <me> IsRational

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.Handle_GeomFill_UniformSection_BarycentreOfSurf(self, *args)


    def MaximalSection(self, *args):
        """
        MaximalSection(Handle_GeomFill_UniformSection self) -> Standard_Real

        Returns the   length of the greater section. This
        information is usefull to G1's control.
        Warning: With an little value, approximation can be slower.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.Handle_GeomFill_UniformSection_MaximalSection(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(Handle_GeomFill_UniformSection self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        in all  sections.
        This information is  usefull to control error
        in rational approximation.
        Warning: Used only if <me> IsRational

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.Handle_GeomFill_UniformSection_GetMinimalWeight(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(Handle_GeomFill_UniformSection self) -> Standard_Boolean

        return True

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_UniformSection_IsConstant(self, *args)


    def ConstantSection(self, *args):
        """
        ConstantSection(Handle_GeomFill_UniformSection self) -> Handle_Geom_Curve

        Return the constant Section if <me>  IsConstant.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _GeomFill.Handle_GeomFill_UniformSection_ConstantSection(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_UniformSection self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_UniformSection_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_UniformSection_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_UniformSection_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_GeomFill_UniformSection self, Standard_Real const Tol3d, Standard_Real const Tol2d)

        Is  usefull, if (me)  have to run  numerical
        algorithm  to perform D0,  D1 or D2
        The default implementation make nothing.

        :type Tol3d: float
        :type Tol2d: float

        """
        return _GeomFill.Handle_GeomFill_UniformSection_SetTolerance(self, *args)


    def IsConicalLaw(self, *args):
        """
        IsConicalLaw(Handle_GeomFill_UniformSection self) -> Standard_Boolean

        Returns True if all section  are circle, with same
        plane,same center and  linear  radius  evolution
        Return False by Default.

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_UniformSection_IsConicalLaw(self, *args)


    def CirclSection(self, *args):
        """
        CirclSection(Handle_GeomFill_UniformSection self, Standard_Real const Param) -> Handle_Geom_Curve

        Return the circle section  at parameter <Param>, if
        <me> a  IsConicalLaw

        :type Param: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _GeomFill.Handle_GeomFill_UniformSection_CirclSection(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_UniformSection self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_UniformSection_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_UniformSection self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_UniformSection self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_UniformSection_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_UniformSection self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_UniformSection self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_UniformSection_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_UniformSection self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_UniformSection_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_UniformSection self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_UniformSection_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_UniformSection self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_UniformSection_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_UniformSection self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_UniformSection_DecrementRefCounter(self, *args)

Handle_GeomFill_UniformSection_swigregister = _GeomFill.Handle_GeomFill_UniformSection_swigregister
Handle_GeomFill_UniformSection_swigregister(Handle_GeomFill_UniformSection)

def Handle_GeomFill_UniformSection_DownCast(thing):
    return _GeomFill.Handle_GeomFill_UniformSection_DownCast(thing)
Handle_GeomFill_UniformSection_DownCast = _GeomFill.Handle_GeomFill_UniformSection_DownCast

class GeomFill_CorrectedFrenet(GeomFill_TrihedronLaw):
    """
    Defined an Corrected Frenet  Trihedron  Law It is
    like Frenet with an Torsion's minimization
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_CorrectedFrenet
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_CorrectedFrenet(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GeomFill_CorrectedFrenet self) -> GeomFill_CorrectedFrenet
        __init__(GeomFill_CorrectedFrenet self, Standard_Boolean const ForEvaluation) -> GeomFill_CorrectedFrenet

        :type ForEvaluation: bool

        """
        this = _GeomFill.new_GeomFill_CorrectedFrenet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Copy(self, *args):
        """
        Copy(GeomFill_CorrectedFrenet self) -> Handle_GeomFill_TrihedronLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_TrihedronLaw

        """
        return _GeomFill.GeomFill_CorrectedFrenet_Copy(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(GeomFill_CorrectedFrenet self, Handle_Adaptor3d_HCurve C)

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.GeomFill_CorrectedFrenet_SetCurve(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(GeomFill_CorrectedFrenet self, Standard_Real const First, Standard_Real const Last)

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_CorrectedFrenet_SetInterval(self, *args)


    def D0(self, *args):
        """
        D0(GeomFill_CorrectedFrenet self, Standard_Real const Param, gp_Vec Tangent, gp_Vec Normal, gp_Vec BiNormal) -> Standard_Boolean

        compute Triedrhon on curve at parameter <Param>

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_CorrectedFrenet_D0(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_CorrectedFrenet self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec BiNormal, gp_Vec DBiNormal) -> Standard_Boolean

        compute Triedrhon and  derivative Trihedron  on curve
        at parameter <Param>
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_CorrectedFrenet_D1(self, *args)


    def D2(self, *args):
        """
        D2(GeomFill_CorrectedFrenet self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec D2Tangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec D2Normal, gp_Vec BiNormal, gp_Vec DBiNormal, gp_Vec D2BiNormal) -> Standard_Boolean

        compute  Trihedron on curve
        first and seconde  derivatives.
        Warning : It used only for C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type D2Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type D2Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :type D2BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_CorrectedFrenet_D2(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(GeomFill_CorrectedFrenet self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_CorrectedFrenet_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(GeomFill_CorrectedFrenet self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.GeomFill_CorrectedFrenet_Intervals(self, *args)


    def EvaluateBestMode(self, *args):
        """
        EvaluateBestMode(GeomFill_CorrectedFrenet self) -> GeomFill_Trihedron

        Tries to define the best trihedron mode
        for the curve. It can be:
        - Frenet
        - CorrectedFrenet
        - DiscreteTrihedron
        Warning: the CorrectedFrenet must be constructed
        with option ForEvaluation = True,
        the curve must be set by method SetCurve.

        :rtype: OCC.wrapper.GeomFill.GeomFill_Trihedron

        """
        return _GeomFill.GeomFill_CorrectedFrenet_EvaluateBestMode(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(GeomFill_CorrectedFrenet self, gp_Vec ATangent, gp_Vec ANormal, gp_Vec ABiNormal)

        Get average value of Tangent(t) and Normal(t) it is usfull to
        make fast approximation of rational  surfaces.

        :type ATangent: OCC.wrapper.gp.gp_Vec
        :type ANormal: OCC.wrapper.gp.gp_Vec
        :type ABiNormal: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_CorrectedFrenet_GetAverageLaw(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(GeomFill_CorrectedFrenet self) -> Standard_Boolean

        Say if the law is Constant.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_CorrectedFrenet_IsConstant(self, *args)


    def IsOnlyBy3dCurve(self, *args):
        """
        IsOnlyBy3dCurve(GeomFill_CorrectedFrenet self) -> Standard_Boolean

        Return True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_CorrectedFrenet_IsOnlyBy3dCurve(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_CorrectedFrenet_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_CorrectedFrenet_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_CorrectedFrenet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_CorrectedFrenet
GeomFill_CorrectedFrenet_swigregister = _GeomFill.GeomFill_CorrectedFrenet_swigregister
GeomFill_CorrectedFrenet_swigregister(GeomFill_CorrectedFrenet)

def GeomFill_CorrectedFrenet_get_type_name(*args):
    """
    GeomFill_CorrectedFrenet_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_CorrectedFrenet_get_type_name(*args)

def GeomFill_CorrectedFrenet_get_type_descriptor(*args):
    """
    GeomFill_CorrectedFrenet_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_CorrectedFrenet_get_type_descriptor(*args)

class Handle_GeomFill_CurveAndTrihedron(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_CurveAndTrihedron self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_CurveAndTrihedron self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_CurveAndTrihedron self, GeomFill_CurveAndTrihedron thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_CurveAndTrihedron self, Handle_GeomFill_CurveAndTrihedron theHandle) -> Handle_GeomFill_CurveAndTrihedron
        assign(Handle_GeomFill_CurveAndTrihedron self, GeomFill_CurveAndTrihedron thePtr) -> Handle_GeomFill_CurveAndTrihedron
        assign(Handle_GeomFill_CurveAndTrihedron self, Handle_GeomFill_CurveAndTrihedron theHandle) -> Handle_GeomFill_CurveAndTrihedron

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_CurveAndTrihedron self) -> GeomFill_CurveAndTrihedron

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_CurveAndTrihedron self) -> GeomFill_CurveAndTrihedron

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_CurveAndTrihedron self) -> GeomFill_CurveAndTrihedron

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_CurveAndTrihedron___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_CurveAndTrihedron(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_CurveAndTrihedron_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_CurveAndTrihedron

    def SetCurve(self, *args):
        """
        SetCurve(Handle_GeomFill_CurveAndTrihedron self, Handle_Adaptor3d_HCurve C)

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_SetCurve(self, *args)


    def GetCurve(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        res = _GeomFill.Handle_GeomFill_CurveAndTrihedron_GetCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTrsf(self, *args):
        """
        SetTrsf(Handle_GeomFill_CurveAndTrihedron self, gp_Mat Transfo)

        Set a transformation Matrix like   the law M(t) become
        Mat * M(t)

        :type Transfo: OCC.wrapper.gp.gp_Mat

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_SetTrsf(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_GeomFill_CurveAndTrihedron self) -> Handle_GeomFill_LocationLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_LocationLaw

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_Copy(self, *args)


    def D0(self, *args):
        """
        D0(Handle_GeomFill_CurveAndTrihedron self, Standard_Real const Param, gp_Mat M, gp_Vec V) -> Standard_Boolean
        D0(Handle_GeomFill_CurveAndTrihedron self, Standard_Real const Param, gp_Mat M, gp_Vec V, NCollection_Array1_gp_Pnt2d Poles2d) -> Standard_Boolean

        compute Location and 2d points

        :type Param: float
        :type M: OCC.wrapper.gp.gp_Mat
        :type V: OCC.wrapper.gp.gp_Vec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_CurveAndTrihedron self, Standard_Real const Param, gp_Mat M, gp_Vec V, gp_Mat DM, gp_Vec DV, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d) -> Standard_Boolean

        compute location 2d  points and  associated
        first derivatives.
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type M: OCC.wrapper.gp.gp_Mat
        :type V: OCC.wrapper.gp.gp_Vec
        :type DM: OCC.wrapper.gp.gp_Mat
        :type DV: OCC.wrapper.gp.gp_Vec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_GeomFill_CurveAndTrihedron self, Standard_Real const Param, gp_Mat M, gp_Vec V, gp_Mat DM, gp_Vec DV, gp_Mat D2M, gp_Vec D2V, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d) -> Standard_Boolean

        compute location 2d  points and associated
        first and seconde  derivatives.
        Warning : It used only for C2 aproximation

        :type Param: float
        :type M: OCC.wrapper.gp.gp_Mat
        :type V: OCC.wrapper.gp.gp_Vec
        :type DM: OCC.wrapper.gp.gp_Mat
        :type DV: OCC.wrapper.gp.gp_Vec
        :type D2M: OCC.wrapper.gp.gp_Mat
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type D2Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_D2(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_GeomFill_CurveAndTrihedron self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_GeomFill_CurveAndTrihedron self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Handle_GeomFill_CurveAndTrihedron self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_SetInterval(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(Handle_GeomFill_CurveAndTrihedron self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_GetInterval(self, *args)


    def GetDomain(self, *args):
        """
        GetDomain(Handle_GeomFill_CurveAndTrihedron self)

        Gets the bounds of the function parametric domain.
        Warning: This domain it is  not modified by the
        SetValue method

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_GetDomain(self, *args)


    def GetMaximalNorm(self, *args):
        """
        GetMaximalNorm(Handle_GeomFill_CurveAndTrihedron self) -> Standard_Real

        Get the maximum Norm  of the matrix-location part.  It
        is usful to find an good Tolerance to approx M(t).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_GetMaximalNorm(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(Handle_GeomFill_CurveAndTrihedron self, gp_Mat AM, gp_Vec AV)

        Get average value of M(t) and V(t) it is usfull to
        make fast approximation of rational  surfaces.

        :type AM: OCC.wrapper.gp.gp_Mat
        :type AV: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_GetAverageLaw(self, *args)


    def IsTranslation(self, *args):
        """
        IsTranslation(Handle_GeomFill_CurveAndTrihedron self) -> Standard_Boolean

        Say if the Location  Law, is an translation of  Location
        The default implementation is " returns False ".

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_IsTranslation(self, *args)


    def IsRotation(self, *args):
        """
        IsRotation(Handle_GeomFill_CurveAndTrihedron self) -> Standard_Boolean

        Say if the Location  Law, is a rotation of Location
        The default implementation is " returns False ".

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_IsRotation(self, *args)


    def Rotation(self, *args):
        """
        Rotation(Handle_GeomFill_CurveAndTrihedron self, gp_Pnt Center)

        :type Center: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_Rotation(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_CurveAndTrihedron self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_CurveAndTrihedron_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_CurveAndTrihedron_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Nb2dCurves(self, *args):
        """
        Nb2dCurves(Handle_GeomFill_CurveAndTrihedron self) -> Standard_Integer

        get the number of  2d  curves (Restrictions  +  Traces)
        to approximate.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_Nb2dCurves(self, *args)


    def HasFirstRestriction(self, *args):
        """
        HasFirstRestriction(Handle_GeomFill_CurveAndTrihedron self) -> Standard_Boolean

        Say if the first restriction is defined in this class.
        If it  is true the  first element  of poles array   in
        D0,D1,D2... Correspond to this restriction.
        Returns Standard_False (default implementation)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_HasFirstRestriction(self, *args)


    def HasLastRestriction(self, *args):
        """
        HasLastRestriction(Handle_GeomFill_CurveAndTrihedron self) -> Standard_Boolean

        Say if the last restriction is defined in this class.
        If it is  true the  last element  of poles array in
        D0,D1,D2... Correspond to this restriction.
        Returns Standard_False (default implementation)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_HasLastRestriction(self, *args)


    def TraceNumber(self, *args):
        """
        TraceNumber(Handle_GeomFill_CurveAndTrihedron self) -> Standard_Integer

        Give the number of trace (Curves 2d wich are not restriction)
        Returns 0 (default implementation)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_TraceNumber(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_GeomFill_CurveAndTrihedron self) -> GeomFill_PipeError

        Give a status to the Law
        Returns PipeOk (default implementation)

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_ErrorStatus(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Handle_GeomFill_CurveAndTrihedron self, Standard_Integer const Index, Standard_Real const Tol)

        Returns the resolutions in the  sub-space 2d <Index>
        This information is usfull to find an good tolerance in
        2d approximation.

        :type Index: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_Resolution(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_GeomFill_CurveAndTrihedron self, Standard_Real const Tol3d, Standard_Real const Tol2d)

        Is usefull, if (me) have to run numerical
        algorithm to perform D0, D1 or D2
        The default implementation make nothing.

        :type Tol3d: float
        :type Tol2d: float

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_SetTolerance(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_CurveAndTrihedron self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_CurveAndTrihedron self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_CurveAndTrihedron self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_CurveAndTrihedron self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_CurveAndTrihedron self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_CurveAndTrihedron self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_CurveAndTrihedron self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_CurveAndTrihedron self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_CurveAndTrihedron self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_CurveAndTrihedron_DecrementRefCounter(self, *args)

Handle_GeomFill_CurveAndTrihedron_swigregister = _GeomFill.Handle_GeomFill_CurveAndTrihedron_swigregister
Handle_GeomFill_CurveAndTrihedron_swigregister(Handle_GeomFill_CurveAndTrihedron)

def Handle_GeomFill_CurveAndTrihedron_DownCast(thing):
    return _GeomFill.Handle_GeomFill_CurveAndTrihedron_DownCast(thing)
Handle_GeomFill_CurveAndTrihedron_DownCast = _GeomFill.Handle_GeomFill_CurveAndTrihedron_DownCast

class Handle_GeomFill_DraftTrihedron(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_DraftTrihedron self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_DraftTrihedron self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_DraftTrihedron self, GeomFill_DraftTrihedron thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_DraftTrihedron self, Handle_GeomFill_DraftTrihedron theHandle) -> Handle_GeomFill_DraftTrihedron
        assign(Handle_GeomFill_DraftTrihedron self, GeomFill_DraftTrihedron thePtr) -> Handle_GeomFill_DraftTrihedron
        assign(Handle_GeomFill_DraftTrihedron self, Handle_GeomFill_DraftTrihedron theHandle) -> Handle_GeomFill_DraftTrihedron

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_DraftTrihedron self) -> GeomFill_DraftTrihedron

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_DraftTrihedron self) -> GeomFill_DraftTrihedron

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_DraftTrihedron self) -> GeomFill_DraftTrihedron

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_DraftTrihedron___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_DraftTrihedron___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_DraftTrihedron(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_DraftTrihedron_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_DraftTrihedron

    def SetAngle(self, *args):
        """
        SetAngle(Handle_GeomFill_DraftTrihedron self, Standard_Real const Angle)

        :type Angle: float

        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_SetAngle(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_GeomFill_DraftTrihedron self) -> Handle_GeomFill_TrihedronLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_TrihedronLaw

        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_Copy(self, *args)


    def D0(self, *args):
        """
        D0(Handle_GeomFill_DraftTrihedron self, Standard_Real const Param, gp_Vec Tangent, gp_Vec Normal, gp_Vec BiNormal) -> Standard_Boolean

        compute Triedrhon and derivative Trihedron on curve at
        parameter <Param>
        Warning : It used  only for C1 or C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_DraftTrihedron self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec BiNormal, gp_Vec DBiNormal) -> Standard_Boolean

        compute Trihedron on curve
        first and seconde  derivatives.
        Warning : It used only for C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_GeomFill_DraftTrihedron self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec D2Tangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec D2Normal, gp_Vec BiNormal, gp_Vec DBiNormal, gp_Vec D2BiNormal) -> Standard_Boolean

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type D2Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type D2Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :type D2BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_D2(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_GeomFill_DraftTrihedron self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_GeomFill_DraftTrihedron self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_Intervals(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(Handle_GeomFill_DraftTrihedron self, gp_Vec ATangent, gp_Vec ANormal, gp_Vec ABiNormal)

        Get average value of Tangent(t) and Normal(t) it is usefull to
        make fast approximation of rational  surfaces.

        :type ATangent: OCC.wrapper.gp.gp_Vec
        :type ANormal: OCC.wrapper.gp.gp_Vec
        :type ABiNormal: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_GetAverageLaw(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(Handle_GeomFill_DraftTrihedron self) -> Standard_Boolean

        Say if the law is Constant.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_IsConstant(self, *args)


    def IsOnlyBy3dCurve(self, *args):
        """
        IsOnlyBy3dCurve(Handle_GeomFill_DraftTrihedron self) -> Standard_Boolean

        Return True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_IsOnlyBy3dCurve(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_DraftTrihedron self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_DraftTrihedron_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_DraftTrihedron_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetCurve(self, *args):
        """
        SetCurve(Handle_GeomFill_DraftTrihedron self, Handle_Adaptor3d_HCurve C)

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_SetCurve(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_GeomFill_DraftTrihedron self) -> GeomFill_PipeError

        Give a status to the Law
        Returns PipeOk (default implementation)

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_ErrorStatus(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Handle_GeomFill_DraftTrihedron self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_SetInterval(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(Handle_GeomFill_DraftTrihedron self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_GetInterval(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_DraftTrihedron self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_DraftTrihedron self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_DraftTrihedron self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_DraftTrihedron self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_DraftTrihedron self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_DraftTrihedron self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_DraftTrihedron self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_DraftTrihedron self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_DraftTrihedron self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_DraftTrihedron_DecrementRefCounter(self, *args)

Handle_GeomFill_DraftTrihedron_swigregister = _GeomFill.Handle_GeomFill_DraftTrihedron_swigregister
Handle_GeomFill_DraftTrihedron_swigregister(Handle_GeomFill_DraftTrihedron)

def Handle_GeomFill_DraftTrihedron_DownCast(thing):
    return _GeomFill.Handle_GeomFill_DraftTrihedron_DownCast(thing)
Handle_GeomFill_DraftTrihedron_DownCast = _GeomFill.Handle_GeomFill_DraftTrihedron_DownCast

class NCollection_Array1_Handle_GeomFill_SectionLaw(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_GeomFill_SectionLaw self) -> NCollection_Array1< opencascade::handle< GeomFill_SectionLaw > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_SectionLaw_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_GeomFill_SectionLaw self) -> NCollection_Array1< opencascade::handle< GeomFill_SectionLaw > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_SectionLaw_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_GeomFill_SectionLaw self) -> NCollection_Array1< opencascade::handle< GeomFill_SectionLaw > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_SectionLaw_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_GeomFill_SectionLaw self) -> NCollection_Array1< opencascade::handle< GeomFill_SectionLaw > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_SectionLaw_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _GeomFill.new_NCollection_Array1_Handle_GeomFill_SectionLaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_GeomFill_SectionLaw self, Handle_GeomFill_SectionLaw theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_SectionLaw_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_GeomFill_SectionLaw self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_SectionLaw_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_GeomFill_SectionLaw self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_SectionLaw_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_GeomFill_SectionLaw self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_SectionLaw_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_GeomFill_SectionLaw self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_SectionLaw_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_GeomFill_SectionLaw self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_SectionLaw_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_GeomFill_SectionLaw self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_SectionLaw_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_GeomFill_SectionLaw self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_SectionLaw_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_GeomFill_SectionLaw self, NCollection_Array1_Handle_GeomFill_SectionLaw theOther) -> NCollection_Array1_Handle_GeomFill_SectionLaw

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_SectionLaw_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_GeomFill_SectionLaw self, NCollection_Array1_Handle_GeomFill_SectionLaw theOther) -> NCollection_Array1_Handle_GeomFill_SectionLaw

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_SectionLaw_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_GeomFill_SectionLaw self, NCollection_Array1_Handle_GeomFill_SectionLaw theOther) -> NCollection_Array1_Handle_GeomFill_SectionLaw
        assign(NCollection_Array1_Handle_GeomFill_SectionLaw self, NCollection_Array1_Handle_GeomFill_SectionLaw theOther) -> NCollection_Array1_Handle_GeomFill_SectionLaw

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_SectionLaw_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _GeomFill.NCollection_Array1_Handle_GeomFill_SectionLaw_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_GeomFill_SectionLaw self) -> Handle_GeomFill_SectionLaw

        @return first element

        :rtype: TheItemType &

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_SectionLaw_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _GeomFill.NCollection_Array1_Handle_GeomFill_SectionLaw_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_GeomFill_SectionLaw self) -> Handle_GeomFill_SectionLaw

        @return last element

        :rtype: TheItemType &

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_SectionLaw_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GeomFill.NCollection_Array1_Handle_GeomFill_SectionLaw_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_GeomFill_SectionLaw self, Standard_Integer const theIndex) -> Handle_GeomFill_SectionLaw

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_SectionLaw_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GeomFill.NCollection_Array1_Handle_GeomFill_SectionLaw___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GeomFill.NCollection_Array1_Handle_GeomFill_SectionLaw_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_GeomFill_SectionLaw self, Standard_Integer const theIndex, Handle_GeomFill_SectionLaw theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_SectionLaw_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_GeomFill_SectionLaw self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_SectionLaw_Resize(self, *args)

    __swig_destroy__ = _GeomFill.delete_NCollection_Array1_Handle_GeomFill_SectionLaw
NCollection_Array1_Handle_GeomFill_SectionLaw_swigregister = _GeomFill.NCollection_Array1_Handle_GeomFill_SectionLaw_swigregister
NCollection_Array1_Handle_GeomFill_SectionLaw_swigregister(NCollection_Array1_Handle_GeomFill_SectionLaw)


try:
	GeomFill_Array1OfSectionLaw = NCollection_Array1_Handle_GeomFill_SectionLaw
except NameError:
	pass # does not exist, probably ignored

class GeomFill_QuasiAngularConvertor(object):
    """
    To convert circular section in QuasiAngular Bezier
    form
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomFill_QuasiAngularConvertor self) -> GeomFill_QuasiAngularConvertor

        To convert circular section in QuasiAngular Bezier
        form
        """
        this = _GeomFill.new_GeomFill_QuasiAngularConvertor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialized(self, *args):
        """
        Initialized(GeomFill_QuasiAngularConvertor self) -> Standard_Boolean

        say if <me> is Initialized

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_QuasiAngularConvertor_Initialized(self, *args)


    def Init(self, *args):
        """Init(GeomFill_QuasiAngularConvertor self)"""
        return _GeomFill.GeomFill_QuasiAngularConvertor_Init(self, *args)


    def Section(self, *args):
        """
        Section(GeomFill_QuasiAngularConvertor self, gp_Pnt FirstPnt, gp_Pnt Center, gp_Vec Dir, Standard_Real const Angle, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weights)
        Section(GeomFill_QuasiAngularConvertor self, gp_Pnt FirstPnt, gp_Vec DFirstPnt, gp_Pnt Center, gp_Vec DCenter, gp_Vec Dir, gp_Vec DDir, Standard_Real const Angle, Standard_Real const DAngle, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real DWeights)
        Section(GeomFill_QuasiAngularConvertor self, gp_Pnt FirstPnt, gp_Vec DFirstPnt, gp_Vec D2FirstPnt, gp_Pnt Center, gp_Vec DCenter, gp_Vec D2Center, gp_Vec Dir, gp_Vec DDir, gp_Vec D2Dir, Standard_Real const Angle, Standard_Real const DAngle, Standard_Real const D2Angle, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_Standard_Real Weights, NCollection_Array1_Standard_Real DWeights, NCollection_Array1_Standard_Real D2Weights)

        :type FirstPnt: OCC.wrapper.gp.gp_Pnt
        :type DFirstPnt: OCC.wrapper.gp.gp_Vec
        :type D2FirstPnt: OCC.wrapper.gp.gp_Vec
        :type Center: OCC.wrapper.gp.gp_Pnt
        :type DCenter: OCC.wrapper.gp.gp_Vec
        :type D2Center: OCC.wrapper.gp.gp_Vec
        :type Dir: OCC.wrapper.gp.gp_Vec
        :type DDir: OCC.wrapper.gp.gp_Vec
        :type D2Dir: OCC.wrapper.gp.gp_Vec
        :type Angle: float
        :type DAngle: float
        :type D2Angle: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeights: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weights: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_QuasiAngularConvertor_Section(self, *args)

    __swig_destroy__ = _GeomFill.delete_GeomFill_QuasiAngularConvertor
GeomFill_QuasiAngularConvertor_swigregister = _GeomFill.GeomFill_QuasiAngularConvertor_swigregister
GeomFill_QuasiAngularConvertor_swigregister(GeomFill_QuasiAngularConvertor)

class Handle_GeomFill_ConstantBiNormal(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_ConstantBiNormal self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_ConstantBiNormal self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_ConstantBiNormal self, GeomFill_ConstantBiNormal thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_ConstantBiNormal self, Handle_GeomFill_ConstantBiNormal theHandle) -> Handle_GeomFill_ConstantBiNormal
        assign(Handle_GeomFill_ConstantBiNormal self, GeomFill_ConstantBiNormal thePtr) -> Handle_GeomFill_ConstantBiNormal
        assign(Handle_GeomFill_ConstantBiNormal self, Handle_GeomFill_ConstantBiNormal theHandle) -> Handle_GeomFill_ConstantBiNormal

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_ConstantBiNormal self) -> GeomFill_ConstantBiNormal

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_ConstantBiNormal self) -> GeomFill_ConstantBiNormal

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_ConstantBiNormal self) -> GeomFill_ConstantBiNormal

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_ConstantBiNormal___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_ConstantBiNormal___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_ConstantBiNormal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_ConstantBiNormal_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_ConstantBiNormal

    def Copy(self, *args):
        """
        Copy(Handle_GeomFill_ConstantBiNormal self) -> Handle_GeomFill_TrihedronLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_TrihedronLaw

        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal_Copy(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(Handle_GeomFill_ConstantBiNormal self, Handle_Adaptor3d_HCurve C)

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal_SetCurve(self, *args)


    def D0(self, *args):
        """
        D0(Handle_GeomFill_ConstantBiNormal self, Standard_Real const Param, gp_Vec Tangent, gp_Vec Normal, gp_Vec BiNormal) -> Standard_Boolean

        Computes Triedrhon on curve at parameter <Param>

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_ConstantBiNormal self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec BiNormal, gp_Vec DBiNormal) -> Standard_Boolean

        Computes Triedrhon and  derivative Trihedron  on curve
        at parameter <Param>
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_GeomFill_ConstantBiNormal self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec D2Tangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec D2Normal, gp_Vec BiNormal, gp_Vec DBiNormal, gp_Vec D2BiNormal) -> Standard_Boolean

        compute  Trihedron on curve
        first and seconde  derivatives.
        Warning : It used only for C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type D2Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type D2Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :type D2BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal_D2(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_GeomFill_ConstantBiNormal self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_GeomFill_ConstantBiNormal self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal_Intervals(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(Handle_GeomFill_ConstantBiNormal self, gp_Vec ATangent, gp_Vec ANormal, gp_Vec ABiNormal)

        Gets average value of Tangent(t) and Normal(t) it is usfull to
        make fast approximation of rational  surfaces.

        :type ATangent: OCC.wrapper.gp.gp_Vec
        :type ANormal: OCC.wrapper.gp.gp_Vec
        :type ABiNormal: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal_GetAverageLaw(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(Handle_GeomFill_ConstantBiNormal self) -> Standard_Boolean

        Says if the law is Constant.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal_IsConstant(self, *args)


    def IsOnlyBy3dCurve(self, *args):
        """
        IsOnlyBy3dCurve(Handle_GeomFill_ConstantBiNormal self) -> Standard_Boolean

        Return True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal_IsOnlyBy3dCurve(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_ConstantBiNormal self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_ConstantBiNormal_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_ConstantBiNormal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_GeomFill_ConstantBiNormal self) -> GeomFill_PipeError

        Give a status to the Law
        Returns PipeOk (default implementation)

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal_ErrorStatus(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Handle_GeomFill_ConstantBiNormal self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal_SetInterval(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(Handle_GeomFill_ConstantBiNormal self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal_GetInterval(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_ConstantBiNormal self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_ConstantBiNormal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_ConstantBiNormal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_ConstantBiNormal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_ConstantBiNormal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_ConstantBiNormal self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_ConstantBiNormal self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_ConstantBiNormal self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_ConstantBiNormal self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_ConstantBiNormal_DecrementRefCounter(self, *args)

Handle_GeomFill_ConstantBiNormal_swigregister = _GeomFill.Handle_GeomFill_ConstantBiNormal_swigregister
Handle_GeomFill_ConstantBiNormal_swigregister(Handle_GeomFill_ConstantBiNormal)

def Handle_GeomFill_ConstantBiNormal_DownCast(thing):
    return _GeomFill.Handle_GeomFill_ConstantBiNormal_DownCast(thing)
Handle_GeomFill_ConstantBiNormal_DownCast = _GeomFill.Handle_GeomFill_ConstantBiNormal_DownCast

class GeomFill_Line(Standard.Standard_Transient):
    """class for instantiation of AppBlend"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_Line
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_Line(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GeomFill_Line self) -> GeomFill_Line
        __init__(GeomFill_Line self, Standard_Integer const NbPoints) -> GeomFill_Line

        :type NbPoints: int

        """
        this = _GeomFill.new_GeomFill_Line(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NbPoints(self, *args):
        """
        NbPoints(GeomFill_Line self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_Line_NbPoints(self, *args)


    def Point(self, *args):
        """
        Point(GeomFill_Line self, Standard_Integer const Index) -> Standard_Integer

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_Line_Point(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_Line_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_Line_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_Line_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_Line
GeomFill_Line_swigregister = _GeomFill.GeomFill_Line_swigregister
GeomFill_Line_swigregister(GeomFill_Line)

def GeomFill_Line_get_type_name(*args):
    """
    GeomFill_Line_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_Line_get_type_name(*args)

def GeomFill_Line_get_type_descriptor(*args):
    """
    GeomFill_Line_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_Line_get_type_descriptor(*args)

class GeomFill_Coons(GeomFill_Filling):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomFill_Coons self) -> GeomFill_Coons
        __init__(GeomFill_Coons self, NCollection_Array1_gp_Pnt P1, NCollection_Array1_gp_Pnt P2, NCollection_Array1_gp_Pnt P3, NCollection_Array1_gp_Pnt P4) -> GeomFill_Coons
        __init__(GeomFill_Coons self, NCollection_Array1_gp_Pnt P1, NCollection_Array1_gp_Pnt P2, NCollection_Array1_gp_Pnt P3, NCollection_Array1_gp_Pnt P4, NCollection_Array1_Standard_Real W1, NCollection_Array1_Standard_Real W2, NCollection_Array1_Standard_Real W3, NCollection_Array1_Standard_Real W4) -> GeomFill_Coons

        :type P1: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type P2: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type P3: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type P4: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type W1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type W2: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type W3: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type W4: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        this = _GeomFill.new_GeomFill_Coons(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(GeomFill_Coons self, NCollection_Array1_gp_Pnt P1, NCollection_Array1_gp_Pnt P2, NCollection_Array1_gp_Pnt P3, NCollection_Array1_gp_Pnt P4)
        Init(GeomFill_Coons self, NCollection_Array1_gp_Pnt P1, NCollection_Array1_gp_Pnt P2, NCollection_Array1_gp_Pnt P3, NCollection_Array1_gp_Pnt P4, NCollection_Array1_Standard_Real W1, NCollection_Array1_Standard_Real W2, NCollection_Array1_Standard_Real W3, NCollection_Array1_Standard_Real W4)

        :type P1: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type P2: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type P3: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type P4: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type W1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type W2: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type W3: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type W4: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_Coons_Init(self, *args)

    __swig_destroy__ = _GeomFill.delete_GeomFill_Coons
GeomFill_Coons_swigregister = _GeomFill.GeomFill_Coons_swigregister
GeomFill_Coons_swigregister(GeomFill_Coons)

class Handle_GeomFill_LocationLaw(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_LocationLaw self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_LocationLaw_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_LocationLaw self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_LocationLaw self, GeomFill_LocationLaw thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_LocationLaw self, Handle_GeomFill_LocationLaw theHandle) -> Handle_GeomFill_LocationLaw
        assign(Handle_GeomFill_LocationLaw self, GeomFill_LocationLaw thePtr) -> Handle_GeomFill_LocationLaw
        assign(Handle_GeomFill_LocationLaw self, Handle_GeomFill_LocationLaw theHandle) -> Handle_GeomFill_LocationLaw

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_LocationLaw self) -> GeomFill_LocationLaw

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_LocationLaw self) -> GeomFill_LocationLaw

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_LocationLaw___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_LocationLaw self) -> GeomFill_LocationLaw

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_LocationLaw___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_LocationLaw___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_LocationLaw___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_LocationLaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_LocationLaw_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_LocationLaw

    def SetCurve(self, *args):
        """
        SetCurve(Handle_GeomFill_LocationLaw self, Handle_Adaptor3d_HCurve C)

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_SetCurve(self, *args)


    def GetCurve(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        res = _GeomFill.Handle_GeomFill_LocationLaw_GetCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTrsf(self, *args):
        """
        SetTrsf(Handle_GeomFill_LocationLaw self, gp_Mat Transfo)

        Set a transformation Matrix like   the law M(t) become
        Mat * M(t)

        :type Transfo: OCC.wrapper.gp.gp_Mat

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_SetTrsf(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_GeomFill_LocationLaw self) -> Handle_GeomFill_LocationLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_LocationLaw

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_Copy(self, *args)


    def D0(self, *args):
        """
        D0(Handle_GeomFill_LocationLaw self, Standard_Real const Param, gp_Mat M, gp_Vec V) -> Standard_Boolean
        D0(Handle_GeomFill_LocationLaw self, Standard_Real const Param, gp_Mat M, gp_Vec V, NCollection_Array1_gp_Pnt2d Poles2d) -> Standard_Boolean

        compute Location and 2d points

        :type Param: float
        :type M: OCC.wrapper.gp.gp_Mat
        :type V: OCC.wrapper.gp.gp_Vec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_LocationLaw self, Standard_Real const Param, gp_Mat M, gp_Vec V, gp_Mat DM, gp_Vec DV, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d) -> Standard_Boolean

        compute location 2d  points and  associated
        first derivatives.
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type M: OCC.wrapper.gp.gp_Mat
        :type V: OCC.wrapper.gp.gp_Vec
        :type DM: OCC.wrapper.gp.gp_Mat
        :type DV: OCC.wrapper.gp.gp_Vec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_GeomFill_LocationLaw self, Standard_Real const Param, gp_Mat M, gp_Vec V, gp_Mat DM, gp_Vec DV, gp_Mat D2M, gp_Vec D2V, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d) -> Standard_Boolean

        compute location 2d  points and associated
        first and seconde  derivatives.
        Warning : It used only for C2 aproximation

        :type Param: float
        :type M: OCC.wrapper.gp.gp_Mat
        :type V: OCC.wrapper.gp.gp_Vec
        :type DM: OCC.wrapper.gp.gp_Mat
        :type DV: OCC.wrapper.gp.gp_Vec
        :type D2M: OCC.wrapper.gp.gp_Mat
        :type D2V: OCC.wrapper.gp.gp_Vec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type D2Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_D2(self, *args)


    def Nb2dCurves(self, *args):
        """
        Nb2dCurves(Handle_GeomFill_LocationLaw self) -> Standard_Integer

        get the number of  2d  curves (Restrictions  +  Traces)
        to approximate.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_Nb2dCurves(self, *args)


    def HasFirstRestriction(self, *args):
        """
        HasFirstRestriction(Handle_GeomFill_LocationLaw self) -> Standard_Boolean

        Say if the first restriction is defined in this class.
        If it  is true the  first element  of poles array   in
        D0,D1,D2... Correspond to this restriction.
        Returns Standard_False (default implementation)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_HasFirstRestriction(self, *args)


    def HasLastRestriction(self, *args):
        """
        HasLastRestriction(Handle_GeomFill_LocationLaw self) -> Standard_Boolean

        Say if the last restriction is defined in this class.
        If it is  true the  last element  of poles array in
        D0,D1,D2... Correspond to this restriction.
        Returns Standard_False (default implementation)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_HasLastRestriction(self, *args)


    def TraceNumber(self, *args):
        """
        TraceNumber(Handle_GeomFill_LocationLaw self) -> Standard_Integer

        Give the number of trace (Curves 2d wich are not restriction)
        Returns 0 (default implementation)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_TraceNumber(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_GeomFill_LocationLaw self) -> GeomFill_PipeError

        Give a status to the Law
        Returns PipeOk (default implementation)

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_ErrorStatus(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_GeomFill_LocationLaw self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_GeomFill_LocationLaw self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Handle_GeomFill_LocationLaw self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_SetInterval(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(Handle_GeomFill_LocationLaw self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_GetInterval(self, *args)


    def GetDomain(self, *args):
        """
        GetDomain(Handle_GeomFill_LocationLaw self)

        Gets the bounds of the function parametric domain.
        Warning: This domain it is  not modified by the
        SetValue method

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_GetDomain(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Handle_GeomFill_LocationLaw self, Standard_Integer const Index, Standard_Real const Tol)

        Returns the resolutions in the  sub-space 2d <Index>
        This information is usfull to find an good tolerance in
        2d approximation.

        :type Index: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_Resolution(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_GeomFill_LocationLaw self, Standard_Real const Tol3d, Standard_Real const Tol2d)

        Is usefull, if (me) have to run numerical
        algorithm to perform D0, D1 or D2
        The default implementation make nothing.

        :type Tol3d: float
        :type Tol2d: float

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_SetTolerance(self, *args)


    def GetMaximalNorm(self, *args):
        """
        GetMaximalNorm(Handle_GeomFill_LocationLaw self) -> Standard_Real

        Get the maximum Norm  of the matrix-location part.  It
        is usful to find an good Tolerance to approx M(t).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_GetMaximalNorm(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(Handle_GeomFill_LocationLaw self, gp_Mat AM, gp_Vec AV)

        Get average value of M(t) and V(t) it is usfull to
        make fast approximation of rational surfaces.

        :type AM: OCC.wrapper.gp.gp_Mat
        :type AV: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_GetAverageLaw(self, *args)


    def IsTranslation(self, *args):
        """
        IsTranslation(Handle_GeomFill_LocationLaw self) -> Standard_Boolean

        Say if the Location  Law, is an translation of  Location
        The default implementation is " returns False ".

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_IsTranslation(self, *args)


    def IsRotation(self, *args):
        """
        IsRotation(Handle_GeomFill_LocationLaw self) -> Standard_Boolean

        Say if the Location  Law, is a rotation of Location
        The default implementation is " returns False ".

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_IsRotation(self, *args)


    def Rotation(self, *args):
        """
        Rotation(Handle_GeomFill_LocationLaw self, gp_Pnt Center)

        :type Center: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_Rotation(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_LocationLaw self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_LocationLaw_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_LocationLaw_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_LocationLaw self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_LocationLaw_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_LocationLaw self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_LocationLaw self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_LocationLaw self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_LocationLaw self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_LocationLaw self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_LocationLaw self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_LocationLaw self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_LocationLaw_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_LocationLaw self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_LocationLaw_DecrementRefCounter(self, *args)

Handle_GeomFill_LocationLaw_swigregister = _GeomFill.Handle_GeomFill_LocationLaw_swigregister
Handle_GeomFill_LocationLaw_swigregister(Handle_GeomFill_LocationLaw)

def Handle_GeomFill_LocationLaw_DownCast(thing):
    return _GeomFill.Handle_GeomFill_LocationLaw_DownCast(thing)
Handle_GeomFill_LocationLaw_DownCast = _GeomFill.Handle_GeomFill_LocationLaw_DownCast

class GeomFill_FunctionGuide(math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomFill_FunctionGuide self, Handle_GeomFill_SectionLaw S, Handle_Adaptor3d_HCurve Guide, Standard_Real const ParamOnLaw=0.0) -> GeomFill_FunctionGuide

        :type S: OCC.wrapper.GeomFill.Handle_GeomFill_SectionLaw
        :type Guide: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type ParamOnLaw: float

        """
        this = _GeomFill.new_GeomFill_FunctionGuide(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetParam(self, *args):
        """
        SetParam(GeomFill_FunctionGuide self, Standard_Real const Param, gp_Pnt Centre, gp_XYZ Dir, gp_XYZ XDir)

        :type Param: float
        :type Centre: OCC.wrapper.gp.gp_Pnt
        :type Dir: OCC.wrapper.gp.gp_XYZ
        :type XDir: OCC.wrapper.gp.gp_XYZ

        """
        return _GeomFill.GeomFill_FunctionGuide_SetParam(self, *args)


    def NbVariables(self, *args):
        """
        NbVariables(GeomFill_FunctionGuide self) -> Standard_Integer

        returns the number of variables of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_FunctionGuide_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(GeomFill_FunctionGuide self) -> Standard_Integer

        returns the number of equations of the function.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_FunctionGuide_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(GeomFill_FunctionGuide self, math_Vector X, math_Vector F) -> Standard_Boolean

        computes the values <F> of the Functions for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_FunctionGuide_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(GeomFill_FunctionGuide self, math_Vector X, math_Matrix D) -> Standard_Boolean

        returns the values <D> of the derivatives for the
        variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_FunctionGuide_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(GeomFill_FunctionGuide self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        returns the values <F> of the functions and the derivatives
        <D> for the variable <X>.
        Returns True if the computation was done successfully,
        False otherwise.

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_FunctionGuide_Values(self, *args)


    def DerivT(self, *args):
        """
        DerivT(GeomFill_FunctionGuide self, math_Vector X, gp_XYZ DCentre, gp_XYZ DDir, math_Vector DFDT) -> Standard_Boolean

        returns the values <F> of the T derivatives for
        the parameter Param .

        :type X: OCC.wrapper.math.math_Vector
        :type DCentre: OCC.wrapper.gp.gp_XYZ
        :type DDir: OCC.wrapper.gp.gp_XYZ
        :type DFDT: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_FunctionGuide_DerivT(self, *args)

    __swig_destroy__ = _GeomFill.delete_GeomFill_FunctionGuide
GeomFill_FunctionGuide_swigregister = _GeomFill.GeomFill_FunctionGuide_swigregister
GeomFill_FunctionGuide_swigregister(GeomFill_FunctionGuide)

class GeomFill_EvolvedSection(GeomFill_SectionLaw):
    """Define an Constant Section Law"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_EvolvedSection
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_EvolvedSection(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GeomFill_EvolvedSection self, Handle_Geom_Curve C, Handle_Law_Function L) -> GeomFill_EvolvedSection

        Make an SectionLaw with a Curve and a real  Law.

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.Law.Handle_Law_Function

        """
        this = _GeomFill.new_GeomFill_EvolvedSection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def D0(self, *args):
        """
        D0(GeomFill_EvolvedSection self, Standard_Real const Param, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weigths) -> Standard_Boolean

        compute the section for v = param

        :type Param: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_EvolvedSection_D0(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_EvolvedSection self, Standard_Real const Param, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean

        compute the first  derivative in v direction  of the
        section for v =  param
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_EvolvedSection_D1(self, *args)


    def D2(self, *args):
        """
        D2(GeomFill_EvolvedSection self, Standard_Real const Param, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        compute the second derivative  in v direction of the
        section  for v = param
        Warning : It used only for C2 aproximation

        :type Param: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_EvolvedSection_D2(self, *args)


    def BSplineSurface(self, *args):
        """
        BSplineSurface(GeomFill_EvolvedSection self) -> Handle_Geom_BSplineSurface

        give if possible an bspline Surface, like iso-v are the
        section.  If it is  not possible  this methode have  to
        get an Null Surface.  Is it the default implementation.

        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

        """
        return _GeomFill.GeomFill_EvolvedSection_BSplineSurface(self, *args)


    def SectionShape(self, *args):
        """
        SectionShape(GeomFill_EvolvedSection self)

        get the format of an  section

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int

        """
        return _GeomFill.GeomFill_EvolvedSection_SectionShape(self, *args)


    def Knots(self, *args):
        """
        Knots(GeomFill_EvolvedSection self, NCollection_Array1_Standard_Real TKnots)

        get the Knots of the section

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_EvolvedSection_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(GeomFill_EvolvedSection self, NCollection_Array1_Standard_Integer TMults)

        get the Multplicities of the section

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _GeomFill.GeomFill_EvolvedSection_Mults(self, *args)


    def IsRational(self, *args):
        """
        IsRational(GeomFill_EvolvedSection self) -> Standard_Boolean

        Returns if the sections are rationnal or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_EvolvedSection_IsRational(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(GeomFill_EvolvedSection self) -> Standard_Boolean

        Returns if the sections are periodic or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_EvolvedSection_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(GeomFill_EvolvedSection self) -> Standard_Boolean

        Returns if the law  isperiodic or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_EvolvedSection_IsVPeriodic(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(GeomFill_EvolvedSection self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_EvolvedSection_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(GeomFill_EvolvedSection self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.GeomFill_EvolvedSection_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(GeomFill_EvolvedSection self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_EvolvedSection_SetInterval(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(GeomFill_EvolvedSection self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_EvolvedSection_GetInterval(self, *args)


    def GetDomain(self, *args):
        """
        GetDomain(GeomFill_EvolvedSection self)

        Gets the bounds of the function parametric domain.
        Warning: This domain it is  not modified by the
        SetValue method

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_EvolvedSection_GetDomain(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(GeomFill_EvolvedSection self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, NCollection_Array1_Standard_Real Tol3d)

        Returns the tolerances associated at each poles to
        reach  in approximation, to satisfy: BoundTol error
        at the   Boundary  AngleTol tangent error  at  the
        Boundary  (in radian)  SurfTol   error inside the
        surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_EvolvedSection_GetTolerance(self, *args)


    def BarycentreOfSurf(self, *args):
        """
        BarycentreOfSurf(GeomFill_EvolvedSection self) -> gp_Pnt

        Get the barycentre of Surface.
        An   very  poor estimation is sufficent.
        This information is usefull to perform well
        conditioned rational approximation.
        Warning: Used only if <me> IsRational

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.GeomFill_EvolvedSection_BarycentreOfSurf(self, *args)


    def MaximalSection(self, *args):
        """
        MaximalSection(GeomFill_EvolvedSection self) -> Standard_Real

        Returns the   length of the greater section. This
        information is usefull to G1's control.
        Warning: With an little value, approximation can be slower.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_EvolvedSection_MaximalSection(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(GeomFill_EvolvedSection self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        in all  sections.
        This information is  usefull to control error
        in rational approximation.
        Warning: Used only if <me> IsRational

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_EvolvedSection_GetMinimalWeight(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(GeomFill_EvolvedSection self) -> Standard_Boolean

        return True If the Law isConstant

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_EvolvedSection_IsConstant(self, *args)


    def ConstantSection(self, *args):
        """
        ConstantSection(GeomFill_EvolvedSection self) -> Handle_Geom_Curve

        Return the constant Section if <me>  IsConstant.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _GeomFill.GeomFill_EvolvedSection_ConstantSection(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_EvolvedSection_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_EvolvedSection_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_EvolvedSection_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_EvolvedSection
GeomFill_EvolvedSection_swigregister = _GeomFill.GeomFill_EvolvedSection_swigregister
GeomFill_EvolvedSection_swigregister(GeomFill_EvolvedSection)

def GeomFill_EvolvedSection_get_type_name(*args):
    """
    GeomFill_EvolvedSection_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_EvolvedSection_get_type_name(*args)

def GeomFill_EvolvedSection_get_type_descriptor(*args):
    """
    GeomFill_EvolvedSection_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_EvolvedSection_get_type_descriptor(*args)

class GeomFill_LocFunction(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomFill_LocFunction self, Handle_GeomFill_LocationLaw Law) -> GeomFill_LocFunction

        :type Law: OCC.wrapper.GeomFill.Handle_GeomFill_LocationLaw

        """
        this = _GeomFill.new_GeomFill_LocFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def D0(self, *args):
        """
        D0(GeomFill_LocFunction self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last) -> Standard_Boolean

        compute the section for v = param

        :type Param: float
        :type First: float
        :type Last: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_LocFunction_D0(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_LocFunction self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last) -> Standard_Boolean

        compute the first  derivative in v direction  of the
        section for v =  param

        :type Param: float
        :type First: float
        :type Last: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_LocFunction_D1(self, *args)


    def D2(self, *args):
        """
        D2(GeomFill_LocFunction self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last) -> Standard_Boolean

        compute the second derivative  in v direction of the
        section  for v = param

        :type Param: float
        :type First: float
        :type Last: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_LocFunction_D2(self, *args)


    def DN(self, *args):
        """
        DN(GeomFill_LocFunction self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, Standard_Integer const Order)

        :type Param: float
        :type First: float
        :type Last: float
        :type Order: int
        :type Result: float
        :type Ier: int

        """
        return _GeomFill.GeomFill_LocFunction_DN(self, *args)

    __swig_destroy__ = _GeomFill.delete_GeomFill_LocFunction
GeomFill_LocFunction_swigregister = _GeomFill.GeomFill_LocFunction_swigregister
GeomFill_LocFunction_swigregister(GeomFill_LocFunction)

class GeomFill_PolynomialConvertor(object):
    """To convert circular section in polynome"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomFill_PolynomialConvertor self) -> GeomFill_PolynomialConvertor

        To convert circular section in polynome
        """
        this = _GeomFill.new_GeomFill_PolynomialConvertor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialized(self, *args):
        """
        Initialized(GeomFill_PolynomialConvertor self) -> Standard_Boolean

        say if <me> is Initialized

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_PolynomialConvertor_Initialized(self, *args)


    def Init(self, *args):
        """Init(GeomFill_PolynomialConvertor self)"""
        return _GeomFill.GeomFill_PolynomialConvertor_Init(self, *args)


    def Section(self, *args):
        """
        Section(GeomFill_PolynomialConvertor self, gp_Pnt FirstPnt, gp_Pnt Center, gp_Vec Dir, Standard_Real const Angle, NCollection_Array1_gp_Pnt Poles)
        Section(GeomFill_PolynomialConvertor self, gp_Pnt FirstPnt, gp_Vec DFirstPnt, gp_Pnt Center, gp_Vec DCenter, gp_Vec Dir, gp_Vec DDir, Standard_Real const Angle, Standard_Real const DAngle, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles)
        Section(GeomFill_PolynomialConvertor self, gp_Pnt FirstPnt, gp_Vec DFirstPnt, gp_Vec D2FirstPnt, gp_Pnt Center, gp_Vec DCenter, gp_Vec D2Center, gp_Vec Dir, gp_Vec DDir, gp_Vec D2Dir, Standard_Real const Angle, Standard_Real const DAngle, Standard_Real const D2Angle, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles)

        :type FirstPnt: OCC.wrapper.gp.gp_Pnt
        :type DFirstPnt: OCC.wrapper.gp.gp_Vec
        :type D2FirstPnt: OCC.wrapper.gp.gp_Vec
        :type Center: OCC.wrapper.gp.gp_Pnt
        :type DCenter: OCC.wrapper.gp.gp_Vec
        :type D2Center: OCC.wrapper.gp.gp_Vec
        :type Dir: OCC.wrapper.gp.gp_Vec
        :type DDir: OCC.wrapper.gp.gp_Vec
        :type D2Dir: OCC.wrapper.gp.gp_Vec
        :type Angle: float
        :type DAngle: float
        :type D2Angle: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec

        """
        return _GeomFill.GeomFill_PolynomialConvertor_Section(self, *args)

    __swig_destroy__ = _GeomFill.delete_GeomFill_PolynomialConvertor
GeomFill_PolynomialConvertor_swigregister = _GeomFill.GeomFill_PolynomialConvertor_swigregister
GeomFill_PolynomialConvertor_swigregister(GeomFill_PolynomialConvertor)

class Handle_GeomFill_TgtOnCoons(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_TgtOnCoons self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_TgtOnCoons_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_TgtOnCoons self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_TgtOnCoons_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_TgtOnCoons self, GeomFill_TgtOnCoons thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_TgtOnCoons_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_TgtOnCoons self, Handle_GeomFill_TgtOnCoons theHandle) -> Handle_GeomFill_TgtOnCoons
        assign(Handle_GeomFill_TgtOnCoons self, GeomFill_TgtOnCoons thePtr) -> Handle_GeomFill_TgtOnCoons
        assign(Handle_GeomFill_TgtOnCoons self, Handle_GeomFill_TgtOnCoons theHandle) -> Handle_GeomFill_TgtOnCoons

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_TgtOnCoons_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_TgtOnCoons self) -> GeomFill_TgtOnCoons

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_TgtOnCoons_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_TgtOnCoons self) -> GeomFill_TgtOnCoons

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_TgtOnCoons___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_TgtOnCoons self) -> GeomFill_TgtOnCoons

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_TgtOnCoons___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_TgtOnCoons___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_TgtOnCoons___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_TgtOnCoons(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_TgtOnCoons_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_TgtOnCoons

    def Value(self, *args):
        """
        Value(Handle_GeomFill_TgtOnCoons self, Standard_Real const W) -> gp_Vec

        Computes  the value  of the    field of tangency    at
        parameter W.

        :type W: float
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_TgtOnCoons_Value(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_TgtOnCoons self, Standard_Real const W) -> gp_Vec
        D1(Handle_GeomFill_TgtOnCoons self, Standard_Real const W, gp_Vec T, gp_Vec DT)

        Computes the value and the  derivative of the field of
        tangency at parameter W.

        :type W: float
        :type T: OCC.wrapper.gp.gp_Vec
        :type DT: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_TgtOnCoons_D1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_TgtOnCoons self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_TgtOnCoons_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_TgtOnCoons_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_TgtOnCoons_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsScalable(self, *args):
        """
        IsScalable(Handle_GeomFill_TgtOnCoons self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_TgtOnCoons_IsScalable(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_GeomFill_TgtOnCoons self, Handle_Law_BSpline Func)

        :type Func: OCC.wrapper.Law.Handle_Law_BSpline

        """
        return _GeomFill.Handle_GeomFill_TgtOnCoons_Scale(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_TgtOnCoons self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_TgtOnCoons_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_TgtOnCoons self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_TgtOnCoons self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_TgtOnCoons_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_TgtOnCoons self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_TgtOnCoons self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_TgtOnCoons_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_TgtOnCoons self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_TgtOnCoons_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_TgtOnCoons self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_TgtOnCoons_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_TgtOnCoons self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_TgtOnCoons_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_TgtOnCoons self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_TgtOnCoons_DecrementRefCounter(self, *args)

Handle_GeomFill_TgtOnCoons_swigregister = _GeomFill.Handle_GeomFill_TgtOnCoons_swigregister
Handle_GeomFill_TgtOnCoons_swigregister(Handle_GeomFill_TgtOnCoons)

def Handle_GeomFill_TgtOnCoons_DownCast(thing):
    return _GeomFill.Handle_GeomFill_TgtOnCoons_DownCast(thing)
Handle_GeomFill_TgtOnCoons_DownCast = _GeomFill.Handle_GeomFill_TgtOnCoons_DownCast

class Handle_GeomFill_Fixed(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_Fixed self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_Fixed_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_Fixed self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_Fixed_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_Fixed self, GeomFill_Fixed thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_Fixed_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_Fixed self, Handle_GeomFill_Fixed theHandle) -> Handle_GeomFill_Fixed
        assign(Handle_GeomFill_Fixed self, GeomFill_Fixed thePtr) -> Handle_GeomFill_Fixed
        assign(Handle_GeomFill_Fixed self, Handle_GeomFill_Fixed theHandle) -> Handle_GeomFill_Fixed

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_Fixed_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_Fixed self) -> GeomFill_Fixed

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_Fixed_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_Fixed self) -> GeomFill_Fixed

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_Fixed___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_Fixed self) -> GeomFill_Fixed

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_Fixed___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_Fixed___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_Fixed___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_Fixed(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_Fixed_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_Fixed

    def Copy(self, *args):
        """
        Copy(Handle_GeomFill_Fixed self) -> Handle_GeomFill_TrihedronLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_TrihedronLaw

        """
        return _GeomFill.Handle_GeomFill_Fixed_Copy(self, *args)


    def D0(self, *args):
        """
        D0(Handle_GeomFill_Fixed self, Standard_Real const Param, gp_Vec Tangent, gp_Vec Normal, gp_Vec BiNormal) -> Standard_Boolean

        compute Triedrhon on curve at parameter <Param>

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Fixed_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_Fixed self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec BiNormal, gp_Vec DBiNormal) -> Standard_Boolean

        compute Triedrhon and  derivative Trihedron  on curve
        at parameter <Param>
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Fixed_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_GeomFill_Fixed self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec D2Tangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec D2Normal, gp_Vec BiNormal, gp_Vec DBiNormal, gp_Vec D2BiNormal) -> Standard_Boolean

        compute  Trihedron on curve
        first and seconde  derivatives.
        Warning : It used only for C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type D2Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type D2Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :type D2BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Fixed_D2(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_GeomFill_Fixed self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_Fixed_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_GeomFill_Fixed self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.Handle_GeomFill_Fixed_Intervals(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(Handle_GeomFill_Fixed self, gp_Vec ATangent, gp_Vec ANormal, gp_Vec ABiNormal)

        Get average value of Tangent(t) and Normal(t) it is usfull to
        make fast approximation of rational  surfaces.

        :type ATangent: OCC.wrapper.gp.gp_Vec
        :type ANormal: OCC.wrapper.gp.gp_Vec
        :type ABiNormal: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_Fixed_GetAverageLaw(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(Handle_GeomFill_Fixed self) -> Standard_Boolean

        Return True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Fixed_IsConstant(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_Fixed self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_Fixed_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_Fixed_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_Fixed_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetCurve(self, *args):
        """
        SetCurve(Handle_GeomFill_Fixed self, Handle_Adaptor3d_HCurve C)

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.Handle_GeomFill_Fixed_SetCurve(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_GeomFill_Fixed self) -> GeomFill_PipeError

        Give a status to the Law
        Returns PipeOk (default implementation)

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _GeomFill.Handle_GeomFill_Fixed_ErrorStatus(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Handle_GeomFill_Fixed self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_Fixed_SetInterval(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(Handle_GeomFill_Fixed self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_Fixed_GetInterval(self, *args)


    def IsOnlyBy3dCurve(self, *args):
        """
        IsOnlyBy3dCurve(Handle_GeomFill_Fixed self) -> Standard_Boolean

        Say if the law is defined, only by the 3d Geometry of
        the setted Curve
        Return False by Default.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Fixed_IsOnlyBy3dCurve(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_Fixed self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_Fixed_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_Fixed self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_Fixed self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Fixed_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_Fixed self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_Fixed self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Fixed_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_Fixed self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_Fixed_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_Fixed self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_Fixed_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_Fixed self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_Fixed_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_Fixed self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_Fixed_DecrementRefCounter(self, *args)

Handle_GeomFill_Fixed_swigregister = _GeomFill.Handle_GeomFill_Fixed_swigregister
Handle_GeomFill_Fixed_swigregister(Handle_GeomFill_Fixed)

def Handle_GeomFill_Fixed_DownCast(thing):
    return _GeomFill.Handle_GeomFill_Fixed_DownCast(thing)
Handle_GeomFill_Fixed_DownCast = _GeomFill.Handle_GeomFill_Fixed_DownCast

class GeomFill_BezierCurves(object):
    """
    This class provides an algorithm for constructing a Bezier surface filled from
    contiguous Bezier curves which form its boundaries.
    The algorithm accepts two, three or four Bezier curves
    as the boundaries of the target surface.
    A range of filling styles - more or less rounded, more or less flat - is available.
    A BezierCurves object provides a framework for:
    -   defining the boundaries, and the filling style of the surface
    -   implementing the construction algorithm
    -   consulting the result.
    Warning
    Some problems may show up with rational curves.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomFill_BezierCurves self) -> GeomFill_BezierCurves
        __init__(GeomFill_BezierCurves self, Handle_Geom_BezierCurve C1, Handle_Geom_BezierCurve C2, Handle_Geom_BezierCurve C3, Handle_Geom_BezierCurve C4, GeomFill_FillingStyle const Type) -> GeomFill_BezierCurves
        __init__(GeomFill_BezierCurves self, Handle_Geom_BezierCurve C1, Handle_Geom_BezierCurve C2, Handle_Geom_BezierCurve C3, GeomFill_FillingStyle const Type) -> GeomFill_BezierCurves
        __init__(GeomFill_BezierCurves self, Handle_Geom_BezierCurve C1, Handle_Geom_BezierCurve C2, GeomFill_FillingStyle const Type) -> GeomFill_BezierCurves

        Constructs a framework for building a Bezier surface
        from the two contiguous Bezier curves, C1 and C2
        Raises Standard_ConstructionError if the curves are not contiguous.

        :type C1: OCC.wrapper.Geom.Handle_Geom_BezierCurve
        :type C2: OCC.wrapper.Geom.Handle_Geom_BezierCurve
        :type Type: OCC.wrapper.GeomFill.GeomFill_FillingStyle

        """
        this = _GeomFill.new_GeomFill_BezierCurves(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(GeomFill_BezierCurves self, Handle_Geom_BezierCurve C1, Handle_Geom_BezierCurve C2, Handle_Geom_BezierCurve C3, Handle_Geom_BezierCurve C4, GeomFill_FillingStyle const Type)
        Init(GeomFill_BezierCurves self, Handle_Geom_BezierCurve C1, Handle_Geom_BezierCurve C2, Handle_Geom_BezierCurve C3, GeomFill_FillingStyle const Type)
        Init(GeomFill_BezierCurves self, Handle_Geom_BezierCurve C1, Handle_Geom_BezierCurve C2, GeomFill_FillingStyle const Type)

        Initializes or reinitializes this algorithm with two, three,
        or four curves - C1, C2, C3, and C4 - and Type, one
        of the following filling styles:
        -   GeomFill_Stretch - the style with the flattest patch
        -   GeomFill_Coons - a rounded style of patch with
        less depth than that of Curved
        -   GeomFill_Curved - the style with the most rounded patch.
        Exceptions
        Standard_ConstructionError if the curves are not contiguous.

        :type C1: OCC.wrapper.Geom.Handle_Geom_BezierCurve
        :type C2: OCC.wrapper.Geom.Handle_Geom_BezierCurve
        :type Type: OCC.wrapper.GeomFill.GeomFill_FillingStyle

        """
        return _GeomFill.GeomFill_BezierCurves_Init(self, *args)


    def Surface(self, *args):
        """
        Returns the Bezier surface resulting from the
        computation performed by this algorithm.

        :rtype: OCC.wrapper.Geom.Handle_Geom_BezierSurface

        """
        res = _GeomFill.GeomFill_BezierCurves_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_BezierCurves
GeomFill_BezierCurves_swigregister = _GeomFill.GeomFill_BezierCurves_swigregister
GeomFill_BezierCurves_swigregister(GeomFill_BezierCurves)

class GeomFill_BSplineCurves(object):
    """
    An algorithm for constructing a BSpline surface filled
    from contiguous BSpline curves which form its boundaries.
    The algorithm accepts two, three or four BSpline
    curves as the boundaries of the target surface.
    A range of filling styles - more or less rounded, more
    or less flat - is available.
    A BSplineCurves object provides a framework for:
    -   defining the boundaries, and the filling style of the surface
    -   implementing the construction algorithm
    -   consulting the result.
    Warning
    Some problems may show up with rational curves.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomFill_BSplineCurves self) -> GeomFill_BSplineCurves
        __init__(GeomFill_BSplineCurves self, Handle_Geom_BSplineCurve C1, Handle_Geom_BSplineCurve C2, Handle_Geom_BSplineCurve C3, Handle_Geom_BSplineCurve C4, GeomFill_FillingStyle const Type) -> GeomFill_BSplineCurves
        __init__(GeomFill_BSplineCurves self, Handle_Geom_BSplineCurve C1, Handle_Geom_BSplineCurve C2, Handle_Geom_BSplineCurve C3, GeomFill_FillingStyle const Type) -> GeomFill_BSplineCurves
        __init__(GeomFill_BSplineCurves self, Handle_Geom_BSplineCurve C1, Handle_Geom_BSplineCurve C2, GeomFill_FillingStyle const Type) -> GeomFill_BSplineCurves

        Constructs a framework for building a BSpline surface from either
        -   the four contiguous BSpline curves, C1, C2, C3 and C4, or
        -   the three contiguous BSpline curves, C1, C2 and C3, or
        -   the two contiguous BSpline curves, C1 and C2.
        The type of filling style Type to be used is one of:
        -   GeomFill_Stretch - the style with the flattest patch
        -   GeomFill_Coons - a rounded style of patch with
        less depth than that of Curved
        -   GeomFill_Curved - the style with the most rounded
        patch.Constructs a framework for building a BSpline
        surface common to the two BSpline curves, C1 and C2.
        Exceptions
        Standard_ConstructionError if the curves are not contiguous.

        :type C1: OCC.wrapper.Geom.Handle_Geom_BSplineCurve
        :type C2: OCC.wrapper.Geom.Handle_Geom_BSplineCurve
        :type Type: OCC.wrapper.GeomFill.GeomFill_FillingStyle

        """
        this = _GeomFill.new_GeomFill_BSplineCurves(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(GeomFill_BSplineCurves self, Handle_Geom_BSplineCurve C1, Handle_Geom_BSplineCurve C2, Handle_Geom_BSplineCurve C3, Handle_Geom_BSplineCurve C4, GeomFill_FillingStyle const Type)
        Init(GeomFill_BSplineCurves self, Handle_Geom_BSplineCurve C1, Handle_Geom_BSplineCurve C2, Handle_Geom_BSplineCurve C3, GeomFill_FillingStyle const Type)
        Init(GeomFill_BSplineCurves self, Handle_Geom_BSplineCurve C1, Handle_Geom_BSplineCurve C2, GeomFill_FillingStyle const Type)

        Initializes or reinitializes this algorithm with two, three,
        or four curves - C1, C2, C3, and C4 - and Type, one
        of the following filling styles:
        -   GeomFill_Stretch - the style with the flattest patch
        -   GeomFill_Coons - a rounded style of patch with
        less depth than that of Curved
        -   GeomFill_Curved - the style with the most rounded patch.
        Exceptions
        Standard_ConstructionError if the curves are not contiguous.

        :type C1: OCC.wrapper.Geom.Handle_Geom_BSplineCurve
        :type C2: OCC.wrapper.Geom.Handle_Geom_BSplineCurve
        :type Type: OCC.wrapper.GeomFill.GeomFill_FillingStyle

        """
        return _GeomFill.GeomFill_BSplineCurves_Init(self, *args)


    def Surface(self, *args):
        """
        Returns the BSpline surface Surface resulting from
        the computation performed by this algorithm.

        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

        """
        res = _GeomFill.GeomFill_BSplineCurves_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_BSplineCurves
GeomFill_BSplineCurves_swigregister = _GeomFill.GeomFill_BSplineCurves_swigregister
GeomFill_BSplineCurves_swigregister(GeomFill_BSplineCurves)

class Handle_GeomFill_HArray1OfLocationLaw(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_HArray1OfLocationLaw self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_HArray1OfLocationLaw_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_HArray1OfLocationLaw self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_HArray1OfLocationLaw_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_HArray1OfLocationLaw self, GeomFill_HArray1OfLocationLaw thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_HArray1OfLocationLaw_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_HArray1OfLocationLaw self, Handle_GeomFill_HArray1OfLocationLaw theHandle) -> Handle_GeomFill_HArray1OfLocationLaw
        assign(Handle_GeomFill_HArray1OfLocationLaw self, GeomFill_HArray1OfLocationLaw thePtr) -> Handle_GeomFill_HArray1OfLocationLaw
        assign(Handle_GeomFill_HArray1OfLocationLaw self, Handle_GeomFill_HArray1OfLocationLaw theHandle) -> Handle_GeomFill_HArray1OfLocationLaw

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_HArray1OfLocationLaw_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_HArray1OfLocationLaw self) -> GeomFill_HArray1OfLocationLaw

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_HArray1OfLocationLaw_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_HArray1OfLocationLaw self) -> GeomFill_HArray1OfLocationLaw

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_HArray1OfLocationLaw___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_HArray1OfLocationLaw self) -> GeomFill_HArray1OfLocationLaw

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_HArray1OfLocationLaw___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_HArray1OfLocationLaw___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_HArray1OfLocationLaw___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_HArray1OfLocationLaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_HArray1OfLocationLaw_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_HArray1OfLocationLaw

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.GeomFill.GeomFill_Array1OfLocationLaw

        """
        res = _GeomFill.Handle_GeomFill_HArray1OfLocationLaw_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_GeomFill_HArray1OfLocationLaw self) -> NCollection_Array1_Handle_GeomFill_LocationLaw

        :rtype: OCC.wrapper.GeomFill.GeomFill_Array1OfLocationLaw

        """
        return _GeomFill.Handle_GeomFill_HArray1OfLocationLaw_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_HArray1OfLocationLaw self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_HArray1OfLocationLaw_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_HArray1OfLocationLaw_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_HArray1OfLocationLaw_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_HArray1OfLocationLaw self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_HArray1OfLocationLaw_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_HArray1OfLocationLaw self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_HArray1OfLocationLaw self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_HArray1OfLocationLaw_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_HArray1OfLocationLaw self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_HArray1OfLocationLaw self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_HArray1OfLocationLaw_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_HArray1OfLocationLaw self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_HArray1OfLocationLaw_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_HArray1OfLocationLaw self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_HArray1OfLocationLaw_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_HArray1OfLocationLaw self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_HArray1OfLocationLaw_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_HArray1OfLocationLaw self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_HArray1OfLocationLaw_DecrementRefCounter(self, *args)

Handle_GeomFill_HArray1OfLocationLaw_swigregister = _GeomFill.Handle_GeomFill_HArray1OfLocationLaw_swigregister
Handle_GeomFill_HArray1OfLocationLaw_swigregister(Handle_GeomFill_HArray1OfLocationLaw)

def Handle_GeomFill_HArray1OfLocationLaw_DownCast(thing):
    return _GeomFill.Handle_GeomFill_HArray1OfLocationLaw_DownCast(thing)
Handle_GeomFill_HArray1OfLocationLaw_DownCast = _GeomFill.Handle_GeomFill_HArray1OfLocationLaw_DownCast

class Handle_GeomFill_TgtField(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_TgtField self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_TgtField_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_TgtField self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_TgtField_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_TgtField self, GeomFill_TgtField thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_TgtField_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_TgtField self, Handle_GeomFill_TgtField theHandle) -> Handle_GeomFill_TgtField
        assign(Handle_GeomFill_TgtField self, GeomFill_TgtField thePtr) -> Handle_GeomFill_TgtField
        assign(Handle_GeomFill_TgtField self, Handle_GeomFill_TgtField theHandle) -> Handle_GeomFill_TgtField

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_TgtField_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_TgtField self) -> GeomFill_TgtField

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_TgtField_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_TgtField self) -> GeomFill_TgtField

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_TgtField___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_TgtField self) -> GeomFill_TgtField

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_TgtField___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_TgtField___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_TgtField___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_TgtField(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_TgtField_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_TgtField

    def IsScalable(self, *args):
        """
        IsScalable(Handle_GeomFill_TgtField self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_TgtField_IsScalable(self, *args)


    def Scale(self, *args):
        """
        Scale(Handle_GeomFill_TgtField self, Handle_Law_BSpline Func)

        :type Func: OCC.wrapper.Law.Handle_Law_BSpline

        """
        return _GeomFill.Handle_GeomFill_TgtField_Scale(self, *args)


    def Value(self, *args):
        """
        Value(Handle_GeomFill_TgtField self, Standard_Real const W) -> gp_Vec

        Computes  the value  of the    field of tangency    at
        parameter W.

        :type W: float
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_TgtField_Value(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_TgtField self, Standard_Real const W) -> gp_Vec
        D1(Handle_GeomFill_TgtField self, Standard_Real const W, gp_Vec V, gp_Vec DV)

        Computes the value and the  derivative of the field of
        tangency at parameter W.

        :type W: float
        :type V: OCC.wrapper.gp.gp_Vec
        :type DV: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_TgtField_D1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_TgtField self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_TgtField_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_TgtField_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_TgtField_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_TgtField self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_TgtField_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_TgtField self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_TgtField self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_TgtField_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_TgtField self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_TgtField self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_TgtField_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_TgtField self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_TgtField_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_TgtField self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_TgtField_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_TgtField self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_TgtField_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_TgtField self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_TgtField_DecrementRefCounter(self, *args)

Handle_GeomFill_TgtField_swigregister = _GeomFill.Handle_GeomFill_TgtField_swigregister
Handle_GeomFill_TgtField_swigregister(Handle_GeomFill_TgtField)

def Handle_GeomFill_TgtField_DownCast(thing):
    return _GeomFill.Handle_GeomFill_TgtField_DownCast(thing)
Handle_GeomFill_TgtField_DownCast = _GeomFill.Handle_GeomFill_TgtField_DownCast

class GeomFill_SimpleBound(GeomFill_Boundary):
    """
    Defines a 3d curve as a boundary for a
    GeomFill_ConstrainedFilling algorithm.
    This curve is unattached to an existing surface.D
    Contains fields to allow a reparametrization of curve.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GeomFill_SimpleBound
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GeomFill_SimpleBound(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GeomFill_SimpleBound self, Handle_Adaptor3d_HCurve Curve, Standard_Real const Tol3d, Standard_Real const Tolang) -> GeomFill_SimpleBound

        Constructs the boundary object defined by the 3d curve.
        The surface to be built along this boundary will be in the
        tolerance range defined by Tol3d.
        This object is to be used as a boundary for a
        GeomFill_ConstrainedFilling framework.
        Dummy is initialized but has no function in this class.
        Warning
        Curve is an adapted curve, that is, an object which is an interface between:
        -   the services provided by a 3D curve from the package Geom
        -   and those required of the curve by the computation
        algorithm which uses it.
        The adapted curve is created in one of the following ways:
        -   First sequence:
        Handle(Geom_Curve) myCurve = ... ;
        Handle(GeomAdaptor_HCurve)
        Curve = new
        GeomAdaptor_HCurve(myCurve);
        -   Second sequence:
        // Step 1
        Handle(Geom_Curve) myCurve = ... ;
        GeomAdaptor_Curve Crv (myCurve);
        // Step 2
        Handle(GeomAdaptor_HCurve)
        Curve = new
        GeomAdaptor_HCurve(Crv);
        You use the second part of this sequence if you already
        have the adapted curve Crv.
        The boundary is then constructed with the Curve object:
        Standard_Real Tol = ... ;
        Standard_Real dummy = 0. ;
        myBoundary = GeomFill_SimpleBound
        (Curve,Tol,dummy);

        :type Curve: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type Tol3d: float
        :type Tolang: float

        """
        this = _GeomFill.new_GeomFill_SimpleBound(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Value(self, *args):
        """
        Value(GeomFill_SimpleBound self, Standard_Real const U) -> gp_Pnt

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.GeomFill_SimpleBound_Value(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_SimpleBound self, Standard_Real const U, gp_Pnt P, gp_Vec V)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_SimpleBound_D1(self, *args)


    def Reparametrize(self, *args):
        """
        Reparametrize(GeomFill_SimpleBound self, Standard_Real const First, Standard_Real const Last, Standard_Boolean const HasDF, Standard_Boolean const HasDL, Standard_Real const DF, Standard_Real const DL, Standard_Boolean const Rev)

        :type First: float
        :type Last: float
        :type HasDF: bool
        :type HasDL: bool
        :type DF: float
        :type DL: float
        :type Rev: bool

        """
        return _GeomFill.GeomFill_SimpleBound_Reparametrize(self, *args)


    def Bounds(self, *args):
        """
        Bounds(GeomFill_SimpleBound self)

        :type First: float
        :type Last: float

        """
        return _GeomFill.GeomFill_SimpleBound_Bounds(self, *args)


    def IsDegenerated(self, *args):
        """
        IsDegenerated(GeomFill_SimpleBound self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_SimpleBound_IsDegenerated(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GeomFill.GeomFill_SimpleBound_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GeomFill.GeomFill_SimpleBound_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.GeomFill_SimpleBound_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomFill.delete_GeomFill_SimpleBound
GeomFill_SimpleBound_swigregister = _GeomFill.GeomFill_SimpleBound_swigregister
GeomFill_SimpleBound_swigregister(GeomFill_SimpleBound)

def GeomFill_SimpleBound_get_type_name(*args):
    """
    GeomFill_SimpleBound_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GeomFill.GeomFill_SimpleBound_get_type_name(*args)

def GeomFill_SimpleBound_get_type_descriptor(*args):
    """
    GeomFill_SimpleBound_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GeomFill.GeomFill_SimpleBound_get_type_descriptor(*args)

class Handle_GeomFill_TrihedronWithGuide(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_TrihedronWithGuide self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_TrihedronWithGuide self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_TrihedronWithGuide self, GeomFill_TrihedronWithGuide thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_TrihedronWithGuide self, Handle_GeomFill_TrihedronWithGuide theHandle) -> Handle_GeomFill_TrihedronWithGuide
        assign(Handle_GeomFill_TrihedronWithGuide self, GeomFill_TrihedronWithGuide thePtr) -> Handle_GeomFill_TrihedronWithGuide
        assign(Handle_GeomFill_TrihedronWithGuide self, Handle_GeomFill_TrihedronWithGuide theHandle) -> Handle_GeomFill_TrihedronWithGuide

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_TrihedronWithGuide self) -> GeomFill_TrihedronWithGuide

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_TrihedronWithGuide self) -> GeomFill_TrihedronWithGuide

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_TrihedronWithGuide self) -> GeomFill_TrihedronWithGuide

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_TrihedronWithGuide___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_TrihedronWithGuide(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_TrihedronWithGuide_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_TrihedronWithGuide

    def Guide(self, *args):
        """
        Guide(Handle_GeomFill_TrihedronWithGuide self) -> Handle_Adaptor3d_HCurve

        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_Guide(self, *args)


    def Origine(self, *args):
        """
        Origine(Handle_GeomFill_TrihedronWithGuide self, Standard_Real const Param1, Standard_Real const Param2)

        :type Param1: float
        :type Param2: float

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_Origine(self, *args)


    def CurrentPointOnGuide(self, *args):
        """
        CurrentPointOnGuide(Handle_GeomFill_TrihedronWithGuide self) -> gp_Pnt

        Returns the current point on guide
        found by D0, D1 or D2.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_CurrentPointOnGuide(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_TrihedronWithGuide self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_TrihedronWithGuide_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_TrihedronWithGuide_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetCurve(self, *args):
        """
        SetCurve(Handle_GeomFill_TrihedronWithGuide self, Handle_Adaptor3d_HCurve C)

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_SetCurve(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_GeomFill_TrihedronWithGuide self) -> Handle_GeomFill_TrihedronLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_TrihedronLaw

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_Copy(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_GeomFill_TrihedronWithGuide self) -> GeomFill_PipeError

        Give a status to the Law
        Returns PipeOk (default implementation)

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_ErrorStatus(self, *args)


    def D0(self, *args):
        """
        D0(Handle_GeomFill_TrihedronWithGuide self, Standard_Real const Param, gp_Vec Tangent, gp_Vec Normal, gp_Vec BiNormal) -> Standard_Boolean

        compute Triedrhon on curve at parameter <Param>

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_TrihedronWithGuide self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec BiNormal, gp_Vec DBiNormal) -> Standard_Boolean

        compute Triedrhon and  derivative Trihedron  on curve
        at parameter <Param>
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_GeomFill_TrihedronWithGuide self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec D2Tangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec D2Normal, gp_Vec BiNormal, gp_Vec DBiNormal, gp_Vec D2BiNormal) -> Standard_Boolean

        compute  Trihedron on curve
        first and seconde  derivatives.
        Warning : It used only for C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type D2Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type D2Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :type D2BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_D2(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_GeomFill_TrihedronWithGuide self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_GeomFill_TrihedronWithGuide self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Handle_GeomFill_TrihedronWithGuide self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_SetInterval(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(Handle_GeomFill_TrihedronWithGuide self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_GetInterval(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(Handle_GeomFill_TrihedronWithGuide self, gp_Vec ATangent, gp_Vec ANormal, gp_Vec ABiNormal)

        Get average value of M(t) and V(t) it is usfull to
        make fast approximation of rational  surfaces.

        :type ATangent: OCC.wrapper.gp.gp_Vec
        :type ANormal: OCC.wrapper.gp.gp_Vec
        :type ABiNormal: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_GetAverageLaw(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(Handle_GeomFill_TrihedronWithGuide self) -> Standard_Boolean

        Say if the law is Constant

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_IsConstant(self, *args)


    def IsOnlyBy3dCurve(self, *args):
        """
        IsOnlyBy3dCurve(Handle_GeomFill_TrihedronWithGuide self) -> Standard_Boolean

        Say if the law is defined, only by the 3d Geometry of
        the setted Curve
        Return False by Default.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_IsOnlyBy3dCurve(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_TrihedronWithGuide self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_TrihedronWithGuide self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_TrihedronWithGuide self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_TrihedronWithGuide self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_TrihedronWithGuide self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_TrihedronWithGuide self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_TrihedronWithGuide self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_TrihedronWithGuide self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_TrihedronWithGuide self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_TrihedronWithGuide_DecrementRefCounter(self, *args)

Handle_GeomFill_TrihedronWithGuide_swigregister = _GeomFill.Handle_GeomFill_TrihedronWithGuide_swigregister
Handle_GeomFill_TrihedronWithGuide_swigregister(Handle_GeomFill_TrihedronWithGuide)

def Handle_GeomFill_TrihedronWithGuide_DownCast(thing):
    return _GeomFill.Handle_GeomFill_TrihedronWithGuide_DownCast(thing)
Handle_GeomFill_TrihedronWithGuide_DownCast = _GeomFill.Handle_GeomFill_TrihedronWithGuide_DownCast

class Handle_GeomFill_Frenet(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_Frenet self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_Frenet_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_Frenet self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_Frenet_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_Frenet self, GeomFill_Frenet thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_Frenet_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_Frenet self, Handle_GeomFill_Frenet theHandle) -> Handle_GeomFill_Frenet
        assign(Handle_GeomFill_Frenet self, GeomFill_Frenet thePtr) -> Handle_GeomFill_Frenet
        assign(Handle_GeomFill_Frenet self, Handle_GeomFill_Frenet theHandle) -> Handle_GeomFill_Frenet

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_Frenet_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_Frenet self) -> GeomFill_Frenet

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_Frenet_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_Frenet self) -> GeomFill_Frenet

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_Frenet___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_Frenet self) -> GeomFill_Frenet

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_Frenet___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_Frenet___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_Frenet___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_Frenet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_Frenet_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_Frenet

    def Copy(self, *args):
        """
        Copy(Handle_GeomFill_Frenet self) -> Handle_GeomFill_TrihedronLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_TrihedronLaw

        """
        return _GeomFill.Handle_GeomFill_Frenet_Copy(self, *args)


    def Init(self, *args):
        """Init(Handle_GeomFill_Frenet self)"""
        return _GeomFill.Handle_GeomFill_Frenet_Init(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(Handle_GeomFill_Frenet self, Handle_Adaptor3d_HCurve C)

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.Handle_GeomFill_Frenet_SetCurve(self, *args)


    def D0(self, *args):
        """
        D0(Handle_GeomFill_Frenet self, Standard_Real const Param, gp_Vec Tangent, gp_Vec Normal, gp_Vec BiNormal) -> Standard_Boolean

        compute Triedrhon on curve at parameter <Param>

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Frenet_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_Frenet self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec BiNormal, gp_Vec DBiNormal) -> Standard_Boolean

        compute Triedrhon and  derivative Trihedron  on curve
        at parameter <Param>
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Frenet_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_GeomFill_Frenet self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec D2Tangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec D2Normal, gp_Vec BiNormal, gp_Vec DBiNormal, gp_Vec D2BiNormal) -> Standard_Boolean

        compute  Trihedron on curve
        first and seconde  derivatives.
        Warning : It used only for C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type D2Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type D2Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :type D2BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Frenet_D2(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_GeomFill_Frenet self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_Frenet_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_GeomFill_Frenet self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.Handle_GeomFill_Frenet_Intervals(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(Handle_GeomFill_Frenet self, gp_Vec ATangent, gp_Vec ANormal, gp_Vec ABiNormal)

        Get average value of Tangent(t) and Normal(t) it is usfull to
        make fast approximation of rational  surfaces.

        :type ATangent: OCC.wrapper.gp.gp_Vec
        :type ANormal: OCC.wrapper.gp.gp_Vec
        :type ABiNormal: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_Frenet_GetAverageLaw(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(Handle_GeomFill_Frenet self) -> Standard_Boolean

        Say if the law is Constant.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Frenet_IsConstant(self, *args)


    def IsOnlyBy3dCurve(self, *args):
        """
        IsOnlyBy3dCurve(Handle_GeomFill_Frenet self) -> Standard_Boolean

        Return True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Frenet_IsOnlyBy3dCurve(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_Frenet self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_Frenet_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_Frenet_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_Frenet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_GeomFill_Frenet self) -> GeomFill_PipeError

        Give a status to the Law
        Returns PipeOk (default implementation)

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _GeomFill.Handle_GeomFill_Frenet_ErrorStatus(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Handle_GeomFill_Frenet self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_Frenet_SetInterval(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(Handle_GeomFill_Frenet self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_Frenet_GetInterval(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_Frenet self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_Frenet_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_Frenet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_Frenet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Frenet_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_Frenet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_Frenet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Frenet_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_Frenet self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_Frenet_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_Frenet self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_Frenet_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_Frenet self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_Frenet_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_Frenet self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_Frenet_DecrementRefCounter(self, *args)

Handle_GeomFill_Frenet_swigregister = _GeomFill.Handle_GeomFill_Frenet_swigregister
Handle_GeomFill_Frenet_swigregister(Handle_GeomFill_Frenet)

def Handle_GeomFill_Frenet_DownCast(thing):
    return _GeomFill.Handle_GeomFill_Frenet_DownCast(thing)
Handle_GeomFill_Frenet_DownCast = _GeomFill.Handle_GeomFill_Frenet_DownCast

class Handle_GeomFill_Darboux(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_Darboux self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_Darboux_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_Darboux self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_Darboux_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_Darboux self, GeomFill_Darboux thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_Darboux_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_Darboux self, Handle_GeomFill_Darboux theHandle) -> Handle_GeomFill_Darboux
        assign(Handle_GeomFill_Darboux self, GeomFill_Darboux thePtr) -> Handle_GeomFill_Darboux
        assign(Handle_GeomFill_Darboux self, Handle_GeomFill_Darboux theHandle) -> Handle_GeomFill_Darboux

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_Darboux_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_Darboux self) -> GeomFill_Darboux

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_Darboux_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_Darboux self) -> GeomFill_Darboux

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_Darboux___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_Darboux self) -> GeomFill_Darboux

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_Darboux___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_Darboux___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_Darboux___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_Darboux(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_Darboux_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_Darboux

    def Copy(self, *args):
        """
        Copy(Handle_GeomFill_Darboux self) -> Handle_GeomFill_TrihedronLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_TrihedronLaw

        """
        return _GeomFill.Handle_GeomFill_Darboux_Copy(self, *args)


    def D0(self, *args):
        """
        D0(Handle_GeomFill_Darboux self, Standard_Real const Param, gp_Vec Tangent, gp_Vec Normal, gp_Vec BiNormal) -> Standard_Boolean

        compute Triedrhon on curve at parameter <Param>

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Darboux_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_Darboux self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec BiNormal, gp_Vec DBiNormal) -> Standard_Boolean

        compute Triedrhon and  derivative Trihedron  on curve
        at parameter <Param>
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Darboux_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_GeomFill_Darboux self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec D2Tangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec D2Normal, gp_Vec BiNormal, gp_Vec DBiNormal, gp_Vec D2BiNormal) -> Standard_Boolean

        compute  Trihedron on curve
        first and seconde  derivatives.
        Warning : It used only for C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type D2Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type D2Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :type D2BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Darboux_D2(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_GeomFill_Darboux self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_Darboux_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_GeomFill_Darboux self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.Handle_GeomFill_Darboux_Intervals(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(Handle_GeomFill_Darboux self, gp_Vec ATangent, gp_Vec ANormal, gp_Vec ABiNormal)

        Get average value of Tangent(t) and Normal(t) it is usfull to
        make fast approximation of rational  surfaces.

        :type ATangent: OCC.wrapper.gp.gp_Vec
        :type ANormal: OCC.wrapper.gp.gp_Vec
        :type ABiNormal: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_Darboux_GetAverageLaw(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(Handle_GeomFill_Darboux self) -> Standard_Boolean

        Say if the law is Constant.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Darboux_IsConstant(self, *args)


    def IsOnlyBy3dCurve(self, *args):
        """
        IsOnlyBy3dCurve(Handle_GeomFill_Darboux self) -> Standard_Boolean

        Return False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Darboux_IsOnlyBy3dCurve(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_Darboux self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_Darboux_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_Darboux_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_Darboux_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetCurve(self, *args):
        """
        SetCurve(Handle_GeomFill_Darboux self, Handle_Adaptor3d_HCurve C)

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.Handle_GeomFill_Darboux_SetCurve(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_GeomFill_Darboux self) -> GeomFill_PipeError

        Give a status to the Law
        Returns PipeOk (default implementation)

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _GeomFill.Handle_GeomFill_Darboux_ErrorStatus(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Handle_GeomFill_Darboux self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_Darboux_SetInterval(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(Handle_GeomFill_Darboux self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_Darboux_GetInterval(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_Darboux self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_Darboux_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_Darboux self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_Darboux self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Darboux_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_Darboux self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_Darboux self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Darboux_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_Darboux self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_Darboux_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_Darboux self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_Darboux_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_Darboux self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_Darboux_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_Darboux self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_Darboux_DecrementRefCounter(self, *args)

Handle_GeomFill_Darboux_swigregister = _GeomFill.Handle_GeomFill_Darboux_swigregister
Handle_GeomFill_Darboux_swigregister(Handle_GeomFill_Darboux)

def Handle_GeomFill_Darboux_DownCast(thing):
    return _GeomFill.Handle_GeomFill_Darboux_DownCast(thing)
Handle_GeomFill_Darboux_DownCast = _GeomFill.Handle_GeomFill_Darboux_DownCast

class Handle_GeomFill_EvolvedSection(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_EvolvedSection self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_EvolvedSection self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_EvolvedSection self, GeomFill_EvolvedSection thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_EvolvedSection self, Handle_GeomFill_EvolvedSection theHandle) -> Handle_GeomFill_EvolvedSection
        assign(Handle_GeomFill_EvolvedSection self, GeomFill_EvolvedSection thePtr) -> Handle_GeomFill_EvolvedSection
        assign(Handle_GeomFill_EvolvedSection self, Handle_GeomFill_EvolvedSection theHandle) -> Handle_GeomFill_EvolvedSection

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_EvolvedSection self) -> GeomFill_EvolvedSection

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_EvolvedSection self) -> GeomFill_EvolvedSection

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_EvolvedSection self) -> GeomFill_EvolvedSection

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_EvolvedSection___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_EvolvedSection___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_EvolvedSection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_EvolvedSection_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_EvolvedSection

    def D0(self, *args):
        """
        D0(Handle_GeomFill_EvolvedSection self, Standard_Real const Param, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_Standard_Real Weigths) -> Standard_Boolean

        compute the section for v = param

        :type Param: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_EvolvedSection self, Standard_Real const Param, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean

        compute the first  derivative in v direction  of the
        section for v =  param
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_GeomFill_EvolvedSection self, Standard_Real const Param, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        compute the second derivative  in v direction of the
        section  for v = param
        Warning : It used only for C2 aproximation

        :type Param: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_D2(self, *args)


    def BSplineSurface(self, *args):
        """
        BSplineSurface(Handle_GeomFill_EvolvedSection self) -> Handle_Geom_BSplineSurface

        give if possible an bspline Surface, like iso-v are the
        section.  If it is  not possible  this methode have  to
        get an Null Surface.  Is it the default implementation.

        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_BSplineSurface(self, *args)


    def SectionShape(self, *args):
        """
        SectionShape(Handle_GeomFill_EvolvedSection self)

        get the format of an  section

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_SectionShape(self, *args)


    def Knots(self, *args):
        """
        Knots(Handle_GeomFill_EvolvedSection self, NCollection_Array1_Standard_Real TKnots)

        get the Knots of the section

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(Handle_GeomFill_EvolvedSection self, NCollection_Array1_Standard_Integer TMults)

        get the Multplicities of the section

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_Mults(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Handle_GeomFill_EvolvedSection self) -> Standard_Boolean

        Returns if the sections are rationnal or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_IsRational(self, *args)


    def IsUPeriodic(self, *args):
        """
        IsUPeriodic(Handle_GeomFill_EvolvedSection self) -> Standard_Boolean

        Returns if the sections are periodic or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_IsUPeriodic(self, *args)


    def IsVPeriodic(self, *args):
        """
        IsVPeriodic(Handle_GeomFill_EvolvedSection self) -> Standard_Boolean

        Returns if the law  isperiodic or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_IsVPeriodic(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_GeomFill_EvolvedSection self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_GeomFill_EvolvedSection self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Handle_GeomFill_EvolvedSection self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_SetInterval(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(Handle_GeomFill_EvolvedSection self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_GetInterval(self, *args)


    def GetDomain(self, *args):
        """
        GetDomain(Handle_GeomFill_EvolvedSection self)

        Gets the bounds of the function parametric domain.
        Warning: This domain it is  not modified by the
        SetValue method

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_GetDomain(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(Handle_GeomFill_EvolvedSection self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, NCollection_Array1_Standard_Real Tol3d)

        Returns the tolerances associated at each poles to
        reach  in approximation, to satisfy: BoundTol error
        at the   Boundary  AngleTol tangent error  at  the
        Boundary  (in radian)  SurfTol   error inside the
        surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_GetTolerance(self, *args)


    def BarycentreOfSurf(self, *args):
        """
        BarycentreOfSurf(Handle_GeomFill_EvolvedSection self) -> gp_Pnt

        Get the barycentre of Surface.
        An   very  poor estimation is sufficent.
        This information is usefull to perform well
        conditioned rational approximation.
        Warning: Used only if <me> IsRational

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_BarycentreOfSurf(self, *args)


    def MaximalSection(self, *args):
        """
        MaximalSection(Handle_GeomFill_EvolvedSection self) -> Standard_Real

        Returns the   length of the greater section. This
        information is usefull to G1's control.
        Warning: With an little value, approximation can be slower.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_MaximalSection(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(Handle_GeomFill_EvolvedSection self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        in all  sections.
        This information is  usefull to control error
        in rational approximation.
        Warning: Used only if <me> IsRational

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_GetMinimalWeight(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(Handle_GeomFill_EvolvedSection self) -> Standard_Boolean

        return True If the Law isConstant

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_IsConstant(self, *args)


    def ConstantSection(self, *args):
        """
        ConstantSection(Handle_GeomFill_EvolvedSection self) -> Handle_Geom_Curve

        Return the constant Section if <me>  IsConstant.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_ConstantSection(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_EvolvedSection self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_EvolvedSection_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_EvolvedSection_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_GeomFill_EvolvedSection self, Standard_Real const Tol3d, Standard_Real const Tol2d)

        Is  usefull, if (me)  have to run  numerical
        algorithm  to perform D0,  D1 or D2
        The default implementation make nothing.

        :type Tol3d: float
        :type Tol2d: float

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_SetTolerance(self, *args)


    def IsConicalLaw(self, *args):
        """
        IsConicalLaw(Handle_GeomFill_EvolvedSection self) -> Standard_Boolean

        Returns True if all section  are circle, with same
        plane,same center and  linear  radius  evolution
        Return False by Default.

        :type Error: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_IsConicalLaw(self, *args)


    def CirclSection(self, *args):
        """
        CirclSection(Handle_GeomFill_EvolvedSection self, Standard_Real const Param) -> Handle_Geom_Curve

        Return the circle section  at parameter <Param>, if
        <me> a  IsConicalLaw

        :type Param: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_CirclSection(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_EvolvedSection self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_EvolvedSection self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_EvolvedSection self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_EvolvedSection self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_EvolvedSection self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_EvolvedSection self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_EvolvedSection self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_EvolvedSection self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_EvolvedSection self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_EvolvedSection_DecrementRefCounter(self, *args)

Handle_GeomFill_EvolvedSection_swigregister = _GeomFill.Handle_GeomFill_EvolvedSection_swigregister
Handle_GeomFill_EvolvedSection_swigregister(Handle_GeomFill_EvolvedSection)

def Handle_GeomFill_EvolvedSection_DownCast(thing):
    return _GeomFill.Handle_GeomFill_EvolvedSection_DownCast(thing)
Handle_GeomFill_EvolvedSection_DownCast = _GeomFill.Handle_GeomFill_EvolvedSection_DownCast

class Handle_GeomFill_CoonsAlgPatch(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_CoonsAlgPatch self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_CoonsAlgPatch_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_CoonsAlgPatch self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_CoonsAlgPatch_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_CoonsAlgPatch self, GeomFill_CoonsAlgPatch thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_CoonsAlgPatch_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_CoonsAlgPatch self, Handle_GeomFill_CoonsAlgPatch theHandle) -> Handle_GeomFill_CoonsAlgPatch
        assign(Handle_GeomFill_CoonsAlgPatch self, GeomFill_CoonsAlgPatch thePtr) -> Handle_GeomFill_CoonsAlgPatch
        assign(Handle_GeomFill_CoonsAlgPatch self, Handle_GeomFill_CoonsAlgPatch theHandle) -> Handle_GeomFill_CoonsAlgPatch

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_CoonsAlgPatch_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_CoonsAlgPatch self) -> GeomFill_CoonsAlgPatch

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_CoonsAlgPatch_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_CoonsAlgPatch self) -> GeomFill_CoonsAlgPatch

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_CoonsAlgPatch___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_CoonsAlgPatch self) -> GeomFill_CoonsAlgPatch

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_CoonsAlgPatch___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_CoonsAlgPatch___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_CoonsAlgPatch___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_CoonsAlgPatch(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_CoonsAlgPatch_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_CoonsAlgPatch

    def Func(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.Law.Handle_Law_Function

        """
        res = _GeomFill.Handle_GeomFill_CoonsAlgPatch_Func(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFunc(self, *args):
        """
        SetFunc(Handle_GeomFill_CoonsAlgPatch self, Handle_Law_Function f1, Handle_Law_Function f2)

        Set the blending functions.

        :type f1: OCC.wrapper.Law.Handle_Law_Function
        :type f2: OCC.wrapper.Law.Handle_Law_Function

        """
        return _GeomFill.Handle_GeomFill_CoonsAlgPatch_SetFunc(self, *args)


    def Value(self, *args):
        """
        Value(Handle_GeomFill_CoonsAlgPatch self, Standard_Real const U, Standard_Real const V) -> gp_Pnt

        Computes  the  value   on the  algorithmic    patch at
        parameters U and V.

        :type U: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.Handle_GeomFill_CoonsAlgPatch_Value(self, *args)


    def D1U(self, *args):
        """
        D1U(Handle_GeomFill_CoonsAlgPatch self, Standard_Real const U, Standard_Real const V) -> gp_Vec

        Computes   the  d/dU   partial   derivative  on    the
        algorithmic patch at parameters U and V.

        :type U: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_CoonsAlgPatch_D1U(self, *args)


    def D1V(self, *args):
        """
        D1V(Handle_GeomFill_CoonsAlgPatch self, Standard_Real const U, Standard_Real const V) -> gp_Vec

        Computes    the  d/dV    partial    derivative on  the
        algorithmic patch at parameters U and V.

        :type U: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_CoonsAlgPatch_D1V(self, *args)


    def DUV(self, *args):
        """
        DUV(Handle_GeomFill_CoonsAlgPatch self, Standard_Real const U, Standard_Real const V) -> gp_Vec

        Computes the   d2/dUdV  partial  derivative   on   the
        algorithmic  patch made with linear blending functions
        at parameter U and V.

        :type U: float
        :type V: float
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_CoonsAlgPatch_DUV(self, *args)


    def Corner(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _GeomFill.Handle_GeomFill_CoonsAlgPatch_Corner(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Bound(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_Boundary

        """
        res = _GeomFill.Handle_GeomFill_CoonsAlgPatch_Bound(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_CoonsAlgPatch self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_CoonsAlgPatch_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_CoonsAlgPatch_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_CoonsAlgPatch_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_CoonsAlgPatch self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_CoonsAlgPatch_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_CoonsAlgPatch self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_CoonsAlgPatch self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_CoonsAlgPatch_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_CoonsAlgPatch self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_CoonsAlgPatch self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_CoonsAlgPatch_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_CoonsAlgPatch self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_CoonsAlgPatch_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_CoonsAlgPatch self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_CoonsAlgPatch_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_CoonsAlgPatch self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_CoonsAlgPatch_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_CoonsAlgPatch self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_CoonsAlgPatch_DecrementRefCounter(self, *args)

Handle_GeomFill_CoonsAlgPatch_swigregister = _GeomFill.Handle_GeomFill_CoonsAlgPatch_swigregister
Handle_GeomFill_CoonsAlgPatch_swigregister(Handle_GeomFill_CoonsAlgPatch)

def Handle_GeomFill_CoonsAlgPatch_DownCast(thing):
    return _GeomFill.Handle_GeomFill_CoonsAlgPatch_DownCast(thing)
Handle_GeomFill_CoonsAlgPatch_DownCast = _GeomFill.Handle_GeomFill_CoonsAlgPatch_DownCast

class Handle_GeomFill_BoundWithSurf(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_BoundWithSurf self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_BoundWithSurf_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_BoundWithSurf self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_BoundWithSurf_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_BoundWithSurf self, GeomFill_BoundWithSurf thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_BoundWithSurf_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_BoundWithSurf self, Handle_GeomFill_BoundWithSurf theHandle) -> Handle_GeomFill_BoundWithSurf
        assign(Handle_GeomFill_BoundWithSurf self, GeomFill_BoundWithSurf thePtr) -> Handle_GeomFill_BoundWithSurf
        assign(Handle_GeomFill_BoundWithSurf self, Handle_GeomFill_BoundWithSurf theHandle) -> Handle_GeomFill_BoundWithSurf

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_BoundWithSurf_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_BoundWithSurf self) -> GeomFill_BoundWithSurf

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_BoundWithSurf_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_BoundWithSurf self) -> GeomFill_BoundWithSurf

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_BoundWithSurf___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_BoundWithSurf self) -> GeomFill_BoundWithSurf

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_BoundWithSurf___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_BoundWithSurf___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_BoundWithSurf___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_BoundWithSurf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_BoundWithSurf_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_BoundWithSurf

    def Value(self, *args):
        """
        Value(Handle_GeomFill_BoundWithSurf self, Standard_Real const U) -> gp_Pnt

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.Handle_GeomFill_BoundWithSurf_Value(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_BoundWithSurf self, Standard_Real const U, gp_Pnt P, gp_Vec V)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_BoundWithSurf_D1(self, *args)


    def HasNormals(self, *args):
        """
        HasNormals(Handle_GeomFill_BoundWithSurf self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_BoundWithSurf_HasNormals(self, *args)


    def Norm(self, *args):
        """
        Norm(Handle_GeomFill_BoundWithSurf self, Standard_Real const U) -> gp_Vec

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_BoundWithSurf_Norm(self, *args)


    def D1Norm(self, *args):
        """
        D1Norm(Handle_GeomFill_BoundWithSurf self, Standard_Real const U, gp_Vec N, gp_Vec DN)

        :type U: float
        :type N: OCC.wrapper.gp.gp_Vec
        :type DN: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_BoundWithSurf_D1Norm(self, *args)


    def Reparametrize(self, *args):
        """
        Reparametrize(Handle_GeomFill_BoundWithSurf self, Standard_Real const First, Standard_Real const Last, Standard_Boolean const HasDF, Standard_Boolean const HasDL, Standard_Real const DF, Standard_Real const DL, Standard_Boolean const Rev)

        :type First: float
        :type Last: float
        :type HasDF: bool
        :type HasDL: bool
        :type DF: float
        :type DL: float
        :type Rev: bool

        """
        return _GeomFill.Handle_GeomFill_BoundWithSurf_Reparametrize(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_GeomFill_BoundWithSurf self)

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_BoundWithSurf_Bounds(self, *args)


    def IsDegenerated(self, *args):
        """
        IsDegenerated(Handle_GeomFill_BoundWithSurf self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_BoundWithSurf_IsDegenerated(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_BoundWithSurf self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_BoundWithSurf_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_BoundWithSurf_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_BoundWithSurf_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Points(self, *args):
        """
        Points(Handle_GeomFill_BoundWithSurf self, gp_Pnt PFirst, gp_Pnt PLast)

        :type PFirst: OCC.wrapper.gp.gp_Pnt
        :type PLast: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.Handle_GeomFill_BoundWithSurf_Points(self, *args)


    def Tol3d(self, *args):
        """
        Tol3d(Handle_GeomFill_BoundWithSurf self) -> Standard_Real
        Tol3d(Handle_GeomFill_BoundWithSurf self, Standard_Real const Tol)

        :type Tol: float

        """
        return _GeomFill.Handle_GeomFill_BoundWithSurf_Tol3d(self, *args)


    def Tolang(self, *args):
        """
        Tolang(Handle_GeomFill_BoundWithSurf self) -> Standard_Real
        Tolang(Handle_GeomFill_BoundWithSurf self, Standard_Real const Tol)

        :type Tol: float

        """
        return _GeomFill.Handle_GeomFill_BoundWithSurf_Tolang(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_BoundWithSurf self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_BoundWithSurf_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_BoundWithSurf self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_BoundWithSurf self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_BoundWithSurf_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_BoundWithSurf self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_BoundWithSurf self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_BoundWithSurf_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_BoundWithSurf self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_BoundWithSurf_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_BoundWithSurf self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_BoundWithSurf_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_BoundWithSurf self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_BoundWithSurf_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_BoundWithSurf self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_BoundWithSurf_DecrementRefCounter(self, *args)

Handle_GeomFill_BoundWithSurf_swigregister = _GeomFill.Handle_GeomFill_BoundWithSurf_swigregister
Handle_GeomFill_BoundWithSurf_swigregister(Handle_GeomFill_BoundWithSurf)

def Handle_GeomFill_BoundWithSurf_DownCast(thing):
    return _GeomFill.Handle_GeomFill_BoundWithSurf_DownCast(thing)
Handle_GeomFill_BoundWithSurf_DownCast = _GeomFill.Handle_GeomFill_BoundWithSurf_DownCast

class Handle_GeomFill_GuideTrihedronAC(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_GuideTrihedronAC self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_GuideTrihedronAC self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_GuideTrihedronAC self, GeomFill_GuideTrihedronAC thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_GuideTrihedronAC self, Handle_GeomFill_GuideTrihedronAC theHandle) -> Handle_GeomFill_GuideTrihedronAC
        assign(Handle_GeomFill_GuideTrihedronAC self, GeomFill_GuideTrihedronAC thePtr) -> Handle_GeomFill_GuideTrihedronAC
        assign(Handle_GeomFill_GuideTrihedronAC self, Handle_GeomFill_GuideTrihedronAC theHandle) -> Handle_GeomFill_GuideTrihedronAC

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_GuideTrihedronAC self) -> GeomFill_GuideTrihedronAC

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_GuideTrihedronAC self) -> GeomFill_GuideTrihedronAC

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_GuideTrihedronAC self) -> GeomFill_GuideTrihedronAC

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_GuideTrihedronAC___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_GuideTrihedronAC(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_GuideTrihedronAC_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_GuideTrihedronAC

    def SetCurve(self, *args):
        """
        SetCurve(Handle_GeomFill_GuideTrihedronAC self, Handle_Adaptor3d_HCurve C)

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_SetCurve(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_GeomFill_GuideTrihedronAC self) -> Handle_GeomFill_TrihedronLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_TrihedronLaw

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_Copy(self, *args)


    def Guide(self, *args):
        """
        Guide(Handle_GeomFill_GuideTrihedronAC self) -> Handle_Adaptor3d_HCurve

        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_Guide(self, *args)


    def D0(self, *args):
        """
        D0(Handle_GeomFill_GuideTrihedronAC self, Standard_Real const Param, gp_Vec Tangent, gp_Vec Normal, gp_Vec BiNormal) -> Standard_Boolean

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_GuideTrihedronAC self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec BiNormal, gp_Vec DBiNormal) -> Standard_Boolean

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_GeomFill_GuideTrihedronAC self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec D2Tangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec D2Normal, gp_Vec BiNormal, gp_Vec DBiNormal, gp_Vec D2BiNormal) -> Standard_Boolean

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type D2Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type D2Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :type D2BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_D2(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_GeomFill_GuideTrihedronAC self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_GeomFill_GuideTrihedronAC self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Handle_GeomFill_GuideTrihedronAC self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_SetInterval(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(Handle_GeomFill_GuideTrihedronAC self, gp_Vec ATangent, gp_Vec ANormal, gp_Vec ABiNormal)

        Get average value of M(t) and V(t) it is usfull to
        make fast approximation of rational  surfaces.

        :type ATangent: OCC.wrapper.gp.gp_Vec
        :type ANormal: OCC.wrapper.gp.gp_Vec
        :type ABiNormal: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_GetAverageLaw(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(Handle_GeomFill_GuideTrihedronAC self) -> Standard_Boolean

        Say if the law is Constant

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_IsConstant(self, *args)


    def IsOnlyBy3dCurve(self, *args):
        """
        IsOnlyBy3dCurve(Handle_GeomFill_GuideTrihedronAC self) -> Standard_Boolean

        Say if the law is defined, only by the 3d Geometry of
        the setted Curve
        Return False by Default.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_IsOnlyBy3dCurve(self, *args)


    def Origine(self, *args):
        """
        Origine(Handle_GeomFill_GuideTrihedronAC self, Standard_Real const OrACR1, Standard_Real const OrACR2)

        :type OrACR1: float
        :type OrACR2: float

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_Origine(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_GuideTrihedronAC self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_GuideTrihedronAC_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_GuideTrihedronAC_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CurrentPointOnGuide(self, *args):
        """
        CurrentPointOnGuide(Handle_GeomFill_GuideTrihedronAC self) -> gp_Pnt

        Returns the current point on guide
        found by D0, D1 or D2.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_CurrentPointOnGuide(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_GeomFill_GuideTrihedronAC self) -> GeomFill_PipeError

        Give a status to the Law
        Returns PipeOk (default implementation)

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_ErrorStatus(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(Handle_GeomFill_GuideTrihedronAC self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_GetInterval(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_GuideTrihedronAC self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_GuideTrihedronAC self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_GuideTrihedronAC self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_GuideTrihedronAC self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_GuideTrihedronAC self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_GuideTrihedronAC self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_GuideTrihedronAC self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_GuideTrihedronAC self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_GuideTrihedronAC self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_GuideTrihedronAC_DecrementRefCounter(self, *args)

Handle_GeomFill_GuideTrihedronAC_swigregister = _GeomFill.Handle_GeomFill_GuideTrihedronAC_swigregister
Handle_GeomFill_GuideTrihedronAC_swigregister(Handle_GeomFill_GuideTrihedronAC)

def Handle_GeomFill_GuideTrihedronAC_DownCast(thing):
    return _GeomFill.Handle_GeomFill_GuideTrihedronAC_DownCast(thing)
Handle_GeomFill_GuideTrihedronAC_DownCast = _GeomFill.Handle_GeomFill_GuideTrihedronAC_DownCast

class Handle_GeomFill_TrihedronLaw(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_TrihedronLaw self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_TrihedronLaw self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_TrihedronLaw self, GeomFill_TrihedronLaw thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_TrihedronLaw self, Handle_GeomFill_TrihedronLaw theHandle) -> Handle_GeomFill_TrihedronLaw
        assign(Handle_GeomFill_TrihedronLaw self, GeomFill_TrihedronLaw thePtr) -> Handle_GeomFill_TrihedronLaw
        assign(Handle_GeomFill_TrihedronLaw self, Handle_GeomFill_TrihedronLaw theHandle) -> Handle_GeomFill_TrihedronLaw

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_TrihedronLaw self) -> GeomFill_TrihedronLaw

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_TrihedronLaw self) -> GeomFill_TrihedronLaw

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_TrihedronLaw self) -> GeomFill_TrihedronLaw

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_TrihedronLaw___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_TrihedronLaw___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_TrihedronLaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_TrihedronLaw_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_TrihedronLaw

    def SetCurve(self, *args):
        """
        SetCurve(Handle_GeomFill_TrihedronLaw self, Handle_Adaptor3d_HCurve C)

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw_SetCurve(self, *args)


    def Copy(self, *args):
        """
        Copy(Handle_GeomFill_TrihedronLaw self) -> Handle_GeomFill_TrihedronLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_TrihedronLaw

        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw_Copy(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_GeomFill_TrihedronLaw self) -> GeomFill_PipeError

        Give a status to the Law
        Returns PipeOk (default implementation)

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw_ErrorStatus(self, *args)


    def D0(self, *args):
        """
        D0(Handle_GeomFill_TrihedronLaw self, Standard_Real const Param, gp_Vec Tangent, gp_Vec Normal, gp_Vec BiNormal) -> Standard_Boolean

        compute Triedrhon on curve at parameter <Param>

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_TrihedronLaw self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec BiNormal, gp_Vec DBiNormal) -> Standard_Boolean

        compute Triedrhon and  derivative Trihedron  on curve
        at parameter <Param>
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_GeomFill_TrihedronLaw self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec D2Tangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec D2Normal, gp_Vec BiNormal, gp_Vec DBiNormal, gp_Vec D2BiNormal) -> Standard_Boolean

        compute  Trihedron on curve
        first and seconde  derivatives.
        Warning : It used only for C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type D2Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type D2Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :type D2BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw_D2(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_GeomFill_TrihedronLaw self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_GeomFill_TrihedronLaw self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Handle_GeomFill_TrihedronLaw self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw_SetInterval(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(Handle_GeomFill_TrihedronLaw self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw_GetInterval(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(Handle_GeomFill_TrihedronLaw self, gp_Vec ATangent, gp_Vec ANormal, gp_Vec ABiNormal)

        Get average value of M(t) and V(t) it is usfull to
        make fast approximation of rational  surfaces.

        :type ATangent: OCC.wrapper.gp.gp_Vec
        :type ANormal: OCC.wrapper.gp.gp_Vec
        :type ABiNormal: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw_GetAverageLaw(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(Handle_GeomFill_TrihedronLaw self) -> Standard_Boolean

        Say if the law is Constant

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw_IsConstant(self, *args)


    def IsOnlyBy3dCurve(self, *args):
        """
        IsOnlyBy3dCurve(Handle_GeomFill_TrihedronLaw self) -> Standard_Boolean

        Say if the law is defined, only by the 3d Geometry of
        the setted Curve
        Return False by Default.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw_IsOnlyBy3dCurve(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_TrihedronLaw self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_TrihedronLaw_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_TrihedronLaw_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_TrihedronLaw self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_TrihedronLaw self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_TrihedronLaw self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_TrihedronLaw self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_TrihedronLaw self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_TrihedronLaw self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_TrihedronLaw self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_TrihedronLaw self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_TrihedronLaw self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_TrihedronLaw_DecrementRefCounter(self, *args)

Handle_GeomFill_TrihedronLaw_swigregister = _GeomFill.Handle_GeomFill_TrihedronLaw_swigregister
Handle_GeomFill_TrihedronLaw_swigregister(Handle_GeomFill_TrihedronLaw)

def Handle_GeomFill_TrihedronLaw_DownCast(thing):
    return _GeomFill.Handle_GeomFill_TrihedronLaw_DownCast(thing)
Handle_GeomFill_TrihedronLaw_DownCast = _GeomFill.Handle_GeomFill_TrihedronLaw_DownCast

class GeomFill_Pipe(object):
    """
    Describes functions to construct pipes. A pipe is built by
    sweeping a curve (the section) along another curve (the path).
    The Pipe class provides the following types of construction:
    -   pipes with a circular section of constant radius,
    -   pipes with a constant section,
    -   pipes with a section evolving between two given curves.
    All standard specific cases are detected in order to build,
    where required, a plane, cylinder, cone, sphere, torus,
    surface of linear extrusion or surface of revolution.
    Generally speaking, the result is a BSpline surface (NURBS).
    A Pipe object provides a framework for:
    -   defining the pipe to be built,
    -   implementing the construction algorithm, and
    -   consulting the resulting surface.
    There are several methods to instantiate a Pipe:
    1) give a path and  a radius : the section is
    a circle.  This location  is the first  point
    of the path,  and this direction is the first
    derivate (calculate at  the  first point ) of
    the path.

    2) give a path and a section.
    Differtent options are available
    2.a) Use the classical Frenet trihedron
    - or the CorrectedFrenet trihedron
    (To avoid twisted surface)
    - or a constant trihedron to have all the sections
    in a same plane
    2.b) Define a ConstantBinormal Direction to keep the
    same angle beetween the Direction and the sections
    along the sweep surface.
    2.c) Define the path by a surface and a 2dcurve,
    the surface is used to define the trihedron's normal.
    It is usefull to keep a constant angle beetween
    input surface and the pipe.                           --
    3) give a  path and two sections. The section
    evoluate from First to Last Section.

    3) give a  path and N sections. The section
    evoluate from First to Last Section.

    In general case the result is a NURBS. But we
    can  generate plane,  cylindrical, spherical,
    conical, toroidal surface in some particular case.

    The natural parametrization of the result is:

    U-Direction along the section.
    V-Direction along the path.

    But, in some particular case, the surface must
    be construct otherwise.
    The method "EchangeUV" return false in such cases.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomFill_Pipe self) -> GeomFill_Pipe
        __init__(GeomFill_Pipe self, Handle_Geom_Curve Path, Standard_Real const Radius) -> GeomFill_Pipe
        __init__(GeomFill_Pipe self, Handle_Geom_Curve Path, Handle_Geom_Curve FirstSect, GeomFill_Trihedron const Option=GeomFill_IsCorrectedFrenet) -> GeomFill_Pipe
        __init__(GeomFill_Pipe self, Handle_Geom2d_Curve Path, Handle_Geom_Surface Support, Handle_Geom_Curve FirstSect) -> GeomFill_Pipe
        __init__(GeomFill_Pipe self, Handle_Geom_Curve Path, Handle_Geom_Curve FirstSect, gp_Dir Dir) -> GeomFill_Pipe
        __init__(GeomFill_Pipe self, Handle_Geom_Curve Path, Handle_Geom_Curve FirstSect, Handle_Geom_Curve LastSect) -> GeomFill_Pipe
        __init__(GeomFill_Pipe self, Handle_Geom_Curve Path, NCollection_Sequence_Handle_Geom_Curve NSections) -> GeomFill_Pipe
        __init__(GeomFill_Pipe self, Handle_Geom_Curve Path, Handle_Geom_Curve Curve1, Handle_Geom_Curve Curve2, Standard_Real const Radius) -> GeomFill_Pipe
        __init__(GeomFill_Pipe self, Handle_Adaptor3d_HCurve Path, Handle_Adaptor3d_HCurve Curve1, Handle_Adaptor3d_HCurve Curve2, Standard_Real const Radius) -> GeomFill_Pipe
        __init__(GeomFill_Pipe self, Handle_Geom_Curve Path, Handle_Adaptor3d_HCurve Guide, Handle_Geom_Curve FirstSect, Standard_Boolean const ByACR, Standard_Boolean const rotat) -> GeomFill_Pipe

        Create a pipe with a constant section and  with 1
        guide-line.
        Use the function Perform to build the surface.
        All standard specific cases are detected in order to
        construct, according to the respective geometric
        nature of Path and the sections, a planar, cylindrical,
        conical, spherical or toroidal surface, a surface of
        linear extrusion or a surface of revolution.
        In the general case, the result is a BSpline surface
        (NURBS) built by approximation of a series of sections where:
        -   the number of sections N is chosen automatically
        by the algorithm according to the respective
        geometries of Path and the sections. N is greater than or equal to 2;
        -   N points Pi (with i in the range [ 1,N ]) are
        defined at regular intervals along the curve Path
        from its first point to its end point. At each point Pi,
        a coordinate system Ti is computed with Pi as
        origin, and with the tangential and normal vectors
        to Path defining two of its coordinate axes.
        In the case of a pipe with a constant circular section,
        the first section is a circle of radius Radius centered
        on the origin of Path and whose "Z Axis" is aligned
        along the vector tangential to the origin of Path. In the
        case of a pipe with a constant section, the first section
        is the curve FirstSect. In these two cases, the ith
        section (for values of i greater than 1) is obtained by
        applying to a copy of this first section the geometric
        transformation which transforms coordinate system
        T1 into coordinate system Ti.
        In the case of an evolving section, N-2 intermediate
        curves Si are first computed (if N is greater than 2,
        and with i in the range [ 2,N-1 ]) whose geometry
        evolves regularly from the curve S1=FirstSect to the
        curve SN=LastSect. The first section is FirstSect,
        and the ith section (for values of i greater than 1) is
        obtained by applying to the curve Si the geometric
        transformation which transforms coordinate system
        T1 into coordinate system Ti.

        :type Path: OCC.wrapper.Geom.Handle_Geom_Curve
        :type Guide: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type FirstSect: OCC.wrapper.Geom.Handle_Geom_Curve
        :type ByACR: bool
        :type rotat: bool

        """
        this = _GeomFill.new_GeomFill_Pipe(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(GeomFill_Pipe self, Handle_Geom_Curve Path, Standard_Real const Radius)
        Init(GeomFill_Pipe self, Handle_Geom_Curve Path, Handle_Geom_Curve FirstSect, GeomFill_Trihedron const Option=GeomFill_IsCorrectedFrenet)
        Init(GeomFill_Pipe self, Handle_Geom2d_Curve Path, Handle_Geom_Surface Support, Handle_Geom_Curve FirstSect)
        Init(GeomFill_Pipe self, Handle_Geom_Curve Path, Handle_Geom_Curve FirstSect, gp_Dir Dir)
        Init(GeomFill_Pipe self, Handle_Geom_Curve Path, Handle_Geom_Curve FirstSect, Handle_Geom_Curve LastSect)
        Init(GeomFill_Pipe self, Handle_Geom_Curve Path, NCollection_Sequence_Handle_Geom_Curve NSections)
        Init(GeomFill_Pipe self, Handle_Adaptor3d_HCurve Path, Handle_Adaptor3d_HCurve Curve1, Handle_Adaptor3d_HCurve Curve2, Standard_Real const Radius)
        Init(GeomFill_Pipe self, Handle_Geom_Curve Path, Handle_Adaptor3d_HCurve Guide, Handle_Geom_Curve FirstSect, Standard_Boolean const ByACR, Standard_Boolean const rotat)

        Initializes this pipe algorithm to build the following surface:
        -   a pipe with a constant circular section of radius
        Radius along the path Path, or
        -   a pipe with constant section FirstSect along the path Path, or
        -   a pipe where the section evolves from FirstSect to
        LastSect along the path Path.
        Use the function Perform to build the surface.
        Note: a description of the resulting surface is given under Constructors.

        :type Path: OCC.wrapper.Geom.Handle_Geom_Curve
        :type Guide: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type FirstSect: OCC.wrapper.Geom.Handle_Geom_Curve
        :type ByACR: bool
        :type rotat: bool

        """
        return _GeomFill.GeomFill_Pipe_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(GeomFill_Pipe self, Standard_Boolean const WithParameters, Standard_Boolean const myPolynomial)
        Perform(GeomFill_Pipe self, Standard_Real const Tol, Standard_Boolean const Polynomial, GeomAbs_Shape const Conti=GeomAbs_C1, Standard_Integer const MaxDegree=11, Standard_Integer const NbMaxSegment=30)

        detects the  particular cases.  And compute the surface.
        if  none   particular  case  is  detected we make an approximation
        with respect of the Tolerance <Tol>, the continuty <Conti>, the
        maximum degree <MaxDegree>, the maximum number of span <NbMaxSegment>
        and the spine parametrization.
        If we can't create a surface with the data

        :type Tol: float
        :type Polynomial: bool
        :type Conti: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type MaxDegree: int
        :type NbMaxSegment: int

        """
        return _GeomFill.GeomFill_Pipe_Perform(self, *args)


    def Surface(self, *args):
        """
        Returns the surface built by this algorithm.
        Warning
        Do not use this function before the surface is built (in this
        case the function will return a null handle).

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _GeomFill.GeomFill_Pipe_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ExchangeUV(self, *args):
        """
        ExchangeUV(GeomFill_Pipe self) -> Standard_Boolean

        The u parametric direction of the surface constructed by
        this algorithm usually corresponds to the evolution
        along the path and the v parametric direction
        corresponds to the evolution along the section(s).
        However, this rule is not respected when constructing
        certain specific Geom surfaces (typically cylindrical
        surfaces, surfaces of revolution, etc.) for which the
        parameterization is inversed.
        The ExchangeUV function checks for this, and returns
        true in all these specific cases.
        Warning
        Do not use this function before the surface is built.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_Pipe_ExchangeUV(self, *args)


    def GenerateParticularCase(self, *args):
        """
        GenerateParticularCase(GeomFill_Pipe self, Standard_Boolean const B)
        GenerateParticularCase(GeomFill_Pipe self) -> Standard_Boolean

        Returns the flag.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_Pipe_GenerateParticularCase(self, *args)


    def ErrorOnSurf(self, *args):
        """
        ErrorOnSurf(GeomFill_Pipe self) -> Standard_Real

        Returns the approximation's error.  if the Surface
        is plane, cylinder ... this error can be 0.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_Pipe_ErrorOnSurf(self, *args)


    def IsDone(self, *args):
        """
        IsDone(GeomFill_Pipe self) -> Standard_Boolean

        Returns whether approximation was done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_Pipe_IsDone(self, *args)

    __swig_destroy__ = _GeomFill.delete_GeomFill_Pipe
GeomFill_Pipe_swigregister = _GeomFill.GeomFill_Pipe_swigregister
GeomFill_Pipe_swigregister(GeomFill_Pipe)

class GeomFill_AppSurf(AppBlend.AppBlend_Approx):
    """
    Approximate a  BSplineSurface passing by all the
    curves described in the SectionGenerator
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomFill_AppSurf self) -> GeomFill_AppSurf
        __init__(GeomFill_AppSurf self, Standard_Integer const Degmin, Standard_Integer const Degmax, Standard_Real const Tol3d, Standard_Real const Tol2d, Standard_Integer const NbIt, Standard_Boolean const KnownParameters) -> GeomFill_AppSurf

        :type Degmin: int
        :type Degmax: int
        :type Tol3d: float
        :type Tol2d: float
        :type NbIt: int
        :type KnownParameters: bool

        """
        this = _GeomFill.new_GeomFill_AppSurf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(GeomFill_AppSurf self, Standard_Integer const Degmin, Standard_Integer const Degmax, Standard_Real const Tol3d, Standard_Real const Tol2d, Standard_Integer const NbIt, Standard_Boolean const KnownParameters)

        :type Degmin: int
        :type Degmax: int
        :type Tol3d: float
        :type Tol2d: float
        :type NbIt: int
        :type KnownParameters: bool

        """
        return _GeomFill.GeomFill_AppSurf_Init(self, *args)


    def SetParType(self, *args):
        """
        SetParType(GeomFill_AppSurf self, Approx_ParametrizationType const ParType)

        Define the type of parametrization used in the approximation

        :type ParType: OCC.wrapper.Approx.Approx_ParametrizationType

        """
        return _GeomFill.GeomFill_AppSurf_SetParType(self, *args)


    def SetContinuity(self, *args):
        """
        SetContinuity(GeomFill_AppSurf self, GeomAbs_Shape const C)

        Define the Continuity used in the approximation

        :type C: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.GeomFill_AppSurf_SetContinuity(self, *args)


    def SetCriteriumWeight(self, *args):
        """
        SetCriteriumWeight(GeomFill_AppSurf self, Standard_Real const W1, Standard_Real const W2, Standard_Real const W3)

        define the Weights  associed to the criterium used in
        the  optimization.

        if Wi <= 0

        :type W1: float
        :type W2: float
        :type W3: float

        """
        return _GeomFill.GeomFill_AppSurf_SetCriteriumWeight(self, *args)


    def ParType(self, *args):
        """
        ParType(GeomFill_AppSurf self) -> Approx_ParametrizationType

        returns the type of parametrization used in the approximation

        :rtype: OCC.wrapper.Approx.Approx_ParametrizationType

        """
        return _GeomFill.GeomFill_AppSurf_ParType(self, *args)


    def Continuity(self, *args):
        """
        Continuity(GeomFill_AppSurf self) -> GeomAbs_Shape

        returns the Continuity used in the approximation

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.GeomFill_AppSurf_Continuity(self, *args)


    def CriteriumWeight(self, *args):
        """
        CriteriumWeight(GeomFill_AppSurf self)

        returns the Weights (as percent) associed  to the criterium used in
        the  optimization.

        :type W1: float
        :type W2: float
        :type W3: float

        """
        return _GeomFill.GeomFill_AppSurf_CriteriumWeight(self, *args)


    def PerformSmoothing(self, *args):
        """
        PerformSmoothing(GeomFill_AppSurf self, Handle_GeomFill_Line Lin, GeomFill_SectionGenerator SecGen)

        :type Lin: OCC.wrapper.GeomFill.Handle_GeomFill_Line
        :type SecGen: OCC.wrapper.GeomFill.GeomFill_SectionGenerator

        """
        return _GeomFill.GeomFill_AppSurf_PerformSmoothing(self, *args)


    def Perform(self, *args):
        """
        Perform(GeomFill_AppSurf self, Handle_GeomFill_Line Lin, GeomFill_SectionGenerator SecGen, Standard_Boolean const SpApprox)
        Perform(GeomFill_AppSurf self, Handle_GeomFill_Line Lin, GeomFill_SectionGenerator SecGen, Standard_Integer const NbMaxP)

        :type Lin: OCC.wrapper.GeomFill.Handle_GeomFill_Line
        :type SecGen: OCC.wrapper.GeomFill.GeomFill_SectionGenerator
        :type NbMaxP: int

        """
        return _GeomFill.GeomFill_AppSurf_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(GeomFill_AppSurf self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_AppSurf_IsDone(self, *args)


    def SurfShape(self, *args):
        """
        SurfShape(GeomFill_AppSurf self)

        :type UDegree: int
        :type VDegree: int
        :type NbUPoles: int
        :type NbVPoles: int
        :type NbUKnots: int
        :type NbVKnots: int

        """
        return _GeomFill.GeomFill_AppSurf_SurfShape(self, *args)


    def Surface(self, *args):
        """
        Surface(GeomFill_AppSurf self, NCollection_Array2_gp_Pnt TPoles, NCollection_Array2_Standard_Real TWeights, NCollection_Array1_Standard_Real TUKnots, NCollection_Array1_Standard_Real TVKnots, NCollection_Array1_Standard_Integer TUMults, NCollection_Array1_Standard_Integer TVMults)

        :type TPoles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type TWeights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type TUKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type TVKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type TUMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type TVMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _GeomFill.GeomFill_AppSurf_Surface(self, *args)


    def UDegree(self, *args):
        """
        UDegree(GeomFill_AppSurf self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_AppSurf_UDegree(self, *args)


    def VDegree(self, *args):
        """
        VDegree(GeomFill_AppSurf self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_AppSurf_VDegree(self, *args)


    def SurfPoles(self, *args):
        """
        :rtype: OCC.wrapper.TColgp.TColgp_Array2OfPnt

        """
        res = _GeomFill.GeomFill_AppSurf_SurfPoles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfWeights(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        res = _GeomFill.GeomFill_AppSurf_SurfWeights(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfUKnots(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _GeomFill.GeomFill_AppSurf_SurfUKnots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfVKnots(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _GeomFill.GeomFill_AppSurf_SurfVKnots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfUMults(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _GeomFill.GeomFill_AppSurf_SurfUMults(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfVMults(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _GeomFill.GeomFill_AppSurf_SurfVMults(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbCurves2d(self, *args):
        """
        NbCurves2d(GeomFill_AppSurf self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_AppSurf_NbCurves2d(self, *args)


    def Curves2dShape(self, *args):
        """
        Curves2dShape(GeomFill_AppSurf self)

        :type Degree: int
        :type NbPoles: int
        :type NbKnots: int

        """
        return _GeomFill.GeomFill_AppSurf_Curves2dShape(self, *args)


    def Curve2d(self, *args):
        """
        Curve2d(GeomFill_AppSurf self, Standard_Integer const Index, NCollection_Array1_gp_Pnt2d TPoles, NCollection_Array1_Standard_Real TKnots, NCollection_Array1_Standard_Integer TMults)

        :type Index: int
        :type TPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _GeomFill.GeomFill_AppSurf_Curve2d(self, *args)


    def Curves2dDegree(self, *args):
        """
        Curves2dDegree(GeomFill_AppSurf self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_AppSurf_Curves2dDegree(self, *args)


    def Curve2dPoles(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        res = _GeomFill.GeomFill_AppSurf_Curve2dPoles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curves2dKnots(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _GeomFill.GeomFill_AppSurf_Curves2dKnots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curves2dMults(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _GeomFill.GeomFill_AppSurf_Curves2dMults(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TolReached(self, *args):
        """
        TolReached(GeomFill_AppSurf self)

        :type Tol3d: float
        :type Tol2d: float

        """
        return _GeomFill.GeomFill_AppSurf_TolReached(self, *args)


    def TolCurveOnSurf(self, *args):
        """
        TolCurveOnSurf(GeomFill_AppSurf self, Standard_Integer const Index) -> Standard_Real

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_AppSurf_TolCurveOnSurf(self, *args)

    __swig_destroy__ = _GeomFill.delete_GeomFill_AppSurf
GeomFill_AppSurf_swigregister = _GeomFill.GeomFill_AppSurf_swigregister
GeomFill_AppSurf_swigregister(GeomFill_AppSurf)

class Handle_GeomFill_Boundary(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_Boundary self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_Boundary_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_Boundary self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_Boundary_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_Boundary self, GeomFill_Boundary thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_Boundary_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_Boundary self, Handle_GeomFill_Boundary theHandle) -> Handle_GeomFill_Boundary
        assign(Handle_GeomFill_Boundary self, GeomFill_Boundary thePtr) -> Handle_GeomFill_Boundary
        assign(Handle_GeomFill_Boundary self, Handle_GeomFill_Boundary theHandle) -> Handle_GeomFill_Boundary

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_Boundary_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_Boundary self) -> GeomFill_Boundary

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_Boundary_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_Boundary self) -> GeomFill_Boundary

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_Boundary___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_Boundary self) -> GeomFill_Boundary

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_Boundary___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_Boundary___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_Boundary___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_Boundary(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_Boundary_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_Boundary

    def Value(self, *args):
        """
        Value(Handle_GeomFill_Boundary self, Standard_Real const U) -> gp_Pnt

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.Handle_GeomFill_Boundary_Value(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_Boundary self, Standard_Real const U, gp_Pnt P, gp_Vec V)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_Boundary_D1(self, *args)


    def HasNormals(self, *args):
        """
        HasNormals(Handle_GeomFill_Boundary self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Boundary_HasNormals(self, *args)


    def Norm(self, *args):
        """
        Norm(Handle_GeomFill_Boundary self, Standard_Real const U) -> gp_Vec

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_Boundary_Norm(self, *args)


    def D1Norm(self, *args):
        """
        D1Norm(Handle_GeomFill_Boundary self, Standard_Real const U, gp_Vec N, gp_Vec DN)

        :type U: float
        :type N: OCC.wrapper.gp.gp_Vec
        :type DN: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_Boundary_D1Norm(self, *args)


    def Reparametrize(self, *args):
        """
        Reparametrize(Handle_GeomFill_Boundary self, Standard_Real const First, Standard_Real const Last, Standard_Boolean const HasDF, Standard_Boolean const HasDL, Standard_Real const DF, Standard_Real const DL, Standard_Boolean const Rev)

        :type First: float
        :type Last: float
        :type HasDF: bool
        :type HasDL: bool
        :type DF: float
        :type DL: float
        :type Rev: bool

        """
        return _GeomFill.Handle_GeomFill_Boundary_Reparametrize(self, *args)


    def Points(self, *args):
        """
        Points(Handle_GeomFill_Boundary self, gp_Pnt PFirst, gp_Pnt PLast)

        :type PFirst: OCC.wrapper.gp.gp_Pnt
        :type PLast: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.Handle_GeomFill_Boundary_Points(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_GeomFill_Boundary self)

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_Boundary_Bounds(self, *args)


    def IsDegenerated(self, *args):
        """
        IsDegenerated(Handle_GeomFill_Boundary self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Boundary_IsDegenerated(self, *args)


    def Tol3d(self, *args):
        """
        Tol3d(Handle_GeomFill_Boundary self) -> Standard_Real
        Tol3d(Handle_GeomFill_Boundary self, Standard_Real const Tol)

        :type Tol: float

        """
        return _GeomFill.Handle_GeomFill_Boundary_Tol3d(self, *args)


    def Tolang(self, *args):
        """
        Tolang(Handle_GeomFill_Boundary self) -> Standard_Real
        Tolang(Handle_GeomFill_Boundary self, Standard_Real const Tol)

        :type Tol: float

        """
        return _GeomFill.Handle_GeomFill_Boundary_Tolang(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_Boundary self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_Boundary_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_Boundary_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_Boundary_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_Boundary self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_Boundary_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_Boundary self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_Boundary self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Boundary_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_Boundary self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_Boundary self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Boundary_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_Boundary self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_Boundary_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_Boundary self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_Boundary_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_Boundary self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_Boundary_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_Boundary self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_Boundary_DecrementRefCounter(self, *args)

Handle_GeomFill_Boundary_swigregister = _GeomFill.Handle_GeomFill_Boundary_swigregister
Handle_GeomFill_Boundary_swigregister(Handle_GeomFill_Boundary)

def Handle_GeomFill_Boundary_DownCast(thing):
    return _GeomFill.Handle_GeomFill_Boundary_DownCast(thing)
Handle_GeomFill_Boundary_DownCast = _GeomFill.Handle_GeomFill_Boundary_DownCast

class GeomFill_SweepSectionGenerator(object):
    """
    class for instantiation of AppBlend.
    evaluate the sections of a sweep surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomFill_SweepSectionGenerator self) -> GeomFill_SweepSectionGenerator
        __init__(GeomFill_SweepSectionGenerator self, Handle_Geom_Curve Path, Standard_Real const Radius) -> GeomFill_SweepSectionGenerator
        __init__(GeomFill_SweepSectionGenerator self, Handle_Geom_Curve Path, Handle_Geom_Curve FirstSect) -> GeomFill_SweepSectionGenerator
        __init__(GeomFill_SweepSectionGenerator self, Handle_Geom_Curve Path, Handle_Geom_Curve FirstSect, Handle_Geom_Curve LastSect) -> GeomFill_SweepSectionGenerator
        __init__(GeomFill_SweepSectionGenerator self, Handle_Adaptor3d_HCurve Path, Handle_Adaptor3d_HCurve Curve1, Handle_Adaptor3d_HCurve Curve2, Standard_Real const Radius) -> GeomFill_SweepSectionGenerator

        Create  a pipe  with  a constant  radius with  2
        guide-line.

        :type Path: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type Curve1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type Curve2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type Radius: float

        """
        this = _GeomFill.new_GeomFill_SweepSectionGenerator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(GeomFill_SweepSectionGenerator self, Handle_Geom_Curve Path, Standard_Real const Radius)
        Init(GeomFill_SweepSectionGenerator self, Handle_Geom_Curve Path, Handle_Geom_Curve FirstSect)
        Init(GeomFill_SweepSectionGenerator self, Handle_Geom_Curve Path, Handle_Geom_Curve FirstSect, Handle_Geom_Curve LastSect)
        Init(GeomFill_SweepSectionGenerator self, Handle_Adaptor3d_HCurve Path, Handle_Adaptor3d_HCurve Curve1, Handle_Adaptor3d_HCurve Curve2, Standard_Real const Radius)

        :type Path: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type Curve1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type Curve2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type Radius: float

        """
        return _GeomFill.GeomFill_SweepSectionGenerator_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(GeomFill_SweepSectionGenerator self, Standard_Boolean const Polynomial)

        :type Polynomial: bool

        """
        return _GeomFill.GeomFill_SweepSectionGenerator_Perform(self, *args)


    def GetShape(self, *args):
        """
        GetShape(GeomFill_SweepSectionGenerator self)

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int
        :type NbPoles2d: int

        """
        return _GeomFill.GeomFill_SweepSectionGenerator_GetShape(self, *args)


    def Knots(self, *args):
        """
        Knots(GeomFill_SweepSectionGenerator self, NCollection_Array1_Standard_Real TKnots)

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_SweepSectionGenerator_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(GeomFill_SweepSectionGenerator self, NCollection_Array1_Standard_Integer TMults)

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _GeomFill.GeomFill_SweepSectionGenerator_Mults(self, *args)


    def NbSections(self, *args):
        """
        NbSections(GeomFill_SweepSectionGenerator self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_SweepSectionGenerator_NbSections(self, *args)


    def Section(self, *args):
        """
        Section(GeomFill_SweepSectionGenerator self, Standard_Integer const P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean
        Section(GeomFill_SweepSectionGenerator self, Standard_Integer const P, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths)

        :type P: int
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_SweepSectionGenerator_Section(self, *args)


    def Transformation(self, *args):
        """
        raised if <Index> not in the range [1,NbSections()]

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _GeomFill.GeomFill_SweepSectionGenerator_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Parameter(self, *args):
        """
        Parameter(GeomFill_SweepSectionGenerator self, Standard_Integer const P) -> Standard_Real

        Returns  the parameter of   <P>, to impose  it for the
        approximation.

        :type P: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_SweepSectionGenerator_Parameter(self, *args)

    __swig_destroy__ = _GeomFill.delete_GeomFill_SweepSectionGenerator
GeomFill_SweepSectionGenerator_swigregister = _GeomFill.GeomFill_SweepSectionGenerator_swigregister
GeomFill_SweepSectionGenerator_swigregister(GeomFill_SweepSectionGenerator)

class GeomFill_AppSweep(AppBlend.AppBlend_Approx):
    """
    Approximate a sweep surface passing  by  all the
    curves described in the SweepSectionGenerator.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomFill_AppSweep self) -> GeomFill_AppSweep
        __init__(GeomFill_AppSweep self, Standard_Integer const Degmin, Standard_Integer const Degmax, Standard_Real const Tol3d, Standard_Real const Tol2d, Standard_Integer const NbIt, Standard_Boolean const KnownParameters) -> GeomFill_AppSweep

        :type Degmin: int
        :type Degmax: int
        :type Tol3d: float
        :type Tol2d: float
        :type NbIt: int
        :type KnownParameters: bool

        """
        this = _GeomFill.new_GeomFill_AppSweep(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(GeomFill_AppSweep self, Standard_Integer const Degmin, Standard_Integer const Degmax, Standard_Real const Tol3d, Standard_Real const Tol2d, Standard_Integer const NbIt, Standard_Boolean const KnownParameters)

        :type Degmin: int
        :type Degmax: int
        :type Tol3d: float
        :type Tol2d: float
        :type NbIt: int
        :type KnownParameters: bool

        """
        return _GeomFill.GeomFill_AppSweep_Init(self, *args)


    def SetParType(self, *args):
        """
        SetParType(GeomFill_AppSweep self, Approx_ParametrizationType const ParType)

        Define the type of parametrization used in the approximation

        :type ParType: OCC.wrapper.Approx.Approx_ParametrizationType

        """
        return _GeomFill.GeomFill_AppSweep_SetParType(self, *args)


    def SetContinuity(self, *args):
        """
        SetContinuity(GeomFill_AppSweep self, GeomAbs_Shape const C)

        Define the Continuity used in the approximation

        :type C: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.GeomFill_AppSweep_SetContinuity(self, *args)


    def SetCriteriumWeight(self, *args):
        """
        SetCriteriumWeight(GeomFill_AppSweep self, Standard_Real const W1, Standard_Real const W2, Standard_Real const W3)

        define the Weights  associed to the criterium used in
        the  optimization.

        if Wi <= 0

        :type W1: float
        :type W2: float
        :type W3: float

        """
        return _GeomFill.GeomFill_AppSweep_SetCriteriumWeight(self, *args)


    def ParType(self, *args):
        """
        ParType(GeomFill_AppSweep self) -> Approx_ParametrizationType

        returns the type of parametrization used in the approximation

        :rtype: OCC.wrapper.Approx.Approx_ParametrizationType

        """
        return _GeomFill.GeomFill_AppSweep_ParType(self, *args)


    def Continuity(self, *args):
        """
        Continuity(GeomFill_AppSweep self) -> GeomAbs_Shape

        returns the Continuity used in the approximation

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.GeomFill_AppSweep_Continuity(self, *args)


    def CriteriumWeight(self, *args):
        """
        CriteriumWeight(GeomFill_AppSweep self)

        returns the Weights (as percent) associed  to the criterium used in
        the  optimization.

        :type W1: float
        :type W2: float
        :type W3: float

        """
        return _GeomFill.GeomFill_AppSweep_CriteriumWeight(self, *args)


    def PerformSmoothing(self, *args):
        """
        PerformSmoothing(GeomFill_AppSweep self, Handle_GeomFill_Line Lin, GeomFill_SweepSectionGenerator SecGen)

        :type Lin: OCC.wrapper.GeomFill.Handle_GeomFill_Line
        :type SecGen: OCC.wrapper.GeomFill.GeomFill_SweepSectionGenerator

        """
        return _GeomFill.GeomFill_AppSweep_PerformSmoothing(self, *args)


    def Perform(self, *args):
        """
        Perform(GeomFill_AppSweep self, Handle_GeomFill_Line Lin, GeomFill_SweepSectionGenerator SecGen, Standard_Boolean const SpApprox)
        Perform(GeomFill_AppSweep self, Handle_GeomFill_Line Lin, GeomFill_SweepSectionGenerator SecGen, Standard_Integer const NbMaxP)

        :type Lin: OCC.wrapper.GeomFill.Handle_GeomFill_Line
        :type SecGen: OCC.wrapper.GeomFill.GeomFill_SweepSectionGenerator
        :type NbMaxP: int

        """
        return _GeomFill.GeomFill_AppSweep_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(GeomFill_AppSweep self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_AppSweep_IsDone(self, *args)


    def SurfShape(self, *args):
        """
        SurfShape(GeomFill_AppSweep self)

        :type UDegree: int
        :type VDegree: int
        :type NbUPoles: int
        :type NbVPoles: int
        :type NbUKnots: int
        :type NbVKnots: int

        """
        return _GeomFill.GeomFill_AppSweep_SurfShape(self, *args)


    def Surface(self, *args):
        """
        Surface(GeomFill_AppSweep self, NCollection_Array2_gp_Pnt TPoles, NCollection_Array2_Standard_Real TWeights, NCollection_Array1_Standard_Real TUKnots, NCollection_Array1_Standard_Real TVKnots, NCollection_Array1_Standard_Integer TUMults, NCollection_Array1_Standard_Integer TVMults)

        :type TPoles: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type TWeights: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type TUKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type TVKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type TUMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type TVMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _GeomFill.GeomFill_AppSweep_Surface(self, *args)


    def UDegree(self, *args):
        """
        UDegree(GeomFill_AppSweep self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_AppSweep_UDegree(self, *args)


    def VDegree(self, *args):
        """
        VDegree(GeomFill_AppSweep self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_AppSweep_VDegree(self, *args)


    def SurfPoles(self, *args):
        """
        :rtype: OCC.wrapper.TColgp.TColgp_Array2OfPnt

        """
        res = _GeomFill.GeomFill_AppSweep_SurfPoles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfWeights(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        res = _GeomFill.GeomFill_AppSweep_SurfWeights(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfUKnots(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _GeomFill.GeomFill_AppSweep_SurfUKnots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfVKnots(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _GeomFill.GeomFill_AppSweep_SurfVKnots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfUMults(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _GeomFill.GeomFill_AppSweep_SurfUMults(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfVMults(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _GeomFill.GeomFill_AppSweep_SurfVMults(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbCurves2d(self, *args):
        """
        NbCurves2d(GeomFill_AppSweep self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_AppSweep_NbCurves2d(self, *args)


    def Curves2dShape(self, *args):
        """
        Curves2dShape(GeomFill_AppSweep self)

        :type Degree: int
        :type NbPoles: int
        :type NbKnots: int

        """
        return _GeomFill.GeomFill_AppSweep_Curves2dShape(self, *args)


    def Curve2d(self, *args):
        """
        Curve2d(GeomFill_AppSweep self, Standard_Integer const Index, NCollection_Array1_gp_Pnt2d TPoles, NCollection_Array1_Standard_Real TKnots, NCollection_Array1_Standard_Integer TMults)

        :type Index: int
        :type TPoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _GeomFill.GeomFill_AppSweep_Curve2d(self, *args)


    def Curves2dDegree(self, *args):
        """
        Curves2dDegree(GeomFill_AppSweep self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_AppSweep_Curves2dDegree(self, *args)


    def Curve2dPoles(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        res = _GeomFill.GeomFill_AppSweep_Curve2dPoles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curves2dKnots(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _GeomFill.GeomFill_AppSweep_Curves2dKnots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curves2dMults(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _GeomFill.GeomFill_AppSweep_Curves2dMults(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TolReached(self, *args):
        """
        TolReached(GeomFill_AppSweep self)

        :type Tol3d: float
        :type Tol2d: float

        """
        return _GeomFill.GeomFill_AppSweep_TolReached(self, *args)


    def TolCurveOnSurf(self, *args):
        """
        TolCurveOnSurf(GeomFill_AppSweep self, Standard_Integer const Index) -> Standard_Real

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_AppSweep_TolCurveOnSurf(self, *args)

    __swig_destroy__ = _GeomFill.delete_GeomFill_AppSweep
GeomFill_AppSweep_swigregister = _GeomFill.GeomFill_AppSweep_swigregister
GeomFill_AppSweep_swigregister(GeomFill_AppSweep)

class GeomFill_SectionPlacement(object):
    """To place section in sweep Function"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomFill_SectionPlacement self, Handle_GeomFill_LocationLaw L, Handle_Geom_Geometry Section) -> GeomFill_SectionPlacement

        :type L: OCC.wrapper.GeomFill.Handle_GeomFill_LocationLaw
        :type Section: OCC.wrapper.Geom.Handle_Geom_Geometry

        """
        this = _GeomFill.new_GeomFill_SectionPlacement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetLocation(self, *args):
        """
        SetLocation(GeomFill_SectionPlacement self, Handle_GeomFill_LocationLaw L)

        To change the section Law

        :type L: OCC.wrapper.GeomFill.Handle_GeomFill_LocationLaw

        """
        return _GeomFill.GeomFill_SectionPlacement_SetLocation(self, *args)


    def Perform(self, *args):
        """
        Perform(GeomFill_SectionPlacement self, Standard_Real const Tol)
        Perform(GeomFill_SectionPlacement self, Handle_Adaptor3d_HCurve Path, Standard_Real const Tol)
        Perform(GeomFill_SectionPlacement self, Standard_Real const ParamOnPath, Standard_Real const Tol)

        :type ParamOnPath: float
        :type Tol: float

        """
        return _GeomFill.GeomFill_SectionPlacement_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(GeomFill_SectionPlacement self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_SectionPlacement_IsDone(self, *args)


    def ParameterOnPath(self, *args):
        """
        ParameterOnPath(GeomFill_SectionPlacement self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_SectionPlacement_ParameterOnPath(self, *args)


    def ParameterOnSection(self, *args):
        """
        ParameterOnSection(GeomFill_SectionPlacement self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_SectionPlacement_ParameterOnSection(self, *args)


    def Distance(self, *args):
        """
        Distance(GeomFill_SectionPlacement self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_SectionPlacement_Distance(self, *args)


    def Angle(self, *args):
        """
        Angle(GeomFill_SectionPlacement self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_SectionPlacement_Angle(self, *args)


    def Transformation(self, *args):
        """
        Transformation(GeomFill_SectionPlacement self, Standard_Boolean const WithTranslation, Standard_Boolean const WithCorrection) -> gp_Trsf

        :type WithTranslation: bool
        :type WithCorrection: bool
        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        return _GeomFill.GeomFill_SectionPlacement_Transformation(self, *args)


    def Section(self, *args):
        """
        Section(GeomFill_SectionPlacement self, Standard_Boolean const WithTranslation) -> Handle_Geom_Curve

        Compute the Section, in the coordinate syteme given by
        the Location Law.
        If <WithTranslation> contact beetween
        <Section> and <Path> is forced.

        :type WithTranslation: bool
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _GeomFill.GeomFill_SectionPlacement_Section(self, *args)


    def ModifiedSection(self, *args):
        """
        ModifiedSection(GeomFill_SectionPlacement self, Standard_Boolean const WithTranslation) -> Handle_Geom_Curve

        Compute the Section, in the coordinate syteme given by
        the Location Law.
        To have the Normal to section equal to the Location
        Law Normal.  If <WithTranslation> contact beetween
        <Section> and <Path> is forced.

        :type WithTranslation: bool
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _GeomFill.GeomFill_SectionPlacement_ModifiedSection(self, *args)

    __swig_destroy__ = _GeomFill.delete_GeomFill_SectionPlacement
GeomFill_SectionPlacement_swigregister = _GeomFill.GeomFill_SectionPlacement_swigregister
GeomFill_SectionPlacement_swigregister(GeomFill_SectionPlacement)

class Handle_GeomFill_CorrectedFrenet(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_CorrectedFrenet self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_CorrectedFrenet self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_CorrectedFrenet self, GeomFill_CorrectedFrenet thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_CorrectedFrenet self, Handle_GeomFill_CorrectedFrenet theHandle) -> Handle_GeomFill_CorrectedFrenet
        assign(Handle_GeomFill_CorrectedFrenet self, GeomFill_CorrectedFrenet thePtr) -> Handle_GeomFill_CorrectedFrenet
        assign(Handle_GeomFill_CorrectedFrenet self, Handle_GeomFill_CorrectedFrenet theHandle) -> Handle_GeomFill_CorrectedFrenet

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_CorrectedFrenet self) -> GeomFill_CorrectedFrenet

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_CorrectedFrenet self) -> GeomFill_CorrectedFrenet

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_CorrectedFrenet self) -> GeomFill_CorrectedFrenet

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_CorrectedFrenet___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_CorrectedFrenet___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_CorrectedFrenet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_CorrectedFrenet_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_CorrectedFrenet

    def Copy(self, *args):
        """
        Copy(Handle_GeomFill_CorrectedFrenet self) -> Handle_GeomFill_TrihedronLaw

        :rtype: OCC.wrapper.GeomFill.Handle_GeomFill_TrihedronLaw

        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_Copy(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(Handle_GeomFill_CorrectedFrenet self, Handle_Adaptor3d_HCurve C)

        :type C: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_SetCurve(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Handle_GeomFill_CorrectedFrenet self, Standard_Real const First, Standard_Real const Last)

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_SetInterval(self, *args)


    def D0(self, *args):
        """
        D0(Handle_GeomFill_CorrectedFrenet self, Standard_Real const Param, gp_Vec Tangent, gp_Vec Normal, gp_Vec BiNormal) -> Standard_Boolean

        compute Triedrhon on curve at parameter <Param>

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_CorrectedFrenet self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec BiNormal, gp_Vec DBiNormal) -> Standard_Boolean

        compute Triedrhon and  derivative Trihedron  on curve
        at parameter <Param>
        Warning : It used only for C1 or C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_GeomFill_CorrectedFrenet self, Standard_Real const Param, gp_Vec Tangent, gp_Vec DTangent, gp_Vec D2Tangent, gp_Vec Normal, gp_Vec DNormal, gp_Vec D2Normal, gp_Vec BiNormal, gp_Vec DBiNormal, gp_Vec D2BiNormal) -> Standard_Boolean

        compute  Trihedron on curve
        first and seconde  derivatives.
        Warning : It used only for C2 aproximation

        :type Param: float
        :type Tangent: OCC.wrapper.gp.gp_Vec
        :type DTangent: OCC.wrapper.gp.gp_Vec
        :type D2Tangent: OCC.wrapper.gp.gp_Vec
        :type Normal: OCC.wrapper.gp.gp_Vec
        :type DNormal: OCC.wrapper.gp.gp_Vec
        :type D2Normal: OCC.wrapper.gp.gp_Vec
        :type BiNormal: OCC.wrapper.gp.gp_Vec
        :type DBiNormal: OCC.wrapper.gp.gp_Vec
        :type D2BiNormal: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_D2(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_GeomFill_CorrectedFrenet self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>.
        May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_GeomFill_CorrectedFrenet self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_Intervals(self, *args)


    def EvaluateBestMode(self, *args):
        """
        EvaluateBestMode(Handle_GeomFill_CorrectedFrenet self) -> GeomFill_Trihedron

        Tries to define the best trihedron mode
        for the curve. It can be:
        - Frenet
        - CorrectedFrenet
        - DiscreteTrihedron
        Warning: the CorrectedFrenet must be constructed
        with option ForEvaluation = True,
        the curve must be set by method SetCurve.

        :rtype: OCC.wrapper.GeomFill.GeomFill_Trihedron

        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_EvaluateBestMode(self, *args)


    def GetAverageLaw(self, *args):
        """
        GetAverageLaw(Handle_GeomFill_CorrectedFrenet self, gp_Vec ATangent, gp_Vec ANormal, gp_Vec ABiNormal)

        Get average value of Tangent(t) and Normal(t) it is usfull to
        make fast approximation of rational  surfaces.

        :type ATangent: OCC.wrapper.gp.gp_Vec
        :type ANormal: OCC.wrapper.gp.gp_Vec
        :type ABiNormal: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_GetAverageLaw(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(Handle_GeomFill_CorrectedFrenet self) -> Standard_Boolean

        Say if the law is Constant.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_IsConstant(self, *args)


    def IsOnlyBy3dCurve(self, *args):
        """
        IsOnlyBy3dCurve(Handle_GeomFill_CorrectedFrenet self) -> Standard_Boolean

        Return True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_IsOnlyBy3dCurve(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_CorrectedFrenet self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_CorrectedFrenet_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_CorrectedFrenet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_GeomFill_CorrectedFrenet self) -> GeomFill_PipeError

        Give a status to the Law
        Returns PipeOk (default implementation)

        :rtype: OCC.wrapper.GeomFill.GeomFill_PipeError

        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_ErrorStatus(self, *args)


    def GetInterval(self, *args):
        """
        GetInterval(Handle_GeomFill_CorrectedFrenet self)

        Gets the bounds of the parametric interval on
        the function

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_GetInterval(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_CorrectedFrenet self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_CorrectedFrenet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_CorrectedFrenet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_CorrectedFrenet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_CorrectedFrenet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_CorrectedFrenet self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_CorrectedFrenet self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_CorrectedFrenet self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_CorrectedFrenet self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_CorrectedFrenet_DecrementRefCounter(self, *args)

Handle_GeomFill_CorrectedFrenet_swigregister = _GeomFill.Handle_GeomFill_CorrectedFrenet_swigregister
Handle_GeomFill_CorrectedFrenet_swigregister(Handle_GeomFill_CorrectedFrenet)

def Handle_GeomFill_CorrectedFrenet_DownCast(thing):
    return _GeomFill.Handle_GeomFill_CorrectedFrenet_DownCast(thing)
Handle_GeomFill_CorrectedFrenet_DownCast = _GeomFill.Handle_GeomFill_CorrectedFrenet_DownCast

class NCollection_Array1_Handle_GeomFill_LocationLaw(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_GeomFill_LocationLaw self) -> NCollection_Array1< opencascade::handle< GeomFill_LocationLaw > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_LocationLaw_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_GeomFill_LocationLaw self) -> NCollection_Array1< opencascade::handle< GeomFill_LocationLaw > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_LocationLaw_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_GeomFill_LocationLaw self) -> NCollection_Array1< opencascade::handle< GeomFill_LocationLaw > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_LocationLaw_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_GeomFill_LocationLaw self) -> NCollection_Array1< opencascade::handle< GeomFill_LocationLaw > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_LocationLaw_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _GeomFill.new_NCollection_Array1_Handle_GeomFill_LocationLaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_GeomFill_LocationLaw self, Handle_GeomFill_LocationLaw theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_LocationLaw_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_GeomFill_LocationLaw self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_LocationLaw_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_GeomFill_LocationLaw self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_LocationLaw_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_GeomFill_LocationLaw self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_LocationLaw_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_GeomFill_LocationLaw self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_LocationLaw_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_GeomFill_LocationLaw self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_LocationLaw_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_GeomFill_LocationLaw self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_LocationLaw_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_GeomFill_LocationLaw self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_LocationLaw_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_GeomFill_LocationLaw self, NCollection_Array1_Handle_GeomFill_LocationLaw theOther) -> NCollection_Array1_Handle_GeomFill_LocationLaw

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_LocationLaw_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_GeomFill_LocationLaw self, NCollection_Array1_Handle_GeomFill_LocationLaw theOther) -> NCollection_Array1_Handle_GeomFill_LocationLaw

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_LocationLaw_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_GeomFill_LocationLaw self, NCollection_Array1_Handle_GeomFill_LocationLaw theOther) -> NCollection_Array1_Handle_GeomFill_LocationLaw
        assign(NCollection_Array1_Handle_GeomFill_LocationLaw self, NCollection_Array1_Handle_GeomFill_LocationLaw theOther) -> NCollection_Array1_Handle_GeomFill_LocationLaw

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_LocationLaw_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _GeomFill.NCollection_Array1_Handle_GeomFill_LocationLaw_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_GeomFill_LocationLaw self) -> Handle_GeomFill_LocationLaw

        @return first element

        :rtype: TheItemType &

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_LocationLaw_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _GeomFill.NCollection_Array1_Handle_GeomFill_LocationLaw_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_GeomFill_LocationLaw self) -> Handle_GeomFill_LocationLaw

        @return last element

        :rtype: TheItemType &

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_LocationLaw_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GeomFill.NCollection_Array1_Handle_GeomFill_LocationLaw_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_GeomFill_LocationLaw self, Standard_Integer const theIndex) -> Handle_GeomFill_LocationLaw

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_LocationLaw_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GeomFill.NCollection_Array1_Handle_GeomFill_LocationLaw___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GeomFill.NCollection_Array1_Handle_GeomFill_LocationLaw_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_GeomFill_LocationLaw self, Standard_Integer const theIndex, Handle_GeomFill_LocationLaw theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_LocationLaw_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_GeomFill_LocationLaw self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _GeomFill.NCollection_Array1_Handle_GeomFill_LocationLaw_Resize(self, *args)

    __swig_destroy__ = _GeomFill.delete_NCollection_Array1_Handle_GeomFill_LocationLaw
NCollection_Array1_Handle_GeomFill_LocationLaw_swigregister = _GeomFill.NCollection_Array1_Handle_GeomFill_LocationLaw_swigregister
NCollection_Array1_Handle_GeomFill_LocationLaw_swigregister(NCollection_Array1_Handle_GeomFill_LocationLaw)


try:
	GeomFill_Array1OfLocationLaw = NCollection_Array1_Handle_GeomFill_LocationLaw
except NameError:
	pass # does not exist, probably ignored

class GeomFill_SnglrFunc(Adaptor3d.Adaptor3d_Curve):
    """to  represent  function  C'(t)^C''(t)"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomFill_SnglrFunc self, Handle_Adaptor3d_HCurve HC) -> GeomFill_SnglrFunc

        :type HC: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        this = _GeomFill.new_GeomFill_SnglrFunc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetRatio(self, *args):
        """
        SetRatio(GeomFill_SnglrFunc self, Standard_Real const Ratio)

        :type Ratio: float

        """
        return _GeomFill.GeomFill_SnglrFunc_SetRatio(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(GeomFill_SnglrFunc self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_SnglrFunc_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(GeomFill_SnglrFunc self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_SnglrFunc_LastParameter(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(GeomFill_SnglrFunc self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_SnglrFunc_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(GeomFill_SnglrFunc self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.GeomFill_SnglrFunc_Intervals(self, *args)


    def Value(self, *args):
        """
        Value(GeomFill_SnglrFunc self, Standard_Real const U) -> gp_Pnt

        Computes the point of parameter U on the curve.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.GeomFill_SnglrFunc_Value(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(GeomFill_SnglrFunc self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_SnglrFunc_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(GeomFill_SnglrFunc self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_SnglrFunc_Period(self, *args)


    def D0(self, *args):
        """
        D0(GeomFill_SnglrFunc self, Standard_Real const U, gp_Pnt P)

        Computes the point of parameter U on the curve.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.GeomFill_SnglrFunc_D0(self, *args)


    def D1(self, *args):
        """
        D1(GeomFill_SnglrFunc self, Standard_Real const U, gp_Pnt P, gp_Vec V)

        Computes the point of parameter U on the curve with its
        first derivative.
        Raised if the continuity of the current interval
        is not C1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_SnglrFunc_D1(self, *args)


    def D2(self, *args):
        """
        D2(GeomFill_SnglrFunc self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.
        Raised if the continuity of the current interval
        is not C2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_SnglrFunc_D2(self, *args)


    def D3(self, *args):
        """
        D3(GeomFill_SnglrFunc self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        Returns the point P of parameter U, the first, the second
        and the third derivative.
        Raised if the continuity of the current interval
        is not C1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_SnglrFunc_D3(self, *args)


    def DN(self, *args):
        """
        DN(GeomFill_SnglrFunc self, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        The returned vector gives the value of the derivative for the
        order of derivation N.
        Raised if N < 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.GeomFill_SnglrFunc_DN(self, *args)


    def Resolution(self, *args):
        """
        Resolution(GeomFill_SnglrFunc self, Standard_Real const R3d) -> Standard_Real

        Returns the parametric  resolution corresponding
        to the real space resolution <R3d>.

        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_SnglrFunc_Resolution(self, *args)


    def GetType(self, *args):
        """
        GetType(GeomFill_SnglrFunc self) -> GeomAbs_CurveType

        Returns  the  type of the   curve  in the  current
        interval :   Line,   Circle,   Ellipse, Hyperbola,
        Parabola, BezierCurve, BSplineCurve, OtherCurve.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _GeomFill.GeomFill_SnglrFunc_GetType(self, *args)

    __swig_destroy__ = _GeomFill.delete_GeomFill_SnglrFunc
GeomFill_SnglrFunc_swigregister = _GeomFill.GeomFill_SnglrFunc_swigregister
GeomFill_SnglrFunc_swigregister(GeomFill_SnglrFunc)

class Handle_GeomFill_Line(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_Line self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_Line_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_Line self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_Line_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_Line self, GeomFill_Line thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_Line_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_Line self, Handle_GeomFill_Line theHandle) -> Handle_GeomFill_Line
        assign(Handle_GeomFill_Line self, GeomFill_Line thePtr) -> Handle_GeomFill_Line
        assign(Handle_GeomFill_Line self, Handle_GeomFill_Line theHandle) -> Handle_GeomFill_Line

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_Line_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_Line self) -> GeomFill_Line

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_Line_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_Line self) -> GeomFill_Line

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_Line___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_Line self) -> GeomFill_Line

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_Line___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_Line___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_Line___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_Line(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_Line_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_Line

    def NbPoints(self, *args):
        """
        NbPoints(Handle_GeomFill_Line self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_Line_NbPoints(self, *args)


    def Point(self, *args):
        """
        Point(Handle_GeomFill_Line self, Standard_Integer const Index) -> Standard_Integer

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_Line_Point(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_Line self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_Line_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_Line_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_Line_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_Line self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_Line_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_Line self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_Line self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Line_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_Line self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_Line self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_Line_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_Line self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_Line_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_Line self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_Line_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_Line self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_Line_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_Line self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_Line_DecrementRefCounter(self, *args)

Handle_GeomFill_Line_swigregister = _GeomFill.Handle_GeomFill_Line_swigregister
Handle_GeomFill_Line_swigregister(Handle_GeomFill_Line)

def Handle_GeomFill_Line_DownCast(thing):
    return _GeomFill.Handle_GeomFill_Line_DownCast(thing)
Handle_GeomFill_Line_DownCast = _GeomFill.Handle_GeomFill_Line_DownCast

class Handle_GeomFill_HSequenceOfAx2(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_HSequenceOfAx2 self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_HSequenceOfAx2_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_HSequenceOfAx2 self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_HSequenceOfAx2_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_HSequenceOfAx2 self, GeomFill_HSequenceOfAx2 thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_HSequenceOfAx2_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_HSequenceOfAx2 self, Handle_GeomFill_HSequenceOfAx2 theHandle) -> Handle_GeomFill_HSequenceOfAx2
        assign(Handle_GeomFill_HSequenceOfAx2 self, GeomFill_HSequenceOfAx2 thePtr) -> Handle_GeomFill_HSequenceOfAx2
        assign(Handle_GeomFill_HSequenceOfAx2 self, Handle_GeomFill_HSequenceOfAx2 theHandle) -> Handle_GeomFill_HSequenceOfAx2

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_HSequenceOfAx2_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_HSequenceOfAx2 self) -> GeomFill_HSequenceOfAx2

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_HSequenceOfAx2_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_HSequenceOfAx2 self) -> GeomFill_HSequenceOfAx2

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_HSequenceOfAx2___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_HSequenceOfAx2 self) -> GeomFill_HSequenceOfAx2

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_HSequenceOfAx2___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_HSequenceOfAx2___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_HSequenceOfAx2___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_HSequenceOfAx2(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_HSequenceOfAx2_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_HSequenceOfAx2

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.GeomFill.GeomFill_SequenceOfAx2

        """
        res = _GeomFill.Handle_GeomFill_HSequenceOfAx2_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_GeomFill_HSequenceOfAx2 self, gp_Ax2 theItem)
        Append(Handle_GeomFill_HSequenceOfAx2 self, NCollection_Sequence_gp_Ax2 theSequence)

        :type theSequence: OCC.wrapper.GeomFill.GeomFill_SequenceOfAx2

        """
        return _GeomFill.Handle_GeomFill_HSequenceOfAx2_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_GeomFill_HSequenceOfAx2 self) -> NCollection_Sequence_gp_Ax2

        :rtype: OCC.wrapper.GeomFill.GeomFill_SequenceOfAx2

        """
        return _GeomFill.Handle_GeomFill_HSequenceOfAx2_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_HSequenceOfAx2 self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_HSequenceOfAx2_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_HSequenceOfAx2_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_HSequenceOfAx2_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_HSequenceOfAx2 self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_HSequenceOfAx2_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_HSequenceOfAx2 self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_HSequenceOfAx2 self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_HSequenceOfAx2_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_HSequenceOfAx2 self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_HSequenceOfAx2 self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_HSequenceOfAx2_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_HSequenceOfAx2 self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_HSequenceOfAx2_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_HSequenceOfAx2 self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_HSequenceOfAx2_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_HSequenceOfAx2 self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_HSequenceOfAx2_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_HSequenceOfAx2 self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_HSequenceOfAx2_DecrementRefCounter(self, *args)

Handle_GeomFill_HSequenceOfAx2_swigregister = _GeomFill.Handle_GeomFill_HSequenceOfAx2_swigregister
Handle_GeomFill_HSequenceOfAx2_swigregister(Handle_GeomFill_HSequenceOfAx2)

def Handle_GeomFill_HSequenceOfAx2_DownCast(thing):
    return _GeomFill.Handle_GeomFill_HSequenceOfAx2_DownCast(thing)
Handle_GeomFill_HSequenceOfAx2_DownCast = _GeomFill.Handle_GeomFill_HSequenceOfAx2_DownCast

class GeomFill_CornerState(object):
    """
    Class  (should    be  a  structure)   storing  the
    informations         about     continuity, normals
    parallelism,  coons conditions and bounds tangents
    angle on the corner of contour to be filled.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomFill_CornerState self) -> GeomFill_CornerState

        Class  (should    be  a  structure)   storing  the
        informations         about     continuity, normals
        parallelism,  coons conditions and bounds tangents
        angle on the corner of contour to be filled.
        """
        this = _GeomFill.new_GeomFill_CornerState(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Gap(self, *args):
        """
        Gap(GeomFill_CornerState self) -> Standard_Real
        Gap(GeomFill_CornerState self, Standard_Real const G)

        :type G: float

        """
        return _GeomFill.GeomFill_CornerState_Gap(self, *args)


    def TgtAng(self, *args):
        """
        TgtAng(GeomFill_CornerState self) -> Standard_Real
        TgtAng(GeomFill_CornerState self, Standard_Real const Ang)

        :type Ang: float

        """
        return _GeomFill.GeomFill_CornerState_TgtAng(self, *args)


    def HasConstraint(self, *args):
        """
        HasConstraint(GeomFill_CornerState self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_CornerState_HasConstraint(self, *args)


    def Constraint(self, *args):
        """Constraint(GeomFill_CornerState self)"""
        return _GeomFill.GeomFill_CornerState_Constraint(self, *args)


    def NorAng(self, *args):
        """
        NorAng(GeomFill_CornerState self) -> Standard_Real
        NorAng(GeomFill_CornerState self, Standard_Real const Ang)

        :type Ang: float

        """
        return _GeomFill.GeomFill_CornerState_NorAng(self, *args)


    def IsToKill(self, *args):
        """
        IsToKill(GeomFill_CornerState self) -> Standard_Boolean

        :type Scal: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_CornerState_IsToKill(self, *args)


    def DoKill(self, *args):
        """
        DoKill(GeomFill_CornerState self, Standard_Real const Scal)

        :type Scal: float

        """
        return _GeomFill.GeomFill_CornerState_DoKill(self, *args)

    __swig_destroy__ = _GeomFill.delete_GeomFill_CornerState
GeomFill_CornerState_swigregister = _GeomFill.GeomFill_CornerState_swigregister
GeomFill_CornerState_swigregister(GeomFill_CornerState)

class GeomFill_Tensor(object):
    """used to store the "gradient of gradient" """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomFill_Tensor self, Standard_Integer const NbRow, Standard_Integer const NbCol, Standard_Integer const NbMat) -> GeomFill_Tensor

        :type NbRow: int
        :type NbCol: int
        :type NbMat: int

        """
        this = _GeomFill.new_GeomFill_Tensor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(GeomFill_Tensor self, Standard_Real const InitialValue)

        Initialize all the elements of a Tensor to InitialValue.

        :type InitialValue: float

        """
        return _GeomFill.GeomFill_Tensor_Init(self, *args)


    def Value(self, *args):
        """
        Value(GeomFill_Tensor self, Standard_Integer const Row, Standard_Integer const Col, Standard_Integer const Mat) -> Standard_Real const &

        accesses (in read or write mode) the value of index <Row>,
        <Col> and <Mat> of a Tensor.
        An exception is raised if <Row>, <Col> or <Mat> are not
        in the correct range.

        :type Row: int
        :type Col: int
        :type Mat: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_Tensor_Value(self, *args)


    def ChangeValue(self, *args):
        """
        ChangeValue(GeomFill_Tensor self, Standard_Integer const Row, Standard_Integer const Col, Standard_Integer const Mat) -> Standard_Real &

        accesses (in read or write mode) the value of index <Row>,
        <Col> and <Mat> of a Tensor.
        An exception is raised if <Row>, <Col> or <Mat> are not
        in the correct range.

        :type Row: int
        :type Col: int
        :type Mat: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_Tensor_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        __call__(GeomFill_Tensor self, Standard_Integer const Row, Standard_Integer const Col, Standard_Integer const Mat) -> Standard_Real const
        __call__(GeomFill_Tensor self, Standard_Integer const Row, Standard_Integer const Col, Standard_Integer const Mat) -> Standard_Real &

        :type Row: int
        :type Col: int
        :type Mat: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_Tensor___call__(self, *args)


    def Multiply(self, *args):
        """
        Multiply(GeomFill_Tensor self, math_Vector Right, math_Matrix Product)

        :type Right: OCC.wrapper.math.math_Vector
        :type Product: OCC.wrapper.math.math_Matrix

        """
        return _GeomFill.GeomFill_Tensor_Multiply(self, *args)

    __swig_destroy__ = _GeomFill.delete_GeomFill_Tensor
GeomFill_Tensor_swigregister = _GeomFill.GeomFill_Tensor_swigregister
GeomFill_Tensor_swigregister(GeomFill_Tensor)

class GeomFill_Stretch(GeomFill_Filling):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomFill_Stretch self) -> GeomFill_Stretch
        __init__(GeomFill_Stretch self, NCollection_Array1_gp_Pnt P1, NCollection_Array1_gp_Pnt P2, NCollection_Array1_gp_Pnt P3, NCollection_Array1_gp_Pnt P4) -> GeomFill_Stretch
        __init__(GeomFill_Stretch self, NCollection_Array1_gp_Pnt P1, NCollection_Array1_gp_Pnt P2, NCollection_Array1_gp_Pnt P3, NCollection_Array1_gp_Pnt P4, NCollection_Array1_Standard_Real W1, NCollection_Array1_Standard_Real W2, NCollection_Array1_Standard_Real W3, NCollection_Array1_Standard_Real W4) -> GeomFill_Stretch

        :type P1: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type P2: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type P3: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type P4: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type W1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type W2: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type W3: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type W4: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        this = _GeomFill.new_GeomFill_Stretch(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(GeomFill_Stretch self, NCollection_Array1_gp_Pnt P1, NCollection_Array1_gp_Pnt P2, NCollection_Array1_gp_Pnt P3, NCollection_Array1_gp_Pnt P4)
        Init(GeomFill_Stretch self, NCollection_Array1_gp_Pnt P1, NCollection_Array1_gp_Pnt P2, NCollection_Array1_gp_Pnt P3, NCollection_Array1_gp_Pnt P4, NCollection_Array1_Standard_Real W1, NCollection_Array1_Standard_Real W2, NCollection_Array1_Standard_Real W3, NCollection_Array1_Standard_Real W4)

        :type P1: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type P2: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type P3: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type P4: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type W1: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type W2: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type W3: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type W4: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.GeomFill_Stretch_Init(self, *args)

    __swig_destroy__ = _GeomFill.delete_GeomFill_Stretch
GeomFill_Stretch_swigregister = _GeomFill.GeomFill_Stretch_swigregister
GeomFill_Stretch_swigregister(GeomFill_Stretch)

class GeomFill_Sweep(object):
    """Geometrical Sweep Algorithm"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomFill_Sweep self, Handle_GeomFill_LocationLaw Location, Standard_Boolean const WithKpart) -> GeomFill_Sweep

        :type Location: OCC.wrapper.GeomFill.Handle_GeomFill_LocationLaw
        :type WithKpart: bool

        """
        this = _GeomFill.new_GeomFill_Sweep(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetDomain(self, *args):
        """
        SetDomain(GeomFill_Sweep self, Standard_Real const First, Standard_Real const Last, Standard_Real const SectionFirst, Standard_Real const SectionLast)

        Set parametric information
        [<First>, <Last>] Sets the parametric bound of the
        sweeping surface to build.
        <SectionFirst>, <SectionLast> gives coresponding
        bounds parameter on the section law of <First> and <Last>

        V-Iso on Sweeping Surface S(u,v) is defined by
        Location(v) and Section(w) where
        w = SectionFirst + (v - First) / (Last-First)
        * (SectionLast - SectionFirst)

        By default w = v, and First and Last are given by
        First and Last parameter stored in LocationLaw.

        :type First: float
        :type Last: float
        :type SectionFirst: float
        :type SectionLast: float

        """
        return _GeomFill.GeomFill_Sweep_SetDomain(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(GeomFill_Sweep self, Standard_Real const Tol3d, Standard_Real const BoundTol=1.0, Standard_Real const Tol2d=1.0e-5, Standard_Real const TolAngular=1.0)

        Set Approximation Tolerance
        Tol3d : Tolerance to surface approximation
        Tol2d : Tolerance used to perform curve approximation
        Normaly the 2d curve are approximated with a
        tolerance given by the resolution method define in
        <LocationLaw> but if this tolerance is too large Tol2d
        is used.
        TolAngular : Tolerance (in radian) to control the angle
        beetween tangents on the section law and
        tangent of iso-v on approximed surface

        :type Tol3d: float
        :type BoundTol: float
        :type Tol2d: float
        :type TolAngular: float

        """
        return _GeomFill.GeomFill_Sweep_SetTolerance(self, *args)


    def SetForceApproxC1(self, *args):
        """
        SetForceApproxC1(GeomFill_Sweep self, Standard_Boolean const ForceApproxC1)

        Set the flag that indicates attempt to approximate
        a C1-continuous surface if a swept surface proved
        to be C0.

        :type ForceApproxC1: bool

        """
        return _GeomFill.GeomFill_Sweep_SetForceApproxC1(self, *args)


    def ExchangeUV(self, *args):
        """
        ExchangeUV(GeomFill_Sweep self) -> Standard_Boolean

        returns true if sections are U-Iso
        This can be produce in some cases when <WithKpart> is True.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_Sweep_ExchangeUV(self, *args)


    def UReversed(self, *args):
        """
        UReversed(GeomFill_Sweep self) -> Standard_Boolean

        returns true if Parametrisation sens in U is inverse of
        parametrisation sens of section (or of path if ExchangeUV)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_Sweep_UReversed(self, *args)


    def VReversed(self, *args):
        """
        VReversed(GeomFill_Sweep self) -> Standard_Boolean

        returns true if Parametrisation sens in V is inverse of
        parametrisation sens of path (or of section if ExchangeUV)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_Sweep_VReversed(self, *args)


    def Build(self, *args):
        """
        Build(GeomFill_Sweep self, Handle_GeomFill_SectionLaw Section, GeomFill_ApproxStyle const Methode=GeomFill_Location, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Integer const Degmax=10, Standard_Integer const Segmax=30)

        Build the Sweeep  Surface
        ApproxStyle defines Approximation Strategy
        - GeomFill_Section : The composed Function : Location X Section
        is directly approximed.
        - GeomFill_Location : The location law is approximed, and the
        SweepSurface is build algebric composition
        of approximed location law and section law
        This option is Ok, if Section.Surface() methode
        is effective.
        Continuity : The continuity in v waiting on the surface
        Degmax     : The maximum degree in v requiered on the surface
        Segmax     : The maximum number of span in v requiered on
        the surface

        raise If Domain are infinite or Profile not Setted.

        :type Section: OCC.wrapper.GeomFill.Handle_GeomFill_SectionLaw
        :type Methode: OCC.wrapper.GeomFill.GeomFill_ApproxStyle
        :type Continuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type Degmax: int
        :type Segmax: int

        """
        return _GeomFill.GeomFill_Sweep_Build(self, *args)


    def IsDone(self, *args):
        """
        IsDone(GeomFill_Sweep self) -> Standard_Boolean

        Tells if the Surface is Buildt.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.GeomFill_Sweep_IsDone(self, *args)


    def ErrorOnSurface(self, *args):
        """
        ErrorOnSurface(GeomFill_Sweep self) -> Standard_Real

        Gets the Approximation  error.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.GeomFill_Sweep_ErrorOnSurface(self, *args)


    def ErrorOnRestriction(self, *args):
        """
        ErrorOnRestriction(GeomFill_Sweep self, Standard_Boolean const IsFirst)

        Gets the Approximation  error.

        :type IsFirst: bool
        :type UError: float
        :type VError: float

        """
        return _GeomFill.GeomFill_Sweep_ErrorOnRestriction(self, *args)


    def ErrorOnTrace(self, *args):
        """
        ErrorOnTrace(GeomFill_Sweep self, Standard_Integer const IndexOfTrace)

        Gets the Approximation error.

        :type IndexOfTrace: int
        :type UError: float
        :type VError: float

        """
        return _GeomFill.GeomFill_Sweep_ErrorOnTrace(self, *args)


    def Surface(self, *args):
        """
        Surface(GeomFill_Sweep self) -> Handle_Geom_Surface

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _GeomFill.GeomFill_Sweep_Surface(self, *args)


    def Restriction(self, *args):
        """
        Restriction(GeomFill_Sweep self, Standard_Boolean const IsFirst) -> Handle_Geom2d_Curve

        :type IsFirst: bool
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _GeomFill.GeomFill_Sweep_Restriction(self, *args)


    def NumberOfTrace(self, *args):
        """
        NumberOfTrace(GeomFill_Sweep self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.GeomFill_Sweep_NumberOfTrace(self, *args)


    def Trace(self, *args):
        """
        Trace(GeomFill_Sweep self, Standard_Integer const IndexOfTrace) -> Handle_Geom2d_Curve

        :type IndexOfTrace: int
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _GeomFill.GeomFill_Sweep_Trace(self, *args)

    __swig_destroy__ = _GeomFill.delete_GeomFill_Sweep
GeomFill_Sweep_swigregister = _GeomFill.GeomFill_Sweep_swigregister
GeomFill_Sweep_swigregister(GeomFill_Sweep)

class Handle_GeomFill_HArray1OfSectionLaw(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_HArray1OfSectionLaw self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_HArray1OfSectionLaw_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_HArray1OfSectionLaw self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_HArray1OfSectionLaw_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_HArray1OfSectionLaw self, GeomFill_HArray1OfSectionLaw thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_HArray1OfSectionLaw_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_HArray1OfSectionLaw self, Handle_GeomFill_HArray1OfSectionLaw theHandle) -> Handle_GeomFill_HArray1OfSectionLaw
        assign(Handle_GeomFill_HArray1OfSectionLaw self, GeomFill_HArray1OfSectionLaw thePtr) -> Handle_GeomFill_HArray1OfSectionLaw
        assign(Handle_GeomFill_HArray1OfSectionLaw self, Handle_GeomFill_HArray1OfSectionLaw theHandle) -> Handle_GeomFill_HArray1OfSectionLaw

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_HArray1OfSectionLaw_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_HArray1OfSectionLaw self) -> GeomFill_HArray1OfSectionLaw

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_HArray1OfSectionLaw_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_HArray1OfSectionLaw self) -> GeomFill_HArray1OfSectionLaw

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_HArray1OfSectionLaw___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_HArray1OfSectionLaw self) -> GeomFill_HArray1OfSectionLaw

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_HArray1OfSectionLaw___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_HArray1OfSectionLaw___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_HArray1OfSectionLaw___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_HArray1OfSectionLaw(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_HArray1OfSectionLaw_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_HArray1OfSectionLaw

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.GeomFill.GeomFill_Array1OfSectionLaw

        """
        res = _GeomFill.Handle_GeomFill_HArray1OfSectionLaw_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_GeomFill_HArray1OfSectionLaw self) -> NCollection_Array1_Handle_GeomFill_SectionLaw

        :rtype: OCC.wrapper.GeomFill.GeomFill_Array1OfSectionLaw

        """
        return _GeomFill.Handle_GeomFill_HArray1OfSectionLaw_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_HArray1OfSectionLaw self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_HArray1OfSectionLaw_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_HArray1OfSectionLaw_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_HArray1OfSectionLaw_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_HArray1OfSectionLaw self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_HArray1OfSectionLaw_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_HArray1OfSectionLaw self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_HArray1OfSectionLaw self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_HArray1OfSectionLaw_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_HArray1OfSectionLaw self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_HArray1OfSectionLaw self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_HArray1OfSectionLaw_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_HArray1OfSectionLaw self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_HArray1OfSectionLaw_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_HArray1OfSectionLaw self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_HArray1OfSectionLaw_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_HArray1OfSectionLaw self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_HArray1OfSectionLaw_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_HArray1OfSectionLaw self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_HArray1OfSectionLaw_DecrementRefCounter(self, *args)

Handle_GeomFill_HArray1OfSectionLaw_swigregister = _GeomFill.Handle_GeomFill_HArray1OfSectionLaw_swigregister
Handle_GeomFill_HArray1OfSectionLaw_swigregister(Handle_GeomFill_HArray1OfSectionLaw)

def Handle_GeomFill_HArray1OfSectionLaw_DownCast(thing):
    return _GeomFill.Handle_GeomFill_HArray1OfSectionLaw_DownCast(thing)
Handle_GeomFill_HArray1OfSectionLaw_DownCast = _GeomFill.Handle_GeomFill_HArray1OfSectionLaw_DownCast

class Handle_GeomFill_DegeneratedBound(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_DegeneratedBound self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_DegeneratedBound_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_DegeneratedBound self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_DegeneratedBound_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_DegeneratedBound self, GeomFill_DegeneratedBound thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_DegeneratedBound_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_DegeneratedBound self, Handle_GeomFill_DegeneratedBound theHandle) -> Handle_GeomFill_DegeneratedBound
        assign(Handle_GeomFill_DegeneratedBound self, GeomFill_DegeneratedBound thePtr) -> Handle_GeomFill_DegeneratedBound
        assign(Handle_GeomFill_DegeneratedBound self, Handle_GeomFill_DegeneratedBound theHandle) -> Handle_GeomFill_DegeneratedBound

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_DegeneratedBound_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_DegeneratedBound self) -> GeomFill_DegeneratedBound

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_DegeneratedBound_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_DegeneratedBound self) -> GeomFill_DegeneratedBound

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_DegeneratedBound___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_DegeneratedBound self) -> GeomFill_DegeneratedBound

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_DegeneratedBound___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_DegeneratedBound___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_DegeneratedBound___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_DegeneratedBound(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_DegeneratedBound_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_DegeneratedBound

    def Value(self, *args):
        """
        Value(Handle_GeomFill_DegeneratedBound self, Standard_Real const U) -> gp_Pnt

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.Handle_GeomFill_DegeneratedBound_Value(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_DegeneratedBound self, Standard_Real const U, gp_Pnt P, gp_Vec V)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_DegeneratedBound_D1(self, *args)


    def Reparametrize(self, *args):
        """
        Reparametrize(Handle_GeomFill_DegeneratedBound self, Standard_Real const First, Standard_Real const Last, Standard_Boolean const HasDF, Standard_Boolean const HasDL, Standard_Real const DF, Standard_Real const DL, Standard_Boolean const Rev)

        :type First: float
        :type Last: float
        :type HasDF: bool
        :type HasDL: bool
        :type DF: float
        :type DL: float
        :type Rev: bool

        """
        return _GeomFill.Handle_GeomFill_DegeneratedBound_Reparametrize(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_GeomFill_DegeneratedBound self)

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_DegeneratedBound_Bounds(self, *args)


    def IsDegenerated(self, *args):
        """
        IsDegenerated(Handle_GeomFill_DegeneratedBound self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_DegeneratedBound_IsDegenerated(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_DegeneratedBound self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_DegeneratedBound_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_DegeneratedBound_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_DegeneratedBound_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasNormals(self, *args):
        """
        HasNormals(Handle_GeomFill_DegeneratedBound self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_DegeneratedBound_HasNormals(self, *args)


    def Norm(self, *args):
        """
        Norm(Handle_GeomFill_DegeneratedBound self, Standard_Real const U) -> gp_Vec

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_DegeneratedBound_Norm(self, *args)


    def D1Norm(self, *args):
        """
        D1Norm(Handle_GeomFill_DegeneratedBound self, Standard_Real const U, gp_Vec N, gp_Vec DN)

        :type U: float
        :type N: OCC.wrapper.gp.gp_Vec
        :type DN: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_DegeneratedBound_D1Norm(self, *args)


    def Points(self, *args):
        """
        Points(Handle_GeomFill_DegeneratedBound self, gp_Pnt PFirst, gp_Pnt PLast)

        :type PFirst: OCC.wrapper.gp.gp_Pnt
        :type PLast: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.Handle_GeomFill_DegeneratedBound_Points(self, *args)


    def Tol3d(self, *args):
        """
        Tol3d(Handle_GeomFill_DegeneratedBound self) -> Standard_Real
        Tol3d(Handle_GeomFill_DegeneratedBound self, Standard_Real const Tol)

        :type Tol: float

        """
        return _GeomFill.Handle_GeomFill_DegeneratedBound_Tol3d(self, *args)


    def Tolang(self, *args):
        """
        Tolang(Handle_GeomFill_DegeneratedBound self) -> Standard_Real
        Tolang(Handle_GeomFill_DegeneratedBound self, Standard_Real const Tol)

        :type Tol: float

        """
        return _GeomFill.Handle_GeomFill_DegeneratedBound_Tolang(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_DegeneratedBound self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_DegeneratedBound_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_DegeneratedBound self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_DegeneratedBound self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_DegeneratedBound_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_DegeneratedBound self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_DegeneratedBound self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_DegeneratedBound_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_DegeneratedBound self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_DegeneratedBound_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_DegeneratedBound self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_DegeneratedBound_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_DegeneratedBound self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_DegeneratedBound_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_DegeneratedBound self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_DegeneratedBound_DecrementRefCounter(self, *args)

Handle_GeomFill_DegeneratedBound_swigregister = _GeomFill.Handle_GeomFill_DegeneratedBound_swigregister
Handle_GeomFill_DegeneratedBound_swigregister(Handle_GeomFill_DegeneratedBound)

def Handle_GeomFill_DegeneratedBound_DownCast(thing):
    return _GeomFill.Handle_GeomFill_DegeneratedBound_DownCast(thing)
Handle_GeomFill_DegeneratedBound_DownCast = _GeomFill.Handle_GeomFill_DegeneratedBound_DownCast

class Handle_GeomFill_SweepFunction(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_SweepFunction self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_SweepFunction_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_SweepFunction self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_SweepFunction self, GeomFill_SweepFunction thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_SweepFunction self, Handle_GeomFill_SweepFunction theHandle) -> Handle_GeomFill_SweepFunction
        assign(Handle_GeomFill_SweepFunction self, GeomFill_SweepFunction thePtr) -> Handle_GeomFill_SweepFunction
        assign(Handle_GeomFill_SweepFunction self, Handle_GeomFill_SweepFunction theHandle) -> Handle_GeomFill_SweepFunction

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_SweepFunction self) -> GeomFill_SweepFunction

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_SweepFunction self) -> GeomFill_SweepFunction

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_SweepFunction___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_SweepFunction self) -> GeomFill_SweepFunction

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_SweepFunction___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_SweepFunction___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_SweepFunction___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_SweepFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_SweepFunction_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_SweepFunction

    def D0(self, *args):
        """
        D0(Handle_GeomFill_SweepFunction self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_Standard_Real Weigths) -> Standard_Boolean

        compute the section for v = param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_SweepFunction self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths) -> Standard_Boolean

        compute the first  derivative in v direction  of the
        section for v =  param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_GeomFill_SweepFunction self, Standard_Real const Param, Standard_Real const First, Standard_Real const Last, NCollection_Array1_gp_Pnt Poles, NCollection_Array1_gp_Vec DPoles, NCollection_Array1_gp_Vec D2Poles, NCollection_Array1_gp_Pnt2d Poles2d, NCollection_Array1_gp_Vec2d DPoles2d, NCollection_Array1_gp_Vec2d D2Poles2d, NCollection_Array1_Standard_Real Weigths, NCollection_Array1_Standard_Real DWeigths, NCollection_Array1_Standard_Real D2Weigths) -> Standard_Boolean

        compute the second derivative  in v direction of the
        section  for v = param

        :type Param: float
        :type First: float
        :type Last: float
        :type Poles: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type DPoles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type D2Poles: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type DPoles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type D2Poles2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type DWeigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type D2Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_D2(self, *args)


    def Nb2dCurves(self, *args):
        """
        Nb2dCurves(Handle_GeomFill_SweepFunction self) -> Standard_Integer

        get the number of 2d curves to  approximate.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_Nb2dCurves(self, *args)


    def SectionShape(self, *args):
        """
        SectionShape(Handle_GeomFill_SweepFunction self)

        get the format of an  section

        :type NbPoles: int
        :type NbKnots: int
        :type Degree: int

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_SectionShape(self, *args)


    def Knots(self, *args):
        """
        Knots(Handle_GeomFill_SweepFunction self, NCollection_Array1_Standard_Real TKnots)

        get the Knots of the section

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_Knots(self, *args)


    def Mults(self, *args):
        """
        Mults(Handle_GeomFill_SweepFunction self, NCollection_Array1_Standard_Integer TMults)

        get the Multplicities of the section

        :type TMults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_Mults(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Handle_GeomFill_SweepFunction self) -> Standard_Boolean

        Returns if the section is rationnal or not

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_IsRational(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_GeomFill_SweepFunction self, GeomAbs_Shape const S) -> Standard_Integer

        Returns  the number  of  intervals for  continuity
        <S>. May be one if Continuity(me) >= <S>

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_GeomFill_SweepFunction self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_Intervals(self, *args)


    def SetInterval(self, *args):
        """
        SetInterval(Handle_GeomFill_SweepFunction self, Standard_Real const First, Standard_Real const Last)

        Sets the bounds of the parametric interval on
        the function
        This determines the derivatives in these values if the
        function is not Cn.

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_SetInterval(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Handle_GeomFill_SweepFunction self, Standard_Integer const Index, Standard_Real const Tol)

        Returns the resolutions in the  sub-space 2d <Index>
        This information is usfull to find an good tolerance in
        2d approximation.
        Warning: Used only if Nb2dCurve > 0

        :type Index: int
        :type Tol: float
        :type TolU: float
        :type TolV: float

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_Resolution(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(Handle_GeomFill_SweepFunction self, Standard_Real const BoundTol, Standard_Real const SurfTol, Standard_Real const AngleTol, NCollection_Array1_Standard_Real Tol3d)

        Returns the tolerance to reach in approximation
        to respecte
        BoundTol error at the Boundary
        AngleTol tangent error at the Boundary (in radian)
        SurfTol error inside the surface.

        :type BoundTol: float
        :type SurfTol: float
        :type AngleTol: float
        :type Tol3d: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_GetTolerance(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_GeomFill_SweepFunction self, Standard_Real const Tol3d, Standard_Real const Tol2d)

        Is usfull, if (me) have to  be run numerical
        algorithme to perform D0, D1 or D2

        :type Tol3d: float
        :type Tol2d: float

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_SetTolerance(self, *args)


    def BarycentreOfSurf(self, *args):
        """
        BarycentreOfSurf(Handle_GeomFill_SweepFunction self) -> gp_Pnt

        Get    the   barycentre of   Surface.   An   very  poor
        estimation is sufficent. This information is usefull
        to perform well conditionned rational approximation.
        Warning: Used only if <me> IsRational

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_BarycentreOfSurf(self, *args)


    def MaximalSection(self, *args):
        """
        MaximalSection(Handle_GeomFill_SweepFunction self) -> Standard_Real

        Returns the   length of the maximum section. This
        information is usefull to perform well conditionned rational
        approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_MaximalSection(self, *args)


    def GetMinimalWeight(self, *args):
        """
        GetMinimalWeight(Handle_GeomFill_SweepFunction self, NCollection_Array1_Standard_Real Weigths)

        Compute the minimal value of weight for each poles
        of all  sections.  This information is  usefull to
        perform well conditionned rational approximation.
        Warning: Used only if <me> IsRational

        :type Weigths: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_GetMinimalWeight(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_SweepFunction self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_SweepFunction_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_SweepFunction_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_SweepFunction self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_SweepFunction_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_SweepFunction self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_SweepFunction self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_SweepFunction self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_SweepFunction self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_SweepFunction self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_SweepFunction self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_SweepFunction self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_SweepFunction_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_SweepFunction self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_SweepFunction_DecrementRefCounter(self, *args)

Handle_GeomFill_SweepFunction_swigregister = _GeomFill.Handle_GeomFill_SweepFunction_swigregister
Handle_GeomFill_SweepFunction_swigregister(Handle_GeomFill_SweepFunction)

def Handle_GeomFill_SweepFunction_DownCast(thing):
    return _GeomFill.Handle_GeomFill_SweepFunction_DownCast(thing)
Handle_GeomFill_SweepFunction_DownCast = _GeomFill.Handle_GeomFill_SweepFunction_DownCast

class Handle_GeomFill_SimpleBound(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GeomFill_SimpleBound self)

        Nullify the handle


        """
        return _GeomFill.Handle_GeomFill_SimpleBound_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GeomFill_SimpleBound self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GeomFill.Handle_GeomFill_SimpleBound_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GeomFill_SimpleBound self, GeomFill_SimpleBound thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GeomFill.Handle_GeomFill_SimpleBound_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GeomFill_SimpleBound self, Handle_GeomFill_SimpleBound theHandle) -> Handle_GeomFill_SimpleBound
        assign(Handle_GeomFill_SimpleBound self, GeomFill_SimpleBound thePtr) -> Handle_GeomFill_SimpleBound
        assign(Handle_GeomFill_SimpleBound self, Handle_GeomFill_SimpleBound theHandle) -> Handle_GeomFill_SimpleBound

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GeomFill.Handle_GeomFill_SimpleBound_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GeomFill_SimpleBound self) -> GeomFill_SimpleBound

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_SimpleBound_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GeomFill_SimpleBound self) -> GeomFill_SimpleBound

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GeomFill.Handle_GeomFill_SimpleBound___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GeomFill_SimpleBound self) -> GeomFill_SimpleBound

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GeomFill.Handle_GeomFill_SimpleBound___ref__(self, *args)


    def __hash__(self):
        return _GeomFill.Handle_GeomFill_SimpleBound___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GeomFill.Handle_GeomFill_SimpleBound___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GeomFill.new_Handle_GeomFill_SimpleBound(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GeomFill.Handle_GeomFill_SimpleBound_DownCast)
    __swig_destroy__ = _GeomFill.delete_Handle_GeomFill_SimpleBound

    def Value(self, *args):
        """
        Value(Handle_GeomFill_SimpleBound self, Standard_Real const U) -> gp_Pnt

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.Handle_GeomFill_SimpleBound_Value(self, *args)


    def D1(self, *args):
        """
        D1(Handle_GeomFill_SimpleBound self, Standard_Real const U, gp_Pnt P, gp_Vec V)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_SimpleBound_D1(self, *args)


    def Reparametrize(self, *args):
        """
        Reparametrize(Handle_GeomFill_SimpleBound self, Standard_Real const First, Standard_Real const Last, Standard_Boolean const HasDF, Standard_Boolean const HasDL, Standard_Real const DF, Standard_Real const DL, Standard_Boolean const Rev)

        :type First: float
        :type Last: float
        :type HasDF: bool
        :type HasDL: bool
        :type DF: float
        :type DL: float
        :type Rev: bool

        """
        return _GeomFill.Handle_GeomFill_SimpleBound_Reparametrize(self, *args)


    def Bounds(self, *args):
        """
        Bounds(Handle_GeomFill_SimpleBound self)

        :type First: float
        :type Last: float

        """
        return _GeomFill.Handle_GeomFill_SimpleBound_Bounds(self, *args)


    def IsDegenerated(self, *args):
        """
        IsDegenerated(Handle_GeomFill_SimpleBound self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_SimpleBound_IsDegenerated(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GeomFill_SimpleBound self) -> char const *

        :rtype: const char *

        """
        return _GeomFill.Handle_GeomFill_SimpleBound_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_SimpleBound_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GeomFill.Handle_GeomFill_SimpleBound_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasNormals(self, *args):
        """
        HasNormals(Handle_GeomFill_SimpleBound self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_SimpleBound_HasNormals(self, *args)


    def Norm(self, *args):
        """
        Norm(Handle_GeomFill_SimpleBound self, Standard_Real const U) -> gp_Vec

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_SimpleBound_Norm(self, *args)


    def D1Norm(self, *args):
        """
        D1Norm(Handle_GeomFill_SimpleBound self, Standard_Real const U, gp_Vec N, gp_Vec DN)

        :type U: float
        :type N: OCC.wrapper.gp.gp_Vec
        :type DN: OCC.wrapper.gp.gp_Vec

        """
        return _GeomFill.Handle_GeomFill_SimpleBound_D1Norm(self, *args)


    def Points(self, *args):
        """
        Points(Handle_GeomFill_SimpleBound self, gp_Pnt PFirst, gp_Pnt PLast)

        :type PFirst: OCC.wrapper.gp.gp_Pnt
        :type PLast: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomFill.Handle_GeomFill_SimpleBound_Points(self, *args)


    def Tol3d(self, *args):
        """
        Tol3d(Handle_GeomFill_SimpleBound self) -> Standard_Real
        Tol3d(Handle_GeomFill_SimpleBound self, Standard_Real const Tol)

        :type Tol: float

        """
        return _GeomFill.Handle_GeomFill_SimpleBound_Tol3d(self, *args)


    def Tolang(self, *args):
        """
        Tolang(Handle_GeomFill_SimpleBound self) -> Standard_Real
        Tolang(Handle_GeomFill_SimpleBound self, Standard_Real const Tol)

        :type Tol: float

        """
        return _GeomFill.Handle_GeomFill_SimpleBound_Tolang(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GeomFill_SimpleBound self)

        Memory deallocator for transient classes


        """
        return _GeomFill.Handle_GeomFill_SimpleBound_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GeomFill_SimpleBound self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GeomFill_SimpleBound self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_SimpleBound_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GeomFill_SimpleBound self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GeomFill_SimpleBound self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.Handle_GeomFill_SimpleBound_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GeomFill_SimpleBound self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GeomFill.Handle_GeomFill_SimpleBound_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GeomFill_SimpleBound self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_SimpleBound_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GeomFill_SimpleBound self)

        Increments the reference counter of this object


        """
        return _GeomFill.Handle_GeomFill_SimpleBound_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GeomFill_SimpleBound self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.Handle_GeomFill_SimpleBound_DecrementRefCounter(self, *args)

Handle_GeomFill_SimpleBound_swigregister = _GeomFill.Handle_GeomFill_SimpleBound_swigregister
Handle_GeomFill_SimpleBound_swigregister(Handle_GeomFill_SimpleBound)

def Handle_GeomFill_SimpleBound_DownCast(thing):
    return _GeomFill.Handle_GeomFill_SimpleBound_DownCast(thing)
Handle_GeomFill_SimpleBound_DownCast = _GeomFill.Handle_GeomFill_SimpleBound_DownCast

class NCollection_Sequence_gp_Trsf(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_gp_Trsf self) -> NCollection_Sequence< gp_Trsf >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _GeomFill.NCollection_Sequence_gp_Trsf_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_gp_Trsf self) -> NCollection_Sequence< gp_Trsf >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _GeomFill.NCollection_Sequence_gp_Trsf_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_gp_Trsf self) -> NCollection_Sequence< gp_Trsf >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _GeomFill.NCollection_Sequence_gp_Trsf_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_gp_Trsf self) -> NCollection_Sequence< gp_Trsf >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _GeomFill.NCollection_Sequence_gp_Trsf_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _GeomFill.new_NCollection_Sequence_gp_Trsf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_gp_Trsf self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.NCollection_Sequence_gp_Trsf_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_gp_Trsf self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.NCollection_Sequence_gp_Trsf_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_gp_Trsf self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.NCollection_Sequence_gp_Trsf_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_gp_Trsf self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomFill.NCollection_Sequence_gp_Trsf_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_gp_Trsf self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomFill.NCollection_Sequence_gp_Trsf_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_gp_Trsf self)

        Reverse sequence


        """
        return _GeomFill.NCollection_Sequence_gp_Trsf_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_gp_Trsf self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _GeomFill.NCollection_Sequence_gp_Trsf_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _GeomFill.NCollection_Sequence_gp_Trsf_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_gp_Trsf self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _GeomFill.NCollection_Sequence_gp_Trsf_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_gp_Trsf self, NCollection_Sequence_gp_Trsf theOther) -> NCollection_Sequence_gp_Trsf

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _GeomFill.NCollection_Sequence_gp_Trsf_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_gp_Trsf self, NCollection_Sequence_gp_Trsf theOther) -> NCollection_Sequence_gp_Trsf

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _GeomFill.NCollection_Sequence_gp_Trsf_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_gp_Trsf self, NCollection_Sequence< gp_Trsf >::Iterator & thePosition)
        Remove(NCollection_Sequence_gp_Trsf self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_gp_Trsf self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _GeomFill.NCollection_Sequence_gp_Trsf_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_gp_Trsf self, gp_Trsf theItem)
        Append(NCollection_Sequence_gp_Trsf self, NCollection_Sequence_gp_Trsf theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _GeomFill.NCollection_Sequence_gp_Trsf_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_gp_Trsf self, gp_Trsf theItem)
        Prepend(NCollection_Sequence_gp_Trsf self, NCollection_Sequence_gp_Trsf theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _GeomFill.NCollection_Sequence_gp_Trsf_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_gp_Trsf self, Standard_Integer const theIndex, gp_Trsf theItem)
        InsertBefore(NCollection_Sequence_gp_Trsf self, Standard_Integer const theIndex, NCollection_Sequence_gp_Trsf theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _GeomFill.NCollection_Sequence_gp_Trsf_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_gp_Trsf self, NCollection_Sequence< gp_Trsf >::Iterator & thePosition, gp_Trsf theItem)
        InsertAfter(NCollection_Sequence_gp_Trsf self, Standard_Integer const theIndex, NCollection_Sequence_gp_Trsf theSeq)
        InsertAfter(NCollection_Sequence_gp_Trsf self, Standard_Integer const theIndex, gp_Trsf theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _GeomFill.NCollection_Sequence_gp_Trsf_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_gp_Trsf self, Standard_Integer const theIndex, NCollection_Sequence_gp_Trsf theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _GeomFill.NCollection_Sequence_gp_Trsf_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _GeomFill.NCollection_Sequence_gp_Trsf_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_gp_Trsf self) -> gp_Trsf

        First item access

        :rtype: TheItemType &

        """
        return _GeomFill.NCollection_Sequence_gp_Trsf_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _GeomFill.NCollection_Sequence_gp_Trsf_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_gp_Trsf self) -> gp_Trsf

        Last item access

        :rtype: TheItemType &

        """
        return _GeomFill.NCollection_Sequence_gp_Trsf_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GeomFill.NCollection_Sequence_gp_Trsf_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_gp_Trsf self, Standard_Integer const theIndex) -> gp_Trsf

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _GeomFill.NCollection_Sequence_gp_Trsf_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _GeomFill.NCollection_Sequence_gp_Trsf___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_gp_Trsf self, Standard_Integer const theIndex, gp_Trsf theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _GeomFill.NCollection_Sequence_gp_Trsf_SetValue(self, *args)


    def __iter__(self):
        return _GeomFill.NCollection_Sequence_gp_Trsf___iter__(self)
    __swig_destroy__ = _GeomFill.delete_NCollection_Sequence_gp_Trsf
NCollection_Sequence_gp_Trsf_swigregister = _GeomFill.NCollection_Sequence_gp_Trsf_swigregister
NCollection_Sequence_gp_Trsf_swigregister(NCollection_Sequence_gp_Trsf)

def NCollection_Sequence_gp_Trsf_delNode(*args):
    """
    NCollection_Sequence_gp_Trsf_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _GeomFill.NCollection_Sequence_gp_Trsf_delNode(*args)

class NCollection_Sequence_gp_Trsf_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _GeomFill.new_NCollection_Sequence_gp_Trsf_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GeomFill.delete_NCollection_Sequence_gp_Trsf_IteratorHelper

    def __next__(self):
        return _GeomFill.NCollection_Sequence_gp_Trsf_IteratorHelper___next__(self)
NCollection_Sequence_gp_Trsf_IteratorHelper_swigregister = _GeomFill.NCollection_Sequence_gp_Trsf_IteratorHelper_swigregister
NCollection_Sequence_gp_Trsf_IteratorHelper_swigregister(NCollection_Sequence_gp_Trsf_IteratorHelper)


try:
	GeomFill_SequenceOfTrsf = NCollection_Sequence_gp_Trsf
except NameError:
	pass # does not exist, probably ignored




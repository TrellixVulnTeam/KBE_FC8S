# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_AppDef')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_AppDef')
    _AppDef = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_AppDef', [dirname(__file__)])
        except ImportError:
            import _AppDef
            return _AppDef
        try:
            _mod = imp.load_module('_AppDef', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _AppDef = swig_import_helper()
    del swig_import_helper
else:
    import _AppDef
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _AppDef.delete_SwigPyIterator

    def value(self):
        return _AppDef.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _AppDef.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _AppDef.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _AppDef.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _AppDef.SwigPyIterator_equal(self, x)

    def copy(self):
        return _AppDef.SwigPyIterator_copy(self)

    def next(self):
        return _AppDef.SwigPyIterator_next(self)

    def __next__(self):
        return _AppDef.SwigPyIterator___next__(self)

    def previous(self):
        return _AppDef.SwigPyIterator_previous(self)

    def advance(self, n):
        return _AppDef.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _AppDef.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _AppDef.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _AppDef.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _AppDef.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _AppDef.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _AppDef.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _AppDef.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _AppDef.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_AppDef.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _AppDef.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _AppDef.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _AppDef.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _AppDef.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _AppDef.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _AppDef.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _AppDef.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_AppDef.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _AppDef.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _AppDef.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _AppDef.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _AppDef.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _AppDef.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _AppDef.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _AppDef.ptr_to_number(item)
ptr_to_number = _AppDef.ptr_to_number

def HashCode(*args):
    return _AppDef.HashCode(*args)
HashCode = _AppDef.HashCode

def ptr_equal(a, b):
    return _AppDef.ptr_equal(a, b)
ptr_equal = _AppDef.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import FEmTool
else:
    import FEmTool
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PLib
else:
    import PLib
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Approx
else:
    import Approx
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppCont
else:
    import AppCont
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppParCurves
else:
    import AppParCurves
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AdvApprox
else:
    import AdvApprox
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
class AppDef_HArray1OfMultiPointConstraint(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AppDef_HArray1OfMultiPointConstraint
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AppDef_HArray1OfMultiPointConstraint(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AppDef_HArray1OfMultiPointConstraint self, Standard_Integer const theLower, Standard_Integer const theUpper) -> AppDef_HArray1OfMultiPointConstraint
        __init__(AppDef_HArray1OfMultiPointConstraint self, Standard_Integer const theLower, Standard_Integer const theUpper, AppDef_MultiPointConstraint theValue) -> AppDef_HArray1OfMultiPointConstraint
        __init__(AppDef_HArray1OfMultiPointConstraint self, NCollection_Array1_AppDef_MultiPointConstraint theOther) -> AppDef_HArray1OfMultiPointConstraint

        :type theOther: OCC.wrapper.AppDef.AppDef_Array1OfMultiPointConstraint

        """
        this = _AppDef.new_AppDef_HArray1OfMultiPointConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.AppDef.AppDef_Array1OfMultiPointConstraint

        """
        res = _AppDef.AppDef_HArray1OfMultiPointConstraint_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(AppDef_HArray1OfMultiPointConstraint self) -> NCollection_Array1_AppDef_MultiPointConstraint

        :rtype: OCC.wrapper.AppDef.AppDef_Array1OfMultiPointConstraint

        """
        return _AppDef.AppDef_HArray1OfMultiPointConstraint_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AppDef.AppDef_HArray1OfMultiPointConstraint_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AppDef.AppDef_HArray1OfMultiPointConstraint_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AppDef.AppDef_HArray1OfMultiPointConstraint_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AppDef.delete_AppDef_HArray1OfMultiPointConstraint
AppDef_HArray1OfMultiPointConstraint_swigregister = _AppDef.AppDef_HArray1OfMultiPointConstraint_swigregister
AppDef_HArray1OfMultiPointConstraint_swigregister(AppDef_HArray1OfMultiPointConstraint)

def AppDef_HArray1OfMultiPointConstraint_get_type_name(*args):
    """
    AppDef_HArray1OfMultiPointConstraint_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AppDef.AppDef_HArray1OfMultiPointConstraint_get_type_name(*args)

def AppDef_HArray1OfMultiPointConstraint_get_type_descriptor(*args):
    """
    AppDef_HArray1OfMultiPointConstraint_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AppDef.AppDef_HArray1OfMultiPointConstraint_get_type_descriptor(*args)

class AppDef_SmoothCriterion(Standard.Standard_Transient):
    """defined criterion to smooth  points in  curve"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AppDef_SmoothCriterion
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AppDef_SmoothCriterion(self) 
            return h


    def SetParameters(self, *args):
        """
        SetParameters(AppDef_SmoothCriterion self, Handle_TColStd_HArray1OfReal Parameters)

        :type Parameters: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _AppDef.AppDef_SmoothCriterion_SetParameters(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(AppDef_SmoothCriterion self, Handle_FEmTool_Curve C)

        :type C: OCC.wrapper.FEmTool.Handle_FEmTool_Curve

        """
        return _AppDef.AppDef_SmoothCriterion_SetCurve(self, *args)


    def GetCurve(self, *args):
        """
        GetCurve(AppDef_SmoothCriterion self, Handle_FEmTool_Curve C)

        :type C: OCC.wrapper.FEmTool.Handle_FEmTool_Curve

        """
        return _AppDef.AppDef_SmoothCriterion_GetCurve(self, *args)


    def SetEstimation(self, *args):
        """
        SetEstimation(AppDef_SmoothCriterion self, Standard_Real const E1, Standard_Real const E2, Standard_Real const E3)

        :type E1: float
        :type E2: float
        :type E3: float

        """
        return _AppDef.AppDef_SmoothCriterion_SetEstimation(self, *args)


    def EstLength(self, *args):
        """
        EstLength(AppDef_SmoothCriterion self) -> Standard_Real &

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_SmoothCriterion_EstLength(self, *args)


    def GetEstimation(self, *args):
        """
        GetEstimation(AppDef_SmoothCriterion self)

        :type E1: float
        :type E2: float
        :type E3: float

        """
        return _AppDef.AppDef_SmoothCriterion_GetEstimation(self, *args)


    def AssemblyTable(self, *args):
        """
        AssemblyTable(AppDef_SmoothCriterion self) -> Handle_FEmTool_HAssemblyTable

        :rtype: OCC.wrapper.FEmTool.Handle_FEmTool_HAssemblyTable

        """
        return _AppDef.AppDef_SmoothCriterion_AssemblyTable(self, *args)


    def DependenceTable(self, *args):
        """
        DependenceTable(AppDef_SmoothCriterion self) -> Handle_TColStd_HArray2OfInteger

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray2OfInteger

        """
        return _AppDef.AppDef_SmoothCriterion_DependenceTable(self, *args)


    def QualityValues(self, *args):
        """
        QualityValues(AppDef_SmoothCriterion self, Standard_Real const J1min, Standard_Real const J2min, Standard_Real const J3min) -> Standard_Integer

        :type J1min: float
        :type J2min: float
        :type J3min: float
        :type J1: float
        :type J2: float
        :type J3: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.AppDef_SmoothCriterion_QualityValues(self, *args)


    def ErrorValues(self, *args):
        """
        ErrorValues(AppDef_SmoothCriterion self)

        :type MaxError: float
        :type QuadraticError: float
        :type AverageError: float

        """
        return _AppDef.AppDef_SmoothCriterion_ErrorValues(self, *args)


    def Hessian(self, *args):
        """
        Hessian(AppDef_SmoothCriterion self, Standard_Integer const Element, Standard_Integer const Dimension1, Standard_Integer const Dimension2, math_Matrix H)

        :type Element: int
        :type Dimension1: int
        :type Dimension2: int
        :type H: OCC.wrapper.math.math_Matrix

        """
        return _AppDef.AppDef_SmoothCriterion_Hessian(self, *args)


    def Gradient(self, *args):
        """
        Gradient(AppDef_SmoothCriterion self, Standard_Integer const Element, Standard_Integer const Dimension, math_Vector G)

        :type Element: int
        :type Dimension: int
        :type G: OCC.wrapper.math.math_Vector

        """
        return _AppDef.AppDef_SmoothCriterion_Gradient(self, *args)


    def InputVector(self, *args):
        """
        InputVector(AppDef_SmoothCriterion self, math_Vector X, Handle_FEmTool_HAssemblyTable AssTable)

        Convert the assembly Vector in an Curve;

        :type X: OCC.wrapper.math.math_Vector
        :type AssTable: OCC.wrapper.FEmTool.Handle_FEmTool_HAssemblyTable

        """
        return _AppDef.AppDef_SmoothCriterion_InputVector(self, *args)


    def GetWeight(self, *args):
        """
        GetWeight(AppDef_SmoothCriterion self)

        :type QuadraticWeight: float
        :type QualityWeight: float

        """
        return _AppDef.AppDef_SmoothCriterion_GetWeight(self, *args)


    def SetWeight(self, *args):
        """
        SetWeight(AppDef_SmoothCriterion self, Standard_Real const QuadraticWeight, Standard_Real const QualityWeight, Standard_Real const percentJ1, Standard_Real const percentJ2, Standard_Real const percentJ3)
        SetWeight(AppDef_SmoothCriterion self, NCollection_Array1_Standard_Real Weight)

        :type Weight: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _AppDef.AppDef_SmoothCriterion_SetWeight(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AppDef.AppDef_SmoothCriterion_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AppDef.AppDef_SmoothCriterion_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AppDef.AppDef_SmoothCriterion_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AppDef.delete_AppDef_SmoothCriterion
AppDef_SmoothCriterion_swigregister = _AppDef.AppDef_SmoothCriterion_swigregister
AppDef_SmoothCriterion_swigregister(AppDef_SmoothCriterion)

def AppDef_SmoothCriterion_get_type_name(*args):
    """
    AppDef_SmoothCriterion_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AppDef.AppDef_SmoothCriterion_get_type_name(*args)

def AppDef_SmoothCriterion_get_type_descriptor(*args):
    """
    AppDef_SmoothCriterion_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AppDef.AppDef_SmoothCriterion_get_type_descriptor(*args)

class AppDef_MultiPointConstraint(AppParCurves.AppParCurves_MultiPoint):
    """
    Describes a MultiPointConstraint used in a
    Multiline. MultiPointConstraints are composed
    of several two or three-dimensional points.
    The purpose is to define the corresponding
    points that share a common constraint in order
    to compute the approximation of several lines in parallel.
    Notes:
    -   The order of points of a MultiPointConstraints is very important.
    Users must give 3D points first, and then 2D points.
    -   The constraints for the points included in a
    MultiPointConstraint are always identical for
    all points, including the parameter.
    -   If a MultiPointConstraint is a "tangency"
    point, the point is also a "passing" point.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_MultiPointConstraint self) -> AppDef_MultiPointConstraint
        __init__(AppDef_MultiPointConstraint self, Standard_Integer const NbPoints, Standard_Integer const NbPoints2d) -> AppDef_MultiPointConstraint
        __init__(AppDef_MultiPointConstraint self, NCollection_Array1_gp_Pnt tabP) -> AppDef_MultiPointConstraint
        __init__(AppDef_MultiPointConstraint self, NCollection_Array1_gp_Pnt2d tabP) -> AppDef_MultiPointConstraint
        __init__(AppDef_MultiPointConstraint self, NCollection_Array1_gp_Pnt tabP, NCollection_Array1_gp_Pnt2d tabP2d) -> AppDef_MultiPointConstraint
        __init__(AppDef_MultiPointConstraint self, NCollection_Array1_gp_Pnt tabP, NCollection_Array1_gp_Pnt2d tabP2d, NCollection_Array1_gp_Vec tabVec, NCollection_Array1_gp_Vec2d tabVec2d, NCollection_Array1_gp_Vec tabCur, NCollection_Array1_gp_Vec2d tabCur2d) -> AppDef_MultiPointConstraint
        __init__(AppDef_MultiPointConstraint self, NCollection_Array1_gp_Pnt tabP, NCollection_Array1_gp_Pnt2d tabP2d, NCollection_Array1_gp_Vec tabVec, NCollection_Array1_gp_Vec2d tabVec2d) -> AppDef_MultiPointConstraint
        __init__(AppDef_MultiPointConstraint self, NCollection_Array1_gp_Pnt tabP, NCollection_Array1_gp_Vec tabVec, NCollection_Array1_gp_Vec tabCur) -> AppDef_MultiPointConstraint
        __init__(AppDef_MultiPointConstraint self, NCollection_Array1_gp_Pnt tabP, NCollection_Array1_gp_Vec tabVec) -> AppDef_MultiPointConstraint
        __init__(AppDef_MultiPointConstraint self, NCollection_Array1_gp_Pnt2d tabP2d, NCollection_Array1_gp_Vec2d tabVec2d) -> AppDef_MultiPointConstraint
        __init__(AppDef_MultiPointConstraint self, NCollection_Array1_gp_Pnt2d tabP2d, NCollection_Array1_gp_Vec2d tabVec2d, NCollection_Array1_gp_Vec2d tabCur2d) -> AppDef_MultiPointConstraint

        creates a MultiPointConstraint only composed of 2d points
        with constraints of curvature.
        An exception is raised if the length of tabP is different
        from the length of tabVec2d or from tabCur2d.

        :type tabP2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type tabVec2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :type tabCur2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d

        """
        this = _AppDef.new_AppDef_MultiPointConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetTang(self, *args):
        """
        SetTang(AppDef_MultiPointConstraint self, Standard_Integer const Index, gp_Vec Tang)

        sets the value of the tangency of the point of range
        Index.
        An exception is raised if Index <0 or if Index > number
        of 3d points.
        An exception is raised if Tang has an incorrect number of
        dimensions.

        :type Index: int
        :type Tang: OCC.wrapper.gp.gp_Vec

        """
        return _AppDef.AppDef_MultiPointConstraint_SetTang(self, *args)


    def Tang(self, *args):
        """
        Tang(AppDef_MultiPointConstraint self, Standard_Integer const Index) -> gp_Vec

        returns the tangency value of the point of range Index.
        An exception is raised if Index < 0 or if Index > number
        of 3d points.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _AppDef.AppDef_MultiPointConstraint_Tang(self, *args)


    def SetTang2d(self, *args):
        """
        SetTang2d(AppDef_MultiPointConstraint self, Standard_Integer const Index, gp_Vec2d Tang2d)

        sets the value of the tangency of the point of range
        Index.
        An exception is raised if Index <number of 3d points or if
        Index > total number of Points
        An exception is raised if Tang has an incorrect number of
        dimensions.

        :type Index: int
        :type Tang2d: OCC.wrapper.gp.gp_Vec2d

        """
        return _AppDef.AppDef_MultiPointConstraint_SetTang2d(self, *args)


    def Tang2d(self, *args):
        """
        Tang2d(AppDef_MultiPointConstraint self, Standard_Integer const Index) -> gp_Vec2d

        returns the tangency value of the point of range Index.
        An exception is raised if Index < number  of 3d points or
        if Index > total number of points.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _AppDef.AppDef_MultiPointConstraint_Tang2d(self, *args)


    def SetCurv(self, *args):
        """
        SetCurv(AppDef_MultiPointConstraint self, Standard_Integer const Index, gp_Vec Curv)

        Vec sets the value of the normal vector at the
        point of index Index. The norm of the normal
        vector at the point of position Index is set to the normal curvature.
        An exception is raised if Index <0 or if Index > number
        of 3d points.
        An exception is raised if Curv has an incorrect number of
        dimensions.

        :type Index: int
        :type Curv: OCC.wrapper.gp.gp_Vec

        """
        return _AppDef.AppDef_MultiPointConstraint_SetCurv(self, *args)


    def Curv(self, *args):
        """
        Curv(AppDef_MultiPointConstraint self, Standard_Integer const Index) -> gp_Vec

        returns the normal vector at the point of range Index.
        An exception is raised if Index < 0 or if Index > number
        of 3d points.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _AppDef.AppDef_MultiPointConstraint_Curv(self, *args)


    def SetCurv2d(self, *args):
        """
        SetCurv2d(AppDef_MultiPointConstraint self, Standard_Integer const Index, gp_Vec2d Curv2d)

        Vec sets the value of the normal vector at the
        point of index Index. The norm of the normal
        vector at the point of position Index is set to the normal curvature.
        An exception is raised if Index <0 or if Index > number
        of 3d points.
        An exception is raised if Curv has an incorrect number of
        dimensions.

        :type Index: int
        :type Curv2d: OCC.wrapper.gp.gp_Vec2d

        """
        return _AppDef.AppDef_MultiPointConstraint_SetCurv2d(self, *args)


    def Curv2d(self, *args):
        """
        Curv2d(AppDef_MultiPointConstraint self, Standard_Integer const Index) -> gp_Vec2d

        returns the normal vector at the point of range Index.
        An exception is raised if Index < 0 or if Index > number
        of 3d points.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _AppDef.AppDef_MultiPointConstraint_Curv2d(self, *args)


    def IsTangencyPoint(self, *args):
        """
        IsTangencyPoint(AppDef_MultiPointConstraint self) -> Standard_Boolean

        returns True if the MultiPoint has a tangency value.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_MultiPointConstraint_IsTangencyPoint(self, *args)


    def IsCurvaturePoint(self, *args):
        """
        IsCurvaturePoint(AppDef_MultiPointConstraint self) -> Standard_Boolean

        returns True if the MultiPoint has a curvature value.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_MultiPointConstraint_IsCurvaturePoint(self, *args)


    def Dump(self, *args):
        """
        Dump(AppDef_MultiPointConstraint self, Standard_OStream & o)

        Prints on the stream o information on the current
        state of the object.
        Is used to redefine the operator <<.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _AppDef.AppDef_MultiPointConstraint_Dump(self, *args)

    __swig_destroy__ = _AppDef.delete_AppDef_MultiPointConstraint
AppDef_MultiPointConstraint_swigregister = _AppDef.AppDef_MultiPointConstraint_swigregister
AppDef_MultiPointConstraint_swigregister(AppDef_MultiPointConstraint)

class AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute self, AppDef_MultiLine SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, math_Vector Parameters, Standard_Integer const NbPol) -> AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute
        __init__(AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute self, AppDef_MultiLine SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, Standard_Integer const NbPol) -> AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute
        __init__(AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute self, AppDef_MultiLine SSP, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, math_Vector Parameters, Standard_Integer const NbPol) -> AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute
        __init__(AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute self, AppDef_MultiLine SSP, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, Standard_Integer const NbPol) -> AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute

        Initializes the fields of the object.

        :type SSP: OCC.wrapper.AppDef.AppDef_MultiLine
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type FirstPoint: int
        :type LastPoint: int
        :type FirstCons: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type LastCons: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type NbPol: int

        """
        this = _AppDef.new_AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute self, math_Vector Parameters)
        Perform(AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute self, math_Vector Parameters, Standard_Real const l1, Standard_Real const l2)
        Perform(AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute self, math_Vector Parameters, math_Vector V1t, math_Vector V2t, Standard_Real const l1, Standard_Real const l2)
        Perform(AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute self, math_Vector Parameters, math_Vector V1t, math_Vector V2t, math_Vector V1c, math_Vector V2c, Standard_Real const l1, Standard_Real const l2)

        Is used after having initialized the fields.
        <V1t> is the tangent vector at the first point.
        <V2t> is the tangent vector at the last point.
        <V1c> is the tangent vector at the first point.
        <V2c> is the tangent vector at the last point.

        :type Parameters: OCC.wrapper.math.math_Vector
        :type V1t: OCC.wrapper.math.math_Vector
        :type V2t: OCC.wrapper.math.math_Vector
        :type V1c: OCC.wrapper.math.math_Vector
        :type V2c: OCC.wrapper.math.math_Vector
        :type l1: float
        :type l2: float

        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_IsDone(self, *args)


    def BezierValue(self, *args):
        """
        BezierValue(AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute self) -> AppParCurves_MultiCurve

        returns the result of the approximation, i.e. all the
        Curves.
        An exception is raised if NotDone.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_BezierValue(self, *args)


    def BSplineValue(self, *args):
        """
        returns the result of the approximation, i.e. all the
        Curves.
        An exception is raised if NotDone.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        res = _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_BSplineValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FunctionMatrix(self, *args):
        """
        returns the function matrix used to approximate the
        set.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_FunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DerivativeFunctionMatrix(self, *args):
        """
        returns the derivative function matrix used
        to approximate the set.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_DerivativeFunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ErrorGradient(self, *args):
        """
        ErrorGradient(AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute self, math_Vector Grad)

        returns the maximum errors between the MultiLine
        and the approximation curves. F is the sum of the square
        distances. Grad is the derivative vector of the
        function F.

        :type Grad: OCC.wrapper.math.math_Vector
        :type F: float
        :type MaxE3d: float
        :type MaxE2d: float

        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_ErrorGradient(self, *args)


    def Distance(self, *args):
        """
        returns the distances between the points of the
        multiline and the approximation curves.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_Distance(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute self)

        returns the maximum errors between the MultiLine
        and the approximation curves. F is the sum of the square
        distances.

        :type F: float
        :type MaxE3d: float
        :type MaxE2d: float

        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_Error(self, *args)


    def FirstLambda(self, *args):
        """
        FirstLambda(AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute self) -> Standard_Real

        returns the value (P2 - P1)/ V1 if the first point
        was a tangency point.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_FirstLambda(self, *args)


    def LastLambda(self, *args):
        """
        LastLambda(AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute self) -> Standard_Real

        returns the value (PN - PN-1)/ VN if the last point
        was a tangency point.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_LastLambda(self, *args)


    def Points(self, *args):
        """
        returns the matrix of points value.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_Points(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Poles(self, *args):
        """
        returns the matrix of resulting control points value.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_Poles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def KIndex(self, *args):
        """
        Returns the indexes of the first non null values of
        A and DA.
        The values are non null from Index(ieme point) +1
        to Index(ieme point) + degree +1.

        :rtype: OCC.wrapper.math.math_IntegerVector

        """
        res = _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_KIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AppDef.delete_AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute
AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_swigregister = _AppDef.AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_swigregister
AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute_swigregister(AppDef_BSpParLeastSquareOfMyBSplGradientOfBSplineCompute)

class NCollection_Array1_AppDef_MultiPointConstraint(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_AppDef_MultiPointConstraint self) -> NCollection_Array1< AppDef_MultiPointConstraint >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _AppDef.NCollection_Array1_AppDef_MultiPointConstraint_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_AppDef_MultiPointConstraint self) -> NCollection_Array1< AppDef_MultiPointConstraint >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _AppDef.NCollection_Array1_AppDef_MultiPointConstraint_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_AppDef_MultiPointConstraint self) -> NCollection_Array1< AppDef_MultiPointConstraint >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _AppDef.NCollection_Array1_AppDef_MultiPointConstraint_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_AppDef_MultiPointConstraint self) -> NCollection_Array1< AppDef_MultiPointConstraint >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _AppDef.NCollection_Array1_AppDef_MultiPointConstraint_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _AppDef.new_NCollection_Array1_AppDef_MultiPointConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_AppDef_MultiPointConstraint self, AppDef_MultiPointConstraint theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _AppDef.NCollection_Array1_AppDef_MultiPointConstraint_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_AppDef_MultiPointConstraint self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.NCollection_Array1_AppDef_MultiPointConstraint_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_AppDef_MultiPointConstraint self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.NCollection_Array1_AppDef_MultiPointConstraint_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_AppDef_MultiPointConstraint self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.NCollection_Array1_AppDef_MultiPointConstraint_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_AppDef_MultiPointConstraint self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.NCollection_Array1_AppDef_MultiPointConstraint_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_AppDef_MultiPointConstraint self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.NCollection_Array1_AppDef_MultiPointConstraint_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_AppDef_MultiPointConstraint self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.NCollection_Array1_AppDef_MultiPointConstraint_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_AppDef_MultiPointConstraint self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.NCollection_Array1_AppDef_MultiPointConstraint_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_AppDef_MultiPointConstraint self, NCollection_Array1_AppDef_MultiPointConstraint theOther) -> NCollection_Array1_AppDef_MultiPointConstraint

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _AppDef.NCollection_Array1_AppDef_MultiPointConstraint_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_AppDef_MultiPointConstraint self, NCollection_Array1_AppDef_MultiPointConstraint theOther) -> NCollection_Array1_AppDef_MultiPointConstraint

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _AppDef.NCollection_Array1_AppDef_MultiPointConstraint_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_AppDef_MultiPointConstraint self, NCollection_Array1_AppDef_MultiPointConstraint theOther) -> NCollection_Array1_AppDef_MultiPointConstraint
        assign(NCollection_Array1_AppDef_MultiPointConstraint self, NCollection_Array1_AppDef_MultiPointConstraint theOther) -> NCollection_Array1_AppDef_MultiPointConstraint

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _AppDef.NCollection_Array1_AppDef_MultiPointConstraint_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _AppDef.NCollection_Array1_AppDef_MultiPointConstraint_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_AppDef_MultiPointConstraint self) -> AppDef_MultiPointConstraint

        @return first element

        :rtype: TheItemType &

        """
        return _AppDef.NCollection_Array1_AppDef_MultiPointConstraint_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _AppDef.NCollection_Array1_AppDef_MultiPointConstraint_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_AppDef_MultiPointConstraint self) -> AppDef_MultiPointConstraint

        @return last element

        :rtype: TheItemType &

        """
        return _AppDef.NCollection_Array1_AppDef_MultiPointConstraint_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AppDef.NCollection_Array1_AppDef_MultiPointConstraint_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_AppDef_MultiPointConstraint self, Standard_Integer const theIndex) -> AppDef_MultiPointConstraint

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _AppDef.NCollection_Array1_AppDef_MultiPointConstraint_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AppDef.NCollection_Array1_AppDef_MultiPointConstraint___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _AppDef.NCollection_Array1_AppDef_MultiPointConstraint_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_AppDef_MultiPointConstraint self, Standard_Integer const theIndex, AppDef_MultiPointConstraint theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _AppDef.NCollection_Array1_AppDef_MultiPointConstraint_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_AppDef_MultiPointConstraint self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _AppDef.NCollection_Array1_AppDef_MultiPointConstraint_Resize(self, *args)

    __swig_destroy__ = _AppDef.delete_NCollection_Array1_AppDef_MultiPointConstraint
NCollection_Array1_AppDef_MultiPointConstraint_swigregister = _AppDef.NCollection_Array1_AppDef_MultiPointConstraint_swigregister
NCollection_Array1_AppDef_MultiPointConstraint_swigregister(NCollection_Array1_AppDef_MultiPointConstraint)


try:
	AppDef_Array1OfMultiPointConstraint = NCollection_Array1_AppDef_MultiPointConstraint
except NameError:
	pass # does not exist, probably ignored

class AppDef_ParLeastSquareOfTheGradient(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_ParLeastSquareOfTheGradient self, AppDef_MultiLine SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, math_Vector Parameters, Standard_Integer const NbPol) -> AppDef_ParLeastSquareOfTheGradient
        __init__(AppDef_ParLeastSquareOfTheGradient self, AppDef_MultiLine SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, Standard_Integer const NbPol) -> AppDef_ParLeastSquareOfTheGradient
        __init__(AppDef_ParLeastSquareOfTheGradient self, AppDef_MultiLine SSP, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, math_Vector Parameters, Standard_Integer const NbPol) -> AppDef_ParLeastSquareOfTheGradient
        __init__(AppDef_ParLeastSquareOfTheGradient self, AppDef_MultiLine SSP, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, Standard_Integer const NbPol) -> AppDef_ParLeastSquareOfTheGradient

        Initializes the fields of the object.

        :type SSP: OCC.wrapper.AppDef.AppDef_MultiLine
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type FirstPoint: int
        :type LastPoint: int
        :type FirstCons: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type LastCons: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type NbPol: int

        """
        this = _AppDef.new_AppDef_ParLeastSquareOfTheGradient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(AppDef_ParLeastSquareOfTheGradient self, math_Vector Parameters)
        Perform(AppDef_ParLeastSquareOfTheGradient self, math_Vector Parameters, Standard_Real const l1, Standard_Real const l2)
        Perform(AppDef_ParLeastSquareOfTheGradient self, math_Vector Parameters, math_Vector V1t, math_Vector V2t, Standard_Real const l1, Standard_Real const l2)
        Perform(AppDef_ParLeastSquareOfTheGradient self, math_Vector Parameters, math_Vector V1t, math_Vector V2t, math_Vector V1c, math_Vector V2c, Standard_Real const l1, Standard_Real const l2)

        Is used after having initialized the fields.
        <V1t> is the tangent vector at the first point.
        <V2t> is the tangent vector at the last point.
        <V1c> is the tangent vector at the first point.
        <V2c> is the tangent vector at the last point.

        :type Parameters: OCC.wrapper.math.math_Vector
        :type V1t: OCC.wrapper.math.math_Vector
        :type V2t: OCC.wrapper.math.math_Vector
        :type V1c: OCC.wrapper.math.math_Vector
        :type V2c: OCC.wrapper.math.math_Vector
        :type l1: float
        :type l2: float

        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(AppDef_ParLeastSquareOfTheGradient self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_IsDone(self, *args)


    def BezierValue(self, *args):
        """
        BezierValue(AppDef_ParLeastSquareOfTheGradient self) -> AppParCurves_MultiCurve

        returns the result of the approximation, i.e. all the
        Curves.
        An exception is raised if NotDone.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_BezierValue(self, *args)


    def BSplineValue(self, *args):
        """
        returns the result of the approximation, i.e. all the
        Curves.
        An exception is raised if NotDone.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        res = _AppDef.AppDef_ParLeastSquareOfTheGradient_BSplineValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FunctionMatrix(self, *args):
        """
        returns the function matrix used to approximate the
        set.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_ParLeastSquareOfTheGradient_FunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DerivativeFunctionMatrix(self, *args):
        """
        returns the derivative function matrix used
        to approximate the set.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_ParLeastSquareOfTheGradient_DerivativeFunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ErrorGradient(self, *args):
        """
        ErrorGradient(AppDef_ParLeastSquareOfTheGradient self, math_Vector Grad)

        returns the maximum errors between the MultiLine
        and the approximation curves. F is the sum of the square
        distances. Grad is the derivative vector of the
        function F.

        :type Grad: OCC.wrapper.math.math_Vector
        :type F: float
        :type MaxE3d: float
        :type MaxE2d: float

        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_ErrorGradient(self, *args)


    def Distance(self, *args):
        """
        returns the distances between the points of the
        multiline and the approximation curves.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_ParLeastSquareOfTheGradient_Distance(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(AppDef_ParLeastSquareOfTheGradient self)

        returns the maximum errors between the MultiLine
        and the approximation curves. F is the sum of the square
        distances.

        :type F: float
        :type MaxE3d: float
        :type MaxE2d: float

        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_Error(self, *args)


    def FirstLambda(self, *args):
        """
        FirstLambda(AppDef_ParLeastSquareOfTheGradient self) -> Standard_Real

        returns the value (P2 - P1)/ V1 if the first point
        was a tangency point.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_FirstLambda(self, *args)


    def LastLambda(self, *args):
        """
        LastLambda(AppDef_ParLeastSquareOfTheGradient self) -> Standard_Real

        returns the value (PN - PN-1)/ VN if the last point
        was a tangency point.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_ParLeastSquareOfTheGradient_LastLambda(self, *args)


    def Points(self, *args):
        """
        returns the matrix of points value.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_ParLeastSquareOfTheGradient_Points(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Poles(self, *args):
        """
        returns the matrix of resulting control points value.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_ParLeastSquareOfTheGradient_Poles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def KIndex(self, *args):
        """
        Returns the indexes of the first non null values of
        A and DA.
        The values are non null from Index(ieme point) +1
        to Index(ieme point) + degree +1.

        :rtype: OCC.wrapper.math.math_IntegerVector

        """
        res = _AppDef.AppDef_ParLeastSquareOfTheGradient_KIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AppDef.delete_AppDef_ParLeastSquareOfTheGradient
AppDef_ParLeastSquareOfTheGradient_swigregister = _AppDef.AppDef_ParLeastSquareOfTheGradient_swigregister
AppDef_ParLeastSquareOfTheGradient_swigregister(AppDef_ParLeastSquareOfTheGradient)

class AppDef_ResConstraintOfMyGradientbisOfBSplineCompute(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_ResConstraintOfMyGradientbisOfBSplineCompute self, AppDef_MultiLine SSP, AppParCurves_MultiCurve SCurv, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple Constraints, math_Matrix Bern, math_Matrix DerivativeBern, Standard_Real const Tolerance=1.0e-10) -> AppDef_ResConstraintOfMyGradientbisOfBSplineCompute

        Given a MultiLine SSP with constraints points, this
        algorithm finds the best curve solution to approximate it.
        The poles from SCurv issued for example from the least
        squares are used as a guess solution for the uzawa
        algorithm. The tolerance used in the Uzawa algorithms
        is Tolerance.
        A is the Bernstein matrix associated to the MultiLine
        and DA is the derivative bernstein matrix.(They can come
        from an approximation with ParLeastSquare.)
        The MultiCurve is modified. New MultiPoles are given.

        :type SSP: OCC.wrapper.AppDef.AppDef_MultiLine
        :type SCurv: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve
        :type FirstPoint: int
        :type LastPoint: int
        :type Constraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Bern: OCC.wrapper.math.math_Matrix
        :type DerivativeBern: OCC.wrapper.math.math_Matrix
        :type Tolerance: float

        """
        this = _AppDef.new_AppDef_ResConstraintOfMyGradientbisOfBSplineCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(AppDef_ResConstraintOfMyGradientbisOfBSplineCompute self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_IsDone(self, *args)


    def ConstraintMatrix(self, *args):
        """
        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_ConstraintMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Duale(self, *args):
        """
        returns the duale variables of the system.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_Duale(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ConstraintDerivative(self, *args):
        """
        Returns the derivative of the constraint matrix.

        :type SSP: OCC.wrapper.AppDef.AppDef_MultiLine
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Deg: int
        :type DA: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_ConstraintDerivative(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InverseMatrix(self, *args):
        """
        returns the Inverse of Cont*Transposed(Cont), where
        Cont is the constraint matrix for the algorithm.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_InverseMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AppDef.delete_AppDef_ResConstraintOfMyGradientbisOfBSplineCompute
AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_swigregister = _AppDef.AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_swigregister
AppDef_ResConstraintOfMyGradientbisOfBSplineCompute_swigregister(AppDef_ResConstraintOfMyGradientbisOfBSplineCompute)

class AppDef_Gradient_BFGSOfTheGradient(math.math_BFGS):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_Gradient_BFGSOfTheGradient self, math_MultipleVarFunctionWithGradient F, math_Vector StartingPoint, Standard_Real const Tolerance3d, Standard_Real const Tolerance2d, Standard_Real const Eps, Standard_Integer const NbIterations=200) -> AppDef_Gradient_BFGSOfTheGradient

        :type F: OCC.wrapper.math.math_MultipleVarFunctionWithGradient
        :type StartingPoint: OCC.wrapper.math.math_Vector
        :type Tolerance3d: float
        :type Tolerance2d: float
        :type Eps: float
        :type NbIterations: int

        """
        this = _AppDef.new_AppDef_Gradient_BFGSOfTheGradient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsSolutionReached(self, *args):
        """
        IsSolutionReached(AppDef_Gradient_BFGSOfTheGradient self, math_MultipleVarFunctionWithGradient F) -> Standard_Boolean

        :type F: OCC.wrapper.math.math_MultipleVarFunctionWithGradient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_Gradient_BFGSOfTheGradient_IsSolutionReached(self, *args)

    __swig_destroy__ = _AppDef.delete_AppDef_Gradient_BFGSOfTheGradient
AppDef_Gradient_BFGSOfTheGradient_swigregister = _AppDef.AppDef_Gradient_BFGSOfTheGradient_swigregister
AppDef_Gradient_BFGSOfTheGradient_swigregister(AppDef_Gradient_BFGSOfTheGradient)

class AppDef_MyGradientOfCompute(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_MyGradientOfCompute self, AppDef_MultiLine SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, math_Vector Parameters, Standard_Integer const Deg, Standard_Real const Tol3d, Standard_Real const Tol2d, Standard_Integer const NbIterations=200) -> AppDef_MyGradientOfCompute

        Tries to minimize the sum (square(||Qui - Bi*Pi||))
        where Pui describe the approximating Bezier curves'Poles
        and Qi the MultiLine points with a parameter ui.
        In this algorithm, the parameters ui are the unknowns.
        The tolerance required on this sum is given by Tol.
        The desired degree of the resulting curve is Deg.

        :type SSP: OCC.wrapper.AppDef.AppDef_MultiLine
        :type FirstPoint: int
        :type LastPoint: int
        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Deg: int
        :type Tol3d: float
        :type Tol2d: float
        :type NbIterations: int

        """
        this = _AppDef.new_AppDef_MyGradientOfCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(AppDef_MyGradientOfCompute self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_MyGradientOfCompute_IsDone(self, *args)


    def Value(self, *args):
        """
        Value(AppDef_MyGradientOfCompute self) -> AppParCurves_MultiCurve

        returns all the Bezier curves approximating the
        MultiLine SSP after minimization of the parameter.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        return _AppDef.AppDef_MyGradientOfCompute_Value(self, *args)


    def Error(self, *args):
        """
        Error(AppDef_MyGradientOfCompute self, Standard_Integer const Index) -> Standard_Real

        returns the difference between the old and the new
        approximation.
        An exception is raised if NotDone.
        An exception is raised if Index<1 or Index>NbParameters.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_MyGradientOfCompute_Error(self, *args)


    def MaxError3d(self, *args):
        """
        MaxError3d(AppDef_MyGradientOfCompute self) -> Standard_Real

        returns the maximum difference between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_MyGradientOfCompute_MaxError3d(self, *args)


    def MaxError2d(self, *args):
        """
        MaxError2d(AppDef_MyGradientOfCompute self) -> Standard_Real

        returns the maximum difference between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_MyGradientOfCompute_MaxError2d(self, *args)


    def AverageError(self, *args):
        """
        AverageError(AppDef_MyGradientOfCompute self) -> Standard_Real

        returns the average error between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_MyGradientOfCompute_AverageError(self, *args)

    __swig_destroy__ = _AppDef.delete_AppDef_MyGradientOfCompute
AppDef_MyGradientOfCompute_swigregister = _AppDef.AppDef_MyGradientOfCompute_swigregister
AppDef_MyGradientOfCompute_swigregister(AppDef_MyGradientOfCompute)

class AppDef_ParFunctionOfTheGradient(math.math_MultipleVarFunctionWithGradient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_ParFunctionOfTheGradient self, AppDef_MultiLine SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, math_Vector Parameters, Standard_Integer const Deg) -> AppDef_ParFunctionOfTheGradient

        initializes the fields of the function. The approximating
        curve has the desired degree Deg.

        :type SSP: OCC.wrapper.AppDef.AppDef_MultiLine
        :type FirstPoint: int
        :type LastPoint: int
        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Deg: int

        """
        this = _AppDef.new_AppDef_ParFunctionOfTheGradient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(AppDef_ParFunctionOfTheGradient self) -> Standard_Integer

        returns the number of variables of the function. It
        corresponds to the number of MultiPoints.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.AppDef_ParFunctionOfTheGradient_NbVariables(self, *args)


    def Value(self, *args):
        """
        Value(AppDef_ParFunctionOfTheGradient self, math_Vector X) -> Standard_Boolean

        this method computes the new approximation of the
        MultiLine
        SSP and calculates F = sum (||Pui - Bi*Pi||2) for each
        point of the MultiLine.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_ParFunctionOfTheGradient_Value(self, *args)


    def Gradient(self, *args):
        """
        Gradient(AppDef_ParFunctionOfTheGradient self, math_Vector X, math_Vector G) -> Standard_Boolean

        returns the gradient G of the sum above for the
        parameters Xi.

        :type X: OCC.wrapper.math.math_Vector
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_ParFunctionOfTheGradient_Gradient(self, *args)


    def Values(self, *args):
        """
        Values(AppDef_ParFunctionOfTheGradient self, math_Vector X, math_Vector G) -> Standard_Boolean

        returns the value F=sum(||Pui - Bi*Pi||)2.
        returns the value G = grad(F) for the parameters Xi.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_ParFunctionOfTheGradient_Values(self, *args)


    def NewParameters(self, *args):
        """
        returns the new parameters of the MultiLine.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _AppDef.AppDef_ParFunctionOfTheGradient_NewParameters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CurveValue(self, *args):
        """
        returns the MultiCurve approximating the set after
        computing the value F or Grad(F).

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        res = _AppDef.AppDef_ParFunctionOfTheGradient_CurveValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(AppDef_ParFunctionOfTheGradient self, Standard_Integer const IPoint, Standard_Integer const CurveIndex) -> Standard_Real

        returns the distance between the MultiPoint of range
        IPoint and the curve CurveIndex.

        :type IPoint: int
        :type CurveIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_ParFunctionOfTheGradient_Error(self, *args)


    def MaxError3d(self, *args):
        """
        MaxError3d(AppDef_ParFunctionOfTheGradient self) -> Standard_Real

        returns the maximum distance between the points
        and the MultiCurve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_ParFunctionOfTheGradient_MaxError3d(self, *args)


    def MaxError2d(self, *args):
        """
        MaxError2d(AppDef_ParFunctionOfTheGradient self) -> Standard_Real

        returns the maximum distance between the points
        and the MultiCurve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_ParFunctionOfTheGradient_MaxError2d(self, *args)


    def FirstConstraint(self, *args):
        """
        FirstConstraint(AppDef_ParFunctionOfTheGradient self, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, Standard_Integer const FirstPoint) -> AppParCurves_Constraint

        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type FirstPoint: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _AppDef.AppDef_ParFunctionOfTheGradient_FirstConstraint(self, *args)


    def LastConstraint(self, *args):
        """
        LastConstraint(AppDef_ParFunctionOfTheGradient self, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, Standard_Integer const LastPoint) -> AppParCurves_Constraint

        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type LastPoint: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _AppDef.AppDef_ParFunctionOfTheGradient_LastConstraint(self, *args)

    __swig_destroy__ = _AppDef.delete_AppDef_ParFunctionOfTheGradient
AppDef_ParFunctionOfTheGradient_swigregister = _AppDef.AppDef_ParFunctionOfTheGradient_swigregister
AppDef_ParFunctionOfTheGradient_swigregister(AppDef_ParFunctionOfTheGradient)

class AppDef_Gradient_BFGSOfMyGradientOfCompute(math.math_BFGS):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_Gradient_BFGSOfMyGradientOfCompute self, math_MultipleVarFunctionWithGradient F, math_Vector StartingPoint, Standard_Real const Tolerance3d, Standard_Real const Tolerance2d, Standard_Real const Eps, Standard_Integer const NbIterations=200) -> AppDef_Gradient_BFGSOfMyGradientOfCompute

        :type F: OCC.wrapper.math.math_MultipleVarFunctionWithGradient
        :type StartingPoint: OCC.wrapper.math.math_Vector
        :type Tolerance3d: float
        :type Tolerance2d: float
        :type Eps: float
        :type NbIterations: int

        """
        this = _AppDef.new_AppDef_Gradient_BFGSOfMyGradientOfCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsSolutionReached(self, *args):
        """
        IsSolutionReached(AppDef_Gradient_BFGSOfMyGradientOfCompute self, math_MultipleVarFunctionWithGradient F) -> Standard_Boolean

        :type F: OCC.wrapper.math.math_MultipleVarFunctionWithGradient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_Gradient_BFGSOfMyGradientOfCompute_IsSolutionReached(self, *args)

    __swig_destroy__ = _AppDef.delete_AppDef_Gradient_BFGSOfMyGradientOfCompute
AppDef_Gradient_BFGSOfMyGradientOfCompute_swigregister = _AppDef.AppDef_Gradient_BFGSOfMyGradientOfCompute_swigregister
AppDef_Gradient_BFGSOfMyGradientOfCompute_swigregister(AppDef_Gradient_BFGSOfMyGradientOfCompute)

class AppDef_MyGradientbisOfBSplineCompute(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_MyGradientbisOfBSplineCompute self, AppDef_MultiLine SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, math_Vector Parameters, Standard_Integer const Deg, Standard_Real const Tol3d, Standard_Real const Tol2d, Standard_Integer const NbIterations=200) -> AppDef_MyGradientbisOfBSplineCompute

        Tries to minimize the sum (square(||Qui - Bi*Pi||))
        where Pui describe the approximating Bezier curves'Poles
        and Qi the MultiLine points with a parameter ui.
        In this algorithm, the parameters ui are the unknowns.
        The tolerance required on this sum is given by Tol.
        The desired degree of the resulting curve is Deg.

        :type SSP: OCC.wrapper.AppDef.AppDef_MultiLine
        :type FirstPoint: int
        :type LastPoint: int
        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Deg: int
        :type Tol3d: float
        :type Tol2d: float
        :type NbIterations: int

        """
        this = _AppDef.new_AppDef_MyGradientbisOfBSplineCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(AppDef_MyGradientbisOfBSplineCompute self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_MyGradientbisOfBSplineCompute_IsDone(self, *args)


    def Value(self, *args):
        """
        Value(AppDef_MyGradientbisOfBSplineCompute self) -> AppParCurves_MultiCurve

        returns all the Bezier curves approximating the
        MultiLine SSP after minimization of the parameter.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        return _AppDef.AppDef_MyGradientbisOfBSplineCompute_Value(self, *args)


    def Error(self, *args):
        """
        Error(AppDef_MyGradientbisOfBSplineCompute self, Standard_Integer const Index) -> Standard_Real

        returns the difference between the old and the new
        approximation.
        An exception is raised if NotDone.
        An exception is raised if Index<1 or Index>NbParameters.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_MyGradientbisOfBSplineCompute_Error(self, *args)


    def MaxError3d(self, *args):
        """
        MaxError3d(AppDef_MyGradientbisOfBSplineCompute self) -> Standard_Real

        returns the maximum difference between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_MyGradientbisOfBSplineCompute_MaxError3d(self, *args)


    def MaxError2d(self, *args):
        """
        MaxError2d(AppDef_MyGradientbisOfBSplineCompute self) -> Standard_Real

        returns the maximum difference between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_MyGradientbisOfBSplineCompute_MaxError2d(self, *args)


    def AverageError(self, *args):
        """
        AverageError(AppDef_MyGradientbisOfBSplineCompute self) -> Standard_Real

        returns the average error between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_MyGradientbisOfBSplineCompute_AverageError(self, *args)

    __swig_destroy__ = _AppDef.delete_AppDef_MyGradientbisOfBSplineCompute
AppDef_MyGradientbisOfBSplineCompute_swigregister = _AppDef.AppDef_MyGradientbisOfBSplineCompute_swigregister
AppDef_MyGradientbisOfBSplineCompute_swigregister(AppDef_MyGradientbisOfBSplineCompute)

class AppDef_MyBSplGradientOfBSplineCompute(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_MyBSplGradientOfBSplineCompute self, AppDef_MultiLine SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, math_Vector Parameters, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const Deg, Standard_Real const Tol3d, Standard_Real const Tol2d, Standard_Integer const NbIterations=1) -> AppDef_MyBSplGradientOfBSplineCompute
        __init__(AppDef_MyBSplGradientOfBSplineCompute self, AppDef_MultiLine SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, math_Vector Parameters, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const Deg, Standard_Real const Tol3d, Standard_Real const Tol2d, Standard_Integer const NbIterations, Standard_Real const lambda1, Standard_Real const lambda2) -> AppDef_MyBSplGradientOfBSplineCompute

        Tries to minimize the sum (square(||Qui - Bi*Pi||))
        where Pui describe the approximating BSpline curves'Poles
        and Qi the MultiLine points with a parameter ui.
        In this algorithm, the parameters ui are the unknowns.
        The tolerance required on this sum is given by Tol.
        The desired degree of the resulting curve is Deg.

        :type SSP: OCC.wrapper.AppDef.AppDef_MultiLine
        :type FirstPoint: int
        :type LastPoint: int
        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type Deg: int
        :type Tol3d: float
        :type Tol2d: float
        :type NbIterations: int
        :type lambda1: float
        :type lambda2: float

        """
        this = _AppDef.new_AppDef_MyBSplGradientOfBSplineCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(AppDef_MyBSplGradientOfBSplineCompute self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_MyBSplGradientOfBSplineCompute_IsDone(self, *args)


    def Value(self, *args):
        """
        Value(AppDef_MyBSplGradientOfBSplineCompute self) -> AppParCurves_MultiBSpCurve

        returns all the BSpline curves approximating the
        MultiLine SSP after minimization of the parameter.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        return _AppDef.AppDef_MyBSplGradientOfBSplineCompute_Value(self, *args)


    def Error(self, *args):
        """
        Error(AppDef_MyBSplGradientOfBSplineCompute self, Standard_Integer const Index) -> Standard_Real

        returns the difference between the old and the new
        approximation.
        An exception is raised if NotDone.
        An exception is raised if Index<1 or Index>NbParameters.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_MyBSplGradientOfBSplineCompute_Error(self, *args)


    def MaxError3d(self, *args):
        """
        MaxError3d(AppDef_MyBSplGradientOfBSplineCompute self) -> Standard_Real

        returns the maximum difference between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_MyBSplGradientOfBSplineCompute_MaxError3d(self, *args)


    def MaxError2d(self, *args):
        """
        MaxError2d(AppDef_MyBSplGradientOfBSplineCompute self) -> Standard_Real

        returns the maximum difference between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_MyBSplGradientOfBSplineCompute_MaxError2d(self, *args)


    def AverageError(self, *args):
        """
        AverageError(AppDef_MyBSplGradientOfBSplineCompute self) -> Standard_Real

        returns the average error between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_MyBSplGradientOfBSplineCompute_AverageError(self, *args)

    __swig_destroy__ = _AppDef.delete_AppDef_MyBSplGradientOfBSplineCompute
AppDef_MyBSplGradientOfBSplineCompute_swigregister = _AppDef.AppDef_MyBSplGradientOfBSplineCompute_swigregister
AppDef_MyBSplGradientOfBSplineCompute_swigregister(AppDef_MyBSplGradientOfBSplineCompute)

class AppDef_Variational(object):
    """
    This class is used to smooth N points with constraints
    by   minimization  of quadratic  criterium   but  also
    variational criterium in order to obtain " fair Curve "
    Computes the approximation of a Multiline by
    Variational optimization.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_Variational self, AppDef_MultiLine SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, Standard_Integer const MaxDegree=14, Standard_Integer const MaxSegment=100, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Boolean const WithMinMax, Standard_Boolean const WithCutting, Standard_Real const Tolerance=1.0, Standard_Integer const NbIterations=2) -> AppDef_Variational

        Constructor.
        Initialization of   the   fields.
        warning :  Nc0 : number of PassagePoint consraints
        Nc2 : number  of  TangencyPoint constraints
        Nc3 : number of    CurvaturePoint   constraints
        if
        ((MaxDegree-Continuity)*MaxSegment -Nc0  - 2*Nc1
        -3*Nc2)
        is  negative
        The problem is over-constrained.

        Limitation : The MultiLine from AppDef has to be composed by
        only one Line ( Dimension 2 or 3).

        :type SSP: OCC.wrapper.AppDef.AppDef_MultiLine
        :type FirstPoint: int
        :type LastPoint: int
        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type MaxDegree: int
        :type MaxSegment: int
        :type Continuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type WithMinMax: bool
        :type WithCutting: bool
        :type Tolerance: float
        :type NbIterations: int

        """
        this = _AppDef.new_AppDef_Variational(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Approximate(self, *args):
        """
        Approximate(AppDef_Variational self)

        Makes the approximation with the current fields.


        """
        return _AppDef.AppDef_Variational_Approximate(self, *args)


    def IsCreated(self, *args):
        """
        IsCreated(AppDef_Variational self) -> Standard_Boolean

        returns True if the creation is done
        and correspond  to the current fields.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_Variational_IsCreated(self, *args)


    def IsDone(self, *args):
        """
        IsDone(AppDef_Variational self) -> Standard_Boolean

        returns True if the  approximation is ok
        and correspond  to the current fields.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_Variational_IsDone(self, *args)


    def IsOverConstrained(self, *args):
        """
        IsOverConstrained(AppDef_Variational self) -> Standard_Boolean

        returns True if the problem is overconstrained
        in this case, approximation cannot be done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_Variational_IsOverConstrained(self, *args)


    def Value(self, *args):
        """
        Value(AppDef_Variational self) -> AppParCurves_MultiBSpCurve

        returns all the BSpline curves approximating the
        MultiLine from AppDef SSP after minimization of the parameter.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        return _AppDef.AppDef_Variational_Value(self, *args)


    def MaxError(self, *args):
        """
        MaxError(AppDef_Variational self) -> Standard_Real

        returns the maximum of the distances between
        the points of the multiline and the approximation
        curves.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_Variational_MaxError(self, *args)


    def MaxErrorIndex(self, *args):
        """
        MaxErrorIndex(AppDef_Variational self) -> Standard_Integer

        returns the index of the MultiPoint of ErrorMax

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.AppDef_Variational_MaxErrorIndex(self, *args)


    def QuadraticError(self, *args):
        """
        QuadraticError(AppDef_Variational self) -> Standard_Real

        returns the quadratic average of the distances between
        the points of the multiline and the approximation
        curves.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_Variational_QuadraticError(self, *args)


    def Distance(self, *args):
        """
        Distance(AppDef_Variational self, math_Matrix mat)

        returns the distances between the points of the
        multiline and the approximation curves.

        :type mat: OCC.wrapper.math.math_Matrix

        """
        return _AppDef.AppDef_Variational_Distance(self, *args)


    def AverageError(self, *args):
        """
        AverageError(AppDef_Variational self) -> Standard_Real

        returns the average error between
        the MultiLine from AppDef and the approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_Variational_AverageError(self, *args)


    def Parameters(self, *args):
        """
        returns the parameters uses to the approximations

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        res = _AppDef.AppDef_Variational_Parameters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Knots(self, *args):
        """
        returns the knots uses to the approximations

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        res = _AppDef.AppDef_Variational_Knots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Criterium(self, *args):
        """
        Criterium(AppDef_Variational self)

        returns the values of the quality criterium.

        :type VFirstOrder: float
        :type VSecondOrder: float
        :type VThirdOrder: float

        """
        return _AppDef.AppDef_Variational_Criterium(self, *args)


    def CriteriumWeight(self, *args):
        """
        CriteriumWeight(AppDef_Variational self)

        returns the Weights (as percent) associed  to the criterium used in
        the  optimization.

        :type Percent1: float
        :type Percent2: float
        :type Percent3: float

        """
        return _AppDef.AppDef_Variational_CriteriumWeight(self, *args)


    def MaxDegree(self, *args):
        """
        MaxDegree(AppDef_Variational self) -> Standard_Integer

        returns the Maximum Degree used in the approximation

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.AppDef_Variational_MaxDegree(self, *args)


    def MaxSegment(self, *args):
        """
        MaxSegment(AppDef_Variational self) -> Standard_Integer

        returns the Maximum of segment used in the approximation

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.AppDef_Variational_MaxSegment(self, *args)


    def Continuity(self, *args):
        """
        Continuity(AppDef_Variational self) -> GeomAbs_Shape

        returns the Continuity used in the approximation

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _AppDef.AppDef_Variational_Continuity(self, *args)


    def WithMinMax(self, *args):
        """
        WithMinMax(AppDef_Variational self) -> Standard_Boolean

        returns if the  approximation  search to  minimize the
        maximum Error or not.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_Variational_WithMinMax(self, *args)


    def WithCutting(self, *args):
        """
        WithCutting(AppDef_Variational self) -> Standard_Boolean

        returns if the  approximation can insert new Knots or not.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_Variational_WithCutting(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(AppDef_Variational self) -> Standard_Real

        returns the tolerance used in the approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_Variational_Tolerance(self, *args)


    def NbIterations(self, *args):
        """
        NbIterations(AppDef_Variational self) -> Standard_Integer

        returns the number of iterations used in the approximation.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.AppDef_Variational_NbIterations(self, *args)


    def Dump(self, *args):
        """
        Dump(AppDef_Variational self, Standard_OStream & o)

        Prints on the stream o information on the current state
        of the object.
        MaxError,MaxErrorIndex,AverageError,QuadraticError,Criterium
        Distances,Degre,Nombre de poles, parametres, noeuds

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _AppDef.AppDef_Variational_Dump(self, *args)


    def SetConstraints(self, *args):
        """
        SetConstraints(AppDef_Variational self, Handle_AppParCurves_HArray1OfConstraintCouple aConstrainst) -> Standard_Boolean

        Define the constraints to approximate
        If this value is incompatible with the others fields
        this method modify nothing and returns false

        :type aConstrainst: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_Variational_SetConstraints(self, *args)


    def SetParameters(self, *args):
        """
        SetParameters(AppDef_Variational self, Handle_TColStd_HArray1OfReal param)

        Defines the parameters used by the approximations.

        :type param: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _AppDef.AppDef_Variational_SetParameters(self, *args)


    def SetKnots(self, *args):
        """
        SetKnots(AppDef_Variational self, Handle_TColStd_HArray1OfReal knots) -> Standard_Boolean

        Defines the knots used by the approximations
        If this value is incompatible with the others fields
        this method modify nothing and returns false

        :type knots: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_Variational_SetKnots(self, *args)


    def SetMaxDegree(self, *args):
        """
        SetMaxDegree(AppDef_Variational self, Standard_Integer const Degree) -> Standard_Boolean

        Define the Maximum Degree used in the approximation
        If this value is incompatible with the others fields
        this method modify nothing and returns false

        :type Degree: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_Variational_SetMaxDegree(self, *args)


    def SetMaxSegment(self, *args):
        """
        SetMaxSegment(AppDef_Variational self, Standard_Integer const NbSegment) -> Standard_Boolean

        Define the maximum number of segments used in the approximation
        If this value is incompatible with the others fields
        this method modify nothing and returns false

        :type NbSegment: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_Variational_SetMaxSegment(self, *args)


    def SetContinuity(self, *args):
        """
        SetContinuity(AppDef_Variational self, GeomAbs_Shape const C) -> Standard_Boolean

        Define the Continuity used in the approximation
        If this value is incompatible with the others fields
        this method modify nothing and returns false

        :type C: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_Variational_SetContinuity(self, *args)


    def SetWithMinMax(self, *args):
        """
        SetWithMinMax(AppDef_Variational self, Standard_Boolean const MinMax)

        Define if the  approximation  search to  minimize the
        maximum Error or not.

        :type MinMax: bool

        """
        return _AppDef.AppDef_Variational_SetWithMinMax(self, *args)


    def SetWithCutting(self, *args):
        """
        SetWithCutting(AppDef_Variational self, Standard_Boolean const Cutting) -> Standard_Boolean

        Define if the  approximation can insert new Knots or not.
        If this value is incompatible with the others fields
        this method modify nothing and returns false

        :type Cutting: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_Variational_SetWithCutting(self, *args)


    def SetCriteriumWeight(self, *args):
        """
        SetCriteriumWeight(AppDef_Variational self, Standard_Real const Percent1, Standard_Real const Percent2, Standard_Real const Percent3)
        SetCriteriumWeight(AppDef_Variational self, Standard_Integer const Order, Standard_Real const Percent)

        define the  Weight   (as  percent)  associed  to   the
        criterium   Order used in   the optimization  : Others
        weights are updated.
        if Percent < 0
        if Order < 1 or Order > 3

        :type Order: int
        :type Percent: float

        """
        return _AppDef.AppDef_Variational_SetCriteriumWeight(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(AppDef_Variational self, Standard_Real const Tol)

        define the tolerance used in the approximation.

        :type Tol: float

        """
        return _AppDef.AppDef_Variational_SetTolerance(self, *args)


    def SetNbIterations(self, *args):
        """
        SetNbIterations(AppDef_Variational self, Standard_Integer const Iter)

        define the number of iterations used in the approximation.
        if Iter < 1

        :type Iter: int

        """
        return _AppDef.AppDef_Variational_SetNbIterations(self, *args)

    __swig_destroy__ = _AppDef.delete_AppDef_Variational
AppDef_Variational_swigregister = _AppDef.AppDef_Variational_swigregister
AppDef_Variational_swigregister(AppDef_Variational)

class AppDef_MyLineTool(object):
    """
    example of MultiLine tool corresponding to the tools of the packages
    AppParCurves and Approx. For Approx, the tool will not addd points
    if the algorithms want some.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FirstPoint(*args):
        """
        FirstPoint(AppDef_MultiLine ML) -> Standard_Integer

        Returns the first index of multipoints of the MultiLine.

        :type ML: OCC.wrapper.AppDef.AppDef_MultiLine
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.AppDef_MyLineTool_FirstPoint(*args)

    FirstPoint = staticmethod(FirstPoint)

    def LastPoint(*args):
        """
        LastPoint(AppDef_MultiLine ML) -> Standard_Integer

        Returns the last index of multipoints of the MultiLine.

        :type ML: OCC.wrapper.AppDef.AppDef_MultiLine
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.AppDef_MyLineTool_LastPoint(*args)

    LastPoint = staticmethod(LastPoint)

    def NbP2d(*args):
        """
        NbP2d(AppDef_MultiLine ML) -> Standard_Integer

        Returns the number of 2d points of a MultiLine.

        :type ML: OCC.wrapper.AppDef.AppDef_MultiLine
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.AppDef_MyLineTool_NbP2d(*args)

    NbP2d = staticmethod(NbP2d)

    def NbP3d(*args):
        """
        NbP3d(AppDef_MultiLine ML) -> Standard_Integer

        Returns the number of 3d points of a MultiLine.

        :type ML: OCC.wrapper.AppDef.AppDef_MultiLine
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.AppDef_MyLineTool_NbP3d(*args)

    NbP3d = staticmethod(NbP3d)

    def Value(*args):
        """
        Value(AppDef_MultiLine ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Pnt tabPt)
        Value(AppDef_MultiLine ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Pnt2d tabPt2d)
        Value(AppDef_MultiLine ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Pnt tabPt, NCollection_Array1_gp_Pnt2d tabPt2d)

        returns the 3d and 2d points of the multipoint
        <MPointIndex>.

        :type ML: OCC.wrapper.AppDef.AppDef_MultiLine
        :type MPointIndex: int
        :type tabPt: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type tabPt2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        return _AppDef.AppDef_MyLineTool_Value(*args)

    Value = staticmethod(Value)

    def Tangency(*args):
        """
        Tangency(AppDef_MultiLine ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV) -> Standard_Boolean
        Tangency(AppDef_MultiLine ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean
        Tangency(AppDef_MultiLine ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean

        returns the 3d and 2d points of the multipoint
        <MPointIndex>.

        :type ML: OCC.wrapper.AppDef.AppDef_MultiLine
        :type MPointIndex: int
        :type tabV: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type tabV2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_MyLineTool_Tangency(*args)

    Tangency = staticmethod(Tangency)

    def Curvature(*args):
        """
        Curvature(AppDef_MultiLine ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV) -> Standard_Boolean
        Curvature(AppDef_MultiLine ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean
        Curvature(AppDef_MultiLine ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean

        returns the 3d and 2d curvatures of the multipoint
        <MPointIndex>.

        :type ML: OCC.wrapper.AppDef.AppDef_MultiLine
        :type MPointIndex: int
        :type tabV: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type tabV2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_MyLineTool_Curvature(*args)

    Curvature = staticmethod(Curvature)

    def WhatStatus(*args):
        """
        WhatStatus(AppDef_MultiLine ML, Standard_Integer const I1, Standard_Integer const I2) -> Approx_Status

        returns NoPointsAdded

        :type ML: OCC.wrapper.AppDef.AppDef_MultiLine
        :type I1: int
        :type I2: int
        :rtype: OCC.wrapper.Approx.Approx_Status

        """
        return _AppDef.AppDef_MyLineTool_WhatStatus(*args)

    WhatStatus = staticmethod(WhatStatus)

    def MakeMLBetween(*args):
        """
        MakeMLBetween(AppDef_MultiLine ML, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const NbPMin) -> AppDef_MultiLine

        Is never called in the algorithms.
        Nothing is done.

        :type ML: OCC.wrapper.AppDef.AppDef_MultiLine
        :type I1: int
        :type I2: int
        :type NbPMin: int
        :rtype: OCC.wrapper.AppDef.AppDef_MultiLine

        """
        return _AppDef.AppDef_MyLineTool_MakeMLBetween(*args)

    MakeMLBetween = staticmethod(MakeMLBetween)

    def MakeMLOneMorePoint(*args):
        """
        MakeMLOneMorePoint(AppDef_MultiLine ML, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const indbad, AppDef_MultiLine OtherLine) -> Standard_Boolean

        Is never called in the algorithms.
        Nothing is done.

        :type ML: OCC.wrapper.AppDef.AppDef_MultiLine
        :type I1: int
        :type I2: int
        :type indbad: int
        :type OtherLine: OCC.wrapper.AppDef.AppDef_MultiLine
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_MyLineTool_MakeMLOneMorePoint(*args)

    MakeMLOneMorePoint = staticmethod(MakeMLOneMorePoint)

    def __init__(self):
        """
        example of MultiLine tool corresponding to the tools of the packages
        AppParCurves and Approx. For Approx, the tool will not addd points
        if the algorithms want some.
        """
        this = _AppDef.new_AppDef_MyLineTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _AppDef.delete_AppDef_MyLineTool
AppDef_MyLineTool_swigregister = _AppDef.AppDef_MyLineTool_swigregister
AppDef_MyLineTool_swigregister(AppDef_MyLineTool)

def AppDef_MyLineTool_FirstPoint(*args):
    """
    AppDef_MyLineTool_FirstPoint(AppDef_MultiLine ML) -> Standard_Integer

    Returns the first index of multipoints of the MultiLine.

    :type ML: OCC.wrapper.AppDef.AppDef_MultiLine
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _AppDef.AppDef_MyLineTool_FirstPoint(*args)

def AppDef_MyLineTool_LastPoint(*args):
    """
    AppDef_MyLineTool_LastPoint(AppDef_MultiLine ML) -> Standard_Integer

    Returns the last index of multipoints of the MultiLine.

    :type ML: OCC.wrapper.AppDef.AppDef_MultiLine
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _AppDef.AppDef_MyLineTool_LastPoint(*args)

def AppDef_MyLineTool_NbP2d(*args):
    """
    AppDef_MyLineTool_NbP2d(AppDef_MultiLine ML) -> Standard_Integer

    Returns the number of 2d points of a MultiLine.

    :type ML: OCC.wrapper.AppDef.AppDef_MultiLine
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _AppDef.AppDef_MyLineTool_NbP2d(*args)

def AppDef_MyLineTool_NbP3d(*args):
    """
    AppDef_MyLineTool_NbP3d(AppDef_MultiLine ML) -> Standard_Integer

    Returns the number of 3d points of a MultiLine.

    :type ML: OCC.wrapper.AppDef.AppDef_MultiLine
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _AppDef.AppDef_MyLineTool_NbP3d(*args)

def AppDef_MyLineTool_Value(*args):
    """
    Value(AppDef_MultiLine ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Pnt tabPt)
    Value(AppDef_MultiLine ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Pnt2d tabPt2d)
    AppDef_MyLineTool_Value(AppDef_MultiLine ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Pnt tabPt, NCollection_Array1_gp_Pnt2d tabPt2d)

    returns the 3d and 2d points of the multipoint
    <MPointIndex>.

    :type ML: OCC.wrapper.AppDef.AppDef_MultiLine
    :type MPointIndex: int
    :type tabPt: OCC.wrapper.TColgp.TColgp_Array1OfPnt
    :type tabPt2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

    """
    return _AppDef.AppDef_MyLineTool_Value(*args)

def AppDef_MyLineTool_Tangency(*args):
    """
    Tangency(AppDef_MultiLine ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV) -> Standard_Boolean
    Tangency(AppDef_MultiLine ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean
    AppDef_MyLineTool_Tangency(AppDef_MultiLine ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean

    returns the 3d and 2d points of the multipoint
    <MPointIndex>.

    :type ML: OCC.wrapper.AppDef.AppDef_MultiLine
    :type MPointIndex: int
    :type tabV: OCC.wrapper.TColgp.TColgp_Array1OfVec
    :type tabV2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _AppDef.AppDef_MyLineTool_Tangency(*args)

def AppDef_MyLineTool_Curvature(*args):
    """
    Curvature(AppDef_MultiLine ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV) -> Standard_Boolean
    Curvature(AppDef_MultiLine ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean
    AppDef_MyLineTool_Curvature(AppDef_MultiLine ML, Standard_Integer const MPointIndex, NCollection_Array1_gp_Vec tabV, NCollection_Array1_gp_Vec2d tabV2d) -> Standard_Boolean

    returns the 3d and 2d curvatures of the multipoint
    <MPointIndex>.

    :type ML: OCC.wrapper.AppDef.AppDef_MultiLine
    :type MPointIndex: int
    :type tabV: OCC.wrapper.TColgp.TColgp_Array1OfVec
    :type tabV2d: OCC.wrapper.TColgp.TColgp_Array1OfVec2d
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _AppDef.AppDef_MyLineTool_Curvature(*args)

def AppDef_MyLineTool_WhatStatus(*args):
    """
    AppDef_MyLineTool_WhatStatus(AppDef_MultiLine ML, Standard_Integer const I1, Standard_Integer const I2) -> Approx_Status

    returns NoPointsAdded

    :type ML: OCC.wrapper.AppDef.AppDef_MultiLine
    :type I1: int
    :type I2: int
    :rtype: OCC.wrapper.Approx.Approx_Status

    """
    return _AppDef.AppDef_MyLineTool_WhatStatus(*args)

def AppDef_MyLineTool_MakeMLBetween(*args):
    """
    AppDef_MyLineTool_MakeMLBetween(AppDef_MultiLine ML, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const NbPMin) -> AppDef_MultiLine

    Is never called in the algorithms.
    Nothing is done.

    :type ML: OCC.wrapper.AppDef.AppDef_MultiLine
    :type I1: int
    :type I2: int
    :type NbPMin: int
    :rtype: OCC.wrapper.AppDef.AppDef_MultiLine

    """
    return _AppDef.AppDef_MyLineTool_MakeMLBetween(*args)

def AppDef_MyLineTool_MakeMLOneMorePoint(*args):
    """
    AppDef_MyLineTool_MakeMLOneMorePoint(AppDef_MultiLine ML, Standard_Integer const I1, Standard_Integer const I2, Standard_Integer const indbad, AppDef_MultiLine OtherLine) -> Standard_Boolean

    Is never called in the algorithms.
    Nothing is done.

    :type ML: OCC.wrapper.AppDef.AppDef_MultiLine
    :type I1: int
    :type I2: int
    :type indbad: int
    :type OtherLine: OCC.wrapper.AppDef.AppDef_MultiLine
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _AppDef.AppDef_MyLineTool_MakeMLOneMorePoint(*args)

class AppDef_ParFunctionOfMyGradientOfCompute(math.math_MultipleVarFunctionWithGradient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_ParFunctionOfMyGradientOfCompute self, AppDef_MultiLine SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, math_Vector Parameters, Standard_Integer const Deg) -> AppDef_ParFunctionOfMyGradientOfCompute

        initializes the fields of the function. The approximating
        curve has the desired degree Deg.

        :type SSP: OCC.wrapper.AppDef.AppDef_MultiLine
        :type FirstPoint: int
        :type LastPoint: int
        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Deg: int

        """
        this = _AppDef.new_AppDef_ParFunctionOfMyGradientOfCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(AppDef_ParFunctionOfMyGradientOfCompute self) -> Standard_Integer

        returns the number of variables of the function. It
        corresponds to the number of MultiPoints.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_NbVariables(self, *args)


    def Value(self, *args):
        """
        Value(AppDef_ParFunctionOfMyGradientOfCompute self, math_Vector X) -> Standard_Boolean

        this method computes the new approximation of the
        MultiLine
        SSP and calculates F = sum (||Pui - Bi*Pi||2) for each
        point of the MultiLine.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_Value(self, *args)


    def Gradient(self, *args):
        """
        Gradient(AppDef_ParFunctionOfMyGradientOfCompute self, math_Vector X, math_Vector G) -> Standard_Boolean

        returns the gradient G of the sum above for the
        parameters Xi.

        :type X: OCC.wrapper.math.math_Vector
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_Gradient(self, *args)


    def Values(self, *args):
        """
        Values(AppDef_ParFunctionOfMyGradientOfCompute self, math_Vector X, math_Vector G) -> Standard_Boolean

        returns the value F=sum(||Pui - Bi*Pi||)2.
        returns the value G = grad(F) for the parameters Xi.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_Values(self, *args)


    def NewParameters(self, *args):
        """
        returns the new parameters of the MultiLine.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_NewParameters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CurveValue(self, *args):
        """
        returns the MultiCurve approximating the set after
        computing the value F or Grad(F).

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        res = _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_CurveValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(AppDef_ParFunctionOfMyGradientOfCompute self, Standard_Integer const IPoint, Standard_Integer const CurveIndex) -> Standard_Real

        returns the distance between the MultiPoint of range
        IPoint and the curve CurveIndex.

        :type IPoint: int
        :type CurveIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_Error(self, *args)


    def MaxError3d(self, *args):
        """
        MaxError3d(AppDef_ParFunctionOfMyGradientOfCompute self) -> Standard_Real

        returns the maximum distance between the points
        and the MultiCurve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_MaxError3d(self, *args)


    def MaxError2d(self, *args):
        """
        MaxError2d(AppDef_ParFunctionOfMyGradientOfCompute self) -> Standard_Real

        returns the maximum distance between the points
        and the MultiCurve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_MaxError2d(self, *args)


    def FirstConstraint(self, *args):
        """
        FirstConstraint(AppDef_ParFunctionOfMyGradientOfCompute self, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, Standard_Integer const FirstPoint) -> AppParCurves_Constraint

        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type FirstPoint: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_FirstConstraint(self, *args)


    def LastConstraint(self, *args):
        """
        LastConstraint(AppDef_ParFunctionOfMyGradientOfCompute self, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, Standard_Integer const LastPoint) -> AppParCurves_Constraint

        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type LastPoint: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_LastConstraint(self, *args)

    __swig_destroy__ = _AppDef.delete_AppDef_ParFunctionOfMyGradientOfCompute
AppDef_ParFunctionOfMyGradientOfCompute_swigregister = _AppDef.AppDef_ParFunctionOfMyGradientOfCompute_swigregister
AppDef_ParFunctionOfMyGradientOfCompute_swigregister(AppDef_ParFunctionOfMyGradientOfCompute)

class AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute(math.math_BFGS):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute self, math_MultipleVarFunctionWithGradient F, math_Vector StartingPoint, Standard_Real const Tolerance3d, Standard_Real const Tolerance2d, Standard_Real const Eps, Standard_Integer const NbIterations=200) -> AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute

        :type F: OCC.wrapper.math.math_MultipleVarFunctionWithGradient
        :type StartingPoint: OCC.wrapper.math.math_Vector
        :type Tolerance3d: float
        :type Tolerance2d: float
        :type Eps: float
        :type NbIterations: int

        """
        this = _AppDef.new_AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsSolutionReached(self, *args):
        """
        IsSolutionReached(AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute self, math_MultipleVarFunctionWithGradient F) -> Standard_Boolean

        :type F: OCC.wrapper.math.math_MultipleVarFunctionWithGradient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute_IsSolutionReached(self, *args)

    __swig_destroy__ = _AppDef.delete_AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute
AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute_swigregister = _AppDef.AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute_swigregister
AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute_swigregister(AppDef_BSpGradient_BFGSOfMyBSplGradientOfBSplineCompute)

class Handle_AppDef_SmoothCriterion(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AppDef_SmoothCriterion self)

        Nullify the handle


        """
        return _AppDef.Handle_AppDef_SmoothCriterion_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AppDef_SmoothCriterion self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AppDef.Handle_AppDef_SmoothCriterion_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AppDef_SmoothCriterion self, AppDef_SmoothCriterion thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AppDef.Handle_AppDef_SmoothCriterion_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AppDef_SmoothCriterion self, Handle_AppDef_SmoothCriterion theHandle) -> Handle_AppDef_SmoothCriterion
        assign(Handle_AppDef_SmoothCriterion self, AppDef_SmoothCriterion thePtr) -> Handle_AppDef_SmoothCriterion
        assign(Handle_AppDef_SmoothCriterion self, Handle_AppDef_SmoothCriterion theHandle) -> Handle_AppDef_SmoothCriterion

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AppDef.Handle_AppDef_SmoothCriterion_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AppDef_SmoothCriterion self) -> AppDef_SmoothCriterion

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AppDef.Handle_AppDef_SmoothCriterion_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AppDef_SmoothCriterion self) -> AppDef_SmoothCriterion

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AppDef.Handle_AppDef_SmoothCriterion___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AppDef_SmoothCriterion self) -> AppDef_SmoothCriterion

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AppDef.Handle_AppDef_SmoothCriterion___ref__(self, *args)


    def __hash__(self):
        return _AppDef.Handle_AppDef_SmoothCriterion___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AppDef.Handle_AppDef_SmoothCriterion___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AppDef.new_Handle_AppDef_SmoothCriterion(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AppDef.Handle_AppDef_SmoothCriterion_DownCast)
    __swig_destroy__ = _AppDef.delete_Handle_AppDef_SmoothCriterion

    def SetParameters(self, *args):
        """
        SetParameters(Handle_AppDef_SmoothCriterion self, Handle_TColStd_HArray1OfReal Parameters)

        :type Parameters: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _AppDef.Handle_AppDef_SmoothCriterion_SetParameters(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(Handle_AppDef_SmoothCriterion self, Handle_FEmTool_Curve C)

        :type C: OCC.wrapper.FEmTool.Handle_FEmTool_Curve

        """
        return _AppDef.Handle_AppDef_SmoothCriterion_SetCurve(self, *args)


    def GetCurve(self, *args):
        """
        GetCurve(Handle_AppDef_SmoothCriterion self, Handle_FEmTool_Curve C)

        :type C: OCC.wrapper.FEmTool.Handle_FEmTool_Curve

        """
        return _AppDef.Handle_AppDef_SmoothCriterion_GetCurve(self, *args)


    def SetEstimation(self, *args):
        """
        SetEstimation(Handle_AppDef_SmoothCriterion self, Standard_Real const E1, Standard_Real const E2, Standard_Real const E3)

        :type E1: float
        :type E2: float
        :type E3: float

        """
        return _AppDef.Handle_AppDef_SmoothCriterion_SetEstimation(self, *args)


    def EstLength(self, *args):
        """
        EstLength(Handle_AppDef_SmoothCriterion self) -> Standard_Real &

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.Handle_AppDef_SmoothCriterion_EstLength(self, *args)


    def GetEstimation(self, *args):
        """
        GetEstimation(Handle_AppDef_SmoothCriterion self)

        :type E1: float
        :type E2: float
        :type E3: float

        """
        return _AppDef.Handle_AppDef_SmoothCriterion_GetEstimation(self, *args)


    def AssemblyTable(self, *args):
        """
        AssemblyTable(Handle_AppDef_SmoothCriterion self) -> Handle_FEmTool_HAssemblyTable

        :rtype: OCC.wrapper.FEmTool.Handle_FEmTool_HAssemblyTable

        """
        return _AppDef.Handle_AppDef_SmoothCriterion_AssemblyTable(self, *args)


    def DependenceTable(self, *args):
        """
        DependenceTable(Handle_AppDef_SmoothCriterion self) -> Handle_TColStd_HArray2OfInteger

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray2OfInteger

        """
        return _AppDef.Handle_AppDef_SmoothCriterion_DependenceTable(self, *args)


    def QualityValues(self, *args):
        """
        QualityValues(Handle_AppDef_SmoothCriterion self, Standard_Real const J1min, Standard_Real const J2min, Standard_Real const J3min) -> Standard_Integer

        :type J1min: float
        :type J2min: float
        :type J3min: float
        :type J1: float
        :type J2: float
        :type J3: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.Handle_AppDef_SmoothCriterion_QualityValues(self, *args)


    def ErrorValues(self, *args):
        """
        ErrorValues(Handle_AppDef_SmoothCriterion self)

        :type MaxError: float
        :type QuadraticError: float
        :type AverageError: float

        """
        return _AppDef.Handle_AppDef_SmoothCriterion_ErrorValues(self, *args)


    def Hessian(self, *args):
        """
        Hessian(Handle_AppDef_SmoothCriterion self, Standard_Integer const Element, Standard_Integer const Dimension1, Standard_Integer const Dimension2, math_Matrix H)

        :type Element: int
        :type Dimension1: int
        :type Dimension2: int
        :type H: OCC.wrapper.math.math_Matrix

        """
        return _AppDef.Handle_AppDef_SmoothCriterion_Hessian(self, *args)


    def Gradient(self, *args):
        """
        Gradient(Handle_AppDef_SmoothCriterion self, Standard_Integer const Element, Standard_Integer const Dimension, math_Vector G)

        :type Element: int
        :type Dimension: int
        :type G: OCC.wrapper.math.math_Vector

        """
        return _AppDef.Handle_AppDef_SmoothCriterion_Gradient(self, *args)


    def InputVector(self, *args):
        """
        InputVector(Handle_AppDef_SmoothCriterion self, math_Vector X, Handle_FEmTool_HAssemblyTable AssTable)

        Convert the assembly Vector in an Curve;

        :type X: OCC.wrapper.math.math_Vector
        :type AssTable: OCC.wrapper.FEmTool.Handle_FEmTool_HAssemblyTable

        """
        return _AppDef.Handle_AppDef_SmoothCriterion_InputVector(self, *args)


    def SetWeight(self, *args):
        """
        SetWeight(Handle_AppDef_SmoothCriterion self, Standard_Real const QuadraticWeight, Standard_Real const QualityWeight, Standard_Real const percentJ1, Standard_Real const percentJ2, Standard_Real const percentJ3)
        SetWeight(Handle_AppDef_SmoothCriterion self, NCollection_Array1_Standard_Real Weight)

        :type Weight: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _AppDef.Handle_AppDef_SmoothCriterion_SetWeight(self, *args)


    def GetWeight(self, *args):
        """
        GetWeight(Handle_AppDef_SmoothCriterion self)

        :type QuadraticWeight: float
        :type QualityWeight: float

        """
        return _AppDef.Handle_AppDef_SmoothCriterion_GetWeight(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AppDef_SmoothCriterion self) -> char const *

        :rtype: const char *

        """
        return _AppDef.Handle_AppDef_SmoothCriterion_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AppDef.Handle_AppDef_SmoothCriterion_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AppDef.Handle_AppDef_SmoothCriterion_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_AppDef_SmoothCriterion self)

        Memory deallocator for transient classes


        """
        return _AppDef.Handle_AppDef_SmoothCriterion_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AppDef_SmoothCriterion self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AppDef_SmoothCriterion self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.Handle_AppDef_SmoothCriterion_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AppDef_SmoothCriterion self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AppDef_SmoothCriterion self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.Handle_AppDef_SmoothCriterion_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AppDef_SmoothCriterion self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AppDef.Handle_AppDef_SmoothCriterion_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AppDef_SmoothCriterion self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.Handle_AppDef_SmoothCriterion_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AppDef_SmoothCriterion self)

        Increments the reference counter of this object


        """
        return _AppDef.Handle_AppDef_SmoothCriterion_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AppDef_SmoothCriterion self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.Handle_AppDef_SmoothCriterion_DecrementRefCounter(self, *args)

Handle_AppDef_SmoothCriterion_swigregister = _AppDef.Handle_AppDef_SmoothCriterion_swigregister
Handle_AppDef_SmoothCriterion_swigregister(Handle_AppDef_SmoothCriterion)

def Handle_AppDef_SmoothCriterion_DownCast(thing):
    return _AppDef.Handle_AppDef_SmoothCriterion_DownCast(thing)
Handle_AppDef_SmoothCriterion_DownCast = _AppDef.Handle_AppDef_SmoothCriterion_DownCast

class Handle_AppDef_HArray1OfMultiPointConstraint(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AppDef_HArray1OfMultiPointConstraint self)

        Nullify the handle


        """
        return _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AppDef_HArray1OfMultiPointConstraint self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AppDef_HArray1OfMultiPointConstraint self, AppDef_HArray1OfMultiPointConstraint thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AppDef_HArray1OfMultiPointConstraint self, Handle_AppDef_HArray1OfMultiPointConstraint theHandle) -> Handle_AppDef_HArray1OfMultiPointConstraint
        assign(Handle_AppDef_HArray1OfMultiPointConstraint self, AppDef_HArray1OfMultiPointConstraint thePtr) -> Handle_AppDef_HArray1OfMultiPointConstraint
        assign(Handle_AppDef_HArray1OfMultiPointConstraint self, Handle_AppDef_HArray1OfMultiPointConstraint theHandle) -> Handle_AppDef_HArray1OfMultiPointConstraint

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AppDef_HArray1OfMultiPointConstraint self) -> AppDef_HArray1OfMultiPointConstraint

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AppDef_HArray1OfMultiPointConstraint self) -> AppDef_HArray1OfMultiPointConstraint

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AppDef_HArray1OfMultiPointConstraint self) -> AppDef_HArray1OfMultiPointConstraint

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint___ref__(self, *args)


    def __hash__(self):
        return _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AppDef.new_Handle_AppDef_HArray1OfMultiPointConstraint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_DownCast)
    __swig_destroy__ = _AppDef.delete_Handle_AppDef_HArray1OfMultiPointConstraint

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.AppDef.AppDef_Array1OfMultiPointConstraint

        """
        res = _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_AppDef_HArray1OfMultiPointConstraint self) -> NCollection_Array1_AppDef_MultiPointConstraint

        :rtype: OCC.wrapper.AppDef.AppDef_Array1OfMultiPointConstraint

        """
        return _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AppDef_HArray1OfMultiPointConstraint self) -> char const *

        :rtype: const char *

        """
        return _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_AppDef_HArray1OfMultiPointConstraint self)

        Memory deallocator for transient classes


        """
        return _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AppDef_HArray1OfMultiPointConstraint self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AppDef_HArray1OfMultiPointConstraint self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AppDef_HArray1OfMultiPointConstraint self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AppDef_HArray1OfMultiPointConstraint self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AppDef_HArray1OfMultiPointConstraint self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AppDef_HArray1OfMultiPointConstraint self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AppDef_HArray1OfMultiPointConstraint self)

        Increments the reference counter of this object


        """
        return _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AppDef_HArray1OfMultiPointConstraint self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_DecrementRefCounter(self, *args)

Handle_AppDef_HArray1OfMultiPointConstraint_swigregister = _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_swigregister
Handle_AppDef_HArray1OfMultiPointConstraint_swigregister(Handle_AppDef_HArray1OfMultiPointConstraint)

def Handle_AppDef_HArray1OfMultiPointConstraint_DownCast(thing):
    return _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_DownCast(thing)
Handle_AppDef_HArray1OfMultiPointConstraint_DownCast = _AppDef.Handle_AppDef_HArray1OfMultiPointConstraint_DownCast

class AppDef_MultiLine(object):
    """
    This class describes the organized set of points used in the
    approximations. A MultiLine is composed of n
    MultiPointConstraints.
    The approximation of the MultiLine will be done in the order
    of the given n MultiPointConstraints.

    Example of a MultiLine composed of MultiPointConstraints:

    P1______P2_____P3______P4________........_____PNbMult

    Q1______Q2_____Q3______Q4________........_____QNbMult
    .                                               .
    .                                               .
    .                                               .
    R1______R2_____R3______R4________........_____RNbMult

    Pi, Qi, ..., Ri are points of dimension 2 or 3.

    (P1, Q1, ...R1), ...(Pn, Qn, ...Rn) n= 1,...NbMult are
    MultiPointConstraints.
    There are NbPoints points in each MultiPointConstraint.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_MultiLine self) -> AppDef_MultiLine
        __init__(AppDef_MultiLine self, Standard_Integer const NbMult) -> AppDef_MultiLine
        __init__(AppDef_MultiLine self, NCollection_Array1_AppDef_MultiPointConstraint tabMultiP) -> AppDef_MultiLine
        __init__(AppDef_MultiLine self, NCollection_Array1_gp_Pnt tabP3d) -> AppDef_MultiLine
        __init__(AppDef_MultiLine self, NCollection_Array1_gp_Pnt2d tabP2d) -> AppDef_MultiLine

        The MultiLine constructed will have one line of
        2d points without their tangencies.

        :type tabP2d: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        this = _AppDef.new_AppDef_MultiLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbMultiPoints(self, *args):
        """
        NbMultiPoints(AppDef_MultiLine self) -> Standard_Integer

        returns the number of MultiPointConstraints of the
        MultiLine.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.AppDef_MultiLine_NbMultiPoints(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(AppDef_MultiLine self) -> Standard_Integer

        returns the number of Points from MultiPoints composing
        the MultiLine.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.AppDef_MultiLine_NbPoints(self, *args)


    def SetValue(self, *args):
        """
        SetValue(AppDef_MultiLine self, Standard_Integer const Index, AppDef_MultiPointConstraint MPoint)

        It sets the MultiPointConstraint of range Index to the
        value MPoint.
        An exception is raised if Index < 0 or Index> MPoint.
        An exception is raised if the dimensions of the
        MultiPoints are different.

        :type Index: int
        :type MPoint: OCC.wrapper.AppDef.AppDef_MultiPointConstraint

        """
        return _AppDef.AppDef_MultiLine_SetValue(self, *args)


    def Value(self, *args):
        """
        Value(AppDef_MultiLine self, Standard_Integer const Index) -> AppDef_MultiPointConstraint

        returns the MultiPointConstraint of range Index
        An exception is raised if Index<0 or Index>MPoint.

        :type Index: int
        :rtype: OCC.wrapper.AppDef.AppDef_MultiPointConstraint

        """
        return _AppDef.AppDef_MultiLine_Value(self, *args)


    def Dump(self, *args):
        """
        Dump(AppDef_MultiLine self, Standard_OStream & o)

        Prints on the stream o information on the current
        state of the object.
        Is used to redefine the operator <<.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _AppDef.AppDef_MultiLine_Dump(self, *args)

    __swig_destroy__ = _AppDef.delete_AppDef_MultiLine
AppDef_MultiLine_swigregister = _AppDef.AppDef_MultiLine_swigregister
AppDef_MultiLine_swigregister(AppDef_MultiLine)

class AppDef_TheLeastSquares(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_TheLeastSquares self, AppDef_MultiLine SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, math_Vector Parameters, Standard_Integer const NbPol) -> AppDef_TheLeastSquares
        __init__(AppDef_TheLeastSquares self, AppDef_MultiLine SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, Standard_Integer const NbPol) -> AppDef_TheLeastSquares
        __init__(AppDef_TheLeastSquares self, AppDef_MultiLine SSP, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, math_Vector Parameters, Standard_Integer const NbPol) -> AppDef_TheLeastSquares
        __init__(AppDef_TheLeastSquares self, AppDef_MultiLine SSP, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, Standard_Integer const NbPol) -> AppDef_TheLeastSquares

        Initializes the fields of the object.

        :type SSP: OCC.wrapper.AppDef.AppDef_MultiLine
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type FirstPoint: int
        :type LastPoint: int
        :type FirstCons: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type LastCons: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type NbPol: int

        """
        this = _AppDef.new_AppDef_TheLeastSquares(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(AppDef_TheLeastSquares self, math_Vector Parameters)
        Perform(AppDef_TheLeastSquares self, math_Vector Parameters, Standard_Real const l1, Standard_Real const l2)
        Perform(AppDef_TheLeastSquares self, math_Vector Parameters, math_Vector V1t, math_Vector V2t, Standard_Real const l1, Standard_Real const l2)
        Perform(AppDef_TheLeastSquares self, math_Vector Parameters, math_Vector V1t, math_Vector V2t, math_Vector V1c, math_Vector V2c, Standard_Real const l1, Standard_Real const l2)

        Is used after having initialized the fields.
        <V1t> is the tangent vector at the first point.
        <V2t> is the tangent vector at the last point.
        <V1c> is the tangent vector at the first point.
        <V2c> is the tangent vector at the last point.

        :type Parameters: OCC.wrapper.math.math_Vector
        :type V1t: OCC.wrapper.math.math_Vector
        :type V2t: OCC.wrapper.math.math_Vector
        :type V1c: OCC.wrapper.math.math_Vector
        :type V2c: OCC.wrapper.math.math_Vector
        :type l1: float
        :type l2: float

        """
        return _AppDef.AppDef_TheLeastSquares_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(AppDef_TheLeastSquares self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_TheLeastSquares_IsDone(self, *args)


    def BezierValue(self, *args):
        """
        BezierValue(AppDef_TheLeastSquares self) -> AppParCurves_MultiCurve

        returns the result of the approximation, i.e. all the
        Curves.
        An exception is raised if NotDone.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        return _AppDef.AppDef_TheLeastSquares_BezierValue(self, *args)


    def BSplineValue(self, *args):
        """
        returns the result of the approximation, i.e. all the
        Curves.
        An exception is raised if NotDone.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        res = _AppDef.AppDef_TheLeastSquares_BSplineValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FunctionMatrix(self, *args):
        """
        returns the function matrix used to approximate the
        set.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_TheLeastSquares_FunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DerivativeFunctionMatrix(self, *args):
        """
        returns the derivative function matrix used
        to approximate the set.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_TheLeastSquares_DerivativeFunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ErrorGradient(self, *args):
        """
        ErrorGradient(AppDef_TheLeastSquares self, math_Vector Grad)

        returns the maximum errors between the MultiLine
        and the approximation curves. F is the sum of the square
        distances. Grad is the derivative vector of the
        function F.

        :type Grad: OCC.wrapper.math.math_Vector
        :type F: float
        :type MaxE3d: float
        :type MaxE2d: float

        """
        return _AppDef.AppDef_TheLeastSquares_ErrorGradient(self, *args)


    def Distance(self, *args):
        """
        returns the distances between the points of the
        multiline and the approximation curves.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_TheLeastSquares_Distance(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(AppDef_TheLeastSquares self)

        returns the maximum errors between the MultiLine
        and the approximation curves. F is the sum of the square
        distances.

        :type F: float
        :type MaxE3d: float
        :type MaxE2d: float

        """
        return _AppDef.AppDef_TheLeastSquares_Error(self, *args)


    def FirstLambda(self, *args):
        """
        FirstLambda(AppDef_TheLeastSquares self) -> Standard_Real

        returns the value (P2 - P1)/ V1 if the first point
        was a tangency point.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_TheLeastSquares_FirstLambda(self, *args)


    def LastLambda(self, *args):
        """
        LastLambda(AppDef_TheLeastSquares self) -> Standard_Real

        returns the value (PN - PN-1)/ VN if the last point
        was a tangency point.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_TheLeastSquares_LastLambda(self, *args)


    def Points(self, *args):
        """
        returns the matrix of points value.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_TheLeastSquares_Points(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Poles(self, *args):
        """
        returns the matrix of resulting control points value.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_TheLeastSquares_Poles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def KIndex(self, *args):
        """
        Returns the indexes of the first non null values of
        A and DA.
        The values are non null from Index(ieme point) +1
        to Index(ieme point) + degree +1.

        :rtype: OCC.wrapper.math.math_IntegerVector

        """
        res = _AppDef.AppDef_TheLeastSquares_KIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AppDef.delete_AppDef_TheLeastSquares
AppDef_TheLeastSquares_swigregister = _AppDef.AppDef_TheLeastSquares_swigregister
AppDef_TheLeastSquares_swigregister(AppDef_TheLeastSquares)

class AppDef_LinearCriteria(AppDef_SmoothCriterion):
    """
    defined an Linear Criteria to used in variational
    Smoothing of points.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_AppDef_LinearCriteria
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_AppDef_LinearCriteria(self) 
            return h


    def __init__(self, *args):
        """
        __init__(AppDef_LinearCriteria self, AppDef_MultiLine SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint) -> AppDef_LinearCriteria

        :type SSP: OCC.wrapper.AppDef.AppDef_MultiLine
        :type FirstPoint: int
        :type LastPoint: int

        """
        this = _AppDef.new_AppDef_LinearCriteria(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetParameters(self, *args):
        """
        SetParameters(AppDef_LinearCriteria self, Handle_TColStd_HArray1OfReal Parameters)

        :type Parameters: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _AppDef.AppDef_LinearCriteria_SetParameters(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(AppDef_LinearCriteria self, Handle_FEmTool_Curve C)

        :type C: OCC.wrapper.FEmTool.Handle_FEmTool_Curve

        """
        return _AppDef.AppDef_LinearCriteria_SetCurve(self, *args)


    def GetCurve(self, *args):
        """
        GetCurve(AppDef_LinearCriteria self, Handle_FEmTool_Curve C)

        :type C: OCC.wrapper.FEmTool.Handle_FEmTool_Curve

        """
        return _AppDef.AppDef_LinearCriteria_GetCurve(self, *args)


    def SetEstimation(self, *args):
        """
        SetEstimation(AppDef_LinearCriteria self, Standard_Real const E1, Standard_Real const E2, Standard_Real const E3)

        :type E1: float
        :type E2: float
        :type E3: float

        """
        return _AppDef.AppDef_LinearCriteria_SetEstimation(self, *args)


    def EstLength(self, *args):
        """
        EstLength(AppDef_LinearCriteria self) -> Standard_Real &

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_LinearCriteria_EstLength(self, *args)


    def GetEstimation(self, *args):
        """
        GetEstimation(AppDef_LinearCriteria self)

        :type E1: float
        :type E2: float
        :type E3: float

        """
        return _AppDef.AppDef_LinearCriteria_GetEstimation(self, *args)


    def AssemblyTable(self, *args):
        """
        AssemblyTable(AppDef_LinearCriteria self) -> Handle_FEmTool_HAssemblyTable

        :rtype: OCC.wrapper.FEmTool.Handle_FEmTool_HAssemblyTable

        """
        return _AppDef.AppDef_LinearCriteria_AssemblyTable(self, *args)


    def DependenceTable(self, *args):
        """
        DependenceTable(AppDef_LinearCriteria self) -> Handle_TColStd_HArray2OfInteger

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray2OfInteger

        """
        return _AppDef.AppDef_LinearCriteria_DependenceTable(self, *args)


    def QualityValues(self, *args):
        """
        QualityValues(AppDef_LinearCriteria self, Standard_Real const J1min, Standard_Real const J2min, Standard_Real const J3min) -> Standard_Integer

        :type J1min: float
        :type J2min: float
        :type J3min: float
        :type J1: float
        :type J2: float
        :type J3: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.AppDef_LinearCriteria_QualityValues(self, *args)


    def ErrorValues(self, *args):
        """
        ErrorValues(AppDef_LinearCriteria self)

        :type MaxError: float
        :type QuadraticError: float
        :type AverageError: float

        """
        return _AppDef.AppDef_LinearCriteria_ErrorValues(self, *args)


    def Hessian(self, *args):
        """
        Hessian(AppDef_LinearCriteria self, Standard_Integer const Element, Standard_Integer const Dimension1, Standard_Integer const Dimension2, math_Matrix H)

        :type Element: int
        :type Dimension1: int
        :type Dimension2: int
        :type H: OCC.wrapper.math.math_Matrix

        """
        return _AppDef.AppDef_LinearCriteria_Hessian(self, *args)


    def Gradient(self, *args):
        """
        Gradient(AppDef_LinearCriteria self, Standard_Integer const Element, Standard_Integer const Dimension, math_Vector G)

        :type Element: int
        :type Dimension: int
        :type G: OCC.wrapper.math.math_Vector

        """
        return _AppDef.AppDef_LinearCriteria_Gradient(self, *args)


    def InputVector(self, *args):
        """
        InputVector(AppDef_LinearCriteria self, math_Vector X, Handle_FEmTool_HAssemblyTable AssTable)

        Convert the assembly Vector in an Curve;

        :type X: OCC.wrapper.math.math_Vector
        :type AssTable: OCC.wrapper.FEmTool.Handle_FEmTool_HAssemblyTable

        """
        return _AppDef.AppDef_LinearCriteria_InputVector(self, *args)


    def GetWeight(self, *args):
        """
        GetWeight(AppDef_LinearCriteria self)

        :type QuadraticWeight: float
        :type QualityWeight: float

        """
        return _AppDef.AppDef_LinearCriteria_GetWeight(self, *args)


    def SetWeight(self, *args):
        """
        SetWeight(AppDef_LinearCriteria self, Standard_Real const QuadraticWeight, Standard_Real const QualityWeight, Standard_Real const percentJ1, Standard_Real const percentJ2, Standard_Real const percentJ3)
        SetWeight(AppDef_LinearCriteria self, NCollection_Array1_Standard_Real Weight)

        :type Weight: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _AppDef.AppDef_LinearCriteria_SetWeight(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _AppDef.AppDef_LinearCriteria_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _AppDef.AppDef_LinearCriteria_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AppDef.AppDef_LinearCriteria_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AppDef.delete_AppDef_LinearCriteria
AppDef_LinearCriteria_swigregister = _AppDef.AppDef_LinearCriteria_swigregister
AppDef_LinearCriteria_swigregister(AppDef_LinearCriteria)

def AppDef_LinearCriteria_get_type_name(*args):
    """
    AppDef_LinearCriteria_get_type_name() -> char const *

    :rtype: const char *

    """
    return _AppDef.AppDef_LinearCriteria_get_type_name(*args)

def AppDef_LinearCriteria_get_type_descriptor(*args):
    """
    AppDef_LinearCriteria_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _AppDef.AppDef_LinearCriteria_get_type_descriptor(*args)

class AppDef_Compute(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_Compute self, AppDef_MultiLine Line, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-3, Standard_Real const Tolerance2d=1.0e-6, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Approx_ParametrizationType const parametrization=Approx_ChordLength, Standard_Boolean const Squares) -> AppDef_Compute
        __init__(AppDef_Compute self, AppDef_MultiLine Line, math_Vector Parameters, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-03, Standard_Real const Tolerance2d=1.0e-06, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Standard_Boolean const Squares) -> AppDef_Compute
        __init__(AppDef_Compute self, math_Vector Parameters, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-03, Standard_Real const Tolerance2d=1.0e-06, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Standard_Boolean const Squares) -> AppDef_Compute
        __init__(AppDef_Compute self, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-03, Standard_Real const Tolerance2d=1.0e-06, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Approx_ParametrizationType const parametrization=Approx_ChordLength, Standard_Boolean const Squares) -> AppDef_Compute

        Initializes the fields of the algorithm.

        :type degreemin: int
        :type degreemax: int
        :type Tolerance3d: float
        :type Tolerance2d: float
        :type NbIterations: int
        :type cutting: bool
        :type parametrization: OCC.wrapper.Approx.Approx_ParametrizationType
        :type Squares: bool

        """
        this = _AppDef.new_AppDef_Compute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(AppDef_Compute self, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-03, Standard_Real const Tolerance2d=1.0e-06, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Approx_ParametrizationType const parametrization=Approx_ChordLength, Standard_Boolean const Squares)

        Initializes the fields of the algorithm.

        :type degreemin: int
        :type degreemax: int
        :type Tolerance3d: float
        :type Tolerance2d: float
        :type NbIterations: int
        :type cutting: bool
        :type parametrization: OCC.wrapper.Approx.Approx_ParametrizationType
        :type Squares: bool

        """
        return _AppDef.AppDef_Compute_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(AppDef_Compute self, AppDef_MultiLine Line)

        runs the algorithm after having initialized the fields.

        :type Line: OCC.wrapper.AppDef.AppDef_MultiLine

        """
        return _AppDef.AppDef_Compute_Perform(self, *args)


    def SetDegrees(self, *args):
        """
        SetDegrees(AppDef_Compute self, Standard_Integer const degreemin, Standard_Integer const degreemax)

        changes the degrees of the approximation.

        :type degreemin: int
        :type degreemax: int

        """
        return _AppDef.AppDef_Compute_SetDegrees(self, *args)


    def SetTolerances(self, *args):
        """
        SetTolerances(AppDef_Compute self, Standard_Real const Tolerance3d, Standard_Real const Tolerance2d)

        Changes the tolerances of the approximation.

        :type Tolerance3d: float
        :type Tolerance2d: float

        """
        return _AppDef.AppDef_Compute_SetTolerances(self, *args)


    def SetConstraints(self, *args):
        """
        SetConstraints(AppDef_Compute self, AppParCurves_Constraint const firstC, AppParCurves_Constraint const lastC)

        changes the first and the last constraint points.

        :type firstC: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type lastC: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _AppDef.AppDef_Compute_SetConstraints(self, *args)


    def IsAllApproximated(self, *args):
        """
        IsAllApproximated(AppDef_Compute self) -> Standard_Boolean

        returns False if at a moment of the approximation,
        the status NoApproximation has been sent by the user
        when more points were needed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_Compute_IsAllApproximated(self, *args)


    def IsToleranceReached(self, *args):
        """
        IsToleranceReached(AppDef_Compute self) -> Standard_Boolean

        returns False if the status NoPointsAdded has been sent.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_Compute_IsToleranceReached(self, *args)


    def Error(self, *args):
        """
        Error(AppDef_Compute self, Standard_Integer const Index)

        returns the tolerances 2d and 3d of the <Index> MultiCurve.

        :type Index: int
        :type tol3d: float
        :type tol2d: float

        """
        return _AppDef.AppDef_Compute_Error(self, *args)


    def NbMultiCurves(self, *args):
        """
        NbMultiCurves(AppDef_Compute self) -> Standard_Integer

        Returns the number of MultiCurve doing the approximation
        of the MultiLine.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.AppDef_Compute_NbMultiCurves(self, *args)


    def Value(self, *args):
        """
        returns the result of the approximation.

        :type Index: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        res = _AppDef.AppDef_Compute_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(AppDef_Compute self, Standard_Integer const Index=1) -> AppParCurves_MultiCurve

        returns the result of the approximation.

        :type Index: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        return _AppDef.AppDef_Compute_ChangeValue(self, *args)


    def SplineValue(self, *args):
        """
        returns the result of the approximation.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        res = _AppDef.AppDef_Compute_SplineValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Parametrization(self, *args):
        """
        Parametrization(AppDef_Compute self) -> Approx_ParametrizationType

        returns the type  of  parametrization

        :rtype: OCC.wrapper.Approx.Approx_ParametrizationType

        """
        return _AppDef.AppDef_Compute_Parametrization(self, *args)


    def Parameters(self, *args):
        """
        returns the new parameters of the approximation
        corresponding to the points of the multicurve <Index>.

        :type Index: int
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _AppDef.AppDef_Compute_Parameters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AppDef.delete_AppDef_Compute
AppDef_Compute_swigregister = _AppDef.AppDef_Compute_swigregister
AppDef_Compute_swigregister(AppDef_Compute)

class AppDef_ParLeastSquareOfMyGradientOfCompute(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_ParLeastSquareOfMyGradientOfCompute self, AppDef_MultiLine SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, math_Vector Parameters, Standard_Integer const NbPol) -> AppDef_ParLeastSquareOfMyGradientOfCompute
        __init__(AppDef_ParLeastSquareOfMyGradientOfCompute self, AppDef_MultiLine SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, Standard_Integer const NbPol) -> AppDef_ParLeastSquareOfMyGradientOfCompute
        __init__(AppDef_ParLeastSquareOfMyGradientOfCompute self, AppDef_MultiLine SSP, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, math_Vector Parameters, Standard_Integer const NbPol) -> AppDef_ParLeastSquareOfMyGradientOfCompute
        __init__(AppDef_ParLeastSquareOfMyGradientOfCompute self, AppDef_MultiLine SSP, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, Standard_Integer const NbPol) -> AppDef_ParLeastSquareOfMyGradientOfCompute

        Initializes the fields of the object.

        :type SSP: OCC.wrapper.AppDef.AppDef_MultiLine
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type FirstPoint: int
        :type LastPoint: int
        :type FirstCons: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type LastCons: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type NbPol: int

        """
        this = _AppDef.new_AppDef_ParLeastSquareOfMyGradientOfCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(AppDef_ParLeastSquareOfMyGradientOfCompute self, math_Vector Parameters)
        Perform(AppDef_ParLeastSquareOfMyGradientOfCompute self, math_Vector Parameters, Standard_Real const l1, Standard_Real const l2)
        Perform(AppDef_ParLeastSquareOfMyGradientOfCompute self, math_Vector Parameters, math_Vector V1t, math_Vector V2t, Standard_Real const l1, Standard_Real const l2)
        Perform(AppDef_ParLeastSquareOfMyGradientOfCompute self, math_Vector Parameters, math_Vector V1t, math_Vector V2t, math_Vector V1c, math_Vector V2c, Standard_Real const l1, Standard_Real const l2)

        Is used after having initialized the fields.
        <V1t> is the tangent vector at the first point.
        <V2t> is the tangent vector at the last point.
        <V1c> is the tangent vector at the first point.
        <V2c> is the tangent vector at the last point.

        :type Parameters: OCC.wrapper.math.math_Vector
        :type V1t: OCC.wrapper.math.math_Vector
        :type V2t: OCC.wrapper.math.math_Vector
        :type V1c: OCC.wrapper.math.math_Vector
        :type V2c: OCC.wrapper.math.math_Vector
        :type l1: float
        :type l2: float

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(AppDef_ParLeastSquareOfMyGradientOfCompute self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_IsDone(self, *args)


    def BezierValue(self, *args):
        """
        BezierValue(AppDef_ParLeastSquareOfMyGradientOfCompute self) -> AppParCurves_MultiCurve

        returns the result of the approximation, i.e. all the
        Curves.
        An exception is raised if NotDone.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_BezierValue(self, *args)


    def BSplineValue(self, *args):
        """
        returns the result of the approximation, i.e. all the
        Curves.
        An exception is raised if NotDone.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        res = _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_BSplineValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FunctionMatrix(self, *args):
        """
        returns the function matrix used to approximate the
        set.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_FunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DerivativeFunctionMatrix(self, *args):
        """
        returns the derivative function matrix used
        to approximate the set.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_DerivativeFunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ErrorGradient(self, *args):
        """
        ErrorGradient(AppDef_ParLeastSquareOfMyGradientOfCompute self, math_Vector Grad)

        returns the maximum errors between the MultiLine
        and the approximation curves. F is the sum of the square
        distances. Grad is the derivative vector of the
        function F.

        :type Grad: OCC.wrapper.math.math_Vector
        :type F: float
        :type MaxE3d: float
        :type MaxE2d: float

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_ErrorGradient(self, *args)


    def Distance(self, *args):
        """
        returns the distances between the points of the
        multiline and the approximation curves.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_Distance(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(AppDef_ParLeastSquareOfMyGradientOfCompute self)

        returns the maximum errors between the MultiLine
        and the approximation curves. F is the sum of the square
        distances.

        :type F: float
        :type MaxE3d: float
        :type MaxE2d: float

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_Error(self, *args)


    def FirstLambda(self, *args):
        """
        FirstLambda(AppDef_ParLeastSquareOfMyGradientOfCompute self) -> Standard_Real

        returns the value (P2 - P1)/ V1 if the first point
        was a tangency point.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_FirstLambda(self, *args)


    def LastLambda(self, *args):
        """
        LastLambda(AppDef_ParLeastSquareOfMyGradientOfCompute self) -> Standard_Real

        returns the value (PN - PN-1)/ VN if the last point
        was a tangency point.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_LastLambda(self, *args)


    def Points(self, *args):
        """
        returns the matrix of points value.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_Points(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Poles(self, *args):
        """
        returns the matrix of resulting control points value.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_Poles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def KIndex(self, *args):
        """
        Returns the indexes of the first non null values of
        A and DA.
        The values are non null from Index(ieme point) +1
        to Index(ieme point) + degree +1.

        :rtype: OCC.wrapper.math.math_IntegerVector

        """
        res = _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_KIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AppDef.delete_AppDef_ParLeastSquareOfMyGradientOfCompute
AppDef_ParLeastSquareOfMyGradientOfCompute_swigregister = _AppDef.AppDef_ParLeastSquareOfMyGradientOfCompute_swigregister
AppDef_ParLeastSquareOfMyGradientOfCompute_swigregister(AppDef_ParLeastSquareOfMyGradientOfCompute)

class AppDef_ResConstraintOfMyGradientOfCompute(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_ResConstraintOfMyGradientOfCompute self, AppDef_MultiLine SSP, AppParCurves_MultiCurve SCurv, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple Constraints, math_Matrix Bern, math_Matrix DerivativeBern, Standard_Real const Tolerance=1.0e-10) -> AppDef_ResConstraintOfMyGradientOfCompute

        Given a MultiLine SSP with constraints points, this
        algorithm finds the best curve solution to approximate it.
        The poles from SCurv issued for example from the least
        squares are used as a guess solution for the uzawa
        algorithm. The tolerance used in the Uzawa algorithms
        is Tolerance.
        A is the Bernstein matrix associated to the MultiLine
        and DA is the derivative bernstein matrix.(They can come
        from an approximation with ParLeastSquare.)
        The MultiCurve is modified. New MultiPoles are given.

        :type SSP: OCC.wrapper.AppDef.AppDef_MultiLine
        :type SCurv: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve
        :type FirstPoint: int
        :type LastPoint: int
        :type Constraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Bern: OCC.wrapper.math.math_Matrix
        :type DerivativeBern: OCC.wrapper.math.math_Matrix
        :type Tolerance: float

        """
        this = _AppDef.new_AppDef_ResConstraintOfMyGradientOfCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(AppDef_ResConstraintOfMyGradientOfCompute self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_ResConstraintOfMyGradientOfCompute_IsDone(self, *args)


    def ConstraintMatrix(self, *args):
        """
        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_ResConstraintOfMyGradientOfCompute_ConstraintMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Duale(self, *args):
        """
        returns the duale variables of the system.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _AppDef.AppDef_ResConstraintOfMyGradientOfCompute_Duale(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ConstraintDerivative(self, *args):
        """
        Returns the derivative of the constraint matrix.

        :type SSP: OCC.wrapper.AppDef.AppDef_MultiLine
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Deg: int
        :type DA: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_ResConstraintOfMyGradientOfCompute_ConstraintDerivative(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InverseMatrix(self, *args):
        """
        returns the Inverse of Cont*Transposed(Cont), where
        Cont is the constraint matrix for the algorithm.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_ResConstraintOfMyGradientOfCompute_InverseMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AppDef.delete_AppDef_ResConstraintOfMyGradientOfCompute
AppDef_ResConstraintOfMyGradientOfCompute_swigregister = _AppDef.AppDef_ResConstraintOfMyGradientOfCompute_swigregister
AppDef_ResConstraintOfMyGradientOfCompute_swigregister(AppDef_ResConstraintOfMyGradientOfCompute)

class AppDef_ParFunctionOfMyGradientbisOfBSplineCompute(math.math_MultipleVarFunctionWithGradient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_ParFunctionOfMyGradientbisOfBSplineCompute self, AppDef_MultiLine SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, math_Vector Parameters, Standard_Integer const Deg) -> AppDef_ParFunctionOfMyGradientbisOfBSplineCompute

        initializes the fields of the function. The approximating
        curve has the desired degree Deg.

        :type SSP: OCC.wrapper.AppDef.AppDef_MultiLine
        :type FirstPoint: int
        :type LastPoint: int
        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Deg: int

        """
        this = _AppDef.new_AppDef_ParFunctionOfMyGradientbisOfBSplineCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(AppDef_ParFunctionOfMyGradientbisOfBSplineCompute self) -> Standard_Integer

        returns the number of variables of the function. It
        corresponds to the number of MultiPoints.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_NbVariables(self, *args)


    def Value(self, *args):
        """
        Value(AppDef_ParFunctionOfMyGradientbisOfBSplineCompute self, math_Vector X) -> Standard_Boolean

        this method computes the new approximation of the
        MultiLine
        SSP and calculates F = sum (||Pui - Bi*Pi||2) for each
        point of the MultiLine.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_Value(self, *args)


    def Gradient(self, *args):
        """
        Gradient(AppDef_ParFunctionOfMyGradientbisOfBSplineCompute self, math_Vector X, math_Vector G) -> Standard_Boolean

        returns the gradient G of the sum above for the
        parameters Xi.

        :type X: OCC.wrapper.math.math_Vector
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_Gradient(self, *args)


    def Values(self, *args):
        """
        Values(AppDef_ParFunctionOfMyGradientbisOfBSplineCompute self, math_Vector X, math_Vector G) -> Standard_Boolean

        returns the value F=sum(||Pui - Bi*Pi||)2.
        returns the value G = grad(F) for the parameters Xi.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_Values(self, *args)


    def NewParameters(self, *args):
        """
        returns the new parameters of the MultiLine.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_NewParameters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CurveValue(self, *args):
        """
        returns the MultiCurve approximating the set after
        computing the value F or Grad(F).

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        res = _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_CurveValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(AppDef_ParFunctionOfMyGradientbisOfBSplineCompute self, Standard_Integer const IPoint, Standard_Integer const CurveIndex) -> Standard_Real

        returns the distance between the MultiPoint of range
        IPoint and the curve CurveIndex.

        :type IPoint: int
        :type CurveIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_Error(self, *args)


    def MaxError3d(self, *args):
        """
        MaxError3d(AppDef_ParFunctionOfMyGradientbisOfBSplineCompute self) -> Standard_Real

        returns the maximum distance between the points
        and the MultiCurve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_MaxError3d(self, *args)


    def MaxError2d(self, *args):
        """
        MaxError2d(AppDef_ParFunctionOfMyGradientbisOfBSplineCompute self) -> Standard_Real

        returns the maximum distance between the points
        and the MultiCurve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_MaxError2d(self, *args)


    def FirstConstraint(self, *args):
        """
        FirstConstraint(AppDef_ParFunctionOfMyGradientbisOfBSplineCompute self, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, Standard_Integer const FirstPoint) -> AppParCurves_Constraint

        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type FirstPoint: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_FirstConstraint(self, *args)


    def LastConstraint(self, *args):
        """
        LastConstraint(AppDef_ParFunctionOfMyGradientbisOfBSplineCompute self, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, Standard_Integer const LastPoint) -> AppParCurves_Constraint

        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type LastPoint: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_LastConstraint(self, *args)

    __swig_destroy__ = _AppDef.delete_AppDef_ParFunctionOfMyGradientbisOfBSplineCompute
AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_swigregister = _AppDef.AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_swigregister
AppDef_ParFunctionOfMyGradientbisOfBSplineCompute_swigregister(AppDef_ParFunctionOfMyGradientbisOfBSplineCompute)

class AppDef_TheGradient(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_TheGradient self, AppDef_MultiLine SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, math_Vector Parameters, Standard_Integer const Deg, Standard_Real const Tol3d, Standard_Real const Tol2d, Standard_Integer const NbIterations=200) -> AppDef_TheGradient

        Tries to minimize the sum (square(||Qui - Bi*Pi||))
        where Pui describe the approximating Bezier curves'Poles
        and Qi the MultiLine points with a parameter ui.
        In this algorithm, the parameters ui are the unknowns.
        The tolerance required on this sum is given by Tol.
        The desired degree of the resulting curve is Deg.

        :type SSP: OCC.wrapper.AppDef.AppDef_MultiLine
        :type FirstPoint: int
        :type LastPoint: int
        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Deg: int
        :type Tol3d: float
        :type Tol2d: float
        :type NbIterations: int

        """
        this = _AppDef.new_AppDef_TheGradient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(AppDef_TheGradient self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_TheGradient_IsDone(self, *args)


    def Value(self, *args):
        """
        Value(AppDef_TheGradient self) -> AppParCurves_MultiCurve

        returns all the Bezier curves approximating the
        MultiLine SSP after minimization of the parameter.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        return _AppDef.AppDef_TheGradient_Value(self, *args)


    def Error(self, *args):
        """
        Error(AppDef_TheGradient self, Standard_Integer const Index) -> Standard_Real

        returns the difference between the old and the new
        approximation.
        An exception is raised if NotDone.
        An exception is raised if Index<1 or Index>NbParameters.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_TheGradient_Error(self, *args)


    def MaxError3d(self, *args):
        """
        MaxError3d(AppDef_TheGradient self) -> Standard_Real

        returns the maximum difference between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_TheGradient_MaxError3d(self, *args)


    def MaxError2d(self, *args):
        """
        MaxError2d(AppDef_TheGradient self) -> Standard_Real

        returns the maximum difference between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_TheGradient_MaxError2d(self, *args)


    def AverageError(self, *args):
        """
        AverageError(AppDef_TheGradient self) -> Standard_Real

        returns the average error between the old and the
        new approximation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_TheGradient_AverageError(self, *args)

    __swig_destroy__ = _AppDef.delete_AppDef_TheGradient
AppDef_TheGradient_swigregister = _AppDef.AppDef_TheGradient_swigregister
AppDef_TheGradient_swigregister(AppDef_TheGradient)

class AppDef_BSplineCompute(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_BSplineCompute self, AppDef_MultiLine Line, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-3, Standard_Real const Tolerance2d=1.0e-6, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Approx_ParametrizationType const parametrization=Approx_ChordLength, Standard_Boolean const Squares) -> AppDef_BSplineCompute
        __init__(AppDef_BSplineCompute self, AppDef_MultiLine Line, math_Vector Parameters, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-03, Standard_Real const Tolerance2d=1.0e-06, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Standard_Boolean const Squares) -> AppDef_BSplineCompute
        __init__(AppDef_BSplineCompute self, math_Vector Parameters, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-03, Standard_Real const Tolerance2d=1.0e-06, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Standard_Boolean const Squares) -> AppDef_BSplineCompute
        __init__(AppDef_BSplineCompute self, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-03, Standard_Real const Tolerance2d=1.0e-06, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Approx_ParametrizationType const parametrization=Approx_ChordLength, Standard_Boolean const Squares) -> AppDef_BSplineCompute

        Initializes the fields of the algorithm.

        :type degreemin: int
        :type degreemax: int
        :type Tolerance3d: float
        :type Tolerance2d: float
        :type NbIterations: int
        :type cutting: bool
        :type parametrization: OCC.wrapper.Approx.Approx_ParametrizationType
        :type Squares: bool

        """
        this = _AppDef.new_AppDef_BSplineCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Interpol(self, *args):
        """
        Interpol(AppDef_BSplineCompute self, AppDef_MultiLine Line)

        Constructs an interpolation of the MultiLine <Line>
        The result will be a C2 curve of degree 3.

        :type Line: OCC.wrapper.AppDef.AppDef_MultiLine

        """
        return _AppDef.AppDef_BSplineCompute_Interpol(self, *args)


    def Init(self, *args):
        """
        Init(AppDef_BSplineCompute self, Standard_Integer const degreemin=4, Standard_Integer const degreemax=8, Standard_Real const Tolerance3d=1.0e-03, Standard_Real const Tolerance2d=1.0e-06, Standard_Integer const NbIterations=5, Standard_Boolean const cutting, Approx_ParametrizationType const parametrization=Approx_ChordLength, Standard_Boolean const Squares)

        Initializes the fields of the algorithm.

        :type degreemin: int
        :type degreemax: int
        :type Tolerance3d: float
        :type Tolerance2d: float
        :type NbIterations: int
        :type cutting: bool
        :type parametrization: OCC.wrapper.Approx.Approx_ParametrizationType
        :type Squares: bool

        """
        return _AppDef.AppDef_BSplineCompute_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(AppDef_BSplineCompute self, AppDef_MultiLine Line)

        runs the algorithm after having initialized the fields.

        :type Line: OCC.wrapper.AppDef.AppDef_MultiLine

        """
        return _AppDef.AppDef_BSplineCompute_Perform(self, *args)


    def SetParameters(self, *args):
        """
        SetParameters(AppDef_BSplineCompute self, math_Vector ThePar)

        The approximation will begin with the
        set of  parameters <ThePar>.

        :type ThePar: OCC.wrapper.math.math_Vector

        """
        return _AppDef.AppDef_BSplineCompute_SetParameters(self, *args)


    def SetKnots(self, *args):
        """
        SetKnots(AppDef_BSplineCompute self, NCollection_Array1_Standard_Real Knots)

        The approximation will be done with the
        set of knots <Knots>. The multiplicities will be set
        with the degree and the desired continuity.

        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _AppDef.AppDef_BSplineCompute_SetKnots(self, *args)


    def SetKnotsAndMultiplicities(self, *args):
        """
        SetKnotsAndMultiplicities(AppDef_BSplineCompute self, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults)

        The approximation will be done with the
        set of knots <Knots> and the multiplicities <Mults>.

        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _AppDef.AppDef_BSplineCompute_SetKnotsAndMultiplicities(self, *args)


    def SetDegrees(self, *args):
        """
        SetDegrees(AppDef_BSplineCompute self, Standard_Integer const degreemin, Standard_Integer const degreemax)

        changes the degrees of the approximation.

        :type degreemin: int
        :type degreemax: int

        """
        return _AppDef.AppDef_BSplineCompute_SetDegrees(self, *args)


    def SetTolerances(self, *args):
        """
        SetTolerances(AppDef_BSplineCompute self, Standard_Real const Tolerance3d, Standard_Real const Tolerance2d)

        Changes the tolerances of the approximation.

        :type Tolerance3d: float
        :type Tolerance2d: float

        """
        return _AppDef.AppDef_BSplineCompute_SetTolerances(self, *args)


    def SetContinuity(self, *args):
        """
        SetContinuity(AppDef_BSplineCompute self, Standard_Integer const C)

        sets the continuity of the spline.
        if C = 2, the spline will be C2.

        :type C: int

        """
        return _AppDef.AppDef_BSplineCompute_SetContinuity(self, *args)


    def SetConstraints(self, *args):
        """
        SetConstraints(AppDef_BSplineCompute self, AppParCurves_Constraint const firstC, AppParCurves_Constraint const lastC)

        changes the first and the last constraint points.

        :type firstC: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type lastC: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _AppDef.AppDef_BSplineCompute_SetConstraints(self, *args)


    def IsAllApproximated(self, *args):
        """
        IsAllApproximated(AppDef_BSplineCompute self) -> Standard_Boolean

        returns False if at a moment of the approximation,
        the status NoApproximation has been sent by the user
        when more points were needed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_BSplineCompute_IsAllApproximated(self, *args)


    def IsToleranceReached(self, *args):
        """
        IsToleranceReached(AppDef_BSplineCompute self) -> Standard_Boolean

        returns False if the status NoPointsAdded has been sent.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_BSplineCompute_IsToleranceReached(self, *args)


    def Error(self, *args):
        """
        Error(AppDef_BSplineCompute self)

        returns the tolerances 2d and 3d of the MultiBSpCurve.

        :type tol3d: float
        :type tol2d: float

        """
        return _AppDef.AppDef_BSplineCompute_Error(self, *args)


    def Value(self, *args):
        """
        returns the result of the approximation.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        res = _AppDef.AppDef_BSplineCompute_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(AppDef_BSplineCompute self) -> AppParCurves_MultiBSpCurve

        returns the result of the approximation.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        return _AppDef.AppDef_BSplineCompute_ChangeValue(self, *args)


    def Parameters(self, *args):
        """
        returns the new parameters of the approximation
        corresponding to the points of the MultiBSpCurve.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _AppDef.AppDef_BSplineCompute_Parameters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AppDef.delete_AppDef_BSplineCompute
AppDef_BSplineCompute_swigregister = _AppDef.AppDef_BSplineCompute_swigregister
AppDef_BSplineCompute_swigregister(AppDef_BSplineCompute)

class AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute(math.math_MultipleVarFunctionWithGradient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute self, AppDef_MultiLine SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, math_Vector Parameters, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const NbPol) -> AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute

        initializes the fields of the function. The approximating
        curve has <NbPol> control points.

        :type SSP: OCC.wrapper.AppDef.AppDef_MultiLine
        :type FirstPoint: int
        :type LastPoint: int
        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type NbPol: int

        """
        this = _AppDef.new_AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute self) -> Standard_Integer

        returns the number of variables of the function. It
        corresponds to the number of MultiPoints.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_NbVariables(self, *args)


    def Value(self, *args):
        """
        Value(AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute self, math_Vector X) -> Standard_Boolean

        this method computes the new approximation of the
        MultiLine
        SSP and calculates F = sum (||Pui - Bi*Pi||2) for each
        point of the MultiLine.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_Value(self, *args)


    def Gradient(self, *args):
        """
        Gradient(AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute self, math_Vector X, math_Vector G) -> Standard_Boolean

        returns the gradient G of the sum above for the
        parameters Xi.

        :type X: OCC.wrapper.math.math_Vector
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_Gradient(self, *args)


    def Values(self, *args):
        """
        Values(AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute self, math_Vector X, math_Vector G) -> Standard_Boolean

        returns the value F=sum(||Pui - Bi*Pi||)2.
        returns the value G = grad(F) for the parameters Xi.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_Values(self, *args)


    def NewParameters(self, *args):
        """
        returns the new parameters of the MultiLine.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_NewParameters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CurveValue(self, *args):
        """
        CurveValue(AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute self) -> AppParCurves_MultiBSpCurve

        returns the MultiBSpCurve approximating the set after
        computing the value F or Grad(F).

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_CurveValue(self, *args)


    def Error(self, *args):
        """
        Error(AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute self, Standard_Integer const IPoint, Standard_Integer const CurveIndex) -> Standard_Real

        returns the distance between the MultiPoint of range
        IPoint and the curve CurveIndex.

        :type IPoint: int
        :type CurveIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_Error(self, *args)


    def MaxError3d(self, *args):
        """
        MaxError3d(AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute self) -> Standard_Real

        returns the maximum distance between the points
        and the MultiBSpCurve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_MaxError3d(self, *args)


    def MaxError2d(self, *args):
        """
        MaxError2d(AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute self) -> Standard_Real

        returns the maximum distance between the points
        and the MultiBSpCurve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_MaxError2d(self, *args)


    def FunctionMatrix(self, *args):
        """
        returns the function matrix used to approximate the
        multiline.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_FunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DerivativeFunctionMatrix(self, *args):
        """
        returns the derivative function matrix used to approximate the
        multiline.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_DerivativeFunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Index(self, *args):
        """
        Returns the indexes of the first non null values of
        A and DA.
        The values are non null from Index(ieme point) +1
        to Index(ieme point) + degree +1.

        :rtype: OCC.wrapper.math.math_IntegerVector

        """
        res = _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_Index(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstConstraint(self, *args):
        """
        FirstConstraint(AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute self, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, Standard_Integer const FirstPoint) -> AppParCurves_Constraint

        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type FirstPoint: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_FirstConstraint(self, *args)


    def LastConstraint(self, *args):
        """
        LastConstraint(AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute self, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, Standard_Integer const LastPoint) -> AppParCurves_Constraint

        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type LastPoint: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_LastConstraint(self, *args)


    def SetFirstLambda(self, *args):
        """
        SetFirstLambda(AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute self, Standard_Real const l1)

        :type l1: float

        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_SetFirstLambda(self, *args)


    def SetLastLambda(self, *args):
        """
        SetLastLambda(AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute self, Standard_Real const l2)

        :type l2: float

        """
        return _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_SetLastLambda(self, *args)

    __swig_destroy__ = _AppDef.delete_AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute
AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_swigregister = _AppDef.AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_swigregister
AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute_swigregister(AppDef_BSpParFunctionOfMyBSplGradientOfBSplineCompute)

class AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute(math.math_BFGS):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute self, math_MultipleVarFunctionWithGradient F, math_Vector StartingPoint, Standard_Real const Tolerance3d, Standard_Real const Tolerance2d, Standard_Real const Eps, Standard_Integer const NbIterations=200) -> AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute

        :type F: OCC.wrapper.math.math_MultipleVarFunctionWithGradient
        :type StartingPoint: OCC.wrapper.math.math_Vector
        :type Tolerance3d: float
        :type Tolerance2d: float
        :type Eps: float
        :type NbIterations: int

        """
        this = _AppDef.new_AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsSolutionReached(self, *args):
        """
        IsSolutionReached(AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute self, math_MultipleVarFunctionWithGradient F) -> Standard_Boolean

        :type F: OCC.wrapper.math.math_MultipleVarFunctionWithGradient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute_IsSolutionReached(self, *args)

    __swig_destroy__ = _AppDef.delete_AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute
AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute_swigregister = _AppDef.AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute_swigregister
AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute_swigregister(AppDef_Gradient_BFGSOfMyGradientbisOfBSplineCompute)

class AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute self, AppDef_MultiLine SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, math_Vector Parameters, Standard_Integer const NbPol) -> AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute
        __init__(AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute self, AppDef_MultiLine SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, Standard_Integer const NbPol) -> AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute
        __init__(AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute self, AppDef_MultiLine SSP, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, math_Vector Parameters, Standard_Integer const NbPol) -> AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute
        __init__(AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute self, AppDef_MultiLine SSP, NCollection_Array1_Standard_Real Knots, NCollection_Array1_Standard_Integer Mults, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, AppParCurves_Constraint const FirstCons, AppParCurves_Constraint const LastCons, Standard_Integer const NbPol) -> AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute

        Initializes the fields of the object.

        :type SSP: OCC.wrapper.AppDef.AppDef_MultiLine
        :type Knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Mults: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type FirstPoint: int
        :type LastPoint: int
        :type FirstCons: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type LastCons: OCC.wrapper.AppParCurves.AppParCurves_Constraint
        :type NbPol: int

        """
        this = _AppDef.new_AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute self, math_Vector Parameters)
        Perform(AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute self, math_Vector Parameters, Standard_Real const l1, Standard_Real const l2)
        Perform(AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute self, math_Vector Parameters, math_Vector V1t, math_Vector V2t, Standard_Real const l1, Standard_Real const l2)
        Perform(AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute self, math_Vector Parameters, math_Vector V1t, math_Vector V2t, math_Vector V1c, math_Vector V2c, Standard_Real const l1, Standard_Real const l2)

        Is used after having initialized the fields.
        <V1t> is the tangent vector at the first point.
        <V2t> is the tangent vector at the last point.
        <V1c> is the tangent vector at the first point.
        <V2c> is the tangent vector at the last point.

        :type Parameters: OCC.wrapper.math.math_Vector
        :type V1t: OCC.wrapper.math.math_Vector
        :type V2t: OCC.wrapper.math.math_Vector
        :type V1c: OCC.wrapper.math.math_Vector
        :type V2c: OCC.wrapper.math.math_Vector
        :type l1: float
        :type l2: float

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_IsDone(self, *args)


    def BezierValue(self, *args):
        """
        BezierValue(AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute self) -> AppParCurves_MultiCurve

        returns the result of the approximation, i.e. all the
        Curves.
        An exception is raised if NotDone.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_BezierValue(self, *args)


    def BSplineValue(self, *args):
        """
        returns the result of the approximation, i.e. all the
        Curves.
        An exception is raised if NotDone.

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiBSpCurve

        """
        res = _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_BSplineValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FunctionMatrix(self, *args):
        """
        returns the function matrix used to approximate the
        set.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_FunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DerivativeFunctionMatrix(self, *args):
        """
        returns the derivative function matrix used
        to approximate the set.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_DerivativeFunctionMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ErrorGradient(self, *args):
        """
        ErrorGradient(AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute self, math_Vector Grad)

        returns the maximum errors between the MultiLine
        and the approximation curves. F is the sum of the square
        distances. Grad is the derivative vector of the
        function F.

        :type Grad: OCC.wrapper.math.math_Vector
        :type F: float
        :type MaxE3d: float
        :type MaxE2d: float

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_ErrorGradient(self, *args)


    def Distance(self, *args):
        """
        returns the distances between the points of the
        multiline and the approximation curves.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_Distance(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute self)

        returns the maximum errors between the MultiLine
        and the approximation curves. F is the sum of the square
        distances.

        :type F: float
        :type MaxE3d: float
        :type MaxE2d: float

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_Error(self, *args)


    def FirstLambda(self, *args):
        """
        FirstLambda(AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute self) -> Standard_Real

        returns the value (P2 - P1)/ V1 if the first point
        was a tangency point.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_FirstLambda(self, *args)


    def LastLambda(self, *args):
        """
        LastLambda(AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute self) -> Standard_Real

        returns the value (PN - PN-1)/ VN if the last point
        was a tangency point.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_LastLambda(self, *args)


    def Points(self, *args):
        """
        returns the matrix of points value.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_Points(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Poles(self, *args):
        """
        returns the matrix of resulting control points value.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_Poles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def KIndex(self, *args):
        """
        Returns the indexes of the first non null values of
        A and DA.
        The values are non null from Index(ieme point) +1
        to Index(ieme point) + degree +1.

        :rtype: OCC.wrapper.math.math_IntegerVector

        """
        res = _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_KIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AppDef.delete_AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute
AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_swigregister = _AppDef.AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_swigregister
AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute_swigregister(AppDef_ParLeastSquareOfMyGradientbisOfBSplineCompute)

class Handle_AppDef_LinearCriteria(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_AppDef_LinearCriteria self)

        Nullify the handle


        """
        return _AppDef.Handle_AppDef_LinearCriteria_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_AppDef_LinearCriteria self) -> bool

        Check for being null

        :rtype: bool

        """
        return _AppDef.Handle_AppDef_LinearCriteria_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_AppDef_LinearCriteria self, AppDef_LinearCriteria thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _AppDef.Handle_AppDef_LinearCriteria_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_AppDef_LinearCriteria self, Handle_AppDef_LinearCriteria theHandle) -> Handle_AppDef_LinearCriteria
        assign(Handle_AppDef_LinearCriteria self, AppDef_LinearCriteria thePtr) -> Handle_AppDef_LinearCriteria
        assign(Handle_AppDef_LinearCriteria self, Handle_AppDef_LinearCriteria theHandle) -> Handle_AppDef_LinearCriteria

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _AppDef.Handle_AppDef_LinearCriteria_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_AppDef_LinearCriteria self) -> AppDef_LinearCriteria

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _AppDef.Handle_AppDef_LinearCriteria_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_AppDef_LinearCriteria self) -> AppDef_LinearCriteria

        Member access operator (note non-const)

        :rtype: T *

        """
        return _AppDef.Handle_AppDef_LinearCriteria___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_AppDef_LinearCriteria self) -> AppDef_LinearCriteria

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _AppDef.Handle_AppDef_LinearCriteria___ref__(self, *args)


    def __hash__(self):
        return _AppDef.Handle_AppDef_LinearCriteria___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _AppDef.Handle_AppDef_LinearCriteria___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _AppDef.new_Handle_AppDef_LinearCriteria(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_AppDef.Handle_AppDef_LinearCriteria_DownCast)
    __swig_destroy__ = _AppDef.delete_Handle_AppDef_LinearCriteria

    def SetParameters(self, *args):
        """
        SetParameters(Handle_AppDef_LinearCriteria self, Handle_TColStd_HArray1OfReal Parameters)

        :type Parameters: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _AppDef.Handle_AppDef_LinearCriteria_SetParameters(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(Handle_AppDef_LinearCriteria self, Handle_FEmTool_Curve C)

        :type C: OCC.wrapper.FEmTool.Handle_FEmTool_Curve

        """
        return _AppDef.Handle_AppDef_LinearCriteria_SetCurve(self, *args)


    def GetCurve(self, *args):
        """
        GetCurve(Handle_AppDef_LinearCriteria self, Handle_FEmTool_Curve C)

        :type C: OCC.wrapper.FEmTool.Handle_FEmTool_Curve

        """
        return _AppDef.Handle_AppDef_LinearCriteria_GetCurve(self, *args)


    def SetEstimation(self, *args):
        """
        SetEstimation(Handle_AppDef_LinearCriteria self, Standard_Real const E1, Standard_Real const E2, Standard_Real const E3)

        :type E1: float
        :type E2: float
        :type E3: float

        """
        return _AppDef.Handle_AppDef_LinearCriteria_SetEstimation(self, *args)


    def EstLength(self, *args):
        """
        EstLength(Handle_AppDef_LinearCriteria self) -> Standard_Real &

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.Handle_AppDef_LinearCriteria_EstLength(self, *args)


    def GetEstimation(self, *args):
        """
        GetEstimation(Handle_AppDef_LinearCriteria self)

        :type E1: float
        :type E2: float
        :type E3: float

        """
        return _AppDef.Handle_AppDef_LinearCriteria_GetEstimation(self, *args)


    def AssemblyTable(self, *args):
        """
        AssemblyTable(Handle_AppDef_LinearCriteria self) -> Handle_FEmTool_HAssemblyTable

        :rtype: OCC.wrapper.FEmTool.Handle_FEmTool_HAssemblyTable

        """
        return _AppDef.Handle_AppDef_LinearCriteria_AssemblyTable(self, *args)


    def DependenceTable(self, *args):
        """
        DependenceTable(Handle_AppDef_LinearCriteria self) -> Handle_TColStd_HArray2OfInteger

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray2OfInteger

        """
        return _AppDef.Handle_AppDef_LinearCriteria_DependenceTable(self, *args)


    def QualityValues(self, *args):
        """
        QualityValues(Handle_AppDef_LinearCriteria self, Standard_Real const J1min, Standard_Real const J2min, Standard_Real const J3min) -> Standard_Integer

        :type J1min: float
        :type J2min: float
        :type J3min: float
        :type J1: float
        :type J2: float
        :type J3: float
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.Handle_AppDef_LinearCriteria_QualityValues(self, *args)


    def ErrorValues(self, *args):
        """
        ErrorValues(Handle_AppDef_LinearCriteria self)

        :type MaxError: float
        :type QuadraticError: float
        :type AverageError: float

        """
        return _AppDef.Handle_AppDef_LinearCriteria_ErrorValues(self, *args)


    def Hessian(self, *args):
        """
        Hessian(Handle_AppDef_LinearCriteria self, Standard_Integer const Element, Standard_Integer const Dimension1, Standard_Integer const Dimension2, math_Matrix H)

        :type Element: int
        :type Dimension1: int
        :type Dimension2: int
        :type H: OCC.wrapper.math.math_Matrix

        """
        return _AppDef.Handle_AppDef_LinearCriteria_Hessian(self, *args)


    def Gradient(self, *args):
        """
        Gradient(Handle_AppDef_LinearCriteria self, Standard_Integer const Element, Standard_Integer const Dimension, math_Vector G)

        :type Element: int
        :type Dimension: int
        :type G: OCC.wrapper.math.math_Vector

        """
        return _AppDef.Handle_AppDef_LinearCriteria_Gradient(self, *args)


    def InputVector(self, *args):
        """
        InputVector(Handle_AppDef_LinearCriteria self, math_Vector X, Handle_FEmTool_HAssemblyTable AssTable)

        Convert the assembly Vector in an Curve;

        :type X: OCC.wrapper.math.math_Vector
        :type AssTable: OCC.wrapper.FEmTool.Handle_FEmTool_HAssemblyTable

        """
        return _AppDef.Handle_AppDef_LinearCriteria_InputVector(self, *args)


    def SetWeight(self, *args):
        """
        SetWeight(Handle_AppDef_LinearCriteria self, Standard_Real const QuadraticWeight, Standard_Real const QualityWeight, Standard_Real const percentJ1, Standard_Real const percentJ2, Standard_Real const percentJ3)
        SetWeight(Handle_AppDef_LinearCriteria self, NCollection_Array1_Standard_Real Weight)

        :type Weight: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _AppDef.Handle_AppDef_LinearCriteria_SetWeight(self, *args)


    def GetWeight(self, *args):
        """
        GetWeight(Handle_AppDef_LinearCriteria self)

        :type QuadraticWeight: float
        :type QualityWeight: float

        """
        return _AppDef.Handle_AppDef_LinearCriteria_GetWeight(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_AppDef_LinearCriteria self) -> char const *

        :rtype: const char *

        """
        return _AppDef.Handle_AppDef_LinearCriteria_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AppDef.Handle_AppDef_LinearCriteria_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _AppDef.Handle_AppDef_LinearCriteria_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_AppDef_LinearCriteria self)

        Memory deallocator for transient classes


        """
        return _AppDef.Handle_AppDef_LinearCriteria_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_AppDef_LinearCriteria self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_AppDef_LinearCriteria self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.Handle_AppDef_LinearCriteria_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_AppDef_LinearCriteria self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_AppDef_LinearCriteria self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.Handle_AppDef_LinearCriteria_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_AppDef_LinearCriteria self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _AppDef.Handle_AppDef_LinearCriteria_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_AppDef_LinearCriteria self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.Handle_AppDef_LinearCriteria_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_AppDef_LinearCriteria self)

        Increments the reference counter of this object


        """
        return _AppDef.Handle_AppDef_LinearCriteria_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_AppDef_LinearCriteria self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.Handle_AppDef_LinearCriteria_DecrementRefCounter(self, *args)

Handle_AppDef_LinearCriteria_swigregister = _AppDef.Handle_AppDef_LinearCriteria_swigregister
Handle_AppDef_LinearCriteria_swigregister(Handle_AppDef_LinearCriteria)

def Handle_AppDef_LinearCriteria_DownCast(thing):
    return _AppDef.Handle_AppDef_LinearCriteria_DownCast(thing)
Handle_AppDef_LinearCriteria_DownCast = _AppDef.Handle_AppDef_LinearCriteria_DownCast

class AppDef_TheResol(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_TheResol self, AppDef_MultiLine SSP, AppParCurves_MultiCurve SCurv, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple Constraints, math_Matrix Bern, math_Matrix DerivativeBern, Standard_Real const Tolerance=1.0e-10) -> AppDef_TheResol

        Given a MultiLine SSP with constraints points, this
        algorithm finds the best curve solution to approximate it.
        The poles from SCurv issued for example from the least
        squares are used as a guess solution for the uzawa
        algorithm. The tolerance used in the Uzawa algorithms
        is Tolerance.
        A is the Bernstein matrix associated to the MultiLine
        and DA is the derivative bernstein matrix.(They can come
        from an approximation with ParLeastSquare.)
        The MultiCurve is modified. New MultiPoles are given.

        :type SSP: OCC.wrapper.AppDef.AppDef_MultiLine
        :type SCurv: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve
        :type FirstPoint: int
        :type LastPoint: int
        :type Constraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Bern: OCC.wrapper.math.math_Matrix
        :type DerivativeBern: OCC.wrapper.math.math_Matrix
        :type Tolerance: float

        """
        this = _AppDef.new_AppDef_TheResol(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(AppDef_TheResol self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_TheResol_IsDone(self, *args)


    def ConstraintMatrix(self, *args):
        """
        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_TheResol_ConstraintMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Duale(self, *args):
        """
        returns the duale variables of the system.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _AppDef.AppDef_TheResol_Duale(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ConstraintDerivative(self, *args):
        """
        Returns the derivative of the constraint matrix.

        :type SSP: OCC.wrapper.AppDef.AppDef_MultiLine
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Deg: int
        :type DA: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_TheResol_ConstraintDerivative(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InverseMatrix(self, *args):
        """
        returns the Inverse of Cont*Transposed(Cont), where
        Cont is the constraint matrix for the algorithm.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_TheResol_InverseMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AppDef.delete_AppDef_TheResol
AppDef_TheResol_swigregister = _AppDef.AppDef_TheResol_swigregister
AppDef_TheResol_swigregister(AppDef_TheResol)

class AppDef_TheFunction(math.math_MultipleVarFunctionWithGradient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_TheFunction self, AppDef_MultiLine SSP, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, math_Vector Parameters, Standard_Integer const Deg) -> AppDef_TheFunction

        initializes the fields of the function. The approximating
        curve has the desired degree Deg.

        :type SSP: OCC.wrapper.AppDef.AppDef_MultiLine
        :type FirstPoint: int
        :type LastPoint: int
        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Deg: int

        """
        this = _AppDef.new_AppDef_TheFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(AppDef_TheFunction self) -> Standard_Integer

        returns the number of variables of the function. It
        corresponds to the number of MultiPoints.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _AppDef.AppDef_TheFunction_NbVariables(self, *args)


    def Value(self, *args):
        """
        Value(AppDef_TheFunction self, math_Vector X) -> Standard_Boolean

        this method computes the new approximation of the
        MultiLine
        SSP and calculates F = sum (||Pui - Bi*Pi||2) for each
        point of the MultiLine.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_TheFunction_Value(self, *args)


    def Gradient(self, *args):
        """
        Gradient(AppDef_TheFunction self, math_Vector X, math_Vector G) -> Standard_Boolean

        returns the gradient G of the sum above for the
        parameters Xi.

        :type X: OCC.wrapper.math.math_Vector
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_TheFunction_Gradient(self, *args)


    def Values(self, *args):
        """
        Values(AppDef_TheFunction self, math_Vector X, math_Vector G) -> Standard_Boolean

        returns the value F=sum(||Pui - Bi*Pi||)2.
        returns the value G = grad(F) for the parameters Xi.

        :type X: OCC.wrapper.math.math_Vector
        :type F: float
        :type G: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_TheFunction_Values(self, *args)


    def NewParameters(self, *args):
        """
        returns the new parameters of the MultiLine.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _AppDef.AppDef_TheFunction_NewParameters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CurveValue(self, *args):
        """
        returns the MultiCurve approximating the set after
        computing the value F or Grad(F).

        :rtype: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve

        """
        res = _AppDef.AppDef_TheFunction_CurveValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Error(self, *args):
        """
        Error(AppDef_TheFunction self, Standard_Integer const IPoint, Standard_Integer const CurveIndex) -> Standard_Real

        returns the distance between the MultiPoint of range
        IPoint and the curve CurveIndex.

        :type IPoint: int
        :type CurveIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_TheFunction_Error(self, *args)


    def MaxError3d(self, *args):
        """
        MaxError3d(AppDef_TheFunction self) -> Standard_Real

        returns the maximum distance between the points
        and the MultiCurve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_TheFunction_MaxError3d(self, *args)


    def MaxError2d(self, *args):
        """
        MaxError2d(AppDef_TheFunction self) -> Standard_Real

        returns the maximum distance between the points
        and the MultiCurve.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _AppDef.AppDef_TheFunction_MaxError2d(self, *args)


    def FirstConstraint(self, *args):
        """
        FirstConstraint(AppDef_TheFunction self, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, Standard_Integer const FirstPoint) -> AppParCurves_Constraint

        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type FirstPoint: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _AppDef.AppDef_TheFunction_FirstConstraint(self, *args)


    def LastConstraint(self, *args):
        """
        LastConstraint(AppDef_TheFunction self, Handle_AppParCurves_HArray1OfConstraintCouple TheConstraints, Standard_Integer const LastPoint) -> AppParCurves_Constraint

        :type TheConstraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type LastPoint: int
        :rtype: OCC.wrapper.AppParCurves.AppParCurves_Constraint

        """
        return _AppDef.AppDef_TheFunction_LastConstraint(self, *args)

    __swig_destroy__ = _AppDef.delete_AppDef_TheFunction
AppDef_TheFunction_swigregister = _AppDef.AppDef_TheFunction_swigregister
AppDef_TheFunction_swigregister(AppDef_TheFunction)

class AppDef_ResConstraintOfTheGradient(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(AppDef_ResConstraintOfTheGradient self, AppDef_MultiLine SSP, AppParCurves_MultiCurve SCurv, Standard_Integer const FirstPoint, Standard_Integer const LastPoint, Handle_AppParCurves_HArray1OfConstraintCouple Constraints, math_Matrix Bern, math_Matrix DerivativeBern, Standard_Real const Tolerance=1.0e-10) -> AppDef_ResConstraintOfTheGradient

        Given a MultiLine SSP with constraints points, this
        algorithm finds the best curve solution to approximate it.
        The poles from SCurv issued for example from the least
        squares are used as a guess solution for the uzawa
        algorithm. The tolerance used in the Uzawa algorithms
        is Tolerance.
        A is the Bernstein matrix associated to the MultiLine
        and DA is the derivative bernstein matrix.(They can come
        from an approximation with ParLeastSquare.)
        The MultiCurve is modified. New MultiPoles are given.

        :type SSP: OCC.wrapper.AppDef.AppDef_MultiLine
        :type SCurv: OCC.wrapper.AppParCurves.AppParCurves_MultiCurve
        :type FirstPoint: int
        :type LastPoint: int
        :type Constraints: OCC.wrapper.AppParCurves.Handle_AppParCurves_HArray1OfConstraintCouple
        :type Bern: OCC.wrapper.math.math_Matrix
        :type DerivativeBern: OCC.wrapper.math.math_Matrix
        :type Tolerance: float

        """
        this = _AppDef.new_AppDef_ResConstraintOfTheGradient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(AppDef_ResConstraintOfTheGradient self) -> Standard_Boolean

        returns True if all has been correctly done.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _AppDef.AppDef_ResConstraintOfTheGradient_IsDone(self, *args)


    def ConstraintMatrix(self, *args):
        """
        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_ResConstraintOfTheGradient_ConstraintMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Duale(self, *args):
        """
        returns the duale variables of the system.

        :rtype: OCC.wrapper.math.math_Vector

        """
        res = _AppDef.AppDef_ResConstraintOfTheGradient_Duale(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ConstraintDerivative(self, *args):
        """
        Returns the derivative of the constraint matrix.

        :type SSP: OCC.wrapper.AppDef.AppDef_MultiLine
        :type Parameters: OCC.wrapper.math.math_Vector
        :type Deg: int
        :type DA: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_ResConstraintOfTheGradient_ConstraintDerivative(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InverseMatrix(self, *args):
        """
        returns the Inverse of Cont*Transposed(Cont), where
        Cont is the constraint matrix for the algorithm.

        :rtype: OCC.wrapper.math.math_Matrix

        """
        res = _AppDef.AppDef_ResConstraintOfTheGradient_InverseMatrix(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _AppDef.delete_AppDef_ResConstraintOfTheGradient
AppDef_ResConstraintOfTheGradient_swigregister = _AppDef.AppDef_ResConstraintOfTheGradient_swigregister
AppDef_ResConstraintOfTheGradient_swigregister(AppDef_ResConstraintOfTheGradient)




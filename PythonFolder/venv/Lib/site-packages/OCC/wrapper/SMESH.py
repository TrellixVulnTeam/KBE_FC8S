# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_SMESH')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_SMESH')
    _SMESH = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_SMESH', [dirname(__file__)])
        except ImportError:
            import _SMESH
            return _SMESH
        try:
            _mod = imp.load_module('_SMESH', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _SMESH = swig_import_helper()
    del swig_import_helper
else:
    import _SMESH
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _SMESH.delete_SwigPyIterator

    def value(self):
        return _SMESH.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _SMESH.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _SMESH.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _SMESH.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _SMESH.SwigPyIterator_equal(self, x)

    def copy(self):
        return _SMESH.SwigPyIterator_copy(self)

    def next(self):
        return _SMESH.SwigPyIterator_next(self)

    def __next__(self):
        return _SMESH.SwigPyIterator___next__(self)

    def previous(self):
        return _SMESH.SwigPyIterator_previous(self)

    def advance(self, n):
        return _SMESH.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _SMESH.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _SMESH.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _SMESH.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _SMESH.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _SMESH.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _SMESH.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _SMESH.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _SMESH.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_SMESH.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _SMESH.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _SMESH.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SMESH.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _SMESH.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _SMESH.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _SMESH.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _SMESH.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_SMESH.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _SMESH.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _SMESH.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SMESH.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _SMESH.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _SMESH.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _SMESH.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _SMESH.ptr_to_number(item)
ptr_to_number = _SMESH.ptr_to_number

def HashCode(*args):
    return _SMESH.HashCode(*args)
HashCode = _SMESH.HashCode

def ptr_equal(a, b):
    return _SMESH.ptr_equal(a, b)
ptr_equal = _SMESH.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepMesh
else:
    import BRepMesh
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import SMDSAbs
else:
    import SMDSAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ShapeAnalysis
else:
    import ShapeAnalysis
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntRes2d
else:
    import IntRes2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ShapeExtend
else:
    import ShapeExtend
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColGeom
else:
    import TColGeom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAPI
else:
    import GeomAPI
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Approx
else:
    import Approx
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppCont
else:
    import AppCont
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppParCurves
else:
    import AppParCurves
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AdvApprox
else:
    import AdvApprox
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PLib
else:
    import PLib
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Extrema
else:
    import Extrema
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import MeshVS
else:
    import MeshVS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import SelectBasics
else:
    import SelectBasics
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Select3D
else:
    import Select3D
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BVH
else:
    import BVH
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Graphic3d
else:
    import Graphic3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Image
else:
    import Image
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Aspect
else:
    import Aspect
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Font
else:
    import Font
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import SelectMgr
else:
    import SelectMgr
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PrsMgr
else:
    import PrsMgr
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import V3d
else:
    import V3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Prs3d
else:
    import Prs3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import HLRAlgo
else:
    import HLRAlgo
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AIS
else:
    import AIS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import DsgPrs
else:
    import DsgPrs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StdSelect
else:
    import StdSelect
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import SMESHDS
else:
    import SMESHDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import SMDS
else:
    import SMDS
del _swig_python_version_info
COMPERR_OK = _SMESH.COMPERR_OK
COMPERR_BAD_INPUT_MESH = _SMESH.COMPERR_BAD_INPUT_MESH
COMPERR_STD_EXCEPTION = _SMESH.COMPERR_STD_EXCEPTION
COMPERR_OCC_EXCEPTION = _SMESH.COMPERR_OCC_EXCEPTION
COMPERR_SLM_EXCEPTION = _SMESH.COMPERR_SLM_EXCEPTION
COMPERR_EXCEPTION = _SMESH.COMPERR_EXCEPTION
COMPERR_MEMORY_PB = _SMESH.COMPERR_MEMORY_PB
COMPERR_ALGO_FAILED = _SMESH.COMPERR_ALGO_FAILED
COMPERR_BAD_SHAPE = _SMESH.COMPERR_BAD_SHAPE
COMPERR_WARNING = _SMESH.COMPERR_WARNING
COMPERR_CANCELED = _SMESH.COMPERR_CANCELED
COMPERR_NO_MESH_ON_SHAPE = _SMESH.COMPERR_NO_MESH_ON_SHAPE
COMPERR_BAD_PARMETERS = _SMESH.COMPERR_BAD_PARMETERS
COMPERR_LAST_ALGO_ERROR = _SMESH.COMPERR_LAST_ALGO_ERROR
EDITERR_NO_MEDIUM_ON_GEOM = _SMESH.EDITERR_NO_MEDIUM_ON_GEOM
MeshDim_0D = _SMESH.MeshDim_0D
MeshDim_1D = _SMESH.MeshDim_1D
MeshDim_2D = _SMESH.MeshDim_2D
MeshDim_3D = _SMESH.MeshDim_3D
class SMESH_VisualObj(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Update(self, *args):
        """
        Update(SMESH_VisualObj self, int theIsClear=True) -> bool

        :type theIsClear: int
        :rtype: bool

        """
        return _SMESH.SMESH_VisualObj_Update(self, *args)


    def NulData(self, *args):
        """
        NulData(SMESH_VisualObj self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_VisualObj_NulData(self, *args)


    def UpdateFunctor(self, *args):
        """
        UpdateFunctor(SMESH_VisualObj self, SMESH::Controls::FunctorPtr const & theFunctor)

        :type theFunctor: FunctorPtr

        """
        return _SMESH.SMESH_VisualObj_UpdateFunctor(self, *args)


    def GetElemDimension(self, *args):
        """
        GetElemDimension(SMESH_VisualObj self, int const theObjId) -> int

        :type theObjId: const int
        :rtype: int

        """
        return _SMESH.SMESH_VisualObj_GetElemDimension(self, *args)


    def GetNbEntities(self, *args):
        """
        GetNbEntities(SMESH_VisualObj self, SMDSAbs_ElementType const theType) -> int

        :type theType: OCC.wrapper.SMDSAbs.SMDSAbs_ElementType
        :rtype: int

        """
        return _SMESH.SMESH_VisualObj_GetNbEntities(self, *args)


    def GetMesh(self, *args):
        """
        GetMesh(SMESH_VisualObj self) -> SMDS_Mesh

        :rtype: OCC.wrapper.SMDS.SMDS_Mesh

        """
        return _SMESH.SMESH_VisualObj_GetMesh(self, *args)


    def GetMeshServer(self, *args):
        """
        GetMeshServer(SMESH_VisualObj self) -> SMESH::SMESH_Mesh_ptr

        :rtype: OCC.wrapper.SMESH.SMESH_Mesh_ptr

        """
        return _SMESH.SMESH_VisualObj_GetMeshServer(self, *args)


    def GetEdgeNodes(self, *args):
        """
        GetEdgeNodes(SMESH_VisualObj self, int const theElemId, int const theEdgeNum) -> bool

        :type theElemId: const int
        :type theEdgeNum: const int
        :type theNodeId1: int &
        :type theNodeId2: int &
        :rtype: bool

        """
        return _SMESH.SMESH_VisualObj_GetEdgeNodes(self, *args)


    def IsValid(self, *args):
        """
        IsValid(SMESH_VisualObj self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_VisualObj_IsValid(self, *args)


    def GetUnstructuredGrid(self, *args):
        """
        GetUnstructuredGrid(SMESH_VisualObj self) -> vtkUnstructuredGrid *

        :rtype: vtkUnstructuredGrid

        """
        return _SMESH.SMESH_VisualObj_GetUnstructuredGrid(self, *args)


    def GetNodeObjId(self, *args):
        """
        GetNodeObjId(SMESH_VisualObj self, int theVTKID) -> vtkIdType

        :type theVTKID: int
        :rtype: vtkIdType

        """
        return _SMESH.SMESH_VisualObj_GetNodeObjId(self, *args)


    def GetNodeVTKId(self, *args):
        """
        GetNodeVTKId(SMESH_VisualObj self, int theObjID) -> vtkIdType

        :type theObjID: int
        :rtype: vtkIdType

        """
        return _SMESH.SMESH_VisualObj_GetNodeVTKId(self, *args)


    def GetElemObjId(self, *args):
        """
        GetElemObjId(SMESH_VisualObj self, int theVTKID) -> vtkIdType

        :type theVTKID: int
        :rtype: vtkIdType

        """
        return _SMESH.SMESH_VisualObj_GetElemObjId(self, *args)


    def GetElemVTKId(self, *args):
        """
        GetElemVTKId(SMESH_VisualObj self, int theObjID) -> vtkIdType

        :type theObjID: int
        :rtype: vtkIdType

        """
        return _SMESH.SMESH_VisualObj_GetElemVTKId(self, *args)


    def ClearEntitiesFlags(self, *args):
        """ClearEntitiesFlags(SMESH_VisualObj self)"""
        return _SMESH.SMESH_VisualObj_ClearEntitiesFlags(self, *args)


    def GetEntitiesFlag(self, *args):
        """
        GetEntitiesFlag(SMESH_VisualObj self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_VisualObj_GetEntitiesFlag(self, *args)


    def GetEntitiesState(self, *args):
        """
        GetEntitiesState(SMESH_VisualObj self) -> unsigned int

        :rtype: unsigned int

        """
        return _SMESH.SMESH_VisualObj_GetEntitiesState(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_VisualObj
SMESH_VisualObj_swigregister = _SMESH.SMESH_VisualObj_swigregister
SMESH_VisualObj_swigregister(SMESH_VisualObj)

class SMESH_Hypothesis(SMESHDS.SMESHDS_Hypothesis):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    HYP_OK = _SMESH.SMESH_Hypothesis_HYP_OK
    HYP_MISSING = _SMESH.SMESH_Hypothesis_HYP_MISSING
    HYP_CONCURRENT = _SMESH.SMESH_Hypothesis_HYP_CONCURRENT
    HYP_BAD_PARAMETER = _SMESH.SMESH_Hypothesis_HYP_BAD_PARAMETER
    HYP_HIDDEN_ALGO = _SMESH.SMESH_Hypothesis_HYP_HIDDEN_ALGO
    HYP_HIDING_ALGO = _SMESH.SMESH_Hypothesis_HYP_HIDING_ALGO
    HYP_UNKNOWN_FATAL = _SMESH.SMESH_Hypothesis_HYP_UNKNOWN_FATAL
    HYP_INCOMPATIBLE = _SMESH.SMESH_Hypothesis_HYP_INCOMPATIBLE
    HYP_NOTCONFORM = _SMESH.SMESH_Hypothesis_HYP_NOTCONFORM
    HYP_ALREADY_EXIST = _SMESH.SMESH_Hypothesis_HYP_ALREADY_EXIST
    HYP_BAD_DIM = _SMESH.SMESH_Hypothesis_HYP_BAD_DIM
    HYP_BAD_SUBSHAPE = _SMESH.SMESH_Hypothesis_HYP_BAD_SUBSHAPE
    HYP_BAD_GEOMETRY = _SMESH.SMESH_Hypothesis_HYP_BAD_GEOMETRY
    HYP_NEED_SHAPE = _SMESH.SMESH_Hypothesis_HYP_NEED_SHAPE
    HYP_INCOMPAT_HYPS = _SMESH.SMESH_Hypothesis_HYP_INCOMPAT_HYPS

    def IsStatusFatal(*args):
        """
        IsStatusFatal(SMESH_Hypothesis::Hypothesis_Status theStatus) -> bool

        :type theStatus: Hypothesis_Status
        :rtype: bool

        """
        return _SMESH.SMESH_Hypothesis_IsStatusFatal(*args)

    IsStatusFatal = staticmethod(IsStatusFatal)

    def GetDim(self, *args):
        """
        GetDim(SMESH_Hypothesis self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_Hypothesis_GetDim(self, *args)


    def GetGen(self, *args):
        """
        GetGen(SMESH_Hypothesis self) -> SMESH_Gen

        :rtype: OCC.wrapper.SMESH.SMESH_Gen

        """
        return _SMESH.SMESH_Hypothesis_GetGen(self, *args)


    def GetShapeType(self, *args):
        """
        GetShapeType(SMESH_Hypothesis self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_Hypothesis_GetShapeType(self, *args)


    def GetLibName(self, *args):
        """
        GetLibName(SMESH_Hypothesis self) -> char const *

        :rtype: const char *

        """
        return _SMESH.SMESH_Hypothesis_GetLibName(self, *args)


    def NotifySubMeshesHypothesisModification(self, *args):
        """NotifySubMeshesHypothesisModification(SMESH_Hypothesis self)"""
        return _SMESH.SMESH_Hypothesis_NotifySubMeshesHypothesisModification(self, *args)


    def SetLibName(self, *args):
        """
        SetLibName(SMESH_Hypothesis self, char const * theLibName)

        :type theLibName: const char *

        """
        return _SMESH.SMESH_Hypothesis_SetLibName(self, *args)


    def DataDependOnParams(self, *args):
        """
        DataDependOnParams(SMESH_Hypothesis self) -> bool

        rief The returned value is used by NotifySubMeshesHypothesisModification()
        to decide to call subMesh->AlgoStateEngine( MODIF_HYP, hyp ) or not
        if subMesh is ready to be computed (algo+hyp==OK)  but not yet computed.
        True result is reasonable for example if EventListeners depend on
        parameters of hypothesis.

        :rtype: bool

        """
        return _SMESH.SMESH_Hypothesis_DataDependOnParams(self, *args)


    def SetParametersByMesh(self, *args):
        """
        SetParametersByMesh(SMESH_Hypothesis self, SMESH_Mesh theMesh, TopoDS_Shape theShape) -> bool

        rief Initialize my parameter values by the mesh built on the geometry
        \param theMesh - the built mesh
        \param theShape - the geometry of interest
        etval bool - true if parameter values have been successfully defined

        :type theMesh: OCC.wrapper.SMESH.SMESH_Mesh
        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: bool

        """
        return _SMESH.SMESH_Hypothesis_SetParametersByMesh(self, *args)


    def SetParametersByDefaults(self, *args):
        """
        SetParametersByDefaults(SMESH_Hypothesis self, SMESH_Hypothesis::TDefaults const & dflts, SMESH_Mesh theMesh=None) -> bool

        rief Initialize my parameter values by default parameters.
        etval bool - true if parameter values have been successfully defined

        :type dflts: TDefaults
        :type theMesh: OCC.wrapper.SMESH.SMESH_Mesh
        :rtype: bool

        """
        return _SMESH.SMESH_Hypothesis_SetParametersByDefaults(self, *args)


    def IsAuxiliary(self, *args):
        """
        IsAuxiliary(SMESH_Hypothesis self) -> bool

        rief Return true if me is an auxiliary hypothesis
        etval bool - auxiliary or not

        An auxiliary hypothesis is optional, i.e. an algorithm
        can work without it and another hypothesis of the same
        dimension can be assigned to the shape

        :rtype: bool

        """
        return _SMESH.SMESH_Hypothesis_IsAuxiliary(self, *args)


    def GetMeshByPersistentID(self, *args):
        """
        GetMeshByPersistentID(SMESH_Hypothesis self, int id) -> SMESH_Mesh

        rief Find a mesh with given persistent ID

        :type id: int
        :rtype: OCC.wrapper.SMESH.SMESH_Mesh

        """
        return _SMESH.SMESH_Hypothesis_GetMeshByPersistentID(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_Hypothesis
SMESH_Hypothesis_swigregister = _SMESH.SMESH_Hypothesis_swigregister
SMESH_Hypothesis_swigregister(SMESH_Hypothesis)

def SMESH_Hypothesis_IsStatusFatal(*args):
    """
    SMESH_Hypothesis_IsStatusFatal(SMESH_Hypothesis::Hypothesis_Status theStatus) -> bool

    :type theStatus: Hypothesis_Status
    :rtype: bool

    """
    return _SMESH.SMESH_Hypothesis_IsStatusFatal(*args)

class SMESH_VisualObjDef(SMESH_VisualObj):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Update(self, *args):
        """
        Update(SMESH_VisualObjDef self, int theIsClear=True) -> bool

        :type theIsClear: int
        :rtype: bool

        """
        return _SMESH.SMESH_VisualObjDef_Update(self, *args)


    def NulData(self, *args):
        """
        NulData(SMESH_VisualObjDef self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_VisualObjDef_NulData(self, *args)


    def UpdateFunctor(self, *args):
        """
        UpdateFunctor(SMESH_VisualObjDef self, SMESH::Controls::FunctorPtr const & theFunctor)

        :type theFunctor: FunctorPtr

        """
        return _SMESH.SMESH_VisualObjDef_UpdateFunctor(self, *args)


    def GetElemDimension(self, *args):
        """
        GetElemDimension(SMESH_VisualObjDef self, int const theObjId) -> int

        :type theObjId: const int
        :rtype: int

        """
        return _SMESH.SMESH_VisualObjDef_GetElemDimension(self, *args)


    def GetNbEntities(self, *args):
        """
        GetNbEntities(SMESH_VisualObjDef self, SMDSAbs_ElementType const theType) -> int

        :type theType: OCC.wrapper.SMDSAbs.SMDSAbs_ElementType
        :rtype: int

        """
        return _SMESH.SMESH_VisualObjDef_GetNbEntities(self, *args)


    def GetEntities(self, *args):
        """
        GetEntities(SMESH_VisualObjDef self, SMDSAbs_ElementType const arg2, SMESH_VisualObjDef::TEntityList & arg3) -> int

        :type : OCC.wrapper.SMDSAbs.SMDSAbs_ElementType
        :type : TEntityList
        :rtype: int

        """
        return _SMESH.SMESH_VisualObjDef_GetEntities(self, *args)


    def IsNodePrs(self, *args):
        """
        IsNodePrs(SMESH_VisualObjDef self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_VisualObjDef_IsNodePrs(self, *args)


    def GetMesh(self, *args):
        """
        GetMesh(SMESH_VisualObjDef self) -> SMDS_Mesh

        :rtype: OCC.wrapper.SMDS.SMDS_Mesh

        """
        return _SMESH.SMESH_VisualObjDef_GetMesh(self, *args)


    def GetMeshServer(self, *args):
        """
        GetMeshServer(SMESH_VisualObjDef self) -> SMESH::SMESH_Mesh_ptr

        :rtype: OCC.wrapper.SMESH.SMESH_Mesh_ptr

        """
        return _SMESH.SMESH_VisualObjDef_GetMeshServer(self, *args)


    def IsValid(self, *args):
        """
        IsValid(SMESH_VisualObjDef self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_VisualObjDef_IsValid(self, *args)


    def GetEdgeNodes(self, *args):
        """
        GetEdgeNodes(SMESH_VisualObjDef self, int const theElemId, int const theEdgeNum) -> bool

        :type theElemId: const int
        :type theEdgeNum: const int
        :type theNodeId1: int &
        :type theNodeId2: int &
        :rtype: bool

        """
        return _SMESH.SMESH_VisualObjDef_GetEdgeNodes(self, *args)


    def GetUnstructuredGrid(self, *args):
        """
        GetUnstructuredGrid(SMESH_VisualObjDef self) -> vtkUnstructuredGrid *

        :rtype: vtkUnstructuredGrid

        """
        return _SMESH.SMESH_VisualObjDef_GetUnstructuredGrid(self, *args)


    def GetNodeObjId(self, *args):
        """
        GetNodeObjId(SMESH_VisualObjDef self, int theVTKID) -> vtkIdType

        :type theVTKID: int
        :rtype: vtkIdType

        """
        return _SMESH.SMESH_VisualObjDef_GetNodeObjId(self, *args)


    def GetNodeVTKId(self, *args):
        """
        GetNodeVTKId(SMESH_VisualObjDef self, int theObjID) -> vtkIdType

        :type theObjID: int
        :rtype: vtkIdType

        """
        return _SMESH.SMESH_VisualObjDef_GetNodeVTKId(self, *args)


    def GetElemObjId(self, *args):
        """
        GetElemObjId(SMESH_VisualObjDef self, int theVTKID) -> vtkIdType

        :type theVTKID: int
        :rtype: vtkIdType

        """
        return _SMESH.SMESH_VisualObjDef_GetElemObjId(self, *args)


    def GetElemVTKId(self, *args):
        """
        GetElemVTKId(SMESH_VisualObjDef self, int theObjID) -> vtkIdType

        :type theObjID: int
        :rtype: vtkIdType

        """
        return _SMESH.SMESH_VisualObjDef_GetElemVTKId(self, *args)


    def ClearEntitiesFlags(self, *args):
        """ClearEntitiesFlags(SMESH_VisualObjDef self)"""
        return _SMESH.SMESH_VisualObjDef_ClearEntitiesFlags(self, *args)


    def GetEntitiesFlag(self, *args):
        """
        GetEntitiesFlag(SMESH_VisualObjDef self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_VisualObjDef_GetEntitiesFlag(self, *args)


    def GetEntitiesState(self, *args):
        """
        GetEntitiesState(SMESH_VisualObjDef self) -> unsigned int

        :rtype: unsigned int

        """
        return _SMESH.SMESH_VisualObjDef_GetEntitiesState(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_VisualObjDef
SMESH_VisualObjDef_swigregister = _SMESH.SMESH_VisualObjDef_swigregister
SMESH_VisualObjDef_swigregister(SMESH_VisualObjDef)

class SMESH_Actor(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    ePoint = _SMESH.SMESH_Actor_ePoint
    eEdge = _SMESH.SMESH_Actor_eEdge
    eSurface = _SMESH.SMESH_Actor_eSurface
    e0DElements = _SMESH.SMESH_Actor_e0DElements
    eEdges = _SMESH.SMESH_Actor_eEdges
    eFaces = _SMESH.SMESH_Actor_eFaces
    eVolumes = _SMESH.SMESH_Actor_eVolumes
    eBallElem = _SMESH.SMESH_Actor_eBallElem
    eAllEntity = _SMESH.SMESH_Actor_eAllEntity
    eLines = _SMESH.SMESH_Actor_eLines
    eArcs = _SMESH.SMESH_Actor_eArcs
    eNone = _SMESH.SMESH_Actor_eNone
    eLength = _SMESH.SMESH_Actor_eLength
    eLength2D = _SMESH.SMESH_Actor_eLength2D
    eDeflection2D = _SMESH.SMESH_Actor_eDeflection2D
    eFreeBorders = _SMESH.SMESH_Actor_eFreeBorders
    eFreeEdges = _SMESH.SMESH_Actor_eFreeEdges
    eFreeNodes = _SMESH.SMESH_Actor_eFreeNodes
    eFreeFaces = _SMESH.SMESH_Actor_eFreeFaces
    eMultiConnection = _SMESH.SMESH_Actor_eMultiConnection
    eArea = _SMESH.SMESH_Actor_eArea
    eTaper = _SMESH.SMESH_Actor_eTaper
    eAspectRatio = _SMESH.SMESH_Actor_eAspectRatio
    eMinimumAngle = _SMESH.SMESH_Actor_eMinimumAngle
    eWarping = _SMESH.SMESH_Actor_eWarping
    eSkew = _SMESH.SMESH_Actor_eSkew
    eAspectRatio3D = _SMESH.SMESH_Actor_eAspectRatio3D
    eMultiConnection2D = _SMESH.SMESH_Actor_eMultiConnection2D
    eVolume3D = _SMESH.SMESH_Actor_eVolume3D
    eMaxElementLength2D = _SMESH.SMESH_Actor_eMaxElementLength2D
    eMaxElementLength3D = _SMESH.SMESH_Actor_eMaxElementLength3D
    eBareBorderFace = _SMESH.SMESH_Actor_eBareBorderFace
    eBareBorderVolume = _SMESH.SMESH_Actor_eBareBorderVolume
    eOverConstrainedFace = _SMESH.SMESH_Actor_eOverConstrainedFace
    eOverConstrainedVolume = _SMESH.SMESH_Actor_eOverConstrainedVolume
    eCoincidentNodes = _SMESH.SMESH_Actor_eCoincidentNodes
    eCoincidentElems1D = _SMESH.SMESH_Actor_eCoincidentElems1D
    eCoincidentElems2D = _SMESH.SMESH_Actor_eCoincidentElems2D
    eCoincidentElems3D = _SMESH.SMESH_Actor_eCoincidentElems3D
    eNodeConnectivityNb = _SMESH.SMESH_Actor_eNodeConnectivityNb
    eCustomControl = _SMESH.SMESH_Actor_eCustomControl

    def IsTypeOf(*args):
        """
        IsTypeOf(char const * type) -> vtkTypeBool

        :type type: const char *
        :rtype: vtkTypeBool

        """
        return _SMESH.SMESH_Actor_IsTypeOf(*args)

    IsTypeOf = staticmethod(IsTypeOf)

    def IsA(self, *args):
        """
        IsA(SMESH_Actor self, char const * type) -> vtkTypeBool

        :type type: const char *
        :rtype: vtkTypeBool

        """
        return _SMESH.SMESH_Actor_IsA(self, *args)


    def SafeDownCast(*args):
        """
        SafeDownCast(vtkObjectBase * o) -> SMESH_Actor

        :type o: vtkObjectBase
        :rtype: OCC.wrapper.SMESH.SMESH_Actor

        """
        return _SMESH.SMESH_Actor_SafeDownCast(*args)

    SafeDownCast = staticmethod(SafeDownCast)

    def NewInstance(self, *args):
        """
        NewInstance(SMESH_Actor self) -> SMESH_Actor

        :rtype: OCC.wrapper.SMESH.SMESH_Actor

        """
        return _SMESH.SMESH_Actor_NewInstance(self, *args)


    def New(*args):
        """
        New(shared_ptr_SMESH_VisualObj theVisualObj, char const * theEntry, char const * theName, int theIsClear) -> SMESH_Actor

        :type theVisualObj: TVisualObjPtr
        :type theEntry: const char *
        :type theName: const char *
        :type theIsClear: int
        :rtype: OCC.wrapper.SMESH.SMESH_Actor

        """
        return _SMESH.SMESH_Actor_New(*args)

    New = staticmethod(New)

    def SetSufaceColor(self, *args):
        """
        SetSufaceColor(SMESH_Actor self, double r, double g, double b, int delta)

        :type r: double
        :type g: double
        :type b: double
        :type delta: int

        """
        return _SMESH.SMESH_Actor_SetSufaceColor(self, *args)


    def GetSufaceColor(self, *args):
        """
        GetSufaceColor(SMESH_Actor self)

        :type r: double &
        :type g: double &
        :type b: double &
        :type delta: int &

        """
        return _SMESH.SMESH_Actor_GetSufaceColor(self, *args)


    def SetVolumeColor(self, *args):
        """
        SetVolumeColor(SMESH_Actor self, double r, double g, double b, int delta)

        :type r: double
        :type g: double
        :type b: double
        :type delta: int

        """
        return _SMESH.SMESH_Actor_SetVolumeColor(self, *args)


    def GetVolumeColor(self, *args):
        """
        GetVolumeColor(SMESH_Actor self)

        :type r: double &
        :type g: double &
        :type b: double &
        :type delta: int &

        """
        return _SMESH.SMESH_Actor_GetVolumeColor(self, *args)


    def SetEdgeColor(self, *args):
        """
        SetEdgeColor(SMESH_Actor self, double r, double g, double b)

        :type r: double
        :type g: double
        :type b: double

        """
        return _SMESH.SMESH_Actor_SetEdgeColor(self, *args)


    def GetEdgeColor(self, *args):
        """
        GetEdgeColor(SMESH_Actor self)

        :type r: double &
        :type g: double &
        :type b: double &

        """
        return _SMESH.SMESH_Actor_GetEdgeColor(self, *args)


    def SetNodeColor(self, *args):
        """
        SetNodeColor(SMESH_Actor self, double r, double g, double b)

        :type r: double
        :type g: double
        :type b: double

        """
        return _SMESH.SMESH_Actor_SetNodeColor(self, *args)


    def GetNodeColor(self, *args):
        """
        GetNodeColor(SMESH_Actor self)

        :type r: double &
        :type g: double &
        :type b: double &

        """
        return _SMESH.SMESH_Actor_GetNodeColor(self, *args)


    def SetOutlineColor(self, *args):
        """
        SetOutlineColor(SMESH_Actor self, double r, double g, double b)

        :type r: double
        :type g: double
        :type b: double

        """
        return _SMESH.SMESH_Actor_SetOutlineColor(self, *args)


    def GetOutlineColor(self, *args):
        """
        GetOutlineColor(SMESH_Actor self)

        :type r: double &
        :type g: double &
        :type b: double &

        """
        return _SMESH.SMESH_Actor_GetOutlineColor(self, *args)


    def Set0DColor(self, *args):
        """
        Set0DColor(SMESH_Actor self, double r, double g, double b)

        :type r: double
        :type g: double
        :type b: double

        """
        return _SMESH.SMESH_Actor_Set0DColor(self, *args)


    def Get0DColor(self, *args):
        """
        Get0DColor(SMESH_Actor self)

        :type r: double &
        :type g: double &
        :type b: double &

        """
        return _SMESH.SMESH_Actor_Get0DColor(self, *args)


    def SetBallColor(self, *args):
        """
        SetBallColor(SMESH_Actor self, double r, double g, double b)

        :type r: double
        :type g: double
        :type b: double

        """
        return _SMESH.SMESH_Actor_SetBallColor(self, *args)


    def GetBallColor(self, *args):
        """
        GetBallColor(SMESH_Actor self)

        :type r: double &
        :type g: double &
        :type b: double &

        """
        return _SMESH.SMESH_Actor_GetBallColor(self, *args)


    def UpdateSelectionProps(self, *args):
        """UpdateSelectionProps(SMESH_Actor self)"""
        return _SMESH.SMESH_Actor_UpdateSelectionProps(self, *args)


    def GetLineWidth(self, *args):
        """
        GetLineWidth(SMESH_Actor self) -> double

        :rtype: double

        """
        return _SMESH.SMESH_Actor_GetLineWidth(self, *args)


    def SetLineWidth(self, *args):
        """
        SetLineWidth(SMESH_Actor self, double theVal)

        :type theVal: double

        """
        return _SMESH.SMESH_Actor_SetLineWidth(self, *args)


    def GetOutlineWidth(self, *args):
        """
        GetOutlineWidth(SMESH_Actor self) -> double

        :rtype: double

        """
        return _SMESH.SMESH_Actor_GetOutlineWidth(self, *args)


    def SetOutlineWidth(self, *args):
        """
        SetOutlineWidth(SMESH_Actor self, double theVal)

        :type theVal: double

        """
        return _SMESH.SMESH_Actor_SetOutlineWidth(self, *args)


    def Set0DSize(self, *args):
        """
        Set0DSize(SMESH_Actor self, double size)

        :type size: double

        """
        return _SMESH.SMESH_Actor_Set0DSize(self, *args)


    def Get0DSize(self, *args):
        """
        Get0DSize(SMESH_Actor self) -> double

        :rtype: double

        """
        return _SMESH.SMESH_Actor_Get0DSize(self, *args)


    def SetBallSize(self, *args):
        """
        SetBallSize(SMESH_Actor self, double size)

        :type size: double

        """
        return _SMESH.SMESH_Actor_SetBallSize(self, *args)


    def GetBallSize(self, *args):
        """
        GetBallSize(SMESH_Actor self) -> double

        :rtype: double

        """
        return _SMESH.SMESH_Actor_GetBallSize(self, *args)


    def SetBallScale(self, *args):
        """
        SetBallScale(SMESH_Actor self, double size)

        :type size: double

        """
        return _SMESH.SMESH_Actor_SetBallScale(self, *args)


    def GetBallScale(self, *args):
        """
        GetBallScale(SMESH_Actor self) -> double

        :rtype: double

        """
        return _SMESH.SMESH_Actor_GetBallScale(self, *args)


    def SetEntityMode(self, *args):
        """
        SetEntityMode(SMESH_Actor self, unsigned int theMode)

        :type theMode: unsigned int

        """
        return _SMESH.SMESH_Actor_SetEntityMode(self, *args)


    def GetEntityMode(self, *args):
        """
        GetEntityMode(SMESH_Actor self) -> unsigned int

        :rtype: unsigned int

        """
        return _SMESH.SMESH_Actor_GetEntityMode(self, *args)


    def SetQuadratic2DRepresentation(self, *args):
        """
        SetQuadratic2DRepresentation(SMESH_Actor self, SMESH_Actor::EQuadratic2DRepresentation arg2)

        :type : EQuadratic2DRepresentation

        """
        return _SMESH.SMESH_Actor_SetQuadratic2DRepresentation(self, *args)


    def GetQuadratic2DRepresentation(self, *args):
        """
        GetQuadratic2DRepresentation(SMESH_Actor self) -> SMESH_Actor::EQuadratic2DRepresentation

        :rtype: EQuadratic2DRepresentation

        """
        return _SMESH.SMESH_Actor_GetQuadratic2DRepresentation(self, *args)


    def SetPointRepresentation(self, *args):
        """
        SetPointRepresentation(SMESH_Actor self, bool theIsPointsVisible)

        :type theIsPointsVisible: bool

        """
        return _SMESH.SMESH_Actor_SetPointRepresentation(self, *args)


    def GetPointRepresentation(self, *args):
        """
        GetPointRepresentation(SMESH_Actor self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_Actor_GetPointRepresentation(self, *args)


    def GetUnstructuredGrid(self, *args):
        """
        GetUnstructuredGrid(SMESH_Actor self) -> vtkUnstructuredGrid *

        :rtype: vtkUnstructuredGrid

        """
        return _SMESH.SMESH_Actor_GetUnstructuredGrid(self, *args)


    def SetShrinkFactor(self, *args):
        """
        SetShrinkFactor(SMESH_Actor self, double theValue)

        :type theValue: double

        """
        return _SMESH.SMESH_Actor_SetShrinkFactor(self, *args)


    def SetPointsLabeled(self, *args):
        """
        SetPointsLabeled(SMESH_Actor self, bool theIsPointsLabeled)

        :type theIsPointsLabeled: bool

        """
        return _SMESH.SMESH_Actor_SetPointsLabeled(self, *args)


    def GetPointsLabeled(self, *args):
        """
        GetPointsLabeled(SMESH_Actor self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_Actor_GetPointsLabeled(self, *args)


    def SetCellsLabeled(self, *args):
        """
        SetCellsLabeled(SMESH_Actor self, bool theIsCellsLabeled)

        :type theIsCellsLabeled: bool

        """
        return _SMESH.SMESH_Actor_SetCellsLabeled(self, *args)


    def GetCellsLabeled(self, *args):
        """
        GetCellsLabeled(SMESH_Actor self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_Actor_GetCellsLabeled(self, *args)


    def SetFacesOriented(self, *args):
        """
        SetFacesOriented(SMESH_Actor self, bool theIsFacesOriented)

        :type theIsFacesOriented: bool

        """
        return _SMESH.SMESH_Actor_SetFacesOriented(self, *args)


    def GetFacesOriented(self, *args):
        """
        GetFacesOriented(SMESH_Actor self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_Actor_GetFacesOriented(self, *args)


    def SetFacesOrientationColor(self, *args):
        """
        SetFacesOrientationColor(SMESH_Actor self, double r, double g, double b)

        :type r: double
        :type g: double
        :type b: double

        """
        return _SMESH.SMESH_Actor_SetFacesOrientationColor(self, *args)


    def GetFacesOrientationColor(self, *args):
        """
        GetFacesOrientationColor(SMESH_Actor self)

        :type r: double &
        :type g: double &
        :type b: double &

        """
        return _SMESH.SMESH_Actor_GetFacesOrientationColor(self, *args)


    def SetFacesOrientationScale(self, *args):
        """
        SetFacesOrientationScale(SMESH_Actor self, double theScale)

        :type theScale: double

        """
        return _SMESH.SMESH_Actor_SetFacesOrientationScale(self, *args)


    def GetFacesOrientationScale(self, *args):
        """
        GetFacesOrientationScale(SMESH_Actor self) -> double

        :rtype: double

        """
        return _SMESH.SMESH_Actor_GetFacesOrientationScale(self, *args)


    def SetFacesOrientation3DVectors(self, *args):
        """
        SetFacesOrientation3DVectors(SMESH_Actor self, bool theState)

        :type theState: bool

        """
        return _SMESH.SMESH_Actor_SetFacesOrientation3DVectors(self, *args)


    def GetFacesOrientation3DVectors(self, *args):
        """
        GetFacesOrientation3DVectors(SMESH_Actor self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_Actor_GetFacesOrientation3DVectors(self, *args)


    def SetControlMode(self, *args):
        """
        SetControlMode(SMESH_Actor self, SMESH_Actor::eControl theMode)

        :type theMode: eControl

        """
        return _SMESH.SMESH_Actor_SetControlMode(self, *args)


    def SetControl(self, *args):
        """
        SetControl(SMESH_Actor self, SMESH::Controls::FunctorPtr arg2)

        :type : FunctorPtr

        """
        return _SMESH.SMESH_Actor_SetControl(self, *args)


    def GetControlMode(self, *args):
        """
        GetControlMode(SMESH_Actor self) -> SMESH_Actor::eControl

        :rtype: eControl

        """
        return _SMESH.SMESH_Actor_GetControlMode(self, *args)


    def GetFunctor(self, *args):
        """
        GetFunctor(SMESH_Actor self) -> SMESH::Controls::FunctorPtr

        :rtype: FunctorPtr

        """
        return _SMESH.SMESH_Actor_GetFunctor(self, *args)


    def GetNumberControlEntities(self, *args):
        """
        GetNumberControlEntities(SMESH_Actor self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_Actor_GetNumberControlEntities(self, *args)


    def GetScalarBarActor(self, *args):
        """
        GetScalarBarActor(SMESH_Actor self) -> SMESH_ScalarBarActor

        :rtype: OCC.wrapper.SMESH.SMESH_ScalarBarActor

        """
        return _SMESH.SMESH_Actor_GetScalarBarActor(self, *args)


    def RemoveAllClippingPlanes(self, *args):
        """RemoveAllClippingPlanes(SMESH_Actor self)"""
        return _SMESH.SMESH_Actor_RemoveAllClippingPlanes(self, *args)


    def GetNumberOfClippingPlanes(self, *args):
        """
        GetNumberOfClippingPlanes(SMESH_Actor self) -> vtkIdType

        :rtype: vtkIdType

        """
        return _SMESH.SMESH_Actor_GetNumberOfClippingPlanes(self, *args)


    def GetClippingPlane(self, *args):
        """
        GetClippingPlane(SMESH_Actor self, vtkIdType theID) -> vtkPlane *

        :type theID: vtkIdType
        :rtype: OCC.wrapper.SMESH.vtkPlane

        """
        return _SMESH.SMESH_Actor_GetClippingPlane(self, *args)


    def AddClippingPlane(self, *args):
        """
        AddClippingPlane(SMESH_Actor self, vtkPlane * thePlane) -> vtkIdType

        :type thePlane: OCC.wrapper.SMESH.vtkPlane
        :rtype: vtkIdType

        """
        return _SMESH.SMESH_Actor_AddClippingPlane(self, *args)


    def AddOpenGLClippingPlane(self, *args):
        """
        AddOpenGLClippingPlane(SMESH_Actor self, vtkPlane * thePlane)

        :type thePlane: OCC.wrapper.SMESH.vtkPlane

        """
        return _SMESH.SMESH_Actor_AddOpenGLClippingPlane(self, *args)


    def SetOpenGLClippingPlane(self, *args):
        """SetOpenGLClippingPlane(SMESH_Actor self)"""
        return _SMESH.SMESH_Actor_SetOpenGLClippingPlane(self, *args)


    def GetObject(self, *args):
        """
        GetObject(SMESH_Actor self) -> shared_ptr_SMESH_VisualObj

        :rtype: TVisualObjPtr

        """
        return _SMESH.SMESH_Actor_GetObject(self, *args)


    def SetControlsPrecision(self, *args):
        """
        SetControlsPrecision(SMESH_Actor self, long const arg2)

        :type : const long

        """
        return _SMESH.SMESH_Actor_SetControlsPrecision(self, *args)


    def GetControlsPrecision(self, *args):
        """
        GetControlsPrecision(SMESH_Actor self) -> long

        :rtype: long

        """
        return _SMESH.SMESH_Actor_GetControlsPrecision(self, *args)


    def UpdateScalarBar(self, *args):
        """UpdateScalarBar(SMESH_Actor self)"""
        return _SMESH.SMESH_Actor_UpdateScalarBar(self, *args)


    def UpdateDistribution(self, *args):
        """UpdateDistribution(SMESH_Actor self)"""
        return _SMESH.SMESH_Actor_UpdateDistribution(self, *args)


    def SetPointsFontProperties(self, *args):
        """
        SetPointsFontProperties(SMESH_Actor self, SMESH::LabelFont family, int size, bool bold, bool italic, bool shadow, double r, double g, double b)

        :type family: LabelFont
        :type size: int
        :type bold: bool
        :type italic: bool
        :type shadow: bool
        :type r: double
        :type g: double
        :type b: double

        """
        return _SMESH.SMESH_Actor_SetPointsFontProperties(self, *args)


    def SetCellsFontProperties(self, *args):
        """
        SetCellsFontProperties(SMESH_Actor self, SMESH::LabelFont family, int size, bool bold, bool italic, bool shadow, double r, double g, double b)

        :type family: LabelFont
        :type size: int
        :type bold: bool
        :type italic: bool
        :type shadow: bool
        :type r: double
        :type g: double
        :type b: double

        """
        return _SMESH.SMESH_Actor_SetCellsFontProperties(self, *args)


    def UpdateFilter(self, *args):
        """UpdateFilter(SMESH_Actor self)"""
        return _SMESH.SMESH_Actor_UpdateFilter(self, *args)


    def GetPlot2Histogram(self, *args):
        """
        GetPlot2Histogram(SMESH_Actor self) -> SPlot2d_Histogram *

        :rtype: OCC.wrapper.SMESH.SPlot2d_Histogram

        """
        return _SMESH.SMESH_Actor_GetPlot2Histogram(self, *args)


    def UpdatePlot2Histogram(self, *args):
        """
        UpdatePlot2Histogram(SMESH_Actor self) -> SPlot2d_Histogram *

        :rtype: OCC.wrapper.SMESH.SPlot2d_Histogram

        """
        return _SMESH.SMESH_Actor_UpdatePlot2Histogram(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_Actor
SMESH_Actor_swigregister = _SMESH.SMESH_Actor_swigregister
SMESH_Actor_swigregister(SMESH_Actor)

def SMESH_Actor_IsTypeOf(*args):
    """
    SMESH_Actor_IsTypeOf(char const * type) -> vtkTypeBool

    :type type: const char *
    :rtype: vtkTypeBool

    """
    return _SMESH.SMESH_Actor_IsTypeOf(*args)

def SMESH_Actor_SafeDownCast(*args):
    """
    SMESH_Actor_SafeDownCast(vtkObjectBase * o) -> SMESH_Actor

    :type o: vtkObjectBase
    :rtype: OCC.wrapper.SMESH.SMESH_Actor

    """
    return _SMESH.SMESH_Actor_SafeDownCast(*args)

def SMESH_Actor_New(*args):
    """
    SMESH_Actor_New(shared_ptr_SMESH_VisualObj theVisualObj, char const * theEntry, char const * theName, int theIsClear) -> SMESH_Actor

    :type theVisualObj: TVisualObjPtr
    :type theEntry: const char *
    :type theName: const char *
    :type theIsClear: int
    :rtype: OCC.wrapper.SMESH.SMESH_Actor

    """
    return _SMESH.SMESH_Actor_New(*args)

class SMESH_SubMeshObj(SMESH_VisualObjDef):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Update(self, *args):
        """
        Update(SMESH_SubMeshObj self, int theIsClear=True) -> bool

        :type theIsClear: int
        :rtype: bool

        """
        return _SMESH.SMESH_SubMeshObj_Update(self, *args)


    def UpdateFunctor(self, *args):
        """
        UpdateFunctor(SMESH_SubMeshObj self, SMESH::Controls::FunctorPtr const & theFunctor)

        :type theFunctor: FunctorPtr

        """
        return _SMESH.SMESH_SubMeshObj_UpdateFunctor(self, *args)


    def GetElemDimension(self, *args):
        """
        GetElemDimension(SMESH_SubMeshObj self, int const theObjId) -> int

        :type theObjId: const int
        :rtype: int

        """
        return _SMESH.SMESH_SubMeshObj_GetElemDimension(self, *args)


    def GetMesh(self, *args):
        """
        GetMesh(SMESH_SubMeshObj self) -> SMDS_Mesh

        :rtype: OCC.wrapper.SMDS.SMDS_Mesh

        """
        return _SMESH.SMESH_SubMeshObj_GetMesh(self, *args)


    def GetMeshServer(self, *args):
        """
        GetMeshServer(SMESH_SubMeshObj self) -> SMESH::SMESH_Mesh_ptr

        :rtype: OCC.wrapper.SMESH.SMESH_Mesh_ptr

        """
        return _SMESH.SMESH_SubMeshObj_GetMeshServer(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_SubMeshObj
SMESH_SubMeshObj_swigregister = _SMESH.SMESH_SubMeshObj_swigregister
SMESH_SubMeshObj_swigregister(SMESH_SubMeshObj)

class SMESH_Algo(SMESH_Hypothesis):
    """
    rief Root of all algorithms

    Methods of the class are grouped into several parts:
    - main lifecycle methods, like Compute()
    - methods describing features of the algorithm, like NeedShape()
    - methods related to dependencies between sub-meshes imposed by the algorithm
    - static utilities, like EdgeLength()
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    MEr_OK = _SMESH.SMESH_Algo_MEr_OK
    MEr_HOLES = _SMESH.SMESH_Algo_MEr_HOLES
    MEr_BAD_ORI = _SMESH.SMESH_Algo_MEr_BAD_ORI
    MEr_EMPTY = _SMESH.SMESH_Algo_MEr_EMPTY

    def GetFeatures(self, *args):
        """
        :rtype: Features

        """
        res = _SMESH.SMESH_Algo_GetFeatures(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SaveTo(self, *args):
        """
        SaveTo(SMESH_Algo self, std::ostream & save) -> std::ostream &

        rief Saves nothing in a stream
        \param save - the stream
        etval std::ostream & - the stream

        :type save: ostream
        :rtype: ostream

        """
        return _SMESH.SMESH_Algo_SaveTo(self, *args)


    def LoadFrom(self, *args):
        """
        LoadFrom(SMESH_Algo self, std::istream & load) -> std::istream &

        rief Loads nothing from a stream
        \param load - the stream
        etval std::ostream & - the stream

        :type load: istream
        :rtype: istream

        """
        return _SMESH.SMESH_Algo_LoadFrom(self, *args)


    def GetCompatibleHypothesis(self, *args):
        """
        GetCompatibleHypothesis(SMESH_Algo self) -> std::string const &

        rief Returns all types of compatible hypotheses

        :rtype: const int &

        """
        return _SMESH.SMESH_Algo_GetCompatibleHypothesis(self, *args)


    def CheckHypothesis(self, *args):
        """
        CheckHypothesis(SMESH_Algo self, SMESH_Mesh aMesh, TopoDS_Shape aShape) -> bool

        rief Check hypothesis definition to mesh a shape
        \param aMesh - the mesh
        \param aShape - the shape
        \param aStatus - check result
        etval bool - true if hypothesis is well defined

        Textual description of a problem can be stored in _comment field.

        :type aMesh: OCC.wrapper.SMESH.SMESH_Mesh
        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aStatus: Hypothesis_Status
        :rtype: bool

        """
        return _SMESH.SMESH_Algo_CheckHypothesis(self, *args)


    def Compute(self, *args):
        """
        Compute(SMESH_Algo self, SMESH_Mesh aMesh, TopoDS_Shape aShape) -> bool
        Compute(SMESH_Algo self, SMESH_Mesh aMesh, SMESH_MesherHelper aHelper) -> bool

        rief Computes mesh without geometry
        \param aMesh - the mesh
        \param aHelper - helper that must be used for adding elements to aMesh
        etval bool - is a success

        The method is called if ( !aMesh->HasShapeToMesh() )

        :type aMesh: OCC.wrapper.SMESH.SMESH_Mesh
        :type aHelper: OCC.wrapper.SMESH.SMESH_MesherHelper
        :rtype: bool

        """
        return _SMESH.SMESH_Algo_Compute(self, *args)


    def IsApplicableToShape(self, *args):
        """
        IsApplicableToShape(SMESH_Algo self, TopoDS_Shape shape, bool toCheckAll) -> bool

        rief Return true if the algorithm can mesh a given shape
        \param [in] aShape - shape to check
        \param [in] toCheckAll - if true, this check returns OK if all shapes are OK,
        else, returns OK if at least one shape is OK
        etval bool - \c true by default

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type toCheckAll: bool
        :rtype: bool

        """
        return _SMESH.SMESH_Algo_IsApplicableToShape(self, *args)


    def CancelCompute(self, *args):
        """
        CancelCompute(SMESH_Algo self)

        rief Sets _computeCanceled to true. It's usage depends on
        implementation of a particular mesher.


        """
        return _SMESH.SMESH_Algo_CancelCompute(self, *args)


    def GetProgress(self, *args):
        """
        GetProgress(SMESH_Algo self) -> double

        rief If possible, returns progress of computation [0.,1.]

        :rtype: double

        """
        return _SMESH.SMESH_Algo_GetProgress(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(SMESH_Algo self, SMESH_Mesh aMesh, TopoDS_Shape aShape, MapShapeNbElems & aResMap) -> bool

        rief evaluates size of prospective mesh on a shape
        \param aMesh - the mesh
        \param aShape - the shape
        \param aResMap - prospective number of elements by SMDSAbs_ElementType by a sub-mesh
        etval bool - is a success

        :type aMesh: OCC.wrapper.SMESH.SMESH_Mesh
        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aResMap: MapShapeNbElems
        :rtype: bool

        """
        return _SMESH.SMESH_Algo_Evaluate(self, *args)


    def GetUsedHypothesis(self, *args):
        """
        GetUsedHypothesis(SMESH_Algo self, SMESH_Mesh aMesh, TopoDS_Shape aShape, bool const ignoreAuxiliary=True) -> SMESHDS_Hypothesis

        rief Returns a list of compatible hypotheses used to mesh a shape
        \param aMesh - the mesh 
        \param aShape - the shape
        \param ignoreAuxiliary - do not include auxiliary hypotheses in the list
        etval const std::list <const SMESHDS_Hypothesis*> - hypotheses list

        List the hypothesis used by the algorithm associated to the shape.
        Hypothesis associated to father shape -are- taken into account (see
        GetAppliedHypothesis). Relevant hypothesis have a name (type) listed in
        the algorithm. This method could be surcharged by specific algorithms, in 
        case of several hypothesis simultaneously applicable.

        :rtype: const int &

        """
        return _SMESH.SMESH_Algo_GetUsedHypothesis(self, *args)


    def GetAppliedHypothesis(self, *args):
        """
        GetAppliedHypothesis(SMESH_Algo self, SMESH_Mesh aMesh, TopoDS_Shape aShape, bool const ignoreAuxiliary=True) -> SMESHDS_Hypothesis

        rief Returns a list of compatible hypotheses assigned to a shape in a mesh
        \param aMesh - the mesh 
        \param aShape - the shape
        \param ignoreAuxiliary - do not include auxiliary hypotheses in the list
        etval const std::list <const SMESHDS_Hypothesis*> - hypotheses list

        List the relevant hypothesis associated to the shape. Relevant hypothesis
        have a name (type) listed in the algorithm. Hypothesis associated to
        father shape -are not- taken into account (see GetUsedHypothesis)

        :rtype: const int &

        """
        return _SMESH.SMESH_Algo_GetAppliedHypothesis(self, *args)


    def GetCompatibleHypoFilter(self, *args):
        """
        GetCompatibleHypoFilter(SMESH_Algo self, bool const ignoreAuxiliary) -> SMESH_HypoFilter

        rief Returns the filter recognizing only compatible hypotheses
        \param ignoreAuxiliary - make filter ignore compatible auxiliary hypotheses
        etval SMESH_HypoFilter* - the filter that can be NULL

        :type ignoreAuxiliary: const bool
        :rtype: OCC.wrapper.SMESH.SMESH_HypoFilter

        """
        return _SMESH.SMESH_Algo_GetCompatibleHypoFilter(self, *args)


    def SetParametersByMesh(self, *args):
        """
        SetParametersByMesh(SMESH_Algo self, SMESH_Mesh theMesh, TopoDS_Shape theShape) -> bool

        rief Just return false as the algorithm does not hold parameters values

        :type theMesh: OCC.wrapper.SMESH.SMESH_Mesh
        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: bool

        """
        return _SMESH.SMESH_Algo_SetParametersByMesh(self, *args)


    def SetParametersByDefaults(self, *args):
        """
        SetParametersByDefaults(SMESH_Algo self, SMESH_Hypothesis::TDefaults const & dflts, SMESH_Mesh theMesh=None) -> bool

        :type dflts: TDefaults
        :type theMesh: OCC.wrapper.SMESH.SMESH_Mesh
        :rtype: bool

        """
        return _SMESH.SMESH_Algo_SetParametersByDefaults(self, *args)


    def GetComputeError(self, *args):
        """
        GetComputeError(SMESH_Algo self) -> shared_ptr_SMESH_ComputeError

        rief return compute error

        :rtype: OCC.wrapper.SMESH.SMESH_ComputeErrorPtr

        """
        return _SMESH.SMESH_Algo_GetComputeError(self, *args)


    def InitComputeError(self, *args):
        """
        InitComputeError(SMESH_Algo self)

        rief initialize compute error etc. before call of Compute()


        """
        return _SMESH.SMESH_Algo_InitComputeError(self, *args)


    def GetProgressByTic(self, *args):
        """
        GetProgressByTic(SMESH_Algo self) -> double

        rief Return compute progress by nb of calls of this method

        :rtype: double

        """
        return _SMESH.SMESH_Algo_GetProgressByTic(self, *args)


    def SubMeshesToCompute(self, *args):
        """
        SubMeshesToCompute(SMESH_Algo self) -> SMESH_subMesh

        Return a vector of sub-meshes to Compute()

        :rtype: int &

        """
        return _SMESH.SMESH_Algo_SubMeshesToCompute(self, *args)


    def OnlyUnaryInput(self, *args):
        """
        OnlyUnaryInput(SMESH_Algo self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_Algo_OnlyUnaryInput(self, *args)


    def NeedDiscreteBoundary(self, *args):
        """
        NeedDiscreteBoundary(SMESH_Algo self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_Algo_NeedDiscreteBoundary(self, *args)


    def NeedShape(self, *args):
        """
        NeedShape(SMESH_Algo self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_Algo_NeedShape(self, *args)


    def SupportSubmeshes(self, *args):
        """
        SupportSubmeshes(SMESH_Algo self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_Algo_SupportSubmeshes(self, *args)


    def NeedLowerHyps(self, *args):
        """
        NeedLowerHyps(SMESH_Algo self, int dim) -> bool

        :type dim: int
        :rtype: bool

        """
        return _SMESH.SMESH_Algo_NeedLowerHyps(self, *args)


    def SetEventListener(self, *args):
        """
        SetEventListener(SMESH_Algo self, SMESH_subMesh subMesh)

        rief Sets event listener to submeshes if necessary
        \param subMesh - submesh where algo is set

        This method is called when a submesh gets HYP_OK algo_state.
        After being set, event listener is notified on each event of a submesh.
        By default none listener is set

        :type subMesh: OCC.wrapper.SMESH.SMESH_subMesh

        """
        return _SMESH.SMESH_Algo_SetEventListener(self, *args)


    def SubmeshRestored(self, *args):
        """
        SubmeshRestored(SMESH_Algo self, SMESH_subMesh subMesh)

        rief Allow algo to do something after persistent restoration
        \param subMesh - restored submesh

        This method is called only if a submesh has HYP_OK algo_state.

        :type subMesh: OCC.wrapper.SMESH.SMESH_subMesh

        """
        return _SMESH.SMESH_Algo_SubmeshRestored(self, *args)


    def GetNodeParamOnEdge(*args):
        """
        GetNodeParamOnEdge(SMESHDS_Mesh theMesh, TopoDS_Edge theEdge, std::vector< double,std::allocator< double > > & theParams) -> bool

        rief Fill vector of node parameters on geometrical edge, including vertex nodes
        \param theMesh - The mesh containing nodes
        \param theEdge - The geometrical edge of interest
        \param theParams - The resulting vector of sorted node parameters
        etval bool - false if not all parameters are OK
        \warning Nodes moved to other geometry by MergeNodes() are NOT returned.

        :type theMesh: OCC.wrapper.SMESHDS.SMESHDS_Mesh
        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theParams: int &
        :rtype: bool

        """
        return _SMESH.SMESH_Algo_GetNodeParamOnEdge(*args)

    GetNodeParamOnEdge = staticmethod(GetNodeParamOnEdge)

    def GetSortedNodesOnEdge(*args):
        """
        GetSortedNodesOnEdge(SMESHDS_Mesh theMesh, TopoDS_Edge theEdge, bool const ignoreMediumNodes, std::map< double,SMDS_MeshNode const *,std::less< double >,std::allocator< std::pair< double const,SMDS_MeshNode const * > > > & theNodes, SMDSAbs_ElementType const typeToCheck=SMDSAbs_All) -> bool

        rief Fill map of node parameter on geometrical edge to node it-self
        \param theMesh - The mesh containing nodes
        \param theEdge - The geometrical edge of interest
        \param theNodes - The resulting map
        \param ignoreMediumNodes - to store medium nodes of quadratic elements or not
        \param typeToCheck - type of elements to check for medium nodes
        etval bool - false if not all parameters are OK
        \warning Nodes moved to other geometry by MergeNodes() are NOT returned.

        :type theMesh: OCC.wrapper.SMESHDS.SMESHDS_Mesh
        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type ignoreMediumNodes: const bool
        :type theNodes: int &
        :type typeToCheck: OCC.wrapper.SMDSAbs.SMDSAbs_ElementType
        :rtype: bool

        """
        return _SMESH.SMESH_Algo_GetSortedNodesOnEdge(*args)

    GetSortedNodesOnEdge = staticmethod(GetSortedNodesOnEdge)

    def EdgeLength(*args):
        """
        EdgeLength(TopoDS_Edge E) -> double

        rief Compute length of an edge
        \param E - the edge
        etval double - the length

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: double

        """
        return _SMESH.SMESH_Algo_EdgeLength(*args)

    EdgeLength = staticmethod(EdgeLength)

    def NumberOfPoints(self, *args):
        """
        NumberOfPoints(SMESH_Algo self, SMESH_Mesh aMesh, TopoDS_Wire W) -> int

        :type aMesh: OCC.wrapper.SMESH.SMESH_Mesh
        :type W: OCC.wrapper.TopoDS.TopoDS_Wire
        :rtype: int

        """
        return _SMESH.SMESH_Algo_NumberOfPoints(self, *args)


    def Continuity(*args):
        """
        Continuity(TopoDS_Edge E1, TopoDS_Edge E2) -> GeomAbs_Shape

        rief Return continuity of two edges
        \param E1 - the 1st edge
        \param E2 - the 2nd edge
        etval GeomAbs_Shape - regularity at the junction between E1 and E2

        :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _SMESH.SMESH_Algo_Continuity(*args)

    Continuity = staticmethod(Continuity)

    def IsContinuous(*args):
        """
        IsContinuous(TopoDS_Edge E1, TopoDS_Edge E2) -> bool

        rief Return true if an edge can be considered as a continuation of another

        :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: bool

        """
        return _SMESH.SMESH_Algo_IsContinuous(*args)

    IsContinuous = staticmethod(IsContinuous)

    def IsStraight(*args):
        """
        IsStraight(TopoDS_Edge E, bool const degenResult=False) -> bool

        rief Return true if an edge can be considered straight

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type degenResult: const bool
        :rtype: bool

        """
        return _SMESH.SMESH_Algo_IsStraight(*args)

    IsStraight = staticmethod(IsStraight)

    def isDegenerated(*args):
        """
        isDegenerated(TopoDS_Edge E, bool const checkLength=False) -> bool

        rief Return true if an edge has no 3D curve

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type checkLength: const bool
        :rtype: bool

        """
        return _SMESH.SMESH_Algo_isDegenerated(*args)

    isDegenerated = staticmethod(isDegenerated)

    def VertexNode(*args):
        """
        VertexNode(TopoDS_Vertex V, SMESHDS_Mesh meshDS) -> SMDS_MeshNode
        VertexNode(TopoDS_Vertex V, SMESH_Mesh mesh) -> SMDS_MeshNode
        VertexNode(TopoDS_Vertex V, SMESHDS_SubMesh edgeSM, SMESH_Mesh mesh, bool const checkV=True) -> SMDS_MeshNode

        rief Return the node built on a vertex.
        A node moved to other geometry by MergeNodes() is also returned.
        \param V - the vertex
        \param edgeSM - sub-mesh of a meshed EDGE sharing the vertex
        \param mesh - the mesh
        \param checkV - if \c true, presence of a node on the vertex is checked
        etval const SMDS_MeshNode* - found node or NULL

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type edgeSM: OCC.wrapper.SMESHDS.SMESHDS_SubMesh
        :type mesh: OCC.wrapper.SMESH.SMESH_Mesh
        :type checkV: const bool
        :rtype: OCC.wrapper.SMDS.SMDS_MeshNode

        """
        return _SMESH.SMESH_Algo_VertexNode(*args)

    VertexNode = staticmethod(VertexNode)

    def GetMeshError(*args):
        """
        GetMeshError(SMESH_subMesh subMesh) -> SMESH_Algo::EMeshError

        rief Finds topological errors of a sub-mesh 

        :type subMesh: OCC.wrapper.SMESH.SMESH_subMesh
        :rtype: EMeshError

        """
        return _SMESH.SMESH_Algo_GetMeshError(*args)

    GetMeshError = staticmethod(GetMeshError)
    __swig_destroy__ = _SMESH.delete_SMESH_Algo
SMESH_Algo_swigregister = _SMESH.SMESH_Algo_swigregister
SMESH_Algo_swigregister(SMESH_Algo)

def SMESH_Algo_GetNodeParamOnEdge(*args):
    """
    SMESH_Algo_GetNodeParamOnEdge(SMESHDS_Mesh theMesh, TopoDS_Edge theEdge, std::vector< double,std::allocator< double > > & theParams) -> bool

    rief Fill vector of node parameters on geometrical edge, including vertex nodes
    \param theMesh - The mesh containing nodes
    \param theEdge - The geometrical edge of interest
    \param theParams - The resulting vector of sorted node parameters
    etval bool - false if not all parameters are OK
    \warning Nodes moved to other geometry by MergeNodes() are NOT returned.

    :type theMesh: OCC.wrapper.SMESHDS.SMESHDS_Mesh
    :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
    :type theParams: int &
    :rtype: bool

    """
    return _SMESH.SMESH_Algo_GetNodeParamOnEdge(*args)

def SMESH_Algo_GetSortedNodesOnEdge(*args):
    """
    SMESH_Algo_GetSortedNodesOnEdge(SMESHDS_Mesh theMesh, TopoDS_Edge theEdge, bool const ignoreMediumNodes, std::map< double,SMDS_MeshNode const *,std::less< double >,std::allocator< std::pair< double const,SMDS_MeshNode const * > > > & theNodes, SMDSAbs_ElementType const typeToCheck=SMDSAbs_All) -> bool

    rief Fill map of node parameter on geometrical edge to node it-self
    \param theMesh - The mesh containing nodes
    \param theEdge - The geometrical edge of interest
    \param theNodes - The resulting map
    \param ignoreMediumNodes - to store medium nodes of quadratic elements or not
    \param typeToCheck - type of elements to check for medium nodes
    etval bool - false if not all parameters are OK
    \warning Nodes moved to other geometry by MergeNodes() are NOT returned.

    :type theMesh: OCC.wrapper.SMESHDS.SMESHDS_Mesh
    :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
    :type ignoreMediumNodes: const bool
    :type theNodes: int &
    :type typeToCheck: OCC.wrapper.SMDSAbs.SMDSAbs_ElementType
    :rtype: bool

    """
    return _SMESH.SMESH_Algo_GetSortedNodesOnEdge(*args)

def SMESH_Algo_EdgeLength(*args):
    """
    SMESH_Algo_EdgeLength(TopoDS_Edge E) -> double

    rief Compute length of an edge
    \param E - the edge
    etval double - the length

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :rtype: double

    """
    return _SMESH.SMESH_Algo_EdgeLength(*args)

def SMESH_Algo_Continuity(*args):
    """
    SMESH_Algo_Continuity(TopoDS_Edge E1, TopoDS_Edge E2) -> GeomAbs_Shape

    rief Return continuity of two edges
    \param E1 - the 1st edge
    \param E2 - the 2nd edge
    etval GeomAbs_Shape - regularity at the junction between E1 and E2

    :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
    :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
    :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

    """
    return _SMESH.SMESH_Algo_Continuity(*args)

def SMESH_Algo_IsContinuous(*args):
    """
    SMESH_Algo_IsContinuous(TopoDS_Edge E1, TopoDS_Edge E2) -> bool

    rief Return true if an edge can be considered as a continuation of another

    :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
    :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
    :rtype: bool

    """
    return _SMESH.SMESH_Algo_IsContinuous(*args)

def SMESH_Algo_IsStraight(*args):
    """
    SMESH_Algo_IsStraight(TopoDS_Edge E, bool const degenResult=False) -> bool

    rief Return true if an edge can be considered straight

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type degenResult: const bool
    :rtype: bool

    """
    return _SMESH.SMESH_Algo_IsStraight(*args)

def SMESH_Algo_isDegenerated(*args):
    """
    SMESH_Algo_isDegenerated(TopoDS_Edge E, bool const checkLength=False) -> bool

    rief Return true if an edge has no 3D curve

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type checkLength: const bool
    :rtype: bool

    """
    return _SMESH.SMESH_Algo_isDegenerated(*args)

def SMESH_Algo_VertexNode(*args):
    """
    VertexNode(TopoDS_Vertex V, SMESHDS_Mesh meshDS) -> SMDS_MeshNode
    VertexNode(TopoDS_Vertex V, SMESH_Mesh mesh) -> SMDS_MeshNode
    SMESH_Algo_VertexNode(TopoDS_Vertex V, SMESHDS_SubMesh edgeSM, SMESH_Mesh mesh, bool const checkV=True) -> SMDS_MeshNode

    rief Return the node built on a vertex.
    A node moved to other geometry by MergeNodes() is also returned.
    \param V - the vertex
    \param edgeSM - sub-mesh of a meshed EDGE sharing the vertex
    \param mesh - the mesh
    \param checkV - if \c true, presence of a node on the vertex is checked
    etval const SMDS_MeshNode* - found node or NULL

    :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type edgeSM: OCC.wrapper.SMESHDS.SMESHDS_SubMesh
    :type mesh: OCC.wrapper.SMESH.SMESH_Mesh
    :type checkV: const bool
    :rtype: OCC.wrapper.SMDS.SMDS_MeshNode

    """
    return _SMESH.SMESH_Algo_VertexNode(*args)

def SMESH_Algo_GetMeshError(*args):
    """
    SMESH_Algo_GetMeshError(SMESH_subMesh subMesh) -> SMESH_Algo::EMeshError

    rief Finds topological errors of a sub-mesh 

    :type subMesh: OCC.wrapper.SMESH.SMESH_subMesh
    :rtype: EMeshError

    """
    return _SMESH.SMESH_Algo_GetMeshError(*args)

class SMESH_HypoPredicate(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def IsOk(self, *args):
        """
        IsOk(SMESH_HypoPredicate self, SMESH_Hypothesis aHyp, TopoDS_Shape aShape) -> bool

        :type aHyp: OCC.wrapper.SMESH.SMESH_Hypothesis
        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: bool

        """
        return _SMESH.SMESH_HypoPredicate_IsOk(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_HypoPredicate
SMESH_HypoPredicate_swigregister = _SMESH.SMESH_HypoPredicate_swigregister
SMESH_HypoPredicate_swigregister(SMESH_HypoPredicate)

class SMESH_DeviceActor(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    ePoint = _SMESH.SMESH_DeviceActor_ePoint
    eWireframe = _SMESH.SMESH_DeviceActor_eWireframe
    eSurface = _SMESH.SMESH_DeviceActor_eSurface
    eInsideframe = _SMESH.SMESH_DeviceActor_eInsideframe

    def IsTypeOf(*args):
        """
        IsTypeOf(char const * type) -> vtkTypeBool

        :type type: const char *
        :rtype: vtkTypeBool

        """
        return _SMESH.SMESH_DeviceActor_IsTypeOf(*args)

    IsTypeOf = staticmethod(IsTypeOf)

    def IsA(self, *args):
        """
        IsA(SMESH_DeviceActor self, char const * type) -> vtkTypeBool

        :type type: const char *
        :rtype: vtkTypeBool

        """
        return _SMESH.SMESH_DeviceActor_IsA(self, *args)


    def SafeDownCast(*args):
        """
        SafeDownCast(vtkObjectBase * o) -> SMESH_DeviceActor

        :type o: vtkObjectBase
        :rtype: OCC.wrapper.SMESH.SMESH_DeviceActor

        """
        return _SMESH.SMESH_DeviceActor_SafeDownCast(*args)

    SafeDownCast = staticmethod(SafeDownCast)

    def NewInstance(self, *args):
        """
        NewInstance(SMESH_DeviceActor self) -> SMESH_DeviceActor

        :rtype: OCC.wrapper.SMESH.SMESH_DeviceActor

        """
        return _SMESH.SMESH_DeviceActor_NewInstance(self, *args)


    def New(*args):
        """
        New() -> SMESH_DeviceActor

        :rtype: OCC.wrapper.SMESH.SMESH_DeviceActor

        """
        return _SMESH.SMESH_DeviceActor_New(*args)

    New = staticmethod(New)

    def SetStoreClippingMapping(self, *args):
        """
        SetStoreClippingMapping(SMESH_DeviceActor self, bool theStoreMapping)

        :type theStoreMapping: bool

        """
        return _SMESH.SMESH_DeviceActor_SetStoreClippingMapping(self, *args)


    def SetStoreGemetryMapping(self, *args):
        """
        SetStoreGemetryMapping(SMESH_DeviceActor self, bool theStoreMapping)

        :type theStoreMapping: bool

        """
        return _SMESH.SMESH_DeviceActor_SetStoreGemetryMapping(self, *args)


    def SetStoreIDMapping(self, *args):
        """
        SetStoreIDMapping(SMESH_DeviceActor self, bool theStoreMapping)

        :type theStoreMapping: bool

        """
        return _SMESH.SMESH_DeviceActor_SetStoreIDMapping(self, *args)


    def GetNodeObjId(self, *args):
        """
        GetNodeObjId(SMESH_DeviceActor self, int theVtkID) -> int

        :type theVtkID: int
        :rtype: int

        """
        return _SMESH.SMESH_DeviceActor_GetNodeObjId(self, *args)


    def GetNodeCoord(self, *args):
        """
        GetNodeCoord(SMESH_DeviceActor self, int theObjID) -> double *

        :type theObjID: int
        :rtype: double *

        """
        return _SMESH.SMESH_DeviceActor_GetNodeCoord(self, *args)


    def GetNodeVtkId(self, *args):
        """
        GetNodeVtkId(SMESH_DeviceActor self, int theObjID) -> int

        :type theObjID: int
        :rtype: int

        """
        return _SMESH.SMESH_DeviceActor_GetNodeVtkId(self, *args)


    def GetElemObjId(self, *args):
        """
        GetElemObjId(SMESH_DeviceActor self, int theVtkID) -> int

        :type theVtkID: int
        :rtype: int

        """
        return _SMESH.SMESH_DeviceActor_GetElemObjId(self, *args)


    def GetElemCell(self, *args):
        """
        GetElemCell(SMESH_DeviceActor self, int theObjID) -> vtkCell *

        :type theObjID: int
        :rtype: vtkCell

        """
        return _SMESH.SMESH_DeviceActor_GetElemCell(self, *args)


    def SetTransform(self, *args):
        """
        SetTransform(SMESH_DeviceActor self, VTKViewer_Transform * theTransform)

        :type theTransform: VTKViewer_Transform

        """
        return _SMESH.SMESH_DeviceActor_SetTransform(self, *args)


    def GetMTime(self, *args):
        """
        GetMTime(SMESH_DeviceActor self) -> vtkMTimeType

        :rtype: vtkMTimeType

        """
        return _SMESH.SMESH_DeviceActor_GetMTime(self, *args)


    def SetFacesOriented(self, *args):
        """
        SetFacesOriented(SMESH_DeviceActor self, bool theIsFacesOriented)

        :type theIsFacesOriented: bool

        """
        return _SMESH.SMESH_DeviceActor_SetFacesOriented(self, *args)


    def GetFacesOriented(self, *args):
        """
        GetFacesOriented(SMESH_DeviceActor self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_DeviceActor_GetFacesOriented(self, *args)


    def SetFacesOrientationColor(self, *args):
        """
        SetFacesOrientationColor(SMESH_DeviceActor self, double r, double g, double b)

        :type r: double
        :type g: double
        :type b: double

        """
        return _SMESH.SMESH_DeviceActor_SetFacesOrientationColor(self, *args)


    def GetFacesOrientationColor(self, *args):
        """
        GetFacesOrientationColor(SMESH_DeviceActor self)

        :type r: double &
        :type g: double &
        :type b: double &

        """
        return _SMESH.SMESH_DeviceActor_GetFacesOrientationColor(self, *args)


    def SetFacesOrientationScale(self, *args):
        """
        SetFacesOrientationScale(SMESH_DeviceActor self, double theScale)

        :type theScale: double

        """
        return _SMESH.SMESH_DeviceActor_SetFacesOrientationScale(self, *args)


    def GetFacesOrientationScale(self, *args):
        """
        GetFacesOrientationScale(SMESH_DeviceActor self) -> double

        :rtype: double

        """
        return _SMESH.SMESH_DeviceActor_GetFacesOrientationScale(self, *args)


    def SetFacesOrientation3DVectors(self, *args):
        """
        SetFacesOrientation3DVectors(SMESH_DeviceActor self, bool theState)

        :type theState: bool

        """
        return _SMESH.SMESH_DeviceActor_SetFacesOrientation3DVectors(self, *args)


    def GetFacesOrientation3DVectors(self, *args):
        """
        GetFacesOrientation3DVectors(SMESH_DeviceActor self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_DeviceActor_GetFacesOrientation3DVectors(self, *args)


    def SetQuadraticArcMode(self, *args):
        """
        SetQuadraticArcMode(SMESH_DeviceActor self, bool theFlag)

        Setting for displaying quadratic elements

        :type theFlag: bool

        """
        return _SMESH.SMESH_DeviceActor_SetQuadraticArcMode(self, *args)


    def GetQuadraticArcMode(self, *args):
        """
        GetQuadraticArcMode(SMESH_DeviceActor self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_DeviceActor_GetQuadraticArcMode(self, *args)


    def SetQuadraticArcAngle(self, *args):
        """
        SetQuadraticArcAngle(SMESH_DeviceActor self, double theMaxAngle)

        :type theMaxAngle: double

        """
        return _SMESH.SMESH_DeviceActor_SetQuadraticArcAngle(self, *args)


    def GetQuadraticArcAngle(self, *args):
        """
        GetQuadraticArcAngle(SMESH_DeviceActor self) -> double

        :rtype: double

        """
        return _SMESH.SMESH_DeviceActor_GetQuadraticArcAngle(self, *args)


    def UpdateFaceOrientation(self, *args):
        """UpdateFaceOrientation(SMESH_DeviceActor self)"""
        return _SMESH.SMESH_DeviceActor_UpdateFaceOrientation(self, *args)


    def GetShrinkFactor(self, *args):
        """
        GetShrinkFactor(SMESH_DeviceActor self) -> double

        :rtype: double

        """
        return _SMESH.SMESH_DeviceActor_GetShrinkFactor(self, *args)


    def SetShrinkFactor(self, *args):
        """
        SetShrinkFactor(SMESH_DeviceActor self, double value)

        :type value: double

        """
        return _SMESH.SMESH_DeviceActor_SetShrinkFactor(self, *args)


    def IsShrunkable(self, *args):
        """
        IsShrunkable(SMESH_DeviceActor self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_DeviceActor_IsShrunkable(self, *args)


    def IsShrunk(self, *args):
        """
        IsShrunk(SMESH_DeviceActor self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_DeviceActor_IsShrunk(self, *args)


    def SetShrink(self, *args):
        """SetShrink(SMESH_DeviceActor self)"""
        return _SMESH.SMESH_DeviceActor_SetShrink(self, *args)


    def UnShrink(self, *args):
        """UnShrink(SMESH_DeviceActor self)"""
        return _SMESH.SMESH_DeviceActor_UnShrink(self, *args)


    def GetRepresentation(self, *args):
        """
        GetRepresentation(SMESH_DeviceActor self) -> SMESH_DeviceActor::EReperesent

        :rtype: EReperesent

        """
        return _SMESH.SMESH_DeviceActor_GetRepresentation(self, *args)


    def SetRepresentation(self, *args):
        """
        SetRepresentation(SMESH_DeviceActor self, SMESH_DeviceActor::EReperesent theMode)

        :type theMode: EReperesent

        """
        return _SMESH.SMESH_DeviceActor_SetRepresentation(self, *args)


    def SetVisibility(self, *args):
        """
        SetVisibility(SMESH_DeviceActor self, int theMode)

        :type theMode: int

        """
        return _SMESH.SMESH_DeviceActor_SetVisibility(self, *args)


    def GetVisibility(self, *args):
        """
        GetVisibility(SMESH_DeviceActor self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_DeviceActor_GetVisibility(self, *args)


    def AddToRender(self, *args):
        """
        AddToRender(SMESH_DeviceActor self, vtkRenderer * theRenderer)

        :type theRenderer: vtkRenderer

        """
        return _SMESH.SMESH_DeviceActor_AddToRender(self, *args)


    def RemoveFromRender(self, *args):
        """
        RemoveFromRender(SMESH_DeviceActor self, vtkRenderer * theRenderer)

        :type theRenderer: vtkRenderer

        """
        return _SMESH.SMESH_DeviceActor_RemoveFromRender(self, *args)


    def GetExtractUnstructuredGrid(self, *args):
        """
        GetExtractUnstructuredGrid(SMESH_DeviceActor self) -> VTKViewer_ExtractUnstructuredGrid *

        :rtype: OCC.wrapper.SMESH.VTKViewer_ExtractUnstructuredGrid

        """
        return _SMESH.SMESH_DeviceActor_GetExtractUnstructuredGrid(self, *args)


    def GetUnstructuredGrid(self, *args):
        """
        GetUnstructuredGrid(SMESH_DeviceActor self) -> vtkUnstructuredGrid *

        :rtype: vtkUnstructuredGrid

        """
        return _SMESH.SMESH_DeviceActor_GetUnstructuredGrid(self, *args)


    def SetPlaneCollection(self, *args):
        """
        SetPlaneCollection(SMESH_DeviceActor self, vtkPlaneCollection * theCollection)

        :type theCollection: OCC.wrapper.SMESH.vtkPlaneCollection

        """
        return _SMESH.SMESH_DeviceActor_SetPlaneCollection(self, *args)


    def SetControlMode(self, *args):
        """
        SetControlMode(SMESH_DeviceActor self, SMESH::Controls::FunctorPtr theFunctor, SMESH_ScalarBarActor theScalarBarActor, vtkLookupTable * theLookupTable)

        :type theFunctor: FunctorPtr
        :type theScalarBarActor: OCC.wrapper.SMESH.SMESH_ScalarBarActor
        :type theLookupTable: OCC.wrapper.SMESH.vtkLookupTable

        """
        return _SMESH.SMESH_DeviceActor_SetControlMode(self, *args)


    def SetExtControlMode(self, *args):
        """
        SetExtControlMode(SMESH_DeviceActor self, SMESH::Controls::FunctorPtr theFunctor, SMESH_ScalarBarActor theScalarBarActor, vtkLookupTable * theLookupTable)
        SetExtControlMode(SMESH_DeviceActor self, SMESH::Controls::FunctorPtr theFunctor)

        :type theFunctor: FunctorPtr

        """
        return _SMESH.SMESH_DeviceActor_SetExtControlMode(self, *args)


    def IsHighlited(self, *args):
        """
        IsHighlited(SMESH_DeviceActor self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_DeviceActor_IsHighlited(self, *args)


    def SetHighlited(self, *args):
        """
        SetHighlited(SMESH_DeviceActor self, bool theIsHighlited)

        :type theIsHighlited: bool

        """
        return _SMESH.SMESH_DeviceActor_SetHighlited(self, *args)


    def SetCoincident3DAllowed(self, *args):
        """
        SetCoincident3DAllowed(SMESH_DeviceActor self, bool theIsFeatureEdgesAllowed)

        :type theIsFeatureEdgesAllowed: bool

        """
        return _SMESH.SMESH_DeviceActor_SetCoincident3DAllowed(self, *args)


    def IsCoincident3DAllowed(self, *args):
        """
        IsCoincident3DAllowed(SMESH_DeviceActor self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_DeviceActor_IsCoincident3DAllowed(self, *args)


    def Render(self, *args):
        """
        Render(SMESH_DeviceActor self, vtkRenderer * arg2, vtkMapper * arg3)

        :type : vtkRenderer
        :type : vtkMapper

        """
        return _SMESH.SMESH_DeviceActor_Render(self, *args)


    def SetImplicitFunctionUsed(self, *args):
        """
        SetImplicitFunctionUsed(SMESH_DeviceActor self, bool theIsImplicitFunctionUsed)

        :type theIsImplicitFunctionUsed: bool

        """
        return _SMESH.SMESH_DeviceActor_SetImplicitFunctionUsed(self, *args)


    def IsImplicitFunctionUsed(self, *args):
        """
        IsImplicitFunctionUsed(SMESH_DeviceActor self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_DeviceActor_IsImplicitFunctionUsed(self, *args)


    def SetMarkerEnabled(self, *args):
        """
        SetMarkerEnabled(SMESH_DeviceActor self, bool arg2)

        :type : bool

        """
        return _SMESH.SMESH_DeviceActor_SetMarkerEnabled(self, *args)


    def SetBallEnabled(self, *args):
        """
        SetBallEnabled(SMESH_DeviceActor self, bool arg2)

        :type : bool

        """
        return _SMESH.SMESH_DeviceActor_SetBallEnabled(self, *args)


    def SetBallScale(self, *args):
        """
        SetBallScale(SMESH_DeviceActor self, double arg2)

        :type : double

        """
        return _SMESH.SMESH_DeviceActor_SetBallScale(self, *args)


    def SetMarkerStd(self, *args):
        """
        SetMarkerStd(SMESH_DeviceActor self, VTK::MarkerType arg2, VTK::MarkerScale arg3)

        :type : MarkerType
        :type : MarkerScale

        """
        return _SMESH.SMESH_DeviceActor_SetMarkerStd(self, *args)


    def SetMarkerTexture(self, *args):
        """
        SetMarkerTexture(SMESH_DeviceActor self, int arg2, VTK::MarkerTexture arg3)

        :type : int
        :type : MarkerTexture

        """
        return _SMESH.SMESH_DeviceActor_SetMarkerTexture(self, *args)


    def GetMarkerType(self, *args):
        """
        GetMarkerType(SMESH_DeviceActor self) -> VTK::MarkerType

        :rtype: MarkerType

        """
        return _SMESH.SMESH_DeviceActor_GetMarkerType(self, *args)


    def GetMarkerScale(self, *args):
        """
        GetMarkerScale(SMESH_DeviceActor self) -> VTK::MarkerScale

        :rtype: MarkerScale

        """
        return _SMESH.SMESH_DeviceActor_GetMarkerScale(self, *args)


    def GetMarkerTexture(self, *args):
        """
        GetMarkerTexture(SMESH_DeviceActor self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_DeviceActor_GetMarkerTexture(self, *args)


    def GetBallScale(self, *args):
        """
        GetBallScale(SMESH_DeviceActor self) -> double

        :rtype: double

        """
        return _SMESH.SMESH_DeviceActor_GetBallScale(self, *args)

SMESH_DeviceActor_swigregister = _SMESH.SMESH_DeviceActor_swigregister
SMESH_DeviceActor_swigregister(SMESH_DeviceActor)

def SMESH_DeviceActor_IsTypeOf(*args):
    """
    SMESH_DeviceActor_IsTypeOf(char const * type) -> vtkTypeBool

    :type type: const char *
    :rtype: vtkTypeBool

    """
    return _SMESH.SMESH_DeviceActor_IsTypeOf(*args)

def SMESH_DeviceActor_SafeDownCast(*args):
    """
    SMESH_DeviceActor_SafeDownCast(vtkObjectBase * o) -> SMESH_DeviceActor

    :type o: vtkObjectBase
    :rtype: OCC.wrapper.SMESH.SMESH_DeviceActor

    """
    return _SMESH.SMESH_DeviceActor_SafeDownCast(*args)

def SMESH_DeviceActor_New(*args):
    """
    SMESH_DeviceActor_New() -> SMESH_DeviceActor

    :rtype: OCC.wrapper.SMESH.SMESH_DeviceActor

    """
    return _SMESH.SMESH_DeviceActor_New(*args)

class SMESH_SubMeshVSLink(MeshVS.MeshVS_DataSource3D):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_SMESH_SubMeshVSLink
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_SMESH_SubMeshVSLink(self) 
            return h


    def __init__(self, *args):
        """
        __init__(SMESH_SubMeshVSLink self, SMESH_Mesh aMesh, SMESH_subMesh aSubMesh, int displaymode, bool supportsmoothshading=False) -> SMESH_SubMeshVSLink

        Constructor <br>

        :type aMesh: OCC.wrapper.SMESH.SMESH_Mesh
        :type aSubMesh: OCC.wrapper.SMESH.SMESH_subMesh
        :type displaymode: int
        :type supportsmoothshading: bool

        """
        this = _SMESH.new_SMESH_SubMeshVSLink(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(SMESH_SubMeshVSLink self, int displaymode)

        :type displaymode: int

        """
        return _SMESH.SMESH_SubMeshVSLink_SetDisplayMode(self, *args)


    def GetHiddenNodes(self, *args):
        """
        GetHiddenNodes(SMESH_SubMeshVSLink self, int planedir, double value, TColStd_PackedMapOfInteger hiddennodes)

        :type planedir: int
        :type value: double
        :type hiddennodes: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        return _SMESH.SMESH_SubMeshVSLink_GetHiddenNodes(self, *args)


    def GetHiddenElements(self, *args):
        """
        GetHiddenElements(SMESH_SubMeshVSLink self, int planedir, double value, TColStd_PackedMapOfInteger hiddenelems)

        :type planedir: int
        :type value: double
        :type hiddenelems: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        return _SMESH.SMESH_SubMeshVSLink_GetHiddenElements(self, *args)


    def GetNodeNormal(self, *args):
        """
        GetNodeNormal(SMESH_SubMeshVSLink self, Standard_Integer const ranknode, Standard_Integer const Id) -> Standard_Boolean

        :type ranknode: int
        :type Id: int
        :type nx: float
        :type ny: float
        :type nz: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.SMESH_SubMeshVSLink_GetNodeNormal(self, *args)


    def GetGeom(self, *args):
        """
        GetGeom(SMESH_SubMeshVSLink self, Standard_Integer const ID, Standard_Boolean const IsElement, NCollection_Array1_Standard_Real Coords) -> Standard_Boolean

        Returns geometry information about node ( if IsElement is False ) or element ( IsElement is True ) <br>
        by co-ordinates. For element this method must return all its nodes co-ordinates in the strict order: X, Y, Z and <br>
        with nodes order is the same as in wire bounding the face or link. NbNodes is number of nodes of element. <br>
        It is recommended to return 1 for node. Type is an element type. <br>

        :type ID: int
        :type IsElement: bool
        :type Coords: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NbNodes: int
        :type Type: OCC.wrapper.MeshVS.MeshVS_EntityType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.SMESH_SubMeshVSLink_GetGeom(self, *args)


    def Get3DGeom(self, *args):
        """
        Get3DGeom(SMESH_SubMeshVSLink self, Standard_Integer const ID, Handle_MeshVS_HArray1OfSequenceOfInteger Data) -> Standard_Boolean

        :type ID: int
        :type NbNodes: int
        :type Data: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.SMESH_SubMeshVSLink_Get3DGeom(self, *args)


    def GetGeomType(self, *args):
        """
        GetGeomType(SMESH_SubMeshVSLink self, Standard_Integer const ID, Standard_Boolean const IsElement) -> Standard_Boolean

        This method is similar to GetGeom, but returns only element or node type. This method is provided for <br>
        a fine performance. <br>

        :type ID: int
        :type IsElement: bool
        :type Type: OCC.wrapper.MeshVS.MeshVS_EntityType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.SMESH_SubMeshVSLink_GetGeomType(self, *args)


    def GetAddr(self, *args):
        """
        GetAddr(SMESH_SubMeshVSLink self, Standard_Integer const ID, Standard_Boolean const IsElement) -> Standard_Address

        This method returns by number an address of any entity which represents element or node data structure. <br>

        :type ID: int
        :type IsElement: bool
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _SMESH.SMESH_SubMeshVSLink_GetAddr(self, *args)


    def GetNodesByElement(self, *args):
        """
        GetNodesByElement(SMESH_SubMeshVSLink self, Standard_Integer const ID, NCollection_Array1_Standard_Integer NodeIDs) -> Standard_Boolean

        This method returns information about what node this element consist of. <br>

        :type ID: int
        :type NodeIDs: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type NbNodes: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.SMESH_SubMeshVSLink_GetNodesByElement(self, *args)


    def GetAllNodes(self, *args):
        """
        This method returns map of all nodes the object consist of. <br>

        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        res = _SMESH.SMESH_SubMeshVSLink_GetAllNodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetAllElements(self, *args):
        """
        This method returns map of all elements the object consist of. <br>

        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        res = _SMESH.SMESH_SubMeshVSLink_GetAllElements(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetNormal(self, *args):
        """
        GetNormal(SMESH_SubMeshVSLink self, Standard_Integer const Id, Standard_Integer const Max) -> Standard_Boolean

        This method calculates normal of face, which is using for correct reflection presentation. <br>
        There is default method, for advance reflection this method can be redefined. <br>

        :type Id: int
        :type Max: int
        :type nx: float
        :type ny: float
        :type nz: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.SMESH_SubMeshVSLink_GetNormal(self, *args)


    def GetAllGroups(self, *args):
        """
        GetAllGroups(SMESH_SubMeshVSLink self, TColStd_PackedMapOfInteger Ids)

        This method returns map of all groups the object contains. <br>

        :type Ids: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        return _SMESH.SMESH_SubMeshVSLink_GetAllGroups(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _SMESH.SMESH_SubMeshVSLink_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _SMESH.SMESH_SubMeshVSLink_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SMESH.SMESH_SubMeshVSLink_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _SMESH.delete_SMESH_SubMeshVSLink
SMESH_SubMeshVSLink_swigregister = _SMESH.SMESH_SubMeshVSLink_swigregister
SMESH_SubMeshVSLink_swigregister(SMESH_SubMeshVSLink)

def SMESH_SubMeshVSLink_get_type_name(*args):
    """
    SMESH_SubMeshVSLink_get_type_name() -> char const *

    :rtype: const char *

    """
    return _SMESH.SMESH_SubMeshVSLink_get_type_name(*args)

def SMESH_SubMeshVSLink_get_type_descriptor(*args):
    """
    SMESH_SubMeshVSLink_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _SMESH.SMESH_SubMeshVSLink_get_type_descriptor(*args)

class SMESH_Group(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(SMESH_Group self, int theID, SMESH_Mesh theMesh, SMDSAbs_ElementType const theType, char const * theName, TopoDS_Shape theShape, SMESH_PredicatePtr const & thePredicate) -> SMESH_Group
        __init__(SMESH_Group self, SMESHDS_GroupBase groupDS) -> SMESH_Group

        :type groupDS: OCC.wrapper.SMESHDS.SMESHDS_GroupBase

        """
        this = _SMESH.new_SMESH_Group(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetName(self, *args):
        """
        SetName(SMESH_Group self, char const * theName)

        :type theName: const char *

        """
        return _SMESH.SMESH_Group_SetName(self, *args)


    def GetName(self, *args):
        """
        GetName(SMESH_Group self) -> char const *

        :rtype: const char *

        """
        return _SMESH.SMESH_Group_GetName(self, *args)


    def GetGroupDS(self, *args):
        """
        GetGroupDS(SMESH_Group self) -> SMESHDS_GroupBase

        :rtype: OCC.wrapper.SMESHDS.SMESHDS_GroupBase

        """
        return _SMESH.SMESH_Group_GetGroupDS(self, *args)


    def GetID(self, *args):
        """
        GetID(SMESH_Group self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_Group_GetID(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_Group
SMESH_Group_swigregister = _SMESH.SMESH_Group_swigregister
SMESH_Group_swigregister(SMESH_Group)

class SMESH_2D_Algo(SMESH_Algo):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def FixInternalNodes(self, *args):
        """
        FixInternalNodes(SMESH_2D_Algo self, SMESH_ProxyMesh mesh, TopoDS_Face face) -> bool

        rief Method in which an algorithm generating a structured mesh
        fixes positions of in-face nodes after there movement
        due to insertion of viscous layers.

        :type mesh: OCC.wrapper.SMESH.SMESH_ProxyMesh
        :type face: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: bool

        """
        return _SMESH.SMESH_2D_Algo_FixInternalNodes(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_2D_Algo
SMESH_2D_Algo_swigregister = _SMESH.SMESH_2D_Algo_swigregister
SMESH_2D_Algo_swigregister(SMESH_2D_Algo)

class shared_ptr_SMDS_Iterator_SMESH_Group(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _SMESH.new_shared_ptr_SMDS_Iterator_SMESH_Group(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        return _SMESH.shared_ptr_SMDS_Iterator_SMESH_Group___deref__(self)

    def __ref__(self):
        return _SMESH.shared_ptr_SMDS_Iterator_SMESH_Group___ref__(self)
    __swig_destroy__ = _SMESH.delete_shared_ptr_SMDS_Iterator_SMESH_Group

    def more(self, *args):
        """
        more(shared_ptr_SMDS_Iterator_SMESH_Group self) -> bool

        Return true if and only if there are other object in this iterator

        :rtype: bool

        """
        return _SMESH.shared_ptr_SMDS_Iterator_SMESH_Group_more(self, *args)


    def next(self, *args):
        """
        next(shared_ptr_SMDS_Iterator_SMESH_Group self) -> SMESH_Group

        Return the current object and step to the next one

        :rtype: VALUE

        """
        return _SMESH.shared_ptr_SMDS_Iterator_SMESH_Group_next(self, *args)


    def remove(self, *args):
        """
        remove(shared_ptr_SMDS_Iterator_SMESH_Group self)

        Delete the current element and step to the next one


        """
        return _SMESH.shared_ptr_SMDS_Iterator_SMESH_Group_remove(self, *args)

shared_ptr_SMDS_Iterator_SMESH_Group_swigregister = _SMESH.shared_ptr_SMDS_Iterator_SMESH_Group_swigregister
shared_ptr_SMDS_Iterator_SMESH_Group_swigregister(shared_ptr_SMDS_Iterator_SMESH_Group)


try:
	GroupIteratorPtr = shared_ptr_SMDS_Iterator_SMESH_Group
except NameError:
	pass # does not exist, probably ignored

class SMESH_NodeLabelActor(SMESH_DeviceActor):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def New(*args):
        """
        New() -> SMESH_NodeLabelActor

        :rtype: OCC.wrapper.SMESH.SMESH_NodeLabelActor

        """
        return _SMESH.SMESH_NodeLabelActor_New(*args)

    New = staticmethod(New)

    def ProcessEvents(*args):
        """
        ProcessEvents(vtkObject * theObject, unsigned long theEvent, void * theClientData, void * theCallData)

        :type theObject: vtkObject
        :type theEvent: unsigned long
        :type theClientData: void *
        :type theCallData: void *

        """
        return _SMESH.SMESH_NodeLabelActor_ProcessEvents(*args)

    ProcessEvents = staticmethod(ProcessEvents)

    def IsTypeOf(*args):
        """
        IsTypeOf(char const * type) -> vtkTypeBool

        :type type: const char *
        :rtype: vtkTypeBool

        """
        return _SMESH.SMESH_NodeLabelActor_IsTypeOf(*args)

    IsTypeOf = staticmethod(IsTypeOf)

    def IsA(self, *args):
        """
        IsA(SMESH_NodeLabelActor self, char const * type) -> vtkTypeBool

        :type type: const char *
        :rtype: vtkTypeBool

        """
        return _SMESH.SMESH_NodeLabelActor_IsA(self, *args)


    def SafeDownCast(*args):
        """
        SafeDownCast(vtkObjectBase * o) -> SMESH_NodeLabelActor

        :type o: vtkObjectBase
        :rtype: OCC.wrapper.SMESH.SMESH_NodeLabelActor

        """
        return _SMESH.SMESH_NodeLabelActor_SafeDownCast(*args)

    SafeDownCast = staticmethod(SafeDownCast)

    def NewInstance(self, *args):
        """
        NewInstance(SMESH_NodeLabelActor self) -> SMESH_NodeLabelActor

        :rtype: OCC.wrapper.SMESH.SMESH_NodeLabelActor

        """
        return _SMESH.SMESH_NodeLabelActor_NewInstance(self, *args)


    def SetPointsLabeled(self, *args):
        """
        SetPointsLabeled(SMESH_NodeLabelActor self, bool theIsPointsLabeled)

        :type theIsPointsLabeled: bool

        """
        return _SMESH.SMESH_NodeLabelActor_SetPointsLabeled(self, *args)


    def GetPointsLabeled(self, *args):
        """
        GetPointsLabeled(SMESH_NodeLabelActor self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_NodeLabelActor_GetPointsLabeled(self, *args)


    def SetVisibility(self, *args):
        """
        SetVisibility(SMESH_NodeLabelActor self, int theMode)

        :type theMode: int

        """
        return _SMESH.SMESH_NodeLabelActor_SetVisibility(self, *args)


    def AddToRender(self, *args):
        """
        AddToRender(SMESH_NodeLabelActor self, vtkRenderer * theRenderer)

        :type theRenderer: vtkRenderer

        """
        return _SMESH.SMESH_NodeLabelActor_AddToRender(self, *args)


    def RemoveFromRender(self, *args):
        """
        RemoveFromRender(SMESH_NodeLabelActor self, vtkRenderer * theRenderer)

        :type theRenderer: vtkRenderer

        """
        return _SMESH.SMESH_NodeLabelActor_RemoveFromRender(self, *args)


    def SetFontProperties(self, *args):
        """
        SetFontProperties(SMESH_NodeLabelActor self, SMESH::LabelFont family, int size, bool bold, bool italic, bool shadow, double r, double g, double b)

        :type family: LabelFont
        :type size: int
        :type bold: bool
        :type italic: bool
        :type shadow: bool
        :type r: double
        :type g: double
        :type b: double

        """
        return _SMESH.SMESH_NodeLabelActor_SetFontProperties(self, *args)


    def UpdateLabels(self, *args):
        """UpdateLabels(SMESH_NodeLabelActor self)"""
        return _SMESH.SMESH_NodeLabelActor_UpdateLabels(self, *args)

SMESH_NodeLabelActor_swigregister = _SMESH.SMESH_NodeLabelActor_swigregister
SMESH_NodeLabelActor_swigregister(SMESH_NodeLabelActor)

def SMESH_NodeLabelActor_New(*args):
    """
    SMESH_NodeLabelActor_New() -> SMESH_NodeLabelActor

    :rtype: OCC.wrapper.SMESH.SMESH_NodeLabelActor

    """
    return _SMESH.SMESH_NodeLabelActor_New(*args)

def SMESH_NodeLabelActor_ProcessEvents(*args):
    """
    SMESH_NodeLabelActor_ProcessEvents(vtkObject * theObject, unsigned long theEvent, void * theClientData, void * theCallData)

    :type theObject: vtkObject
    :type theEvent: unsigned long
    :type theClientData: void *
    :type theCallData: void *

    """
    return _SMESH.SMESH_NodeLabelActor_ProcessEvents(*args)

def SMESH_NodeLabelActor_IsTypeOf(*args):
    """
    SMESH_NodeLabelActor_IsTypeOf(char const * type) -> vtkTypeBool

    :type type: const char *
    :rtype: vtkTypeBool

    """
    return _SMESH.SMESH_NodeLabelActor_IsTypeOf(*args)

def SMESH_NodeLabelActor_SafeDownCast(*args):
    """
    SMESH_NodeLabelActor_SafeDownCast(vtkObjectBase * o) -> SMESH_NodeLabelActor

    :type o: vtkObjectBase
    :rtype: OCC.wrapper.SMESH.SMESH_NodeLabelActor

    """
    return _SMESH.SMESH_NodeLabelActor_SafeDownCast(*args)

class SMESH_ScalarBarActor(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PrintSelf(self, *args):
        """
        PrintSelf(SMESH_ScalarBarActor self, std::ostream & os, vtkIndent indent)

        :type os: ostream
        :type indent: vtkIndent

        """
        return _SMESH.SMESH_ScalarBarActor_PrintSelf(self, *args)


    def IsTypeOf(*args):
        """
        IsTypeOf(char const * type) -> vtkTypeBool

        :type type: const char *
        :rtype: vtkTypeBool

        """
        return _SMESH.SMESH_ScalarBarActor_IsTypeOf(*args)

    IsTypeOf = staticmethod(IsTypeOf)

    def IsA(self, *args):
        """
        IsA(SMESH_ScalarBarActor self, char const * type) -> vtkTypeBool

        :type type: const char *
        :rtype: vtkTypeBool

        """
        return _SMESH.SMESH_ScalarBarActor_IsA(self, *args)


    def SafeDownCast(*args):
        """
        SafeDownCast(vtkObjectBase * o) -> SMESH_ScalarBarActor

        :type o: vtkObjectBase
        :rtype: OCC.wrapper.SMESH.SMESH_ScalarBarActor

        """
        return _SMESH.SMESH_ScalarBarActor_SafeDownCast(*args)

    SafeDownCast = staticmethod(SafeDownCast)

    def NewInstance(self, *args):
        """
        NewInstance(SMESH_ScalarBarActor self) -> SMESH_ScalarBarActor

        :rtype: OCC.wrapper.SMESH.SMESH_ScalarBarActor

        """
        return _SMESH.SMESH_ScalarBarActor_NewInstance(self, *args)


    def New(*args):
        """
        New() -> SMESH_ScalarBarActor

        :rtype: OCC.wrapper.SMESH.SMESH_ScalarBarActor

        """
        return _SMESH.SMESH_ScalarBarActor_New(*args)

    New = staticmethod(New)

    def RenderOpaqueGeometry(self, *args):
        """
        RenderOpaqueGeometry(SMESH_ScalarBarActor self, vtkViewport * viewport) -> int

        :type viewport: vtkViewport
        :rtype: int

        """
        return _SMESH.SMESH_ScalarBarActor_RenderOpaqueGeometry(self, *args)


    def RenderTranslucentGeometry(self, *args):
        """
        RenderTranslucentGeometry(SMESH_ScalarBarActor self, vtkViewport * arg2) -> int

        :type : vtkViewport
        :rtype: int

        """
        return _SMESH.SMESH_ScalarBarActor_RenderTranslucentGeometry(self, *args)


    def RenderOverlay(self, *args):
        """
        RenderOverlay(SMESH_ScalarBarActor self, vtkViewport * viewport) -> int

        :type viewport: vtkViewport
        :rtype: int

        """
        return _SMESH.SMESH_ScalarBarActor_RenderOverlay(self, *args)


    def ReleaseGraphicsResources(self, *args):
        """
        ReleaseGraphicsResources(SMESH_ScalarBarActor self, vtkWindow * arg2)

        :type : vtkWindow

        """
        return _SMESH.SMESH_ScalarBarActor_ReleaseGraphicsResources(self, *args)


    def SetLookupTable(self, *args):
        """
        SetLookupTable(SMESH_ScalarBarActor self, vtkScalarsToColors * arg2)

        :type : OCC.wrapper.SMESH.vtkScalarsToColors

        """
        return _SMESH.SMESH_ScalarBarActor_SetLookupTable(self, *args)


    def GetLookupTable(self, *args):
        """
        GetLookupTable(SMESH_ScalarBarActor self) -> vtkScalarsToColors *

        :rtype: OCC.wrapper.SMESH.vtkScalarsToColors

        """
        return _SMESH.SMESH_ScalarBarActor_GetLookupTable(self, *args)


    def SetMaximumNumberOfColors(self, *args):
        """
        SetMaximumNumberOfColors(SMESH_ScalarBarActor self, int _arg)

        :type _arg: int

        """
        return _SMESH.SMESH_ScalarBarActor_SetMaximumNumberOfColors(self, *args)


    def SetNumberOfLabels(self, *args):
        """
        SetNumberOfLabels(SMESH_ScalarBarActor self, int _arg)

        :type _arg: int

        """
        return _SMESH.SMESH_ScalarBarActor_SetNumberOfLabels(self, *args)


    def SetOrientation(self, *args):
        """
        SetOrientation(SMESH_ScalarBarActor self, int _arg)

        :type _arg: int

        """
        return _SMESH.SMESH_ScalarBarActor_SetOrientation(self, *args)


    def SetOrientationToHorizontal(self, *args):
        """SetOrientationToHorizontal(SMESH_ScalarBarActor self)"""
        return _SMESH.SMESH_ScalarBarActor_SetOrientationToHorizontal(self, *args)


    def SetOrientationToVertical(self, *args):
        """SetOrientationToVertical(SMESH_ScalarBarActor self)"""
        return _SMESH.SMESH_ScalarBarActor_SetOrientationToVertical(self, *args)


    def SetTitleTextProperty(self, *args):
        """
        SetTitleTextProperty(SMESH_ScalarBarActor self, vtkTextProperty * p)

        :type p: OCC.wrapper.SMESH.vtkTextProperty

        """
        return _SMESH.SMESH_ScalarBarActor_SetTitleTextProperty(self, *args)


    def GetTitleTextProperty(self, *args):
        """
        GetTitleTextProperty(SMESH_ScalarBarActor self) -> vtkTextProperty *

        :rtype: OCC.wrapper.SMESH.vtkTextProperty

        """
        return _SMESH.SMESH_ScalarBarActor_GetTitleTextProperty(self, *args)


    def SetLabelTextProperty(self, *args):
        """
        SetLabelTextProperty(SMESH_ScalarBarActor self, vtkTextProperty * p)

        :type p: OCC.wrapper.SMESH.vtkTextProperty

        """
        return _SMESH.SMESH_ScalarBarActor_SetLabelTextProperty(self, *args)


    def GetLabelTextProperty(self, *args):
        """
        GetLabelTextProperty(SMESH_ScalarBarActor self) -> vtkTextProperty *

        :rtype: OCC.wrapper.SMESH.vtkTextProperty

        """
        return _SMESH.SMESH_ScalarBarActor_GetLabelTextProperty(self, *args)


    def SetLabelFormat(self, *args):
        """
        SetLabelFormat(SMESH_ScalarBarActor self, char const * _arg)

        :type _arg: const char *

        """
        return _SMESH.SMESH_ScalarBarActor_SetLabelFormat(self, *args)


    def GetLabelFormat(self, *args):
        """
        GetLabelFormat(SMESH_ScalarBarActor self) -> char *

        :rtype: char *

        """
        return _SMESH.SMESH_ScalarBarActor_GetLabelFormat(self, *args)


    def SetTitle(self, *args):
        """
        SetTitle(SMESH_ScalarBarActor self, char const * _arg)

        :type _arg: const char *

        """
        return _SMESH.SMESH_ScalarBarActor_SetTitle(self, *args)


    def GetTitle(self, *args):
        """
        GetTitle(SMESH_ScalarBarActor self) -> char *

        :rtype: char *

        """
        return _SMESH.SMESH_ScalarBarActor_GetTitle(self, *args)


    def ShallowCopy(self, *args):
        """
        ShallowCopy(SMESH_ScalarBarActor self, vtkProp * prop)

        :type prop: vtkProp

        """
        return _SMESH.SMESH_ScalarBarActor_ShallowCopy(self, *args)


    def SetDistributionVisibility(self, *args):
        """
        SetDistributionVisibility(SMESH_ScalarBarActor self, int flag)

        :type flag: int

        """
        return _SMESH.SMESH_ScalarBarActor_SetDistributionVisibility(self, *args)


    def GetDistributionVisibility(self, *args):
        """
        GetDistributionVisibility(SMESH_ScalarBarActor self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_ScalarBarActor_GetDistributionVisibility(self, *args)


    def SetDistribution(self, *args):
        """
        SetDistribution(SMESH_ScalarBarActor self, std::vector< int,std::allocator< int > > const & theNbValues)

        :type theNbValues: const int &

        """
        return _SMESH.SMESH_ScalarBarActor_SetDistribution(self, *args)


    def SetDistributionColoringType(self, *args):
        """
        SetDistributionColoringType(SMESH_ScalarBarActor self, int theDistributionColoringType)

        :type theDistributionColoringType: int

        """
        return _SMESH.SMESH_ScalarBarActor_SetDistributionColoringType(self, *args)


    def GetDistributionColoringType(self, *args):
        """
        GetDistributionColoringType(SMESH_ScalarBarActor self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_ScalarBarActor_GetDistributionColoringType(self, *args)


    def SetDistributionColor(self, *args):
        """
        SetDistributionColor(SMESH_ScalarBarActor self, double * rgb)

        :type rgb: double [3]

        """
        return _SMESH.SMESH_ScalarBarActor_SetDistributionColor(self, *args)


    def GetDistributionColor(self, *args):
        """
        GetDistributionColor(SMESH_ScalarBarActor self, double * rgb)

        :type rgb: double [3]

        """
        return _SMESH.SMESH_ScalarBarActor_GetDistributionColor(self, *args)


    def SetTitleOnlyVisibility(self, *args):
        """
        SetTitleOnlyVisibility(SMESH_ScalarBarActor self, bool arg2)

        :type : bool

        """
        return _SMESH.SMESH_ScalarBarActor_SetTitleOnlyVisibility(self, *args)


    def GetTitleOnlyVisibility(self, *args):
        """
        GetTitleOnlyVisibility(SMESH_ScalarBarActor self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_ScalarBarActor_GetTitleOnlyVisibility(self, *args)

SMESH_ScalarBarActor_swigregister = _SMESH.SMESH_ScalarBarActor_swigregister
SMESH_ScalarBarActor_swigregister(SMESH_ScalarBarActor)

def SMESH_ScalarBarActor_IsTypeOf(*args):
    """
    SMESH_ScalarBarActor_IsTypeOf(char const * type) -> vtkTypeBool

    :type type: const char *
    :rtype: vtkTypeBool

    """
    return _SMESH.SMESH_ScalarBarActor_IsTypeOf(*args)

def SMESH_ScalarBarActor_SafeDownCast(*args):
    """
    SMESH_ScalarBarActor_SafeDownCast(vtkObjectBase * o) -> SMESH_ScalarBarActor

    :type o: vtkObjectBase
    :rtype: OCC.wrapper.SMESH.SMESH_ScalarBarActor

    """
    return _SMESH.SMESH_ScalarBarActor_SafeDownCast(*args)

def SMESH_ScalarBarActor_New(*args):
    """
    SMESH_ScalarBarActor_New() -> SMESH_ScalarBarActor

    :rtype: OCC.wrapper.SMESH.SMESH_ScalarBarActor

    """
    return _SMESH.SMESH_ScalarBarActor_New(*args)

class shared_ptr_FaceQuadStruct(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _SMESH.new_shared_ptr_FaceQuadStruct(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        return _SMESH.shared_ptr_FaceQuadStruct___deref__(self)

    def __ref__(self):
        return _SMESH.shared_ptr_FaceQuadStruct___ref__(self)
    __swig_destroy__ = _SMESH.delete_shared_ptr_FaceQuadStruct
shared_ptr_FaceQuadStruct_swigregister = _SMESH.shared_ptr_FaceQuadStruct_swigregister
shared_ptr_FaceQuadStruct_swigregister(shared_ptr_FaceQuadStruct)


try:
	TFaceQuadStructPtr = shared_ptr_FaceQuadStruct
except NameError:
	pass # does not exist, probably ignored

class SMDS_Iterator_TopoDS_Shape(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def more(self, *args):
        """
        more(SMDS_Iterator_TopoDS_Shape self) -> bool

        Return true if and only if there are other object in this iterator

        :rtype: bool

        """
        return _SMESH.SMDS_Iterator_TopoDS_Shape_more(self, *args)


    def next(self, *args):
        """
        next(SMDS_Iterator_TopoDS_Shape self) -> TopoDS_Shape

        Return the current object and step to the next one

        :rtype: VALUE

        """
        return _SMESH.SMDS_Iterator_TopoDS_Shape_next(self, *args)


    def remove(self, *args):
        """
        remove(SMDS_Iterator_TopoDS_Shape self)

        Delete the current element and step to the next one


        """
        return _SMESH.SMDS_Iterator_TopoDS_Shape_remove(self, *args)

    __swig_destroy__ = _SMESH.delete_SMDS_Iterator_TopoDS_Shape
SMDS_Iterator_TopoDS_Shape_swigregister = _SMESH.SMDS_Iterator_TopoDS_Shape_swigregister
SMDS_Iterator_TopoDS_Shape_swigregister(SMDS_Iterator_TopoDS_Shape)


try:
	PShapeIterator = SMDS_Iterator_TopoDS_Shape
except NameError:
	pass # does not exist, probably ignored

class SMESH_LogicalFilter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    LO_OR = _SMESH.SMESH_LogicalFilter_LO_OR
    LO_AND = _SMESH.SMESH_LogicalFilter_LO_AND
    LO_NOT = _SMESH.SMESH_LogicalFilter_LO_NOT
    LO_UNDEFINED = _SMESH.SMESH_LogicalFilter_LO_UNDEFINED

    def __init__(self, *args):
        """
        __init__(SMESH_LogicalFilter self, QList< SUIT_SelectionFilter * > const & arg2, int const arg3, bool takeOwnership=False) -> SMESH_LogicalFilter

        :type : OCC.wrapper.SMESH.QList_SUIT_SelectionFilter
        :type : const int
        :type takeOwnership: bool

        """
        this = _SMESH.new_SMESH_LogicalFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def isOk(self, *args):
        """
        isOk(SMESH_LogicalFilter self, SUIT_DataOwner const * arg2) -> bool

        :type : SUIT_DataOwner
        :rtype: bool

        """
        return _SMESH.SMESH_LogicalFilter_isOk(self, *args)


    def setFilters(self, *args):
        """
        setFilters(SMESH_LogicalFilter self, QList< SUIT_SelectionFilter * > const & arg2)

        :type : OCC.wrapper.SMESH.QList_SUIT_SelectionFilter

        """
        return _SMESH.SMESH_LogicalFilter_setFilters(self, *args)


    def setOperation(self, *args):
        """
        setOperation(SMESH_LogicalFilter self, int const arg2)

        :type : const int

        """
        return _SMESH.SMESH_LogicalFilter_setOperation(self, *args)


    def getFilters(self, *args):
        """
        getFilters(SMESH_LogicalFilter self) -> QList< SUIT_SelectionFilter * > const

        :rtype: OCC.wrapper.SMESH.QList_SUIT_SelectionFilter

        """
        return _SMESH.SMESH_LogicalFilter_getFilters(self, *args)


    def getOperation(self, *args):
        """
        getOperation(SMESH_LogicalFilter self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_LogicalFilter_getOperation(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_LogicalFilter
SMESH_LogicalFilter_swigregister = _SMESH.SMESH_LogicalFilter_swigregister
SMESH_LogicalFilter_swigregister(SMESH_LogicalFilter)

class Handle_SMESH_SubMeshVSLink(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_SMESH_SubMeshVSLink self)

        Nullify the handle


        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_SMESH_SubMeshVSLink self) -> bool

        Check for being null

        :rtype: bool

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_SMESH_SubMeshVSLink self, SMESH_SubMeshVSLink thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_SMESH_SubMeshVSLink self, Handle_SMESH_SubMeshVSLink theHandle) -> Handle_SMESH_SubMeshVSLink
        assign(Handle_SMESH_SubMeshVSLink self, SMESH_SubMeshVSLink thePtr) -> Handle_SMESH_SubMeshVSLink
        assign(Handle_SMESH_SubMeshVSLink self, Handle_SMESH_SubMeshVSLink theHandle) -> Handle_SMESH_SubMeshVSLink

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_SMESH_SubMeshVSLink self) -> SMESH_SubMeshVSLink

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_SMESH_SubMeshVSLink self) -> SMESH_SubMeshVSLink

        Member access operator (note non-const)

        :rtype: T *

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_SMESH_SubMeshVSLink self) -> SMESH_SubMeshVSLink

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink___ref__(self, *args)


    def __hash__(self):
        return _SMESH.Handle_SMESH_SubMeshVSLink___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _SMESH.Handle_SMESH_SubMeshVSLink___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _SMESH.new_Handle_SMESH_SubMeshVSLink(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_SMESH.Handle_SMESH_SubMeshVSLink_DownCast)
    __swig_destroy__ = _SMESH.delete_Handle_SMESH_SubMeshVSLink

    def SetDisplayMode(self, *args):
        """
        SetDisplayMode(Handle_SMESH_SubMeshVSLink self, int displaymode)

        :type displaymode: int

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_SetDisplayMode(self, *args)


    def GetHiddenNodes(self, *args):
        """
        GetHiddenNodes(Handle_SMESH_SubMeshVSLink self, int planedir, double value, TColStd_PackedMapOfInteger hiddennodes)

        :type planedir: int
        :type value: double
        :type hiddennodes: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_GetHiddenNodes(self, *args)


    def GetHiddenElements(self, *args):
        """
        GetHiddenElements(Handle_SMESH_SubMeshVSLink self, int planedir, double value, TColStd_PackedMapOfInteger hiddenelems)

        :type planedir: int
        :type value: double
        :type hiddenelems: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_GetHiddenElements(self, *args)


    def GetNodeNormal(self, *args):
        """
        GetNodeNormal(Handle_SMESH_SubMeshVSLink self, Standard_Integer const ranknode, Standard_Integer const Id) -> Standard_Boolean

        :type ranknode: int
        :type Id: int
        :type nx: float
        :type ny: float
        :type nz: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_GetNodeNormal(self, *args)


    def GetGeom(self, *args):
        """
        GetGeom(Handle_SMESH_SubMeshVSLink self, Standard_Integer const ID, Standard_Boolean const IsElement, NCollection_Array1_Standard_Real Coords) -> Standard_Boolean

        Returns geometry information about node ( if IsElement is False ) or element ( IsElement is True ) <br>
        by co-ordinates. For element this method must return all its nodes co-ordinates in the strict order: X, Y, Z and <br>
        with nodes order is the same as in wire bounding the face or link. NbNodes is number of nodes of element. <br>
        It is recommended to return 1 for node. Type is an element type. <br>

        :type ID: int
        :type IsElement: bool
        :type Coords: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NbNodes: int
        :type Type: OCC.wrapper.MeshVS.MeshVS_EntityType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_GetGeom(self, *args)


    def Get3DGeom(self, *args):
        """
        Get3DGeom(Handle_SMESH_SubMeshVSLink self, Standard_Integer const ID, Handle_MeshVS_HArray1OfSequenceOfInteger Data) -> Standard_Boolean

        :type ID: int
        :type NbNodes: int
        :type Data: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_Get3DGeom(self, *args)


    def GetGeomType(self, *args):
        """
        GetGeomType(Handle_SMESH_SubMeshVSLink self, Standard_Integer const ID, Standard_Boolean const IsElement) -> Standard_Boolean

        This method is similar to GetGeom, but returns only element or node type. This method is provided for <br>
        a fine performance. <br>

        :type ID: int
        :type IsElement: bool
        :type Type: OCC.wrapper.MeshVS.MeshVS_EntityType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_GetGeomType(self, *args)


    def GetAddr(self, *args):
        """
        GetAddr(Handle_SMESH_SubMeshVSLink self, Standard_Integer const ID, Standard_Boolean const IsElement) -> Standard_Address

        This method returns by number an address of any entity which represents element or node data structure. <br>

        :type ID: int
        :type IsElement: bool
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_GetAddr(self, *args)


    def GetNodesByElement(self, *args):
        """
        GetNodesByElement(Handle_SMESH_SubMeshVSLink self, Standard_Integer const ID, NCollection_Array1_Standard_Integer NodeIDs) -> Standard_Boolean

        This method returns information about what node this element consist of. <br>

        :type ID: int
        :type NodeIDs: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type NbNodes: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_GetNodesByElement(self, *args)


    def GetAllNodes(self, *args):
        """
        This method returns map of all nodes the object consist of. <br>

        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        res = _SMESH.Handle_SMESH_SubMeshVSLink_GetAllNodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetAllElements(self, *args):
        """
        This method returns map of all elements the object consist of. <br>

        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        res = _SMESH.Handle_SMESH_SubMeshVSLink_GetAllElements(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetNormal(self, *args):
        """
        GetNormal(Handle_SMESH_SubMeshVSLink self, Standard_Integer const Id, Standard_Integer const Max) -> Standard_Boolean

        This method calculates normal of face, which is using for correct reflection presentation. <br>
        There is default method, for advance reflection this method can be redefined. <br>

        :type Id: int
        :type Max: int
        :type nx: float
        :type ny: float
        :type nz: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_GetNormal(self, *args)


    def GetAllGroups(self, *args):
        """
        GetAllGroups(Handle_SMESH_SubMeshVSLink self, TColStd_PackedMapOfInteger Ids)

        This method returns map of all groups the object contains. <br>

        :type Ids: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_GetAllGroups(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_SMESH_SubMeshVSLink self) -> char const *

        :rtype: const char *

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SMESH.Handle_SMESH_SubMeshVSLink_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SMESH.Handle_SMESH_SubMeshVSLink_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetPrismTopology(self, *args):
        """
        GetPrismTopology(Handle_SMESH_SubMeshVSLink self, Standard_Integer const BasePoints) -> Handle_MeshVS_HArray1OfSequenceOfInteger

        :type BasePoints: int
        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_GetPrismTopology(self, *args)


    def GetPyramidTopology(self, *args):
        """
        GetPyramidTopology(Handle_SMESH_SubMeshVSLink self, Standard_Integer const BasePoints) -> Handle_MeshVS_HArray1OfSequenceOfInteger

        :type BasePoints: int
        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_GetPyramidTopology(self, *args)


    def CreatePrismTopology(self, *args):
        """
        CreatePrismTopology(Handle_SMESH_SubMeshVSLink self, Standard_Integer const BasePoints) -> Handle_MeshVS_HArray1OfSequenceOfInteger

        :type BasePoints: int
        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_CreatePrismTopology(self, *args)


    def CreatePyramidTopology(self, *args):
        """
        CreatePyramidTopology(Handle_SMESH_SubMeshVSLink self, Standard_Integer const BasePoints) -> Handle_MeshVS_HArray1OfSequenceOfInteger

        :type BasePoints: int
        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_CreatePyramidTopology(self, *args)


    def GetNormalsByElement(self, *args):
        """
        GetNormalsByElement(Handle_SMESH_SubMeshVSLink self, Standard_Integer const Id, Standard_Boolean const IsNodal, Standard_Integer const MaxNodes, Handle_TColStd_HArray1OfReal Normals) -> Standard_Boolean

        This method puts components of normal vectors at each node of a mesh face (at each face of a mesh volume)
        into the output array.
        Returns false if some problem was detected during calculation of normals.
        Id is an identifier of the mesh element.
        IsNodal, when true, means that normals at mesh element nodes are needed. If nodal normals
        are not available, or IsNodal is false, or the mesh element is a volume, then the output array contents
        depend on the element type:
        face: a normal calculated by GetNormal() is duplicated for each node of the face;
        volume: normals to all faces of the volume are computed (not for each node!).
        MaxNodes is maximal number of nodes an element can consist of.
        Normals contains the result.

        :type Id: int
        :type IsNodal: bool
        :type MaxNodes: int
        :type Normals: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_GetNormalsByElement(self, *args)


    def GetGroup(self, *args):
        """
        GetGroup(Handle_SMESH_SubMeshVSLink self, Standard_Integer const Id, TColStd_PackedMapOfInteger Ids) -> Standard_Boolean

        This method returns map of all group elements.

        :type Id: int
        :type Type: OCC.wrapper.MeshVS.MeshVS_EntityType
        :type Ids: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_GetGroup(self, *args)


    def GetGroupAddr(self, *args):
        """
        GetGroupAddr(Handle_SMESH_SubMeshVSLink self, Standard_Integer const ID) -> Standard_Address

        This method returns pointer which represents group data structure.
        This address will be saved in MeshVS_MeshOwner, so that you can access to data structure fast
        by the method Owner(). In the redefined method you can return NULL.
        ID is the numerical identificator of group

        :type ID: int
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_GetGroupAddr(self, *args)


    def IsAdvancedSelectionEnabled(self, *args):
        """
        IsAdvancedSelectionEnabled(Handle_SMESH_SubMeshVSLink self) -> Standard_Boolean

        Returns True if advanced mesh selection is enabled.
        Default implementation returns False.
        It should be redefined to return True for advanced
        mesh selection activation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_IsAdvancedSelectionEnabled(self, *args)


    def GetBoundingBox(self, *args):
        """
        GetBoundingBox(Handle_SMESH_SubMeshVSLink self) -> Bnd_Box

        Returns the bounding box of the whole mesh.
        It is used in advanced selection mode to define roughly
        the sensitive area of the mesh.
        It can be redefined to get access to a box computed in advance.

        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_GetBoundingBox(self, *args)


    def GetDetectedEntities(self, *args):
        """
        GetDetectedEntities(Handle_SMESH_SubMeshVSLink self, Handle_MeshVS_Mesh Prs, Standard_Real const X, Standard_Real const Y, Standard_Real const aTol, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elements) -> Standard_Boolean
        GetDetectedEntities(Handle_SMESH_SubMeshVSLink self, Handle_MeshVS_Mesh Prs, Standard_Real const XMin, Standard_Real const YMin, Standard_Real const XMax, Standard_Real const YMax, Standard_Real const aTol, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elements) -> Standard_Boolean
        GetDetectedEntities(Handle_SMESH_SubMeshVSLink self, Handle_MeshVS_Mesh Prs, NCollection_Array1_gp_Pnt2d Polyline, Bnd_Box2d aBox, Standard_Real const aTol, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elements) -> Standard_Boolean
        GetDetectedEntities(Handle_SMESH_SubMeshVSLink self, Handle_MeshVS_Mesh Prs, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elements) -> Standard_Boolean

        Filter out the maps of mesh entities so as to keep
        only the entities that are allowed to be selected
        according to the current context.
        Returns True if any of the maps has been changed.
        It should be redefined if the advanced mesh selection is
        activated. Default implementation returns False.

        :type Prs: OCC.wrapper.MeshVS.Handle_MeshVS_Mesh
        :type Nodes: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger
        :type Elements: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_GetDetectedEntities(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_SMESH_SubMeshVSLink self)

        Memory deallocator for transient classes


        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_SMESH_SubMeshVSLink self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_SMESH_SubMeshVSLink self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_SMESH_SubMeshVSLink self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_SMESH_SubMeshVSLink self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_SMESH_SubMeshVSLink self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_SMESH_SubMeshVSLink self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_SMESH_SubMeshVSLink self)

        Increments the reference counter of this object


        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_SMESH_SubMeshVSLink self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SMESH.Handle_SMESH_SubMeshVSLink_DecrementRefCounter(self, *args)

Handle_SMESH_SubMeshVSLink_swigregister = _SMESH.Handle_SMESH_SubMeshVSLink_swigregister
Handle_SMESH_SubMeshVSLink_swigregister(Handle_SMESH_SubMeshVSLink)

def Handle_SMESH_SubMeshVSLink_DownCast(thing):
    return _SMESH.Handle_SMESH_SubMeshVSLink_DownCast(thing)
Handle_SMESH_SubMeshVSLink_DownCast = _SMESH.Handle_SMESH_SubMeshVSLink_DownCast

class SMESH_subMesh(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    NOT_READY = _SMESH.SMESH_subMesh_NOT_READY
    READY_TO_COMPUTE = _SMESH.SMESH_subMesh_READY_TO_COMPUTE
    COMPUTE_OK = _SMESH.SMESH_subMesh_COMPUTE_OK
    FAILED_TO_COMPUTE = _SMESH.SMESH_subMesh_FAILED_TO_COMPUTE
    NO_ALGO = _SMESH.SMESH_subMesh_NO_ALGO
    MISSING_HYP = _SMESH.SMESH_subMesh_MISSING_HYP
    HYP_OK = _SMESH.SMESH_subMesh_HYP_OK
    ADD_HYP = _SMESH.SMESH_subMesh_ADD_HYP
    ADD_ALGO = _SMESH.SMESH_subMesh_ADD_ALGO
    REMOVE_HYP = _SMESH.SMESH_subMesh_REMOVE_HYP
    REMOVE_ALGO = _SMESH.SMESH_subMesh_REMOVE_ALGO
    ADD_FATHER_HYP = _SMESH.SMESH_subMesh_ADD_FATHER_HYP
    ADD_FATHER_ALGO = _SMESH.SMESH_subMesh_ADD_FATHER_ALGO
    REMOVE_FATHER_HYP = _SMESH.SMESH_subMesh_REMOVE_FATHER_HYP
    REMOVE_FATHER_ALGO = _SMESH.SMESH_subMesh_REMOVE_FATHER_ALGO
    MODIF_HYP = _SMESH.SMESH_subMesh_MODIF_HYP
    MODIF_ALGO_STATE = _SMESH.SMESH_subMesh_MODIF_ALGO_STATE
    COMPUTE = _SMESH.SMESH_subMesh_COMPUTE
    COMPUTE_SUBMESH = _SMESH.SMESH_subMesh_COMPUTE_SUBMESH
    COMPUTE_NOGEOM = _SMESH.SMESH_subMesh_COMPUTE_NOGEOM
    COMPUTE_CANCELED = _SMESH.SMESH_subMesh_COMPUTE_CANCELED
    CLEAN = _SMESH.SMESH_subMesh_CLEAN
    SUBMESH_COMPUTED = _SMESH.SMESH_subMesh_SUBMESH_COMPUTED
    SUBMESH_RESTORED = _SMESH.SMESH_subMesh_SUBMESH_RESTORED
    SUBMESH_LOADED = _SMESH.SMESH_subMesh_SUBMESH_LOADED
    MESH_ENTITY_REMOVED = _SMESH.SMESH_subMesh_MESH_ENTITY_REMOVED
    CHECK_COMPUTE_STATE = _SMESH.SMESH_subMesh_CHECK_COMPUTE_STATE
    ALGO_EVENT = _SMESH.SMESH_subMesh_ALGO_EVENT
    COMPUTE_EVENT = _SMESH.SMESH_subMesh_COMPUTE_EVENT

    def __init__(self, *args):
        """
        __init__(SMESH_subMesh self, int Id, SMESH_Mesh father, SMESHDS_Mesh meshDS, TopoDS_Shape aSubShape) -> SMESH_subMesh

        :type Id: int
        :type father: OCC.wrapper.SMESH.SMESH_Mesh
        :type meshDS: OCC.wrapper.SMESHDS.SMESHDS_Mesh
        :type aSubShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _SMESH.new_SMESH_subMesh(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetId(self, *args):
        """
        GetId(SMESH_subMesh self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_subMesh_GetId(self, *args)


    def GetFather(self, *args):
        """
        GetFather(SMESH_subMesh self) -> SMESH_Mesh

        :rtype: OCC.wrapper.SMESH.SMESH_Mesh

        """
        return _SMESH.SMESH_subMesh_GetFather(self, *args)


    def GetSubMeshDS(self, *args):
        """
        GetSubMeshDS(SMESH_subMesh self) -> SMESHDS_SubMesh
        GetSubMeshDS(SMESH_subMesh self) -> SMESHDS_SubMesh

        :rtype: OCC.wrapper.SMESHDS.SMESHDS_SubMesh

        """
        return _SMESH.SMESH_subMesh_GetSubMeshDS(self, *args)


    def CreateSubMeshDS(self, *args):
        """
        CreateSubMeshDS(SMESH_subMesh self) -> SMESHDS_SubMesh

        :rtype: OCC.wrapper.SMESHDS.SMESHDS_SubMesh

        """
        return _SMESH.SMESH_subMesh_CreateSubMeshDS(self, *args)


    def GetFirstToCompute(self, *args):
        """
        GetFirstToCompute(SMESH_subMesh self) -> SMESH_subMesh

        :rtype: OCC.wrapper.SMESH.SMESH_subMesh

        """
        return _SMESH.SMESH_subMesh_GetFirstToCompute(self, *args)


    def GetAlgo(self, *args):
        """
        GetAlgo(SMESH_subMesh self) -> SMESH_Algo

        :rtype: OCC.wrapper.SMESH.SMESH_Algo

        """
        return _SMESH.SMESH_subMesh_GetAlgo(self, *args)


    def DependsOn(self, *args):
        """
        DependsOn(SMESH_subMesh self) -> SMESH_subMesh
        DependsOn(SMESH_subMesh self, SMESH_subMesh other) -> bool
        DependsOn(SMESH_subMesh self, int const shapeID) -> bool

        :type shapeID: const int
        :rtype: bool

        """
        return _SMESH.SMESH_subMesh_DependsOn(self, *args)


    def getDependsOnIterator(self, *args):
        """
        getDependsOnIterator(SMESH_subMesh self, bool const includeSelf, bool const complexShapeFirst=False) -> shared_ptr_SMDS_Iterator_SMESH_subMesh

        rief Return iterator on the sub-meshes this one depends on. By default
        most simple sub-meshes go first.

        :type includeSelf: const bool
        :type complexShapeFirst: const bool
        :rtype: OCC.wrapper.SMESH.SMESH_subMeshIteratorPtr

        """
        return _SMESH.SMESH_subMesh_getDependsOnIterator(self, *args)


    def GetAncestors(self, *args):
        """
        GetAncestors(SMESH_subMesh self) -> SMESH_subMesh

        :rtype: const int &

        """
        return _SMESH.SMESH_subMesh_GetAncestors(self, *args)


    def ClearAncestors(self, *args):
        """ClearAncestors(SMESH_subMesh self)"""
        return _SMESH.SMESH_subMesh_ClearAncestors(self, *args)


    def GetSubShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _SMESH.SMESH_subMesh_GetSubShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetEventListener(self, *args):
        """
        SetEventListener(SMESH_subMesh self, SMESH_subMeshEventListener listener, EventListenerData * data, SMESH_subMesh where)

        rief Sets an event listener and its data to a submesh
        \param listener - the listener to store
        \param data - the listener data to store
        \param where - the submesh to store the listener and it's data

        The method remembers the submesh where it puts the listener in order to delete
        it when HYP_OK algo_state is lost
        After being set, event listener is notified on each event of where submesh.

        :type listener: EventListener
        :type data: EventListenerData
        :type where: OCC.wrapper.SMESH.SMESH_subMesh

        """
        return _SMESH.SMESH_subMesh_SetEventListener(self, *args)


    def GetEventListenerData(self, *args):
        """
        GetEventListenerData(SMESH_subMesh self, SMESH_subMeshEventListener listener, bool const myOwn=False) -> EventListenerData
        GetEventListenerData(SMESH_subMesh self, std::string const & listenerName, bool const myOwn=False) -> EventListenerData *

        rief Return an event listener data
        \param listenerName - the listener name
        \param myOwn - if \c true, returns a listener set by this sub-mesh,
        else returns a listener listening to events of this sub-mesh
        etval EventListenerData* - found data, maybe NULL

        :type listenerName: string
        :type myOwn: const bool
        :rtype: EventListenerData

        """
        return _SMESH.SMESH_subMesh_GetEventListenerData(self, *args)


    def DeleteEventListener(self, *args):
        """
        DeleteEventListener(SMESH_subMesh self, SMESH_subMeshEventListener listener)

        rief Unregister the listener and delete it and it's data
        \param listener - the event listener to delete

        :type listener: EventListener

        """
        return _SMESH.SMESH_subMesh_DeleteEventListener(self, *args)


    def AlgoStateEngine(self, *args):
        """
        AlgoStateEngine(SMESH_subMesh self, SMESH_subMesh::algo_event event, SMESH_Hypothesis anHyp) -> SMESH_Hypothesis::Hypothesis_Status

        :type event: algo_event
        :type anHyp: OCC.wrapper.SMESH.SMESH_Hypothesis
        :rtype: Hypothesis_Status

        """
        return _SMESH.SMESH_subMesh_AlgoStateEngine(self, *args)


    def SubMeshesAlgoStateEngine(self, *args):
        """
        SubMeshesAlgoStateEngine(SMESH_subMesh self, SMESH_subMesh::algo_event event, SMESH_Hypothesis anHyp, bool exitOnFatal=False) -> SMESH_Hypothesis::Hypothesis_Status

        :type event: algo_event
        :type anHyp: OCC.wrapper.SMESH.SMESH_Hypothesis
        :type exitOnFatal: bool
        :rtype: Hypothesis_Status

        """
        return _SMESH.SMESH_subMesh_SubMeshesAlgoStateEngine(self, *args)


    def GetAlgoState(self, *args):
        """
        GetAlgoState(SMESH_subMesh self) -> SMESH_subMesh::algo_state

        :rtype: algo_state

        """
        return _SMESH.SMESH_subMesh_GetAlgoState(self, *args)


    def GetComputeState(self, *args):
        """
        GetComputeState(SMESH_subMesh self) -> SMESH_subMesh::compute_state

        :rtype: compute_state

        """
        return _SMESH.SMESH_subMesh_GetComputeState(self, *args)


    def GetComputeError(self, *args):
        """
        GetComputeError(SMESH_subMesh self) -> shared_ptr_SMESH_ComputeError

        :rtype: OCC.wrapper.SMESH.SMESH_ComputeErrorPtr

        """
        return _SMESH.SMESH_subMesh_GetComputeError(self, *args)


    def DumpAlgoState(self, *args):
        """
        DumpAlgoState(SMESH_subMesh self, bool isMain)

        :type isMain: bool

        """
        return _SMESH.SMESH_subMesh_DumpAlgoState(self, *args)


    def ComputeStateEngine(self, *args):
        """
        ComputeStateEngine(SMESH_subMesh self, SMESH_subMesh::compute_event event) -> bool

        :type event: compute_event
        :rtype: bool

        """
        return _SMESH.SMESH_subMesh_ComputeStateEngine(self, *args)


    def ComputeSubMeshStateEngine(self, *args):
        """
        ComputeSubMeshStateEngine(SMESH_subMesh self, SMESH_subMesh::compute_event event, bool const includeSelf=False)

        :type event: compute_event
        :type includeSelf: const bool

        """
        return _SMESH.SMESH_subMesh_ComputeSubMeshStateEngine(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(SMESH_subMesh self, MapShapeNbElems & aResMap) -> bool

        :type aResMap: MapShapeNbElems
        :rtype: bool

        """
        return _SMESH.SMESH_subMesh_Evaluate(self, *args)


    def IsConform(self, *args):
        """
        IsConform(SMESH_subMesh self, SMESH_Algo theAlgo) -> bool

        :type theAlgo: OCC.wrapper.SMESH.SMESH_Algo
        :rtype: bool

        """
        return _SMESH.SMESH_subMesh_IsConform(self, *args)


    def CanAddHypothesis(self, *args):
        """
        CanAddHypothesis(SMESH_subMesh self, SMESH_Hypothesis theHypothesis) -> bool

        :type theHypothesis: OCC.wrapper.SMESH.SMESH_Hypothesis
        :rtype: bool

        """
        return _SMESH.SMESH_subMesh_CanAddHypothesis(self, *args)


    def IsApplicableHypothesis(self, *args):
        """
        IsApplicableHypothesis(SMESH_subMesh self, SMESH_Hypothesis theHypothesis, TopAbs_ShapeEnum const theShapeType) -> bool
        IsApplicableHypothesis(SMESH_subMesh self, SMESH_Hypothesis theHypothesis) -> bool

        :type theHypothesis: OCC.wrapper.SMESH.SMESH_Hypothesis
        :rtype: bool

        """
        return _SMESH.SMESH_subMesh_IsApplicableHypothesis(self, *args)


    def CheckConcurrentHypothesis(self, *args):
        """
        CheckConcurrentHypothesis(SMESH_subMesh self, int const theHypType) -> SMESH_Hypothesis::Hypothesis_Status

        :type theHypType: const int
        :rtype: Hypothesis_Status

        """
        return _SMESH.SMESH_subMesh_CheckConcurrentHypothesis(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(SMESH_subMesh self) -> bool

        rief Return true if no mesh entities is bound to the submesh

        :rtype: bool

        """
        return _SMESH.SMESH_subMesh_IsEmpty(self, *args)


    def IsMeshComputed(self, *args):
        """
        IsMeshComputed(SMESH_subMesh self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_subMesh_IsMeshComputed(self, *args)


    def SetIsAlwaysComputed(self, *args):
        """
        SetIsAlwaysComputed(SMESH_subMesh self, bool isAlCo)

        rief Allow algo->Compute() if a subshape of lower dim is meshed but
        none mesh entity is bound to it

        :type isAlCo: bool

        """
        return _SMESH.SMESH_subMesh_SetIsAlwaysComputed(self, *args)


    def IsAlwaysComputed(self, *args):
        """
        IsAlwaysComputed(SMESH_subMesh self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_subMesh_IsAlwaysComputed(self, *args)


    def SubMeshesComputed(self, *args):
        """
        SubMeshesComputed(SMESH_subMesh self, bool * isFailedToCompute=None) -> bool

        :type isFailedToCompute: bool *
        :rtype: bool

        """
        return _SMESH.SMESH_subMesh_SubMeshesComputed(self, *args)


    def GetComputeCost(self, *args):
        """
        GetComputeCost(SMESH_subMesh self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_subMesh_GetComputeCost(self, *args)


    def FindIntersection(self, *args):
        """
        FindIntersection(SMESH_subMesh self, SMESH_subMesh theOther, std::set< SMESH_subMesh const *,std::less< SMESH_subMesh const * >,std::allocator< SMESH_subMesh const * > > & theSetOfCommon) -> bool

        rief  Find common submeshes (based on shared subshapes with other
        \param theOther submesh to check
        \param theCommonIds set of common submesh IDs
        NOTE: this method does not cleat set before collect common IDs

        :type theOther: OCC.wrapper.SMESH.SMESH_subMesh
        :type theSetOfCommon: int &
        :rtype: bool

        """
        return _SMESH.SMESH_subMesh_FindIntersection(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_subMesh
SMESH_subMesh_swigregister = _SMESH.SMESH_subMesh_swigregister
SMESH_subMesh_swigregister(SMESH_subMesh)

class SMESH_Delaunay(object):
    """
    rief Create a Delaunay triangulation of nodes on a face boundary
    and provide exploration of nodes shared by elements lying on
    the face. For a returned node, also return a Delaunay triangle
    the node lies in and its Barycentric Coordinates within the triangle.
    Only non-marked nodes are visited. Boundary nodes given at the construction
    are not returned.

    For usage, this class needs to be subclassed to implement getNodeUV();
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def InitTraversal(self, *args):
        """
        InitTraversal(SMESH_Delaunay self, int const nbNodesToVisit=-1)

        :type nbNodesToVisit: const int

        """
        return _SMESH.SMESH_Delaunay_InitTraversal(self, *args)


    def NbVisitedNodes(self, *args):
        """
        NbVisitedNodes(SMESH_Delaunay self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_Delaunay_NbVisitedNodes(self, *args)


    def GetTriangleNear(self, *args):
        """
        GetTriangleNear(SMESH_Delaunay self, int iBndNode) -> BRepMesh_Triangle

        :type iBndNode: int
        :rtype: OCC.wrapper.BRepMesh.BRepMesh_Triangle

        """
        return _SMESH.SMESH_Delaunay_GetTriangleNear(self, *args)


    def GetBndNodes(self, *args):
        """
        GetBndNodes(SMESH_Delaunay self) -> SMDS_MeshNode

        :rtype: const int &

        """
        return _SMESH.SMESH_Delaunay_GetBndNodes(self, *args)


    def GetBndUV(self, *args):
        """
        GetBndUV(SMESH_Delaunay self, int const iNode) -> gp_XY

        :type iNode: const int
        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _SMESH.SMESH_Delaunay_GetBndUV(self, *args)


    def GetScale(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_XY

        """
        res = _SMESH.SMESH_Delaunay_GetScale(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ToPython(self, *args):
        """ToPython(SMESH_Delaunay self)"""
        return _SMESH.SMESH_Delaunay_ToPython(self, *args)


    def GetDS(self, *args):
        """
        GetDS(SMESH_Delaunay self) -> Handle_BRepMesh_DataStructureOfDelaun

        :rtype: OCC.wrapper.BRepMesh.Handle_BRepMesh_DataStructureOfDelaun

        """
        return _SMESH.SMESH_Delaunay_GetDS(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_Delaunay
SMESH_Delaunay_swigregister = _SMESH.SMESH_Delaunay_swigregister
SMESH_Delaunay_swigregister(SMESH_Delaunay)

class SMESH_ExtractGeometry(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def IsTypeOf(*args):
        """
        IsTypeOf(char const * type) -> vtkTypeBool

        :type type: const char *
        :rtype: vtkTypeBool

        """
        return _SMESH.SMESH_ExtractGeometry_IsTypeOf(*args)

    IsTypeOf = staticmethod(IsTypeOf)

    def IsA(self, *args):
        """
        IsA(SMESH_ExtractGeometry self, char const * type) -> vtkTypeBool

        :type type: const char *
        :rtype: vtkTypeBool

        """
        return _SMESH.SMESH_ExtractGeometry_IsA(self, *args)


    def SafeDownCast(*args):
        """
        SafeDownCast(vtkObjectBase * o) -> SMESH_ExtractGeometry

        :type o: vtkObjectBase
        :rtype: OCC.wrapper.SMESH.SMESH_ExtractGeometry

        """
        return _SMESH.SMESH_ExtractGeometry_SafeDownCast(*args)

    SafeDownCast = staticmethod(SafeDownCast)

    def NewInstance(self, *args):
        """
        NewInstance(SMESH_ExtractGeometry self) -> SMESH_ExtractGeometry

        :rtype: OCC.wrapper.SMESH.SMESH_ExtractGeometry

        """
        return _SMESH.SMESH_ExtractGeometry_NewInstance(self, *args)


    def New(*args):
        """
        New() -> SMESH_ExtractGeometry

        :rtype: OCC.wrapper.SMESH.SMESH_ExtractGeometry

        """
        return _SMESH.SMESH_ExtractGeometry_New(*args)

    New = staticmethod(New)

    def SetStoreMapping(self, *args):
        """
        SetStoreMapping(SMESH_ExtractGeometry self, bool theStoreMapping)

        :type theStoreMapping: bool

        """
        return _SMESH.SMESH_ExtractGeometry_SetStoreMapping(self, *args)


    def GetStoreMapping(self, *args):
        """
        GetStoreMapping(SMESH_ExtractGeometry self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_ExtractGeometry_GetStoreMapping(self, *args)


    def GetNodeObjId(self, *args):
        """
        GetNodeObjId(SMESH_ExtractGeometry self, int theVtkID) -> vtkIdType

        :type theVtkID: int
        :rtype: vtkIdType

        """
        return _SMESH.SMESH_ExtractGeometry_GetNodeObjId(self, *args)


    def GetElemObjId(self, *args):
        """
        GetElemObjId(SMESH_ExtractGeometry self, int theVtkID) -> vtkIdType

        :type theVtkID: int
        :rtype: vtkIdType

        """
        return _SMESH.SMESH_ExtractGeometry_GetElemObjId(self, *args)

SMESH_ExtractGeometry_swigregister = _SMESH.SMESH_ExtractGeometry_swigregister
SMESH_ExtractGeometry_swigregister(SMESH_ExtractGeometry)

def SMESH_ExtractGeometry_IsTypeOf(*args):
    """
    SMESH_ExtractGeometry_IsTypeOf(char const * type) -> vtkTypeBool

    :type type: const char *
    :rtype: vtkTypeBool

    """
    return _SMESH.SMESH_ExtractGeometry_IsTypeOf(*args)

def SMESH_ExtractGeometry_SafeDownCast(*args):
    """
    SMESH_ExtractGeometry_SafeDownCast(vtkObjectBase * o) -> SMESH_ExtractGeometry

    :type o: vtkObjectBase
    :rtype: OCC.wrapper.SMESH.SMESH_ExtractGeometry

    """
    return _SMESH.SMESH_ExtractGeometry_SafeDownCast(*args)

def SMESH_ExtractGeometry_New(*args):
    """
    SMESH_ExtractGeometry_New() -> SMESH_ExtractGeometry

    :rtype: OCC.wrapper.SMESH.SMESH_ExtractGeometry

    """
    return _SMESH.SMESH_ExtractGeometry_New(*args)

class SMESH_FaceOrientationFilter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def IsTypeOf(*args):
        """
        IsTypeOf(char const * type) -> vtkTypeBool

        :type type: const char *
        :rtype: vtkTypeBool

        """
        return _SMESH.SMESH_FaceOrientationFilter_IsTypeOf(*args)

    IsTypeOf = staticmethod(IsTypeOf)

    def IsA(self, *args):
        """
        IsA(SMESH_FaceOrientationFilter self, char const * type) -> vtkTypeBool

        :type type: const char *
        :rtype: vtkTypeBool

        """
        return _SMESH.SMESH_FaceOrientationFilter_IsA(self, *args)


    def SafeDownCast(*args):
        """
        SafeDownCast(vtkObjectBase * o) -> SMESH_FaceOrientationFilter

        :type o: vtkObjectBase
        :rtype: OCC.wrapper.SMESH.SMESH_FaceOrientationFilter

        """
        return _SMESH.SMESH_FaceOrientationFilter_SafeDownCast(*args)

    SafeDownCast = staticmethod(SafeDownCast)

    def NewInstance(self, *args):
        """
        NewInstance(SMESH_FaceOrientationFilter self) -> SMESH_FaceOrientationFilter

        :rtype: OCC.wrapper.SMESH.SMESH_FaceOrientationFilter

        """
        return _SMESH.SMESH_FaceOrientationFilter_NewInstance(self, *args)


    def New(*args):
        """
        New() -> SMESH_FaceOrientationFilter

        a new SMESH_FaceOrientationFilter.

        :rtype: OCC.wrapper.SMESH.SMESH_FaceOrientationFilter

        """
        return _SMESH.SMESH_FaceOrientationFilter_New(*args)

    New = staticmethod(New)

    def SetOrientationScale(self, *args):
        """
        SetOrientationScale(SMESH_FaceOrientationFilter self, double arg2)

        :type : double

        """
        return _SMESH.SMESH_FaceOrientationFilter_SetOrientationScale(self, *args)


    def GetOrientationScale(self, *args):
        """
        GetOrientationScale(SMESH_FaceOrientationFilter self) -> double

        :rtype: double

        """
        return _SMESH.SMESH_FaceOrientationFilter_GetOrientationScale(self, *args)


    def Set3dVectors(self, *args):
        """
        Set3dVectors(SMESH_FaceOrientationFilter self, bool arg2)

        :type : bool

        """
        return _SMESH.SMESH_FaceOrientationFilter_Set3dVectors(self, *args)


    def Get3dVectors(self, *args):
        """
        Get3dVectors(SMESH_FaceOrientationFilter self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_FaceOrientationFilter_Get3dVectors(self, *args)

SMESH_FaceOrientationFilter_swigregister = _SMESH.SMESH_FaceOrientationFilter_swigregister
SMESH_FaceOrientationFilter_swigregister(SMESH_FaceOrientationFilter)

def SMESH_FaceOrientationFilter_IsTypeOf(*args):
    """
    SMESH_FaceOrientationFilter_IsTypeOf(char const * type) -> vtkTypeBool

    :type type: const char *
    :rtype: vtkTypeBool

    """
    return _SMESH.SMESH_FaceOrientationFilter_IsTypeOf(*args)

def SMESH_FaceOrientationFilter_SafeDownCast(*args):
    """
    SMESH_FaceOrientationFilter_SafeDownCast(vtkObjectBase * o) -> SMESH_FaceOrientationFilter

    :type o: vtkObjectBase
    :rtype: OCC.wrapper.SMESH.SMESH_FaceOrientationFilter

    """
    return _SMESH.SMESH_FaceOrientationFilter_SafeDownCast(*args)

def SMESH_FaceOrientationFilter_New(*args):
    """
    SMESH_FaceOrientationFilter_New() -> SMESH_FaceOrientationFilter

    a new SMESH_FaceOrientationFilter.

    :rtype: OCC.wrapper.SMESH.SMESH_FaceOrientationFilter

    """
    return _SMESH.SMESH_FaceOrientationFilter_New(*args)

class SMESH_File(object):
    """rief High level util for effective file reading and other file operations"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(SMESH_File self, std::string const & name, bool openForReading=True) -> SMESH_File

        :type name: string
        :type openForReading: bool

        """
        this = _SMESH.new_SMESH_File(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def getName(self, *args):
        """
        getName(SMESH_File self) -> std::string

        :rtype: string

        """
        return _SMESH.SMESH_File_getName(self, *args)


    def error(self, *args):
        """
        :rtype: string

        """
        res = _SMESH.SMESH_File_error(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def close(self, *args):
        """close(SMESH_File self)"""
        return _SMESH.SMESH_File_close(self, *args)


    def remove(self, *args):
        """
        remove(SMESH_File self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_File_remove(self, *args)


    def size(self, *args):
        """
        size(SMESH_File self) -> long

        :rtype: long

        """
        return _SMESH.SMESH_File_size(self, *args)


    def exists(self, *args):
        """
        exists(SMESH_File self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_File_exists(self, *args)


    def isDirectory(self, *args):
        """
        isDirectory(SMESH_File self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_File_isDirectory(self, *args)


    def open(self, *args):
        """
        open(SMESH_File self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_File_open(self, *args)


    def __iadd__(self, *args):
        """
        __iadd__(SMESH_File self, int posDelta)

        :type posDelta: int

        """
        return _SMESH.SMESH_File___iadd__(self, *args)


    def eof(self, *args):
        """
        eof(SMESH_File self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_File_eof(self, *args)


    def end(self, *args):
        """
        end(SMESH_File self) -> char const *

        :rtype: const char *

        """
        return _SMESH.SMESH_File_end(self, *args)


    def getPos(self, *args):
        """
        getPos(SMESH_File self) -> char const *

        :rtype: const char *

        """
        return _SMESH.SMESH_File_getPos(self, *args)


    def setPos(self, *args):
        """
        setPos(SMESH_File self, char const * pos)

        :type pos: const char *

        """
        return _SMESH.SMESH_File_setPos(self, *args)


    def getLine(self, *args):
        """
        getLine(SMESH_File self) -> std::string

        :rtype: string

        """
        return _SMESH.SMESH_File_getLine(self, *args)


    def rewind(self, *args):
        """rewind(SMESH_File self)"""
        return _SMESH.SMESH_File_rewind(self, *args)


    def getInts(self, *args):
        """
        getInts(SMESH_File self, std::vector< int,std::allocator< int > > & ids) -> bool

        :type ids: int &
        :rtype: bool

        """
        return _SMESH.SMESH_File_getInts(self, *args)


    def openForWriting(self, *args):
        """
        openForWriting(SMESH_File self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_File_openForWriting(self, *args)


    def writeRaw(self, *args):
        """
        writeRaw(SMESH_File self, void const * data, size_t size) -> bool

        :type data: const void *
        :type size: size_t
        :rtype: bool

        """
        return _SMESH.SMESH_File_writeRaw(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_File
SMESH_File_swigregister = _SMESH.SMESH_File_swigregister
SMESH_File_swigregister(SMESH_File)

class SMESH_ActorDef(SMESH_Actor):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def IsTypeOf(*args):
        """
        IsTypeOf(char const * type) -> vtkTypeBool

        :type type: const char *
        :rtype: vtkTypeBool

        """
        return _SMESH.SMESH_ActorDef_IsTypeOf(*args)

    IsTypeOf = staticmethod(IsTypeOf)

    def IsA(self, *args):
        """
        IsA(SMESH_ActorDef self, char const * type) -> vtkTypeBool

        :type type: const char *
        :rtype: vtkTypeBool

        """
        return _SMESH.SMESH_ActorDef_IsA(self, *args)


    def SafeDownCast(*args):
        """
        SafeDownCast(vtkObjectBase * o) -> SMESH_ActorDef

        :type o: vtkObjectBase
        :rtype: OCC.wrapper.SMESH.SMESH_ActorDef

        """
        return _SMESH.SMESH_ActorDef_SafeDownCast(*args)

    SafeDownCast = staticmethod(SafeDownCast)

    def NewInstance(self, *args):
        """
        NewInstance(SMESH_ActorDef self) -> SMESH_ActorDef

        :rtype: OCC.wrapper.SMESH.SMESH_ActorDef

        """
        return _SMESH.SMESH_ActorDef_NewInstance(self, *args)


    def hasHighlight(self, *args):
        """
        hasHighlight(SMESH_ActorDef self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_ActorDef_hasHighlight(self, *args)


    def GetEntityMode(self, *args):
        """
        GetEntityMode(SMESH_ActorDef self) -> unsigned int

        :rtype: unsigned int

        """
        return _SMESH.SMESH_ActorDef_GetEntityMode(self, *args)


    def IsShrunkable(self, *args):
        """
        IsShrunkable(SMESH_ActorDef self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_ActorDef_IsShrunkable(self, *args)


    def IsShrunk(self, *args):
        """
        IsShrunk(SMESH_ActorDef self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_ActorDef_IsShrunk(self, *args)


    def GetControlMode(self, *args):
        """
        GetControlMode(SMESH_ActorDef self) -> SMESH_Actor::eControl

        :rtype: eControl

        """
        return _SMESH.SMESH_ActorDef_GetControlMode(self, *args)


    def GetFunctor(self, *args):
        """
        GetFunctor(SMESH_ActorDef self) -> SMESH::Controls::FunctorPtr

        :rtype: FunctorPtr

        """
        return _SMESH.SMESH_ActorDef_GetFunctor(self, *args)


    def GetScalarBarActor(self, *args):
        """
        GetScalarBarActor(SMESH_ActorDef self) -> SMESH_ScalarBarActor

        :rtype: OCC.wrapper.SMESH.SMESH_ScalarBarActor

        """
        return _SMESH.SMESH_ActorDef_GetScalarBarActor(self, *args)


    def GetObject(self, *args):
        """
        GetObject(SMESH_ActorDef self) -> shared_ptr_SMESH_VisualObj

        :rtype: TVisualObjPtr

        """
        return _SMESH.SMESH_ActorDef_GetObject(self, *args)


    def SetControlsPrecision(self, *args):
        """
        SetControlsPrecision(SMESH_ActorDef self, long const p)

        :type p: const long

        """
        return _SMESH.SMESH_ActorDef_SetControlsPrecision(self, *args)


    def GetControlsPrecision(self, *args):
        """
        GetControlsPrecision(SMESH_ActorDef self) -> long

        :rtype: long

        """
        return _SMESH.SMESH_ActorDef_GetControlsPrecision(self, *args)


    def GetPlot2Histogram(self, *args):
        """
        GetPlot2Histogram(SMESH_ActorDef self) -> SPlot2d_Histogram *

        :rtype: OCC.wrapper.SMESH.SPlot2d_Histogram

        """
        return _SMESH.SMESH_ActorDef_GetPlot2Histogram(self, *args)

SMESH_ActorDef_swigregister = _SMESH.SMESH_ActorDef_swigregister
SMESH_ActorDef_swigregister(SMESH_ActorDef)

def SMESH_ActorDef_IsTypeOf(*args):
    """
    SMESH_ActorDef_IsTypeOf(char const * type) -> vtkTypeBool

    :type type: const char *
    :rtype: vtkTypeBool

    """
    return _SMESH.SMESH_ActorDef_IsTypeOf(*args)

def SMESH_ActorDef_SafeDownCast(*args):
    """
    SMESH_ActorDef_SafeDownCast(vtkObjectBase * o) -> SMESH_ActorDef

    :type o: vtkObjectBase
    :rtype: OCC.wrapper.SMESH.SMESH_ActorDef

    """
    return _SMESH.SMESH_ActorDef_SafeDownCast(*args)

class SMESH_1D_Algo(SMESH_Algo):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _SMESH.delete_SMESH_1D_Algo
SMESH_1D_Algo_swigregister = _SMESH.SMESH_1D_Algo_swigregister
SMESH_1D_Algo_swigregister(SMESH_1D_Algo)

class SMDS_Iterator_SMESH_subMesh(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def more(self, *args):
        """
        more(SMDS_Iterator_SMESH_subMesh self) -> bool

        Return true if and only if there are other object in this iterator

        :rtype: bool

        """
        return _SMESH.SMDS_Iterator_SMESH_subMesh_more(self, *args)


    def next(self, *args):
        """
        next(SMDS_Iterator_SMESH_subMesh self) -> SMESH_subMesh

        Return the current object and step to the next one

        :rtype: VALUE

        """
        return _SMESH.SMDS_Iterator_SMESH_subMesh_next(self, *args)


    def remove(self, *args):
        """
        remove(SMDS_Iterator_SMESH_subMesh self)

        Delete the current element and step to the next one


        """
        return _SMESH.SMDS_Iterator_SMESH_subMesh_remove(self, *args)

    __swig_destroy__ = _SMESH.delete_SMDS_Iterator_SMESH_subMesh
SMDS_Iterator_SMESH_subMesh_swigregister = _SMESH.SMDS_Iterator_SMESH_subMesh_swigregister
SMDS_Iterator_SMESH_subMesh_swigregister(SMDS_Iterator_SMESH_subMesh)

class SMESH_Pattern(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ERR_OK = _SMESH.SMESH_Pattern_ERR_OK
    ERR_READ_NB_POINTS = _SMESH.SMESH_Pattern_ERR_READ_NB_POINTS
    ERR_READ_POINT_COORDS = _SMESH.SMESH_Pattern_ERR_READ_POINT_COORDS
    ERR_READ_TOO_FEW_POINTS = _SMESH.SMESH_Pattern_ERR_READ_TOO_FEW_POINTS
    ERR_READ_3D_COORD = _SMESH.SMESH_Pattern_ERR_READ_3D_COORD
    ERR_READ_NO_KEYPOINT = _SMESH.SMESH_Pattern_ERR_READ_NO_KEYPOINT
    ERR_READ_BAD_INDEX = _SMESH.SMESH_Pattern_ERR_READ_BAD_INDEX
    ERR_READ_ELEM_POINTS = _SMESH.SMESH_Pattern_ERR_READ_ELEM_POINTS
    ERR_READ_NO_ELEMS = _SMESH.SMESH_Pattern_ERR_READ_NO_ELEMS
    ERR_READ_BAD_KEY_POINT = _SMESH.SMESH_Pattern_ERR_READ_BAD_KEY_POINT
    ERR_SAVE_NOT_LOADED = _SMESH.SMESH_Pattern_ERR_SAVE_NOT_LOADED
    ERR_LOAD_EMPTY_SUBMESH = _SMESH.SMESH_Pattern_ERR_LOAD_EMPTY_SUBMESH
    ERR_LOADF_NARROW_FACE = _SMESH.SMESH_Pattern_ERR_LOADF_NARROW_FACE
    ERR_LOADF_CLOSED_FACE = _SMESH.SMESH_Pattern_ERR_LOADF_CLOSED_FACE
    ERR_LOADF_CANT_PROJECT = _SMESH.SMESH_Pattern_ERR_LOADF_CANT_PROJECT
    ERR_LOADV_BAD_SHAPE = _SMESH.SMESH_Pattern_ERR_LOADV_BAD_SHAPE
    ERR_LOADV_COMPUTE_PARAMS = _SMESH.SMESH_Pattern_ERR_LOADV_COMPUTE_PARAMS
    ERR_APPL_NOT_COMPUTED = _SMESH.SMESH_Pattern_ERR_APPL_NOT_COMPUTED
    ERR_APPL_NOT_LOADED = _SMESH.SMESH_Pattern_ERR_APPL_NOT_LOADED
    ERR_APPL_BAD_DIMENTION = _SMESH.SMESH_Pattern_ERR_APPL_BAD_DIMENTION
    ERR_APPL_BAD_NB_VERTICES = _SMESH.SMESH_Pattern_ERR_APPL_BAD_NB_VERTICES
    ERR_APPLF_BAD_TOPOLOGY = _SMESH.SMESH_Pattern_ERR_APPLF_BAD_TOPOLOGY
    ERR_APPLF_BAD_VERTEX = _SMESH.SMESH_Pattern_ERR_APPLF_BAD_VERTEX
    ERR_APPLF_INTERNAL_EEROR = _SMESH.SMESH_Pattern_ERR_APPLF_INTERNAL_EEROR
    ERR_APPLV_BAD_SHAPE = _SMESH.SMESH_Pattern_ERR_APPLV_BAD_SHAPE
    ERR_APPLF_BAD_FACE_GEOM = _SMESH.SMESH_Pattern_ERR_APPLF_BAD_FACE_GEOM
    ERR_MAKEM_NOT_COMPUTED = _SMESH.SMESH_Pattern_ERR_MAKEM_NOT_COMPUTED
    ERR_UNEXPECTED = _SMESH.SMESH_Pattern_ERR_UNEXPECTED

    def __init__(self, *args):
        """__init__(SMESH_Pattern self) -> SMESH_Pattern"""
        this = _SMESH.new_SMESH_Pattern(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self, *args):
        """Clear(SMESH_Pattern self)"""
        return _SMESH.SMESH_Pattern_Clear(self, *args)


    def Load(self, *args):
        """
        Load(SMESH_Pattern self, char const * theFileContents) -> bool
        Load(SMESH_Pattern self, SMESH_Mesh theMesh, TopoDS_Face theFace, bool theProject=False, TopoDS_Vertex the1stVertex, bool theKeepNodes=False) -> bool
        Load(SMESH_Pattern self, SMESH_Mesh theMesh, TopoDS_Shell theBlock, bool theKeepNodes=False) -> bool

        :type theMesh: OCC.wrapper.SMESH.SMESH_Mesh
        :type theBlock: OCC.wrapper.TopoDS.TopoDS_Shell
        :type theKeepNodes: bool
        :rtype: bool

        """
        return _SMESH.SMESH_Pattern_Load(self, *args)


    def Save(self, *args):
        """
        Save(SMESH_Pattern self, std::ostream & theFile) -> bool

        :type theFile: ostream
        :rtype: bool

        """
        return _SMESH.SMESH_Pattern_Save(self, *args)


    def Apply(self, *args):
        """
        Apply(SMESH_Pattern self, TopoDS_Face theFace, TopoDS_Vertex theVertexOnKeyPoint1, bool const theReverse) -> bool
        Apply(SMESH_Pattern self, TopoDS_Shell theBlock, TopoDS_Vertex theVertex000, TopoDS_Vertex theVertex001) -> bool
        Apply(SMESH_Pattern self, SMDS_MeshFace theFace, int const theNodeIndexOnKeyPoint1, bool const theReverse) -> bool
        Apply(SMESH_Pattern self, SMESH_Mesh theMesh, SMDS_MeshFace theFace, TopoDS_Shape theSurface, int const theNodeIndexOnKeyPoint1, bool const theReverse) -> bool
        Apply(SMESH_Pattern self, SMESH_Mesh theMesh, std::set< SMDS_MeshFace const *,std::less< SMDS_MeshFace const * >,std::allocator< SMDS_MeshFace const * > > & theFaces, int const theNodeIndexOnKeyPoint1, bool const theReverse) -> bool
        Apply(SMESH_Pattern self, SMDS_MeshVolume theVolume, int const theNode000Index, int const theNode001Index) -> bool
        Apply(SMESH_Pattern self, std::set< SMDS_MeshVolume const *,std::less< SMDS_MeshVolume const * >,std::allocator< SMDS_MeshVolume const * > > & theVolumes, int const theNode000Index, int const theNode001Index) -> bool

        :type theVolumes: int &
        :type theNode000Index: const int
        :type theNode001Index: const int
        :rtype: bool

        """
        return _SMESH.SMESH_Pattern_Apply(self, *args)


    def GetMappedPoints(self, *args):
        """
        GetMappedPoints(SMESH_Pattern self, std::list< gp_XYZ const *,std::allocator< gp_XYZ const * > > & thePoints) -> bool

        :type thePoints: int &
        :rtype: bool

        """
        return _SMESH.SMESH_Pattern_GetMappedPoints(self, *args)


    def MakeMesh(self, *args):
        """
        MakeMesh(SMESH_Pattern self, SMESH_Mesh theMesh, bool const toCreatePolygons=False, bool const toCreatePolyedrs=False) -> bool

        :type theMesh: OCC.wrapper.SMESH.SMESH_Mesh
        :type toCreatePolygons: const bool
        :type toCreatePolyedrs: const bool
        :rtype: bool

        """
        return _SMESH.SMESH_Pattern_MakeMesh(self, *args)


    def GetErrorCode(self, *args):
        """
        GetErrorCode(SMESH_Pattern self) -> SMESH_Pattern::ErrorCode

        :rtype: ErrorCode

        """
        return _SMESH.SMESH_Pattern_GetErrorCode(self, *args)


    def IsLoaded(self, *args):
        """
        IsLoaded(SMESH_Pattern self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_Pattern_IsLoaded(self, *args)


    def Is2D(self, *args):
        """
        Is2D(SMESH_Pattern self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_Pattern_Is2D(self, *args)


    def GetPoints(self, *args):
        """
        GetPoints(SMESH_Pattern self, std::list< gp_XYZ const *,std::allocator< gp_XYZ const * > > & thePoints) -> bool

        :type thePoints: int &
        :rtype: bool

        """
        return _SMESH.SMESH_Pattern_GetPoints(self, *args)


    def GetKeyPointIDs(self, *args):
        """
        GetKeyPointIDs(SMESH_Pattern self) -> int const &

        :rtype: const int &

        """
        return _SMESH.SMESH_Pattern_GetKeyPointIDs(self, *args)


    def GetElementPointIDs(self, *args):
        """
        GetElementPointIDs(SMESH_Pattern self, bool applied) -> std::list< std::list< int,std::allocator< int > >,std::allocator< std::list< int,std::allocator< int > > > > const &

        :rtype: const int &

        """
        return _SMESH.SMESH_Pattern_GetElementPointIDs(self, *args)


    def GetInOutNodes(self, *args):
        """
        GetInOutNodes(SMESH_Pattern self, std::vector< SMDS_MeshNode const *,std::allocator< SMDS_MeshNode const * > > *& inNodes, std::vector< SMDS_MeshNode const *,std::allocator< SMDS_MeshNode const * > > *& outNodes)

        :type inNodes: int *&
        :type outNodes: int *&

        """
        return _SMESH.SMESH_Pattern_GetInOutNodes(self, *args)


    def DumpPoints(self, *args):
        """DumpPoints(SMESH_Pattern self)"""
        return _SMESH.SMESH_Pattern_DumpPoints(self, *args)


    def GetSubShape(self, *args):
        """
        GetSubShape(SMESH_Pattern self, int const i) -> TopoDS_Shape

        :type i: const int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _SMESH.SMESH_Pattern_GetSubShape(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_Pattern
SMESH_Pattern_swigregister = _SMESH.SMESH_Pattern_swigregister
SMESH_Pattern_swigregister(SMESH_Pattern)

class SMESH_Tree_Bnd_B2d_(object):
    """rief Base class for 2D and 3D trees"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def compute(self, *args):
        """
        compute(SMESH_Tree_Bnd_B2d_ self)

        rief Compute the Tree


        """
        return _SMESH.SMESH_Tree_Bnd_B2d__compute(self, *args)


    def isLeaf(self, *args):
        """
        isLeaf(SMESH_Tree_Bnd_B2d_ self) -> bool

        rief Tell if Tree is a leaf or not
        An inheriting class can influence it via myIsLeaf protected field

        :rtype: bool

        """
        return _SMESH.SMESH_Tree_Bnd_B2d__isLeaf(self, *args)


    def level(self, *args):
        """
        level(SMESH_Tree_Bnd_B2d_ self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_Tree_Bnd_B2d__level(self, *args)


    def getBox(self, *args):
        """
        getBox(SMESH_Tree_Bnd_B2d_ self) -> Bnd_B2d

        :rtype: box_type

        """
        return _SMESH.SMESH_Tree_Bnd_B2d__getBox(self, *args)


    def getHeight(self, *args):
        """
        getHeight(SMESH_Tree_Bnd_B2d_ self, bool const full=True) -> int

        rief Return height of the tree, full or from this level to topest leaf

        :type full: const bool
        :rtype: int

        """
        return _SMESH.SMESH_Tree_Bnd_B2d__getHeight(self, *args)


    def nbChildren(*args):
        """
        nbChildren() -> int

        :rtype: int

        """
        return _SMESH.SMESH_Tree_Bnd_B2d__nbChildren(*args)

    nbChildren = staticmethod(nbChildren)

    def maxSize(self, *args):
        """
        maxSize(SMESH_Tree_Bnd_B2d_ self) -> double

        :rtype: double

        """
        return _SMESH.SMESH_Tree_Bnd_B2d__maxSize(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_Tree_Bnd_B2d_
SMESH_Tree_Bnd_B2d__swigregister = _SMESH.SMESH_Tree_Bnd_B2d__swigregister
SMESH_Tree_Bnd_B2d__swigregister(SMESH_Tree_Bnd_B2d_)

def SMESH_Tree_Bnd_B2d__nbChildren(*args):
    """
    SMESH_Tree_Bnd_B2d__nbChildren() -> int

    :rtype: int

    """
    return _SMESH.SMESH_Tree_Bnd_B2d__nbChildren(*args)


try:
	TBaseTree = SMESH_Tree_Bnd_B2d_
except NameError:
	pass # does not exist, probably ignored

class SMESH_CellLabelActor(SMESH_DeviceActor):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def New(*args):
        """
        New() -> SMESH_CellLabelActor

        :rtype: OCC.wrapper.SMESH.SMESH_CellLabelActor

        """
        return _SMESH.SMESH_CellLabelActor_New(*args)

    New = staticmethod(New)

    def ProcessEvents(*args):
        """
        ProcessEvents(vtkObject * theObject, unsigned long theEvent, void * theClientData, void * theCallData)

        :type theObject: vtkObject
        :type theEvent: unsigned long
        :type theClientData: void *
        :type theCallData: void *

        """
        return _SMESH.SMESH_CellLabelActor_ProcessEvents(*args)

    ProcessEvents = staticmethod(ProcessEvents)

    def IsTypeOf(*args):
        """
        IsTypeOf(char const * type) -> vtkTypeBool

        :type type: const char *
        :rtype: vtkTypeBool

        """
        return _SMESH.SMESH_CellLabelActor_IsTypeOf(*args)

    IsTypeOf = staticmethod(IsTypeOf)

    def IsA(self, *args):
        """
        IsA(SMESH_CellLabelActor self, char const * type) -> vtkTypeBool

        :type type: const char *
        :rtype: vtkTypeBool

        """
        return _SMESH.SMESH_CellLabelActor_IsA(self, *args)


    def SafeDownCast(*args):
        """
        SafeDownCast(vtkObjectBase * o) -> SMESH_CellLabelActor

        :type o: vtkObjectBase
        :rtype: OCC.wrapper.SMESH.SMESH_CellLabelActor

        """
        return _SMESH.SMESH_CellLabelActor_SafeDownCast(*args)

    SafeDownCast = staticmethod(SafeDownCast)

    def NewInstance(self, *args):
        """
        NewInstance(SMESH_CellLabelActor self) -> SMESH_CellLabelActor

        :rtype: OCC.wrapper.SMESH.SMESH_CellLabelActor

        """
        return _SMESH.SMESH_CellLabelActor_NewInstance(self, *args)


    def SetCellsLabeled(self, *args):
        """
        SetCellsLabeled(SMESH_CellLabelActor self, bool theIsCellsLabeled)

        :type theIsCellsLabeled: bool

        """
        return _SMESH.SMESH_CellLabelActor_SetCellsLabeled(self, *args)


    def GetCellsLabeled(self, *args):
        """
        GetCellsLabeled(SMESH_CellLabelActor self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_CellLabelActor_GetCellsLabeled(self, *args)


    def SetVisibility(self, *args):
        """
        SetVisibility(SMESH_CellLabelActor self, int theMode)

        :type theMode: int

        """
        return _SMESH.SMESH_CellLabelActor_SetVisibility(self, *args)


    def AddToRender(self, *args):
        """
        AddToRender(SMESH_CellLabelActor self, vtkRenderer * theRenderer)

        :type theRenderer: vtkRenderer

        """
        return _SMESH.SMESH_CellLabelActor_AddToRender(self, *args)


    def RemoveFromRender(self, *args):
        """
        RemoveFromRender(SMESH_CellLabelActor self, vtkRenderer * theRenderer)

        :type theRenderer: vtkRenderer

        """
        return _SMESH.SMESH_CellLabelActor_RemoveFromRender(self, *args)


    def SetFontProperties(self, *args):
        """
        SetFontProperties(SMESH_CellLabelActor self, SMESH::LabelFont family, int size, bool bold, bool italic, bool shadow, double r, double g, double b)

        :type family: LabelFont
        :type size: int
        :type bold: bool
        :type italic: bool
        :type shadow: bool
        :type r: double
        :type g: double
        :type b: double

        """
        return _SMESH.SMESH_CellLabelActor_SetFontProperties(self, *args)


    def UpdateLabels(self, *args):
        """UpdateLabels(SMESH_CellLabelActor self)"""
        return _SMESH.SMESH_CellLabelActor_UpdateLabels(self, *args)

SMESH_CellLabelActor_swigregister = _SMESH.SMESH_CellLabelActor_swigregister
SMESH_CellLabelActor_swigregister(SMESH_CellLabelActor)

def SMESH_CellLabelActor_New(*args):
    """
    SMESH_CellLabelActor_New() -> SMESH_CellLabelActor

    :rtype: OCC.wrapper.SMESH.SMESH_CellLabelActor

    """
    return _SMESH.SMESH_CellLabelActor_New(*args)

def SMESH_CellLabelActor_ProcessEvents(*args):
    """
    SMESH_CellLabelActor_ProcessEvents(vtkObject * theObject, unsigned long theEvent, void * theClientData, void * theCallData)

    :type theObject: vtkObject
    :type theEvent: unsigned long
    :type theClientData: void *
    :type theCallData: void *

    """
    return _SMESH.SMESH_CellLabelActor_ProcessEvents(*args)

def SMESH_CellLabelActor_IsTypeOf(*args):
    """
    SMESH_CellLabelActor_IsTypeOf(char const * type) -> vtkTypeBool

    :type type: const char *
    :rtype: vtkTypeBool

    """
    return _SMESH.SMESH_CellLabelActor_IsTypeOf(*args)

def SMESH_CellLabelActor_SafeDownCast(*args):
    """
    SMESH_CellLabelActor_SafeDownCast(vtkObjectBase * o) -> SMESH_CellLabelActor

    :type o: vtkObjectBase
    :rtype: OCC.wrapper.SMESH.SMESH_CellLabelActor

    """
    return _SMESH.SMESH_CellLabelActor_SafeDownCast(*args)

class SMESH_subMeshObj(SMESH_SubMeshObj):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(SMESH_subMeshObj self, SMESH::SMESH_subMesh_ptr arg2, SMESH_MeshObj arg3) -> SMESH_subMeshObj

        :type : OCC.wrapper.SMESH.SMESH_subMesh_ptr
        :type : OCC.wrapper.SMESH.SMESH_MeshObj

        """
        this = _SMESH.new_SMESH_subMeshObj(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetNbEntities(self, *args):
        """
        GetNbEntities(SMESH_subMeshObj self, SMDSAbs_ElementType const arg2) -> int

        :type : OCC.wrapper.SMDSAbs.SMDSAbs_ElementType
        :rtype: int

        """
        return _SMESH.SMESH_subMeshObj_GetNbEntities(self, *args)


    def GetEntities(self, *args):
        """
        GetEntities(SMESH_subMeshObj self, SMDSAbs_ElementType const arg2, SMESH_VisualObjDef::TEntityList & arg3) -> int

        :type : OCC.wrapper.SMDSAbs.SMDSAbs_ElementType
        :type : TEntityList
        :rtype: int

        """
        return _SMESH.SMESH_subMeshObj_GetEntities(self, *args)


    def IsNodePrs(self, *args):
        """
        IsNodePrs(SMESH_subMeshObj self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_subMeshObj_IsNodePrs(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_subMeshObj
SMESH_subMeshObj_swigregister = _SMESH.SMESH_subMeshObj_swigregister
SMESH_subMeshObj_swigregister(SMESH_subMeshObj)

class SMESH_OctreeNode(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(SMESH_OctreeNode self, TIDSortedNodeSet const & theNodes, int const maxLevel=8, int const maxNbNodes=5, double const minBoxSize=0.) -> SMESH_OctreeNode

        :type theNodes: TIDSortedNodeSet
        :type maxLevel: const int
        :type maxNbNodes: const int
        :type minBoxSize: const double

        """
        this = _SMESH.new_SMESH_OctreeNode(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def isInside(self, *args):
        """
        isInside(SMESH_OctreeNode self, gp_XYZ p, double const precision=0.) -> bool const

        :type p: OCC.wrapper.gp.gp_XYZ
        :type precision: const double
        :rtype: const bool

        """
        return _SMESH.SMESH_OctreeNode_isInside(self, *args)


    def AllNodesAround(self, *args):
        """
        AllNodesAround(SMESH_OctreeNode self, SMDS_MeshNode node, std::vector< SMDS_MeshNode const *,std::allocator< SMDS_MeshNode const * > > * result, double const precision=0.)

        :type node: OCC.wrapper.SMDS.SMDS_MeshNode
        :type result: int *
        :type precision: const double

        """
        return _SMESH.SMESH_OctreeNode_AllNodesAround(self, *args)


    def NodesAround(self, *args):
        """
        NodesAround(SMESH_OctreeNode self, gp_XYZ point, std::map< double,SMDS_MeshNode const *,std::less< double >,std::allocator< std::pair< double const,SMDS_MeshNode const * > > > & dist2Nodes, double precision) -> bool
        NodesAround(SMESH_OctreeNode self, gp_XYZ point, std::vector< SMDS_MeshNode const *,std::allocator< SMDS_MeshNode const * > > & nodes, double precision)

        :type point: OCC.wrapper.gp.gp_XYZ
        :type nodes: int &
        :type precision: double

        """
        return _SMESH.SMESH_OctreeNode_NodesAround(self, *args)


    def FindCoincidentNodes(*args):
        """
        FindCoincidentNodes(TIDSortedNodeSet * nodes, double const theTolerance, TListOfNodeLists * theGroupsOfNodes)
        FindCoincidentNodes(TIDSortedNodeSet & nodes, TListOfNodeLists * theGroupsOfNodes, double const theTolerance=0.00001, int const maxLevel=-1, int const maxNbNodes=5)

        :type nodes: TIDSortedNodeSet
        :type theGroupsOfNodes: TListOfNodeLists
        :type theTolerance: const double
        :type maxLevel: const int
        :type maxNbNodes: const int

        """
        return _SMESH.SMESH_OctreeNode_FindCoincidentNodes(*args)

    FindCoincidentNodes = staticmethod(FindCoincidentNodes)

    def UpdateByMoveNode(self, *args):
        """
        UpdateByMoveNode(SMESH_OctreeNode self, SMDS_MeshNode node, gp_Pnt toPnt)

        rief Update data according to node movement

        :type node: OCC.wrapper.SMDS.SMDS_MeshNode
        :type toPnt: OCC.wrapper.gp.gp_Pnt

        """
        return _SMESH.SMESH_OctreeNode_UpdateByMoveNode(self, *args)


    def GetChildrenIterator(self, *args):
        """
        GetChildrenIterator(SMESH_OctreeNode self) -> SMESH_OctreeNodeIteratorPtr

        rief Return iterator over children

        :rtype: OCC.wrapper.SMESH.SMESH_OctreeNodeIteratorPtr

        """
        return _SMESH.SMESH_OctreeNode_GetChildrenIterator(self, *args)


    def GetNodeIterator(self, *args):
        """
        GetNodeIterator(SMESH_OctreeNode self) -> shared_ptr_SMDS_Iterator_SMDS_MeshNode

        rief Return nodes iterator

        :rtype: OCC.wrapper.SMDS.SMDS_NodeIteratorPtr

        """
        return _SMESH.SMESH_OctreeNode_GetNodeIterator(self, *args)


    def NbNodes(self, *args):
        """
        NbNodes(SMESH_OctreeNode self) -> int

        rief Return nb nodes in a tree

        :rtype: int

        """
        return _SMESH.SMESH_OctreeNode_NbNodes(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_OctreeNode
SMESH_OctreeNode_swigregister = _SMESH.SMESH_OctreeNode_swigregister
SMESH_OctreeNode_swigregister(SMESH_OctreeNode)

def SMESH_OctreeNode_FindCoincidentNodes(*args):
    """
    FindCoincidentNodes(TIDSortedNodeSet * nodes, double const theTolerance, TListOfNodeLists * theGroupsOfNodes)
    SMESH_OctreeNode_FindCoincidentNodes(TIDSortedNodeSet & nodes, TListOfNodeLists * theGroupsOfNodes, double const theTolerance=0.00001, int const maxLevel=-1, int const maxNbNodes=5)

    :type nodes: TIDSortedNodeSet
    :type theGroupsOfNodes: TListOfNodeLists
    :type theTolerance: const double
    :type maxLevel: const int
    :type maxNbNodes: const int

    """
    return _SMESH.SMESH_OctreeNode_FindCoincidentNodes(*args)

class SMESH_subMeshEventListener(object):
    """rief A base for objects reacting on submesh events"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(SMESH_subMeshEventListener self, bool isDeletable, char const * name) -> SMESH_subMeshEventListener

        :type isDeletable: bool
        :type name: const char *

        """
        this = _SMESH.new_SMESH_subMeshEventListener(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDeletable(self, *args):
        """
        IsDeletable(SMESH_subMeshEventListener self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_subMeshEventListener_IsDeletable(self, *args)


    def GetName(self, *args):
        """
        GetName(SMESH_subMeshEventListener self) -> char const *

        :rtype: const char *

        """
        return _SMESH.SMESH_subMeshEventListener_GetName(self, *args)


    def BeforeDelete(self, *args):
        """
        BeforeDelete(SMESH_subMeshEventListener self, SMESH_subMesh subMesh, SMESH_subMeshEventListenerData * data)

        :type subMesh: OCC.wrapper.SMESH.SMESH_subMesh
        :type data: OCC.wrapper.SMESH.SMESH_subMeshEventListenerData

        """
        return _SMESH.SMESH_subMeshEventListener_BeforeDelete(self, *args)


    def ProcessEvent(self, *args):
        """
        ProcessEvent(SMESH_subMeshEventListener self, int const event, int const eventType, SMESH_subMesh subMesh, SMESH_subMeshEventListenerData * data, SMESH_Hypothesis hyp=None)

        rief Do something on a certain event
        \param event - algo_event or compute_event itself (of SMESH_subMesh)
        \param eventType - ALGO_EVENT or COMPUTE_EVENT (of SMESH_subMesh)
        \param subMesh - the submesh where the event occurs
        \param data - listener data stored in the subMesh
        \param hyp - hypothesis, if eventType is algo_event

        The base implementation (see SMESH_subMesh.cxx) translates CLEAN event
        to the subMeshes stored in the listener data. Also it sends SUBMESH_COMPUTED
        event in case of successful COMPUTE event.

        :type event: const int
        :type eventType: const int
        :type subMesh: OCC.wrapper.SMESH.SMESH_subMesh
        :type data: OCC.wrapper.SMESH.SMESH_subMeshEventListenerData
        :type hyp: OCC.wrapper.SMESH.SMESH_Hypothesis

        """
        return _SMESH.SMESH_subMeshEventListener_ProcessEvent(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_subMeshEventListener
SMESH_subMeshEventListener_swigregister = _SMESH.SMESH_subMeshEventListener_swigregister
SMESH_subMeshEventListener_swigregister(SMESH_subMeshEventListener)

class SMESH_Gen(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    SHAPE_ONLY = _SMESH.SMESH_Gen_SHAPE_ONLY
    UPWARD = _SMESH.SMESH_Gen_UPWARD
    COMPACT_MESH = _SMESH.SMESH_Gen_COMPACT_MESH
    SHAPE_ONLY_UPWARD = _SMESH.SMESH_Gen_SHAPE_ONLY_UPWARD

    def __init__(self, *args):
        """__init__(SMESH_Gen self) -> SMESH_Gen"""
        this = _SMESH.new_SMESH_Gen(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CreateMesh(self, *args):
        """
        CreateMesh(SMESH_Gen self, bool theIsEmbeddedMode) -> SMESH_Mesh

        :type theIsEmbeddedMode: bool
        :rtype: OCC.wrapper.SMESH.SMESH_Mesh

        """
        return _SMESH.SMESH_Gen_CreateMesh(self, *args)


    def Compute(self, *args):
        """
        Compute(SMESH_Gen self, SMESH_Mesh aMesh, TopoDS_Shape aShape, int const aFlags, ::MeshDimension const aDim, TSetOfInt * aShapesId=None) -> bool

        rief Computes aMesh on aShape 
        \param aMesh - the mesh.
        \param aShape - the shape.
        \param aFlags - ComputeFlags. By default compute the whole mesh and compact at the end.
        \param aDim - upper level dimension of the mesh computation (for preview)
        \param aShapesId - list of shapes with computed mesh entities (elements or nodes)
        etval bool - true if none sub-mesh failed to compute

        :type aMesh: OCC.wrapper.SMESH.SMESH_Mesh
        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aFlags: const int
        :type aDim: MeshDimension
        :type aShapesId: TSetOfInt
        :rtype: bool

        """
        return _SMESH.SMESH_Gen_Compute(self, *args)


    def PrepareCompute(self, *args):
        """
        PrepareCompute(SMESH_Gen self, SMESH_Mesh aMesh, TopoDS_Shape aShape)

        :type aMesh: OCC.wrapper.SMESH.SMESH_Mesh
        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _SMESH.SMESH_Gen_PrepareCompute(self, *args)


    def CancelCompute(self, *args):
        """
        CancelCompute(SMESH_Gen self, SMESH_Mesh aMesh, TopoDS_Shape aShape)

        :type aMesh: OCC.wrapper.SMESH.SMESH_Mesh
        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _SMESH.SMESH_Gen_CancelCompute(self, *args)


    def GetCurrentSubMesh(self, *args):
        """
        GetCurrentSubMesh(SMESH_Gen self) -> SMESH_subMesh

        :rtype: OCC.wrapper.SMESH.SMESH_subMesh

        """
        return _SMESH.SMESH_Gen_GetCurrentSubMesh(self, *args)


    def Evaluate(self, *args):
        """
        Evaluate(SMESH_Gen self, SMESH_Mesh aMesh, TopoDS_Shape aShape, MapShapeNbElems & aResMap, bool const anUpward=False, TSetOfInt * aShapesId=None) -> bool

        rief evaluates size of prospective mesh on a shape 
        \param aMesh - the mesh
        \param aShape - the shape
        \param aResMap - map for prospective numbers of elements
        etval bool - is a success

        :type aMesh: OCC.wrapper.SMESH.SMESH_Mesh
        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aResMap: MapShapeNbElems
        :type anUpward: const bool
        :type aShapesId: TSetOfInt
        :rtype: bool

        """
        return _SMESH.SMESH_Gen_Evaluate(self, *args)


    def CheckAlgoState(self, *args):
        """
        CheckAlgoState(SMESH_Gen self, SMESH_Mesh aMesh, TopoDS_Shape aShape) -> bool

        :type aMesh: OCC.wrapper.SMESH.SMESH_Mesh
        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: bool

        """
        return _SMESH.SMESH_Gen_CheckAlgoState(self, *args)


    def SetBoundaryBoxSegmentation(self, *args):
        """
        SetBoundaryBoxSegmentation(SMESH_Gen self, int theNbSegments)

        rief Sets number of segments per diagonal of boundary box of geometry by which
        default segment length of appropriate 1D hypotheses is defined

        :type theNbSegments: int

        """
        return _SMESH.SMESH_Gen_SetBoundaryBoxSegmentation(self, *args)


    def GetBoundaryBoxSegmentation(self, *args):
        """
        GetBoundaryBoxSegmentation(SMESH_Gen self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_Gen_GetBoundaryBoxSegmentation(self, *args)


    def SetDefaultNbSegments(self, *args):
        """
        SetDefaultNbSegments(SMESH_Gen self, int nb)

        rief Sets default number of segments per edge

        :type nb: int

        """
        return _SMESH.SMESH_Gen_SetDefaultNbSegments(self, *args)


    def GetDefaultNbSegments(self, *args):
        """
        GetDefaultNbSegments(SMESH_Gen self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_Gen_GetDefaultNbSegments(self, *args)


    def GetAlgoState(self, *args):
        """
        GetAlgoState(SMESH_Gen self, SMESH_Mesh aMesh, TopoDS_Shape aShape, std::list< SMESH_Gen::TAlgoStateError,std::allocator< SMESH_Gen::TAlgoStateError > > & theErrors) -> bool

        :type aMesh: OCC.wrapper.SMESH.SMESH_Mesh
        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theErrors: int &
        :rtype: bool

        """
        return _SMESH.SMESH_Gen_GetAlgoState(self, *args)


    def GetStudyContext(self, *args):
        """
        GetStudyContext(SMESH_Gen self) -> StudyContextStruct *

        :rtype: StudyContextStruct

        """
        return _SMESH.SMESH_Gen_GetStudyContext(self, *args)


    def GetShapeDim(*args):
        """
        GetShapeDim(TopAbs_ShapeEnum const & aShapeType) -> int
        GetShapeDim(TopoDS_Shape aShape) -> int

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: int

        """
        return _SMESH.SMESH_Gen_GetShapeDim(*args)

    GetShapeDim = staticmethod(GetShapeDim)

    def GetAlgo(self, *args):
        """
        GetAlgo(SMESH_Gen self, SMESH_Mesh aMesh, TopoDS_Shape aShape, TopoDS_Shape assignedTo=None) -> SMESH_Algo
        GetAlgo(SMESH_Gen self, SMESH_subMesh aSubMesh, TopoDS_Shape assignedTo=None) -> SMESH_Algo

        :type aSubMesh: OCC.wrapper.SMESH.SMESH_subMesh
        :type assignedTo: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.SMESH.SMESH_Algo

        """
        return _SMESH.SMESH_Gen_GetAlgo(self, *args)


    def IsGlobalHypothesis(*args):
        """
        IsGlobalHypothesis(SMESH_Hypothesis theHyp, SMESH_Mesh aMesh) -> bool

        :type theHyp: OCC.wrapper.SMESH.SMESH_Hypothesis
        :type aMesh: OCC.wrapper.SMESH.SMESH_Mesh
        :rtype: bool

        """
        return _SMESH.SMESH_Gen_IsGlobalHypothesis(*args)

    IsGlobalHypothesis = staticmethod(IsGlobalHypothesis)

    def GetPluginXMLPaths(*args):
        """
        GetPluginXMLPaths() -> std::vector< std::string,std::allocator< std::string > >

        :rtype: int

        """
        return _SMESH.SMESH_Gen_GetPluginXMLPaths(*args)

    GetPluginXMLPaths = staticmethod(GetPluginXMLPaths)

    def GetANewId(self, *args):
        """
        GetANewId(SMESH_Gen self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_Gen_GetANewId(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_Gen
SMESH_Gen_swigregister = _SMESH.SMESH_Gen_swigregister
SMESH_Gen_swigregister(SMESH_Gen)

def SMESH_Gen_GetShapeDim(*args):
    """
    GetShapeDim(TopAbs_ShapeEnum const & aShapeType) -> int
    SMESH_Gen_GetShapeDim(TopoDS_Shape aShape) -> int

    :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: int

    """
    return _SMESH.SMESH_Gen_GetShapeDim(*args)

def SMESH_Gen_IsGlobalHypothesis(*args):
    """
    SMESH_Gen_IsGlobalHypothesis(SMESH_Hypothesis theHyp, SMESH_Mesh aMesh) -> bool

    :type theHyp: OCC.wrapper.SMESH.SMESH_Hypothesis
    :type aMesh: OCC.wrapper.SMESH.SMESH_Mesh
    :rtype: bool

    """
    return _SMESH.SMESH_Gen_IsGlobalHypothesis(*args)

def SMESH_Gen_GetPluginXMLPaths(*args):
    """
    SMESH_Gen_GetPluginXMLPaths() -> std::vector< std::string,std::allocator< std::string > >

    :rtype: int

    """
    return _SMESH.SMESH_Gen_GetPluginXMLPaths(*args)

class SMESH_TypeFilter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(SMESH_TypeFilter self, SMESH::MeshObjectType theType) -> SMESH_TypeFilter

        :type theType: MeshObjectType

        """
        this = _SMESH.new_SMESH_TypeFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def isOk(self, *args):
        """
        isOk(SMESH_TypeFilter self, SUIT_DataOwner const * arg2) -> bool

        :type : SUIT_DataOwner
        :rtype: bool

        """
        return _SMESH.SMESH_TypeFilter_isOk(self, *args)


    def type(self, *args):
        """
        type(SMESH_TypeFilter self) -> SMESH::MeshObjectType

        :rtype: MeshObjectType

        """
        return _SMESH.SMESH_TypeFilter_type(self, *args)


    def setType(self, *args):
        """
        setType(SMESH_TypeFilter self, SMESH::MeshObjectType theType)

        :type theType: MeshObjectType

        """
        return _SMESH.SMESH_TypeFilter_setType(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_TypeFilter
SMESH_TypeFilter_swigregister = _SMESH.SMESH_TypeFilter_swigregister
SMESH_TypeFilter_swigregister(SMESH_TypeFilter)

class SMESH_Mesh(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(SMESH_Mesh self, int theLocalId, SMESH_Gen theGen, bool theIsEmbeddedMode, SMESHDS_Document theDocument) -> SMESH_Mesh

        :type theLocalId: int
        :type theGen: OCC.wrapper.SMESH.SMESH_Gen
        :type theIsEmbeddedMode: bool
        :type theDocument: OCC.wrapper.SMESHDS.SMESHDS_Document

        """
        this = _SMESH.new_SMESH_Mesh(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ShapeToMesh(self, *args):
        """
        ShapeToMesh(SMESH_Mesh self, TopoDS_Shape aShape)

        rief Set geometry to be meshed

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _SMESH.SMESH_Mesh_ShapeToMesh(self, *args)


    def GetShapeToMesh(self, *args):
        """
        GetShapeToMesh(SMESH_Mesh self) -> TopoDS_Shape

        rief Return geometry to be meshed. (It may be a PseudoShape()!)

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _SMESH.SMESH_Mesh_GetShapeToMesh(self, *args)


    def HasShapeToMesh(self, *args):
        """
        HasShapeToMesh(SMESH_Mesh self) -> bool

        rief Return true if there is a geometry to be meshed, not PseudoShape()

        :rtype: bool

        """
        return _SMESH.SMESH_Mesh_HasShapeToMesh(self, *args)


    def GetShapeDiagonalSize(*args):
        """
        GetShapeDiagonalSize() -> double
        GetShapeDiagonalSize(TopoDS_Shape aShape) -> double

        rief Return diagonal size of bounding box of a shape.

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: double

        """
        return _SMESH.SMESH_Mesh_GetShapeDiagonalSize(*args)

    GetShapeDiagonalSize = staticmethod(GetShapeDiagonalSize)

    def PseudoShape(*args):
        """
        PseudoShape() -> TopoDS_Solid

        rief Return a solid which is returned by GetShapeToMesh() if
        a real geometry to be meshed was not set

        :rtype: OCC.wrapper.TopoDS.TopoDS_Solid

        """
        return _SMESH.SMESH_Mesh_PseudoShape(*args)

    PseudoShape = staticmethod(PseudoShape)

    def Load(self, *args):
        """
        Load(SMESH_Mesh self)

        rief Load mesh from study file


        """
        return _SMESH.SMESH_Mesh_Load(self, *args)


    def Clear(self, *args):
        """
        Clear(SMESH_Mesh self)

        rief Remove all nodes and elements


        """
        return _SMESH.SMESH_Mesh_Clear(self, *args)


    def ClearSubMesh(self, *args):
        """
        ClearSubMesh(SMESH_Mesh self, int const theShapeId)

        rief Remove all nodes and elements of indicated shape

        :type theShapeId: const int

        """
        return _SMESH.SMESH_Mesh_ClearSubMesh(self, *args)


    def UNVToMesh(self, *args):
        """
        UNVToMesh(SMESH_Mesh self, char const * theFileName) -> int

        consult DriverMED_R_SMESHDS_Mesh::ReadStatus for returned value

        :type theFileName: const char *
        :rtype: int

        """
        return _SMESH.SMESH_Mesh_UNVToMesh(self, *args)


    def MEDToMesh(self, *args):
        """
        MEDToMesh(SMESH_Mesh self, char const * theFileName, char const * theMeshName) -> int

        :type theFileName: const char *
        :type theMeshName: const char *
        :rtype: int

        """
        return _SMESH.SMESH_Mesh_MEDToMesh(self, *args)


    def STLToMesh(self, *args):
        """
        STLToMesh(SMESH_Mesh self, char const * theFileName) -> std::string

        :type theFileName: const char *
        :rtype: string

        """
        return _SMESH.SMESH_Mesh_STLToMesh(self, *args)


    def CGNSToMesh(self, *args):
        """
        CGNSToMesh(SMESH_Mesh self, char const * theFileName, int const theMeshIndex, std::string & theMeshName) -> int

        :type theFileName: const char *
        :type theMeshIndex: const int
        :type theMeshName: string
        :rtype: int

        """
        return _SMESH.SMESH_Mesh_CGNSToMesh(self, *args)


    def GMFToMesh(self, *args):
        """
        GMFToMesh(SMESH_Mesh self, char const * theFileName, bool theMakeRequiredGroups=True) -> shared_ptr_SMESH_ComputeError

        :type theFileName: const char *
        :type theMakeRequiredGroups: bool
        :rtype: OCC.wrapper.SMESH.SMESH_ComputeErrorPtr

        """
        return _SMESH.SMESH_Mesh_GMFToMesh(self, *args)


    def AddHypothesis(self, *args):
        """
        AddHypothesis(SMESH_Mesh self, TopoDS_Shape aSubShape, int anHypId, std::string * error=None) -> SMESH_Hypothesis::Hypothesis_Status

        :type aSubShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type anHypId: int
        :type error: string
        :rtype: Hypothesis_Status

        """
        return _SMESH.SMESH_Mesh_AddHypothesis(self, *args)


    def RemoveHypothesis(self, *args):
        """
        RemoveHypothesis(SMESH_Mesh self, TopoDS_Shape aSubShape, int anHypId) -> SMESH_Hypothesis::Hypothesis_Status

        :type aSubShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type anHypId: int
        :rtype: Hypothesis_Status

        """
        return _SMESH.SMESH_Mesh_RemoveHypothesis(self, *args)


    def GetHypothesisList(self, *args):
        """
        GetHypothesisList(SMESH_Mesh self, TopoDS_Shape aSubShape) -> SMESHDS_Hypothesis

        :rtype: const int &

        """
        return _SMESH.SMESH_Mesh_GetHypothesisList(self, *args)


    def GetHypotheses(self, *args):
        """
        GetHypotheses(SMESH_Mesh self, TopoDS_Shape aSubShape, SMESH_HypoFilter aFilter, std::list< SMESHDS_Hypothesis const *,std::allocator< SMESHDS_Hypothesis const * > > & aHypList, bool const andAncestors, std::list< TopoDS_Shape,std::allocator< TopoDS_Shape > > * assignedTo=None) -> int
        GetHypotheses(SMESH_Mesh self, SMESH_subMesh aSubMesh, SMESH_HypoFilter aFilter, std::list< SMESHDS_Hypothesis const *,std::allocator< SMESHDS_Hypothesis const * > > & aHypList, bool const andAncestors, std::list< TopoDS_Shape,std::allocator< TopoDS_Shape > > * assignedTo=None) -> int

        :type aSubMesh: OCC.wrapper.SMESH.SMESH_subMesh
        :type aFilter: OCC.wrapper.SMESH.SMESH_HypoFilter
        :type aHypList: int &
        :type andAncestors: const bool
        :type assignedTo: int *
        :rtype: int

        """
        return _SMESH.SMESH_Mesh_GetHypotheses(self, *args)


    def GetHypothesis(self, *args):
        """
        GetHypothesis(SMESH_Mesh self, TopoDS_Shape aSubShape, SMESH_HypoFilter aFilter, bool const andAncestors, TopoDS_Shape assignedTo=None) -> SMESH_Hypothesis
        GetHypothesis(SMESH_Mesh self, SMESH_subMesh aSubMesh, SMESH_HypoFilter aFilter, bool const andAncestors, TopoDS_Shape assignedTo=None) -> SMESH_Hypothesis
        GetHypothesis(SMESH_Mesh self, int const aHypID) -> SMESH_Hypothesis

        :type aHypID: const int
        :rtype: OCC.wrapper.SMESH.SMESH_Hypothesis

        """
        return _SMESH.SMESH_Mesh_GetHypothesis(self, *args)


    def GetLog(self, *args):
        """
        GetLog(SMESH_Mesh self) -> SMESHDS_Command

        :rtype: const int &

        """
        return _SMESH.SMESH_Mesh_GetLog(self, *args)


    def ClearLog(self, *args):
        """ClearLog(SMESH_Mesh self)"""
        return _SMESH.SMESH_Mesh_ClearLog(self, *args)


    def GetId(self, *args):
        """
        GetId(SMESH_Mesh self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_Mesh_GetId(self, *args)


    def MeshExists(self, *args):
        """
        MeshExists(SMESH_Mesh self, int meshId) -> bool

        :type meshId: int
        :rtype: bool

        """
        return _SMESH.SMESH_Mesh_MeshExists(self, *args)


    def FindMesh(self, *args):
        """
        FindMesh(SMESH_Mesh self, int meshId) -> SMESH_Mesh

        :type meshId: int
        :rtype: OCC.wrapper.SMESH.SMESH_Mesh

        """
        return _SMESH.SMESH_Mesh_FindMesh(self, *args)


    def GetMeshDS(self, *args):
        """
        GetMeshDS(SMESH_Mesh self) -> SMESHDS_Mesh
        GetMeshDS(SMESH_Mesh self) -> SMESHDS_Mesh

        :rtype: OCC.wrapper.SMESHDS.SMESHDS_Mesh

        """
        return _SMESH.SMESH_Mesh_GetMeshDS(self, *args)


    def GetGen(self, *args):
        """
        GetGen(SMESH_Mesh self) -> SMESH_Gen

        :rtype: OCC.wrapper.SMESH.SMESH_Gen

        """
        return _SMESH.SMESH_Mesh_GetGen(self, *args)


    def GetSubMesh(self, *args):
        """
        GetSubMesh(SMESH_Mesh self, TopoDS_Shape aSubShape) -> SMESH_subMesh

        :type aSubShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.SMESH.SMESH_subMesh

        """
        return _SMESH.SMESH_Mesh_GetSubMesh(self, *args)


    def GetSubMeshContaining(self, *args):
        """
        GetSubMeshContaining(SMESH_Mesh self, TopoDS_Shape aSubShape) -> SMESH_subMesh
        GetSubMeshContaining(SMESH_Mesh self, int const aShapeID) -> SMESH_subMesh

        :type aShapeID: const int
        :rtype: OCC.wrapper.SMESH.SMESH_subMesh

        """
        return _SMESH.SMESH_Mesh_GetSubMeshContaining(self, *args)


    def GetGroupSubMeshesContaining(self, *args):
        """
        GetGroupSubMeshesContaining(SMESH_Mesh self, TopoDS_Shape shape) -> std::list< SMESH_subMesh *,std::allocator< SMESH_subMesh * > >

        rief Return submeshes of groups containing the given subshape

        :rtype: int

        """
        return _SMESH.SMESH_Mesh_GetGroupSubMeshesContaining(self, *args)


    def NotifySubMeshesHypothesisModification(self, *args):
        """
        NotifySubMeshesHypothesisModification(SMESH_Mesh self, SMESH_Hypothesis theChangedHyp)

        rief Say all submeshes that theChangedHyp has been modified

        :type theChangedHyp: OCC.wrapper.SMESH.SMESH_Hypothesis

        """
        return _SMESH.SMESH_Mesh_NotifySubMeshesHypothesisModification(self, *args)


    def IsUsedHypothesis(self, *args):
        """
        IsUsedHypothesis(SMESH_Mesh self, SMESHDS_Hypothesis anHyp, SMESH_subMesh aSubMesh) -> bool

        rief Return True if anHyp is used to mesh aSubShape

        :type anHyp: OCC.wrapper.SMESHDS.SMESHDS_Hypothesis
        :type aSubMesh: OCC.wrapper.SMESH.SMESH_subMesh
        :rtype: bool

        """
        return _SMESH.SMESH_Mesh_IsUsedHypothesis(self, *args)


    def IsNotConformAllowed(self, *args):
        """
        IsNotConformAllowed(SMESH_Mesh self) -> bool

        rief check if a hypothesis allowing notconform mesh is present

        :rtype: bool

        """
        return _SMESH.SMESH_Mesh_IsNotConformAllowed(self, *args)


    def IsMainShape(self, *args):
        """
        IsMainShape(SMESH_Mesh self, TopoDS_Shape theShape) -> bool

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: bool

        """
        return _SMESH.SMESH_Mesh_IsMainShape(self, *args)


    def GetAncestors(self, *args):
        """
        \brief Return list of ancestors of theSubShape in the order
        that lower dimension shapes come first

        :type theSubShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _SMESH.SMESH_Mesh_GetAncestors(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAutoColor(self, *args):
        """
        SetAutoColor(SMESH_Mesh self, bool theAutoColor)

        :type theAutoColor: bool

        """
        return _SMESH.SMESH_Mesh_SetAutoColor(self, *args)


    def GetAutoColor(self, *args):
        """
        GetAutoColor(SMESH_Mesh self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_Mesh_GetAutoColor(self, *args)


    def SetIsModified(self, *args):
        """
        SetIsModified(SMESH_Mesh self, bool isModified)

        rief Set the flag meaning that the mesh has been edited "manually".
        It is to set to false after Clear() and to set to true by MeshEditor

        :type isModified: bool

        """
        return _SMESH.SMESH_Mesh_SetIsModified(self, *args)


    def GetIsModified(self, *args):
        """
        GetIsModified(SMESH_Mesh self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_Mesh_GetIsModified(self, *args)


    def HasModificationsToDiscard(self, *args):
        """
        HasModificationsToDiscard(SMESH_Mesh self) -> bool

        rief Return true if the mesh has been edited since a total re-compute
        and those modifications may prevent successful partial re-compute.
        As a side effect reset _isModified flag if mesh is empty

        :rtype: bool

        """
        return _SMESH.SMESH_Mesh_HasModificationsToDiscard(self, *args)


    def IsComputedOK(self, *args):
        """
        IsComputedOK(SMESH_Mesh self) -> bool

        rief Return true if all sub-meshes are computed OK - to update an icon

        :rtype: bool

        """
        return _SMESH.SMESH_Mesh_IsComputedOK(self, *args)


    def GetAncestorMap(self, *args):
        """
        :rtype: TAncestorMap

        """
        res = _SMESH.SMESH_Mesh_GetAncestorMap(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasDuplicatedGroupNamesMED(self, *args):
        """
        HasDuplicatedGroupNamesMED(SMESH_Mesh self) -> bool

        rief Check group names for duplications.
        Consider maximum group name length stored in MED file

        :rtype: bool

        """
        return _SMESH.SMESH_Mesh_HasDuplicatedGroupNamesMED(self, *args)


    def ExportMED(self, *args):
        """
        ExportMED(SMESH_Mesh self, char const * theFile, char const * theMeshName=None, bool theAutoGroups=True, int theVersion=-1, SMESHDS_Mesh theMeshPart=None, bool theAutoDimension=False, bool theAddODOnVertices=False, double theZTolerance=-1., bool theAllElemsToGroup=False)

        :type theFile: const char *
        :type theMeshName: const char *
        :type theAutoGroups: bool
        :type theVersion: int
        :type theMeshPart: OCC.wrapper.SMESHDS.SMESHDS_Mesh
        :type theAutoDimension: bool
        :type theAddODOnVertices: bool
        :type theZTolerance: double
        :type theAllElemsToGroup: bool

        """
        return _SMESH.SMESH_Mesh_ExportMED(self, *args)


    def ExportDAT(self, *args):
        """
        ExportDAT(SMESH_Mesh self, char const * file, SMESHDS_Mesh meshPart=None)

        :type file: const char *
        :type meshPart: OCC.wrapper.SMESHDS.SMESHDS_Mesh

        """
        return _SMESH.SMESH_Mesh_ExportDAT(self, *args)


    def ExportUNV(self, *args):
        """
        ExportUNV(SMESH_Mesh self, char const * file, SMESHDS_Mesh meshPart=None)

        :type file: const char *
        :type meshPart: OCC.wrapper.SMESHDS.SMESHDS_Mesh

        """
        return _SMESH.SMESH_Mesh_ExportUNV(self, *args)


    def ExportSTL(self, *args):
        """
        ExportSTL(SMESH_Mesh self, char const * file, bool const __isascii, char const * name=None, SMESHDS_Mesh meshPart=None)

        :type file: const char *
        :type __isascii: const bool
        :type name: const char *
        :type meshPart: OCC.wrapper.SMESHDS.SMESHDS_Mesh

        """
        return _SMESH.SMESH_Mesh_ExportSTL(self, *args)


    def ExportCGNS(self, *args):
        """
        ExportCGNS(SMESH_Mesh self, char const * file, SMESHDS_Mesh mesh, char const * meshName=None, bool const groupElemsByType=False)

        :type file: const char *
        :type mesh: OCC.wrapper.SMESHDS.SMESHDS_Mesh
        :type meshName: const char *
        :type groupElemsByType: const bool

        """
        return _SMESH.SMESH_Mesh_ExportCGNS(self, *args)


    def ExportGMF(self, *args):
        """
        ExportGMF(SMESH_Mesh self, char const * file, SMESHDS_Mesh mesh, bool withRequiredGroups=True)

        :type file: const char *
        :type mesh: OCC.wrapper.SMESHDS.SMESHDS_Mesh
        :type withRequiredGroups: bool

        """
        return _SMESH.SMESH_Mesh_ExportGMF(self, *args)


    def ExportSAUV(self, *args):
        """
        ExportSAUV(SMESH_Mesh self, char const * file, char const * theMeshName=None, bool theAutoGroups=True)

        :type file: const char *
        :type theMeshName: const char *
        :type theAutoGroups: bool

        """
        return _SMESH.SMESH_Mesh_ExportSAUV(self, *args)


    def GetComputeProgress(self, *args):
        """
        GetComputeProgress(SMESH_Mesh self) -> double

        :rtype: double

        """
        return _SMESH.SMESH_Mesh_GetComputeProgress(self, *args)


    def NbNodes(self, *args):
        """
        NbNodes(SMESH_Mesh self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_Mesh_NbNodes(self, *args)


    def Nb0DElements(self, *args):
        """
        Nb0DElements(SMESH_Mesh self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_Mesh_Nb0DElements(self, *args)


    def NbBalls(self, *args):
        """
        NbBalls(SMESH_Mesh self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_Mesh_NbBalls(self, *args)


    def NbEdges(self, *args):
        """
        NbEdges(SMESH_Mesh self, SMDSAbs_ElementOrder order=ORDER_ANY) -> int

        :type order: OCC.wrapper.SMDSAbs.SMDSAbs_ElementOrder
        :rtype: int

        """
        return _SMESH.SMESH_Mesh_NbEdges(self, *args)


    def NbFaces(self, *args):
        """
        NbFaces(SMESH_Mesh self, SMDSAbs_ElementOrder order=ORDER_ANY) -> int

        :type order: OCC.wrapper.SMDSAbs.SMDSAbs_ElementOrder
        :rtype: int

        """
        return _SMESH.SMESH_Mesh_NbFaces(self, *args)


    def NbTriangles(self, *args):
        """
        NbTriangles(SMESH_Mesh self, SMDSAbs_ElementOrder order=ORDER_ANY) -> int

        :type order: OCC.wrapper.SMDSAbs.SMDSAbs_ElementOrder
        :rtype: int

        """
        return _SMESH.SMESH_Mesh_NbTriangles(self, *args)


    def NbQuadrangles(self, *args):
        """
        NbQuadrangles(SMESH_Mesh self, SMDSAbs_ElementOrder order=ORDER_ANY) -> int

        :type order: OCC.wrapper.SMDSAbs.SMDSAbs_ElementOrder
        :rtype: int

        """
        return _SMESH.SMESH_Mesh_NbQuadrangles(self, *args)


    def NbBiQuadQuadrangles(self, *args):
        """
        NbBiQuadQuadrangles(SMESH_Mesh self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_Mesh_NbBiQuadQuadrangles(self, *args)


    def NbBiQuadTriangles(self, *args):
        """
        NbBiQuadTriangles(SMESH_Mesh self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_Mesh_NbBiQuadTriangles(self, *args)


    def NbPolygons(self, *args):
        """
        NbPolygons(SMESH_Mesh self, SMDSAbs_ElementOrder order=ORDER_ANY) -> int

        :type order: OCC.wrapper.SMDSAbs.SMDSAbs_ElementOrder
        :rtype: int

        """
        return _SMESH.SMESH_Mesh_NbPolygons(self, *args)


    def NbVolumes(self, *args):
        """
        NbVolumes(SMESH_Mesh self, SMDSAbs_ElementOrder order=ORDER_ANY) -> int

        :type order: OCC.wrapper.SMDSAbs.SMDSAbs_ElementOrder
        :rtype: int

        """
        return _SMESH.SMESH_Mesh_NbVolumes(self, *args)


    def NbTetras(self, *args):
        """
        NbTetras(SMESH_Mesh self, SMDSAbs_ElementOrder order=ORDER_ANY) -> int

        :type order: OCC.wrapper.SMDSAbs.SMDSAbs_ElementOrder
        :rtype: int

        """
        return _SMESH.SMESH_Mesh_NbTetras(self, *args)


    def NbHexas(self, *args):
        """
        NbHexas(SMESH_Mesh self, SMDSAbs_ElementOrder order=ORDER_ANY) -> int

        :type order: OCC.wrapper.SMDSAbs.SMDSAbs_ElementOrder
        :rtype: int

        """
        return _SMESH.SMESH_Mesh_NbHexas(self, *args)


    def NbTriQuadraticHexas(self, *args):
        """
        NbTriQuadraticHexas(SMESH_Mesh self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_Mesh_NbTriQuadraticHexas(self, *args)


    def NbPyramids(self, *args):
        """
        NbPyramids(SMESH_Mesh self, SMDSAbs_ElementOrder order=ORDER_ANY) -> int

        :type order: OCC.wrapper.SMDSAbs.SMDSAbs_ElementOrder
        :rtype: int

        """
        return _SMESH.SMESH_Mesh_NbPyramids(self, *args)


    def NbPrisms(self, *args):
        """
        NbPrisms(SMESH_Mesh self, SMDSAbs_ElementOrder order=ORDER_ANY) -> int

        :type order: OCC.wrapper.SMDSAbs.SMDSAbs_ElementOrder
        :rtype: int

        """
        return _SMESH.SMESH_Mesh_NbPrisms(self, *args)


    def NbQuadPrisms(self, *args):
        """
        NbQuadPrisms(SMESH_Mesh self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_Mesh_NbQuadPrisms(self, *args)


    def NbBiQuadPrisms(self, *args):
        """
        NbBiQuadPrisms(SMESH_Mesh self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_Mesh_NbBiQuadPrisms(self, *args)


    def NbHexagonalPrisms(self, *args):
        """
        NbHexagonalPrisms(SMESH_Mesh self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_Mesh_NbHexagonalPrisms(self, *args)


    def NbPolyhedrons(self, *args):
        """
        NbPolyhedrons(SMESH_Mesh self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_Mesh_NbPolyhedrons(self, *args)


    def NbSubMesh(self, *args):
        """
        NbSubMesh(SMESH_Mesh self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_Mesh_NbSubMesh(self, *args)


    def NbGroup(self, *args):
        """
        NbGroup(SMESH_Mesh self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_Mesh_NbGroup(self, *args)


    def NbMeshes(self, *args):
        """
        NbMeshes(SMESH_Mesh self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_Mesh_NbMeshes(self, *args)


    def AddGroup(self, *args):
        """
        AddGroup(SMESH_Mesh self, SMDSAbs_ElementType const theType, char const * theName, int const theId=-1, TopoDS_Shape theShape, SMESH_PredicatePtr const & thePredicate) -> SMESH_Group
        AddGroup(SMESH_Mesh self, SMESHDS_GroupBase groupDS) -> SMESH_Group

        :type groupDS: OCC.wrapper.SMESHDS.SMESHDS_GroupBase
        :rtype: OCC.wrapper.SMESH.SMESH_Group

        """
        return _SMESH.SMESH_Mesh_AddGroup(self, *args)


    def GetGroups(self, *args):
        """
        GetGroups(SMESH_Mesh self) -> shared_ptr_SMDS_Iterator_SMESH_Group

        :rtype: GroupIteratorPtr

        """
        return _SMESH.SMESH_Mesh_GetGroups(self, *args)


    def GetGroupIds(self, *args):
        """
        GetGroupIds(SMESH_Mesh self) -> std::list< int,std::allocator< int > >

        :rtype: int

        """
        return _SMESH.SMESH_Mesh_GetGroupIds(self, *args)


    def GetGroup(self, *args):
        """
        GetGroup(SMESH_Mesh self, int const theGroupID) -> SMESH_Group

        :type theGroupID: const int
        :rtype: OCC.wrapper.SMESH.SMESH_Group

        """
        return _SMESH.SMESH_Mesh_GetGroup(self, *args)


    def RemoveGroup(self, *args):
        """
        RemoveGroup(SMESH_Mesh self, int const theGroupID) -> bool

        :type theGroupID: const int
        :rtype: bool

        """
        return _SMESH.SMESH_Mesh_RemoveGroup(self, *args)


    def ConvertToStandalone(self, *args):
        """
        ConvertToStandalone(SMESH_Mesh self, int theGroupID) -> SMESH_Group

        :type theGroupID: int
        :rtype: OCC.wrapper.SMESH.SMESH_Group

        """
        return _SMESH.SMESH_Mesh_ConvertToStandalone(self, *args)


    def SetCallUp(self, *args):
        """
        SetCallUp(SMESH_Mesh self, SMESH_Mesh::TCallUp * upCaller)

        :type upCaller: TCallUp

        """
        return _SMESH.SMESH_Mesh_SetCallUp(self, *args)


    def SynchronizeGroups(self, *args):
        """
        SynchronizeGroups(SMESH_Mesh self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_Mesh_SynchronizeGroups(self, *args)


    def GetElementType(self, *args):
        """
        GetElementType(SMESH_Mesh self, int const id, bool const iselem) -> SMDSAbs_ElementType

        :type id: const int
        :type iselem: const bool
        :rtype: OCC.wrapper.SMDSAbs.SMDSAbs_ElementType

        """
        return _SMESH.SMESH_Mesh_GetElementType(self, *args)


    def ClearMeshOrder(self, *args):
        """ClearMeshOrder(SMESH_Mesh self)"""
        return _SMESH.SMESH_Mesh_ClearMeshOrder(self, *args)


    def SetMeshOrder(self, *args):
        """
        SetMeshOrder(SMESH_Mesh self, TListOfListOfInt const & theOrder)

        :type theOrder: TListOfListOfInt

        """
        return _SMESH.SMESH_Mesh_SetMeshOrder(self, *args)


    def GetMeshOrder(self, *args):
        """
        GetMeshOrder(SMESH_Mesh self) -> TListOfListOfInt const &

        :rtype: TListOfListOfInt

        """
        return _SMESH.SMESH_Mesh_GetMeshOrder(self, *args)


    def SortByMeshOrder(self, *args):
        """
        SortByMeshOrder(SMESH_Mesh self, std::vector< SMESH_subMesh *,std::allocator< SMESH_subMesh * > > & theListToSort) -> bool

        :type theListToSort: int &
        :rtype: bool

        """
        return _SMESH.SMESH_Mesh_SortByMeshOrder(self, *args)


    def IsOrderOK(self, *args):
        """
        IsOrderOK(SMESH_Mesh self, SMESH_subMesh smBefore, SMESH_subMesh smAfter) -> bool

        :type smBefore: OCC.wrapper.SMESH.SMESH_subMesh
        :type smAfter: OCC.wrapper.SMESH.SMESH_subMesh
        :rtype: bool

        """
        return _SMESH.SMESH_Mesh_IsOrderOK(self, *args)


    def Dump(self, *args):
        """
        Dump(SMESH_Mesh self, std::ostream & save) -> std::ostream &

        :type save: ostream
        :rtype: ostream

        """
        return _SMESH.SMESH_Mesh_Dump(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_Mesh
SMESH_Mesh_swigregister = _SMESH.SMESH_Mesh_swigregister
SMESH_Mesh_swigregister(SMESH_Mesh)

def SMESH_Mesh_GetShapeDiagonalSize(*args):
    """
    GetShapeDiagonalSize() -> double
    SMESH_Mesh_GetShapeDiagonalSize(TopoDS_Shape aShape) -> double

    rief Return diagonal size of bounding box of a shape.

    :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: double

    """
    return _SMESH.SMESH_Mesh_GetShapeDiagonalSize(*args)

def SMESH_Mesh_PseudoShape(*args):
    """
    SMESH_Mesh_PseudoShape() -> TopoDS_Solid

    rief Return a solid which is returned by GetShapeToMesh() if
    a real geometry to be meshed was not set

    :rtype: OCC.wrapper.TopoDS.TopoDS_Solid

    """
    return _SMESH.SMESH_Mesh_PseudoShape(*args)

class shared_ptr_SMDS_Iterator_SMESH_subMesh(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _SMESH.new_shared_ptr_SMDS_Iterator_SMESH_subMesh(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        return _SMESH.shared_ptr_SMDS_Iterator_SMESH_subMesh___deref__(self)

    def __ref__(self):
        return _SMESH.shared_ptr_SMDS_Iterator_SMESH_subMesh___ref__(self)
    __swig_destroy__ = _SMESH.delete_shared_ptr_SMDS_Iterator_SMESH_subMesh

    def more(self, *args):
        """
        more(shared_ptr_SMDS_Iterator_SMESH_subMesh self) -> bool

        Return true if and only if there are other object in this iterator

        :rtype: bool

        """
        return _SMESH.shared_ptr_SMDS_Iterator_SMESH_subMesh_more(self, *args)


    def next(self, *args):
        """
        next(shared_ptr_SMDS_Iterator_SMESH_subMesh self) -> SMESH_subMesh

        Return the current object and step to the next one

        :rtype: VALUE

        """
        return _SMESH.shared_ptr_SMDS_Iterator_SMESH_subMesh_next(self, *args)


    def remove(self, *args):
        """
        remove(shared_ptr_SMDS_Iterator_SMESH_subMesh self)

        Delete the current element and step to the next one


        """
        return _SMESH.shared_ptr_SMDS_Iterator_SMESH_subMesh_remove(self, *args)

shared_ptr_SMDS_Iterator_SMESH_subMesh_swigregister = _SMESH.shared_ptr_SMDS_Iterator_SMESH_subMesh_swigregister
shared_ptr_SMDS_Iterator_SMESH_subMesh_swigregister(shared_ptr_SMDS_Iterator_SMESH_subMesh)


try:
	SMESH_subMeshIteratorPtr = shared_ptr_SMDS_Iterator_SMESH_subMesh
except NameError:
	pass # does not exist, probably ignored

class SMESH_HypoFilter(SMESH_HypoPredicate):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(SMESH_HypoFilter self) -> SMESH_HypoFilter
        __init__(SMESH_HypoFilter self, SMESH_HypoPredicate aPredicate, bool notNegate=True) -> SMESH_HypoFilter

        :type aPredicate: OCC.wrapper.SMESH.SMESH_HypoPredicate
        :type notNegate: bool

        """
        this = _SMESH.new_SMESH_HypoFilter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(SMESH_HypoFilter self, SMESH_HypoPredicate aPredicate, bool notNegate=True) -> SMESH_HypoFilter

        :type aPredicate: OCC.wrapper.SMESH.SMESH_HypoPredicate
        :type notNegate: bool
        :rtype: OCC.wrapper.SMESH.SMESH_HypoFilter

        """
        return _SMESH.SMESH_HypoFilter_Init(self, *args)


    def And(self, *args):
        """
        And(SMESH_HypoFilter self, SMESH_HypoPredicate aPredicate) -> SMESH_HypoFilter

        :type aPredicate: OCC.wrapper.SMESH.SMESH_HypoPredicate
        :rtype: OCC.wrapper.SMESH.SMESH_HypoFilter

        """
        return _SMESH.SMESH_HypoFilter_And(self, *args)


    def AndNot(self, *args):
        """
        AndNot(SMESH_HypoFilter self, SMESH_HypoPredicate aPredicate) -> SMESH_HypoFilter

        :type aPredicate: OCC.wrapper.SMESH.SMESH_HypoPredicate
        :rtype: OCC.wrapper.SMESH.SMESH_HypoFilter

        """
        return _SMESH.SMESH_HypoFilter_AndNot(self, *args)


    def Or(self, *args):
        """
        Or(SMESH_HypoFilter self, SMESH_HypoPredicate aPredicate) -> SMESH_HypoFilter

        :type aPredicate: OCC.wrapper.SMESH.SMESH_HypoPredicate
        :rtype: OCC.wrapper.SMESH.SMESH_HypoFilter

        """
        return _SMESH.SMESH_HypoFilter_Or(self, *args)


    def OrNot(self, *args):
        """
        OrNot(SMESH_HypoFilter self, SMESH_HypoPredicate aPredicate) -> SMESH_HypoFilter

        :type aPredicate: OCC.wrapper.SMESH.SMESH_HypoPredicate
        :rtype: OCC.wrapper.SMESH.SMESH_HypoFilter

        """
        return _SMESH.SMESH_HypoFilter_OrNot(self, *args)


    def IsAlgo(*args):
        """
        IsAlgo() -> SMESH_HypoPredicate

        :rtype: OCC.wrapper.SMESH.SMESH_HypoPredicate

        """
        return _SMESH.SMESH_HypoFilter_IsAlgo(*args)

    IsAlgo = staticmethod(IsAlgo)

    def IsAuxiliary(*args):
        """
        IsAuxiliary() -> SMESH_HypoPredicate

        :rtype: OCC.wrapper.SMESH.SMESH_HypoPredicate

        """
        return _SMESH.SMESH_HypoFilter_IsAuxiliary(*args)

    IsAuxiliary = staticmethod(IsAuxiliary)

    def IsApplicableTo(*args):
        """
        IsApplicableTo(TopoDS_Shape theShape) -> SMESH_HypoPredicate

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.SMESH.SMESH_HypoPredicate

        """
        return _SMESH.SMESH_HypoFilter_IsApplicableTo(*args)

    IsApplicableTo = staticmethod(IsApplicableTo)

    def IsAssignedTo(*args):
        """
        IsAssignedTo(TopoDS_Shape theShape) -> SMESH_HypoPredicate

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.SMESH.SMESH_HypoPredicate

        """
        return _SMESH.SMESH_HypoFilter_IsAssignedTo(*args)

    IsAssignedTo = staticmethod(IsAssignedTo)

    def Is(*args):
        """
        Is(SMESH_Hypothesis theHypo) -> SMESH_HypoPredicate

        :type theHypo: OCC.wrapper.SMESH.SMESH_Hypothesis
        :rtype: OCC.wrapper.SMESH.SMESH_HypoPredicate

        """
        return _SMESH.SMESH_HypoFilter_Is(*args)

    Is = staticmethod(Is)

    def IsGlobal(*args):
        """
        IsGlobal(TopoDS_Shape theMainShape) -> SMESH_HypoPredicate

        :type theMainShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.SMESH.SMESH_HypoPredicate

        """
        return _SMESH.SMESH_HypoFilter_IsGlobal(*args)

    IsGlobal = staticmethod(IsGlobal)

    def IsMoreLocalThan(*args):
        """
        IsMoreLocalThan(TopoDS_Shape theShape, SMESH_Mesh theMesh) -> SMESH_HypoPredicate

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theMesh: OCC.wrapper.SMESH.SMESH_Mesh
        :rtype: OCC.wrapper.SMESH.SMESH_HypoPredicate

        """
        return _SMESH.SMESH_HypoFilter_IsMoreLocalThan(*args)

    IsMoreLocalThan = staticmethod(IsMoreLocalThan)

    def HasName(*args):
        """
        HasName(std::string const & theName) -> SMESH_HypoPredicate

        :type theName: string
        :rtype: OCC.wrapper.SMESH.SMESH_HypoPredicate

        """
        return _SMESH.SMESH_HypoFilter_HasName(*args)

    HasName = staticmethod(HasName)

    def HasDim(*args):
        """
        HasDim(int const theDim) -> SMESH_HypoPredicate

        :type theDim: const int
        :rtype: OCC.wrapper.SMESH.SMESH_HypoPredicate

        """
        return _SMESH.SMESH_HypoFilter_HasDim(*args)

    HasDim = staticmethod(HasDim)

    def HasType(*args):
        """
        HasType(int const theHypType) -> SMESH_HypoPredicate

        :type theHypType: const int
        :rtype: OCC.wrapper.SMESH.SMESH_HypoPredicate

        """
        return _SMESH.SMESH_HypoFilter_HasType(*args)

    HasType = staticmethod(HasType)

    def IsEmpty(self, *args):
        """
        IsEmpty(SMESH_HypoFilter self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_HypoFilter_IsEmpty(self, *args)


    def IsOk(self, *args):
        """
        IsOk(SMESH_HypoFilter self, SMESH_Hypothesis aHyp, TopoDS_Shape aShape) -> bool

        rief check aHyp or/and aShape it is assigned to

        :type aHyp: OCC.wrapper.SMESH.SMESH_Hypothesis
        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: bool

        """
        return _SMESH.SMESH_HypoFilter_IsOk(self, *args)


    def IsAny(self, *args):
        """
        IsAny(SMESH_HypoFilter self) -> bool

        rief return true if contains no predicates

        :rtype: bool

        """
        return _SMESH.SMESH_HypoFilter_IsAny(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_HypoFilter
SMESH_HypoFilter_swigregister = _SMESH.SMESH_HypoFilter_swigregister
SMESH_HypoFilter_swigregister(SMESH_HypoFilter)

def SMESH_HypoFilter_IsAlgo(*args):
    """
    SMESH_HypoFilter_IsAlgo() -> SMESH_HypoPredicate

    :rtype: OCC.wrapper.SMESH.SMESH_HypoPredicate

    """
    return _SMESH.SMESH_HypoFilter_IsAlgo(*args)

def SMESH_HypoFilter_IsAuxiliary(*args):
    """
    SMESH_HypoFilter_IsAuxiliary() -> SMESH_HypoPredicate

    :rtype: OCC.wrapper.SMESH.SMESH_HypoPredicate

    """
    return _SMESH.SMESH_HypoFilter_IsAuxiliary(*args)

def SMESH_HypoFilter_IsApplicableTo(*args):
    """
    SMESH_HypoFilter_IsApplicableTo(TopoDS_Shape theShape) -> SMESH_HypoPredicate

    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.SMESH.SMESH_HypoPredicate

    """
    return _SMESH.SMESH_HypoFilter_IsApplicableTo(*args)

def SMESH_HypoFilter_IsAssignedTo(*args):
    """
    SMESH_HypoFilter_IsAssignedTo(TopoDS_Shape theShape) -> SMESH_HypoPredicate

    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.SMESH.SMESH_HypoPredicate

    """
    return _SMESH.SMESH_HypoFilter_IsAssignedTo(*args)

def SMESH_HypoFilter_Is(*args):
    """
    SMESH_HypoFilter_Is(SMESH_Hypothesis theHypo) -> SMESH_HypoPredicate

    :type theHypo: OCC.wrapper.SMESH.SMESH_Hypothesis
    :rtype: OCC.wrapper.SMESH.SMESH_HypoPredicate

    """
    return _SMESH.SMESH_HypoFilter_Is(*args)

def SMESH_HypoFilter_IsGlobal(*args):
    """
    SMESH_HypoFilter_IsGlobal(TopoDS_Shape theMainShape) -> SMESH_HypoPredicate

    :type theMainShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.SMESH.SMESH_HypoPredicate

    """
    return _SMESH.SMESH_HypoFilter_IsGlobal(*args)

def SMESH_HypoFilter_IsMoreLocalThan(*args):
    """
    SMESH_HypoFilter_IsMoreLocalThan(TopoDS_Shape theShape, SMESH_Mesh theMesh) -> SMESH_HypoPredicate

    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theMesh: OCC.wrapper.SMESH.SMESH_Mesh
    :rtype: OCC.wrapper.SMESH.SMESH_HypoPredicate

    """
    return _SMESH.SMESH_HypoFilter_IsMoreLocalThan(*args)

def SMESH_HypoFilter_HasName(*args):
    """
    SMESH_HypoFilter_HasName(std::string const & theName) -> SMESH_HypoPredicate

    :type theName: string
    :rtype: OCC.wrapper.SMESH.SMESH_HypoPredicate

    """
    return _SMESH.SMESH_HypoFilter_HasName(*args)

def SMESH_HypoFilter_HasDim(*args):
    """
    SMESH_HypoFilter_HasDim(int const theDim) -> SMESH_HypoPredicate

    :type theDim: const int
    :rtype: OCC.wrapper.SMESH.SMESH_HypoPredicate

    """
    return _SMESH.SMESH_HypoFilter_HasDim(*args)

def SMESH_HypoFilter_HasType(*args):
    """
    SMESH_HypoFilter_HasType(int const theHypType) -> SMESH_HypoPredicate

    :type theHypType: const int
    :rtype: OCC.wrapper.SMESH.SMESH_HypoPredicate

    """
    return _SMESH.SMESH_HypoFilter_HasType(*args)

class shared_ptr_SMESH_ComputeError(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _SMESH.new_shared_ptr_SMESH_ComputeError(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        return _SMESH.shared_ptr_SMESH_ComputeError___deref__(self)

    def __ref__(self):
        return _SMESH.shared_ptr_SMESH_ComputeError___ref__(self)
    __swig_destroy__ = _SMESH.delete_shared_ptr_SMESH_ComputeError
shared_ptr_SMESH_ComputeError_swigregister = _SMESH.shared_ptr_SMESH_ComputeError_swigregister
shared_ptr_SMESH_ComputeError_swigregister(shared_ptr_SMESH_ComputeError)


try:
	SMESH_ComputeErrorPtr = shared_ptr_SMESH_ComputeError
except NameError:
	pass # does not exist, probably ignored

class SMESH_ProxyMesh(object):
    """
    rief Container of xD mesh elements substituting other ones in the
    input mesh of an (x+1)D algorithm
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(SMESH_ProxyMesh self) -> SMESH_ProxyMesh
        __init__(SMESH_ProxyMesh self, std::vector< SMESH_ProxyMesh::Ptr,std::allocator< SMESH_ProxyMesh::Ptr > > & components) -> SMESH_ProxyMesh
        __init__(SMESH_ProxyMesh self, SMESH_Mesh mesh) -> SMESH_ProxyMesh

        :type mesh: OCC.wrapper.SMESH.SMESH_Mesh

        """
        this = _SMESH.new_SMESH_ProxyMesh(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetSubMesh(self, *args):
        """
        GetSubMesh(SMESH_ProxyMesh self, TopoDS_Shape shape) -> SMESHDS_SubMesh

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.SMESHDS.SMESHDS_SubMesh

        """
        return _SMESH.SMESH_ProxyMesh_GetSubMesh(self, *args)


    def GetProxySubMesh(self, *args):
        """
        GetProxySubMesh(SMESH_ProxyMesh self, TopoDS_Shape shape) -> SMESH_ProxyMesh::SubMesh const *

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.SMESH.SubMesh

        """
        return _SMESH.SMESH_ProxyMesh_GetProxySubMesh(self, *args)


    def GetProxyNode(self, *args):
        """
        GetProxyNode(SMESH_ProxyMesh self, SMDS_MeshNode node) -> SMDS_MeshNode

        :type node: OCC.wrapper.SMDS.SMDS_MeshNode
        :rtype: OCC.wrapper.SMDS.SMDS_MeshNode

        """
        return _SMESH.SMESH_ProxyMesh_GetProxyNode(self, *args)


    def NbProxySubMeshes(self, *args):
        """
        NbProxySubMeshes(SMESH_ProxyMesh self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_ProxyMesh_NbProxySubMeshes(self, *args)


    def GetFaces(self, *args):
        """
        GetFaces(SMESH_ProxyMesh self) -> shared_ptr_SMDS_Iterator_SMDS_MeshElement
        GetFaces(SMESH_ProxyMesh self, TopoDS_Shape face) -> shared_ptr_SMDS_Iterator_SMDS_MeshElement

        :type face: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.SMDS.SMDS_ElemIteratorPtr

        """
        return _SMESH.SMESH_ProxyMesh_GetFaces(self, *args)


    def NbFaces(self, *args):
        """
        NbFaces(SMESH_ProxyMesh self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_ProxyMesh_NbFaces(self, *args)


    def IsTemporary(self, *args):
        """
        IsTemporary(SMESH_ProxyMesh self, SMDS_MeshElement elem) -> bool

        :type elem: OCC.wrapper.SMDS.SMDS_MeshElement
        :rtype: bool

        """
        return _SMESH.SMESH_ProxyMesh_IsTemporary(self, *args)


    def GetMesh(self, *args):
        """
        GetMesh(SMESH_ProxyMesh self) -> SMESH_Mesh

        :rtype: OCC.wrapper.SMESH.SMESH_Mesh

        """
        return _SMESH.SMESH_ProxyMesh_GetMesh(self, *args)


    def GetMeshDS(self, *args):
        """
        GetMeshDS(SMESH_ProxyMesh self) -> SMESHDS_Mesh

        :rtype: OCC.wrapper.SMESHDS.SMESHDS_Mesh

        """
        return _SMESH.SMESH_ProxyMesh_GetMeshDS(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_ProxyMesh
SMESH_ProxyMesh_swigregister = _SMESH.SMESH_ProxyMesh_swigregister
SMESH_ProxyMesh_swigregister(SMESH_ProxyMesh)

class SMESH_0D_Algo(SMESH_Algo):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _SMESH.delete_SMESH_0D_Algo
SMESH_0D_Algo_swigregister = _SMESH.SMESH_0D_Algo_swigregister
SMESH_0D_Algo_swigregister(SMESH_0D_Algo)

class NCollection_Sequence_SMDS_MeshNodePtr(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_SMDS_MeshNodePtr self) -> NCollection_Sequence< SMDS_MeshNode const * >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_SMDS_MeshNodePtr self) -> NCollection_Sequence< SMDS_MeshNode const * >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_SMDS_MeshNodePtr self) -> NCollection_Sequence< SMDS_MeshNode const * >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_SMDS_MeshNodePtr self) -> NCollection_Sequence< SMDS_MeshNode const * >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _SMESH.new_NCollection_Sequence_SMDS_MeshNodePtr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_SMDS_MeshNodePtr self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_SMDS_MeshNodePtr self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_SMDS_MeshNodePtr self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_SMDS_MeshNodePtr self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_SMDS_MeshNodePtr self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_SMDS_MeshNodePtr self)

        Reverse sequence


        """
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_SMDS_MeshNodePtr self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_SMDS_MeshNodePtr self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_SMDS_MeshNodePtr self, NCollection_Sequence_SMDS_MeshNodePtr theOther) -> NCollection_Sequence_SMDS_MeshNodePtr

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_SMDS_MeshNodePtr self, NCollection_Sequence_SMDS_MeshNodePtr theOther) -> NCollection_Sequence_SMDS_MeshNodePtr

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_SMDS_MeshNodePtr self, NCollection_Sequence< SMDS_MeshNode const * >::Iterator & thePosition)
        Remove(NCollection_Sequence_SMDS_MeshNodePtr self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_SMDS_MeshNodePtr self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_SMDS_MeshNodePtr self, SMDS_MeshNode theItem)
        Append(NCollection_Sequence_SMDS_MeshNodePtr self, NCollection_Sequence_SMDS_MeshNodePtr theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_SMDS_MeshNodePtr self, SMDS_MeshNode theItem)
        Prepend(NCollection_Sequence_SMDS_MeshNodePtr self, NCollection_Sequence_SMDS_MeshNodePtr theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_SMDS_MeshNodePtr self, Standard_Integer const theIndex, SMDS_MeshNode theItem)
        InsertBefore(NCollection_Sequence_SMDS_MeshNodePtr self, Standard_Integer const theIndex, NCollection_Sequence_SMDS_MeshNodePtr theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_SMDS_MeshNodePtr self, NCollection_Sequence< SMDS_MeshNode const * >::Iterator & thePosition, SMDS_MeshNode theItem)
        InsertAfter(NCollection_Sequence_SMDS_MeshNodePtr self, Standard_Integer const theIndex, NCollection_Sequence_SMDS_MeshNodePtr theSeq)
        InsertAfter(NCollection_Sequence_SMDS_MeshNodePtr self, Standard_Integer const theIndex, SMDS_MeshNode theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_SMDS_MeshNodePtr self, Standard_Integer const theIndex, NCollection_Sequence_SMDS_MeshNodePtr theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_SMDS_MeshNodePtr self) -> SMDS_MeshNode const *&

        First item access

        :rtype: TheItemType &

        """
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_SMDS_MeshNodePtr self) -> SMDS_MeshNode const *&

        Last item access

        :rtype: TheItemType &

        """
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_SMDS_MeshNodePtr self, Standard_Integer const theIndex) -> SMDS_MeshNode const *&

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _SMESH.NCollection_Sequence_SMDS_MeshNodePtr___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_SMDS_MeshNodePtr self, Standard_Integer const theIndex, SMDS_MeshNode theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_SetValue(self, *args)


    def __iter__(self):
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr___iter__(self)
    __swig_destroy__ = _SMESH.delete_NCollection_Sequence_SMDS_MeshNodePtr
NCollection_Sequence_SMDS_MeshNodePtr_swigregister = _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_swigregister
NCollection_Sequence_SMDS_MeshNodePtr_swigregister(NCollection_Sequence_SMDS_MeshNodePtr)

def NCollection_Sequence_SMDS_MeshNodePtr_delNode(*args):
    """
    NCollection_Sequence_SMDS_MeshNodePtr_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_delNode(*args)

class NCollection_Sequence_SMDS_MeshNodePtr_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _SMESH.new_NCollection_Sequence_SMDS_MeshNodePtr_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _SMESH.delete_NCollection_Sequence_SMDS_MeshNodePtr_IteratorHelper

    def __next__(self):
        return _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_IteratorHelper___next__(self)
NCollection_Sequence_SMDS_MeshNodePtr_IteratorHelper_swigregister = _SMESH.NCollection_Sequence_SMDS_MeshNodePtr_IteratorHelper_swigregister
NCollection_Sequence_SMDS_MeshNodePtr_IteratorHelper_swigregister(NCollection_Sequence_SMDS_MeshNodePtr_IteratorHelper)


try:
	SMESH_SequenceOfNode = NCollection_Sequence_SMDS_MeshNodePtr
except NameError:
	pass # does not exist, probably ignored

class shared_ptr_SMESH_ProxyMesh(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _SMESH.new_shared_ptr_SMESH_ProxyMesh(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        return _SMESH.shared_ptr_SMESH_ProxyMesh___deref__(self)

    def __ref__(self):
        return _SMESH.shared_ptr_SMESH_ProxyMesh___ref__(self)
    __swig_destroy__ = _SMESH.delete_shared_ptr_SMESH_ProxyMesh

    def GetSubMesh(self, *args):
        """
        GetSubMesh(shared_ptr_SMESH_ProxyMesh self, TopoDS_Shape shape) -> SMESHDS_SubMesh

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.SMESHDS.SMESHDS_SubMesh

        """
        return _SMESH.shared_ptr_SMESH_ProxyMesh_GetSubMesh(self, *args)


    def GetProxySubMesh(self, *args):
        """
        GetProxySubMesh(shared_ptr_SMESH_ProxyMesh self, TopoDS_Shape shape) -> SMESH_ProxyMesh::SubMesh const *

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.SMESH.SubMesh

        """
        return _SMESH.shared_ptr_SMESH_ProxyMesh_GetProxySubMesh(self, *args)


    def GetProxyNode(self, *args):
        """
        GetProxyNode(shared_ptr_SMESH_ProxyMesh self, SMDS_MeshNode node) -> SMDS_MeshNode

        :type node: OCC.wrapper.SMDS.SMDS_MeshNode
        :rtype: OCC.wrapper.SMDS.SMDS_MeshNode

        """
        return _SMESH.shared_ptr_SMESH_ProxyMesh_GetProxyNode(self, *args)


    def NbProxySubMeshes(self, *args):
        """
        NbProxySubMeshes(shared_ptr_SMESH_ProxyMesh self) -> int

        :rtype: int

        """
        return _SMESH.shared_ptr_SMESH_ProxyMesh_NbProxySubMeshes(self, *args)


    def GetFaces(self, *args):
        """
        GetFaces(shared_ptr_SMESH_ProxyMesh self) -> shared_ptr_SMDS_Iterator_SMDS_MeshElement
        GetFaces(shared_ptr_SMESH_ProxyMesh self, TopoDS_Shape face) -> shared_ptr_SMDS_Iterator_SMDS_MeshElement

        :type face: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.SMDS.SMDS_ElemIteratorPtr

        """
        return _SMESH.shared_ptr_SMESH_ProxyMesh_GetFaces(self, *args)


    def NbFaces(self, *args):
        """
        NbFaces(shared_ptr_SMESH_ProxyMesh self) -> int

        :rtype: int

        """
        return _SMESH.shared_ptr_SMESH_ProxyMesh_NbFaces(self, *args)


    def IsTemporary(self, *args):
        """
        IsTemporary(shared_ptr_SMESH_ProxyMesh self, SMDS_MeshElement elem) -> bool

        :type elem: OCC.wrapper.SMDS.SMDS_MeshElement
        :rtype: bool

        """
        return _SMESH.shared_ptr_SMESH_ProxyMesh_IsTemporary(self, *args)


    def GetMesh(self, *args):
        """
        GetMesh(shared_ptr_SMESH_ProxyMesh self) -> SMESH_Mesh

        :rtype: OCC.wrapper.SMESH.SMESH_Mesh

        """
        return _SMESH.shared_ptr_SMESH_ProxyMesh_GetMesh(self, *args)


    def GetMeshDS(self, *args):
        """
        GetMeshDS(shared_ptr_SMESH_ProxyMesh self) -> SMESHDS_Mesh

        :rtype: OCC.wrapper.SMESHDS.SMESHDS_Mesh

        """
        return _SMESH.shared_ptr_SMESH_ProxyMesh_GetMeshDS(self, *args)

shared_ptr_SMESH_ProxyMesh_swigregister = _SMESH.shared_ptr_SMESH_ProxyMesh_swigregister
shared_ptr_SMESH_ProxyMesh_swigregister(shared_ptr_SMESH_ProxyMesh)


try:
	Ptr = shared_ptr_SMESH_ProxyMesh
except NameError:
	pass # does not exist, probably ignored

class SMDS_Iterator_SMESH_Group(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def more(self, *args):
        """
        more(SMDS_Iterator_SMESH_Group self) -> bool

        Return true if and only if there are other object in this iterator

        :rtype: bool

        """
        return _SMESH.SMDS_Iterator_SMESH_Group_more(self, *args)


    def next(self, *args):
        """
        next(SMDS_Iterator_SMESH_Group self) -> SMESH_Group

        Return the current object and step to the next one

        :rtype: VALUE

        """
        return _SMESH.SMDS_Iterator_SMESH_Group_next(self, *args)


    def remove(self, *args):
        """
        remove(SMDS_Iterator_SMESH_Group self)

        Delete the current element and step to the next one


        """
        return _SMESH.SMDS_Iterator_SMESH_Group_remove(self, *args)

    __swig_destroy__ = _SMESH.delete_SMDS_Iterator_SMESH_Group
SMDS_Iterator_SMESH_Group_swigregister = _SMESH.SMDS_Iterator_SMESH_Group_swigregister
SMDS_Iterator_SMESH_Group_swigregister(SMDS_Iterator_SMESH_Group)

class SMESH_Comment(object):
    """rief Class to generate string from any type"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(SMESH_Comment self) -> SMESH_Comment
        __init__(SMESH_Comment self, SMESH_Comment c) -> SMESH_Comment

        :type c: OCC.wrapper.SMESH.SMESH_Comment

        """
        this = _SMESH.new_SMESH_Comment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def assign(self, *args):
        """
        assign(SMESH_Comment self, SMESH_Comment c) -> SMESH_Comment

        :type c: OCC.wrapper.SMESH.SMESH_Comment
        :rtype: OCC.wrapper.SMESH.SMESH_Comment

        """
        return _SMESH.SMESH_Comment_assign(self, *args)


    def Stream(self, *args):
        """
        Stream(SMESH_Comment self) -> std::ostream &

        :rtype: ostream

        """
        return _SMESH.SMESH_Comment_Stream(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_Comment
SMESH_Comment_swigregister = _SMESH.SMESH_Comment_swigregister
SMESH_Comment_swigregister(SMESH_Comment)

class SMESH_ActorProps(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def props(*args):
        """
        props() -> SMESH_ActorProps

        :rtype: OCC.wrapper.SMESH.SMESH_ActorProps

        """
        return _SMESH.SMESH_ActorProps_props(*args)

    props = staticmethod(props)

    def reset(*args):
        """reset()"""
        return _SMESH.SMESH_ActorProps_reset(*args)

    reset = staticmethod(reset)

    def selectionColor(self, *args):
        """
        selectionColor(SMESH_ActorProps self) -> QColor

        :rtype: QColor

        """
        return _SMESH.SMESH_ActorProps_selectionColor(self, *args)


    def highlightColor(self, *args):
        """
        highlightColor(SMESH_ActorProps self) -> QColor

        :rtype: QColor

        """
        return _SMESH.SMESH_ActorProps_highlightColor(self, *args)


    def selectionIncrement(self, *args):
        """
        selectionIncrement(SMESH_ActorProps self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_ActorProps_selectionIncrement(self, *args)


    def controlsIncrement(self, *args):
        """
        controlsIncrement(SMESH_ActorProps self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_ActorProps_controlsIncrement(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_ActorProps
SMESH_ActorProps_swigregister = _SMESH.SMESH_ActorProps_swigregister
SMESH_ActorProps_swigregister(SMESH_ActorProps)

def SMESH_ActorProps_props(*args):
    """
    SMESH_ActorProps_props() -> SMESH_ActorProps

    :rtype: OCC.wrapper.SMESH.SMESH_ActorProps

    """
    return _SMESH.SMESH_ActorProps_props(*args)

def SMESH_ActorProps_reset(*args):
    """SMESH_ActorProps_reset()"""
    return _SMESH.SMESH_ActorProps_reset(*args)

class SMESH_MeshObj(SMESH_VisualObjDef):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(SMESH_MeshObj self, SMESH::SMESH_Mesh_ptr arg2) -> SMESH_MeshObj

        :type : OCC.wrapper.SMESH.SMESH_Mesh_ptr

        """
        this = _SMESH.new_SMESH_MeshObj(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Update(self, *args):
        """
        Update(SMESH_MeshObj self, int theIsClear=True) -> bool

        :type theIsClear: int
        :rtype: bool

        """
        return _SMESH.SMESH_MeshObj_Update(self, *args)


    def NulData(self, *args):
        """
        NulData(SMESH_MeshObj self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_MeshObj_NulData(self, *args)


    def GetNbEntities(self, *args):
        """
        GetNbEntities(SMESH_MeshObj self, SMDSAbs_ElementType const arg2) -> int

        :type : OCC.wrapper.SMDSAbs.SMDSAbs_ElementType
        :rtype: int

        """
        return _SMESH.SMESH_MeshObj_GetNbEntities(self, *args)


    def GetEntities(self, *args):
        """
        GetEntities(SMESH_MeshObj self, SMDSAbs_ElementType const arg2, SMESH_VisualObjDef::TEntityList & arg3) -> int

        :type : OCC.wrapper.SMDSAbs.SMDSAbs_ElementType
        :type : TEntityList
        :rtype: int

        """
        return _SMESH.SMESH_MeshObj_GetEntities(self, *args)


    def IsNodePrs(self, *args):
        """
        IsNodePrs(SMESH_MeshObj self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_MeshObj_IsNodePrs(self, *args)


    def GetElemDimension(self, *args):
        """
        GetElemDimension(SMESH_MeshObj self, int const theObjId) -> int

        :type theObjId: const int
        :rtype: int

        """
        return _SMESH.SMESH_MeshObj_GetElemDimension(self, *args)


    def UpdateFunctor(self, *args):
        """
        UpdateFunctor(SMESH_MeshObj self, SMESH::Controls::FunctorPtr const & theFunctor)

        :type theFunctor: FunctorPtr

        """
        return _SMESH.SMESH_MeshObj_UpdateFunctor(self, *args)


    def GetMeshServer(self, *args):
        """
        GetMeshServer(SMESH_MeshObj self) -> SMESH::SMESH_Mesh_ptr

        :rtype: OCC.wrapper.SMESH.SMESH_Mesh_ptr

        """
        return _SMESH.SMESH_MeshObj_GetMeshServer(self, *args)


    def GetMesh(self, *args):
        """
        GetMesh(SMESH_MeshObj self) -> SMDS_Mesh

        :rtype: OCC.wrapper.SMDS.SMDS_Mesh

        """
        return _SMESH.SMESH_MeshObj_GetMesh(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_MeshObj
SMESH_MeshObj_swigregister = _SMESH.SMESH_MeshObj_swigregister
SMESH_MeshObj_swigregister(SMESH_MeshObj)

class SMESH_PreviewActorsCollection(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(SMESH_PreviewActorsCollection self) -> SMESH_PreviewActorsCollection"""
        this = _SMESH.new_SMESH_PreviewActorsCollection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddToRender(self, *args):
        """
        AddToRender(SMESH_PreviewActorsCollection self, vtkRenderer * theRenderer)

        :type theRenderer: vtkRenderer

        """
        return _SMESH.SMESH_PreviewActorsCollection_AddToRender(self, *args)


    def RemoveFromRender(self, *args):
        """
        RemoveFromRender(SMESH_PreviewActorsCollection self, vtkRenderer * theRenderer)

        :type theRenderer: vtkRenderer

        """
        return _SMESH.SMESH_PreviewActorsCollection_RemoveFromRender(self, *args)


    def Init(self, *args):
        """
        Init(SMESH_PreviewActorsCollection self, TopoDS_Shape theShape, TopoDS_Shape theMainShape, TopAbs_ShapeEnum subShapeType=TopAbs_EDGE, QString const & arg5) -> bool

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theMainShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type subShapeType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type : QString
        :rtype: bool

        """
        return _SMESH.SMESH_PreviewActorsCollection_Init(self, *args)


    def SetSelector(self, *args):
        """
        SetSelector(SMESH_PreviewActorsCollection self, SVTK_Selector * arg2)

        :type : SVTK_Selector

        """
        return _SMESH.SMESH_PreviewActorsCollection_SetSelector(self, *args)


    def HighlightAll(self, *args):
        """
        HighlightAll(SMESH_PreviewActorsCollection self, bool arg2)

        :type : bool

        """
        return _SMESH.SMESH_PreviewActorsCollection_HighlightAll(self, *args)


    def HighlightID(self, *args):
        """
        HighlightID(SMESH_PreviewActorsCollection self, int arg2)

        :type : int

        """
        return _SMESH.SMESH_PreviewActorsCollection_HighlightID(self, *args)


    def GetActorByIndex(self, *args):
        """
        GetActorByIndex(SMESH_PreviewActorsCollection self, int arg2) -> GEOM_Actor *

        :type : int
        :rtype: OCC.wrapper.SMESH.GEOM_Actor

        """
        return _SMESH.SMESH_PreviewActorsCollection_GetActorByIndex(self, *args)


    def IsValidIndex(self, *args):
        """
        IsValidIndex(SMESH_PreviewActorsCollection self, int arg2) -> bool

        :type : int
        :rtype: bool

        """
        return _SMESH.SMESH_PreviewActorsCollection_IsValidIndex(self, *args)


    def GetIndexByShape(self, *args):
        """
        GetIndexByShape(SMESH_PreviewActorsCollection self, TopoDS_Shape arg2) -> int

        :type : OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: int

        """
        return _SMESH.SMESH_PreviewActorsCollection_GetIndexByShape(self, *args)


    def GetShapeByIndex(self, *args):
        """
        GetShapeByIndex(SMESH_PreviewActorsCollection self, int i) -> TopoDS_Shape

        :type i: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _SMESH.SMESH_PreviewActorsCollection_GetShapeByIndex(self, *args)


    def NbShapesOfType(self, *args):
        """
        NbShapesOfType(SMESH_PreviewActorsCollection self, TopAbs_ShapeEnum type) -> int

        :type type: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: int

        """
        return _SMESH.SMESH_PreviewActorsCollection_NbShapesOfType(self, *args)


    def SetIndices(self, *args):
        """
        SetIndices(SMESH_PreviewActorsCollection self, QList< int > const & indices)

        :type indices: OCC.wrapper.SMESH.QList

        """
        return _SMESH.SMESH_PreviewActorsCollection_SetIndices(self, *args)


    def GetIndices(self, *args):
        """
        :rtype: OCC.wrapper.SMESH.QList

        """
        res = _SMESH.SMESH_PreviewActorsCollection_GetIndices(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetShown(self, *args):
        """
        SetShown(SMESH_PreviewActorsCollection self, bool arg2)

        :type : bool

        """
        return _SMESH.SMESH_PreviewActorsCollection_SetShown(self, *args)


    def count(self, *args):
        """
        count(SMESH_PreviewActorsCollection self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_PreviewActorsCollection_count(self, *args)


    def chunkSize(self, *args):
        """
        chunkSize(SMESH_PreviewActorsCollection self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_PreviewActorsCollection_chunkSize(self, *args)


    def currentChunk(self, *args):
        """
        currentChunk(SMESH_PreviewActorsCollection self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_PreviewActorsCollection_currentChunk(self, *args)


    def hasPrevious(self, *args):
        """
        hasPrevious(SMESH_PreviewActorsCollection self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_PreviewActorsCollection_hasPrevious(self, *args)


    def hasNext(self, *args):
        """
        hasNext(SMESH_PreviewActorsCollection self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_PreviewActorsCollection_hasNext(self, *args)


    def previous(self, *args):
        """previous(SMESH_PreviewActorsCollection self)"""
        return _SMESH.SMESH_PreviewActorsCollection_previous(self, *args)


    def next(self, *args):
        """next(SMESH_PreviewActorsCollection self)"""
        return _SMESH.SMESH_PreviewActorsCollection_next(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_PreviewActorsCollection
SMESH_PreviewActorsCollection_swigregister = _SMESH.SMESH_PreviewActorsCollection_swigregister
SMESH_PreviewActorsCollection_swigregister(SMESH_PreviewActorsCollection)

class SMESH_MeshVSLink(MeshVS.MeshVS_DataSource3D):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_SMESH_MeshVSLink
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_SMESH_MeshVSLink(self) 
            return h


    def __init__(self, *args):
        """
        __init__(SMESH_MeshVSLink self, SMESH_Mesh aMesh) -> SMESH_MeshVSLink

        Constructor <br>

        :type aMesh: OCC.wrapper.SMESH.SMESH_Mesh

        """
        this = _SMESH.new_SMESH_MeshVSLink(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetGeom(self, *args):
        """
        GetGeom(SMESH_MeshVSLink self, Standard_Integer const ID, Standard_Boolean const IsElement, NCollection_Array1_Standard_Real Coords) -> Standard_Boolean

        Returns geometry information about node ( if IsElement is False ) or element ( IsElement is True ) <br>
        by co-ordinates. For element this method must return all its nodes co-ordinates in the strict order: X, Y, Z and <br>
        with nodes order is the same as in wire bounding the face or link. NbNodes is number of nodes of element. <br>
        It is recommended to return 1 for node. Type is an element type. <br>

        :type ID: int
        :type IsElement: bool
        :type Coords: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NbNodes: int
        :type Type: OCC.wrapper.MeshVS.MeshVS_EntityType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.SMESH_MeshVSLink_GetGeom(self, *args)


    def Get3DGeom(self, *args):
        """
        Get3DGeom(SMESH_MeshVSLink self, Standard_Integer const ID, Handle_MeshVS_HArray1OfSequenceOfInteger Data) -> Standard_Boolean

        :type ID: int
        :type NbNodes: int
        :type Data: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.SMESH_MeshVSLink_Get3DGeom(self, *args)


    def GetGeomType(self, *args):
        """
        GetGeomType(SMESH_MeshVSLink self, Standard_Integer const ID, Standard_Boolean const IsElement) -> Standard_Boolean

        This method is similar to GetGeom, but returns only element or node type. This method is provided for <br>
        a fine performance. <br>

        :type ID: int
        :type IsElement: bool
        :type Type: OCC.wrapper.MeshVS.MeshVS_EntityType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.SMESH_MeshVSLink_GetGeomType(self, *args)


    def GetAddr(self, *args):
        """
        GetAddr(SMESH_MeshVSLink self, Standard_Integer const ID, Standard_Boolean const IsElement) -> Standard_Address

        This method returns by number an address of any entity which represents element or node data structure. <br>

        :type ID: int
        :type IsElement: bool
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _SMESH.SMESH_MeshVSLink_GetAddr(self, *args)


    def GetNodesByElement(self, *args):
        """
        GetNodesByElement(SMESH_MeshVSLink self, Standard_Integer const ID, NCollection_Array1_Standard_Integer NodeIDs) -> Standard_Boolean

        This method returns information about what node this element consist of. <br>

        :type ID: int
        :type NodeIDs: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type NbNodes: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.SMESH_MeshVSLink_GetNodesByElement(self, *args)


    def GetAllNodes(self, *args):
        """
        This method returns map of all nodes the object consist of. <br>

        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        res = _SMESH.SMESH_MeshVSLink_GetAllNodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetAllElements(self, *args):
        """
        This method returns map of all elements the object consist of. <br>

        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        res = _SMESH.SMESH_MeshVSLink_GetAllElements(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetNormal(self, *args):
        """
        GetNormal(SMESH_MeshVSLink self, Standard_Integer const Id, Standard_Integer const Max) -> Standard_Boolean

        This method calculates normal of face, which is using for correct reflection presentation. <br>
        There is default method, for advance reflection this method can be redefined. <br>

        :type Id: int
        :type Max: int
        :type nx: float
        :type ny: float
        :type nz: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.SMESH_MeshVSLink_GetNormal(self, *args)


    def GetAllGroups(self, *args):
        """
        GetAllGroups(SMESH_MeshVSLink self, TColStd_PackedMapOfInteger Ids)

        This method returns map of all groups the object contains. <br>

        :type Ids: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        return _SMESH.SMESH_MeshVSLink_GetAllGroups(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _SMESH.SMESH_MeshVSLink_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _SMESH.SMESH_MeshVSLink_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SMESH.SMESH_MeshVSLink_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _SMESH.delete_SMESH_MeshVSLink
SMESH_MeshVSLink_swigregister = _SMESH.SMESH_MeshVSLink_swigregister
SMESH_MeshVSLink_swigregister(SMESH_MeshVSLink)

def SMESH_MeshVSLink_get_type_name(*args):
    """
    SMESH_MeshVSLink_get_type_name() -> char const *

    :rtype: const char *

    """
    return _SMESH.SMESH_MeshVSLink_get_type_name(*args)

def SMESH_MeshVSLink_get_type_descriptor(*args):
    """
    SMESH_MeshVSLink_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _SMESH.SMESH_MeshVSLink_get_type_descriptor(*args)

class SMESH_MeshEditor(object):
    """rief Editor of a mesh"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    HEXA_TO_5 = _SMESH.SMESH_MeshEditor_HEXA_TO_5
    HEXA_TO_6 = _SMESH.SMESH_MeshEditor_HEXA_TO_6
    HEXA_TO_24 = _SMESH.SMESH_MeshEditor_HEXA_TO_24
    HEXA_TO_2_PRISMS = _SMESH.SMESH_MeshEditor_HEXA_TO_2_PRISMS
    HEXA_TO_4_PRISMS = _SMESH.SMESH_MeshEditor_HEXA_TO_4_PRISMS
    LAPLACIAN = _SMESH.SMESH_MeshEditor_LAPLACIAN
    CENTROIDAL = _SMESH.SMESH_MeshEditor_CENTROIDAL
    EXTRUSION_FLAG_BOUNDARY = _SMESH.SMESH_MeshEditor_EXTRUSION_FLAG_BOUNDARY
    EXTRUSION_FLAG_SEW = _SMESH.SMESH_MeshEditor_EXTRUSION_FLAG_SEW
    EXTRUSION_FLAG_GROUPS = _SMESH.SMESH_MeshEditor_EXTRUSION_FLAG_GROUPS
    EXTRUSION_FLAG_BY_AVG_NORMAL = _SMESH.SMESH_MeshEditor_EXTRUSION_FLAG_BY_AVG_NORMAL
    EXTRUSION_FLAG_USE_INPUT_ELEMS_ONLY = _SMESH.SMESH_MeshEditor_EXTRUSION_FLAG_USE_INPUT_ELEMS_ONLY
    EXTRUSION_FLAG_SCALE_LINEAR_VARIATION = _SMESH.SMESH_MeshEditor_EXTRUSION_FLAG_SCALE_LINEAR_VARIATION
    EXTRUSION_FLAG_ANGLE_LINEAR_VARIATION = _SMESH.SMESH_MeshEditor_EXTRUSION_FLAG_ANGLE_LINEAR_VARIATION
    EXTR_OK = _SMESH.SMESH_MeshEditor_EXTR_OK
    EXTR_NO_ELEMENTS = _SMESH.SMESH_MeshEditor_EXTR_NO_ELEMENTS
    EXTR_PATH_NOT_EDGE = _SMESH.SMESH_MeshEditor_EXTR_PATH_NOT_EDGE
    EXTR_BAD_PATH_SHAPE = _SMESH.SMESH_MeshEditor_EXTR_BAD_PATH_SHAPE
    EXTR_BAD_STARTING_NODE = _SMESH.SMESH_MeshEditor_EXTR_BAD_STARTING_NODE
    EXTR_BAD_ANGLES_NUMBER = _SMESH.SMESH_MeshEditor_EXTR_BAD_ANGLES_NUMBER
    EXTR_CANT_GET_TANGENT = _SMESH.SMESH_MeshEditor_EXTR_CANT_GET_TANGENT
    SEW_OK = _SMESH.SMESH_MeshEditor_SEW_OK
    SEW_BORDER1_NOT_FOUND = _SMESH.SMESH_MeshEditor_SEW_BORDER1_NOT_FOUND
    SEW_BORDER2_NOT_FOUND = _SMESH.SMESH_MeshEditor_SEW_BORDER2_NOT_FOUND
    SEW_BOTH_BORDERS_NOT_FOUND = _SMESH.SMESH_MeshEditor_SEW_BOTH_BORDERS_NOT_FOUND
    SEW_BAD_SIDE_NODES = _SMESH.SMESH_MeshEditor_SEW_BAD_SIDE_NODES
    SEW_VOLUMES_TO_SPLIT = _SMESH.SMESH_MeshEditor_SEW_VOLUMES_TO_SPLIT
    SEW_DIFF_NB_OF_ELEMENTS = _SMESH.SMESH_MeshEditor_SEW_DIFF_NB_OF_ELEMENTS
    SEW_TOPO_DIFF_SETS_OF_ELEMENTS = _SMESH.SMESH_MeshEditor_SEW_TOPO_DIFF_SETS_OF_ELEMENTS
    SEW_BAD_SIDE1_NODES = _SMESH.SMESH_MeshEditor_SEW_BAD_SIDE1_NODES
    SEW_BAD_SIDE2_NODES = _SMESH.SMESH_MeshEditor_SEW_BAD_SIDE2_NODES
    SEW_INTERNAL_ERROR = _SMESH.SMESH_MeshEditor_SEW_INTERNAL_ERROR
    BND_2DFROM3D = _SMESH.SMESH_MeshEditor_BND_2DFROM3D
    BND_1DFROM3D = _SMESH.SMESH_MeshEditor_BND_1DFROM3D
    BND_1DFROM2D = _SMESH.SMESH_MeshEditor_BND_1DFROM2D

    def __init__(self, *args):
        """
        __init__(SMESH_MeshEditor self, SMESH_Mesh theMesh) -> SMESH_MeshEditor

        :type theMesh: OCC.wrapper.SMESH.SMESH_Mesh

        """
        this = _SMESH.new_SMESH_MeshEditor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetMesh(self, *args):
        """
        GetMesh(SMESH_MeshEditor self) -> SMESH_Mesh

        :rtype: OCC.wrapper.SMESH.SMESH_Mesh

        """
        return _SMESH.SMESH_MeshEditor_GetMesh(self, *args)


    def GetMeshDS(self, *args):
        """
        GetMeshDS(SMESH_MeshEditor self) -> SMESHDS_Mesh

        :rtype: OCC.wrapper.SMESHDS.SMESHDS_Mesh

        """
        return _SMESH.SMESH_MeshEditor_GetMeshDS(self, *args)


    def GetLastCreatedNodes(self, *args):
        """
        GetLastCreatedNodes(SMESH_MeshEditor self) -> SMESH_SequenceOfElemPtr const &

        :rtype: OCC.wrapper.SMESH.SMESH_SequenceOfElemPtr

        """
        return _SMESH.SMESH_MeshEditor_GetLastCreatedNodes(self, *args)


    def GetLastCreatedElems(self, *args):
        """
        GetLastCreatedElems(SMESH_MeshEditor self) -> SMESH_SequenceOfElemPtr const &

        :rtype: OCC.wrapper.SMESH.SMESH_SequenceOfElemPtr

        """
        return _SMESH.SMESH_MeshEditor_GetLastCreatedElems(self, *args)


    def ClearLastCreated(self, *args):
        """ClearLastCreated(SMESH_MeshEditor self)"""
        return _SMESH.SMESH_MeshEditor_ClearLastCreated(self, *args)


    def GetError(self, *args):
        """
        GetError(SMESH_MeshEditor self) -> shared_ptr_SMESH_ComputeError

        :rtype: OCC.wrapper.SMESH.SMESH_ComputeErrorPtr

        """
        return _SMESH.SMESH_MeshEditor_GetError(self, *args)


    def AddElement(self, *args):
        """
        AddElement(SMESH_MeshEditor self, std::vector< SMDS_MeshNode const *,std::allocator< SMDS_MeshNode const * > > const & nodes, SMESH_MeshEditor::ElemFeatures const & features) -> SMDS_MeshElement
        AddElement(SMESH_MeshEditor self, std::vector< int,std::allocator< int > > const & nodeIDs, SMESH_MeshEditor::ElemFeatures const & features) -> SMDS_MeshElement

        rief Add element

        :type nodeIDs: const int &
        :type features: ElemFeatures
        :rtype: OCC.wrapper.SMDS.SMDS_MeshElement

        """
        return _SMESH.SMESH_MeshEditor_AddElement(self, *args)


    def Remove(self, *args):
        """
        Remove(SMESH_MeshEditor self, std::list< int,std::allocator< int > > const & theElemIDs, bool const isNodes) -> int

        :type theElemIDs: const int &
        :type isNodes: const bool
        :rtype: int

        """
        return _SMESH.SMESH_MeshEditor_Remove(self, *args)


    def Create0DElementsOnAllNodes(self, *args):
        """
        Create0DElementsOnAllNodes(SMESH_MeshEditor self, TIDSortedElemSet const & elements, TIDSortedElemSet & all0DElems, bool const duplicateElements)

        :type elements: TIDSortedElemSet
        :type all0DElems: TIDSortedElemSet
        :type duplicateElements: const bool

        """
        return _SMESH.SMESH_MeshEditor_Create0DElementsOnAllNodes(self, *args)


    def InverseDiag(self, *args):
        """
        InverseDiag(SMESH_MeshEditor self, SMDS_MeshElement theTria1, SMDS_MeshElement theTria2) -> bool
        InverseDiag(SMESH_MeshEditor self, SMDS_MeshNode theNode1, SMDS_MeshNode theNode2) -> bool

        :type theNode1: OCC.wrapper.SMDS.SMDS_MeshNode
        :type theNode2: OCC.wrapper.SMDS.SMDS_MeshNode
        :rtype: bool

        """
        return _SMESH.SMESH_MeshEditor_InverseDiag(self, *args)


    def DeleteDiag(self, *args):
        """
        DeleteDiag(SMESH_MeshEditor self, SMDS_MeshNode theNode1, SMDS_MeshNode theNode2) -> bool

        :type theNode1: OCC.wrapper.SMDS.SMDS_MeshNode
        :type theNode2: OCC.wrapper.SMDS.SMDS_MeshNode
        :rtype: bool

        """
        return _SMESH.SMESH_MeshEditor_DeleteDiag(self, *args)


    def Reorient(self, *args):
        """
        Reorient(SMESH_MeshEditor self, SMDS_MeshElement theElement) -> bool

        :type theElement: OCC.wrapper.SMDS.SMDS_MeshElement
        :rtype: bool

        """
        return _SMESH.SMESH_MeshEditor_Reorient(self, *args)


    def Reorient2D(self, *args):
        """
        Reorient2D(SMESH_MeshEditor self, TIDSortedElemSet & theFaces, gp_Dir theDirection, SMDS_MeshElement theFace) -> int

        :type theFaces: TIDSortedElemSet
        :type theDirection: OCC.wrapper.gp.gp_Dir
        :type theFace: OCC.wrapper.SMDS.SMDS_MeshElement
        :rtype: int

        """
        return _SMESH.SMESH_MeshEditor_Reorient2D(self, *args)


    def Reorient2DBy3D(self, *args):
        """
        Reorient2DBy3D(SMESH_MeshEditor self, TIDSortedElemSet & theFaces, TIDSortedElemSet & theVolumes, bool const theOutsideNormal) -> int

        :type theFaces: TIDSortedElemSet
        :type theVolumes: TIDSortedElemSet
        :type theOutsideNormal: const bool
        :rtype: int

        """
        return _SMESH.SMESH_MeshEditor_Reorient2DBy3D(self, *args)


    def TriToQuad(self, *args):
        """
        TriToQuad(SMESH_MeshEditor self, TIDSortedElemSet & theElems, SMESH::Controls::NumericalFunctorPtr theCriterion, double const theMaxAngle) -> bool

        rief Fuse neighbour triangles into quadrangles.
        \param theElems     - The triangles to be fused.
        \param theCriterion - Is used to choose a neighbour to fuse with.
        \param theMaxAngle  - Is a max angle between element normals at which fusion
        is still performed; theMaxAngle is measured in radians.
        @return bool - Success or not.

        :type theElems: TIDSortedElemSet
        :type theCriterion: NumericalFunctorPtr
        :type theMaxAngle: const double
        :rtype: bool

        """
        return _SMESH.SMESH_MeshEditor_TriToQuad(self, *args)


    def QuadToTri(self, *args):
        """
        QuadToTri(SMESH_MeshEditor self, TIDSortedElemSet & theElems, SMESH::Controls::NumericalFunctorPtr theCriterion) -> bool
        QuadToTri(SMESH_MeshEditor self, TIDSortedElemSet & theElems, bool const the13Diag) -> bool

        rief Split quadrangles into triangles.
        \param theElems  - The faces to be split.
        \param the13Diag - Is used to choose a diagonal for splitting.
        @return bool - Success or not.

        :type theElems: TIDSortedElemSet
        :type the13Diag: const bool
        :rtype: bool

        """
        return _SMESH.SMESH_MeshEditor_QuadToTri(self, *args)


    def QuadTo4Tri(self, *args):
        """
        QuadTo4Tri(SMESH_MeshEditor self, TIDSortedElemSet & theElems)

        rief Split each of given quadrangles into 4 triangles.
        \param theElems - The faces to be split. If empty all faces are split.

        :type theElems: TIDSortedElemSet

        """
        return _SMESH.SMESH_MeshEditor_QuadTo4Tri(self, *args)


    def BestSplit(self, *args):
        """
        BestSplit(SMESH_MeshEditor self, SMDS_MeshElement theQuad, SMESH::Controls::NumericalFunctorPtr theCriterion) -> int

        rief Find better diagonal for splitting.
        \param theQuad      - The face to find better splitting of.
        \param theCriterion - Is used to choose a diagonal for splitting.
        @return int - 1 for 1-3 diagonal, 2 for 2-4, -1 - for errors.

        :type theQuad: OCC.wrapper.SMDS.SMDS_MeshElement
        :type theCriterion: NumericalFunctorPtr
        :rtype: int

        """
        return _SMESH.SMESH_MeshEditor_BestSplit(self, *args)


    def SplitVolumes(self, *args):
        """
        SplitVolumes(SMESH_MeshEditor self, SMESH_MeshEditor::TFacetOfElem const & theElems, int const theMethodFlags)

        rief Split volumic elements into tetrahedra or prisms.
        If facet ID < 0, element is split into tetrahedra,
        else a hexahedron is split into prisms so that the given facet is
        split into triangles

        :type theElems: TFacetOfElem
        :type theMethodFlags: const int

        """
        return _SMESH.SMESH_MeshEditor_SplitVolumes(self, *args)


    def GetHexaFacetsToSplit(self, *args):
        """
        GetHexaFacetsToSplit(SMESH_MeshEditor self, TIDSortedElemSet & theHexas, gp_Ax1 theFacetNormal, SMESH_MeshEditor::TFacetOfElem & theFacets)

        rief For hexahedra that will be split into prisms, finds facets to
        split into triangles
        \param [in,out] theHexas - the hexahedra
        \param [in]     theFacetNormal - facet normal
        \param [out]    theFacets - the hexahedra and found facet IDs

        :type theHexas: TIDSortedElemSet
        :type theFacetNormal: OCC.wrapper.gp.gp_Ax1
        :type theFacets: TFacetOfElem

        """
        return _SMESH.SMESH_MeshEditor_GetHexaFacetsToSplit(self, *args)


    def SplitBiQuadraticIntoLinear(self, *args):
        """
        SplitBiQuadraticIntoLinear(SMESH_MeshEditor self, TIDSortedElemSet & theElems)

        rief Split bi-quadratic elements into linear ones without creation of additional nodes
        - bi-quadratic triangle will be split into 3 linear quadrangles;
        - bi-quadratic quadrangle will be split into 4 linear quadrangles;
        - tri-quadratic hexahedron will be split into 8 linear hexahedra;
        Quadratic elements of lower dimension  adjacent to the split bi-quadratic element
        will be split in order to keep the mesh conformal.
        \param elems - elements to split

        :type theElems: TIDSortedElemSet

        """
        return _SMESH.SMESH_MeshEditor_SplitBiQuadraticIntoLinear(self, *args)


    def Smooth(self, *args):
        """
        Smooth(SMESH_MeshEditor self, TIDSortedElemSet & theElements, std::set< SMDS_MeshNode const *,std::less< SMDS_MeshNode const * >,std::allocator< SMDS_MeshNode const * > > & theFixedNodes, SMESH_MeshEditor::SmoothMethod const theSmoothMethod, int const theNbIterations, double theTgtAspectRatio=1.0, bool const the2D=True)

        :type theElements: TIDSortedElemSet
        :type theFixedNodes: int &
        :type theSmoothMethod: SmoothMethod
        :type theNbIterations: const int
        :type theTgtAspectRatio: double
        :type the2D: const bool

        """
        return _SMESH.SMESH_MeshEditor_Smooth(self, *args)


    def ExtrusionAlongTrack(self, *args):
        """
        ExtrusionAlongTrack(SMESH_MeshEditor self, TIDSortedElemSet * theElements, SMESH_Mesh theTrackMesh, shared_ptr_SMDS_Iterator_SMDS_MeshElement theTrackIterator, SMDS_MeshNode theNodeStart, std::list< double,std::allocator< double > > & theAngles, bool const theAngleVariation, std::list< double,std::allocator< double > > & theScales, bool const theScaleVariation, gp_Pnt theRefPoint, bool const theMakeGroups) -> SMESH_MeshEditor::Extrusion_Error

        :type theElements: TIDSortedElemSet [2]
        :type theTrackMesh: OCC.wrapper.SMESH.SMESH_Mesh
        :type theTrackIterator: OCC.wrapper.SMDS.SMDS_ElemIteratorPtr
        :type theNodeStart: OCC.wrapper.SMDS.SMDS_MeshNode
        :type theAngles: int &
        :type theAngleVariation: const bool
        :type theScales: int &
        :type theScaleVariation: const bool
        :type theRefPoint: OCC.wrapper.gp.gp_Pnt
        :type theMakeGroups: const bool
        :rtype: Extrusion_Error

        """
        return _SMESH.SMESH_MeshEditor_ExtrusionAlongTrack(self, *args)


    def FindCoincidentNodes(self, *args):
        """
        FindCoincidentNodes(SMESH_MeshEditor self, TIDSortedNodeSet & theNodes, double const theTolerance, SMESH_MeshEditor::TListOfListOfNodes & theGroupsOfNodes, bool theSeparateCornersAndMedium)

        :type theNodes: TIDSortedNodeSet
        :type theTolerance: const double
        :type theGroupsOfNodes: TListOfListOfNodes
        :type theSeparateCornersAndMedium: bool

        """
        return _SMESH.SMESH_MeshEditor_FindCoincidentNodes(self, *args)


    def MergeNodes(self, *args):
        """
        MergeNodes(SMESH_MeshEditor self, SMESH_MeshEditor::TListOfListOfNodes & theNodeGroups, bool const theAvoidMakingHoles=False)

        :type theNodeGroups: TListOfListOfNodes
        :type theAvoidMakingHoles: const bool

        """
        return _SMESH.SMESH_MeshEditor_MergeNodes(self, *args)


    def FindEqualElements(self, *args):
        """
        FindEqualElements(SMESH_MeshEditor self, TIDSortedElemSet & theElements, SMESH_MeshEditor::TListOfListOfElementsID & theGroupsOfElementsID)

        :type theElements: TIDSortedElemSet
        :type theGroupsOfElementsID: TListOfListOfElementsID

        """
        return _SMESH.SMESH_MeshEditor_FindEqualElements(self, *args)


    def MergeElements(self, *args):
        """
        MergeElements(SMESH_MeshEditor self, SMESH_MeshEditor::TListOfListOfElementsID & theGroupsOfElementsID)

        :type theGroupsOfElementsID: TListOfListOfElementsID

        """
        return _SMESH.SMESH_MeshEditor_MergeElements(self, *args)


    def MergeEqualElements(self, *args):
        """MergeEqualElements(SMESH_MeshEditor self)"""
        return _SMESH.SMESH_MeshEditor_MergeEqualElements(self, *args)


    def SimplifyFace(self, *args):
        """
        SimplifyFace(SMESH_MeshEditor self, std::vector< SMDS_MeshNode const *,std::allocator< SMDS_MeshNode const * > > const & faceNodes, std::vector< SMDS_MeshNode const *,std::allocator< SMDS_MeshNode const * > > & poly_nodes, std::vector< int,std::allocator< int > > & quantities) -> int

        :type faceNodes: const int &
        :type poly_nodes: int &
        :type quantities: int &
        :rtype: int

        """
        return _SMESH.SMESH_MeshEditor_SimplifyFace(self, *args)


    def CheckFreeBorderNodes(*args):
        """
        CheckFreeBorderNodes(SMDS_MeshNode theNode1, SMDS_MeshNode theNode2, SMDS_MeshNode theNode3=None) -> bool

        :type theNode1: OCC.wrapper.SMDS.SMDS_MeshNode
        :type theNode2: OCC.wrapper.SMDS.SMDS_MeshNode
        :type theNode3: OCC.wrapper.SMDS.SMDS_MeshNode
        :rtype: bool

        """
        return _SMESH.SMESH_MeshEditor_CheckFreeBorderNodes(*args)

    CheckFreeBorderNodes = staticmethod(CheckFreeBorderNodes)

    def FindFreeBorder(*args):
        """
        FindFreeBorder(SMDS_MeshNode theFirstNode, SMDS_MeshNode theSecondNode, SMDS_MeshNode theLastNode, std::list< SMDS_MeshNode const *,std::allocator< SMDS_MeshNode const * > > & theNodes, std::list< SMDS_MeshElement const *,std::allocator< SMDS_MeshElement const * > > & theFaces) -> bool

        :type theFirstNode: OCC.wrapper.SMDS.SMDS_MeshNode
        :type theSecondNode: OCC.wrapper.SMDS.SMDS_MeshNode
        :type theLastNode: OCC.wrapper.SMDS.SMDS_MeshNode
        :type theNodes: int &
        :type theFaces: int &
        :rtype: bool

        """
        return _SMESH.SMESH_MeshEditor_FindFreeBorder(*args)

    FindFreeBorder = staticmethod(FindFreeBorder)

    def SewFreeBorder(self, *args):
        """
        SewFreeBorder(SMESH_MeshEditor self, SMDS_MeshNode theBorderFirstNode, SMDS_MeshNode theBorderSecondNode, SMDS_MeshNode theBorderLastNode, SMDS_MeshNode theSide2FirstNode, SMDS_MeshNode theSide2SecondNode, SMDS_MeshNode theSide2ThirdNode=None, bool const theSide2IsFreeBorder=True, bool const toCreatePolygons=False, bool const toCreatePolyedrs=False) -> SMESH_MeshEditor::Sew_Error

        :type theBorderFirstNode: OCC.wrapper.SMDS.SMDS_MeshNode
        :type theBorderSecondNode: OCC.wrapper.SMDS.SMDS_MeshNode
        :type theBorderLastNode: OCC.wrapper.SMDS.SMDS_MeshNode
        :type theSide2FirstNode: OCC.wrapper.SMDS.SMDS_MeshNode
        :type theSide2SecondNode: OCC.wrapper.SMDS.SMDS_MeshNode
        :type theSide2ThirdNode: OCC.wrapper.SMDS.SMDS_MeshNode
        :type theSide2IsFreeBorder: const bool
        :type toCreatePolygons: const bool
        :type toCreatePolyedrs: const bool
        :rtype: Sew_Error

        """
        return _SMESH.SMESH_MeshEditor_SewFreeBorder(self, *args)


    def SewSideElements(self, *args):
        """
        SewSideElements(SMESH_MeshEditor self, TIDSortedElemSet & theSide1, TIDSortedElemSet & theSide2, SMDS_MeshNode theFirstNode1ToMerge, SMDS_MeshNode theFirstNode2ToMerge, SMDS_MeshNode theSecondNode1ToMerge, SMDS_MeshNode theSecondNode2ToMerge) -> SMESH_MeshEditor::Sew_Error

        :type theSide1: TIDSortedElemSet
        :type theSide2: TIDSortedElemSet
        :type theFirstNode1ToMerge: OCC.wrapper.SMDS.SMDS_MeshNode
        :type theFirstNode2ToMerge: OCC.wrapper.SMDS.SMDS_MeshNode
        :type theSecondNode1ToMerge: OCC.wrapper.SMDS.SMDS_MeshNode
        :type theSecondNode2ToMerge: OCC.wrapper.SMDS.SMDS_MeshNode
        :rtype: Sew_Error

        """
        return _SMESH.SMESH_MeshEditor_SewSideElements(self, *args)


    def InsertNodesIntoLink(self, *args):
        """
        InsertNodesIntoLink(SMESH_MeshEditor self, SMDS_MeshElement theFace, SMDS_MeshNode theBetweenNode1, SMDS_MeshNode theBetweenNode2, std::list< SMDS_MeshNode const *,std::allocator< SMDS_MeshNode const * > > & theNodesToInsert, bool const toCreatePoly=False)

        :type theFace: OCC.wrapper.SMDS.SMDS_MeshElement
        :type theBetweenNode1: OCC.wrapper.SMDS.SMDS_MeshNode
        :type theBetweenNode2: OCC.wrapper.SMDS.SMDS_MeshNode
        :type theNodesToInsert: int &
        :type toCreatePoly: const bool

        """
        return _SMESH.SMESH_MeshEditor_InsertNodesIntoLink(self, *args)


    def UpdateVolumes(self, *args):
        """
        UpdateVolumes(SMESH_MeshEditor self, SMDS_MeshNode theBetweenNode1, SMDS_MeshNode theBetweenNode2, std::list< SMDS_MeshNode const *,std::allocator< SMDS_MeshNode const * > > & theNodesToInsert)

        :type theBetweenNode1: OCC.wrapper.SMDS.SMDS_MeshNode
        :type theBetweenNode2: OCC.wrapper.SMDS.SMDS_MeshNode
        :type theNodesToInsert: int &

        """
        return _SMESH.SMESH_MeshEditor_UpdateVolumes(self, *args)


    def ConvertToQuadratic(self, *args):
        """
        ConvertToQuadratic(SMESH_MeshEditor self, bool const theForce3d, bool const theToBiQuad)
        ConvertToQuadratic(SMESH_MeshEditor self, bool const theForce3d, TIDSortedElemSet & theElements, bool const theToBiQuad)

        :type theForce3d: const bool
        :type theElements: TIDSortedElemSet
        :type theToBiQuad: const bool

        """
        return _SMESH.SMESH_MeshEditor_ConvertToQuadratic(self, *args)


    def ConvertFromQuadratic(self, *args):
        """
        ConvertFromQuadratic(SMESH_MeshEditor self) -> bool
        ConvertFromQuadratic(SMESH_MeshEditor self, TIDSortedElemSet & theElements)

        :type theElements: TIDSortedElemSet

        """
        return _SMESH.SMESH_MeshEditor_ConvertFromQuadratic(self, *args)


    def AddToSameGroups(*args):
        """
        AddToSameGroups(SMDS_MeshElement elemToAdd, SMDS_MeshElement elemInGroups, SMESHDS_Mesh aMesh)

        :type elemToAdd: OCC.wrapper.SMDS.SMDS_MeshElement
        :type elemInGroups: OCC.wrapper.SMDS.SMDS_MeshElement
        :type aMesh: OCC.wrapper.SMESHDS.SMESHDS_Mesh

        """
        return _SMESH.SMESH_MeshEditor_AddToSameGroups(*args)

    AddToSameGroups = staticmethod(AddToSameGroups)

    def RemoveElemFromGroups(*args):
        """
        RemoveElemFromGroups(SMDS_MeshElement element, SMESHDS_Mesh aMesh)

        :type element: OCC.wrapper.SMDS.SMDS_MeshElement
        :type aMesh: OCC.wrapper.SMESHDS.SMESHDS_Mesh

        """
        return _SMESH.SMESH_MeshEditor_RemoveElemFromGroups(*args)

    RemoveElemFromGroups = staticmethod(RemoveElemFromGroups)

    def ReplaceElemInGroups(*args):
        """
        ReplaceElemInGroups(SMDS_MeshElement elemToRm, SMDS_MeshElement elemToAdd, SMESHDS_Mesh aMesh)
        ReplaceElemInGroups(SMDS_MeshElement elemToRm, std::vector< SMDS_MeshElement const *,std::allocator< SMDS_MeshElement const * > > const & elemToAdd, SMESHDS_Mesh aMesh)

        :type elemToRm: OCC.wrapper.SMDS.SMDS_MeshElement
        :type elemToAdd: const int &
        :type aMesh: OCC.wrapper.SMESHDS.SMESHDS_Mesh

        """
        return _SMESH.SMESH_MeshEditor_ReplaceElemInGroups(*args)

    ReplaceElemInGroups = staticmethod(ReplaceElemInGroups)

    def GetLinkedNodes(*args):
        """
        GetLinkedNodes(SMDS_MeshNode node, TIDSortedElemSet & linkedNodes, SMDSAbs_ElementType type=SMDSAbs_All)

        rief Return nodes linked to the given one in elements of the type

        :type node: OCC.wrapper.SMDS.SMDS_MeshNode
        :type linkedNodes: TIDSortedElemSet
        :type type: OCC.wrapper.SMDSAbs.SMDSAbs_ElementType

        """
        return _SMESH.SMESH_MeshEditor_GetLinkedNodes(*args)

    GetLinkedNodes = staticmethod(GetLinkedNodes)

    def FindMatchingNodes(*args):
        """
        FindMatchingNodes(std::set< SMDS_MeshElement const *,std::less< SMDS_MeshElement const * >,std::allocator< SMDS_MeshElement const * > > & theSide1, std::set< SMDS_MeshElement const *,std::less< SMDS_MeshElement const * >,std::allocator< SMDS_MeshElement const * > > & theSide2, SMDS_MeshNode theFirstNode1, SMDS_MeshNode theFirstNode2, SMDS_MeshNode theSecondNode1, SMDS_MeshNode theSecondNode2, TNodeNodeMap & theNodeReplaceMap) -> SMESH_MeshEditor::Sew_Error

        rief Find corresponding nodes in two sets of faces 
        \param theSide1 - first face set
        \param theSide2 - second first face
        \param theFirstNode1 - a boundary node of set 1
        \param theFirstNode2 - a node of set 2 corresponding to theFirstNode1
        \param theSecondNode1 - a boundary node of set 1 linked with theFirstNode1
        \param theSecondNode2 - a node of set 2 corresponding to theSecondNode1
        \param nReplaceMap - output map of corresponding nodes
        @return Sew_Error  - is a success or not

        :type theSide1: int &
        :type theSide2: int &
        :type theFirstNode1: OCC.wrapper.SMDS.SMDS_MeshNode
        :type theFirstNode2: OCC.wrapper.SMDS.SMDS_MeshNode
        :type theSecondNode1: OCC.wrapper.SMDS.SMDS_MeshNode
        :type theSecondNode2: OCC.wrapper.SMDS.SMDS_MeshNode
        :type theNodeReplaceMap: TNodeNodeMap
        :rtype: Sew_Error

        """
        return _SMESH.SMESH_MeshEditor_FindMatchingNodes(*args)

    FindMatchingNodes = staticmethod(FindMatchingNodes)

    def IsMedium(*args):
        """
        IsMedium(SMDS_MeshNode node, SMDSAbs_ElementType const typeToCheck=SMDSAbs_All) -> bool

        rief Returns true if given node is medium
        \param n - node to check
        \param typeToCheck - type of elements containing the node to ask about node status
        @return bool - check result

        :type node: OCC.wrapper.SMDS.SMDS_MeshNode
        :type typeToCheck: OCC.wrapper.SMDSAbs.SMDSAbs_ElementType
        :rtype: bool

        """
        return _SMESH.SMESH_MeshEditor_IsMedium(*args)

    IsMedium = staticmethod(IsMedium)

    def FindShape(self, *args):
        """
        FindShape(SMESH_MeshEditor self, SMDS_MeshElement theElem) -> int

        :type theElem: OCC.wrapper.SMDS.SMDS_MeshElement
        :rtype: int

        """
        return _SMESH.SMESH_MeshEditor_FindShape(self, *args)


    def DoubleElements(self, *args):
        """
        DoubleElements(SMESH_MeshEditor self, TIDSortedElemSet const & theElements)

        :type theElements: TIDSortedElemSet

        """
        return _SMESH.SMESH_MeshEditor_DoubleElements(self, *args)


    def DoubleNodes(self, *args):
        """
        DoubleNodes(SMESH_MeshEditor self, std::list< int,std::allocator< int > > const & theListOfNodes, std::list< int,std::allocator< int > > const & theListOfModifiedElems) -> bool
        DoubleNodes(SMESH_MeshEditor self, TIDSortedElemSet const & theElems, TIDSortedElemSet const & theNodesNot, TIDSortedElemSet const & theAffectedElems) -> bool

        :type theElems: TIDSortedElemSet
        :type theNodesNot: TIDSortedElemSet
        :type theAffectedElems: TIDSortedElemSet
        :rtype: bool

        """
        return _SMESH.SMESH_MeshEditor_DoubleNodes(self, *args)


    def AffectedElemGroupsInRegion(self, *args):
        """
        AffectedElemGroupsInRegion(SMESH_MeshEditor self, TIDSortedElemSet const & theElems, TIDSortedElemSet const & theNodesNot, TopoDS_Shape theShape, TIDSortedElemSet & theAffectedElems) -> bool

        :type theElems: TIDSortedElemSet
        :type theNodesNot: TIDSortedElemSet
        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theAffectedElems: TIDSortedElemSet
        :rtype: bool

        """
        return _SMESH.SMESH_MeshEditor_AffectedElemGroupsInRegion(self, *args)


    def DoubleNodesInRegion(self, *args):
        """
        DoubleNodesInRegion(SMESH_MeshEditor self, TIDSortedElemSet const & theElems, TIDSortedElemSet const & theNodesNot, TopoDS_Shape theShape) -> bool

        :type theElems: TIDSortedElemSet
        :type theNodesNot: TIDSortedElemSet
        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: bool

        """
        return _SMESH.SMESH_MeshEditor_DoubleNodesInRegion(self, *args)


    def OrientedAngle(self, *args):
        """
        OrientedAngle(SMESH_MeshEditor self, gp_Pnt p0, gp_Pnt p1, gp_Pnt g1, gp_Pnt g2) -> double

        :type p0: OCC.wrapper.gp.gp_Pnt
        :type p1: OCC.wrapper.gp.gp_Pnt
        :type g1: OCC.wrapper.gp.gp_Pnt
        :type g2: OCC.wrapper.gp.gp_Pnt
        :rtype: double

        """
        return _SMESH.SMESH_MeshEditor_OrientedAngle(self, *args)


    def DoubleNodesOnGroupBoundaries(self, *args):
        """
        DoubleNodesOnGroupBoundaries(SMESH_MeshEditor self, std::vector< TIDSortedElemSet,std::allocator< TIDSortedElemSet > > const & theElems, bool createJointElems, bool onAllBoundaries) -> bool

        :type theElems: const int &
        :type createJointElems: bool
        :type onAllBoundaries: bool
        :rtype: bool

        """
        return _SMESH.SMESH_MeshEditor_DoubleNodesOnGroupBoundaries(self, *args)


    def CreateFlatElementsOnFacesGroups(self, *args):
        """
        CreateFlatElementsOnFacesGroups(SMESH_MeshEditor self, std::vector< TIDSortedElemSet,std::allocator< TIDSortedElemSet > > const & theElems) -> bool

        :type theElems: const int &
        :rtype: bool

        """
        return _SMESH.SMESH_MeshEditor_CreateFlatElementsOnFacesGroups(self, *args)


    def CreateHoleSkin(self, *args):
        """
        CreateHoleSkin(SMESH_MeshEditor self, double radius, TopoDS_Shape theShape, SMESH_NodeSearcher * theNodeSearcher, char const * groupName, std::vector< double,std::allocator< double > > & nodesCoords, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > & listOfListOfNodes)

        :type radius: double
        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theNodeSearcher: OCC.wrapper.SMESH.SMESH_NodeSearcher
        :type groupName: const char *
        :type nodesCoords: int &
        :type listOfListOfNodes: int &

        """
        return _SMESH.SMESH_MeshEditor_CreateHoleSkin(self, *args)


    def Make2DMeshFrom3D(self, *args):
        """
        Make2DMeshFrom3D(SMESH_MeshEditor self) -> bool

        rief Generated skin mesh (containing 2D cells) from 3D mesh
        The created 2D mesh elements based on nodes of free faces of boundary volumes
        @return TRUE if operation has been completed successfully, FALSE otherwise

        :rtype: bool

        """
        return _SMESH.SMESH_MeshEditor_Make2DMeshFrom3D(self, *args)


    def MakeBoundaryMesh(self, *args):
        """
        MakeBoundaryMesh(SMESH_MeshEditor self, TIDSortedElemSet const & elements, SMESH_MeshEditor::Bnd_Dimension dimension, SMESH_Group group=None, SMESH_Mesh targetMesh=None, bool toCopyElements=False, bool toCopyExistingBondary=False, bool toAddExistingBondary=False, bool aroundElements=False) -> int

        :type elements: TIDSortedElemSet
        :type dimension: OCC.wrapper.Bnd.Bnd_Dimension
        :type group: OCC.wrapper.SMESH.SMESH_Group
        :type targetMesh: OCC.wrapper.SMESH.SMESH_Mesh
        :type toCopyElements: bool
        :type toCopyExistingBondary: bool
        :type toAddExistingBondary: bool
        :type aroundElements: bool
        :rtype: int

        """
        return _SMESH.SMESH_MeshEditor_MakeBoundaryMesh(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_MeshEditor
SMESH_MeshEditor_swigregister = _SMESH.SMESH_MeshEditor_swigregister
SMESH_MeshEditor_swigregister(SMESH_MeshEditor)

def SMESH_MeshEditor_CheckFreeBorderNodes(*args):
    """
    SMESH_MeshEditor_CheckFreeBorderNodes(SMDS_MeshNode theNode1, SMDS_MeshNode theNode2, SMDS_MeshNode theNode3=None) -> bool

    :type theNode1: OCC.wrapper.SMDS.SMDS_MeshNode
    :type theNode2: OCC.wrapper.SMDS.SMDS_MeshNode
    :type theNode3: OCC.wrapper.SMDS.SMDS_MeshNode
    :rtype: bool

    """
    return _SMESH.SMESH_MeshEditor_CheckFreeBorderNodes(*args)

def SMESH_MeshEditor_FindFreeBorder(*args):
    """
    SMESH_MeshEditor_FindFreeBorder(SMDS_MeshNode theFirstNode, SMDS_MeshNode theSecondNode, SMDS_MeshNode theLastNode, std::list< SMDS_MeshNode const *,std::allocator< SMDS_MeshNode const * > > & theNodes, std::list< SMDS_MeshElement const *,std::allocator< SMDS_MeshElement const * > > & theFaces) -> bool

    :type theFirstNode: OCC.wrapper.SMDS.SMDS_MeshNode
    :type theSecondNode: OCC.wrapper.SMDS.SMDS_MeshNode
    :type theLastNode: OCC.wrapper.SMDS.SMDS_MeshNode
    :type theNodes: int &
    :type theFaces: int &
    :rtype: bool

    """
    return _SMESH.SMESH_MeshEditor_FindFreeBorder(*args)

def SMESH_MeshEditor_AddToSameGroups(*args):
    """
    SMESH_MeshEditor_AddToSameGroups(SMDS_MeshElement elemToAdd, SMDS_MeshElement elemInGroups, SMESHDS_Mesh aMesh)

    :type elemToAdd: OCC.wrapper.SMDS.SMDS_MeshElement
    :type elemInGroups: OCC.wrapper.SMDS.SMDS_MeshElement
    :type aMesh: OCC.wrapper.SMESHDS.SMESHDS_Mesh

    """
    return _SMESH.SMESH_MeshEditor_AddToSameGroups(*args)

def SMESH_MeshEditor_RemoveElemFromGroups(*args):
    """
    SMESH_MeshEditor_RemoveElemFromGroups(SMDS_MeshElement element, SMESHDS_Mesh aMesh)

    :type element: OCC.wrapper.SMDS.SMDS_MeshElement
    :type aMesh: OCC.wrapper.SMESHDS.SMESHDS_Mesh

    """
    return _SMESH.SMESH_MeshEditor_RemoveElemFromGroups(*args)

def SMESH_MeshEditor_ReplaceElemInGroups(*args):
    """
    ReplaceElemInGroups(SMDS_MeshElement elemToRm, SMDS_MeshElement elemToAdd, SMESHDS_Mesh aMesh)
    SMESH_MeshEditor_ReplaceElemInGroups(SMDS_MeshElement elemToRm, std::vector< SMDS_MeshElement const *,std::allocator< SMDS_MeshElement const * > > const & elemToAdd, SMESHDS_Mesh aMesh)

    :type elemToRm: OCC.wrapper.SMDS.SMDS_MeshElement
    :type elemToAdd: const int &
    :type aMesh: OCC.wrapper.SMESHDS.SMESHDS_Mesh

    """
    return _SMESH.SMESH_MeshEditor_ReplaceElemInGroups(*args)

def SMESH_MeshEditor_GetLinkedNodes(*args):
    """
    SMESH_MeshEditor_GetLinkedNodes(SMDS_MeshNode node, TIDSortedElemSet & linkedNodes, SMDSAbs_ElementType type=SMDSAbs_All)

    rief Return nodes linked to the given one in elements of the type

    :type node: OCC.wrapper.SMDS.SMDS_MeshNode
    :type linkedNodes: TIDSortedElemSet
    :type type: OCC.wrapper.SMDSAbs.SMDSAbs_ElementType

    """
    return _SMESH.SMESH_MeshEditor_GetLinkedNodes(*args)

def SMESH_MeshEditor_FindMatchingNodes(*args):
    """
    SMESH_MeshEditor_FindMatchingNodes(std::set< SMDS_MeshElement const *,std::less< SMDS_MeshElement const * >,std::allocator< SMDS_MeshElement const * > > & theSide1, std::set< SMDS_MeshElement const *,std::less< SMDS_MeshElement const * >,std::allocator< SMDS_MeshElement const * > > & theSide2, SMDS_MeshNode theFirstNode1, SMDS_MeshNode theFirstNode2, SMDS_MeshNode theSecondNode1, SMDS_MeshNode theSecondNode2, TNodeNodeMap & theNodeReplaceMap) -> SMESH_MeshEditor::Sew_Error

    rief Find corresponding nodes in two sets of faces 
    \param theSide1 - first face set
    \param theSide2 - second first face
    \param theFirstNode1 - a boundary node of set 1
    \param theFirstNode2 - a node of set 2 corresponding to theFirstNode1
    \param theSecondNode1 - a boundary node of set 1 linked with theFirstNode1
    \param theSecondNode2 - a node of set 2 corresponding to theSecondNode1
    \param nReplaceMap - output map of corresponding nodes
    @return Sew_Error  - is a success or not

    :type theSide1: int &
    :type theSide2: int &
    :type theFirstNode1: OCC.wrapper.SMDS.SMDS_MeshNode
    :type theFirstNode2: OCC.wrapper.SMDS.SMDS_MeshNode
    :type theSecondNode1: OCC.wrapper.SMDS.SMDS_MeshNode
    :type theSecondNode2: OCC.wrapper.SMDS.SMDS_MeshNode
    :type theNodeReplaceMap: TNodeNodeMap
    :rtype: Sew_Error

    """
    return _SMESH.SMESH_MeshEditor_FindMatchingNodes(*args)

def SMESH_MeshEditor_IsMedium(*args):
    """
    SMESH_MeshEditor_IsMedium(SMDS_MeshNode node, SMDSAbs_ElementType const typeToCheck=SMDSAbs_All) -> bool

    rief Returns true if given node is medium
    \param n - node to check
    \param typeToCheck - type of elements containing the node to ask about node status
    @return bool - check result

    :type node: OCC.wrapper.SMDS.SMDS_MeshNode
    :type typeToCheck: OCC.wrapper.SMDSAbs.SMDSAbs_ElementType
    :rtype: bool

    """
    return _SMESH.SMESH_MeshEditor_IsMedium(*args)

class SMESH_Block(math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ID_NONE = _SMESH.SMESH_Block_ID_NONE
    ID_V000 = _SMESH.SMESH_Block_ID_V000
    ID_V100 = _SMESH.SMESH_Block_ID_V100
    ID_V010 = _SMESH.SMESH_Block_ID_V010
    ID_V110 = _SMESH.SMESH_Block_ID_V110
    ID_V001 = _SMESH.SMESH_Block_ID_V001
    ID_V101 = _SMESH.SMESH_Block_ID_V101
    ID_V011 = _SMESH.SMESH_Block_ID_V011
    ID_V111 = _SMESH.SMESH_Block_ID_V111
    ID_Ex00 = _SMESH.SMESH_Block_ID_Ex00
    ID_Ex10 = _SMESH.SMESH_Block_ID_Ex10
    ID_Ex01 = _SMESH.SMESH_Block_ID_Ex01
    ID_Ex11 = _SMESH.SMESH_Block_ID_Ex11
    ID_E0y0 = _SMESH.SMESH_Block_ID_E0y0
    ID_E1y0 = _SMESH.SMESH_Block_ID_E1y0
    ID_E0y1 = _SMESH.SMESH_Block_ID_E0y1
    ID_E1y1 = _SMESH.SMESH_Block_ID_E1y1
    ID_E00z = _SMESH.SMESH_Block_ID_E00z
    ID_E10z = _SMESH.SMESH_Block_ID_E10z
    ID_E01z = _SMESH.SMESH_Block_ID_E01z
    ID_E11z = _SMESH.SMESH_Block_ID_E11z
    ID_Fxy0 = _SMESH.SMESH_Block_ID_Fxy0
    ID_Fxy1 = _SMESH.SMESH_Block_ID_Fxy1
    ID_Fx0z = _SMESH.SMESH_Block_ID_Fx0z
    ID_Fx1z = _SMESH.SMESH_Block_ID_Fx1z
    ID_F0yz = _SMESH.SMESH_Block_ID_F0yz
    ID_F1yz = _SMESH.SMESH_Block_ID_F1yz
    ID_Shell = _SMESH.SMESH_Block_ID_Shell
    ID_FirstV = _SMESH.SMESH_Block_ID_FirstV
    ID_FirstE = _SMESH.SMESH_Block_ID_FirstE
    ID_FirstF = _SMESH.SMESH_Block_ID_FirstF

    def NbVertices(*args):
        """
        NbVertices() -> int

        :rtype: int

        """
        return _SMESH.SMESH_Block_NbVertices(*args)

    NbVertices = staticmethod(NbVertices)

    def NbEdges(*args):
        """
        NbEdges() -> int

        :rtype: int

        """
        return _SMESH.SMESH_Block_NbEdges(*args)

    NbEdges = staticmethod(NbEdges)

    def NbFaces(*args):
        """
        NbFaces() -> int

        :rtype: int

        """
        return _SMESH.SMESH_Block_NbFaces(*args)

    NbFaces = staticmethod(NbFaces)

    def NbSubShapes(*args):
        """
        NbSubShapes() -> int

        :rtype: int

        """
        return _SMESH.SMESH_Block_NbSubShapes(*args)

    NbSubShapes = staticmethod(NbSubShapes)

    def IsVertexID(*args):
        """
        IsVertexID(int theShapeID) -> bool

        :type theShapeID: int
        :rtype: bool

        """
        return _SMESH.SMESH_Block_IsVertexID(*args)

    IsVertexID = staticmethod(IsVertexID)

    def IsEdgeID(*args):
        """
        IsEdgeID(int theShapeID) -> bool

        :type theShapeID: int
        :rtype: bool

        """
        return _SMESH.SMESH_Block_IsEdgeID(*args)

    IsEdgeID = staticmethod(IsEdgeID)

    def IsFaceID(*args):
        """
        IsFaceID(int theShapeID) -> bool

        :type theShapeID: int
        :rtype: bool

        """
        return _SMESH.SMESH_Block_IsFaceID(*args)

    IsFaceID = staticmethod(IsFaceID)

    def ShapeIndex(*args):
        """
        ShapeIndex(int theShapeID) -> int

        :type theShapeID: int
        :rtype: int

        """
        return _SMESH.SMESH_Block_ShapeIndex(*args)

    ShapeIndex = staticmethod(ShapeIndex)

    def GetFaceEdgesIDs(*args):
        """
        GetFaceEdgesIDs(int const faceID, std::vector< int,std::allocator< int > > & edgeVec)

        :type faceID: const int
        :type edgeVec: int &

        """
        return _SMESH.SMESH_Block_GetFaceEdgesIDs(*args)

    GetFaceEdgesIDs = staticmethod(GetFaceEdgesIDs)

    def GetEdgeVertexIDs(*args):
        """
        GetEdgeVertexIDs(int const edgeID, std::vector< int,std::allocator< int > > & vertexVec)

        :type edgeID: const int
        :type vertexVec: int &

        """
        return _SMESH.SMESH_Block_GetEdgeVertexIDs(*args)

    GetEdgeVertexIDs = staticmethod(GetEdgeVertexIDs)

    def GetCoordIndOnEdge(*args):
        """
        GetCoordIndOnEdge(int const theEdgeID) -> int

        :type theEdgeID: const int
        :rtype: int

        """
        return _SMESH.SMESH_Block_GetCoordIndOnEdge(*args)

    GetCoordIndOnEdge = staticmethod(GetCoordIndOnEdge)

    def GetShapeCoef(*args):
        """
        GetShapeCoef(int const theShapeID) -> double *

        :type theShapeID: const int
        :rtype: double *

        """
        return _SMESH.SMESH_Block_GetShapeCoef(*args)

    GetShapeCoef = staticmethod(GetShapeCoef)

    def GetShapeIDByParams(*args):
        """
        GetShapeIDByParams(gp_XYZ theParams) -> int

        :type theParams: OCC.wrapper.gp.gp_XYZ
        :rtype: int

        """
        return _SMESH.SMESH_Block_GetShapeIDByParams(*args)

    GetShapeIDByParams = staticmethod(GetShapeIDByParams)

    def DumpShapeID(*args):
        """
        DumpShapeID(int const theBlockShapeID, std::ostream & stream) -> std::ostream &

        :type theBlockShapeID: const int
        :type stream: ostream
        :rtype: ostream

        """
        return _SMESH.SMESH_Block_DumpShapeID(*args)

    DumpShapeID = staticmethod(DumpShapeID)

    def __init__(self, *args):
        """__init__(SMESH_Block self) -> SMESH_Block"""
        this = _SMESH.new_SMESH_Block(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def LoadBlockShapes(self, *args):
        """
        LoadBlockShapes(SMESH_Block self, TopoDS_Shell theShell, TopoDS_Vertex theVertex000, TopoDS_Vertex theVertex001, NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher theShapeIDMap) -> bool
        LoadBlockShapes(SMESH_Block self, NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher theShapeIDMap) -> bool

        :type theShapeIDMap: OCC.wrapper.TopTools.TopTools_IndexedMapOfOrientedShape
        :rtype: bool

        """
        return _SMESH.SMESH_Block_LoadBlockShapes(self, *args)


    def LoadMeshBlock(self, *args):
        """
        LoadMeshBlock(SMESH_Block self, SMDS_MeshVolume theVolume, int const theNode000Index, int const theNode001Index, std::vector< SMDS_MeshNode const *,std::allocator< SMDS_MeshNode const * > > & theOrderedNodes) -> bool

        :type theVolume: OCC.wrapper.SMDS.SMDS_MeshVolume
        :type theNode000Index: const int
        :type theNode001Index: const int
        :type theOrderedNodes: int &
        :rtype: bool

        """
        return _SMESH.SMESH_Block_LoadMeshBlock(self, *args)


    def LoadFace(self, *args):
        """
        LoadFace(SMESH_Block self, TopoDS_Face theFace, int const theFaceID, NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher theShapeIDMap) -> bool

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theFaceID: const int
        :type theShapeIDMap: OCC.wrapper.TopTools.TopTools_IndexedMapOfOrientedShape
        :rtype: bool

        """
        return _SMESH.SMESH_Block_LoadFace(self, *args)


    def Insert(*args):
        """
        Insert(TopoDS_Shape theShape, int const theShapeID, NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher theShapeIDMap) -> bool

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theShapeID: const int
        :type theShapeIDMap: OCC.wrapper.TopTools.TopTools_IndexedMapOfOrientedShape
        :rtype: bool

        """
        return _SMESH.SMESH_Block_Insert(*args)

    Insert = staticmethod(Insert)

    def FindBlockShapes(*args):
        """
        FindBlockShapes(TopoDS_Shell theShell, TopoDS_Vertex theVertex000, TopoDS_Vertex theVertex001, NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher theShapeIDMap) -> bool

        :type theShell: OCC.wrapper.TopoDS.TopoDS_Shell
        :type theVertex000: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type theVertex001: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type theShapeIDMap: OCC.wrapper.TopTools.TopTools_IndexedMapOfOrientedShape
        :rtype: bool

        """
        return _SMESH.SMESH_Block_FindBlockShapes(*args)

    FindBlockShapes = staticmethod(FindBlockShapes)

    def VertexPoint(self, *args):
        """
        VertexPoint(SMESH_Block self, int const theVertexID, gp_XYZ thePoint) -> bool

        :type theVertexID: const int
        :type thePoint: OCC.wrapper.gp.gp_XYZ
        :rtype: bool

        """
        return _SMESH.SMESH_Block_VertexPoint(self, *args)


    def EdgePoint(self, *args):
        """
        EdgePoint(SMESH_Block self, int const theEdgeID, gp_XYZ theParams, gp_XYZ thePoint) -> bool

        :type theEdgeID: const int
        :type theParams: OCC.wrapper.gp.gp_XYZ
        :type thePoint: OCC.wrapper.gp.gp_XYZ
        :rtype: bool

        """
        return _SMESH.SMESH_Block_EdgePoint(self, *args)


    def EdgeU(self, *args):
        """
        EdgeU(SMESH_Block self, int const theEdgeID, gp_XYZ theParams) -> bool

        :type theEdgeID: const int
        :type theParams: OCC.wrapper.gp.gp_XYZ
        :type theU: double &
        :rtype: bool

        """
        return _SMESH.SMESH_Block_EdgeU(self, *args)


    def FacePoint(self, *args):
        """
        FacePoint(SMESH_Block self, int const theFaceID, gp_XYZ theParams, gp_XYZ thePoint) -> bool

        :type theFaceID: const int
        :type theParams: OCC.wrapper.gp.gp_XYZ
        :type thePoint: OCC.wrapper.gp.gp_XYZ
        :rtype: bool

        """
        return _SMESH.SMESH_Block_FacePoint(self, *args)


    def FaceUV(self, *args):
        """
        FaceUV(SMESH_Block self, int const theFaceID, gp_XYZ theParams, gp_XY theUV) -> bool

        :type theFaceID: const int
        :type theParams: OCC.wrapper.gp.gp_XYZ
        :type theUV: OCC.wrapper.gp.gp_XY
        :rtype: bool

        """
        return _SMESH.SMESH_Block_FaceUV(self, *args)


    def ShellPoint(*args):
        """
        ShellPoint(gp_XYZ theParams, gp_XYZ thePoint) -> bool
        ShellPoint(gp_XYZ theParams, std::vector< gp_XYZ,std::allocator< gp_XYZ > > const & thePointOnShape, gp_XYZ thePoint) -> bool

        :type theParams: OCC.wrapper.gp.gp_XYZ
        :type thePointOnShape: const int &
        :type thePoint: OCC.wrapper.gp.gp_XYZ
        :rtype: bool

        """
        return _SMESH.SMESH_Block_ShellPoint(*args)

    ShellPoint = staticmethod(ShellPoint)

    def ComputeParameters(self, *args):
        """
        ComputeParameters(SMESH_Block self, gp_Pnt thePoint, gp_XYZ theParams, int const theShapeID, gp_XYZ theParamsHint) -> bool

        :type thePoint: OCC.wrapper.gp.gp_Pnt
        :type theParams: OCC.wrapper.gp.gp_XYZ
        :type theShapeID: const int
        :type theParamsHint: OCC.wrapper.gp.gp_XYZ
        :rtype: bool

        """
        return _SMESH.SMESH_Block_ComputeParameters(self, *args)


    def VertexParameters(self, *args):
        """
        VertexParameters(SMESH_Block self, int const theVertexID, gp_XYZ theParams) -> bool

        :type theVertexID: const int
        :type theParams: OCC.wrapper.gp.gp_XYZ
        :rtype: bool

        """
        return _SMESH.SMESH_Block_VertexParameters(self, *args)


    def EdgeParameters(self, *args):
        """
        EdgeParameters(SMESH_Block self, int const theEdgeID, double const theU, gp_XYZ theParams) -> bool

        :type theEdgeID: const int
        :type theU: const double
        :type theParams: OCC.wrapper.gp.gp_XYZ
        :rtype: bool

        """
        return _SMESH.SMESH_Block_EdgeParameters(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(SMESH_Block self, double const tol)

        :type tol: const double

        """
        return _SMESH.SMESH_Block_SetTolerance(self, *args)


    def GetTolerance(self, *args):
        """
        GetTolerance(SMESH_Block self) -> double

        :rtype: double

        """
        return _SMESH.SMESH_Block_GetTolerance(self, *args)


    def IsToleranceReached(self, *args):
        """
        IsToleranceReached(SMESH_Block self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_Block_IsToleranceReached(self, *args)


    def DistanceReached(self, *args):
        """
        DistanceReached(SMESH_Block self) -> double

        :rtype: double

        """
        return _SMESH.SMESH_Block_DistanceReached(self, *args)


    def IsForwardEdge(*args):
        """
        IsForwardEdge(TopoDS_Edge theEdge, NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher theShapeIDMap) -> bool

        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theShapeIDMap: OCC.wrapper.TopTools.TopTools_IndexedMapOfOrientedShape
        :rtype: bool

        """
        return _SMESH.SMESH_Block_IsForwardEdge(*args)

    IsForwardEdge = staticmethod(IsForwardEdge)

    def GetOrderedEdges(*args):
        """
        GetOrderedEdges(TopoDS_Face theFace, std::list< TopoDS_Edge,std::allocator< TopoDS_Edge > > & theEdges, std::list< int,std::allocator< int > > & theNbEdgesInWires, TopoDS_Vertex theFirstVertex, bool const theShapeAnalysisAlgo=False) -> int

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theEdges: int &
        :type theNbEdgesInWires: int &
        :type theFirstVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type theShapeAnalysisAlgo: const bool
        :rtype: int

        """
        return _SMESH.SMESH_Block_GetOrderedEdges(*args)

    GetOrderedEdges = staticmethod(GetOrderedEdges)

    def NbVariables(self, *args):
        """
        NbVariables(SMESH_Block self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SMESH.SMESH_Block_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(SMESH_Block self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SMESH.SMESH_Block_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(SMESH_Block self, math_Vector X, math_Vector F) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.SMESH_Block_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(SMESH_Block self, math_Vector X, math_Matrix D) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.SMESH_Block_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(SMESH_Block self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.SMESH_Block_Values(self, *args)


    def GetStateNumber(self, *args):
        """
        GetStateNumber(SMESH_Block self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SMESH.SMESH_Block_GetStateNumber(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_Block
SMESH_Block_swigregister = _SMESH.SMESH_Block_swigregister
SMESH_Block_swigregister(SMESH_Block)

def SMESH_Block_NbVertices(*args):
    """
    SMESH_Block_NbVertices() -> int

    :rtype: int

    """
    return _SMESH.SMESH_Block_NbVertices(*args)

def SMESH_Block_NbEdges(*args):
    """
    SMESH_Block_NbEdges() -> int

    :rtype: int

    """
    return _SMESH.SMESH_Block_NbEdges(*args)

def SMESH_Block_NbFaces(*args):
    """
    SMESH_Block_NbFaces() -> int

    :rtype: int

    """
    return _SMESH.SMESH_Block_NbFaces(*args)

def SMESH_Block_NbSubShapes(*args):
    """
    SMESH_Block_NbSubShapes() -> int

    :rtype: int

    """
    return _SMESH.SMESH_Block_NbSubShapes(*args)

def SMESH_Block_IsVertexID(*args):
    """
    SMESH_Block_IsVertexID(int theShapeID) -> bool

    :type theShapeID: int
    :rtype: bool

    """
    return _SMESH.SMESH_Block_IsVertexID(*args)

def SMESH_Block_IsEdgeID(*args):
    """
    SMESH_Block_IsEdgeID(int theShapeID) -> bool

    :type theShapeID: int
    :rtype: bool

    """
    return _SMESH.SMESH_Block_IsEdgeID(*args)

def SMESH_Block_IsFaceID(*args):
    """
    SMESH_Block_IsFaceID(int theShapeID) -> bool

    :type theShapeID: int
    :rtype: bool

    """
    return _SMESH.SMESH_Block_IsFaceID(*args)

def SMESH_Block_ShapeIndex(*args):
    """
    SMESH_Block_ShapeIndex(int theShapeID) -> int

    :type theShapeID: int
    :rtype: int

    """
    return _SMESH.SMESH_Block_ShapeIndex(*args)

def SMESH_Block_GetFaceEdgesIDs(*args):
    """
    SMESH_Block_GetFaceEdgesIDs(int const faceID, std::vector< int,std::allocator< int > > & edgeVec)

    :type faceID: const int
    :type edgeVec: int &

    """
    return _SMESH.SMESH_Block_GetFaceEdgesIDs(*args)

def SMESH_Block_GetEdgeVertexIDs(*args):
    """
    SMESH_Block_GetEdgeVertexIDs(int const edgeID, std::vector< int,std::allocator< int > > & vertexVec)

    :type edgeID: const int
    :type vertexVec: int &

    """
    return _SMESH.SMESH_Block_GetEdgeVertexIDs(*args)

def SMESH_Block_GetCoordIndOnEdge(*args):
    """
    SMESH_Block_GetCoordIndOnEdge(int const theEdgeID) -> int

    :type theEdgeID: const int
    :rtype: int

    """
    return _SMESH.SMESH_Block_GetCoordIndOnEdge(*args)

def SMESH_Block_GetShapeCoef(*args):
    """
    SMESH_Block_GetShapeCoef(int const theShapeID) -> double *

    :type theShapeID: const int
    :rtype: double *

    """
    return _SMESH.SMESH_Block_GetShapeCoef(*args)

def SMESH_Block_GetShapeIDByParams(*args):
    """
    SMESH_Block_GetShapeIDByParams(gp_XYZ theParams) -> int

    :type theParams: OCC.wrapper.gp.gp_XYZ
    :rtype: int

    """
    return _SMESH.SMESH_Block_GetShapeIDByParams(*args)

def SMESH_Block_DumpShapeID(*args):
    """
    SMESH_Block_DumpShapeID(int const theBlockShapeID, std::ostream & stream) -> std::ostream &

    :type theBlockShapeID: const int
    :type stream: ostream
    :rtype: ostream

    """
    return _SMESH.SMESH_Block_DumpShapeID(*args)

def SMESH_Block_Insert(*args):
    """
    SMESH_Block_Insert(TopoDS_Shape theShape, int const theShapeID, NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher theShapeIDMap) -> bool

    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theShapeID: const int
    :type theShapeIDMap: OCC.wrapper.TopTools.TopTools_IndexedMapOfOrientedShape
    :rtype: bool

    """
    return _SMESH.SMESH_Block_Insert(*args)

def SMESH_Block_FindBlockShapes(*args):
    """
    SMESH_Block_FindBlockShapes(TopoDS_Shell theShell, TopoDS_Vertex theVertex000, TopoDS_Vertex theVertex001, NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher theShapeIDMap) -> bool

    :type theShell: OCC.wrapper.TopoDS.TopoDS_Shell
    :type theVertex000: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type theVertex001: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type theShapeIDMap: OCC.wrapper.TopTools.TopTools_IndexedMapOfOrientedShape
    :rtype: bool

    """
    return _SMESH.SMESH_Block_FindBlockShapes(*args)

def SMESH_Block_ShellPoint(*args):
    """
    ShellPoint(gp_XYZ theParams, gp_XYZ thePoint) -> bool
    SMESH_Block_ShellPoint(gp_XYZ theParams, std::vector< gp_XYZ,std::allocator< gp_XYZ > > const & thePointOnShape, gp_XYZ thePoint) -> bool

    :type theParams: OCC.wrapper.gp.gp_XYZ
    :type thePointOnShape: const int &
    :type thePoint: OCC.wrapper.gp.gp_XYZ
    :rtype: bool

    """
    return _SMESH.SMESH_Block_ShellPoint(*args)

def SMESH_Block_IsForwardEdge(*args):
    """
    SMESH_Block_IsForwardEdge(TopoDS_Edge theEdge, NCollection_IndexedMap_TopoDS_Shape_TopTools_OrientedShapeMapHasher theShapeIDMap) -> bool

    :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
    :type theShapeIDMap: OCC.wrapper.TopTools.TopTools_IndexedMapOfOrientedShape
    :rtype: bool

    """
    return _SMESH.SMESH_Block_IsForwardEdge(*args)

def SMESH_Block_GetOrderedEdges(*args):
    """
    SMESH_Block_GetOrderedEdges(TopoDS_Face theFace, std::list< TopoDS_Edge,std::allocator< TopoDS_Edge > > & theEdges, std::list< int,std::allocator< int > > & theNbEdgesInWires, TopoDS_Vertex theFirstVertex, bool const theShapeAnalysisAlgo=False) -> int

    :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type theEdges: int &
    :type theNbEdgesInWires: int &
    :type theFirstVertex: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type theShapeAnalysisAlgo: const bool
    :rtype: int

    """
    return _SMESH.SMESH_Block_GetOrderedEdges(*args)

class SMESH_3D_Algo(SMESH_Algo):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _SMESH.delete_SMESH_3D_Algo
SMESH_3D_Algo_swigregister = _SMESH.SMESH_3D_Algo_swigregister
SMESH_3D_Algo_swigregister(SMESH_3D_Algo)

class shared_ptr_SMESH_VisualObj(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _SMESH.new_shared_ptr_SMESH_VisualObj(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __deref__(self):
        return _SMESH.shared_ptr_SMESH_VisualObj___deref__(self)

    def __ref__(self):
        return _SMESH.shared_ptr_SMESH_VisualObj___ref__(self)
    __swig_destroy__ = _SMESH.delete_shared_ptr_SMESH_VisualObj

    def Update(self, *args):
        """
        Update(shared_ptr_SMESH_VisualObj self, int theIsClear=True) -> bool

        :type theIsClear: int
        :rtype: bool

        """
        return _SMESH.shared_ptr_SMESH_VisualObj_Update(self, *args)


    def NulData(self, *args):
        """
        NulData(shared_ptr_SMESH_VisualObj self) -> bool

        :rtype: bool

        """
        return _SMESH.shared_ptr_SMESH_VisualObj_NulData(self, *args)


    def UpdateFunctor(self, *args):
        """
        UpdateFunctor(shared_ptr_SMESH_VisualObj self, SMESH::Controls::FunctorPtr const & theFunctor)

        :type theFunctor: FunctorPtr

        """
        return _SMESH.shared_ptr_SMESH_VisualObj_UpdateFunctor(self, *args)


    def GetElemDimension(self, *args):
        """
        GetElemDimension(shared_ptr_SMESH_VisualObj self, int const theObjId) -> int

        :type theObjId: const int
        :rtype: int

        """
        return _SMESH.shared_ptr_SMESH_VisualObj_GetElemDimension(self, *args)


    def GetNbEntities(self, *args):
        """
        GetNbEntities(shared_ptr_SMESH_VisualObj self, SMDSAbs_ElementType const theType) -> int

        :type theType: OCC.wrapper.SMDSAbs.SMDSAbs_ElementType
        :rtype: int

        """
        return _SMESH.shared_ptr_SMESH_VisualObj_GetNbEntities(self, *args)


    def GetMesh(self, *args):
        """
        GetMesh(shared_ptr_SMESH_VisualObj self) -> SMDS_Mesh

        :rtype: OCC.wrapper.SMDS.SMDS_Mesh

        """
        return _SMESH.shared_ptr_SMESH_VisualObj_GetMesh(self, *args)


    def GetMeshServer(self, *args):
        """
        GetMeshServer(shared_ptr_SMESH_VisualObj self) -> SMESH::SMESH_Mesh_ptr

        :rtype: OCC.wrapper.SMESH.SMESH_Mesh_ptr

        """
        return _SMESH.shared_ptr_SMESH_VisualObj_GetMeshServer(self, *args)


    def GetEdgeNodes(self, *args):
        """
        GetEdgeNodes(shared_ptr_SMESH_VisualObj self, int const theElemId, int const theEdgeNum) -> bool

        :type theElemId: const int
        :type theEdgeNum: const int
        :type theNodeId1: int &
        :type theNodeId2: int &
        :rtype: bool

        """
        return _SMESH.shared_ptr_SMESH_VisualObj_GetEdgeNodes(self, *args)


    def IsValid(self, *args):
        """
        IsValid(shared_ptr_SMESH_VisualObj self) -> bool

        :rtype: bool

        """
        return _SMESH.shared_ptr_SMESH_VisualObj_IsValid(self, *args)


    def GetUnstructuredGrid(self, *args):
        """
        GetUnstructuredGrid(shared_ptr_SMESH_VisualObj self) -> vtkUnstructuredGrid *

        :rtype: vtkUnstructuredGrid

        """
        return _SMESH.shared_ptr_SMESH_VisualObj_GetUnstructuredGrid(self, *args)


    def GetNodeObjId(self, *args):
        """
        GetNodeObjId(shared_ptr_SMESH_VisualObj self, int theVTKID) -> vtkIdType

        :type theVTKID: int
        :rtype: vtkIdType

        """
        return _SMESH.shared_ptr_SMESH_VisualObj_GetNodeObjId(self, *args)


    def GetNodeVTKId(self, *args):
        """
        GetNodeVTKId(shared_ptr_SMESH_VisualObj self, int theObjID) -> vtkIdType

        :type theObjID: int
        :rtype: vtkIdType

        """
        return _SMESH.shared_ptr_SMESH_VisualObj_GetNodeVTKId(self, *args)


    def GetElemObjId(self, *args):
        """
        GetElemObjId(shared_ptr_SMESH_VisualObj self, int theVTKID) -> vtkIdType

        :type theVTKID: int
        :rtype: vtkIdType

        """
        return _SMESH.shared_ptr_SMESH_VisualObj_GetElemObjId(self, *args)


    def GetElemVTKId(self, *args):
        """
        GetElemVTKId(shared_ptr_SMESH_VisualObj self, int theObjID) -> vtkIdType

        :type theObjID: int
        :rtype: vtkIdType

        """
        return _SMESH.shared_ptr_SMESH_VisualObj_GetElemVTKId(self, *args)


    def ClearEntitiesFlags(self, *args):
        """ClearEntitiesFlags(shared_ptr_SMESH_VisualObj self)"""
        return _SMESH.shared_ptr_SMESH_VisualObj_ClearEntitiesFlags(self, *args)


    def GetEntitiesFlag(self, *args):
        """
        GetEntitiesFlag(shared_ptr_SMESH_VisualObj self) -> bool

        :rtype: bool

        """
        return _SMESH.shared_ptr_SMESH_VisualObj_GetEntitiesFlag(self, *args)


    def GetEntitiesState(self, *args):
        """
        GetEntitiesState(shared_ptr_SMESH_VisualObj self) -> unsigned int

        :rtype: unsigned int

        """
        return _SMESH.shared_ptr_SMESH_VisualObj_GetEntitiesState(self, *args)

shared_ptr_SMESH_VisualObj_swigregister = _SMESH.shared_ptr_SMESH_VisualObj_swigregister
shared_ptr_SMESH_VisualObj_swigregister(shared_ptr_SMESH_VisualObj)


try:
	TVisualObjPtr = shared_ptr_SMESH_VisualObj
except NameError:
	pass # does not exist, probably ignored

class SMESH_SVTKActor(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def New(*args):
        """
        New() -> SMESH_SVTKActor

        :rtype: OCC.wrapper.SMESH.SMESH_SVTKActor

        """
        return _SMESH.SMESH_SVTKActor_New(*args)

    New = staticmethod(New)

    def IsTypeOf(*args):
        """
        IsTypeOf(char const * type) -> vtkTypeBool

        :type type: const char *
        :rtype: vtkTypeBool

        """
        return _SMESH.SMESH_SVTKActor_IsTypeOf(*args)

    IsTypeOf = staticmethod(IsTypeOf)

    def IsA(self, *args):
        """
        IsA(SMESH_SVTKActor self, char const * type) -> vtkTypeBool

        :type type: const char *
        :rtype: vtkTypeBool

        """
        return _SMESH.SMESH_SVTKActor_IsA(self, *args)


    def SafeDownCast(*args):
        """
        SafeDownCast(vtkObjectBase * o) -> SMESH_SVTKActor

        :type o: vtkObjectBase
        :rtype: OCC.wrapper.SMESH.SMESH_SVTKActor

        """
        return _SMESH.SMESH_SVTKActor_SafeDownCast(*args)

    SafeDownCast = staticmethod(SafeDownCast)

    def NewInstance(self, *args):
        """
        NewInstance(SMESH_SVTKActor self) -> SMESH_SVTKActor

        :rtype: OCC.wrapper.SMESH.SMESH_SVTKActor

        """
        return _SMESH.SMESH_SVTKActor_NewInstance(self, *args)


    def SetBallScale(self, *args):
        """
        SetBallScale(SMESH_SVTKActor self, double theSize)

        :type theSize: double

        """
        return _SMESH.SMESH_SVTKActor_SetBallScale(self, *args)


    def SetBallSize(self, *args):
        """
        SetBallSize(SMESH_SVTKActor self, float theSize)

        :type theSize: float

        """
        return _SMESH.SMESH_SVTKActor_SetBallSize(self, *args)


    def Set0DSize(self, *args):
        """
        Set0DSize(SMESH_SVTKActor self, float theSize)

        :type theSize: float

        """
        return _SMESH.SMESH_SVTKActor_Set0DSize(self, *args)


    def AddToRender(self, *args):
        """
        AddToRender(SMESH_SVTKActor self, vtkRenderer * theRendere)

        To publish the actor an all its internal devices

        :type theRendere: vtkRenderer

        """
        return _SMESH.SMESH_SVTKActor_AddToRender(self, *args)


    def SetVisibility(self, *args):
        """
        SetVisibility(SMESH_SVTKActor self, int theVisibility)

        :type theVisibility: int

        """
        return _SMESH.SMESH_SVTKActor_SetVisibility(self, *args)


    def Initialize(self, *args):
        """
        Initialize(SMESH_SVTKActor self)

        Initialize the instance completely


        """
        return _SMESH.SMESH_SVTKActor_Initialize(self, *args)


    def MapCells(self, *args):
        """
        MapCells(SMESH_SVTKActor self, SALOME_Actor * theMapActor, NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher theMapIndex)

        Allow to recostruct selected cells from source SALOME_Actor and map of subindexes

        :type theMapActor: SALOME_Actor
        :type theMapIndex: OCC.wrapper.TColStd.TColStd_IndexedMapOfInteger

        """
        return _SMESH.SMESH_SVTKActor_MapCells(self, *args)


    def RemoveFromRender(self, *args):
        """
        RemoveFromRender(SMESH_SVTKActor self, vtkRenderer * theRendere)

        To remove the actor an all its internal devices

        :type theRendere: vtkRenderer

        """
        return _SMESH.SMESH_SVTKActor_RemoveFromRender(self, *args)


    def SetVisualObject(self, *args):
        """
        SetVisualObject(SMESH_SVTKActor self, shared_ptr_SMESH_VisualObj theVisualObj)

        :type theVisualObj: TVisualObjPtr

        """
        return _SMESH.SMESH_SVTKActor_SetVisualObject(self, *args)

SMESH_SVTKActor_swigregister = _SMESH.SMESH_SVTKActor_swigregister
SMESH_SVTKActor_swigregister(SMESH_SVTKActor)

def SMESH_SVTKActor_New(*args):
    """
    SMESH_SVTKActor_New() -> SMESH_SVTKActor

    :rtype: OCC.wrapper.SMESH.SMESH_SVTKActor

    """
    return _SMESH.SMESH_SVTKActor_New(*args)

def SMESH_SVTKActor_IsTypeOf(*args):
    """
    SMESH_SVTKActor_IsTypeOf(char const * type) -> vtkTypeBool

    :type type: const char *
    :rtype: vtkTypeBool

    """
    return _SMESH.SMESH_SVTKActor_IsTypeOf(*args)

def SMESH_SVTKActor_SafeDownCast(*args):
    """
    SMESH_SVTKActor_SafeDownCast(vtkObjectBase * o) -> SMESH_SVTKActor

    :type o: vtkObjectBase
    :rtype: OCC.wrapper.SMESH.SMESH_SVTKActor

    """
    return _SMESH.SMESH_SVTKActor_SafeDownCast(*args)

class SMESH_GroupObj(SMESH_SubMeshObj):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(SMESH_GroupObj self, SMESH::SMESH_GroupBase_ptr arg2, SMESH_MeshObj arg3) -> SMESH_GroupObj

        :type : OCC.wrapper.SMESH.SMESH_GroupBase_ptr
        :type : OCC.wrapper.SMESH.SMESH_MeshObj

        """
        this = _SMESH.new_SMESH_GroupObj(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetNbEntities(self, *args):
        """
        GetNbEntities(SMESH_GroupObj self, SMDSAbs_ElementType const arg2) -> int

        :type : OCC.wrapper.SMDSAbs.SMDSAbs_ElementType
        :rtype: int

        """
        return _SMESH.SMESH_GroupObj_GetNbEntities(self, *args)


    def GetEntities(self, *args):
        """
        GetEntities(SMESH_GroupObj self, SMDSAbs_ElementType const arg2, SMESH_VisualObjDef::TEntityList & arg3) -> int

        :type : OCC.wrapper.SMDSAbs.SMDSAbs_ElementType
        :type : TEntityList
        :rtype: int

        """
        return _SMESH.SMESH_GroupObj_GetEntities(self, *args)


    def IsNodePrs(self, *args):
        """
        IsNodePrs(SMESH_GroupObj self) -> bool

        :rtype: bool

        """
        return _SMESH.SMESH_GroupObj_IsNodePrs(self, *args)


    def GetElementType(self, *args):
        """
        GetElementType(SMESH_GroupObj self) -> SMDSAbs_ElementType

        :rtype: OCC.wrapper.SMDSAbs.SMDSAbs_ElementType

        """
        return _SMESH.SMESH_GroupObj_GetElementType(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_GroupObj
SMESH_GroupObj_swigregister = _SMESH.SMESH_GroupObj_swigregister
SMESH_GroupObj_swigregister(SMESH_GroupObj)


try:
	NLink = pair_SMDS_MeshNode_SMDS_MeshNode
except NameError:
	pass # does not exist, probably ignored

class SMESH_MesherHelper(object):
    """
    rief It helps meshers to add elements and provides other utilities

    - It allows meshers not to care about creation of medium nodes
    when filling a quadratic mesh. Helper does it itself.
    It defines order of elements to create when IsQuadraticSubMesh()
    is called.
    - It provides information on a shape it is initialized with:
    periodicity, presence of singularities etc.
    - ...
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    LINEAR = _SMESH.SMESH_MesherHelper_LINEAR
    QUADRATIC = _SMESH.SMESH_MesherHelper_QUADRATIC
    COMP = _SMESH.SMESH_MesherHelper_COMP

    def IsSameElemGeometry(*args):
        """
        IsSameElemGeometry(SMESHDS_SubMesh smDS, SMDSAbs_GeometryType shape, bool const nullSubMeshRes=True) -> bool

        rief Returns true if all elements of a sub-mesh are of same shape
        \param smDS - sub-mesh to check elements of
        \param shape - expected shape of elements
        \param nullSubMeshRes - result value for the case of smDS == NULL
        etval bool - check result

        :type smDS: OCC.wrapper.SMESHDS.SMESHDS_SubMesh
        :type shape: OCC.wrapper.SMDSAbs.SMDSAbs_GeometryType
        :type nullSubMeshRes: const bool
        :rtype: bool

        """
        return _SMESH.SMESH_MesherHelper_IsSameElemGeometry(*args)

    IsSameElemGeometry = staticmethod(IsSameElemGeometry)

    def LoadNodeColumns(*args):
        """
        LoadNodeColumns(TParam2ColumnMap & theParam2ColumnMap, TopoDS_Face theFace, std::list< TopoDS_Edge,std::allocator< TopoDS_Edge > > const & theBaseSide, SMESHDS_Mesh theMesh, SMESH_ProxyMesh theProxyMesh=None) -> bool
        LoadNodeColumns(TParam2ColumnMap & theParam2ColumnMap, TopoDS_Face theFace, TopoDS_Edge theBaseEdge, SMESHDS_Mesh theMesh, SMESH_ProxyMesh theProxyMesh=None) -> bool

        rief Variant of LoadNodeColumns() above with theBaseSide given by one edge

        :type theParam2ColumnMap: TParam2ColumnMap
        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theBaseEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theMesh: OCC.wrapper.SMESHDS.SMESHDS_Mesh
        :type theProxyMesh: OCC.wrapper.SMESH.SMESH_ProxyMesh
        :rtype: bool

        """
        return _SMESH.SMESH_MesherHelper_LoadNodeColumns(*args)

    LoadNodeColumns = staticmethod(LoadNodeColumns)

    def IsStructured(*args):
        """
        IsStructured(SMESH_subMesh faceSM) -> bool

        rief Return true if 2D mesh on FACE is structured

        :type faceSM: OCC.wrapper.SMESH.SMESH_subMesh
        :rtype: bool

        """
        return _SMESH.SMESH_MesherHelper_IsStructured(*args)

    IsStructured = staticmethod(IsStructured)

    def IsDistorted2D(*args):
        """
        IsDistorted2D(SMESH_subMesh faceSM, bool checkUV=False, SMESH_MesherHelper faceHelper=None) -> bool

        rief Return true if 2D mesh on FACE is distored

        :type faceSM: OCC.wrapper.SMESH.SMESH_subMesh
        :type checkUV: bool
        :type faceHelper: OCC.wrapper.SMESH.SMESH_MesherHelper
        :rtype: bool

        """
        return _SMESH.SMESH_MesherHelper_IsDistorted2D(*args)

    IsDistorted2D = staticmethod(IsDistorted2D)

    def IsMedium(*args):
        """
        IsMedium(SMDS_MeshNode node, SMDSAbs_ElementType const typeToCheck=SMDSAbs_All) -> bool

        rief Returns true if given node is medium
        \param n - node to check
        \param typeToCheck - type of elements containing the node to ask about node status
        etval bool - check result

        :type node: OCC.wrapper.SMDS.SMDS_MeshNode
        :type typeToCheck: OCC.wrapper.SMDSAbs.SMDSAbs_ElementType
        :rtype: bool

        """
        return _SMESH.SMESH_MesherHelper_IsMedium(*args)

    IsMedium = staticmethod(IsMedium)

    def GetSubShapeByNode(*args):
        """
        GetSubShapeByNode(SMDS_MeshNode node, SMESHDS_Mesh meshDS) -> TopoDS_Shape

        rief Return support shape of a node
        \param node - the node
        \param meshDS - mesh DS
        etval TopoDS_Shape - found support shape
        \sa SMESH_Algo::VertexNode( const TopoDS_Vertex&, SMESHDS_Mesh* )

        :type node: OCC.wrapper.SMDS.SMDS_MeshNode
        :type meshDS: OCC.wrapper.SMESHDS.SMESHDS_Mesh
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _SMESH.SMESH_MesherHelper_GetSubShapeByNode(*args)

    GetSubShapeByNode = staticmethod(GetSubShapeByNode)

    def WrapIndex(*args):
        """
        WrapIndex(int ind, int const nbNodes) -> int

        rief Return a valid node index, fixing the given one if necessary
        \param ind - node index
        \param nbNodes - total nb of nodes
        etval int - valid node index

        :type ind: int
        :type nbNodes: const int
        :rtype: int

        """
        return _SMESH.SMESH_MesherHelper_WrapIndex(*args)

    WrapIndex = staticmethod(WrapIndex)

    def calcTFI(*args):
        """
        calcTFI(double x, double y, gp_XY a0, gp_XY a1, gp_XY a2, gp_XY a3, gp_XY p0, gp_XY p1, gp_XY p2, gp_XY p3) -> gp_XY
        calcTFI(double x, double y, gp_XYZ a0, gp_XYZ a1, gp_XYZ a2, gp_XYZ a3, gp_XYZ p0, gp_XYZ p1, gp_XYZ p2, gp_XYZ p3) -> gp_XYZ

        rief Same as "gp_XY calcTFI(...)" but in 3D

        :type x: double
        :type y: double
        :type a0: OCC.wrapper.gp.gp_XYZ
        :type a1: OCC.wrapper.gp.gp_XYZ
        :type a2: OCC.wrapper.gp.gp_XYZ
        :type a3: OCC.wrapper.gp.gp_XYZ
        :type p0: OCC.wrapper.gp.gp_XYZ
        :type p1: OCC.wrapper.gp.gp_XYZ
        :type p2: OCC.wrapper.gp.gp_XYZ
        :type p3: OCC.wrapper.gp.gp_XYZ
        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _SMESH.SMESH_MesherHelper_calcTFI(*args)

    calcTFI = staticmethod(calcTFI)

    def Count(*args):
        """
        Count(TopoDS_Shape shape, TopAbs_ShapeEnum const type, bool const ignoreSame) -> int

        rief Count nb of sub-shapes
        \param shape - the shape
        \param type - the type of sub-shapes to count
        \param ignoreSame - if true, use map not to count same shapes, else use explorer
        etval int - the calculated number

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type type: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type ignoreSame: const bool
        :rtype: int

        """
        return _SMESH.SMESH_MesherHelper_Count(*args)

    Count = staticmethod(Count)

    def NbAncestors(*args):
        """
        NbAncestors(TopoDS_Shape shape, SMESH_Mesh mesh, TopAbs_ShapeEnum ancestorType=TopAbs_SHAPE) -> int

        rief Return number of unique ancestors of the shape

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type mesh: OCC.wrapper.SMESH.SMESH_Mesh
        :type ancestorType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: int

        """
        return _SMESH.SMESH_MesherHelper_NbAncestors(*args)

    NbAncestors = staticmethod(NbAncestors)

    def GetAncestors(*args):
        """
        GetAncestors(TopoDS_Shape shape, SMESH_Mesh mesh, TopAbs_ShapeEnum ancestorType, TopoDS_Shape container=None) -> PShapeIteratorPtr

        rief Return iterator on ancestors of the given type, included into a container shape

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type mesh: OCC.wrapper.SMESH.SMESH_Mesh
        :type ancestorType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type container: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: PShapeIteratorPtr

        """
        return _SMESH.SMESH_MesherHelper_GetAncestors(*args)

    GetAncestors = staticmethod(GetAncestors)

    def GetCommonAncestor(*args):
        """
        GetCommonAncestor(TopoDS_Shape shape1, TopoDS_Shape shape2, SMESH_Mesh mesh, TopAbs_ShapeEnum ancestorType) -> TopoDS_Shape

        rief Find a common ancestor, of the given type, of two shapes

        :type shape1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type shape2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type mesh: OCC.wrapper.SMESH.SMESH_Mesh
        :type ancestorType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _SMESH.SMESH_MesherHelper_GetCommonAncestor(*args)

    GetCommonAncestor = staticmethod(GetCommonAncestor)

    def GetSubShapeOri(*args):
        """
        GetSubShapeOri(TopoDS_Shape shape, TopoDS_Shape subShape) -> TopAbs_Orientation

        rief Return orientation of sub-shape in the main shape

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type subShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _SMESH.SMESH_MesherHelper_GetSubShapeOri(*args)

    GetSubShapeOri = staticmethod(GetSubShapeOri)

    def IsSubShape(*args):
        """
        IsSubShape(TopoDS_Shape shape, TopoDS_Shape mainShape) -> bool
        IsSubShape(TopoDS_Shape shape, SMESH_Mesh aMesh) -> bool

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aMesh: OCC.wrapper.SMESH.SMESH_Mesh
        :rtype: bool

        """
        return _SMESH.SMESH_MesherHelper_IsSubShape(*args)

    IsSubShape = staticmethod(IsSubShape)

    def IsBlock(*args):
        """
        IsBlock(TopoDS_Shape shape) -> bool

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: bool

        """
        return _SMESH.SMESH_MesherHelper_IsBlock(*args)

    IsBlock = staticmethod(IsBlock)

    def MaxTolerance(*args):
        """
        MaxTolerance(TopoDS_Shape shape) -> double

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: double

        """
        return _SMESH.SMESH_MesherHelper_MaxTolerance(*args)

    MaxTolerance = staticmethod(MaxTolerance)

    def GetAngle(*args):
        """
        GetAngle(TopoDS_Edge E1, TopoDS_Edge E2, TopoDS_Face F, TopoDS_Vertex V, gp_Vec faceNormal=None) -> double

        :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type faceNormal: OCC.wrapper.gp.gp_Vec
        :rtype: double

        """
        return _SMESH.SMESH_MesherHelper_GetAngle(*args)

    GetAngle = staticmethod(GetAngle)

    def IsClosedEdge(*args):
        """
        IsClosedEdge(TopoDS_Edge anEdge) -> bool

        :type anEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: bool

        """
        return _SMESH.SMESH_MesherHelper_IsClosedEdge(*args)

    IsClosedEdge = staticmethod(IsClosedEdge)

    def IthVertex(*args):
        """
        IthVertex(bool const is2nd, TopoDS_Edge anEdge, bool const CumOri=True) -> TopoDS_Vertex

        :type is2nd: const bool
        :type anEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type CumOri: const bool
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _SMESH.SMESH_MesherHelper_IthVertex(*args)

    IthVertex = staticmethod(IthVertex)

    def GetGroupType(*args):
        """
        GetGroupType(TopoDS_Shape group, bool const avoidCompound=False) -> TopAbs_ShapeEnum

        :type group: OCC.wrapper.TopoDS.TopoDS_Shape
        :type avoidCompound: const bool
        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _SMESH.SMESH_MesherHelper_GetGroupType(*args)

    GetGroupType = staticmethod(GetGroupType)

    def GetShapeOfHypothesis(*args):
        """
        GetShapeOfHypothesis(SMESHDS_Hypothesis hyp, TopoDS_Shape shape, SMESH_Mesh mesh) -> TopoDS_Shape

        :type hyp: OCC.wrapper.SMESHDS.SMESHDS_Hypothesis
        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type mesh: OCC.wrapper.SMESH.SMESH_Mesh
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _SMESH.SMESH_MesherHelper_GetShapeOfHypothesis(*args)

    GetShapeOfHypothesis = staticmethod(GetShapeOfHypothesis)

    def __init__(self, *args):
        """
        __init__(SMESH_MesherHelper self, SMESH_Mesh theMesh) -> SMESH_MesherHelper

        :type theMesh: OCC.wrapper.SMESH.SMESH_Mesh

        """
        this = _SMESH.new_SMESH_MesherHelper(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetGen(self, *args):
        """
        GetGen(SMESH_MesherHelper self) -> SMESH_Gen

        :rtype: OCC.wrapper.SMESH.SMESH_Gen

        """
        return _SMESH.SMESH_MesherHelper_GetGen(self, *args)


    def GetMesh(self, *args):
        """
        GetMesh(SMESH_MesherHelper self) -> SMESH_Mesh

        :rtype: OCC.wrapper.SMESH.SMESH_Mesh

        """
        return _SMESH.SMESH_MesherHelper_GetMesh(self, *args)


    def GetMeshDS(self, *args):
        """
        GetMeshDS(SMESH_MesherHelper self) -> SMESHDS_Mesh

        :rtype: OCC.wrapper.SMESHDS.SMESHDS_Mesh

        """
        return _SMESH.SMESH_MesherHelper_GetMeshDS(self, *args)


    def IsQuadraticSubMesh(self, *args):
        """
        IsQuadraticSubMesh(SMESH_MesherHelper self, TopoDS_Shape theShape) -> bool

        Check submesh for given shape: if all elements on this shape are quadratic,
        quadratic elements will be created. Also fill myTLinkNodeMap

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: bool

        """
        return _SMESH.SMESH_MesherHelper_IsQuadraticSubMesh(self, *args)


    def SetIsQuadratic(self, *args):
        """
        SetIsQuadratic(SMESH_MesherHelper self, bool const theBuildQuadratic)

        rief Set order of elements to create without calling IsQuadraticSubMesh()

        :type theBuildQuadratic: const bool

        """
        return _SMESH.SMESH_MesherHelper_SetIsQuadratic(self, *args)


    def SetIsBiQuadratic(self, *args):
        """
        SetIsBiQuadratic(SMESH_MesherHelper self, bool const theBuildBiQuadratic)

        rief Set myCreateBiQuadratic flag

        :type theBuildBiQuadratic: const bool

        """
        return _SMESH.SMESH_MesherHelper_SetIsBiQuadratic(self, *args)


    def GetIsQuadratic(self, *args):
        """
        GetIsQuadratic(SMESH_MesherHelper self) -> bool

        rief Return myCreateQuadratic flag

        :rtype: bool

        """
        return _SMESH.SMESH_MesherHelper_GetIsQuadratic(self, *args)


    def IsReversedSubMesh(self, *args):
        """
        IsReversedSubMesh(SMESH_MesherHelper self, TopoDS_Face theFace) -> bool

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: bool

        """
        return _SMESH.SMESH_MesherHelper_IsReversedSubMesh(self, *args)


    def GetIsBiQuadratic(self, *args):
        """
        GetIsBiQuadratic(SMESH_MesherHelper self) -> bool

        rief Return myCreateBiQuadratic flag

        :rtype: bool

        """
        return _SMESH.SMESH_MesherHelper_GetIsBiQuadratic(self, *args)


    def FixQuadraticElements(self, *args):
        """
        FixQuadraticElements(SMESH_MesherHelper self, shared_ptr_SMESH_ComputeError error, bool volumeOnly=True)

        rief Move medium nodes of faces and volumes to fix distorted elements
        \param error - container of fixed distorted elements
        \param volumeOnly - fix nodes on geom faces or not if the shape is solid

        :type error: OCC.wrapper.SMESH.SMESH_ComputeErrorPtr
        :type volumeOnly: bool

        """
        return _SMESH.SMESH_MesherHelper_FixQuadraticElements(self, *args)


    def SetElementsOnShape(self, *args):
        """
        SetElementsOnShape(SMESH_MesherHelper self, bool toSet) -> bool

        rief To set created elements on the shape set by IsQuadraticSubMesh()
        or the next methods. By default elements are set on the shape if
        a mesh has no shape to be meshed

        :type toSet: bool
        :rtype: bool

        """
        return _SMESH.SMESH_MesherHelper_SetElementsOnShape(self, *args)


    def SetSubShape(self, *args):
        """
        SetSubShape(SMESH_MesherHelper self, int const subShapeID)
        SetSubShape(SMESH_MesherHelper self, TopoDS_Shape subShape)

        ==SMESHDS_Mesh::ShapeToIndex(shape)

        :type subShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _SMESH.SMESH_MesherHelper_SetSubShape(self, *args)


    def GetSubShapeID(self, *args):
        """
        GetSubShapeID(SMESH_MesherHelper self) -> int

        rief Return ID of the shape set by IsQuadraticSubMesh() or SetSubShape() 
        etval int - shape index in SMESHDS

        :rtype: int

        """
        return _SMESH.SMESH_MesherHelper_GetSubShapeID(self, *args)


    def GetSubShape(self, *args):
        """
        \brief Return the shape set by IsQuadraticSubMesh() or SetSubShape() 

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _SMESH.SMESH_MesherHelper_GetSubShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CopySubShapeInfo(self, *args):
        """
        CopySubShapeInfo(SMESH_MesherHelper self, SMESH_MesherHelper other)

        rief Copy shape information from another helper to improve performance
        since SetSubShape() can be time consuming if there are many edges

        :type other: OCC.wrapper.SMESH.SMESH_MesherHelper

        """
        return _SMESH.SMESH_MesherHelper_CopySubShapeInfo(self, *args)


    def ShapeToIndex(self, *args):
        """
        ShapeToIndex(SMESH_MesherHelper self, TopoDS_Shape S) -> int

        rief Convert a shape to its index in the SMESHDS_Mesh

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: int

        """
        return _SMESH.SMESH_MesherHelper_ShapeToIndex(self, *args)


    def AddNode(self, *args):
        """
        AddNode(SMESH_MesherHelper self, double x, double y, double z, int ID=0, double u=0., double v=0.) -> SMDS_MeshNode

        Creates a node (!Note ID before u=0.,v0.)

        :type x: double
        :type y: double
        :type z: double
        :type ID: int
        :type u: double
        :type v: double
        :rtype: OCC.wrapper.SMDS.SMDS_MeshNode

        """
        return _SMESH.SMESH_MesherHelper_AddNode(self, *args)


    def AddEdge(self, *args):
        """
        AddEdge(SMESH_MesherHelper self, SMDS_MeshNode n1, SMDS_MeshNode n2, int const id=0, bool const force3d=True) -> SMDS_MeshEdge

        Creates quadratic or linear edge

        :type n1: OCC.wrapper.SMDS.SMDS_MeshNode
        :type n2: OCC.wrapper.SMDS.SMDS_MeshNode
        :type id: const int
        :type force3d: const bool
        :rtype: OCC.wrapper.SMDS.SMDS_MeshEdge

        """
        return _SMESH.SMESH_MesherHelper_AddEdge(self, *args)


    def AddFace(self, *args):
        """
        AddFace(SMESH_MesherHelper self, SMDS_MeshNode n1, SMDS_MeshNode n2, SMDS_MeshNode n3, int const id=0, bool const force3d=False) -> SMDS_MeshFace
        AddFace(SMESH_MesherHelper self, SMDS_MeshNode n1, SMDS_MeshNode n2, SMDS_MeshNode n3, SMDS_MeshNode n4, int const id=0, bool const force3d=False) -> SMDS_MeshFace

        Creates bi-quadratic, quadratic or linear quadrangle

        :type n1: OCC.wrapper.SMDS.SMDS_MeshNode
        :type n2: OCC.wrapper.SMDS.SMDS_MeshNode
        :type n3: OCC.wrapper.SMDS.SMDS_MeshNode
        :type n4: OCC.wrapper.SMDS.SMDS_MeshNode
        :type id: const int
        :type force3d: const bool
        :rtype: OCC.wrapper.SMDS.SMDS_MeshFace

        """
        return _SMESH.SMESH_MesherHelper_AddFace(self, *args)


    def AddPolygonalFace(self, *args):
        """
        AddPolygonalFace(SMESH_MesherHelper self, std::vector< SMDS_MeshNode const *,std::allocator< SMDS_MeshNode const * > > const & nodes, int const id=0, bool const force3d=False) -> SMDS_MeshFace

        Creates polygon, with additional nodes in quadratic mesh

        :type nodes: const int &
        :type id: const int
        :type force3d: const bool
        :rtype: OCC.wrapper.SMDS.SMDS_MeshFace

        """
        return _SMESH.SMESH_MesherHelper_AddPolygonalFace(self, *args)


    def AddVolume(self, *args):
        """
        AddVolume(SMESH_MesherHelper self, SMDS_MeshNode n1, SMDS_MeshNode n2, SMDS_MeshNode n3, SMDS_MeshNode n4, int const id=0, bool const force3d=True) -> SMDS_MeshVolume
        AddVolume(SMESH_MesherHelper self, SMDS_MeshNode n1, SMDS_MeshNode n2, SMDS_MeshNode n3, SMDS_MeshNode n4, SMDS_MeshNode n5, int const id=0, bool const force3d=True) -> SMDS_MeshVolume
        AddVolume(SMESH_MesherHelper self, SMDS_MeshNode n1, SMDS_MeshNode n2, SMDS_MeshNode n3, SMDS_MeshNode n4, SMDS_MeshNode n5, SMDS_MeshNode n6, int const id=0, bool const force3d=True) -> SMDS_MeshVolume
        AddVolume(SMESH_MesherHelper self, SMDS_MeshNode n1, SMDS_MeshNode n2, SMDS_MeshNode n3, SMDS_MeshNode n4, SMDS_MeshNode n5, SMDS_MeshNode n6, SMDS_MeshNode n7, SMDS_MeshNode n8, int const id=0, bool force3d=True) -> SMDS_MeshVolume
        AddVolume(SMESH_MesherHelper self, SMDS_MeshNode n1, SMDS_MeshNode n2, SMDS_MeshNode n3, SMDS_MeshNode n4, SMDS_MeshNode n5, SMDS_MeshNode n6, SMDS_MeshNode n7, SMDS_MeshNode n8, SMDS_MeshNode n9, SMDS_MeshNode n10, SMDS_MeshNode n11, SMDS_MeshNode n12, int const id=0, bool force3d=True) -> SMDS_MeshVolume

        Creates LINEAR!!!!!!!!! octahedron

        :type n1: OCC.wrapper.SMDS.SMDS_MeshNode
        :type n2: OCC.wrapper.SMDS.SMDS_MeshNode
        :type n3: OCC.wrapper.SMDS.SMDS_MeshNode
        :type n4: OCC.wrapper.SMDS.SMDS_MeshNode
        :type n5: OCC.wrapper.SMDS.SMDS_MeshNode
        :type n6: OCC.wrapper.SMDS.SMDS_MeshNode
        :type n7: OCC.wrapper.SMDS.SMDS_MeshNode
        :type n8: OCC.wrapper.SMDS.SMDS_MeshNode
        :type n9: OCC.wrapper.SMDS.SMDS_MeshNode
        :type n10: OCC.wrapper.SMDS.SMDS_MeshNode
        :type n11: OCC.wrapper.SMDS.SMDS_MeshNode
        :type n12: OCC.wrapper.SMDS.SMDS_MeshNode
        :type id: const int
        :type force3d: bool
        :rtype: OCC.wrapper.SMDS.SMDS_MeshVolume

        """
        return _SMESH.SMESH_MesherHelper_AddVolume(self, *args)


    def AddPolyhedralVolume(self, *args):
        """
        AddPolyhedralVolume(SMESH_MesherHelper self, std::vector< SMDS_MeshNode const *,std::allocator< SMDS_MeshNode const * > > const & nodes, std::vector< int,std::allocator< int > > const & quantities, int const ID=0, bool const force3d=True) -> SMDS_MeshVolume

        Creates polyhedron. In quadratic mesh, adds medium nodes

        :type nodes: const int &
        :type quantities: const int &
        :type ID: const int
        :type force3d: const bool
        :rtype: OCC.wrapper.SMDS.SMDS_MeshVolume

        """
        return _SMESH.SMESH_MesherHelper_AddPolyhedralVolume(self, *args)


    def ToFixNodeParameters(self, *args):
        """
        ToFixNodeParameters(SMESH_MesherHelper self, bool toFix)

        rief Enables fixing node parameters on EDGEs and FACEs by
        GetNodeU(...,check=true), GetNodeUV(...,check=true), CheckNodeUV() and
        CheckNodeU() in case if a node lies on a shape set via SetSubShape().
        Default is False

        :type toFix: bool

        """
        return _SMESH.SMESH_MesherHelper_ToFixNodeParameters(self, *args)


    def GetNodeU(self, *args):
        """
        GetNodeU(SMESH_MesherHelper self, TopoDS_Edge theEdge, SMDS_MeshNode theNode, SMDS_MeshNode inEdgeNode=None, bool * check=None) -> double

        rief Return U of the given node on the edge

        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theNode: OCC.wrapper.SMDS.SMDS_MeshNode
        :type inEdgeNode: OCC.wrapper.SMDS.SMDS_MeshNode
        :type check: bool *
        :rtype: double

        """
        return _SMESH.SMESH_MesherHelper_GetNodeU(self, *args)


    def GetNodeUV(self, *args):
        """
        GetNodeUV(SMESH_MesherHelper self, TopoDS_Face F, SMDS_MeshNode n, SMDS_MeshNode inFaceNode=None, bool * check=None) -> gp_XY

        rief Return node UV on face
        \param inFaceNode - a node of element being created located inside a face
        \param check - if provided, returns result of UV check that it enforces

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type n: OCC.wrapper.SMDS.SMDS_MeshNode
        :type inFaceNode: OCC.wrapper.SMDS.SMDS_MeshNode
        :type check: bool *
        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _SMESH.SMESH_MesherHelper_GetNodeUV(self, *args)


    def CheckNodeUV(self, *args):
        """
        CheckNodeUV(SMESH_MesherHelper self, TopoDS_Face F, SMDS_MeshNode n, gp_XY uv, double const tol, bool const force=False, double * distXYZ=None) -> bool

        rief Check and fix node UV on a face
        \param force - check even if checks of other nodes on this face passed OK
        \param distXYZ - returns result distance and point coordinates
        etval bool - false if UV is bad and could not be fixed

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type n: OCC.wrapper.SMDS.SMDS_MeshNode
        :type uv: OCC.wrapper.gp.gp_XY
        :type tol: const double
        :type force: const bool
        :type distXYZ: double [4]
        :rtype: bool

        """
        return _SMESH.SMESH_MesherHelper_CheckNodeUV(self, *args)


    def CheckNodeU(self, *args):
        """
        CheckNodeU(SMESH_MesherHelper self, TopoDS_Edge E, SMDS_MeshNode n, double const tol, bool const force=False, double * distXYZ=None) -> bool

        rief Check and fix node U on an edge
        \param force - check even if checks of other nodes on this edge passed OK
        \param distXYZ - returns result distance and point coordinates
        etval bool - false if U is bad and could not be fixed

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type n: OCC.wrapper.SMDS.SMDS_MeshNode
        :type u: double &
        :type tol: const double
        :type force: const bool
        :type distXYZ: double [4]
        :rtype: bool

        """
        return _SMESH.SMESH_MesherHelper_CheckNodeU(self, *args)


    def GetMiddleUV(*args):
        """
        GetMiddleUV(Handle_Geom_Surface surface, gp_XY uv1, gp_XY uv2) -> gp_XY

        rief Return middle UV taking in account surface period

        :type surface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type uv1: OCC.wrapper.gp.gp_XY
        :type uv2: OCC.wrapper.gp.gp_XY
        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _SMESH.SMESH_MesherHelper_GetMiddleUV(*args)

    GetMiddleUV = staticmethod(GetMiddleUV)

    def GetCenterUV(*args):
        """
        GetCenterUV(gp_XY uv1, gp_XY uv2, gp_XY uv3, gp_XY uv12, gp_XY uv23, gp_XY uv31, bool * isBadTria=None) -> gp_XY

        rief Return UV for the central node of a biquadratic triangle

        :type uv1: OCC.wrapper.gp.gp_XY
        :type uv2: OCC.wrapper.gp.gp_XY
        :type uv3: OCC.wrapper.gp.gp_XY
        :type uv12: OCC.wrapper.gp.gp_XY
        :type uv23: OCC.wrapper.gp.gp_XY
        :type uv31: OCC.wrapper.gp.gp_XY
        :type isBadTria: bool *
        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _SMESH.SMESH_MesherHelper_GetCenterUV(*args)

    GetCenterUV = staticmethod(GetCenterUV)

    def ApplyIn2D(*args):
        """
        ApplyIn2D(Handle_Geom_Surface surface, gp_XY uv1, gp_XY uv2, xyFunPtr fun, bool const resultInPeriod=True) -> gp_XY

        rief Perform given operation on two 2d points in parameric space of given surface.
        It takes into account period of the surface. Use gp_XY_FunPtr macro
        to easily define pointer to function of gp_XY class.

        :type surface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type uv1: OCC.wrapper.gp.gp_XY
        :type uv2: OCC.wrapper.gp.gp_XY
        :type fun: xyFunPtr
        :type resultInPeriod: const bool
        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _SMESH.SMESH_MesherHelper_ApplyIn2D(*args)

    ApplyIn2D = staticmethod(ApplyIn2D)

    def AdjustByPeriod(self, *args):
        """
        AdjustByPeriod(SMESH_MesherHelper self, TopoDS_Face face, gp_XY uv, int const nbUV)

        rief Move node positions on a FACE within surface period
        \param [in] face - the FACE
        \param [inout] uv - node positions to adjust
        \param [in] nbUV - nb of  uv

        :type face: OCC.wrapper.TopoDS.TopoDS_Face
        :type uv: OCC.wrapper.gp.gp_XY []
        :type nbUV: const int

        """
        return _SMESH.SMESH_MesherHelper_AdjustByPeriod(self, *args)


    def GetNodeUVneedInFaceNode(self, *args):
        """
        GetNodeUVneedInFaceNode(SMESH_MesherHelper self, TopoDS_Face F) -> bool

        rief Check if inFaceNode argument is necessary for call GetNodeUV(F,..)
        etval bool - return true if the face is periodic

        If F is Null, answer about subshape set through IsQuadraticSubMesh() or
        SetSubShape()

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: bool

        """
        return _SMESH.SMESH_MesherHelper_GetNodeUVneedInFaceNode(self, *args)


    def GetProjector(self, *args):
        """
        GetProjector(SMESH_MesherHelper self, TopoDS_Face F, TopLoc_Location loc, double tol=0) -> GeomAPI_ProjectPointOnSurf

        rief Return projector initialized by given face without location, which is returned

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type loc: OCC.wrapper.TopLoc.TopLoc_Location
        :type tol: double
        :rtype: OCC.wrapper.GeomAPI.GeomAPI_ProjectPointOnSurf

        """
        return _SMESH.SMESH_MesherHelper_GetProjector(self, *args)


    def GetSurface(self, *args):
        """
        GetSurface(SMESH_MesherHelper self, TopoDS_Face F) -> Handle_ShapeAnalysis_Surface

        rief Return a cached ShapeAnalysis_Surface of a FACE

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_Surface

        """
        return _SMESH.SMESH_MesherHelper_GetSurface(self, *args)


    def IsDegenShape(self, *args):
        """
        IsDegenShape(SMESH_MesherHelper self, int const subShape) -> bool

        rief Check if shape is a degenerated edge or it's vertex
        \param subShape - edge or vertex index in SMESHDS
        etval bool - true if subShape is a degenerated shape

        It works only if IsQuadraticSubMesh() or SetSubShape() has been called

        :type subShape: const int
        :rtype: bool

        """
        return _SMESH.SMESH_MesherHelper_IsDegenShape(self, *args)


    def HasDegeneratedEdges(self, *args):
        """
        HasDegeneratedEdges(SMESH_MesherHelper self) -> bool

        rief Check if the shape set through IsQuadraticSubMesh() or SetSubShape()
        has a degenerated edges
        etval bool - true if there are degenerated edges

        :rtype: bool

        """
        return _SMESH.SMESH_MesherHelper_HasDegeneratedEdges(self, *args)


    def NbDegeneratedEdges(self, *args):
        """
        NbDegeneratedEdges(SMESH_MesherHelper self) -> size_t

        rief Return a number of degenerated edges in the shape set through
        IsQuadraticSubMesh() or SetSubShape()
        etval size_t - nb edges

        :rtype: size_t

        """
        return _SMESH.SMESH_MesherHelper_NbDegeneratedEdges(self, *args)


    def IsSeamShape(self, *args):
        """
        IsSeamShape(SMESH_MesherHelper self, int const subShape) -> bool
        IsSeamShape(SMESH_MesherHelper self, TopoDS_Shape subShape) -> bool

        rief Check if shape is a seam edge or it's vertex
        \param subShape - edge or vertex
        etval bool - true if subShape is a seam shape

        It works only if IsQuadraticSubMesh() or SetSubShape() has been called.
        Seam shape has two 2D alternative representations on the face

        :type subShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: bool

        """
        return _SMESH.SMESH_MesherHelper_IsSeamShape(self, *args)


    def IsRealSeam(self, *args):
        """
        IsRealSeam(SMESH_MesherHelper self, int const subShape) -> bool
        IsRealSeam(SMESH_MesherHelper self, TopoDS_Shape subShape) -> bool

        rief Return true if an edge or a vertex encounters twice in face wire
        \param subShape - edge or vertex

        :type subShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: bool

        """
        return _SMESH.SMESH_MesherHelper_IsRealSeam(self, *args)


    def HasSeam(self, *args):
        """
        HasSeam(SMESH_MesherHelper self) -> bool

        rief Check if the shape set through IsQuadraticSubMesh() or SetSubShape()
        has a seam edge, i.e. an edge that has two parametric representations
        on a surface
        etval bool - true if it has

        :rtype: bool

        """
        return _SMESH.SMESH_MesherHelper_HasSeam(self, *args)


    def HasRealSeam(self, *args):
        """
        HasRealSeam(SMESH_MesherHelper self) -> bool

        rief Check if the shape set through IsQuadraticSubMesh() or SetSubShape()
        has a seam edge that encounters twice in a wire
        etval bool - true if it has

        :rtype: bool

        """
        return _SMESH.SMESH_MesherHelper_HasRealSeam(self, *args)


    def NbRealSeam(self, *args):
        """
        NbRealSeam(SMESH_MesherHelper self) -> size_t

        rief Return a number of real seam edges in the shape set through
        IsQuadraticSubMesh() or SetSubShape(). A real seam edge encounters twice in a wire
        etval size_t - nb of real seams

        :rtype: size_t

        """
        return _SMESH.SMESH_MesherHelper_NbRealSeam(self, *args)


    def GetPeriodicIndex(self, *args):
        """
        GetPeriodicIndex(SMESH_MesherHelper self) -> int

        rief Return index of periodic parametric direction of a closed face
        etval int - 1 for U, 2 for V direction

        :rtype: int

        """
        return _SMESH.SMESH_MesherHelper_GetPeriodicIndex(self, *args)


    def GetOtherParam(self, *args):
        """
        GetOtherParam(SMESH_MesherHelper self, double const param) -> double

        rief Return an alternative parameter for a node on seam

        :type param: const double
        :rtype: double

        """
        return _SMESH.SMESH_MesherHelper_GetOtherParam(self, *args)


    def IsOnSeam(self, *args):
        """
        IsOnSeam(SMESH_MesherHelper self, gp_XY uv) -> int

        rief Check if UV is on seam. Return 0 if not, 1 for U seam, 2 for V seam

        :type uv: OCC.wrapper.gp.gp_XY
        :rtype: int

        """
        return _SMESH.SMESH_MesherHelper_IsOnSeam(self, *args)


    def GetMediumNode(self, *args):
        """
        GetMediumNode(SMESH_MesherHelper self, SMDS_MeshNode n1, SMDS_MeshNode n2, bool const force3d, TopAbs_ShapeEnum expectedSupport=TopAbs_SHAPE) -> SMDS_MeshNode

        rief Return existing or create new medium nodes between given ones
        \param force3d - true means node creation at the middle between the
        two given nodes, else node position is found on its
        supporting geometrical shape, if any.
        \param expectedSupport - shape type corresponding to element being created
        , e.g TopAbs_EDGE if SMDSAbs_Edge is created
        basing on  n1 and  n2

        :type n1: OCC.wrapper.SMDS.SMDS_MeshNode
        :type n2: OCC.wrapper.SMDS.SMDS_MeshNode
        :type force3d: const bool
        :type expectedSupport: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.SMDS.SMDS_MeshNode

        """
        return _SMESH.SMESH_MesherHelper_GetMediumNode(self, *args)


    def GetCentralNode(self, *args):
        """
        GetCentralNode(SMESH_MesherHelper self, SMDS_MeshNode n1, SMDS_MeshNode n2, SMDS_MeshNode n3, SMDS_MeshNode n4, SMDS_MeshNode n12, SMDS_MeshNode n23, SMDS_MeshNode n34, SMDS_MeshNode n41, bool force3d) -> SMDS_MeshNode
        GetCentralNode(SMESH_MesherHelper self, SMDS_MeshNode n1, SMDS_MeshNode n2, SMDS_MeshNode n3, SMDS_MeshNode n12, SMDS_MeshNode n23, SMDS_MeshNode n31, bool force3d) -> SMDS_MeshNode

        rief Return existing or create a new central node for a 
        quadratic triangle given its 6 nodes.
        \param force3d - true means node creation in between the given nodes,
        else node position is found on a geometrical face if any.

        :type n1: OCC.wrapper.SMDS.SMDS_MeshNode
        :type n2: OCC.wrapper.SMDS.SMDS_MeshNode
        :type n3: OCC.wrapper.SMDS.SMDS_MeshNode
        :type n12: OCC.wrapper.SMDS.SMDS_MeshNode
        :type n23: OCC.wrapper.SMDS.SMDS_MeshNode
        :type n31: OCC.wrapper.SMDS.SMDS_MeshNode
        :type force3d: bool
        :rtype: OCC.wrapper.SMDS.SMDS_MeshNode

        """
        return _SMESH.SMESH_MesherHelper_GetCentralNode(self, *args)


    def GetMediumPos(self, *args):
        """
        GetMediumPos(SMESH_MesherHelper self, SMDS_MeshNode n1, SMDS_MeshNode n2, bool const useCurSubShape=False, TopAbs_ShapeEnum expectedSupport=TopAbs_SHAPE) -> std::pair< int,TopAbs_ShapeEnum >

        rief Return index and type of the shape (EDGE or FACE only) to set a medium node on

        :type n1: OCC.wrapper.SMDS.SMDS_MeshNode
        :type n2: OCC.wrapper.SMDS.SMDS_MeshNode
        :type useCurSubShape: const bool
        :type expectedSupport: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.SMESH.pair_TopAbs_ShapeEnum

        """
        return _SMESH.SMESH_MesherHelper_GetMediumPos(self, *args)


    def AddTLinkNode(self, *args):
        """
        AddTLinkNode(SMESH_MesherHelper self, SMDS_MeshNode n1, SMDS_MeshNode n2, SMDS_MeshNode n12)

        rief Add a link in my data structure

        :type n1: OCC.wrapper.SMDS.SMDS_MeshNode
        :type n2: OCC.wrapper.SMDS.SMDS_MeshNode
        :type n12: OCC.wrapper.SMDS.SMDS_MeshNode

        """
        return _SMESH.SMESH_MesherHelper_AddTLinkNode(self, *args)


    def AddTLinkNodeMap(self, *args):
        """
        AddTLinkNodeMap(SMESH_MesherHelper self, TLinkNodeMap const & aMap)

        rief Add many links in my data structure

        :type aMap: TLinkNodeMap

        """
        return _SMESH.SMESH_MesherHelper_AddTLinkNodeMap(self, *args)


    def AddTLinks(self, *args):
        """
        AddTLinks(SMESH_MesherHelper self, SMDS_MeshEdge edge) -> bool
        AddTLinks(SMESH_MesherHelper self, SMDS_MeshFace face) -> bool
        AddTLinks(SMESH_MesherHelper self, SMDS_MeshVolume vol) -> bool

        :type vol: OCC.wrapper.SMDS.SMDS_MeshVolume
        :rtype: bool

        """
        return _SMESH.SMESH_MesherHelper_AddTLinks(self, *args)


    def GetTLinkNodeMap(self, *args):
        """
        GetTLinkNodeMap(SMESH_MesherHelper self) -> TLinkNodeMap const &

        Returns myTLinkNodeMap

        :rtype: TLinkNodeMap

        """
        return _SMESH.SMESH_MesherHelper_GetTLinkNodeMap(self, *args)


    def IsQuadraticMesh(self, *args):
        """
        IsQuadraticMesh(SMESH_MesherHelper self) -> SMESH_MesherHelper::MType

        :rtype: MType

        """
        return _SMESH.SMESH_MesherHelper_IsQuadraticMesh(self, *args)


    def WriteShape(*args):
        """
        WriteShape(TopoDS_Shape s)

        :type s: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _SMESH.SMESH_MesherHelper_WriteShape(*args)

    WriteShape = staticmethod(WriteShape)
    __swig_destroy__ = _SMESH.delete_SMESH_MesherHelper
SMESH_MesherHelper_swigregister = _SMESH.SMESH_MesherHelper_swigregister
SMESH_MesherHelper_swigregister(SMESH_MesherHelper)

def SMESH_MesherHelper_IsSameElemGeometry(*args):
    """
    SMESH_MesherHelper_IsSameElemGeometry(SMESHDS_SubMesh smDS, SMDSAbs_GeometryType shape, bool const nullSubMeshRes=True) -> bool

    rief Returns true if all elements of a sub-mesh are of same shape
    \param smDS - sub-mesh to check elements of
    \param shape - expected shape of elements
    \param nullSubMeshRes - result value for the case of smDS == NULL
    etval bool - check result

    :type smDS: OCC.wrapper.SMESHDS.SMESHDS_SubMesh
    :type shape: OCC.wrapper.SMDSAbs.SMDSAbs_GeometryType
    :type nullSubMeshRes: const bool
    :rtype: bool

    """
    return _SMESH.SMESH_MesherHelper_IsSameElemGeometry(*args)

def SMESH_MesherHelper_LoadNodeColumns(*args):
    """
    LoadNodeColumns(TParam2ColumnMap & theParam2ColumnMap, TopoDS_Face theFace, std::list< TopoDS_Edge,std::allocator< TopoDS_Edge > > const & theBaseSide, SMESHDS_Mesh theMesh, SMESH_ProxyMesh theProxyMesh=None) -> bool
    SMESH_MesherHelper_LoadNodeColumns(TParam2ColumnMap & theParam2ColumnMap, TopoDS_Face theFace, TopoDS_Edge theBaseEdge, SMESHDS_Mesh theMesh, SMESH_ProxyMesh theProxyMesh=None) -> bool

    rief Variant of LoadNodeColumns() above with theBaseSide given by one edge

    :type theParam2ColumnMap: TParam2ColumnMap
    :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type theBaseEdge: OCC.wrapper.TopoDS.TopoDS_Edge
    :type theMesh: OCC.wrapper.SMESHDS.SMESHDS_Mesh
    :type theProxyMesh: OCC.wrapper.SMESH.SMESH_ProxyMesh
    :rtype: bool

    """
    return _SMESH.SMESH_MesherHelper_LoadNodeColumns(*args)

def SMESH_MesherHelper_IsStructured(*args):
    """
    SMESH_MesherHelper_IsStructured(SMESH_subMesh faceSM) -> bool

    rief Return true if 2D mesh on FACE is structured

    :type faceSM: OCC.wrapper.SMESH.SMESH_subMesh
    :rtype: bool

    """
    return _SMESH.SMESH_MesherHelper_IsStructured(*args)

def SMESH_MesherHelper_IsDistorted2D(*args):
    """
    SMESH_MesherHelper_IsDistorted2D(SMESH_subMesh faceSM, bool checkUV=False, SMESH_MesherHelper faceHelper=None) -> bool

    rief Return true if 2D mesh on FACE is distored

    :type faceSM: OCC.wrapper.SMESH.SMESH_subMesh
    :type checkUV: bool
    :type faceHelper: OCC.wrapper.SMESH.SMESH_MesherHelper
    :rtype: bool

    """
    return _SMESH.SMESH_MesherHelper_IsDistorted2D(*args)

def SMESH_MesherHelper_IsMedium(*args):
    """
    SMESH_MesherHelper_IsMedium(SMDS_MeshNode node, SMDSAbs_ElementType const typeToCheck=SMDSAbs_All) -> bool

    rief Returns true if given node is medium
    \param n - node to check
    \param typeToCheck - type of elements containing the node to ask about node status
    etval bool - check result

    :type node: OCC.wrapper.SMDS.SMDS_MeshNode
    :type typeToCheck: OCC.wrapper.SMDSAbs.SMDSAbs_ElementType
    :rtype: bool

    """
    return _SMESH.SMESH_MesherHelper_IsMedium(*args)

def SMESH_MesherHelper_GetSubShapeByNode(*args):
    """
    SMESH_MesherHelper_GetSubShapeByNode(SMDS_MeshNode node, SMESHDS_Mesh meshDS) -> TopoDS_Shape

    rief Return support shape of a node
    \param node - the node
    \param meshDS - mesh DS
    etval TopoDS_Shape - found support shape
    \sa SMESH_Algo::VertexNode( const TopoDS_Vertex&, SMESHDS_Mesh* )

    :type node: OCC.wrapper.SMDS.SMDS_MeshNode
    :type meshDS: OCC.wrapper.SMESHDS.SMESHDS_Mesh
    :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _SMESH.SMESH_MesherHelper_GetSubShapeByNode(*args)

def SMESH_MesherHelper_WrapIndex(*args):
    """
    SMESH_MesherHelper_WrapIndex(int ind, int const nbNodes) -> int

    rief Return a valid node index, fixing the given one if necessary
    \param ind - node index
    \param nbNodes - total nb of nodes
    etval int - valid node index

    :type ind: int
    :type nbNodes: const int
    :rtype: int

    """
    return _SMESH.SMESH_MesherHelper_WrapIndex(*args)

def SMESH_MesherHelper_calcTFI(*args):
    """
    calcTFI(double x, double y, gp_XY a0, gp_XY a1, gp_XY a2, gp_XY a3, gp_XY p0, gp_XY p1, gp_XY p2, gp_XY p3) -> gp_XY
    SMESH_MesherHelper_calcTFI(double x, double y, gp_XYZ a0, gp_XYZ a1, gp_XYZ a2, gp_XYZ a3, gp_XYZ p0, gp_XYZ p1, gp_XYZ p2, gp_XYZ p3) -> gp_XYZ

    rief Same as "gp_XY calcTFI(...)" but in 3D

    :type x: double
    :type y: double
    :type a0: OCC.wrapper.gp.gp_XYZ
    :type a1: OCC.wrapper.gp.gp_XYZ
    :type a2: OCC.wrapper.gp.gp_XYZ
    :type a3: OCC.wrapper.gp.gp_XYZ
    :type p0: OCC.wrapper.gp.gp_XYZ
    :type p1: OCC.wrapper.gp.gp_XYZ
    :type p2: OCC.wrapper.gp.gp_XYZ
    :type p3: OCC.wrapper.gp.gp_XYZ
    :rtype: OCC.wrapper.gp.gp_XYZ

    """
    return _SMESH.SMESH_MesherHelper_calcTFI(*args)

def SMESH_MesherHelper_Count(*args):
    """
    SMESH_MesherHelper_Count(TopoDS_Shape shape, TopAbs_ShapeEnum const type, bool const ignoreSame) -> int

    rief Count nb of sub-shapes
    \param shape - the shape
    \param type - the type of sub-shapes to count
    \param ignoreSame - if true, use map not to count same shapes, else use explorer
    etval int - the calculated number

    :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type type: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
    :type ignoreSame: const bool
    :rtype: int

    """
    return _SMESH.SMESH_MesherHelper_Count(*args)

def SMESH_MesherHelper_NbAncestors(*args):
    """
    SMESH_MesherHelper_NbAncestors(TopoDS_Shape shape, SMESH_Mesh mesh, TopAbs_ShapeEnum ancestorType=TopAbs_SHAPE) -> int

    rief Return number of unique ancestors of the shape

    :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type mesh: OCC.wrapper.SMESH.SMESH_Mesh
    :type ancestorType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
    :rtype: int

    """
    return _SMESH.SMESH_MesherHelper_NbAncestors(*args)

def SMESH_MesherHelper_GetAncestors(*args):
    """
    SMESH_MesherHelper_GetAncestors(TopoDS_Shape shape, SMESH_Mesh mesh, TopAbs_ShapeEnum ancestorType, TopoDS_Shape container=None) -> PShapeIteratorPtr

    rief Return iterator on ancestors of the given type, included into a container shape

    :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type mesh: OCC.wrapper.SMESH.SMESH_Mesh
    :type ancestorType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
    :type container: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: PShapeIteratorPtr

    """
    return _SMESH.SMESH_MesherHelper_GetAncestors(*args)

def SMESH_MesherHelper_GetCommonAncestor(*args):
    """
    SMESH_MesherHelper_GetCommonAncestor(TopoDS_Shape shape1, TopoDS_Shape shape2, SMESH_Mesh mesh, TopAbs_ShapeEnum ancestorType) -> TopoDS_Shape

    rief Find a common ancestor, of the given type, of two shapes

    :type shape1: OCC.wrapper.TopoDS.TopoDS_Shape
    :type shape2: OCC.wrapper.TopoDS.TopoDS_Shape
    :type mesh: OCC.wrapper.SMESH.SMESH_Mesh
    :type ancestorType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
    :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _SMESH.SMESH_MesherHelper_GetCommonAncestor(*args)

def SMESH_MesherHelper_GetSubShapeOri(*args):
    """
    SMESH_MesherHelper_GetSubShapeOri(TopoDS_Shape shape, TopoDS_Shape subShape) -> TopAbs_Orientation

    rief Return orientation of sub-shape in the main shape

    :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type subShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

    """
    return _SMESH.SMESH_MesherHelper_GetSubShapeOri(*args)

def SMESH_MesherHelper_IsSubShape(*args):
    """
    IsSubShape(TopoDS_Shape shape, TopoDS_Shape mainShape) -> bool
    SMESH_MesherHelper_IsSubShape(TopoDS_Shape shape, SMESH_Mesh aMesh) -> bool

    :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type aMesh: OCC.wrapper.SMESH.SMESH_Mesh
    :rtype: bool

    """
    return _SMESH.SMESH_MesherHelper_IsSubShape(*args)

def SMESH_MesherHelper_IsBlock(*args):
    """
    SMESH_MesherHelper_IsBlock(TopoDS_Shape shape) -> bool

    :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: bool

    """
    return _SMESH.SMESH_MesherHelper_IsBlock(*args)

def SMESH_MesherHelper_MaxTolerance(*args):
    """
    SMESH_MesherHelper_MaxTolerance(TopoDS_Shape shape) -> double

    :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: double

    """
    return _SMESH.SMESH_MesherHelper_MaxTolerance(*args)

def SMESH_MesherHelper_GetAngle(*args):
    """
    SMESH_MesherHelper_GetAngle(TopoDS_Edge E1, TopoDS_Edge E2, TopoDS_Face F, TopoDS_Vertex V, gp_Vec faceNormal=None) -> double

    :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
    :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type faceNormal: OCC.wrapper.gp.gp_Vec
    :rtype: double

    """
    return _SMESH.SMESH_MesherHelper_GetAngle(*args)

def SMESH_MesherHelper_IsClosedEdge(*args):
    """
    SMESH_MesherHelper_IsClosedEdge(TopoDS_Edge anEdge) -> bool

    :type anEdge: OCC.wrapper.TopoDS.TopoDS_Edge
    :rtype: bool

    """
    return _SMESH.SMESH_MesherHelper_IsClosedEdge(*args)

def SMESH_MesherHelper_IthVertex(*args):
    """
    SMESH_MesherHelper_IthVertex(bool const is2nd, TopoDS_Edge anEdge, bool const CumOri=True) -> TopoDS_Vertex

    :type is2nd: const bool
    :type anEdge: OCC.wrapper.TopoDS.TopoDS_Edge
    :type CumOri: const bool
    :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

    """
    return _SMESH.SMESH_MesherHelper_IthVertex(*args)

def SMESH_MesherHelper_GetGroupType(*args):
    """
    SMESH_MesherHelper_GetGroupType(TopoDS_Shape group, bool const avoidCompound=False) -> TopAbs_ShapeEnum

    :type group: OCC.wrapper.TopoDS.TopoDS_Shape
    :type avoidCompound: const bool
    :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

    """
    return _SMESH.SMESH_MesherHelper_GetGroupType(*args)

def SMESH_MesherHelper_GetShapeOfHypothesis(*args):
    """
    SMESH_MesherHelper_GetShapeOfHypothesis(SMESHDS_Hypothesis hyp, TopoDS_Shape shape, SMESH_Mesh mesh) -> TopoDS_Shape

    :type hyp: OCC.wrapper.SMESHDS.SMESHDS_Hypothesis
    :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type mesh: OCC.wrapper.SMESH.SMESH_Mesh
    :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _SMESH.SMESH_MesherHelper_GetShapeOfHypothesis(*args)

def SMESH_MesherHelper_GetMiddleUV(*args):
    """
    SMESH_MesherHelper_GetMiddleUV(Handle_Geom_Surface surface, gp_XY uv1, gp_XY uv2) -> gp_XY

    rief Return middle UV taking in account surface period

    :type surface: OCC.wrapper.Geom.Handle_Geom_Surface
    :type uv1: OCC.wrapper.gp.gp_XY
    :type uv2: OCC.wrapper.gp.gp_XY
    :rtype: OCC.wrapper.gp.gp_XY

    """
    return _SMESH.SMESH_MesherHelper_GetMiddleUV(*args)

def SMESH_MesherHelper_GetCenterUV(*args):
    """
    SMESH_MesherHelper_GetCenterUV(gp_XY uv1, gp_XY uv2, gp_XY uv3, gp_XY uv12, gp_XY uv23, gp_XY uv31, bool * isBadTria=None) -> gp_XY

    rief Return UV for the central node of a biquadratic triangle

    :type uv1: OCC.wrapper.gp.gp_XY
    :type uv2: OCC.wrapper.gp.gp_XY
    :type uv3: OCC.wrapper.gp.gp_XY
    :type uv12: OCC.wrapper.gp.gp_XY
    :type uv23: OCC.wrapper.gp.gp_XY
    :type uv31: OCC.wrapper.gp.gp_XY
    :type isBadTria: bool *
    :rtype: OCC.wrapper.gp.gp_XY

    """
    return _SMESH.SMESH_MesherHelper_GetCenterUV(*args)

def SMESH_MesherHelper_ApplyIn2D(*args):
    """
    SMESH_MesherHelper_ApplyIn2D(Handle_Geom_Surface surface, gp_XY uv1, gp_XY uv2, xyFunPtr fun, bool const resultInPeriod=True) -> gp_XY

    rief Perform given operation on two 2d points in parameric space of given surface.
    It takes into account period of the surface. Use gp_XY_FunPtr macro
    to easily define pointer to function of gp_XY class.

    :type surface: OCC.wrapper.Geom.Handle_Geom_Surface
    :type uv1: OCC.wrapper.gp.gp_XY
    :type uv2: OCC.wrapper.gp.gp_XY
    :type fun: xyFunPtr
    :type resultInPeriod: const bool
    :rtype: OCC.wrapper.gp.gp_XY

    """
    return _SMESH.SMESH_MesherHelper_ApplyIn2D(*args)

def SMESH_MesherHelper_WriteShape(*args):
    """
    SMESH_MesherHelper_WriteShape(TopoDS_Shape s)

    :type s: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _SMESH.SMESH_MesherHelper_WriteShape(*args)

class Handle_SMESH_MeshVSLink(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_SMESH_MeshVSLink self)

        Nullify the handle


        """
        return _SMESH.Handle_SMESH_MeshVSLink_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_SMESH_MeshVSLink self) -> bool

        Check for being null

        :rtype: bool

        """
        return _SMESH.Handle_SMESH_MeshVSLink_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_SMESH_MeshVSLink self, SMESH_MeshVSLink thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _SMESH.Handle_SMESH_MeshVSLink_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_SMESH_MeshVSLink self, Handle_SMESH_MeshVSLink theHandle) -> Handle_SMESH_MeshVSLink
        assign(Handle_SMESH_MeshVSLink self, SMESH_MeshVSLink thePtr) -> Handle_SMESH_MeshVSLink
        assign(Handle_SMESH_MeshVSLink self, Handle_SMESH_MeshVSLink theHandle) -> Handle_SMESH_MeshVSLink

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _SMESH.Handle_SMESH_MeshVSLink_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_SMESH_MeshVSLink self) -> SMESH_MeshVSLink

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _SMESH.Handle_SMESH_MeshVSLink_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_SMESH_MeshVSLink self) -> SMESH_MeshVSLink

        Member access operator (note non-const)

        :rtype: T *

        """
        return _SMESH.Handle_SMESH_MeshVSLink___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_SMESH_MeshVSLink self) -> SMESH_MeshVSLink

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _SMESH.Handle_SMESH_MeshVSLink___ref__(self, *args)


    def __hash__(self):
        return _SMESH.Handle_SMESH_MeshVSLink___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _SMESH.Handle_SMESH_MeshVSLink___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _SMESH.new_Handle_SMESH_MeshVSLink(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_SMESH.Handle_SMESH_MeshVSLink_DownCast)
    __swig_destroy__ = _SMESH.delete_Handle_SMESH_MeshVSLink

    def GetGeom(self, *args):
        """
        GetGeom(Handle_SMESH_MeshVSLink self, Standard_Integer const ID, Standard_Boolean const IsElement, NCollection_Array1_Standard_Real Coords) -> Standard_Boolean

        Returns geometry information about node ( if IsElement is False ) or element ( IsElement is True ) <br>
        by co-ordinates. For element this method must return all its nodes co-ordinates in the strict order: X, Y, Z and <br>
        with nodes order is the same as in wire bounding the face or link. NbNodes is number of nodes of element. <br>
        It is recommended to return 1 for node. Type is an element type. <br>

        :type ID: int
        :type IsElement: bool
        :type Coords: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type NbNodes: int
        :type Type: OCC.wrapper.MeshVS.MeshVS_EntityType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.Handle_SMESH_MeshVSLink_GetGeom(self, *args)


    def Get3DGeom(self, *args):
        """
        Get3DGeom(Handle_SMESH_MeshVSLink self, Standard_Integer const ID, Handle_MeshVS_HArray1OfSequenceOfInteger Data) -> Standard_Boolean

        :type ID: int
        :type NbNodes: int
        :type Data: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.Handle_SMESH_MeshVSLink_Get3DGeom(self, *args)


    def GetGeomType(self, *args):
        """
        GetGeomType(Handle_SMESH_MeshVSLink self, Standard_Integer const ID, Standard_Boolean const IsElement) -> Standard_Boolean

        This method is similar to GetGeom, but returns only element or node type. This method is provided for <br>
        a fine performance. <br>

        :type ID: int
        :type IsElement: bool
        :type Type: OCC.wrapper.MeshVS.MeshVS_EntityType
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.Handle_SMESH_MeshVSLink_GetGeomType(self, *args)


    def GetAddr(self, *args):
        """
        GetAddr(Handle_SMESH_MeshVSLink self, Standard_Integer const ID, Standard_Boolean const IsElement) -> Standard_Address

        This method returns by number an address of any entity which represents element or node data structure. <br>

        :type ID: int
        :type IsElement: bool
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _SMESH.Handle_SMESH_MeshVSLink_GetAddr(self, *args)


    def GetNodesByElement(self, *args):
        """
        GetNodesByElement(Handle_SMESH_MeshVSLink self, Standard_Integer const ID, NCollection_Array1_Standard_Integer NodeIDs) -> Standard_Boolean

        This method returns information about what node this element consist of. <br>

        :type ID: int
        :type NodeIDs: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type NbNodes: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.Handle_SMESH_MeshVSLink_GetNodesByElement(self, *args)


    def GetAllNodes(self, *args):
        """
        This method returns map of all nodes the object consist of. <br>

        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        res = _SMESH.Handle_SMESH_MeshVSLink_GetAllNodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetAllElements(self, *args):
        """
        This method returns map of all elements the object consist of. <br>

        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        res = _SMESH.Handle_SMESH_MeshVSLink_GetAllElements(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetNormal(self, *args):
        """
        GetNormal(Handle_SMESH_MeshVSLink self, Standard_Integer const Id, Standard_Integer const Max) -> Standard_Boolean

        This method calculates normal of face, which is using for correct reflection presentation. <br>
        There is default method, for advance reflection this method can be redefined. <br>

        :type Id: int
        :type Max: int
        :type nx: float
        :type ny: float
        :type nz: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.Handle_SMESH_MeshVSLink_GetNormal(self, *args)


    def GetAllGroups(self, *args):
        """
        GetAllGroups(Handle_SMESH_MeshVSLink self, TColStd_PackedMapOfInteger Ids)

        This method returns map of all groups the object contains. <br>

        :type Ids: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        return _SMESH.Handle_SMESH_MeshVSLink_GetAllGroups(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_SMESH_MeshVSLink self) -> char const *

        :rtype: const char *

        """
        return _SMESH.Handle_SMESH_MeshVSLink_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SMESH.Handle_SMESH_MeshVSLink_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _SMESH.Handle_SMESH_MeshVSLink_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetPrismTopology(self, *args):
        """
        GetPrismTopology(Handle_SMESH_MeshVSLink self, Standard_Integer const BasePoints) -> Handle_MeshVS_HArray1OfSequenceOfInteger

        :type BasePoints: int
        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger

        """
        return _SMESH.Handle_SMESH_MeshVSLink_GetPrismTopology(self, *args)


    def GetPyramidTopology(self, *args):
        """
        GetPyramidTopology(Handle_SMESH_MeshVSLink self, Standard_Integer const BasePoints) -> Handle_MeshVS_HArray1OfSequenceOfInteger

        :type BasePoints: int
        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger

        """
        return _SMESH.Handle_SMESH_MeshVSLink_GetPyramidTopology(self, *args)


    def CreatePrismTopology(self, *args):
        """
        CreatePrismTopology(Handle_SMESH_MeshVSLink self, Standard_Integer const BasePoints) -> Handle_MeshVS_HArray1OfSequenceOfInteger

        :type BasePoints: int
        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger

        """
        return _SMESH.Handle_SMESH_MeshVSLink_CreatePrismTopology(self, *args)


    def CreatePyramidTopology(self, *args):
        """
        CreatePyramidTopology(Handle_SMESH_MeshVSLink self, Standard_Integer const BasePoints) -> Handle_MeshVS_HArray1OfSequenceOfInteger

        :type BasePoints: int
        :rtype: OCC.wrapper.MeshVS.Handle_MeshVS_HArray1OfSequenceOfInteger

        """
        return _SMESH.Handle_SMESH_MeshVSLink_CreatePyramidTopology(self, *args)


    def GetNodeNormal(self, *args):
        """
        GetNodeNormal(Handle_SMESH_MeshVSLink self, Standard_Integer const ranknode, Standard_Integer const ElementId) -> Standard_Boolean

        This method return normal of node ranknode of face Id,
        which is using for smooth shading presentation.
        Returns false if normal isn't defined.

        :type ranknode: int
        :type ElementId: int
        :type nx: float
        :type ny: float
        :type nz: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.Handle_SMESH_MeshVSLink_GetNodeNormal(self, *args)


    def GetNormalsByElement(self, *args):
        """
        GetNormalsByElement(Handle_SMESH_MeshVSLink self, Standard_Integer const Id, Standard_Boolean const IsNodal, Standard_Integer const MaxNodes, Handle_TColStd_HArray1OfReal Normals) -> Standard_Boolean

        This method puts components of normal vectors at each node of a mesh face (at each face of a mesh volume)
        into the output array.
        Returns false if some problem was detected during calculation of normals.
        Id is an identifier of the mesh element.
        IsNodal, when true, means that normals at mesh element nodes are needed. If nodal normals
        are not available, or IsNodal is false, or the mesh element is a volume, then the output array contents
        depend on the element type:
        face: a normal calculated by GetNormal() is duplicated for each node of the face;
        volume: normals to all faces of the volume are computed (not for each node!).
        MaxNodes is maximal number of nodes an element can consist of.
        Normals contains the result.

        :type Id: int
        :type IsNodal: bool
        :type MaxNodes: int
        :type Normals: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.Handle_SMESH_MeshVSLink_GetNormalsByElement(self, *args)


    def GetGroup(self, *args):
        """
        GetGroup(Handle_SMESH_MeshVSLink self, Standard_Integer const Id, TColStd_PackedMapOfInteger Ids) -> Standard_Boolean

        This method returns map of all group elements.

        :type Id: int
        :type Type: OCC.wrapper.MeshVS.MeshVS_EntityType
        :type Ids: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.Handle_SMESH_MeshVSLink_GetGroup(self, *args)


    def GetGroupAddr(self, *args):
        """
        GetGroupAddr(Handle_SMESH_MeshVSLink self, Standard_Integer const ID) -> Standard_Address

        This method returns pointer which represents group data structure.
        This address will be saved in MeshVS_MeshOwner, so that you can access to data structure fast
        by the method Owner(). In the redefined method you can return NULL.
        ID is the numerical identificator of group

        :type ID: int
        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _SMESH.Handle_SMESH_MeshVSLink_GetGroupAddr(self, *args)


    def IsAdvancedSelectionEnabled(self, *args):
        """
        IsAdvancedSelectionEnabled(Handle_SMESH_MeshVSLink self) -> Standard_Boolean

        Returns True if advanced mesh selection is enabled.
        Default implementation returns False.
        It should be redefined to return True for advanced
        mesh selection activation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.Handle_SMESH_MeshVSLink_IsAdvancedSelectionEnabled(self, *args)


    def GetBoundingBox(self, *args):
        """
        GetBoundingBox(Handle_SMESH_MeshVSLink self) -> Bnd_Box

        Returns the bounding box of the whole mesh.
        It is used in advanced selection mode to define roughly
        the sensitive area of the mesh.
        It can be redefined to get access to a box computed in advance.

        :rtype: OCC.wrapper.Bnd.Bnd_Box

        """
        return _SMESH.Handle_SMESH_MeshVSLink_GetBoundingBox(self, *args)


    def GetDetectedEntities(self, *args):
        """
        GetDetectedEntities(Handle_SMESH_MeshVSLink self, Handle_MeshVS_Mesh Prs, Standard_Real const X, Standard_Real const Y, Standard_Real const aTol, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elements) -> Standard_Boolean
        GetDetectedEntities(Handle_SMESH_MeshVSLink self, Handle_MeshVS_Mesh Prs, Standard_Real const XMin, Standard_Real const YMin, Standard_Real const XMax, Standard_Real const YMax, Standard_Real const aTol, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elements) -> Standard_Boolean
        GetDetectedEntities(Handle_SMESH_MeshVSLink self, Handle_MeshVS_Mesh Prs, NCollection_Array1_gp_Pnt2d Polyline, Bnd_Box2d aBox, Standard_Real const aTol, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elements) -> Standard_Boolean
        GetDetectedEntities(Handle_SMESH_MeshVSLink self, Handle_MeshVS_Mesh Prs, Handle_TColStd_HPackedMapOfInteger Nodes, Handle_TColStd_HPackedMapOfInteger Elements) -> Standard_Boolean

        Filter out the maps of mesh entities so as to keep
        only the entities that are allowed to be selected
        according to the current context.
        Returns True if any of the maps has been changed.
        It should be redefined if the advanced mesh selection is
        activated. Default implementation returns False.

        :type Prs: OCC.wrapper.MeshVS.Handle_MeshVS_Mesh
        :type Nodes: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger
        :type Elements: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.Handle_SMESH_MeshVSLink_GetDetectedEntities(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_SMESH_MeshVSLink self)

        Memory deallocator for transient classes


        """
        return _SMESH.Handle_SMESH_MeshVSLink_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_SMESH_MeshVSLink self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_SMESH_MeshVSLink self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.Handle_SMESH_MeshVSLink_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_SMESH_MeshVSLink self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_SMESH_MeshVSLink self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _SMESH.Handle_SMESH_MeshVSLink_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_SMESH_MeshVSLink self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _SMESH.Handle_SMESH_MeshVSLink_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_SMESH_MeshVSLink self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SMESH.Handle_SMESH_MeshVSLink_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_SMESH_MeshVSLink self)

        Increments the reference counter of this object


        """
        return _SMESH.Handle_SMESH_MeshVSLink_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_SMESH_MeshVSLink self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _SMESH.Handle_SMESH_MeshVSLink_DecrementRefCounter(self, *args)

Handle_SMESH_MeshVSLink_swigregister = _SMESH.Handle_SMESH_MeshVSLink_swigregister
Handle_SMESH_MeshVSLink_swigregister(Handle_SMESH_MeshVSLink)

def Handle_SMESH_MeshVSLink_DownCast(thing):
    return _SMESH.Handle_SMESH_MeshVSLink_DownCast(thing)
Handle_SMESH_MeshVSLink_DownCast = _SMESH.Handle_SMESH_MeshVSLink_DownCast

class SMDS_Iterator_SMESH_OctreeNode(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def more(self, *args):
        """
        more(SMDS_Iterator_SMESH_OctreeNode self) -> bool

        Return true if and only if there are other object in this iterator

        :rtype: bool

        """
        return _SMESH.SMDS_Iterator_SMESH_OctreeNode_more(self, *args)


    def next(self, *args):
        """
        next(SMDS_Iterator_SMESH_OctreeNode self) -> SMESH_OctreeNode

        Return the current object and step to the next one

        :rtype: VALUE

        """
        return _SMESH.SMDS_Iterator_SMESH_OctreeNode_next(self, *args)


    def remove(self, *args):
        """
        remove(SMDS_Iterator_SMESH_OctreeNode self)

        Delete the current element and step to the next one


        """
        return _SMESH.SMDS_Iterator_SMESH_OctreeNode_remove(self, *args)

    __swig_destroy__ = _SMESH.delete_SMDS_Iterator_SMESH_OctreeNode
SMDS_Iterator_SMESH_OctreeNode_swigregister = _SMESH.SMDS_Iterator_SMESH_OctreeNode_swigregister
SMDS_Iterator_SMESH_OctreeNode_swigregister(SMDS_Iterator_SMESH_OctreeNode)


try:
	SMESH_OctreeNodeIterator = SMDS_Iterator_SMESH_OctreeNode
except NameError:
	pass # does not exist, probably ignored

class SMESH_Tree_Bnd_B3d_(object):
    """rief Base class for 2D and 3D trees"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def compute(self, *args):
        """
        compute(SMESH_Tree_Bnd_B3d_ self)

        rief Compute the Tree


        """
        return _SMESH.SMESH_Tree_Bnd_B3d__compute(self, *args)


    def isLeaf(self, *args):
        """
        isLeaf(SMESH_Tree_Bnd_B3d_ self) -> bool

        rief Tell if Tree is a leaf or not
        An inheriting class can influence it via myIsLeaf protected field

        :rtype: bool

        """
        return _SMESH.SMESH_Tree_Bnd_B3d__isLeaf(self, *args)


    def level(self, *args):
        """
        level(SMESH_Tree_Bnd_B3d_ self) -> int

        :rtype: int

        """
        return _SMESH.SMESH_Tree_Bnd_B3d__level(self, *args)


    def getBox(self, *args):
        """
        getBox(SMESH_Tree_Bnd_B3d_ self) -> Bnd_B3d

        :rtype: box_type

        """
        return _SMESH.SMESH_Tree_Bnd_B3d__getBox(self, *args)


    def getHeight(self, *args):
        """
        getHeight(SMESH_Tree_Bnd_B3d_ self, bool const full=True) -> int

        rief Return height of the tree, full or from this level to topest leaf

        :type full: const bool
        :rtype: int

        """
        return _SMESH.SMESH_Tree_Bnd_B3d__getHeight(self, *args)


    def nbChildren(*args):
        """
        nbChildren() -> int

        :rtype: int

        """
        return _SMESH.SMESH_Tree_Bnd_B3d__nbChildren(*args)

    nbChildren = staticmethod(nbChildren)

    def maxSize(self, *args):
        """
        maxSize(SMESH_Tree_Bnd_B3d_ self) -> double

        :rtype: double

        """
        return _SMESH.SMESH_Tree_Bnd_B3d__maxSize(self, *args)

    __swig_destroy__ = _SMESH.delete_SMESH_Tree_Bnd_B3d_
SMESH_Tree_Bnd_B3d__swigregister = _SMESH.SMESH_Tree_Bnd_B3d__swigregister
SMESH_Tree_Bnd_B3d__swigregister(SMESH_Tree_Bnd_B3d_)

def SMESH_Tree_Bnd_B3d__nbChildren(*args):
    """
    SMESH_Tree_Bnd_B3d__nbChildren() -> int

    :rtype: int

    """
    return _SMESH.SMESH_Tree_Bnd_B3d__nbChildren(*args)


try:
	TBaseTree = SMESH_Tree_Bnd_B3d_
except NameError:
	pass # does not exist, probably ignored




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_gp')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_gp')
    _gp = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_gp', [dirname(__file__)])
        except ImportError:
            import _gp
            return _gp
        try:
            _mod = imp.load_module('_gp', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _gp = swig_import_helper()
    del swig_import_helper
else:
    import _gp
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gp.delete_SwigPyIterator

    def value(self):
        return _gp.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _gp.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _gp.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _gp.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _gp.SwigPyIterator_equal(self, x)

    def copy(self):
        return _gp.SwigPyIterator_copy(self)

    def next(self):
        return _gp.SwigPyIterator_next(self)

    def __next__(self):
        return _gp.SwigPyIterator___next__(self)

    def previous(self):
        return _gp.SwigPyIterator_previous(self)

    def advance(self, n):
        return _gp.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _gp.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _gp.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _gp.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _gp.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _gp.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _gp.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _gp.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _gp.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_gp.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _gp.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _gp.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gp.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _gp.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _gp.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _gp.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _gp.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_gp.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _gp.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _gp.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gp.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _gp.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _gp.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _gp.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _gp.ptr_to_number(item)
ptr_to_number = _gp.ptr_to_number

def HashCode(*args):
    return _gp.HashCode(*args)
HashCode = _gp.HashCode

def ptr_equal(a, b):
    return _gp.ptr_equal(a, b)
ptr_equal = _gp.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
gp_Identity = _gp.gp_Identity
gp_Rotation = _gp.gp_Rotation
gp_Translation = _gp.gp_Translation
gp_PntMirror = _gp.gp_PntMirror
gp_Ax1Mirror = _gp.gp_Ax1Mirror
gp_Ax2Mirror = _gp.gp_Ax2Mirror
gp_Scale = _gp.gp_Scale
gp_CompoundTrsf = _gp.gp_CompoundTrsf
gp_Other = _gp.gp_Other
gp_EulerAngles = _gp.gp_EulerAngles
gp_YawPitchRoll = _gp.gp_YawPitchRoll
gp_Extrinsic_XYZ = _gp.gp_Extrinsic_XYZ
gp_Extrinsic_XZY = _gp.gp_Extrinsic_XZY
gp_Extrinsic_YZX = _gp.gp_Extrinsic_YZX
gp_Extrinsic_YXZ = _gp.gp_Extrinsic_YXZ
gp_Extrinsic_ZXY = _gp.gp_Extrinsic_ZXY
gp_Extrinsic_ZYX = _gp.gp_Extrinsic_ZYX
gp_Intrinsic_XYZ = _gp.gp_Intrinsic_XYZ
gp_Intrinsic_XZY = _gp.gp_Intrinsic_XZY
gp_Intrinsic_YZX = _gp.gp_Intrinsic_YZX
gp_Intrinsic_YXZ = _gp.gp_Intrinsic_YXZ
gp_Intrinsic_ZXY = _gp.gp_Intrinsic_ZXY
gp_Intrinsic_ZYX = _gp.gp_Intrinsic_ZYX
gp_Extrinsic_XYX = _gp.gp_Extrinsic_XYX
gp_Extrinsic_XZX = _gp.gp_Extrinsic_XZX
gp_Extrinsic_YZY = _gp.gp_Extrinsic_YZY
gp_Extrinsic_YXY = _gp.gp_Extrinsic_YXY
gp_Extrinsic_ZYZ = _gp.gp_Extrinsic_ZYZ
gp_Extrinsic_ZXZ = _gp.gp_Extrinsic_ZXZ
gp_Intrinsic_XYX = _gp.gp_Intrinsic_XYX
gp_Intrinsic_XZX = _gp.gp_Intrinsic_XZX
gp_Intrinsic_YZY = _gp.gp_Intrinsic_YZY
gp_Intrinsic_YXY = _gp.gp_Intrinsic_YXY
gp_Intrinsic_ZXZ = _gp.gp_Intrinsic_ZXZ
gp_Intrinsic_ZYZ = _gp.gp_Intrinsic_ZYZ
class gp_Trsf(object):
    """
    Defines a non-persistent transformation in 3D space.
    The following transformations are implemented :
    . Translation, Rotation, Scale
    . Symmetry with respect to a point, a line, a plane.
    Complex transformations can be obtained by combining the
    previous elementary transformations using the method
    Multiply.
    The transformations can be represented as follow :

    V1   V2   V3    T       XYZ        XYZ
    | a11  a12  a13   a14 |   | x |      | x'|
    | a21  a22  a23   a24 |   | y |      | y'|
    | a31  a32  a33   a34 |   | z |   =  | z'|
    |  0    0    0     1  |   | 1 |      | 1 |

    where {V1, V2, V3} defines the vectorial part of the
    transformation and T defines the translation part of the
    transformation.
    This transformation never change the nature of the objects.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Trsf self) -> gp_Trsf
        __init__(gp_Trsf self, gp_Trsf2d T) -> gp_Trsf

        Creates  a 3D transformation from the 2D transformation T.
        The resulting transformation has a homogeneous
        vectorial part, V3, and a translation part, T3, built from T:
        a11    a12
        0             a13
        V3 =    a21    a22    0       T3
        =   a23
        0    0    1.
        0
        It also has the same scale factor as T. This
        guarantees (by projection) that the transformation
        which would be performed by T in a plane (2D space)
        is performed by the resulting transformation in the xOy
        plane of the 3D space, (i.e. in the plane defined by the
        origin (0., 0., 0.) and the vectors DX (1., 0., 0.), and DY
        (0., 1., 0.)). The scale factor is applied to the entire space.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        this = _gp.new_gp_Trsf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetMirror(self, *args):
        """
        SetMirror(gp_Trsf self, gp_Pnt P)
        SetMirror(gp_Trsf self, gp_Ax1 A1)
        SetMirror(gp_Trsf self, gp_Ax2 A2)

        Makes the transformation into a symmetrical transformation.
        A2 is the center of the planar symmetry
        and defines the plane of symmetry by its origin, "X
        Direction" and "Y Direction".

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Trsf_SetMirror(self, *args)


    def SetRotation(self, *args):
        """
        SetRotation(gp_Trsf self, gp_Ax1 A1, Standard_Real const Ang)
        SetRotation(gp_Trsf self, gp_Quaternion R)

        Changes the transformation into a rotation defined by quaternion.
        Note that rotation is performed around origin, i.e.
        no translation is involved.

        :type R: OCC.wrapper.gp.gp_Quaternion

        """
        return _gp.gp_Trsf_SetRotation(self, *args)


    def SetScale(self, *args):
        """
        SetScale(gp_Trsf self, gp_Pnt P, Standard_Real const S)

        Changes the transformation into a scale.
        P is the center of the scale and S is the scaling value.
        Raises ConstructionError  If <S> is null.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _gp.gp_Trsf_SetScale(self, *args)


    def SetDisplacement(self, *args):
        """
        SetDisplacement(gp_Trsf self, gp_Ax3 FromSystem1, gp_Ax3 ToSystem2)

        Modifies this transformation so that it transforms the
        coordinate system defined by FromSystem1 into the
        one defined by ToSystem2. After this modification, this
        transformation transforms:
        -   the origin of FromSystem1 into the origin of ToSystem2,
        -   the "X Direction" of FromSystem1 into the "X
        Direction" of ToSystem2,
        -   the "Y Direction" of FromSystem1 into the "Y
        Direction" of ToSystem2, and
        -   the "main Direction" of FromSystem1 into the "main
        Direction" of ToSystem2.
        Warning
        When you know the coordinates of a point in one
        coordinate system and you want to express these
        coordinates in another one, do not use the
        transformation resulting from this function. Use the
        transformation that results from SetTransformation instead.
        SetDisplacement and SetTransformation create
        related transformations: the vectorial part of one is the
        inverse of the vectorial part of the other.

        :type FromSystem1: OCC.wrapper.gp.gp_Ax3
        :type ToSystem2: OCC.wrapper.gp.gp_Ax3

        """
        return _gp.gp_Trsf_SetDisplacement(self, *args)


    def SetTransformation(self, *args):
        """
        SetTransformation(gp_Trsf self, gp_Ax3 FromSystem1, gp_Ax3 ToSystem2)
        SetTransformation(gp_Trsf self, gp_Ax3 ToSystem)
        SetTransformation(gp_Trsf self, gp_Quaternion R, gp_Vec T)

        Sets transformation by directly specified rotation and translation.

        :type R: OCC.wrapper.gp.gp_Quaternion
        :type T: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Trsf_SetTransformation(self, *args)


    def SetTranslation(self, *args):
        """
        SetTranslation(gp_Trsf self, gp_Vec V)
        SetTranslation(gp_Trsf self, gp_Pnt P1, gp_Pnt P2)

        Makes the transformation into a translation where the translation vector
        is the vector (P1, P2) defined from point P1 to point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Trsf_SetTranslation(self, *args)


    def SetTranslationPart(self, *args):
        """
        SetTranslationPart(gp_Trsf self, gp_Vec V)

        Replaces the translation vector with the vector V.

        :type V: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Trsf_SetTranslationPart(self, *args)


    def SetScaleFactor(self, *args):
        """
        SetScaleFactor(gp_Trsf self, Standard_Real const S)

        Modifies the scale factor.
        Raises ConstructionError  If S is null.

        :type S: float

        """
        return _gp.gp_Trsf_SetScaleFactor(self, *args)


    def SetForm(self, *args):
        """
        SetForm(gp_Trsf self, gp_TrsfForm const P)

        :type P: OCC.wrapper.gp.gp_TrsfForm

        """
        return _gp.gp_Trsf_SetForm(self, *args)


    def SetValues(self, *args):
        """
        SetValues(gp_Trsf self, Standard_Real const a11, Standard_Real const a12, Standard_Real const a13, Standard_Real const a14, Standard_Real const a21, Standard_Real const a22, Standard_Real const a23, Standard_Real const a24, Standard_Real const a31, Standard_Real const a32, Standard_Real const a33, Standard_Real const a34)

        Sets the coefficients  of the transformation.  The
        transformation  of the  point  x,y,z is  the point
        x',y',z' with :

        x' = a11 x + a12 y + a13 z + a14
        y' = a21 x + a22 y + a23 z + a24
        z' = a31 x + a32 y + a33 z + a34

        The method Value(i,j) will return aij.
        Raises ConstructionError if the determinant of  the aij is null.
        The matrix is orthogonalized before future using.

        :type a11: float
        :type a12: float
        :type a13: float
        :type a14: float
        :type a21: float
        :type a22: float
        :type a23: float
        :type a24: float
        :type a31: float
        :type a32: float
        :type a33: float
        :type a34: float

        """
        return _gp.gp_Trsf_SetValues(self, *args)


    def IsNegative(self, *args):
        """
        IsNegative(gp_Trsf self) -> Standard_Boolean

        Returns true if the determinant of the vectorial part of
        this transformation is negative.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Trsf_IsNegative(self, *args)


    def Form(self, *args):
        """
        Form(gp_Trsf self) -> gp_TrsfForm

        Returns the nature of the transformation. It can be: an
        identity transformation, a rotation, a translation, a mirror
        transformation (relative to a point, an axis or a plane), a
        scaling transformation, or a compound transformation.

        :rtype: OCC.wrapper.gp.gp_TrsfForm

        """
        return _gp.gp_Trsf_Form(self, *args)


    def ScaleFactor(self, *args):
        """
        ScaleFactor(gp_Trsf self) -> Standard_Real

        Returns the scale factor.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Trsf_ScaleFactor(self, *args)


    def TranslationPart(self, *args):
        """
        Returns the translation part of the transformation's matrix

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        res = _gp.gp_Trsf_TranslationPart(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetRotation(self, *args):
        """
        GetRotation(gp_Trsf self, gp_XYZ theAxis) -> Standard_Boolean
        GetRotation(gp_Trsf self) -> gp_Quaternion

        Returns quaternion representing rotational part of the transformation.

        :rtype: OCC.wrapper.gp.gp_Quaternion

        """
        return _gp.gp_Trsf_GetRotation(self, *args)


    def VectorialPart(self, *args):
        """
        VectorialPart(gp_Trsf self) -> gp_Mat

        Returns the vectorial part of the transformation. It is
        a 3*3 matrix which includes the scale factor.

        :rtype: OCC.wrapper.gp.gp_Mat

        """
        return _gp.gp_Trsf_VectorialPart(self, *args)


    def HVectorialPart(self, *args):
        """
        Computes the homogeneous vectorial part of the transformation.
        It is a 3*3 matrix which doesn't include the scale factor.
        In other words, the vectorial part of this transformation is equal
        to its homogeneous vectorial part, multiplied by the scale factor.
        The coefficients of this matrix must be multiplied by the
        scale factor to obtain the coefficients of the transformation.

        :rtype: OCC.wrapper.gp.gp_Mat

        """
        res = _gp.gp_Trsf_HVectorialPart(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Value(self, *args):
        """
        Value(gp_Trsf self, Standard_Integer const Row, Standard_Integer const Col) -> Standard_Real

        Returns the coefficients of the transformation's matrix.
        It is a 3 rows * 4 columns matrix.
        This coefficient includes the scale factor.
        Raises OutOfRanged if Row < 1 or Row > 3 or Col < 1 or Col > 4

        :type Row: int
        :type Col: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Trsf_Value(self, *args)


    def Invert(self, *args):
        """Invert(gp_Trsf self)"""
        return _gp.gp_Trsf_Invert(self, *args)


    def Inverted(self, *args):
        """
        Inverted(gp_Trsf self) -> gp_Trsf

        Computes the reverse transformation
        Raises an exception if the matrix of the transformation
        is not inversible, it means that the scale factor is lower
        or equal to Resolution from package gp.
        Computes the transformation composed with T and  <me>.
        In a C++ implementation you can also write Tcomposed = <me> * T.
        Example :
        Trsf T1, T2, Tcomp; ...............
        Tcomp = T2.Multiplied(T1);         // or   (Tcomp = T2 * T1)
        Pnt P1(10.,3.,4.);
        Pnt P2 = P1.Transformed(Tcomp);    //using Tcomp
        Pnt P3 = P1.Transformed(T1);       //using T1 then T2
        P3.Transform(T2);                  // P3 = P2 !!!

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        return _gp.gp_Trsf_Inverted(self, *args)


    def Multiplied(self, *args):
        """
        Multiplied(gp_Trsf self, gp_Trsf T) -> gp_Trsf

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        return _gp.gp_Trsf_Multiplied(self, *args)


    def __mul__(self, *args):
        """
        __mul__(gp_Trsf self, gp_Trsf T) -> gp_Trsf

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        return _gp.gp_Trsf___mul__(self, *args)


    def Multiply(self, *args):
        """
        Multiply(gp_Trsf self, gp_Trsf T)

        Computes the transformation composed with <me> and T.
        <me> = <me> * T

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _gp.gp_Trsf_Multiply(self, *args)


    def __imul__(self, *args):
        """
        __imul__(gp_Trsf self, gp_Trsf T)

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _gp.gp_Trsf___imul__(self, *args)


    def PreMultiply(self, *args):
        """
        PreMultiply(gp_Trsf self, gp_Trsf T)

        Computes the transformation composed with <me> and T.
        <me> = T * <me>

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _gp.gp_Trsf_PreMultiply(self, *args)


    def Power(self, *args):
        """
        Power(gp_Trsf self, Standard_Integer const N)

        :type N: int

        """
        return _gp.gp_Trsf_Power(self, *args)


    def Powered(self, *args):
        """
        Powered(gp_Trsf self, Standard_Integer const N) -> gp_Trsf

        Computes the following composition of transformations
        <me> * <me> * .......* <me>, N time.
        if N = 0 <me> = Identity
        if N < 0 <me> = <me>.Inverse() *...........* <me>.Inverse().

        Raises if N < 0 and if the matrix of the transformation not
        inversible.

        :type N: int
        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        return _gp.gp_Trsf_Powered(self, *args)


    def Transforms(self, *args):
        """
        Transforms(gp_Trsf self)
        Transforms(gp_Trsf self, gp_XYZ Coord)

        Transformation of a triplet XYZ with a Trsf

        :type Coord: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_Trsf_Transforms(self, *args)

    __swig_destroy__ = _gp.delete_gp_Trsf
gp_Trsf_swigregister = _gp.gp_Trsf_swigregister
gp_Trsf_swigregister(gp_Trsf)

class gp_Torus(object):
    """
    Describes a torus.
    A torus is defined by its major and minor radii and
    positioned in space with a coordinate system (a gp_Ax3
    object) as follows:
    -   The origin of the coordinate system is the center of the torus;
    -   The surface is obtained by rotating a circle of radius
    equal to the minor radius of the torus about the "main
    Direction" of the coordinate system. This circle is
    located in the plane defined by the origin, the "X
    Direction" and the "main Direction" of the coordinate
    system. It is centered on the "X Axis" of this coordinate
    system, and located at a distance, from the origin of
    this coordinate system, equal to the major radius of the   torus;
    -   The "X Direction" and "Y Direction" define the
    reference plane of the torus.
    The coordinate system described above is the "local
    coordinate system" of the torus.
    Note: when a gp_Torus torus is converted into a
    Geom_ToroidalSurface torus, some implicit properties
    of its local coordinate system are used explicitly:
    -   its origin, "X Direction", "Y Direction" and "main
    Direction" are used directly to define the parametric
    directions on the torus and the origin of the parameters,
    -   its implicit orientation (right-handed or left-handed)
    gives the orientation (direct, indirect) to the
    Geom_ToroidalSurface torus.
    See Also
    gce_MakeTorus which provides functions for more
    complex torus constructions
    Geom_ToroidalSurface which provides additional
    functions for constructing tori and works, in particular,
    with the parametric equations of tori.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Torus self) -> gp_Torus
        __init__(gp_Torus self, gp_Ax3 A3, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> gp_Torus

        a torus centered on the origin of coordinate system
        A3, with major radius MajorRadius and minor radius
        MinorRadius, and with the reference plane defined
        by the origin, the "X Direction" and the "Y Direction" of A3.
        Warnings :
        It is not forbidden to create a torus with
        MajorRadius = MinorRadius = 0.0
        Raises ConstructionError if MinorRadius < 0.0 or if MajorRadius < 0.0

        :type A3: OCC.wrapper.gp.gp_Ax3
        :type MajorRadius: float
        :type MinorRadius: float

        """
        this = _gp.new_gp_Torus(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetAxis(self, *args):
        """
        SetAxis(gp_Torus self, gp_Ax1 A1)

        Modifies this torus, by redefining its local coordinate
        system so that:
        -   its origin and "main Direction" become those of the
        axis A1 (the "X Direction" and "Y Direction" are then recomputed).
        Raises ConstructionError if the direction of A1 is parallel to the "XDirection"
        of the coordinate system of the toroidal surface.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Torus_SetAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(gp_Torus self, gp_Pnt Loc)

        Changes the location of the torus.

        :type Loc: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Torus_SetLocation(self, *args)


    def SetMajorRadius(self, *args):
        """
        SetMajorRadius(gp_Torus self, Standard_Real const MajorRadius)

        Assigns value to the major radius  of this torus.
        Raises ConstructionError if MajorRadius - MinorRadius <= Resolution()

        :type MajorRadius: float

        """
        return _gp.gp_Torus_SetMajorRadius(self, *args)


    def SetMinorRadius(self, *args):
        """
        SetMinorRadius(gp_Torus self, Standard_Real const MinorRadius)

        Assigns value to the  minor radius of this torus.
        Raises ConstructionError if MinorRadius < 0.0 or if
        MajorRadius - MinorRadius <= Resolution from gp.

        :type MinorRadius: float

        """
        return _gp.gp_Torus_SetMinorRadius(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(gp_Torus self, gp_Ax3 A3)

        Changes the local coordinate system of the surface.

        :type A3: OCC.wrapper.gp.gp_Ax3

        """
        return _gp.gp_Torus_SetPosition(self, *args)


    def Area(self, *args):
        """
        Area(gp_Torus self) -> Standard_Real

        Computes the area of the torus.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Torus_Area(self, *args)


    def UReverse(self, *args):
        """
        UReverse(gp_Torus self)

        Reverses the   U   parametrization of   the  torus
        reversing the YAxis.


        """
        return _gp.gp_Torus_UReverse(self, *args)


    def VReverse(self, *args):
        """
        VReverse(gp_Torus self)

        Reverses the   V   parametrization of   the  torus
        reversing the ZAxis.


        """
        return _gp.gp_Torus_VReverse(self, *args)


    def Direct(self, *args):
        """
        Direct(gp_Torus self) -> Standard_Boolean

        returns true if the Ax3, the local coordinate system of this torus, is right handed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Torus_Direct(self, *args)


    def Axis(self, *args):
        """
        returns the symmetry axis of the torus.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        res = _gp.gp_Torus_Axis(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Coefficients(self, *args):
        """
        Coefficients(gp_Torus self, NCollection_Array1_Standard_Real Coef)

        Computes the coefficients of the implicit equation of the surface
        in the absolute Cartesian coordinate system:
        Coef(1) * X^4 + Coef(2) * Y^4 + Coef(3) * Z^4 +
        Coef(4) * X^3 * Y + Coef(5) * X^3 * Z + Coef(6) * Y^3 * X +
        Coef(7) * Y^3 * Z + Coef(8) * Z^3 * X + Coef(9) * Z^3 * Y +
        Coef(10) * X^2 * Y^2 + Coef(11) * X^2 * Z^2 +
        Coef(12) * Y^2 * Z^2 + Coef(13) * X^2 * Y * Z +
        Coef(14) * X * Y^2 * Z + Coef(15) * X * Y * Z^2 +
        Coef(16) * X^3 + Coef(17) * Y^3 + Coef(18) * Z^3 + 
        Coef(19) * X^2 * Y + Coef(20) * X^2 * Z + Coef(21) * Y^2 * X +
        Coef(22) * Y^2 * Z + Coef(23) * Z^2 * X + Coef(24) * Z^2 * Y +
        Coef(25) * X * Y * Z +
        Coef(26) * X^2 + Coef(27) * Y^2 + Coef(28) * Z^2 +
        Coef(29) * X * Y + Coef(30) * X * Z + Coef(31) * Y * Z +
        Coef(32) * X + Coef(33) * Y + Coef(34) *  Z + 
        Coef(35) = 0.0
        Raises DimensionError if the length of Coef is lower than 35.

        :type Coef: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _gp.gp_Torus_Coefficients(self, *args)


    def Location(self, *args):
        """
        Returns the Torus's location.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _gp.gp_Torus_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Position(self, *args):
        """
        Returns the local coordinates system of the torus.

        :rtype: OCC.wrapper.gp.gp_Ax3

        """
        res = _gp.gp_Torus_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MajorRadius(self, *args):
        """
        MajorRadius(gp_Torus self) -> Standard_Real

        returns the major radius of the torus.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Torus_MajorRadius(self, *args)


    def MinorRadius(self, *args):
        """
        MinorRadius(gp_Torus self) -> Standard_Real

        returns the minor radius of the torus.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Torus_MinorRadius(self, *args)


    def Volume(self, *args):
        """
        Volume(gp_Torus self) -> Standard_Real

        Computes the volume of the torus.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Torus_Volume(self, *args)


    def XAxis(self, *args):
        """
        XAxis(gp_Torus self) -> gp_Ax1

        returns the axis X of the torus.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Torus_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(gp_Torus self) -> gp_Ax1

        returns the axis Y of the torus.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Torus_YAxis(self, *args)


    def Mirror(self, *args):
        """
        Mirror(gp_Torus self, gp_Pnt P)
        Mirror(gp_Torus self, gp_Ax1 A1)
        Mirror(gp_Torus self, gp_Ax2 A2)

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Torus_Mirror(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(gp_Torus self, gp_Pnt P) -> gp_Torus
        Mirrored(gp_Torus self, gp_Ax1 A1) -> gp_Torus
        Mirrored(gp_Torus self, gp_Ax2 A2) -> gp_Torus

        Performs the symmetrical transformation of a torus with respect
        to a plane. The axis placement A2 locates the plane of the
        of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.gp.gp_Torus

        """
        return _gp.gp_Torus_Mirrored(self, *args)


    def Rotate(self, *args):
        """
        Rotate(gp_Torus self, gp_Ax1 A1, Standard_Real const Ang)

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _gp.gp_Torus_Rotate(self, *args)


    def Rotated(self, *args):
        """
        Rotated(gp_Torus self, gp_Ax1 A1, Standard_Real const Ang) -> gp_Torus

        Rotates a torus. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.gp.gp_Torus

        """
        return _gp.gp_Torus_Rotated(self, *args)


    def Scale(self, *args):
        """
        Scale(gp_Torus self, gp_Pnt P, Standard_Real const S)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _gp.gp_Torus_Scale(self, *args)


    def Scaled(self, *args):
        """
        Scaled(gp_Torus self, gp_Pnt P, Standard_Real const S) -> gp_Torus

        Scales a torus. S is the scaling value.
        The absolute value of S is used to scale the torus

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.gp.gp_Torus

        """
        return _gp.gp_Torus_Scaled(self, *args)


    def Transform(self, *args):
        """
        Transform(gp_Torus self, gp_Trsf T)

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _gp.gp_Torus_Transform(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_Torus self, gp_Trsf T) -> gp_Torus

        Transforms a torus with the transformation T from class Trsf.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_Torus

        """
        return _gp.gp_Torus_Transformed(self, *args)


    def Translate(self, *args):
        """
        Translate(gp_Torus self, gp_Vec V)
        Translate(gp_Torus self, gp_Pnt P1, gp_Pnt P2)

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Torus_Translate(self, *args)


    def Translated(self, *args):
        """
        Translated(gp_Torus self, gp_Vec V) -> gp_Torus
        Translated(gp_Torus self, gp_Pnt P1, gp_Pnt P2) -> gp_Torus

        Translates a torus from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.gp.gp_Torus

        """
        return _gp.gp_Torus_Translated(self, *args)

    __swig_destroy__ = _gp.delete_gp_Torus
gp_Torus_swigregister = _gp.gp_Torus_swigregister
gp_Torus_swigregister(gp_Torus)

class gp_Ax2d(object):
    """
    Describes an axis in the plane (2D space).
    An axis is defined by:
    -   its origin (also referred to as its "Location point"),   and
    -   its unit vector (referred to as its "Direction").
    An axis implicitly defines a direct, right-handed
    coordinate system in 2D space by:
    -   its origin,
    - its "Direction" (giving the "X Direction" of the coordinate system), and
    -   the unit vector normal to "Direction" (positive angle
    measured in the trigonometric sense).
    An axis is used:
    -   to describe 2D geometric entities (for example, the
    axis which defines angular coordinates on a circle).
    It serves for the same purpose as the STEP function
    "axis placement one axis", or
    -   to define geometric transformations (axis of
    symmetry, axis of rotation, and so on).
    Note: to define a left-handed 2D coordinate system, use gp_Ax22d.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Ax2d self) -> gp_Ax2d
        __init__(gp_Ax2d self, gp_Pnt2d P, gp_Dir2d V) -> gp_Ax2d

        Creates an Ax2d. <P> is the "Location" point of
        the axis placement and V is the "Direction" of
        the axis placement.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V: OCC.wrapper.gp.gp_Dir2d

        """
        this = _gp.new_gp_Ax2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetLocation(self, *args):
        """
        SetLocation(gp_Ax2d self, gp_Pnt2d Locat)

        Changes the "Location" point (origin) of <me>.

        :type Locat: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Ax2d_SetLocation(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(gp_Ax2d self, gp_Dir2d V)

        Changes the direction of <me>.

        :type V: OCC.wrapper.gp.gp_Dir2d

        """
        return _gp.gp_Ax2d_SetDirection(self, *args)


    def Location(self, *args):
        """
        Returns the origin of <me>.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _gp.gp_Ax2d_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Direction(self, *args):
        """
        Returns the direction of <me>.

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        res = _gp.gp_Ax2d_Direction(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsCoaxial(self, *args):
        """
        IsCoaxial(gp_Ax2d self, gp_Ax2d Other, Standard_Real const AngularTolerance, Standard_Real const LinearTolerance) -> Standard_Boolean

        Returns True if  :
        . the angle between <me> and <Other> is lower or equal
        to <AngularTolerance> and
        . the distance between <me>.Location() and <Other> is lower
        or equal to <LinearTolerance> and
        . the distance between <Other>.Location() and <me> is lower
        or equal to LinearTolerance.

        :type Other: OCC.wrapper.gp.gp_Ax2d
        :type AngularTolerance: float
        :type LinearTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Ax2d_IsCoaxial(self, *args)


    def IsNormal(self, *args):
        """
        IsNormal(gp_Ax2d self, gp_Ax2d Other, Standard_Real const AngularTolerance) -> Standard_Boolean

        Returns true if this axis and the axis Other are normal to
        each other. That is, if the angle between the two axes is equal to Pi/2 or -Pi/2.
        Note: the tolerance criterion is given by AngularTolerance.

        :type Other: OCC.wrapper.gp.gp_Ax2d
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Ax2d_IsNormal(self, *args)


    def IsOpposite(self, *args):
        """
        IsOpposite(gp_Ax2d self, gp_Ax2d Other, Standard_Real const AngularTolerance) -> Standard_Boolean

        Returns true if this axis and the axis Other are parallel,
        and have opposite orientations. That is, if the angle
        between the two axes is equal to Pi or -Pi.
        Note: the tolerance criterion is given by AngularTolerance.

        :type Other: OCC.wrapper.gp.gp_Ax2d
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Ax2d_IsOpposite(self, *args)


    def IsParallel(self, *args):
        """
        IsParallel(gp_Ax2d self, gp_Ax2d Other, Standard_Real const AngularTolerance) -> Standard_Boolean

        Returns true if this axis and the axis Other are parallel,
        and have either the same or opposite orientations. That
        is, if the angle between the two axes is equal to 0, Pi or -Pi.
        Note: the tolerance criterion is given by AngularTolerance.

        :type Other: OCC.wrapper.gp.gp_Ax2d
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Ax2d_IsParallel(self, *args)


    def Angle(self, *args):
        """
        Angle(gp_Ax2d self, gp_Ax2d Other) -> Standard_Real

        Computes the angle, in radians, between this axis and
        the axis Other. The value of the angle is between -Pi and Pi.

        :type Other: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Ax2d_Angle(self, *args)


    def Reverse(self, *args):
        """
        Reverse(gp_Ax2d self)

        Reverses the direction of <me> and assigns the result to this axis.


        """
        return _gp.gp_Ax2d_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(gp_Ax2d self) -> gp_Ax2d

        Computes a new axis placement with a direction opposite to
        the direction of <me>.

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Ax2d_Reversed(self, *args)


    def Mirror(self, *args):
        """
        Mirror(gp_Ax2d self, gp_Pnt2d P)
        Mirror(gp_Ax2d self, gp_Ax2d A)

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Ax2d_Mirror(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(gp_Ax2d self, gp_Pnt2d P) -> gp_Ax2d
        Mirrored(gp_Ax2d self, gp_Ax2d A) -> gp_Ax2d

        Performs the symmetrical transformation of an axis
        placement with respect to an axis placement which
        is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Ax2d_Mirrored(self, *args)


    def Rotate(self, *args):
        """
        Rotate(gp_Ax2d self, gp_Pnt2d P, Standard_Real const Ang)

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _gp.gp_Ax2d_Rotate(self, *args)


    def Rotated(self, *args):
        """
        Rotated(gp_Ax2d self, gp_Pnt2d P, Standard_Real const Ang) -> gp_Ax2d

        Rotates an axis placement. <P> is the center of the
        rotation . Ang is the angular value of the rotation
        in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Ax2d_Rotated(self, *args)


    def Scale(self, *args):
        """
        Scale(gp_Ax2d self, gp_Pnt2d P, Standard_Real const S)

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _gp.gp_Ax2d_Scale(self, *args)


    def Scaled(self, *args):
        """
        Scaled(gp_Ax2d self, gp_Pnt2d P, Standard_Real const S) -> gp_Ax2d

        Applies a scaling transformation on the axis placement.
        The "Location" point of the axisplacement is modified.
        The "Direction" is reversed if the scale is negative.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Ax2d_Scaled(self, *args)


    def Transform(self, *args):
        """
        Transform(gp_Ax2d self, gp_Trsf2d T)

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _gp.gp_Ax2d_Transform(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_Ax2d self, gp_Trsf2d T) -> gp_Ax2d

        Transforms an axis placement with a Trsf.

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Ax2d_Transformed(self, *args)


    def Translate(self, *args):
        """
        Translate(gp_Ax2d self, gp_Vec2d V)
        Translate(gp_Ax2d self, gp_Pnt2d P1, gp_Pnt2d P2)

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Ax2d_Translate(self, *args)


    def Translated(self, *args):
        """
        Translated(gp_Ax2d self, gp_Vec2d V) -> gp_Ax2d
        Translated(gp_Ax2d self, gp_Pnt2d P1, gp_Pnt2d P2) -> gp_Ax2d

        Translates an axis placement from the point <P1> to the
        point <P2>.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Ax2d_Translated(self, *args)

    __swig_destroy__ = _gp.delete_gp_Ax2d
gp_Ax2d_swigregister = _gp.gp_Ax2d_swigregister
gp_Ax2d_swigregister(gp_Ax2d)

class gp_Sphere(object):
    """
    Describes a sphere.
    A sphere is defined by its radius and positioned in space
    with a coordinate system (a gp_Ax3 object). The origin of
    the coordinate system is the center of the sphere. This
    coordinate system is the "local coordinate system" of the sphere.
    Note: when a gp_Sphere sphere is converted into a
    Geom_SphericalSurface sphere, some implicit
    properties of its local coordinate system are used explicitly:
    -   its origin, "X Direction", "Y Direction" and "main
    Direction" are used directly to define the parametric
    directions on the sphere and the origin of the parameters,
    -   its implicit orientation (right-handed or left-handed)
    gives the orientation (direct, indirect) to the
    Geom_SphericalSurface sphere.
    See Also
    gce_MakeSphere which provides functions for more
    complex sphere constructions
    Geom_SphericalSurface which provides additional
    functions for constructing spheres and works, in
    particular, with the parametric equations of spheres.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Sphere self) -> gp_Sphere
        __init__(gp_Sphere self, gp_Ax3 A3, Standard_Real const Radius) -> gp_Sphere

        Constructs a sphere with radius Radius, centered on the origin
        of A3.  A3 is the local coordinate system of the sphere.
        Warnings :
        It is not forbidden to create a sphere with null radius.
        Raises ConstructionError if Radius < 0.0

        :type A3: OCC.wrapper.gp.gp_Ax3
        :type Radius: float

        """
        this = _gp.new_gp_Sphere(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetLocation(self, *args):
        """
        SetLocation(gp_Sphere self, gp_Pnt Loc)

        Changes the center of the sphere.

        :type Loc: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Sphere_SetLocation(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(gp_Sphere self, gp_Ax3 A3)

        Changes the local coordinate system of the sphere.

        :type A3: OCC.wrapper.gp.gp_Ax3

        """
        return _gp.gp_Sphere_SetPosition(self, *args)


    def SetRadius(self, *args):
        """
        SetRadius(gp_Sphere self, Standard_Real const R)

        Assigns R the radius of the Sphere.
        Warnings :
        It is not forbidden to create a sphere with null radius.
        Raises ConstructionError if R < 0.0

        :type R: float

        """
        return _gp.gp_Sphere_SetRadius(self, *args)


    def Area(self, *args):
        """
        Area(gp_Sphere self) -> Standard_Real

        Computes the aera of the sphere.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Sphere_Area(self, *args)


    def Coefficients(self, *args):
        """
        Coefficients(gp_Sphere self)

        Computes the coefficients of the implicit equation of the quadric
        in the absolute cartesian coordinates system :
        A1.X**2 + A2.Y**2 + A3.Z**2 + 2.(B1.X.Y + B2.X.Z + B3.Y.Z) +
        2.(C1.X + C2.Y + C3.Z) + D = 0.0

        :type A1: float
        :type A2: float
        :type A3: float
        :type B1: float
        :type B2: float
        :type B3: float
        :type C1: float
        :type C2: float
        :type C3: float
        :type D: float

        """
        return _gp.gp_Sphere_Coefficients(self, *args)


    def UReverse(self, *args):
        """
        UReverse(gp_Sphere self)

        Reverses the   U   parametrization of   the sphere
        reversing the YAxis.


        """
        return _gp.gp_Sphere_UReverse(self, *args)


    def VReverse(self, *args):
        """
        VReverse(gp_Sphere self)

        Reverses the   V   parametrization of   the  sphere
        reversing the ZAxis.


        """
        return _gp.gp_Sphere_VReverse(self, *args)


    def Direct(self, *args):
        """
        Direct(gp_Sphere self) -> Standard_Boolean

        Returns true if the local coordinate system of this sphere
        is right-handed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Sphere_Direct(self, *args)


    def Location(self, *args):
        """
        --- Purpose ;
        Returns the center of the sphere.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _gp.gp_Sphere_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Position(self, *args):
        """
        Returns the local coordinates system of the sphere.

        :rtype: OCC.wrapper.gp.gp_Ax3

        """
        res = _gp.gp_Sphere_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Radius(self, *args):
        """
        Radius(gp_Sphere self) -> Standard_Real

        Returns the radius of the sphere.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Sphere_Radius(self, *args)


    def Volume(self, *args):
        """
        Volume(gp_Sphere self) -> Standard_Real

        Computes the volume of the sphere

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Sphere_Volume(self, *args)


    def XAxis(self, *args):
        """
        XAxis(gp_Sphere self) -> gp_Ax1

        Returns the axis X of the sphere.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Sphere_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(gp_Sphere self) -> gp_Ax1

        Returns the axis Y of the sphere.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Sphere_YAxis(self, *args)


    def Mirror(self, *args):
        """
        Mirror(gp_Sphere self, gp_Pnt P)
        Mirror(gp_Sphere self, gp_Ax1 A1)
        Mirror(gp_Sphere self, gp_Ax2 A2)

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Sphere_Mirror(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(gp_Sphere self, gp_Pnt P) -> gp_Sphere
        Mirrored(gp_Sphere self, gp_Ax1 A1) -> gp_Sphere
        Mirrored(gp_Sphere self, gp_Ax2 A2) -> gp_Sphere

        Performs the symmetrical transformation of a sphere with respect
        to a plane. The axis placement A2 locates the plane of the
        of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.gp.gp_Sphere

        """
        return _gp.gp_Sphere_Mirrored(self, *args)


    def Rotate(self, *args):
        """
        Rotate(gp_Sphere self, gp_Ax1 A1, Standard_Real const Ang)

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _gp.gp_Sphere_Rotate(self, *args)


    def Rotated(self, *args):
        """
        Rotated(gp_Sphere self, gp_Ax1 A1, Standard_Real const Ang) -> gp_Sphere

        Rotates a sphere. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.gp.gp_Sphere

        """
        return _gp.gp_Sphere_Rotated(self, *args)


    def Scale(self, *args):
        """
        Scale(gp_Sphere self, gp_Pnt P, Standard_Real const S)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _gp.gp_Sphere_Scale(self, *args)


    def Scaled(self, *args):
        """
        Scaled(gp_Sphere self, gp_Pnt P, Standard_Real const S) -> gp_Sphere

        Scales a sphere. S is the scaling value.
        The absolute value of S is used to scale the sphere

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.gp.gp_Sphere

        """
        return _gp.gp_Sphere_Scaled(self, *args)


    def Transform(self, *args):
        """
        Transform(gp_Sphere self, gp_Trsf T)

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _gp.gp_Sphere_Transform(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_Sphere self, gp_Trsf T) -> gp_Sphere

        Transforms a sphere with the transformation T from class Trsf.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_Sphere

        """
        return _gp.gp_Sphere_Transformed(self, *args)


    def Translate(self, *args):
        """
        Translate(gp_Sphere self, gp_Vec V)
        Translate(gp_Sphere self, gp_Pnt P1, gp_Pnt P2)

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Sphere_Translate(self, *args)


    def Translated(self, *args):
        """
        Translated(gp_Sphere self, gp_Vec V) -> gp_Sphere
        Translated(gp_Sphere self, gp_Pnt P1, gp_Pnt P2) -> gp_Sphere

        Translates a sphere from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.gp.gp_Sphere

        """
        return _gp.gp_Sphere_Translated(self, *args)

    __swig_destroy__ = _gp.delete_gp_Sphere
gp_Sphere_swigregister = _gp.gp_Sphere_swigregister
gp_Sphere_swigregister(gp_Sphere)

class gp_Parab(object):
    """
    Describes a parabola in 3D space.
    A parabola is defined by its focal length (that is, the
    distance between its focus and apex) and positioned in
    space with a coordinate system (a gp_Ax2 object)
    where:
    -   the origin of the coordinate system is on the apex of
    the parabola,
    -   the "X Axis" of the coordinate system is the axis of
    symmetry; the parabola is on the positive side of this axis, and
    -   the origin, "X Direction" and "Y Direction" of the
    coordinate system define the plane of the parabola.
    The equation of the parabola in this coordinate system,
    which is the "local coordinate system" of the parabola, is:
    Y**2 = (2*P) * X.
    where P, referred to as the parameter of the parabola, is
    the distance between the focus and the directrix (P is
    twice the focal length).
    The "main Direction" of the local coordinate system gives
    the normal vector to the plane of the parabola.
    See Also
    gce_MakeParab which provides functions for more
    complex parabola constructions
    Geom_Parabola which provides additional functions for
    constructing parabolas and works, in particular, with the
    parametric equations of parabolas
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Parab self) -> gp_Parab
        __init__(gp_Parab self, gp_Ax2 A2, Standard_Real const Focal) -> gp_Parab
        __init__(gp_Parab self, gp_Ax1 D, gp_Pnt F) -> gp_Parab

        D is the directrix of the parabola and F the focus point.
        The symmetry axis (XAxis) of the parabola is normal to the
        directrix and pass through the focus point F, but its
        location point is the vertex of the parabola.
        The YAxis of the parabola is parallel to D and its location
        point is the vertex of the parabola. The normal to the plane
        of the parabola is the cross product between the XAxis and the
        YAxis.

        :type D: OCC.wrapper.gp.gp_Ax1
        :type F: OCC.wrapper.gp.gp_Pnt

        """
        this = _gp.new_gp_Parab(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetAxis(self, *args):
        """
        SetAxis(gp_Parab self, gp_Ax1 A1)

        Modifies this parabola by redefining its local coordinate system so that
        -   its origin and "main Direction" become those of the
        axis A1 (the "X Direction" and "Y Direction" are then
        recomputed in the same way as for any gp_Ax2)
        Raises ConstructionError if the direction of A1 is parallel to the previous
        XAxis of the parabola.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Parab_SetAxis(self, *args)


    def SetFocal(self, *args):
        """
        SetFocal(gp_Parab self, Standard_Real const Focal)

        Changes the focal distance of the parabola.
        Raises ConstructionError if Focal < 0.0

        :type Focal: float

        """
        return _gp.gp_Parab_SetFocal(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(gp_Parab self, gp_Pnt P)

        Changes the location of the parabola. It is the vertex of
        the parabola.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Parab_SetLocation(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(gp_Parab self, gp_Ax2 A2)

        Changes the local coordinate system of the parabola.

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Parab_SetPosition(self, *args)


    def Axis(self, *args):
        """
        Returns the main axis of the parabola.
        It is the axis normal to the plane of the parabola passing
        through the vertex of the parabola.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        res = _gp.gp_Parab_Axis(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Directrix(self, *args):
        """
        Directrix(gp_Parab self) -> gp_Ax1

        Computes the directrix of this parabola.
        The directrix is:
        -   a line parallel to the "Y Direction" of the local
        coordinate system of this parabola, and
        -   located on the negative side of the axis of symmetry,
        at a distance from the apex which is equal to the focal
        length of this parabola.
        The directrix is returned as an axis (a gp_Ax1 object),
        the origin of which is situated on the "X Axis" of this parabola.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Parab_Directrix(self, *args)


    def Focal(self, *args):
        """
        Focal(gp_Parab self) -> Standard_Real

        Returns the distance between the vertex and the focus
        of the parabola.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Parab_Focal(self, *args)


    def Focus(self, *args):
        """
        Focus(gp_Parab self) -> gp_Pnt

        -   Computes the focus of the parabola.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Parab_Focus(self, *args)


    def Location(self, *args):
        """
        Returns the vertex of the parabola. It is the "Location"
        point of the coordinate system of the parabola.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _gp.gp_Parab_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Parameter(self, *args):
        """
        Parameter(gp_Parab self) -> Standard_Real

        Computes the parameter of the parabola.
        It is the distance between the focus and the directrix of
        the parabola. This distance is twice the focal length.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Parab_Parameter(self, *args)


    def Position(self, *args):
        """
        Returns the local coordinate system of the parabola.

        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        res = _gp.gp_Parab_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def XAxis(self, *args):
        """
        XAxis(gp_Parab self) -> gp_Ax1

        Returns the symmetry axis of the parabola. The location point
        of the axis is the vertex of the parabola.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Parab_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(gp_Parab self) -> gp_Ax1

        It is an axis parallel to the directrix of the parabola.
        The location point of this axis is the vertex of the parabola.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Parab_YAxis(self, *args)


    def Mirror(self, *args):
        """
        Mirror(gp_Parab self, gp_Pnt P)
        Mirror(gp_Parab self, gp_Ax1 A1)
        Mirror(gp_Parab self, gp_Ax2 A2)

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Parab_Mirror(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(gp_Parab self, gp_Pnt P) -> gp_Parab
        Mirrored(gp_Parab self, gp_Ax1 A1) -> gp_Parab
        Mirrored(gp_Parab self, gp_Ax2 A2) -> gp_Parab

        Performs the symmetrical transformation of a parabola
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.gp.gp_Parab

        """
        return _gp.gp_Parab_Mirrored(self, *args)


    def Rotate(self, *args):
        """
        Rotate(gp_Parab self, gp_Ax1 A1, Standard_Real const Ang)

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _gp.gp_Parab_Rotate(self, *args)


    def Rotated(self, *args):
        """
        Rotated(gp_Parab self, gp_Ax1 A1, Standard_Real const Ang) -> gp_Parab

        Rotates a parabola. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.gp.gp_Parab

        """
        return _gp.gp_Parab_Rotated(self, *args)


    def Scale(self, *args):
        """
        Scale(gp_Parab self, gp_Pnt P, Standard_Real const S)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _gp.gp_Parab_Scale(self, *args)


    def Scaled(self, *args):
        """
        Scaled(gp_Parab self, gp_Pnt P, Standard_Real const S) -> gp_Parab

        Scales a parabola. S is the scaling value.
        If S is negative the direction of the symmetry axis
        XAxis is reversed and the direction of the YAxis too.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.gp.gp_Parab

        """
        return _gp.gp_Parab_Scaled(self, *args)


    def Transform(self, *args):
        """
        Transform(gp_Parab self, gp_Trsf T)

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _gp.gp_Parab_Transform(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_Parab self, gp_Trsf T) -> gp_Parab

        Transforms a parabola with the transformation T from class Trsf.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_Parab

        """
        return _gp.gp_Parab_Transformed(self, *args)


    def Translate(self, *args):
        """
        Translate(gp_Parab self, gp_Vec V)
        Translate(gp_Parab self, gp_Pnt P1, gp_Pnt P2)

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Parab_Translate(self, *args)


    def Translated(self, *args):
        """
        Translated(gp_Parab self, gp_Vec V) -> gp_Parab
        Translated(gp_Parab self, gp_Pnt P1, gp_Pnt P2) -> gp_Parab

        Translates a parabola from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.gp.gp_Parab

        """
        return _gp.gp_Parab_Translated(self, *args)

    __swig_destroy__ = _gp.delete_gp_Parab
gp_Parab_swigregister = _gp.gp_Parab_swigregister
gp_Parab_swigregister(gp_Parab)

class gp_Ax1(object):
    """
    Describes an axis in 3D space.
    An axis is defined by:
    -   its origin (also referred to as its "Location point"), and
    -   its unit vector (referred to as its "Direction" or "main   Direction").
    An axis is used:
    -   to describe 3D geometric entities (for example, the
    axis of a revolution entity). It serves the same purpose
    as the STEP function "axis placement one axis", or
    -   to define geometric transformations (axis of
    symmetry, axis of rotation, and so on).
    For example, this entity can be used to locate a geometric entity
    or to define a symmetry axis.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Ax1 self) -> gp_Ax1
        __init__(gp_Ax1 self, gp_Pnt P, gp_Dir V) -> gp_Ax1

        P is the location point and V is the direction of <me>.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type V: OCC.wrapper.gp.gp_Dir

        """
        this = _gp.new_gp_Ax1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetDirection(self, *args):
        """
        SetDirection(gp_Ax1 self, gp_Dir V)

        Assigns V as the "Direction"  of this axis.

        :type V: OCC.wrapper.gp.gp_Dir

        """
        return _gp.gp_Ax1_SetDirection(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(gp_Ax1 self, gp_Pnt P)

        Assigns  P as the origin of this axis.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Ax1_SetLocation(self, *args)


    def Direction(self, *args):
        """
        Returns the direction of <me>.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _gp.gp_Ax1_Direction(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Location(self, *args):
        """
        Returns the location point of <me>.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _gp.gp_Ax1_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsCoaxial(self, *args):
        """
        IsCoaxial(gp_Ax1 self, gp_Ax1 Other, Standard_Real const AngularTolerance, Standard_Real const LinearTolerance) -> Standard_Boolean

        Returns True if  :
        . the angle between <me> and <Other> is lower or equal
        to <AngularTolerance> and
        . the distance between <me>.Location() and <Other> is lower
        or equal to <LinearTolerance> and
        . the distance between <Other>.Location() and <me> is lower
        or equal to LinearTolerance.

        :type Other: OCC.wrapper.gp.gp_Ax1
        :type AngularTolerance: float
        :type LinearTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Ax1_IsCoaxial(self, *args)


    def IsNormal(self, *args):
        """
        IsNormal(gp_Ax1 self, gp_Ax1 Other, Standard_Real const AngularTolerance) -> Standard_Boolean

        Returns True if the direction of the <me> and <Other>
        are normal to each other.
        That is, if the angle between the two axes is equal to Pi/2.
        Note: the tolerance criterion is given by AngularTolerance..

        :type Other: OCC.wrapper.gp.gp_Ax1
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Ax1_IsNormal(self, *args)


    def IsOpposite(self, *args):
        """
        IsOpposite(gp_Ax1 self, gp_Ax1 Other, Standard_Real const AngularTolerance) -> Standard_Boolean

        Returns True if the direction of <me> and <Other> are
        parallel with opposite orientation. That is, if the angle
        between the two axes is equal to Pi.
        Note: the tolerance criterion is given by AngularTolerance.

        :type Other: OCC.wrapper.gp.gp_Ax1
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Ax1_IsOpposite(self, *args)


    def IsParallel(self, *args):
        """
        IsParallel(gp_Ax1 self, gp_Ax1 Other, Standard_Real const AngularTolerance) -> Standard_Boolean

        Returns True if the direction of <me> and <Other> are
        parallel with same orientation or opposite orientation. That
        is, if the angle between the two axes is equal to 0 or Pi.
        Note: the tolerance criterion is given by
        AngularTolerance.

        :type Other: OCC.wrapper.gp.gp_Ax1
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Ax1_IsParallel(self, *args)


    def Angle(self, *args):
        """
        Angle(gp_Ax1 self, gp_Ax1 Other) -> Standard_Real

        Computes the angular value, in radians, between <me>.Direction() and
        <Other>.Direction(). Returns the angle between 0 and 2*PI
        radians.

        :type Other: OCC.wrapper.gp.gp_Ax1
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Ax1_Angle(self, *args)


    def Reverse(self, *args):
        """
        Reverse(gp_Ax1 self)

        Reverses the unit vector of this axis.
        and  assigns the result to this axis.


        """
        return _gp.gp_Ax1_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(gp_Ax1 self) -> gp_Ax1

        Reverses the unit vector of this axis and creates a new one.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Ax1_Reversed(self, *args)


    def Mirror(self, *args):
        """
        Mirror(gp_Ax1 self, gp_Pnt P)
        Mirror(gp_Ax1 self, gp_Ax1 A1)
        Mirror(gp_Ax1 self, gp_Ax2 A2)

        Performs the symmetrical transformation of an axis
        placement with respect to a plane. The axis placement
        <A2> locates the plane of the symmetry :
        (Location, XDirection, YDirection) and assigns the result to this axis.

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Ax1_Mirror(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(gp_Ax1 self, gp_Pnt P) -> gp_Ax1
        Mirrored(gp_Ax1 self, gp_Ax1 A1) -> gp_Ax1
        Mirrored(gp_Ax1 self, gp_Ax2 A2) -> gp_Ax1

        Performs the symmetrical transformation of an axis
        placement with respect to a plane. The axis placement
        <A2> locates the plane of the symmetry :
        (Location, XDirection, YDirection) and creates a new axis.

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Ax1_Mirrored(self, *args)


    def Rotate(self, *args):
        """
        Rotate(gp_Ax1 self, gp_Ax1 A1, Standard_Real const Ang)

        Rotates this axis at an angle Ang (in radians) about the axis A1
        and assigns the result to this axis.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _gp.gp_Ax1_Rotate(self, *args)


    def Rotated(self, *args):
        """
        Rotated(gp_Ax1 self, gp_Ax1 A1, Standard_Real const Ang) -> gp_Ax1

        Rotates this axis at an angle Ang (in radians) about the axis A1
        and creates a new one.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Ax1_Rotated(self, *args)


    def Scale(self, *args):
        """
        Scale(gp_Ax1 self, gp_Pnt P, Standard_Real const S)

        Applies a scaling transformation to this axis with:
        -   scale factor S, and
        -   center P and assigns the result to this axis.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _gp.gp_Ax1_Scale(self, *args)


    def Scaled(self, *args):
        """
        Scaled(gp_Ax1 self, gp_Pnt P, Standard_Real const S) -> gp_Ax1

        Applies a scaling transformation to this axis with:
        -   scale factor S, and
        -   center P and creates a new axis.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Ax1_Scaled(self, *args)


    def Transform(self, *args):
        """
        Transform(gp_Ax1 self, gp_Trsf T)

        Applies the transformation T to this axis.
        and assigns the result to this axis.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _gp.gp_Ax1_Transform(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_Ax1 self, gp_Trsf T) -> gp_Ax1

        Applies the transformation T to this axis and creates a new one.

        Translates an axis plaxement in the direction of the vector
        <V>. The magnitude of the translation is the vector's magnitude.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Ax1_Transformed(self, *args)


    def Translate(self, *args):
        """
        Translate(gp_Ax1 self, gp_Vec V)
        Translate(gp_Ax1 self, gp_Pnt P1, gp_Pnt P2)

        Translates this axis by:
        the vector (P1, P2) defined from point P1 to point P2.
        and assigns the result to this axis.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Ax1_Translate(self, *args)


    def Translated(self, *args):
        """
        Translated(gp_Ax1 self, gp_Vec V) -> gp_Ax1
        Translated(gp_Ax1 self, gp_Pnt P1, gp_Pnt P2) -> gp_Ax1

        Translates this axis by:
        the vector (P1, P2) defined from point P1 to point P2.
        and creates a new one.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Ax1_Translated(self, *args)

    __swig_destroy__ = _gp.delete_gp_Ax1
gp_Ax1_swigregister = _gp.gp_Ax1_swigregister
gp_Ax1_swigregister(gp_Ax1)

class gp_Hypr(object):
    """
    Describes a branch of a hyperbola in 3D space.
    A hyperbola is defined by its major and minor radii and
    positioned in space with a coordinate system (a gp_Ax2
    object) of which:
    -   the origin is the center of the hyperbola,
    -   the "X Direction" defines the major axis of the
    hyperbola, and
    - the "Y Direction" defines the minor axis of the hyperbola.
    The origin, "X Direction" and "Y Direction" of this
    coordinate system together define the plane of the
    hyperbola. This coordinate system is the "local
    coordinate system" of the hyperbola. In this coordinate
    system, the equation of the hyperbola is:
    X*X/(MajorRadius**2)-Y*Y/(MinorRadius**2) = 1.0
    The branch of the hyperbola described is the one located
    on the positive side of the major axis.
    The "main Direction" of the local coordinate system is a
    normal vector to the plane of the hyperbola. This vector
    gives an implicit orientation to the hyperbola. We refer to
    the "main Axis" of the local coordinate system as the
    "Axis" of the hyperbola.
    The following schema shows the plane of the hyperbola,
    and in it, the respective positions of the three branches of
    hyperbolas constructed with the functions OtherBranch,
    ConjugateBranch1, and ConjugateBranch2:

    ^YAxis
    |
    FirstConjugateBranch
    |
    Other            |                Main
    --------------------- C ------------------------------>XAxis
    Branch           |                Branch
    |
    |
    SecondConjugateBranch
    |                  ^YAxis
    Warning
    The major radius can be less than the minor radius.
    See Also
    gce_MakeHypr which provides functions for more
    complex hyperbola constructions
    Geom_Hyperbola which provides additional functions for
    constructing hyperbolas and works, in particular, with the
    parametric equations of hyperbolas
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Hypr self) -> gp_Hypr
        __init__(gp_Hypr self, gp_Ax2 A2, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> gp_Hypr

        Creates a hyperbola with radii MajorRadius and
        MinorRadius, positioned in the space by the
        coordinate system A2 such that:
        -   the origin of A2 is the center of the hyperbola,
        -   the "X Direction" of A2 defines the major axis of
        the hyperbola, that is, the major radius
        MajorRadius is measured along this axis, and
        -   the "Y Direction" of A2 defines the minor axis of
        the hyperbola, that is, the minor radius
        MinorRadius is measured along this axis.
        Note: This class does not prevent the creation of a
        hyperbola where:
        -   MajorAxis is equal to MinorAxis, or
        -   MajorAxis is less than MinorAxis.
        Exceptions
        Standard_ConstructionError if MajorAxis or MinorAxis is negative.
        Raises ConstructionError if MajorRadius < 0.0 or MinorRadius < 0.0
        Raised if MajorRadius < 0.0 or MinorRadius < 0.0

        :type A2: OCC.wrapper.gp.gp_Ax2
        :type MajorRadius: float
        :type MinorRadius: float

        """
        this = _gp.new_gp_Hypr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetAxis(self, *args):
        """
        SetAxis(gp_Hypr self, gp_Ax1 A1)

        Modifies this hyperbola, by redefining its local coordinate
        system so that:
        -   its origin and "main Direction" become those of the
        axis A1 (the "X Direction" and "Y Direction" are then
        recomputed in the same way as for any gp_Ax2).
        Raises ConstructionError if the direction of A1 is parallel to the direction of
        the "XAxis" of the hyperbola.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Hypr_SetAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(gp_Hypr self, gp_Pnt P)

        Modifies this hyperbola, by redefining its local coordinate
        system so that its origin becomes P.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Hypr_SetLocation(self, *args)


    def SetMajorRadius(self, *args):
        """
        SetMajorRadius(gp_Hypr self, Standard_Real const MajorRadius)

        Modifies the major  radius of this hyperbola.
        Exceptions
        Standard_ConstructionError if MajorRadius is negative.

        :type MajorRadius: float

        """
        return _gp.gp_Hypr_SetMajorRadius(self, *args)


    def SetMinorRadius(self, *args):
        """
        SetMinorRadius(gp_Hypr self, Standard_Real const MinorRadius)

        Modifies the minor  radius of this hyperbola.
        Exceptions
        Standard_ConstructionError if MinorRadius is negative.

        :type MinorRadius: float

        """
        return _gp.gp_Hypr_SetMinorRadius(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(gp_Hypr self, gp_Ax2 A2)

        Modifies this hyperbola, by redefining its local coordinate
        system so that it becomes A2.

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Hypr_SetPosition(self, *args)


    def Asymptote1(self, *args):
        """
        Asymptote1(gp_Hypr self) -> gp_Ax1

        In the local coordinate system of the hyperbola the equation of
        the hyperbola is (X*X)/(A*A) - (Y*Y)/(B*B) = 1.0 and the
        equation of the first asymptote is Y = (B/A)*X
        where A is the major radius and B is the minor radius. Raises ConstructionError if MajorRadius = 0.0

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Hypr_Asymptote1(self, *args)


    def Asymptote2(self, *args):
        """
        Asymptote2(gp_Hypr self) -> gp_Ax1

        In the local coordinate system of the hyperbola the equation of
        the hyperbola is (X*X)/(A*A) - (Y*Y)/(B*B) = 1.0 and the
        equation of the first asymptote is Y = -(B/A)*X.
        where A is the major radius and B is the minor radius. Raises ConstructionError if MajorRadius = 0.0

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Hypr_Asymptote2(self, *args)


    def Axis(self, *args):
        """
        Returns the axis passing through the center,
        and normal to the plane of this hyperbola.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        res = _gp.gp_Hypr_Axis(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ConjugateBranch1(self, *args):
        """
        ConjugateBranch1(gp_Hypr self) -> gp_Hypr

        Computes the branch of hyperbola which is on the positive side of the
        "YAxis" of <me>.

        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        return _gp.gp_Hypr_ConjugateBranch1(self, *args)


    def ConjugateBranch2(self, *args):
        """
        ConjugateBranch2(gp_Hypr self) -> gp_Hypr

        Computes the branch of hyperbola which is on the negative side of the
        "YAxis" of <me>.

        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        return _gp.gp_Hypr_ConjugateBranch2(self, *args)


    def Directrix1(self, *args):
        """
        Directrix1(gp_Hypr self) -> gp_Ax1

        This directrix is the line normal to the XAxis of the hyperbola
        in the local plane (Z = 0) at a distance d = MajorRadius / e
        from the center of the hyperbola, where e is the eccentricity of
        the hyperbola.
        This line is parallel to the "YAxis". The intersection point
        between the directrix1 and the "XAxis" is the "Location" point
        of the directrix1. This point is on the positive side of the
        "XAxis".

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Hypr_Directrix1(self, *args)


    def Directrix2(self, *args):
        """
        Directrix2(gp_Hypr self) -> gp_Ax1

        This line is obtained by the symmetrical transformation
        of "Directrix1" with respect to the "YAxis" of the hyperbola.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Hypr_Directrix2(self, *args)


    def Eccentricity(self, *args):
        """
        Eccentricity(gp_Hypr self) -> Standard_Real

        Returns the excentricity of the hyperbola (e > 1).
        If f is the distance between the location of the hyperbola
        and the Focus1 then the eccentricity e = f / MajorRadius. Raises DomainError if MajorRadius = 0.0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Hypr_Eccentricity(self, *args)


    def Focal(self, *args):
        """
        Focal(gp_Hypr self) -> Standard_Real

        Computes the focal distance. It is the distance between the
        the two focus of the hyperbola.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Hypr_Focal(self, *args)


    def Focus1(self, *args):
        """
        Focus1(gp_Hypr self) -> gp_Pnt

        Returns the first focus of the hyperbola. This focus is on the
        positive side of the "XAxis" of the hyperbola.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Hypr_Focus1(self, *args)


    def Focus2(self, *args):
        """
        Focus2(gp_Hypr self) -> gp_Pnt

        Returns the second focus of the hyperbola. This focus is on the
        negative side of the "XAxis" of the hyperbola.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Hypr_Focus2(self, *args)


    def Location(self, *args):
        """
        Returns  the location point of the hyperbola. It is the
        intersection point between the "XAxis" and the "YAxis".

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _gp.gp_Hypr_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MajorRadius(self, *args):
        """
        MajorRadius(gp_Hypr self) -> Standard_Real

        Returns the major radius of the hyperbola. It is the radius
        on the "XAxis" of the hyperbola.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Hypr_MajorRadius(self, *args)


    def MinorRadius(self, *args):
        """
        MinorRadius(gp_Hypr self) -> Standard_Real

        Returns the minor radius of the hyperbola. It is the radius
        on the "YAxis" of the hyperbola.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Hypr_MinorRadius(self, *args)


    def OtherBranch(self, *args):
        """
        OtherBranch(gp_Hypr self) -> gp_Hypr

        Returns the branch of hyperbola obtained by doing the
        symmetrical transformation of <me> with respect to the
        "YAxis"  of <me>.

        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        return _gp.gp_Hypr_OtherBranch(self, *args)


    def Parameter(self, *args):
        """
        Parameter(gp_Hypr self) -> Standard_Real

        Returns p = (e * e - 1) * MajorRadius where e is the
        eccentricity of the hyperbola.
        Raises DomainError if MajorRadius = 0.0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Hypr_Parameter(self, *args)


    def Position(self, *args):
        """
        Returns the coordinate system of the hyperbola.

        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        res = _gp.gp_Hypr_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def XAxis(self, *args):
        """
        XAxis(gp_Hypr self) -> gp_Ax1

        Computes an axis, whose
        -   the origin is the center of this hyperbola, and
        -   the unit vector is the "X Direction"
        of the local coordinate system of this hyperbola.
        These axes are, the major axis (the "X
        Axis") and  of this hyperboReturns the "XAxis" of the hyperbola.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Hypr_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(gp_Hypr self) -> gp_Ax1

        Computes an axis, whose
        -   the origin is the center of this hyperbola, and
        -   the unit vector is the "Y Direction"
        of the local coordinate system of this hyperbola.
        These axes are the minor axis (the "Y Axis") of this hyperbola

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Hypr_YAxis(self, *args)


    def Mirror(self, *args):
        """
        Mirror(gp_Hypr self, gp_Pnt P)
        Mirror(gp_Hypr self, gp_Ax1 A1)
        Mirror(gp_Hypr self, gp_Ax2 A2)

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Hypr_Mirror(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(gp_Hypr self, gp_Pnt P) -> gp_Hypr
        Mirrored(gp_Hypr self, gp_Ax1 A1) -> gp_Hypr
        Mirrored(gp_Hypr self, gp_Ax2 A2) -> gp_Hypr

        Performs the symmetrical transformation of an hyperbola with
        respect to a plane. The axis placement A2 locates the plane
        of the symmetry (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        return _gp.gp_Hypr_Mirrored(self, *args)


    def Rotate(self, *args):
        """
        Rotate(gp_Hypr self, gp_Ax1 A1, Standard_Real const Ang)

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _gp.gp_Hypr_Rotate(self, *args)


    def Rotated(self, *args):
        """
        Rotated(gp_Hypr self, gp_Ax1 A1, Standard_Real const Ang) -> gp_Hypr

        Rotates an hyperbola. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        return _gp.gp_Hypr_Rotated(self, *args)


    def Scale(self, *args):
        """
        Scale(gp_Hypr self, gp_Pnt P, Standard_Real const S)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _gp.gp_Hypr_Scale(self, *args)


    def Scaled(self, *args):
        """
        Scaled(gp_Hypr self, gp_Pnt P, Standard_Real const S) -> gp_Hypr

        Scales an hyperbola. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        return _gp.gp_Hypr_Scaled(self, *args)


    def Transform(self, *args):
        """
        Transform(gp_Hypr self, gp_Trsf T)

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _gp.gp_Hypr_Transform(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_Hypr self, gp_Trsf T) -> gp_Hypr

        Transforms an hyperbola with the transformation T from
        class Trsf.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        return _gp.gp_Hypr_Transformed(self, *args)


    def Translate(self, *args):
        """
        Translate(gp_Hypr self, gp_Vec V)
        Translate(gp_Hypr self, gp_Pnt P1, gp_Pnt P2)

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Hypr_Translate(self, *args)


    def Translated(self, *args):
        """
        Translated(gp_Hypr self, gp_Vec V) -> gp_Hypr
        Translated(gp_Hypr self, gp_Pnt P1, gp_Pnt P2) -> gp_Hypr

        Translates an hyperbola from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        return _gp.gp_Hypr_Translated(self, *args)

    __swig_destroy__ = _gp.delete_gp_Hypr
gp_Hypr_swigregister = _gp.gp_Hypr_swigregister
gp_Hypr_swigregister(gp_Hypr)

class gp_QuaternionSLerp(object):
    """
    Perform Spherical Linear Interpolation of the quaternions,
    return unit length quaternion.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_QuaternionSLerp self) -> gp_QuaternionSLerp
        __init__(gp_QuaternionSLerp self, gp_Quaternion theQStart, gp_Quaternion theQEnd) -> gp_QuaternionSLerp

        Constructor with initialization.

        :type theQStart: OCC.wrapper.gp.gp_Quaternion
        :type theQEnd: OCC.wrapper.gp.gp_Quaternion

        """
        this = _gp.new_gp_QuaternionSLerp(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(gp_QuaternionSLerp self, gp_Quaternion theQStart, gp_Quaternion theQEnd)

        Initialize the tool with Start and End values.

        :type theQStart: OCC.wrapper.gp.gp_Quaternion
        :type theQEnd: OCC.wrapper.gp.gp_Quaternion

        """
        return _gp.gp_QuaternionSLerp_Init(self, *args)


    def InitFromUnit(self, *args):
        """
        InitFromUnit(gp_QuaternionSLerp self, gp_Quaternion theQStart, gp_Quaternion theQEnd)

        Initialize the tool with Start and End unit quaternions.

        :type theQStart: OCC.wrapper.gp.gp_Quaternion
        :type theQEnd: OCC.wrapper.gp.gp_Quaternion

        """
        return _gp.gp_QuaternionSLerp_InitFromUnit(self, *args)


    def Interpolate(self, *args):
        """
        Interpolate(gp_QuaternionSLerp self, gp_Quaternion theQStart, gp_Quaternion theQEnd, Standard_Real theT) -> gp_Quaternion
        Interpolate(gp_QuaternionSLerp self, Standard_Real theT, gp_Quaternion theResultQ)

        Set interpolated quaternion for theT position (from 0.0 to 1.0)

        :type theT: float
        :type theResultQ: OCC.wrapper.gp.gp_Quaternion

        """
        return _gp.gp_QuaternionSLerp_Interpolate(self, *args)

    __swig_destroy__ = _gp.delete_gp_QuaternionSLerp
gp_QuaternionSLerp_swigregister = _gp.gp_QuaternionSLerp_swigregister
gp_QuaternionSLerp_swigregister(gp_QuaternionSLerp)

class gp_GTrsf2d(object):
    """
    Defines a non persistent transformation in 2D space.
    This transformation is a general transformation.
    It can be a Trsf2d from package gp, an affinity, or you can
    define your own transformation giving the corresponding
    matrix of transformation.

    With a GTrsf2d you can transform only a doublet of coordinates
    XY. It is not possible to transform other geometric objects
    because these transformations can change the nature of non-
    elementary geometric objects.
    A GTrsf2d is represented with a 2 rows * 3 columns matrix :

    V1   V2   T        XY         XY
    | a11  a12  a14 |   | x |      | x'|
    | a21  a22  a24 |   | y |      | y'|
    |  0    0    1  |   | 1 |      | 1 |

    where {V1, V2} defines the vectorial part of the
    transformation and T defines the translation part of
    the transformation.
    Warning
    A GTrsf2d transformation is only applicable on
    coordinates. Be careful if you apply such a
    transformation to all the points of a geometric object,
    as this can change the nature of the object and thus
    render it incoherent!
    Typically, a circle is transformed into an ellipse by an
    affinity transformation. To avoid modifying the nature of
    an object, use a gp_Trsf2d transformation instead, as
    objects of this class respect the nature of geometric objects.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_GTrsf2d self) -> gp_GTrsf2d
        __init__(gp_GTrsf2d self, gp_Trsf2d T) -> gp_GTrsf2d
        __init__(gp_GTrsf2d self, gp_Mat2d M, gp_XY V) -> gp_GTrsf2d

        Creates   a transformation based on the matrix M and the
        vector V where M defines the vectorial part of the
        transformation, and V the translation part.

        :type M: OCC.wrapper.gp.gp_Mat2d
        :type V: OCC.wrapper.gp.gp_XY

        """
        this = _gp.new_gp_GTrsf2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetAffinity(self, *args):
        """
        SetAffinity(gp_GTrsf2d self, gp_Ax2d A, Standard_Real const Ratio)

        Changes this transformation into an affinity of ratio Ratio
        with respect to the axis A.
        Note: An affinity is a point-by-point transformation that
        transforms any point P into a point P' such that if H is
        the orthogonal projection of P on the axis A, the vectors
        HP and HP' satisfy: HP' = Ratio * HP.

        :type A: OCC.wrapper.gp.gp_Ax2d
        :type Ratio: float

        """
        return _gp.gp_GTrsf2d_SetAffinity(self, *args)


    def SetValue(self, *args):
        """
        SetValue(gp_GTrsf2d self, Standard_Integer const Row, Standard_Integer const Col, Standard_Real const Value)

        Replaces   the coefficient (Row, Col) of the matrix representing
        this transformation by Value,
        Raises OutOfRange if Row < 1 or Row > 2 or Col < 1 or Col > 3

        :type Row: int
        :type Col: int
        :type Value: float

        """
        return _gp.gp_GTrsf2d_SetValue(self, *args)


    def SetTranslationPart(self, *args):
        """
        SetTranslationPart(gp_GTrsf2d self, gp_XY Coord)

        Replacesthe translation part of this
        transformation by the coordinates of the number pair Coord.

        :type Coord: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_GTrsf2d_SetTranslationPart(self, *args)


    def SetTrsf2d(self, *args):
        """
        SetTrsf2d(gp_GTrsf2d self, gp_Trsf2d T)

        Assigns the vectorial and translation parts of T to this transformation.

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _gp.gp_GTrsf2d_SetTrsf2d(self, *args)


    def SetVectorialPart(self, *args):
        """
        SetVectorialPart(gp_GTrsf2d self, gp_Mat2d Matrix)

        Replaces the vectorial part of this transformation by Matrix.

        :type Matrix: OCC.wrapper.gp.gp_Mat2d

        """
        return _gp.gp_GTrsf2d_SetVectorialPart(self, *args)


    def IsNegative(self, *args):
        """
        IsNegative(gp_GTrsf2d self) -> Standard_Boolean

        Returns true if the determinant of the vectorial part of
        this transformation is negative.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_GTrsf2d_IsNegative(self, *args)


    def IsSingular(self, *args):
        """
        IsSingular(gp_GTrsf2d self) -> Standard_Boolean

        Returns true if this transformation is singular (and
        therefore, cannot be inverted).
        Note: The Gauss LU decomposition is used to invert the
        transformation matrix. Consequently, the transformation
        is considered as singular if the largest pivot found is less
        than or equal to gp::Resolution().
        Warning
        If this transformation is singular, it cannot be inverted.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_GTrsf2d_IsSingular(self, *args)


    def Form(self, *args):
        """
        Form(gp_GTrsf2d self) -> gp_TrsfForm

        Returns the nature of the transformation.  It can be
        an identity transformation, a rotation, a translation, a mirror
        transformation (relative to a point or axis), a scaling
        transformation, a compound transformation or some
        other type of transformation.

        :rtype: OCC.wrapper.gp.gp_TrsfForm

        """
        return _gp.gp_GTrsf2d_Form(self, *args)


    def TranslationPart(self, *args):
        """
        Returns the translation part of the GTrsf2d.

        :rtype: OCC.wrapper.gp.gp_XY

        """
        res = _gp.gp_GTrsf2d_TranslationPart(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VectorialPart(self, *args):
        """
        Computes the vectorial part of the GTrsf2d. The returned
        Matrix is a 2*2 matrix.

        :rtype: OCC.wrapper.gp.gp_Mat2d

        """
        res = _gp.gp_GTrsf2d_VectorialPart(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Value(self, *args):
        """
        Value(gp_GTrsf2d self, Standard_Integer const Row, Standard_Integer const Col) -> Standard_Real

        Returns the coefficients of the global matrix of transformation.
        Raised OutOfRange if Row < 1 or Row > 2 or Col < 1 or Col > 3

        :type Row: int
        :type Col: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_GTrsf2d_Value(self, *args)


    def __call__(self, *args):
        """
        __call__(gp_GTrsf2d self, Standard_Integer const Row, Standard_Integer const Col) -> Standard_Real

        :type Row: int
        :type Col: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_GTrsf2d___call__(self, *args)


    def Invert(self, *args):
        """Invert(gp_GTrsf2d self)"""
        return _gp.gp_GTrsf2d_Invert(self, *args)


    def Inverted(self, *args):
        """
        Inverted(gp_GTrsf2d self) -> gp_GTrsf2d

        Computes the reverse transformation.
        Raised an exception if the matrix of the transformation
        is not inversible.

        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _gp.gp_GTrsf2d_Inverted(self, *args)


    def Multiplied(self, *args):
        """
        Multiplied(gp_GTrsf2d self, gp_GTrsf2d T) -> gp_GTrsf2d

        Computes the transformation composed with T and <me>.
        In a C++ implementation you can also write Tcomposed = <me> * T.
        Example :
        GTrsf2d T1, T2, Tcomp; ...............
        //composition :
        Tcomp = T2.Multiplied(T1);         // or   (Tcomp = T2 * T1)
        // transformation of a point
        XY P(10.,3.);
        XY P1(P);
        Tcomp.Transforms(P1);               //using Tcomp
        XY P2(P);
        T1.Transforms(P2);                  //using T1 then T2
        T2.Transforms(P2);                  // P1 = P2 !!!

        :type T: OCC.wrapper.gp.gp_GTrsf2d
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _gp.gp_GTrsf2d_Multiplied(self, *args)


    def __mul__(self, *args):
        """
        __mul__(gp_GTrsf2d self, gp_GTrsf2d T) -> gp_GTrsf2d

        :type T: OCC.wrapper.gp.gp_GTrsf2d
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _gp.gp_GTrsf2d___mul__(self, *args)


    def Multiply(self, *args):
        """
        Multiply(gp_GTrsf2d self, gp_GTrsf2d T)

        :type T: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _gp.gp_GTrsf2d_Multiply(self, *args)


    def __imul__(self, *args):
        """
        __imul__(gp_GTrsf2d self, gp_GTrsf2d T)

        :type T: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _gp.gp_GTrsf2d___imul__(self, *args)


    def PreMultiply(self, *args):
        """
        PreMultiply(gp_GTrsf2d self, gp_GTrsf2d T)

        Computes the product of the transformation T and this
        transformation, and assigns the result to this transformation:
        this = T * this

        :type T: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _gp.gp_GTrsf2d_PreMultiply(self, *args)


    def Power(self, *args):
        """
        Power(gp_GTrsf2d self, Standard_Integer const N)

        :type N: int

        """
        return _gp.gp_GTrsf2d_Power(self, *args)


    def Powered(self, *args):
        """
        Powered(gp_GTrsf2d self, Standard_Integer const N) -> gp_GTrsf2d

        Computes the following composition of transformations
        <me> * <me> * .......* <me>, N time.
        if N = 0 <me> = Identity
        if N < 0 <me> = <me>.Inverse() *...........* <me>.Inverse().

        Raises an exception if N < 0 and if the matrix of the
        transformation is not inversible.

        :type N: int
        :rtype: OCC.wrapper.gp.gp_GTrsf2d

        """
        return _gp.gp_GTrsf2d_Powered(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_GTrsf2d self, gp_XY Coord) -> gp_XY

        :type Coord: OCC.wrapper.gp.gp_XY
        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_GTrsf2d_Transformed(self, *args)


    def Transforms(self, *args):
        """
        Transforms(gp_GTrsf2d self, gp_XY Coord)
        Transforms(gp_GTrsf2d self)

        Applies this transformation to the coordinates:
        -   of the number pair Coord, or
        -   X and Y.

        Note:
        -   Transforms modifies X, Y, or the coordinate pair Coord, while
        -   Transformed creates a new coordinate pair.

        :type X: float
        :type Y: float

        """
        return _gp.gp_GTrsf2d_Transforms(self, *args)


    def Trsf2d(self, *args):
        """
        Trsf2d(gp_GTrsf2d self) -> gp_Trsf2d

        Converts this transformation into a gp_Trsf2d transformation.
        Exceptions
        Standard_ConstructionError if this transformation
        cannot be converted, i.e. if its form is gp_Other.

        :rtype: OCC.wrapper.gp.gp_Trsf2d

        """
        return _gp.gp_GTrsf2d_Trsf2d(self, *args)

    __swig_destroy__ = _gp.delete_gp_GTrsf2d
gp_GTrsf2d_swigregister = _gp.gp_GTrsf2d_swigregister
gp_GTrsf2d_swigregister(gp_GTrsf2d)

class gp_Circ(object):
    """
    Describes a circle in 3D space.
    A circle is defined by its radius and positioned in space
    with a coordinate system (a gp_Ax2 object) as follows:
    -   the origin of the coordinate system is the center of the circle, and
    -   the origin, "X Direction" and "Y Direction" of the
    coordinate system define the plane of the circle.
    This positioning coordinate system is the "local
    coordinate system" of the circle. Its "main Direction"
    gives the normal vector to the plane of the circle. The
    "main Axis" of the coordinate system is referred to as
    the "Axis" of the circle.
    Note: when a gp_Circ circle is converted into a
    Geom_Circle circle, some implicit properties of the
    circle are used explicitly:
    -   the "main Direction" of the local coordinate system
    gives an implicit orientation to the circle (and defines
    its trigonometric sense),
    -   this orientation corresponds to the direction in
    which parameter values increase,
    -   the starting point for parameterization is that of the
    "X Axis" of the local coordinate system (i.e. the "X Axis" of the circle).
    See Also
    gce_MakeCirc which provides functions for more complex circle constructions
    Geom_Circle which provides additional functions for
    constructing circles and works, in particular, with the
    parametric equations of circles
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Circ self) -> gp_Circ
        __init__(gp_Circ self, gp_Ax2 A2, Standard_Real const Radius) -> gp_Circ

        A2 locates the circle and gives its orientation in 3D space.
        Warnings :
        It is not forbidden to create a circle with Radius = 0.0  Raises ConstructionError if Radius < 0.0

        :type A2: OCC.wrapper.gp.gp_Ax2
        :type Radius: float

        """
        this = _gp.new_gp_Circ(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetAxis(self, *args):
        """
        SetAxis(gp_Circ self, gp_Ax1 A1)

        Changes the main axis of the circle. It is the axis
        perpendicular to the plane of the circle.
        Raises ConstructionError if the direction of A1
        is parallel to the "XAxis" of the circle.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Circ_SetAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(gp_Circ self, gp_Pnt P)

        Changes the "Location" point (center) of the circle.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Circ_SetLocation(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(gp_Circ self, gp_Ax2 A2)

        Changes the position of the circle.

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Circ_SetPosition(self, *args)


    def SetRadius(self, *args):
        """
        SetRadius(gp_Circ self, Standard_Real const Radius)

        Modifies the radius of this circle.
        Warning. This class does not prevent the creation of a circle where Radius is null.
        Exceptions
        Standard_ConstructionError if Radius is negative.

        :type Radius: float

        """
        return _gp.gp_Circ_SetRadius(self, *args)


    def Area(self, *args):
        """
        Area(gp_Circ self) -> Standard_Real

        Computes the area of the circle.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Circ_Area(self, *args)


    def Axis(self, *args):
        """
        Returns the main axis of the circle.
        It is the axis perpendicular to the plane of the circle,
        passing through the "Location" point (center) of the circle.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        res = _gp.gp_Circ_Axis(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Length(self, *args):
        """
        Length(gp_Circ self) -> Standard_Real

        Computes the circumference of the circle.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Circ_Length(self, *args)


    def Location(self, *args):
        """
        Returns the center of the circle. It is the
        "Location" point of the local coordinate system
        of the circle

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _gp.gp_Circ_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Position(self, *args):
        """
        Returns the position of the circle.
        It is the local coordinate system of the circle.

        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        res = _gp.gp_Circ_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Radius(self, *args):
        """
        Radius(gp_Circ self) -> Standard_Real

        Returns the radius of this circle.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Circ_Radius(self, *args)


    def XAxis(self, *args):
        """
        XAxis(gp_Circ self) -> gp_Ax1

        Returns the "XAxis" of the circle.
        This axis is perpendicular to the axis of the conic.
        This axis and the "Yaxis" define the plane of the conic.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Circ_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(gp_Circ self) -> gp_Ax1

        Returns the "YAxis" of the circle.
        This axis and the "Xaxis" define the plane of the conic.
        The "YAxis" is perpendicular to the "Xaxis".

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Circ_YAxis(self, *args)


    def Distance(self, *args):
        """
        Distance(gp_Circ self, gp_Pnt P) -> Standard_Real

        Computes the minimum of distance between the point P and
        any point on the circumference of the circle.

        :type P: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Circ_Distance(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(gp_Circ self, gp_Pnt P) -> Standard_Real

        Computes the square distance between <me> and the point P.

        :type P: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Circ_SquareDistance(self, *args)


    def Contains(self, *args):
        """
        Contains(gp_Circ self, gp_Pnt P, Standard_Real const LinearTolerance) -> Standard_Boolean

        Returns True if the point P is on the circumference.
        The distance between <me> and <P> must be lower or
        equal to LinearTolerance.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type LinearTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Circ_Contains(self, *args)


    def Mirror(self, *args):
        """
        Mirror(gp_Circ self, gp_Pnt P)
        Mirror(gp_Circ self, gp_Ax1 A1)
        Mirror(gp_Circ self, gp_Ax2 A2)

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Circ_Mirror(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(gp_Circ self, gp_Pnt P) -> gp_Circ
        Mirrored(gp_Circ self, gp_Ax1 A1) -> gp_Circ
        Mirrored(gp_Circ self, gp_Ax2 A2) -> gp_Circ

        Performs the symmetrical transformation of a circle with respect
        to a plane. The axis placement A2 locates the plane of the
        of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _gp.gp_Circ_Mirrored(self, *args)


    def Rotate(self, *args):
        """
        Rotate(gp_Circ self, gp_Ax1 A1, Standard_Real const Ang)

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _gp.gp_Circ_Rotate(self, *args)


    def Rotated(self, *args):
        """
        Rotated(gp_Circ self, gp_Ax1 A1, Standard_Real const Ang) -> gp_Circ

        Rotates a circle. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _gp.gp_Circ_Rotated(self, *args)


    def Scale(self, *args):
        """
        Scale(gp_Circ self, gp_Pnt P, Standard_Real const S)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _gp.gp_Circ_Scale(self, *args)


    def Scaled(self, *args):
        """
        Scaled(gp_Circ self, gp_Pnt P, Standard_Real const S) -> gp_Circ

        Scales a circle. S is the scaling value.
        Warnings :
        If S is negative the radius stay positive but
        the "XAxis" and the "YAxis" are  reversed as for
        an ellipse.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _gp.gp_Circ_Scaled(self, *args)


    def Transform(self, *args):
        """
        Transform(gp_Circ self, gp_Trsf T)

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _gp.gp_Circ_Transform(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_Circ self, gp_Trsf T) -> gp_Circ

        Transforms a circle with the transformation T from class Trsf.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _gp.gp_Circ_Transformed(self, *args)


    def Translate(self, *args):
        """
        Translate(gp_Circ self, gp_Vec V)
        Translate(gp_Circ self, gp_Pnt P1, gp_Pnt P2)

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Circ_Translate(self, *args)


    def Translated(self, *args):
        """
        Translated(gp_Circ self, gp_Vec V) -> gp_Circ
        Translated(gp_Circ self, gp_Pnt P1, gp_Pnt P2) -> gp_Circ

        Translates a circle from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _gp.gp_Circ_Translated(self, *args)

    __swig_destroy__ = _gp.delete_gp_Circ
gp_Circ_swigregister = _gp.gp_Circ_swigregister
gp_Circ_swigregister(gp_Circ)

class gp_XYZ(object):
    """
    This class describes a cartesian coordinate entity in
    3D space {X,Y,Z}. This entity is used for algebraic
    calculation. This entity can be transformed
    with a "Trsf" or a  "GTrsf" from package "gp".
    It is used in vectorial computations or for holding this type
    of information in data structures.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_XYZ self) -> gp_XYZ
        __init__(gp_XYZ self, Standard_Real const X, Standard_Real const Y, Standard_Real const Z) -> gp_XYZ

        creates an XYZ with given coordinates

        :type X: float
        :type Y: float
        :type Z: float

        """
        this = _gp.new_gp_XYZ(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetCoord(self, *args):
        """
        SetCoord(gp_XYZ self, Standard_Real const X, Standard_Real const Y, Standard_Real const Z)
        SetCoord(gp_XYZ self, Standard_Integer const Index, Standard_Real const Xi)

        modifies the coordinate of range Index
        Index = 1 => X is modified
        Index = 2 => Y is modified
        Index = 3 => Z is modified
        Raises OutOfRange if Index != {1, 2, 3}.

        :type Index: int
        :type Xi: float

        """
        return _gp.gp_XYZ_SetCoord(self, *args)


    def SetX(self, *args):
        """
        SetX(gp_XYZ self, Standard_Real const X)

        Assigns the given value to the X coordinate

        :type X: float

        """
        return _gp.gp_XYZ_SetX(self, *args)


    def SetY(self, *args):
        """
        SetY(gp_XYZ self, Standard_Real const Y)

        Assigns the given value to the Y coordinate

        :type Y: float

        """
        return _gp.gp_XYZ_SetY(self, *args)


    def SetZ(self, *args):
        """
        SetZ(gp_XYZ self, Standard_Real const Z)

        Assigns the given value to the Z coordinate

        :type Z: float

        """
        return _gp.gp_XYZ_SetZ(self, *args)


    def ChangeCoord(self, *args):
        """
        ChangeCoord(gp_XYZ self, Standard_Integer const theIndex) -> Standard_Real &

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_XYZ_ChangeCoord(self, *args)


    def Coord(self, *args):
        """
        Coord(gp_XYZ self, Standard_Integer const Index) -> Standard_Real
        Coord(gp_XYZ self)

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _gp.gp_XYZ_Coord(self, *args)


    def GetData(self, *args):
        """
        GetData(gp_XYZ self) -> Standard_Real const *

        Returns a const ptr to coordinates location.
        Is useful for algorithms, but DOES NOT PERFORM
        ANY CHECKS!

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_XYZ_GetData(self, *args)


    def ChangeData(self, *args):
        """
        ChangeData(gp_XYZ self) -> Standard_Real *

        Returns a ptr to coordinates location.
        Is useful for algorithms, but DOES NOT PERFORM
        ANY CHECKS!

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_XYZ_ChangeData(self, *args)


    def X(self, *args):
        """
        X(gp_XYZ self) -> Standard_Real

        Returns the X coordinate

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_XYZ_X(self, *args)


    def Y(self, *args):
        """
        Y(gp_XYZ self) -> Standard_Real

        Returns the Y coordinate

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_XYZ_Y(self, *args)


    def Z(self, *args):
        """
        Z(gp_XYZ self) -> Standard_Real

        Returns the Z coordinate

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_XYZ_Z(self, *args)


    def Modulus(self, *args):
        """
        Modulus(gp_XYZ self) -> Standard_Real

        computes Sqrt (X*X + Y*Y + Z*Z) where X, Y and Z are the three coordinates of this XYZ object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_XYZ_Modulus(self, *args)


    def SquareModulus(self, *args):
        """
        SquareModulus(gp_XYZ self) -> Standard_Real

        Computes X*X + Y*Y + Z*Z where X, Y and Z are the three coordinates of this XYZ object.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_XYZ_SquareModulus(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(gp_XYZ self, gp_XYZ Other, Standard_Real const Tolerance) -> Standard_Boolean

        Returns True if he coordinates of this XYZ object are
        equal to the respective coordinates Other,
        within the specified tolerance Tolerance. I.e.:
        abs(<me>.X() - Other.X()) <= Tolerance and
        abs(<me>.Y() - Other.Y()) <= Tolerance and
        abs(<me>.Z() - Other.Z()) <= Tolerance.

        :type Other: OCC.wrapper.gp.gp_XYZ
        :type Tolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_XYZ_IsEqual(self, *args)


    def Add(self, *args):
        """
        Add(gp_XYZ self, gp_XYZ Other)

        <me>.X() = <me>.X() + Other.X()
        <me>.Y() = <me>.Y() + Other.Y()
        <me>.Z() = <me>.Z() + Other.Z()

        :type Other: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_XYZ_Add(self, *args)


    def __iadd__(self, *args):
        """
        __iadd__(gp_XYZ self, gp_XYZ Other)

        :type Other: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_XYZ___iadd__(self, *args)


    def Added(self, *args):
        """
        Added(gp_XYZ self, gp_XYZ Other) -> gp_XYZ

        new.X() = <me>.X() + Other.X()
        new.Y() = <me>.Y() + Other.Y()
        new.Z() = <me>.Z() + Other.Z()

        :type Other: OCC.wrapper.gp.gp_XYZ
        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_XYZ_Added(self, *args)


    def __add__(self, *args):
        """
        __add__(gp_XYZ self, gp_XYZ Other) -> gp_XYZ

        :type Other: OCC.wrapper.gp.gp_XYZ
        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_XYZ___add__(self, *args)


    def Cross(self, *args):
        """
        Cross(gp_XYZ self, gp_XYZ Right)

        <me>.X() = <me>.Y() * Other.Z() - <me>.Z() * Other.Y()
        <me>.Y() = <me>.Z() * Other.X() - <me>.X() * Other.Z()
        <me>.Z() = <me>.X() * Other.Y() - <me>.Y() * Other.X()

        :type Right: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_XYZ_Cross(self, *args)


    def __ixor__(self, *args):
        """
        __ixor__(gp_XYZ self, gp_XYZ Right)

        :type Right: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_XYZ___ixor__(self, *args)


    def Crossed(self, *args):
        """
        Crossed(gp_XYZ self, gp_XYZ Right) -> gp_XYZ

        new.X() = <me>.Y() * Other.Z() - <me>.Z() * Other.Y()
        new.Y() = <me>.Z() * Other.X() - <me>.X() * Other.Z()
        new.Z() = <me>.X() * Other.Y() - <me>.Y() * Other.X()

        :type Right: OCC.wrapper.gp.gp_XYZ
        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_XYZ_Crossed(self, *args)


    def __xor__(self, *args):
        """
        __xor__(gp_XYZ self, gp_XYZ Right) -> gp_XYZ

        :type Right: OCC.wrapper.gp.gp_XYZ
        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_XYZ___xor__(self, *args)


    def CrossMagnitude(self, *args):
        """
        CrossMagnitude(gp_XYZ self, gp_XYZ Right) -> Standard_Real

        Computes the magnitude of the cross product between <me> and
        Right. Returns || <me> ^ Right ||

        :type Right: OCC.wrapper.gp.gp_XYZ
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_XYZ_CrossMagnitude(self, *args)


    def CrossSquareMagnitude(self, *args):
        """
        CrossSquareMagnitude(gp_XYZ self, gp_XYZ Right) -> Standard_Real

        Computes the square magnitude of the cross product between <me> and
        Right. Returns || <me> ^ Right ||**2

        :type Right: OCC.wrapper.gp.gp_XYZ
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_XYZ_CrossSquareMagnitude(self, *args)


    def CrossCross(self, *args):
        """
        CrossCross(gp_XYZ self, gp_XYZ Coord1, gp_XYZ Coord2)

        Triple vector product
        Computes <me> = <me>.Cross(Coord1.Cross(Coord2))

        :type Coord1: OCC.wrapper.gp.gp_XYZ
        :type Coord2: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_XYZ_CrossCross(self, *args)


    def CrossCrossed(self, *args):
        """
        CrossCrossed(gp_XYZ self, gp_XYZ Coord1, gp_XYZ Coord2) -> gp_XYZ

        Triple vector product
        computes New = <me>.Cross(Coord1.Cross(Coord2))

        :type Coord1: OCC.wrapper.gp.gp_XYZ
        :type Coord2: OCC.wrapper.gp.gp_XYZ
        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_XYZ_CrossCrossed(self, *args)


    def Divide(self, *args):
        """
        Divide(gp_XYZ self, Standard_Real const Scalar)

        divides <me> by a real.

        :type Scalar: float

        """
        return _gp.gp_XYZ_Divide(self, *args)


    def __itruediv__(self, *args):
        return _gp.gp_XYZ___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def Divided(self, *args):
        """
        Divided(gp_XYZ self, Standard_Real const Scalar) -> gp_XYZ

        divides <me> by a real.

        :type Scalar: float
        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_XYZ_Divided(self, *args)


    def __truediv__(self, *args):
        return _gp.gp_XYZ___truediv__(self, *args)
    __div__ = __truediv__



    def Dot(self, *args):
        """
        Dot(gp_XYZ self, gp_XYZ Other) -> Standard_Real

        computes the scalar product between <me> and Other

        :type Other: OCC.wrapper.gp.gp_XYZ
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_XYZ_Dot(self, *args)


    def DotCross(self, *args):
        """
        DotCross(gp_XYZ self, gp_XYZ Coord1, gp_XYZ Coord2) -> Standard_Real

        computes the triple scalar product

        :type Coord1: OCC.wrapper.gp.gp_XYZ
        :type Coord2: OCC.wrapper.gp.gp_XYZ
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_XYZ_DotCross(self, *args)


    def Multiply(self, *args):
        """
        Multiply(gp_XYZ self, Standard_Real const Scalar)
        Multiply(gp_XYZ self, gp_XYZ Other)
        Multiply(gp_XYZ self, gp_Mat Matrix)

        <me> = Matrix * <me>

        :type Matrix: OCC.wrapper.gp.gp_Mat

        """
        return _gp.gp_XYZ_Multiply(self, *args)


    def __imul__(self, *args):
        """
        __imul__(gp_XYZ self, Standard_Real const Scalar)
        __imul__(gp_XYZ self, gp_XYZ Other)
        __imul__(gp_XYZ self, gp_Mat Matrix)

        :type Matrix: OCC.wrapper.gp.gp_Mat

        """
        return _gp.gp_XYZ___imul__(self, *args)


    def Multiplied(self, *args):
        """
        Multiplied(gp_XYZ self, Standard_Real const Scalar) -> gp_XYZ
        Multiplied(gp_XYZ self, gp_XYZ Other) -> gp_XYZ
        Multiplied(gp_XYZ self, gp_Mat Matrix) -> gp_XYZ

        New = Matrix * <me>

        :type Matrix: OCC.wrapper.gp.gp_Mat
        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_XYZ_Multiplied(self, *args)


    def __mul__(self, *args):
        """
        __mul__(gp_XYZ self, gp_XYZ Other) -> Standard_Real
        __mul__(gp_XYZ self, Standard_Real const Scalar) -> gp_XYZ
        __mul__(gp_XYZ self, gp_Mat Matrix) -> gp_XYZ

        :type Matrix: OCC.wrapper.gp.gp_Mat
        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_XYZ___mul__(self, *args)


    def Normalize(self, *args):
        """
        Normalize(gp_XYZ self)

        <me>.X() = <me>.X()/ <me>.Modulus()
        <me>.Y() = <me>.Y()/ <me>.Modulus()
        <me>.Z() = <me>.Z()/ <me>.Modulus()
        Raised if <me>.Modulus() <= Resolution from gp


        """
        return _gp.gp_XYZ_Normalize(self, *args)


    def Normalized(self, *args):
        """
        Normalized(gp_XYZ self) -> gp_XYZ

        New.X() = <me>.X()/ <me>.Modulus()
        New.Y() = <me>.Y()/ <me>.Modulus()
        New.Z() = <me>.Z()/ <me>.Modulus()
        Raised if <me>.Modulus() <= Resolution from gp

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_XYZ_Normalized(self, *args)


    def Reverse(self, *args):
        """
        Reverse(gp_XYZ self)

        <me>.X() = -<me>.X()
        <me>.Y() = -<me>.Y()
        <me>.Z() = -<me>.Z()


        """
        return _gp.gp_XYZ_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(gp_XYZ self) -> gp_XYZ

        New.X() = -<me>.X()
        New.Y() = -<me>.Y()
        New.Z() = -<me>.Z()

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_XYZ_Reversed(self, *args)


    def Subtract(self, *args):
        """
        Subtract(gp_XYZ self, gp_XYZ Right)

        <me>.X() = <me>.X() - Other.X()
        <me>.Y() = <me>.Y() - Other.Y()
        <me>.Z() = <me>.Z() - Other.Z()

        :type Right: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_XYZ_Subtract(self, *args)


    def __isub__(self, *args):
        """
        __isub__(gp_XYZ self, gp_XYZ Right)

        :type Right: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_XYZ___isub__(self, *args)


    def Subtracted(self, *args):
        """
        Subtracted(gp_XYZ self, gp_XYZ Right) -> gp_XYZ

        new.X() = <me>.X() - Other.X()
        new.Y() = <me>.Y() - Other.Y()
        new.Z() = <me>.Z() - Other.Z()

        :type Right: OCC.wrapper.gp.gp_XYZ
        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_XYZ_Subtracted(self, *args)


    def __sub__(self, *args):
        """
        __sub__(gp_XYZ self, gp_XYZ Right) -> gp_XYZ

        :type Right: OCC.wrapper.gp.gp_XYZ
        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_XYZ___sub__(self, *args)


    def SetLinearForm(self, *args):
        """
        SetLinearForm(gp_XYZ self, Standard_Real const A1, gp_XYZ XYZ1, Standard_Real const A2, gp_XYZ XYZ2, Standard_Real const A3, gp_XYZ XYZ3, gp_XYZ XYZ4)
        SetLinearForm(gp_XYZ self, Standard_Real const A1, gp_XYZ XYZ1, Standard_Real const A2, gp_XYZ XYZ2, Standard_Real const A3, gp_XYZ XYZ3)
        SetLinearForm(gp_XYZ self, Standard_Real const A1, gp_XYZ XYZ1, Standard_Real const A2, gp_XYZ XYZ2, gp_XYZ XYZ3)
        SetLinearForm(gp_XYZ self, Standard_Real const A1, gp_XYZ XYZ1, Standard_Real const A2, gp_XYZ XYZ2)
        SetLinearForm(gp_XYZ self, Standard_Real const A1, gp_XYZ XYZ1, gp_XYZ XYZ2)
        SetLinearForm(gp_XYZ self, gp_XYZ XYZ1, gp_XYZ XYZ2)

        <me> is set to the following linear form :
        XYZ1 + XYZ2

        :type XYZ1: OCC.wrapper.gp.gp_XYZ
        :type XYZ2: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_XYZ_SetLinearForm(self, *args)

    __swig_destroy__ = _gp.delete_gp_XYZ
gp_XYZ_swigregister = _gp.gp_XYZ_swigregister
gp_XYZ_swigregister(gp_XYZ)

class gp_GTrsf(object):
    """
    Defines a non-persistent transformation in 3D space.
    This transformation is a general transformation.
    It can be a Trsf from gp, an affinity, or you can define
    your own transformation giving the matrix of transformation.

    With a Gtrsf you can transform only a triplet of coordinates
    XYZ. It is not possible to transform other geometric objects
    because these transformations can change the nature of non-
    elementary geometric objects.
    The transformation GTrsf can be represented as follow :

    V1   V2   V3    T       XYZ        XYZ
    | a11  a12  a13   a14 |   | x |      | x'|
    | a21  a22  a23   a24 |   | y |      | y'|
    | a31  a32  a33   a34 |   | z |   =  | z'|
    |  0    0    0     1  |   | 1 |      | 1 |

    where {V1, V2, V3} define the vectorial part of the
    transformation and T defines the translation part of the
    transformation.
    Warning
    A GTrsf transformation is only applicable to
    coordinates. Be careful if you apply such a
    transformation to all points of a geometric object, as
    this can change the nature of the object and thus
    render it incoherent!
    Typically, a circle is transformed into an ellipse by an
    affinity transformation. To avoid modifying the nature of
    an object, use a gp_Trsf transformation instead, as
    objects of this class respect the nature of geometric objects.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_GTrsf self) -> gp_GTrsf
        __init__(gp_GTrsf self, gp_Trsf T) -> gp_GTrsf
        __init__(gp_GTrsf self, gp_Mat M, gp_XYZ V) -> gp_GTrsf

        Creates a transformation based on the matrix M and the
        vector V where M defines the vectorial part of
        the transformation, and V the translation part, or

        :type M: OCC.wrapper.gp.gp_Mat
        :type V: OCC.wrapper.gp.gp_XYZ

        """
        this = _gp.new_gp_GTrsf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetAffinity(self, *args):
        """
        SetAffinity(gp_GTrsf self, gp_Ax1 A1, Standard_Real const Ratio)
        SetAffinity(gp_GTrsf self, gp_Ax2 A2, Standard_Real const Ratio)

        Changes this transformation into an affinity of ratio Ratio
        with respect to  the plane defined by the origin, the "X Direction" and
        the "Y Direction" of coordinate system A2.
        Note: an affinity is a point-by-point transformation that
        transforms any point P into a point P' such that if H is
        the orthogonal projection of P on the axis A1 or the
        plane A2, the vectors HP and HP' satisfy:
        HP' = Ratio * HP.

        :type A2: OCC.wrapper.gp.gp_Ax2
        :type Ratio: float

        """
        return _gp.gp_GTrsf_SetAffinity(self, *args)


    def SetValue(self, *args):
        """
        SetValue(gp_GTrsf self, Standard_Integer const Row, Standard_Integer const Col, Standard_Real const Value)

        Replaces  the coefficient (Row, Col) of the matrix representing
        this transformation by Value.  Raises OutOfRange
        if  Row < 1 or Row > 3 or Col < 1 or Col > 4

        :type Row: int
        :type Col: int
        :type Value: float

        """
        return _gp.gp_GTrsf_SetValue(self, *args)


    def SetVectorialPart(self, *args):
        """
        SetVectorialPart(gp_GTrsf self, gp_Mat Matrix)

        Replaces the vectorial part of this transformation by Matrix.

        :type Matrix: OCC.wrapper.gp.gp_Mat

        """
        return _gp.gp_GTrsf_SetVectorialPart(self, *args)


    def SetTranslationPart(self, *args):
        """
        SetTranslationPart(gp_GTrsf self, gp_XYZ Coord)

        Replaces the translation part of
        this transformation by the coordinates of the number triple Coord.

        :type Coord: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_GTrsf_SetTranslationPart(self, *args)


    def SetTrsf(self, *args):
        """
        SetTrsf(gp_GTrsf self, gp_Trsf T)

        Assigns the vectorial and translation parts of T to this transformation.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _gp.gp_GTrsf_SetTrsf(self, *args)


    def IsNegative(self, *args):
        """
        IsNegative(gp_GTrsf self) -> Standard_Boolean

        Returns true if the determinant of the vectorial part of
        this transformation is negative.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_GTrsf_IsNegative(self, *args)


    def IsSingular(self, *args):
        """
        IsSingular(gp_GTrsf self) -> Standard_Boolean

        Returns true if this transformation is singular (and
        therefore, cannot be inverted).
        Note: The Gauss LU decomposition is used to invert the
        transformation matrix. Consequently, the transformation
        is considered as singular if the largest pivot found is less
        than or equal to gp::Resolution().
        Warning
        If this transformation is singular, it cannot be inverted.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_GTrsf_IsSingular(self, *args)


    def Form(self, *args):
        """
        Form(gp_GTrsf self) -> gp_TrsfForm

        Returns the nature of the transformation.  It can be an
        identity transformation, a rotation, a translation, a mirror
        transformation (relative to a point, an axis or a plane), a
        scaling transformation, a compound transformation or
        some other type of transformation.

        :rtype: OCC.wrapper.gp.gp_TrsfForm

        """
        return _gp.gp_GTrsf_Form(self, *args)


    def TranslationPart(self, *args):
        """
        Returns the translation part of the GTrsf.

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        res = _gp.gp_GTrsf_TranslationPart(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VectorialPart(self, *args):
        """
        Computes the vectorial part of the GTrsf. The returned Matrix
        is a  3*3 matrix.

        :rtype: OCC.wrapper.gp.gp_Mat

        """
        res = _gp.gp_GTrsf_VectorialPart(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Value(self, *args):
        """
        Value(gp_GTrsf self, Standard_Integer const Row, Standard_Integer const Col) -> Standard_Real

        Returns the coefficients of the global matrix of transformation.
        Raises OutOfRange if Row < 1 or Row > 3 or Col < 1 or Col > 4

        :type Row: int
        :type Col: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_GTrsf_Value(self, *args)


    def __call__(self, *args):
        """
        __call__(gp_GTrsf self, Standard_Integer const Row, Standard_Integer const Col) -> Standard_Real

        :type Row: int
        :type Col: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_GTrsf___call__(self, *args)


    def Invert(self, *args):
        """Invert(gp_GTrsf self)"""
        return _gp.gp_GTrsf_Invert(self, *args)


    def Inverted(self, *args):
        """
        Inverted(gp_GTrsf self) -> gp_GTrsf

        Computes the reverse transformation.
        Raises an exception if the matrix of the transformation
        is not inversible.

        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        return _gp.gp_GTrsf_Inverted(self, *args)


    def Multiplied(self, *args):
        """
        Multiplied(gp_GTrsf self, gp_GTrsf T) -> gp_GTrsf

        Computes the transformation composed from T and <me>.
        In a C++ implementation you can also write Tcomposed = <me> * T.
        Example :
        GTrsf T1, T2, Tcomp; ...............
        //composition :
        Tcomp = T2.Multiplied(T1);         // or   (Tcomp = T2 * T1)
        // transformation of a point
        XYZ P(10.,3.,4.);
        XYZ P1(P);
        Tcomp.Transforms(P1);               //using Tcomp
        XYZ P2(P);
        T1.Transforms(P2);                  //using T1 then T2
        T2.Transforms(P2);                  // P1 = P2 !!!

        :type T: OCC.wrapper.gp.gp_GTrsf
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        return _gp.gp_GTrsf_Multiplied(self, *args)


    def __mul__(self, *args):
        """
        __mul__(gp_GTrsf self, gp_GTrsf T) -> gp_GTrsf

        :type T: OCC.wrapper.gp.gp_GTrsf
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        return _gp.gp_GTrsf___mul__(self, *args)


    def Multiply(self, *args):
        """
        Multiply(gp_GTrsf self, gp_GTrsf T)

        Computes the transformation composed with <me> and T.
        <me> = <me> * T

        :type T: OCC.wrapper.gp.gp_GTrsf

        """
        return _gp.gp_GTrsf_Multiply(self, *args)


    def __imul__(self, *args):
        """
        __imul__(gp_GTrsf self, gp_GTrsf T)

        :type T: OCC.wrapper.gp.gp_GTrsf

        """
        return _gp.gp_GTrsf___imul__(self, *args)


    def PreMultiply(self, *args):
        """
        PreMultiply(gp_GTrsf self, gp_GTrsf T)

        Computes the product of the transformation T and this
        transformation and assigns the result to this transformation.
        this = T * this

        :type T: OCC.wrapper.gp.gp_GTrsf

        """
        return _gp.gp_GTrsf_PreMultiply(self, *args)


    def Power(self, *args):
        """
        Power(gp_GTrsf self, Standard_Integer const N)

        :type N: int

        """
        return _gp.gp_GTrsf_Power(self, *args)


    def Powered(self, *args):
        """
        Powered(gp_GTrsf self, Standard_Integer const N) -> gp_GTrsf

        Computes:
        -   the product of this transformation multiplied by itself
        N times, if N is positive, or
        -   the product of the inverse of this transformation
        multiplied by itself |N| times, if N is negative.
        If N equals zero, the result is equal to the Identity
        transformation.
        I.e.:  <me> * <me> * .......* <me>, N time.
        if N =0 <me> = Identity
        if N < 0 <me> = <me>.Inverse() *...........* <me>.Inverse().

        Raises an exception if N < 0 and if the matrix of the
        transformation not inversible.

        :type N: int
        :rtype: OCC.wrapper.gp.gp_GTrsf

        """
        return _gp.gp_GTrsf_Powered(self, *args)


    def Transforms(self, *args):
        """
        Transforms(gp_GTrsf self, gp_XYZ Coord)
        Transforms(gp_GTrsf self)

        Transforms a triplet XYZ with a GTrsf.

        :type X: float
        :type Y: float
        :type Z: float

        """
        return _gp.gp_GTrsf_Transforms(self, *args)


    def Trsf(self, *args):
        """
        Trsf(gp_GTrsf self) -> gp_Trsf

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        return _gp.gp_GTrsf_Trsf(self, *args)


    def SetFormA(self):
        return _gp.gp_GTrsf_SetFormA(self)

    def SetForm(self):
        return _gp.gp_GTrsf_SetForm(self)
    __swig_destroy__ = _gp.delete_gp_GTrsf
gp_GTrsf_swigregister = _gp.gp_GTrsf_swigregister
gp_GTrsf_swigregister(gp_GTrsf)

class gp_Quaternion(object):
    """
    Represents operation of rotation in 3d space as queternion
    and implements operations with rotations basing on
    quaternion mathematics.

    In addition, provides methods for conversion to and from other
    representatons of rotation (3*3 matrix, vector and
    angle, Euler angles)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Quaternion self) -> gp_Quaternion
        __init__(gp_Quaternion self, Standard_Real const x, Standard_Real const y, Standard_Real const z, Standard_Real const w) -> gp_Quaternion
        __init__(gp_Quaternion self, gp_Quaternion theToCopy) -> gp_Quaternion
        __init__(gp_Quaternion self, gp_Vec theVecFrom, gp_Vec theVecTo) -> gp_Quaternion
        __init__(gp_Quaternion self, gp_Vec theVecFrom, gp_Vec theVecTo, gp_Vec theHelpCrossVec) -> gp_Quaternion
        __init__(gp_Quaternion self, gp_Vec theAxis, Standard_Real const theAngle) -> gp_Quaternion
        __init__(gp_Quaternion self, gp_Mat theMat) -> gp_Quaternion

        Creates quaternion from rotation matrix 3*3
        (which should be orthonormal skew-symmetric matrix)

        :type theMat: OCC.wrapper.gp.gp_Mat

        """
        this = _gp.new_gp_Quaternion(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsEqual(self, *args):
        """
        IsEqual(gp_Quaternion self, gp_Quaternion theOther) -> Standard_Boolean

        Simple equal test without precision

        :type theOther: OCC.wrapper.gp.gp_Quaternion
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Quaternion_IsEqual(self, *args)


    def SetRotation(self, *args):
        """
        SetRotation(gp_Quaternion self, gp_Vec theVecFrom, gp_Vec theVecTo)
        SetRotation(gp_Quaternion self, gp_Vec theVecFrom, gp_Vec theVecTo, gp_Vec theHelpCrossVec)

        Sets quaternion to shortest-arc rotation producing
        vector theVecTo from vector theVecFrom.
        If vectors theVecFrom and theVecTo are opposite then rotation
        axis is computed as theVecFrom ^ theHelpCrossVec.

        :type theVecFrom: OCC.wrapper.gp.gp_Vec
        :type theVecTo: OCC.wrapper.gp.gp_Vec
        :type theHelpCrossVec: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Quaternion_SetRotation(self, *args)


    def SetVectorAndAngle(self, *args):
        """
        SetVectorAndAngle(gp_Quaternion self, gp_Vec theAxis, Standard_Real const theAngle)

        Create a unit quaternion from Axis+Angle representation

        :type theAxis: OCC.wrapper.gp.gp_Vec
        :type theAngle: float

        """
        return _gp.gp_Quaternion_SetVectorAndAngle(self, *args)


    def GetVectorAndAngle(self, *args):
        """
        GetVectorAndAngle(gp_Quaternion self, gp_Vec theAxis)

        Convert a quaternion to Axis+Angle representation,
        preserve the axis direction and angle from -PI to +PI

        :type theAxis: OCC.wrapper.gp.gp_Vec
        :type theAngle: float

        """
        return _gp.gp_Quaternion_GetVectorAndAngle(self, *args)


    def SetMatrix(self, *args):
        """
        SetMatrix(gp_Quaternion self, gp_Mat theMat)

        Create a unit quaternion by rotation matrix
        matrix must contain only rotation (not scale or shear)

        For numerical stability we find first the greatest component of quaternion
        and than search others from this one

        :type theMat: OCC.wrapper.gp.gp_Mat

        """
        return _gp.gp_Quaternion_SetMatrix(self, *args)


    def GetMatrix(self, *args):
        """
        GetMatrix(gp_Quaternion self) -> gp_Mat

        Returns rotation operation as 3*3 matrix

        :rtype: OCC.wrapper.gp.gp_Mat

        """
        return _gp.gp_Quaternion_GetMatrix(self, *args)


    def SetEulerAngles(self, *args):
        """
        SetEulerAngles(gp_Quaternion self, gp_EulerSequence const theOrder, Standard_Real const theAlpha, Standard_Real const theBeta, Standard_Real const theGamma)

        Create a unit quaternion representing rotation defined
        by generalized Euler angles

        :type theOrder: OCC.wrapper.gp.gp_EulerSequence
        :type theAlpha: float
        :type theBeta: float
        :type theGamma: float

        """
        return _gp.gp_Quaternion_SetEulerAngles(self, *args)


    def GetEulerAngles(self, *args):
        """
        GetEulerAngles(gp_Quaternion self, gp_EulerSequence const theOrder)

        Returns Euler angles describing current rotation

        :type theOrder: OCC.wrapper.gp.gp_EulerSequence
        :type theAlpha: float
        :type theBeta: float
        :type theGamma: float

        """
        return _gp.gp_Quaternion_GetEulerAngles(self, *args)


    def Set(self, *args):
        """
        Set(gp_Quaternion self, Standard_Real const x, Standard_Real const y, Standard_Real const z, Standard_Real const w)
        Set(gp_Quaternion self, gp_Quaternion theQuaternion)

        :type theQuaternion: OCC.wrapper.gp.gp_Quaternion

        """
        return _gp.gp_Quaternion_Set(self, *args)


    def X(self, *args):
        """
        X(gp_Quaternion self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Quaternion_X(self, *args)


    def Y(self, *args):
        """
        Y(gp_Quaternion self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Quaternion_Y(self, *args)


    def Z(self, *args):
        """
        Z(gp_Quaternion self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Quaternion_Z(self, *args)


    def W(self, *args):
        """
        W(gp_Quaternion self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Quaternion_W(self, *args)


    def SetIdent(self, *args):
        """
        SetIdent(gp_Quaternion self)

        Make identity quaternion (zero-rotation)


        """
        return _gp.gp_Quaternion_SetIdent(self, *args)


    def Reverse(self, *args):
        """
        Reverse(gp_Quaternion self)

        Reverse direction of rotation (conjugate quaternion)


        """
        return _gp.gp_Quaternion_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(gp_Quaternion self) -> gp_Quaternion

        Return rotation with reversed direction (conjugated quaternion)

        :rtype: OCC.wrapper.gp.gp_Quaternion

        """
        return _gp.gp_Quaternion_Reversed(self, *args)


    def Invert(self, *args):
        """
        Invert(gp_Quaternion self)

        Inverts quaternion (both rotation direction and norm)


        """
        return _gp.gp_Quaternion_Invert(self, *args)


    def Inverted(self, *args):
        """
        Inverted(gp_Quaternion self) -> gp_Quaternion

        Return inversed quaternion q^-1

        :rtype: OCC.wrapper.gp.gp_Quaternion

        """
        return _gp.gp_Quaternion_Inverted(self, *args)


    def SquareNorm(self, *args):
        """
        SquareNorm(gp_Quaternion self) -> Standard_Real

        Returns square norm of quaternion

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Quaternion_SquareNorm(self, *args)


    def Norm(self, *args):
        """
        Norm(gp_Quaternion self) -> Standard_Real

        Returns norm of quaternion

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Quaternion_Norm(self, *args)


    def Scale(self, *args):
        """
        Scale(gp_Quaternion self, Standard_Real const theScale)

        Scale all components by quaternion by theScale; note that
        rotation is not changed by this operation (except 0-scaling)

        :type theScale: float

        """
        return _gp.gp_Quaternion_Scale(self, *args)


    def Scaled(self, *args):
        """
        Scaled(gp_Quaternion self, Standard_Real const theScale) -> gp_Quaternion

        Returns scaled quaternion

        :type theScale: float
        :rtype: OCC.wrapper.gp.gp_Quaternion

        """
        return _gp.gp_Quaternion_Scaled(self, *args)


    def StabilizeLength(self, *args):
        """
        StabilizeLength(gp_Quaternion self)

        Stabilize quaternion length within 1 - 1/4.
        This operation is a lot faster than normalization
        and preserve length goes to 0 or infinity


        """
        return _gp.gp_Quaternion_StabilizeLength(self, *args)


    def Normalize(self, *args):
        """
        Normalize(gp_Quaternion self)

        Scale quaternion that its norm goes to 1.
        The appearing of 0 magnitude or near is a error,
        so we can be sure that can divide by magnitude


        """
        return _gp.gp_Quaternion_Normalize(self, *args)


    def Normalized(self, *args):
        """
        Normalized(gp_Quaternion self) -> gp_Quaternion

        Returns quaternion scaled so that its norm goes to 1.

        :rtype: OCC.wrapper.gp.gp_Quaternion

        """
        return _gp.gp_Quaternion_Normalized(self, *args)


    def Negated(self, *args):
        """
        Negated(gp_Quaternion self) -> gp_Quaternion

        Returns quaternion with all components negated.
        Note that this operation does not affect neither
        rotation operator defined by quaternion nor its norm.

        :rtype: OCC.wrapper.gp.gp_Quaternion

        """
        return _gp.gp_Quaternion_Negated(self, *args)


    def __neg__(self, *args):
        """
        __neg__(gp_Quaternion self) -> gp_Quaternion

        :rtype: OCC.wrapper.gp.gp_Quaternion

        """
        return _gp.gp_Quaternion___neg__(self, *args)


    def Added(self, *args):
        """
        Added(gp_Quaternion self, gp_Quaternion theOther) -> gp_Quaternion

        Makes sum of quaternion components; result is "rotations mix"

        :type theOther: OCC.wrapper.gp.gp_Quaternion
        :rtype: OCC.wrapper.gp.gp_Quaternion

        """
        return _gp.gp_Quaternion_Added(self, *args)


    def __add__(self, *args):
        """
        __add__(gp_Quaternion self, gp_Quaternion theOther) -> gp_Quaternion

        :type theOther: OCC.wrapper.gp.gp_Quaternion
        :rtype: OCC.wrapper.gp.gp_Quaternion

        """
        return _gp.gp_Quaternion___add__(self, *args)


    def Subtracted(self, *args):
        """
        Subtracted(gp_Quaternion self, gp_Quaternion theOther) -> gp_Quaternion

        Makes difference of quaternion components; result is "rotations mix"

        :type theOther: OCC.wrapper.gp.gp_Quaternion
        :rtype: OCC.wrapper.gp.gp_Quaternion

        """
        return _gp.gp_Quaternion_Subtracted(self, *args)


    def __sub__(self, *args):
        """
        __sub__(gp_Quaternion self, gp_Quaternion theOther) -> gp_Quaternion

        :type theOther: OCC.wrapper.gp.gp_Quaternion
        :rtype: OCC.wrapper.gp.gp_Quaternion

        """
        return _gp.gp_Quaternion___sub__(self, *args)


    def Multiplied(self, *args):
        """
        Multiplied(gp_Quaternion self, gp_Quaternion theOther) -> gp_Quaternion

        Multiply function - work the same as Matrices multiplying.
        qq' = (cross(v,v') + wv' + w'v, ww' - dot(v,v'))
        Result is rotation combination: q' than q (here q=this, q'=theQ).
        Notices than:
        qq' != q'q;
        qq^-1 = q;

        :type theOther: OCC.wrapper.gp.gp_Quaternion
        :rtype: OCC.wrapper.gp.gp_Quaternion

        """
        return _gp.gp_Quaternion_Multiplied(self, *args)


    def Add(self, *args):
        """
        Add(gp_Quaternion self, gp_Quaternion theOther)

        Adds componnets of other quaternion; result is "rotations mix"

        :type theOther: OCC.wrapper.gp.gp_Quaternion

        """
        return _gp.gp_Quaternion_Add(self, *args)


    def __iadd__(self, *args):
        """
        __iadd__(gp_Quaternion self, gp_Quaternion theOther)

        :type theOther: OCC.wrapper.gp.gp_Quaternion

        """
        return _gp.gp_Quaternion___iadd__(self, *args)


    def Subtract(self, *args):
        """
        Subtract(gp_Quaternion self, gp_Quaternion theOther)

        Subtracts componnets of other quaternion; result is "rotations mix"

        :type theOther: OCC.wrapper.gp.gp_Quaternion

        """
        return _gp.gp_Quaternion_Subtract(self, *args)


    def __isub__(self, *args):
        """
        __isub__(gp_Quaternion self, gp_Quaternion theOther)

        :type theOther: OCC.wrapper.gp.gp_Quaternion

        """
        return _gp.gp_Quaternion___isub__(self, *args)


    def __imul__(self, *args):
        """
        __imul__(gp_Quaternion self, Standard_Real const theScale)
        __imul__(gp_Quaternion self, gp_Quaternion theOther)

        :type theOther: OCC.wrapper.gp.gp_Quaternion

        """
        return _gp.gp_Quaternion___imul__(self, *args)


    def Dot(self, *args):
        """
        Dot(gp_Quaternion self, gp_Quaternion theOther) -> Standard_Real

        Computes inner product / scalar product / Dot

        :type theOther: OCC.wrapper.gp.gp_Quaternion
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Quaternion_Dot(self, *args)


    def GetRotationAngle(self, *args):
        """
        GetRotationAngle(gp_Quaternion self) -> Standard_Real

        Return rotation angle from -PI to PI

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Quaternion_GetRotationAngle(self, *args)


    def Multiply(self, *args):
        """
        Multiply(gp_Quaternion self, gp_Quaternion theOther)
        Multiply(gp_Quaternion self, gp_Vec theVec) -> gp_Vec

        Rotates vector by quaternion as rotation operator

        :type theVec: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Quaternion_Multiply(self, *args)


    def __mul__(self, *args):
        """
        __mul__(gp_Quaternion self, Standard_Real const theScale) -> gp_Quaternion
        __mul__(gp_Quaternion self, gp_Quaternion theOther) -> gp_Quaternion
        __mul__(gp_Quaternion self, gp_Vec theVec) -> gp_Vec

        :type theVec: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Quaternion___mul__(self, *args)

    __swig_destroy__ = _gp.delete_gp_Quaternion
gp_Quaternion_swigregister = _gp.gp_Quaternion_swigregister
gp_Quaternion_swigregister(gp_Quaternion)

class gp_Circ2d(object):
    """
    Describes a circle in the plane (2D space).
    A circle is defined by its radius and positioned in the
    plane with a coordinate system (a gp_Ax22d object) as follows:
    -   the origin of the coordinate system is the center of the circle, and
    -   the orientation (direct or indirect) of the coordinate
    system gives an implicit orientation to the circle (and
    defines its trigonometric sense).
    This positioning coordinate system is the "local
    coordinate system" of the circle.
    Note: when a gp_Circ2d circle is converted into a
    Geom2d_Circle circle, some implicit properties of the
    circle are used explicitly:
    -   the implicit orientation corresponds to the direction in
    which parameter values increase,
    -   the starting point for parameterization is that of the "X
    Axis" of the local coordinate system (i.e. the "X Axis" of the circle).
    See Also
    GccAna and Geom2dGcc packages which provide
    functions for constructing circles defined by geometric constraints
    gce_MakeCirc2d which provides functions for more
    complex circle constructions
    Geom2d_Circle which provides additional functions for
    constructing circles and works, with the parametric
    equations of circles in particular  gp_Ax22d
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Circ2d self) -> gp_Circ2d
        __init__(gp_Circ2d self, gp_Ax2d XAxis, Standard_Real const Radius, Standard_Boolean const Sense) -> gp_Circ2d
        __init__(gp_Circ2d self, gp_Ax22d Axis, Standard_Real const Radius) -> gp_Circ2d

        Axis defines the Xaxis and Yaxis of the circle which defines
        the origin and the sense of parametrization.
        The location point of Axis is the center of the circle.
        Warnings :
        It is not forbidden to create a circle with Radius = 0.0 Raises ConstructionError if Radius < 0.0.
        Raised if Radius < 0.0.

        :type Axis: OCC.wrapper.gp.gp_Ax22d
        :type Radius: float

        """
        this = _gp.new_gp_Circ2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetLocation(self, *args):
        """
        SetLocation(gp_Circ2d self, gp_Pnt2d P)

        Changes the location point (center) of the circle.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Circ2d_SetLocation(self, *args)


    def SetXAxis(self, *args):
        """
        SetXAxis(gp_Circ2d self, gp_Ax2d A)

        Changes the X axis of the circle.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Circ2d_SetXAxis(self, *args)


    def SetAxis(self, *args):
        """
        SetAxis(gp_Circ2d self, gp_Ax22d A)

        Changes the X axis of the circle.

        :type A: OCC.wrapper.gp.gp_Ax22d

        """
        return _gp.gp_Circ2d_SetAxis(self, *args)


    def SetYAxis(self, *args):
        """
        SetYAxis(gp_Circ2d self, gp_Ax2d A)

        Changes the Y axis of the circle.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Circ2d_SetYAxis(self, *args)


    def SetRadius(self, *args):
        """
        SetRadius(gp_Circ2d self, Standard_Real const Radius)

        Modifies the radius of this circle.
        This class does not prevent the creation of a circle where
        Radius is null.
        Exceptions
        Standard_ConstructionError if Radius is negative.

        :type Radius: float

        """
        return _gp.gp_Circ2d_SetRadius(self, *args)


    def Area(self, *args):
        """
        Area(gp_Circ2d self) -> Standard_Real

        Computes the area of the circle.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Circ2d_Area(self, *args)


    def Coefficients(self, *args):
        """
        Coefficients(gp_Circ2d self)

        Returns the normalized coefficients from the implicit equation
        of the circle :
        A * (X**2) + B * (Y**2) + 2*C*(X*Y) + 2*D*X + 2*E*Y + F = 0.0

        :type A: float
        :type B: float
        :type C: float
        :type D: float
        :type E: float
        :type F: float

        """
        return _gp.gp_Circ2d_Coefficients(self, *args)


    def Contains(self, *args):
        """
        Contains(gp_Circ2d self, gp_Pnt2d P, Standard_Real const LinearTolerance) -> Standard_Boolean

        Does <me> contain P ?
        Returns True if the distance between P and any point on
        the circumference of the circle is lower of equal to
        <LinearTolerance>.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type LinearTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Circ2d_Contains(self, *args)


    def Distance(self, *args):
        """
        Distance(gp_Circ2d self, gp_Pnt2d P) -> Standard_Real

        Computes the minimum of distance between the point P and any
        point on the circumference of the circle.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Circ2d_Distance(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(gp_Circ2d self, gp_Pnt2d P) -> Standard_Real

        Computes the square distance between <me> and the point P.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Circ2d_SquareDistance(self, *args)


    def Length(self, *args):
        """
        Length(gp_Circ2d self) -> Standard_Real

        computes the circumference of the circle.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Circ2d_Length(self, *args)


    def Location(self, *args):
        """
        Returns the location point (center) of the circle.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _gp.gp_Circ2d_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Radius(self, *args):
        """
        Radius(gp_Circ2d self) -> Standard_Real

        Returns the radius value of the circle.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Circ2d_Radius(self, *args)


    def Axis(self, *args):
        """
        returns the position of the circle.

        :rtype: OCC.wrapper.gp.gp_Ax22d

        """
        res = _gp.gp_Circ2d_Axis(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Position(self, *args):
        """
        returns the position of the circle. Idem Axis(me).

        :rtype: OCC.wrapper.gp.gp_Ax22d

        """
        res = _gp.gp_Circ2d_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def XAxis(self, *args):
        """
        XAxis(gp_Circ2d self) -> gp_Ax2d

        returns the X axis of the circle.

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Circ2d_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(gp_Circ2d self) -> gp_Ax2d

        Returns the Y axis of the circle.
        Reverses the direction of the circle.

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Circ2d_YAxis(self, *args)


    def Reverse(self, *args):
        """
        Reverse(gp_Circ2d self)

        Reverses the orientation of the local coordinate system
        of this circle (the "Y Direction" is reversed) and therefore
        changes the implicit orientation of this circle.
        Reverse assigns the result to this circle,


        """
        return _gp.gp_Circ2d_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(gp_Circ2d self) -> gp_Circ2d

        Reverses the orientation of the local coordinate system
        of this circle (the "Y Direction" is reversed) and therefore
        changes the implicit orientation of this circle.
        Reversed creates a new circle.

        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _gp.gp_Circ2d_Reversed(self, *args)


    def IsDirect(self, *args):
        """
        IsDirect(gp_Circ2d self) -> Standard_Boolean

        Returns true if the local coordinate system is direct
        and false in the other case.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Circ2d_IsDirect(self, *args)


    def Mirror(self, *args):
        """
        Mirror(gp_Circ2d self, gp_Pnt2d P)
        Mirror(gp_Circ2d self, gp_Ax2d A)

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Circ2d_Mirror(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(gp_Circ2d self, gp_Pnt2d P) -> gp_Circ2d
        Mirrored(gp_Circ2d self, gp_Ax2d A) -> gp_Circ2d

        Performs the symmetrical transformation of a circle with respect
        to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _gp.gp_Circ2d_Mirrored(self, *args)


    def Rotate(self, *args):
        """
        Rotate(gp_Circ2d self, gp_Pnt2d P, Standard_Real const Ang)

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _gp.gp_Circ2d_Rotate(self, *args)


    def Rotated(self, *args):
        """
        Rotated(gp_Circ2d self, gp_Pnt2d P, Standard_Real const Ang) -> gp_Circ2d

        Rotates a circle. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _gp.gp_Circ2d_Rotated(self, *args)


    def Scale(self, *args):
        """
        Scale(gp_Circ2d self, gp_Pnt2d P, Standard_Real const S)

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _gp.gp_Circ2d_Scale(self, *args)


    def Scaled(self, *args):
        """
        Scaled(gp_Circ2d self, gp_Pnt2d P, Standard_Real const S) -> gp_Circ2d

        Scales a circle. S is the scaling value.
        Warnings :
        If S is negative the radius stay positive but
        the "XAxis" and the "YAxis" are  reversed as for
        an ellipse.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _gp.gp_Circ2d_Scaled(self, *args)


    def Transform(self, *args):
        """
        Transform(gp_Circ2d self, gp_Trsf2d T)

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _gp.gp_Circ2d_Transform(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_Circ2d self, gp_Trsf2d T) -> gp_Circ2d

        Transforms a circle with the transformation T from class Trsf2d.

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _gp.gp_Circ2d_Transformed(self, *args)


    def Translate(self, *args):
        """
        Translate(gp_Circ2d self, gp_Vec2d V)
        Translate(gp_Circ2d self, gp_Pnt2d P1, gp_Pnt2d P2)

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Circ2d_Translate(self, *args)


    def Translated(self, *args):
        """
        Translated(gp_Circ2d self, gp_Vec2d V) -> gp_Circ2d
        Translated(gp_Circ2d self, gp_Pnt2d P1, gp_Pnt2d P2) -> gp_Circ2d

        Translates a circle from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _gp.gp_Circ2d_Translated(self, *args)

    __swig_destroy__ = _gp.delete_gp_Circ2d
gp_Circ2d_swigregister = _gp.gp_Circ2d_swigregister
gp_Circ2d_swigregister(gp_Circ2d)

class gp_Mat(object):
    """
    Describes a three column, three row matrix. This sort of
    object is used in various vectorial or matrix computations.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Mat self) -> gp_Mat
        __init__(gp_Mat self, Standard_Real const a11, Standard_Real const a12, Standard_Real const a13, Standard_Real const a21, Standard_Real const a22, Standard_Real const a23, Standard_Real const a31, Standard_Real const a32, Standard_Real const a33) -> gp_Mat
        __init__(gp_Mat self, gp_XYZ Col1, gp_XYZ Col2, gp_XYZ Col3) -> gp_Mat

        Creates a matrix.
        Col1, Col2, Col3 are the 3 columns of the matrix.

        :type Col1: OCC.wrapper.gp.gp_XYZ
        :type Col2: OCC.wrapper.gp.gp_XYZ
        :type Col3: OCC.wrapper.gp.gp_XYZ

        """
        this = _gp.new_gp_Mat(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetCol(self, *args):
        """
        SetCol(gp_Mat self, Standard_Integer const Col, gp_XYZ Value)

        Assigns the three coordinates of Value to the column of index
        Col of this matrix.
        Raises OutOfRange if Col < 1 or Col > 3.

        :type Col: int
        :type Value: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_Mat_SetCol(self, *args)


    def SetCols(self, *args):
        """
        SetCols(gp_Mat self, gp_XYZ Col1, gp_XYZ Col2, gp_XYZ Col3)

        Assigns the number triples Col1, Col2, Col3 to the three
        columns of this matrix.

        :type Col1: OCC.wrapper.gp.gp_XYZ
        :type Col2: OCC.wrapper.gp.gp_XYZ
        :type Col3: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_Mat_SetCols(self, *args)


    def SetCross(self, *args):
        """
        SetCross(gp_Mat self, gp_XYZ Ref)

        Modifies the matrix  M so that applying it to any number
        triple (X, Y, Z) produces the same result as the cross
        product of Ref and the number triple (X, Y, Z):
        i.e.: M * {X,Y,Z}t = Ref.Cross({X, Y ,Z})
        this matrix is anti symmetric. To apply this matrix to the
        triplet  {XYZ} is the same as to do the cross product between the
        triplet Ref and the triplet {XYZ}.
        Note: this matrix is anti-symmetric.

        :type Ref: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_Mat_SetCross(self, *args)


    def SetDiagonal(self, *args):
        """
        SetDiagonal(gp_Mat self, Standard_Real const X1, Standard_Real const X2, Standard_Real const X3)

        Modifies the main diagonal of the matrix.
        <me>.Value (1, 1) = X1
        <me>.Value (2, 2) = X2
        <me>.Value (3, 3) = X3
        The other coefficients of the matrix are not modified.

        :type X1: float
        :type X2: float
        :type X3: float

        """
        return _gp.gp_Mat_SetDiagonal(self, *args)


    def SetDot(self, *args):
        """
        SetDot(gp_Mat self, gp_XYZ Ref)

        Modifies this matrix so that applying it to any number
        triple (X, Y, Z) produces the same result as the scalar
        product of Ref and the number triple (X, Y, Z):
        this * (X,Y,Z) = Ref.(X,Y,Z)
        Note: this matrix is symmetric.

        :type Ref: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_Mat_SetDot(self, *args)


    def SetIdentity(self, *args):
        """
        SetIdentity(gp_Mat self)

        Modifies this matrix so that it represents the Identity matrix.


        """
        return _gp.gp_Mat_SetIdentity(self, *args)


    def SetRotation(self, *args):
        """
        SetRotation(gp_Mat self, gp_XYZ Axis, Standard_Real const Ang)

        Modifies this matrix so that it represents a rotation. Ang is the angular value in
        radians and the XYZ axis gives the direction of the
        rotation.
        Raises ConstructionError if XYZ.Modulus() <= Resolution()

        :type Axis: OCC.wrapper.gp.gp_XYZ
        :type Ang: float

        """
        return _gp.gp_Mat_SetRotation(self, *args)


    def SetRow(self, *args):
        """
        SetRow(gp_Mat self, Standard_Integer const Row, gp_XYZ Value)

        Assigns the three coordinates of Value to the row of index
        Row of this matrix. Raises OutOfRange if Row < 1 or Row > 3.

        :type Row: int
        :type Value: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_Mat_SetRow(self, *args)


    def SetRows(self, *args):
        """
        SetRows(gp_Mat self, gp_XYZ Row1, gp_XYZ Row2, gp_XYZ Row3)

        Assigns the number triples Row1, Row2, Row3 to the three
        rows of this matrix.

        :type Row1: OCC.wrapper.gp.gp_XYZ
        :type Row2: OCC.wrapper.gp.gp_XYZ
        :type Row3: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_Mat_SetRows(self, *args)


    def SetScale(self, *args):
        """
        SetScale(gp_Mat self, Standard_Real const S)

        Modifies the the matrix so that it represents
        a scaling transformation, where S is the scale factor. :
        | S    0.0  0.0 |
        <me> =  | 0.0   S   0.0 |
        | 0.0  0.0   S  |

        :type S: float

        """
        return _gp.gp_Mat_SetScale(self, *args)


    def SetValue(self, *args):
        """
        SetValue(gp_Mat self, Standard_Integer const Row, Standard_Integer const Col, Standard_Real const Value)

        Assigns <Value> to the coefficient of row Row, column Col of   this matrix.
        Raises OutOfRange if Row < 1 or Row > 3 or Col < 1 or Col > 3

        :type Row: int
        :type Col: int
        :type Value: float

        """
        return _gp.gp_Mat_SetValue(self, *args)


    def Column(self, *args):
        """
        Column(gp_Mat self, Standard_Integer const Col) -> gp_XYZ

        Returns the column of Col index.
        Raises OutOfRange if Col < 1 or Col > 3

        :type Col: int
        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_Mat_Column(self, *args)


    def Determinant(self, *args):
        """
        Determinant(gp_Mat self) -> Standard_Real

        Computes the determinant of the matrix.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Mat_Determinant(self, *args)


    def Diagonal(self, *args):
        """
        Diagonal(gp_Mat self) -> gp_XYZ

        Returns the main diagonal of the matrix.

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_Mat_Diagonal(self, *args)


    def Row(self, *args):
        """
        Row(gp_Mat self, Standard_Integer const Row) -> gp_XYZ

        returns the row of Row index.
        Raises OutOfRange if Row < 1 or Row > 3

        :type Row: int
        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_Mat_Row(self, *args)


    def Value(self, *args):
        """
        Value(gp_Mat self, Standard_Integer const Row, Standard_Integer const Col) -> Standard_Real const &

        Returns the coefficient of range (Row, Col)
        Raises OutOfRange if Row < 1 or Row > 3 or Col < 1 or Col > 3

        :type Row: int
        :type Col: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Mat_Value(self, *args)


    def ChangeValue(self, *args):
        """
        ChangeValue(gp_Mat self, Standard_Integer const Row, Standard_Integer const Col) -> Standard_Real &

        Returns the coefficient of range (Row, Col)
        Raises OutOfRange if Row < 1 or Row > 3 or Col < 1 or Col > 3

        :type Row: int
        :type Col: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Mat_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        __call__(gp_Mat self, Standard_Integer const Row, Standard_Integer const Col) -> Standard_Real const
        __call__(gp_Mat self, Standard_Integer const Row, Standard_Integer const Col) -> Standard_Real &

        :type Row: int
        :type Col: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Mat___call__(self, *args)


    def IsSingular(self, *args):
        """
        IsSingular(gp_Mat self) -> Standard_Boolean

        The Gauss LU decomposition is used to invert the matrix
        (see Math package) so the matrix is considered as singular if
        the largest pivot found is lower or equal to Resolution from gp.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Mat_IsSingular(self, *args)


    def Add(self, *args):
        """
        Add(gp_Mat self, gp_Mat Other)

        :type Other: OCC.wrapper.gp.gp_Mat

        """
        return _gp.gp_Mat_Add(self, *args)


    def __iadd__(self, *args):
        """
        __iadd__(gp_Mat self, gp_Mat Other)

        :type Other: OCC.wrapper.gp.gp_Mat

        """
        return _gp.gp_Mat___iadd__(self, *args)


    def Added(self, *args):
        """
        Added(gp_Mat self, gp_Mat Other) -> gp_Mat

        Computes the sum of this matrix and
        the matrix Other for each coefficient of the matrix :
        <me>.Coef(i,j) + <Other>.Coef(i,j)

        :type Other: OCC.wrapper.gp.gp_Mat
        :rtype: OCC.wrapper.gp.gp_Mat

        """
        return _gp.gp_Mat_Added(self, *args)


    def __add__(self, *args):
        """
        __add__(gp_Mat self, gp_Mat Other) -> gp_Mat

        :type Other: OCC.wrapper.gp.gp_Mat
        :rtype: OCC.wrapper.gp.gp_Mat

        """
        return _gp.gp_Mat___add__(self, *args)


    def Divide(self, *args):
        """
        Divide(gp_Mat self, Standard_Real const Scalar)

        :type Scalar: float

        """
        return _gp.gp_Mat_Divide(self, *args)


    def __itruediv__(self, *args):
        return _gp.gp_Mat___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def Divided(self, *args):
        """
        Divided(gp_Mat self, Standard_Real const Scalar) -> gp_Mat

        Divides all the coefficients of the matrix by Scalar

        :type Scalar: float
        :rtype: OCC.wrapper.gp.gp_Mat

        """
        return _gp.gp_Mat_Divided(self, *args)


    def __truediv__(self, *args):
        return _gp.gp_Mat___truediv__(self, *args)
    __div__ = __truediv__



    def Invert(self, *args):
        """Invert(gp_Mat self)"""
        return _gp.gp_Mat_Invert(self, *args)


    def Inverted(self, *args):
        """
        Inverted(gp_Mat self) -> gp_Mat

        Inverses the matrix and raises if the matrix is singular.
        -   Invert assigns the result to this matrix, while
        -   Inverted creates a new one.
        Warning
        The Gauss LU decomposition is used to invert the matrix.
        Consequently, the matrix is considered as singular if the
        largest pivot found is less than or equal to gp::Resolution().
        Exceptions
        Standard_ConstructionError if this matrix is singular,
        and therefore cannot be inverted.

        :rtype: OCC.wrapper.gp.gp_Mat

        """
        return _gp.gp_Mat_Inverted(self, *args)


    def PreMultiply(self, *args):
        """
        PreMultiply(gp_Mat self, gp_Mat Other)

        :type Other: OCC.wrapper.gp.gp_Mat

        """
        return _gp.gp_Mat_PreMultiply(self, *args)


    def Multiplied(self, *args):
        """
        Multiplied(gp_Mat self, gp_Mat Other) -> gp_Mat
        Multiplied(gp_Mat self, Standard_Real const Scalar) -> gp_Mat

        :type Scalar: float
        :rtype: OCC.wrapper.gp.gp_Mat

        """
        return _gp.gp_Mat_Multiplied(self, *args)


    def __mul__(self, *args):
        """
        __mul__(gp_Mat self, gp_Mat Other) -> gp_Mat
        __mul__(gp_Mat self, Standard_Real const Scalar) -> gp_Mat

        :type Scalar: float
        :rtype: OCC.wrapper.gp.gp_Mat

        """
        return _gp.gp_Mat___mul__(self, *args)


    def Multiply(self, *args):
        """
        Multiply(gp_Mat self, gp_Mat Other)
        Multiply(gp_Mat self, Standard_Real const Scalar)

        Multiplies all the coefficients of the matrix by Scalar

        :type Scalar: float

        """
        return _gp.gp_Mat_Multiply(self, *args)


    def __imul__(self, *args):
        """
        __imul__(gp_Mat self, gp_Mat Other)
        __imul__(gp_Mat self, Standard_Real const Scalar)

        :type Scalar: float

        """
        return _gp.gp_Mat___imul__(self, *args)


    def Power(self, *args):
        """
        Power(gp_Mat self, Standard_Integer const N)

        :type N: int

        """
        return _gp.gp_Mat_Power(self, *args)


    def Powered(self, *args):
        """
        Powered(gp_Mat self, Standard_Integer const N) -> gp_Mat

        Computes <me> = <me> * <me> * .......* <me>,   N time.
        if N = 0 <me> = Identity
        if N < 0 <me> = <me>.Invert() *...........* <me>.Invert().
        If N < 0 an exception will be raised if the matrix is not
        inversible

        :type N: int
        :rtype: OCC.wrapper.gp.gp_Mat

        """
        return _gp.gp_Mat_Powered(self, *args)


    def Subtract(self, *args):
        """
        Subtract(gp_Mat self, gp_Mat Other)

        :type Other: OCC.wrapper.gp.gp_Mat

        """
        return _gp.gp_Mat_Subtract(self, *args)


    def __isub__(self, *args):
        """
        __isub__(gp_Mat self, gp_Mat Other)

        :type Other: OCC.wrapper.gp.gp_Mat

        """
        return _gp.gp_Mat___isub__(self, *args)


    def Subtracted(self, *args):
        """
        Subtracted(gp_Mat self, gp_Mat Other) -> gp_Mat

        cOmputes for each coefficient of the matrix :
        <me>.Coef(i,j) - <Other>.Coef(i,j)

        :type Other: OCC.wrapper.gp.gp_Mat
        :rtype: OCC.wrapper.gp.gp_Mat

        """
        return _gp.gp_Mat_Subtracted(self, *args)


    def __sub__(self, *args):
        """
        __sub__(gp_Mat self, gp_Mat Other) -> gp_Mat

        :type Other: OCC.wrapper.gp.gp_Mat
        :rtype: OCC.wrapper.gp.gp_Mat

        """
        return _gp.gp_Mat___sub__(self, *args)


    def Transpose(self, *args):
        """Transpose(gp_Mat self)"""
        return _gp.gp_Mat_Transpose(self, *args)


    def Transposed(self, *args):
        """
        Transposed(gp_Mat self) -> gp_Mat

        Transposes the matrix. A(j, i) -> A (i, j)

        :rtype: OCC.wrapper.gp.gp_Mat

        """
        return _gp.gp_Mat_Transposed(self, *args)

    __swig_destroy__ = _gp.delete_gp_Mat
gp_Mat_swigregister = _gp.gp_Mat_swigregister
gp_Mat_swigregister(gp_Mat)

class gp_(object):
    """
    The geometric processor package, called gp, provides an
    implementation of entities used  :
    . for algebraic calculation such as "XYZ" coordinates, "Mat"
    matrix
    . for basis analytic geometry such as Transformations, point,
    vector, line, plane, axis placement, conics, and elementary
    surfaces.
    These entities are defined in 2d and 3d space.
    All the classes of this package are non-persistent.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Resolution(*args):
        """
        Resolution() -> Standard_Real

        Method of package gp

        In geometric computations, defines the tolerance criterion
        used to determine when two numbers can be considered equal.
        Many class functions use this tolerance criterion, for
        example, to avoid division by zero in geometric
        computations. In the documentation, tolerance criterion is
        always referred to as gp::Resolution().

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp__Resolution(*args)

    Resolution = staticmethod(Resolution)

    def Origin(*args):
        """
        Origin() -> gp_Pnt

        Identifies a Cartesian point with coordinates X = Y = Z = 0.0.0

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp__Origin(*args)

    Origin = staticmethod(Origin)

    def DX(*args):
        """
        DX() -> gp_Dir

        Returns a unit vector with the combination (1,0,0)

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _gp.gp__DX(*args)

    DX = staticmethod(DX)

    def DY(*args):
        """
        DY() -> gp_Dir

        Returns a unit vector with the combination (0,1,0)

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _gp.gp__DY(*args)

    DY = staticmethod(DY)

    def DZ(*args):
        """
        DZ() -> gp_Dir

        Returns a unit vector with the combination (0,0,1)

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _gp.gp__DZ(*args)

    DZ = staticmethod(DZ)

    def OX(*args):
        """
        OX() -> gp_Ax1

        Identifies an axis where its origin is Origin
        and its unit vector coordinates  X = 1.0,  Y = Z = 0.0

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp__OX(*args)

    OX = staticmethod(OX)

    def OY(*args):
        """
        OY() -> gp_Ax1

        Identifies an axis where its origin is Origin
        and its unit vector coordinates Y = 1.0,  X = Z = 0.0

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp__OY(*args)

    OY = staticmethod(OY)

    def OZ(*args):
        """
        OZ() -> gp_Ax1

        Identifies an axis where its origin is Origin
        and its unit vector coordinates Z = 1.0,  Y = X = 0.0

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp__OZ(*args)

    OZ = staticmethod(OZ)

    def XOY(*args):
        """
        XOY() -> gp_Ax2

        Identifies a coordinate system where its origin is Origin,
        and its "main Direction" and "X Direction" coordinates
        Z = 1.0, X = Y =0.0 and X direction coordinates X = 1.0, Y = Z = 0.0

        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp__XOY(*args)

    XOY = staticmethod(XOY)

    def ZOX(*args):
        """
        ZOX() -> gp_Ax2

        Identifies a coordinate system where its origin is Origin,
        and its "main Direction" and "X Direction" coordinates
        Y = 1.0, X = Z =0.0 and X direction coordinates Z = 1.0, X = Y = 0.0

        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp__ZOX(*args)

    ZOX = staticmethod(ZOX)

    def YOZ(*args):
        """
        YOZ() -> gp_Ax2

        Identifies a coordinate system where its origin is Origin,
        and its "main Direction" and "X Direction" coordinates
        X = 1.0, Z = Y =0.0 and X direction coordinates Y = 1.0, X = Z = 0.0
        In 2D space

        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp__YOZ(*args)

    YOZ = staticmethod(YOZ)

    def Origin2d(*args):
        """
        Origin2d() -> gp_Pnt2d

        Identifies a Cartesian point with coordinates X = Y = 0.0

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp__Origin2d(*args)

    Origin2d = staticmethod(Origin2d)

    def DX2d(*args):
        """
        DX2d() -> gp_Dir2d

        Returns a unit vector with the combinations (1,0)

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        return _gp.gp__DX2d(*args)

    DX2d = staticmethod(DX2d)

    def DY2d(*args):
        """
        DY2d() -> gp_Dir2d

        Returns a unit vector with the combinations (0,1)

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        return _gp.gp__DY2d(*args)

    DY2d = staticmethod(DY2d)

    def OX2d(*args):
        """
        OX2d() -> gp_Ax2d

        Identifies an axis where its origin is Origin2d
        and its unit vector coordinates are: X = 1.0,  Y = 0.0

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp__OX2d(*args)

    OX2d = staticmethod(OX2d)

    def OY2d(*args):
        """
        OY2d() -> gp_Ax2d

        Identifies an axis where its origin is Origin2d
        and its unit vector coordinates are Y = 1.0,  X = 0.0

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp__OY2d(*args)

    OY2d = staticmethod(OY2d)

    def __init__(self):
        """
        The geometric processor package, called gp, provides an
        implementation of entities used  :
        . for algebraic calculation such as "XYZ" coordinates, "Mat"
        matrix
        . for basis analytic geometry such as Transformations, point,
        vector, line, plane, axis placement, conics, and elementary
        surfaces.
        These entities are defined in 2d and 3d space.
        All the classes of this package are non-persistent.
        """
        this = _gp.new_gp_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gp.delete_gp_
gp__swigregister = _gp.gp__swigregister
gp__swigregister(gp_)

def gp__Resolution(*args):
    """
    gp__Resolution() -> Standard_Real

    Method of package gp

    In geometric computations, defines the tolerance criterion
    used to determine when two numbers can be considered equal.
    Many class functions use this tolerance criterion, for
    example, to avoid division by zero in geometric
    computations. In the documentation, tolerance criterion is
    always referred to as gp::Resolution().

    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _gp.gp__Resolution(*args)

def gp__Origin(*args):
    """
    gp__Origin() -> gp_Pnt

    Identifies a Cartesian point with coordinates X = Y = Z = 0.0.0

    :rtype: OCC.wrapper.gp.gp_Pnt

    """
    return _gp.gp__Origin(*args)

def gp__DX(*args):
    """
    gp__DX() -> gp_Dir

    Returns a unit vector with the combination (1,0,0)

    :rtype: OCC.wrapper.gp.gp_Dir

    """
    return _gp.gp__DX(*args)

def gp__DY(*args):
    """
    gp__DY() -> gp_Dir

    Returns a unit vector with the combination (0,1,0)

    :rtype: OCC.wrapper.gp.gp_Dir

    """
    return _gp.gp__DY(*args)

def gp__DZ(*args):
    """
    gp__DZ() -> gp_Dir

    Returns a unit vector with the combination (0,0,1)

    :rtype: OCC.wrapper.gp.gp_Dir

    """
    return _gp.gp__DZ(*args)

def gp__OX(*args):
    """
    gp__OX() -> gp_Ax1

    Identifies an axis where its origin is Origin
    and its unit vector coordinates  X = 1.0,  Y = Z = 0.0

    :rtype: OCC.wrapper.gp.gp_Ax1

    """
    return _gp.gp__OX(*args)

def gp__OY(*args):
    """
    gp__OY() -> gp_Ax1

    Identifies an axis where its origin is Origin
    and its unit vector coordinates Y = 1.0,  X = Z = 0.0

    :rtype: OCC.wrapper.gp.gp_Ax1

    """
    return _gp.gp__OY(*args)

def gp__OZ(*args):
    """
    gp__OZ() -> gp_Ax1

    Identifies an axis where its origin is Origin
    and its unit vector coordinates Z = 1.0,  Y = X = 0.0

    :rtype: OCC.wrapper.gp.gp_Ax1

    """
    return _gp.gp__OZ(*args)

def gp__XOY(*args):
    """
    gp__XOY() -> gp_Ax2

    Identifies a coordinate system where its origin is Origin,
    and its "main Direction" and "X Direction" coordinates
    Z = 1.0, X = Y =0.0 and X direction coordinates X = 1.0, Y = Z = 0.0

    :rtype: OCC.wrapper.gp.gp_Ax2

    """
    return _gp.gp__XOY(*args)

def gp__ZOX(*args):
    """
    gp__ZOX() -> gp_Ax2

    Identifies a coordinate system where its origin is Origin,
    and its "main Direction" and "X Direction" coordinates
    Y = 1.0, X = Z =0.0 and X direction coordinates Z = 1.0, X = Y = 0.0

    :rtype: OCC.wrapper.gp.gp_Ax2

    """
    return _gp.gp__ZOX(*args)

def gp__YOZ(*args):
    """
    gp__YOZ() -> gp_Ax2

    Identifies a coordinate system where its origin is Origin,
    and its "main Direction" and "X Direction" coordinates
    X = 1.0, Z = Y =0.0 and X direction coordinates Y = 1.0, X = Z = 0.0
    In 2D space

    :rtype: OCC.wrapper.gp.gp_Ax2

    """
    return _gp.gp__YOZ(*args)

def gp__Origin2d(*args):
    """
    gp__Origin2d() -> gp_Pnt2d

    Identifies a Cartesian point with coordinates X = Y = 0.0

    :rtype: OCC.wrapper.gp.gp_Pnt2d

    """
    return _gp.gp__Origin2d(*args)

def gp__DX2d(*args):
    """
    gp__DX2d() -> gp_Dir2d

    Returns a unit vector with the combinations (1,0)

    :rtype: OCC.wrapper.gp.gp_Dir2d

    """
    return _gp.gp__DX2d(*args)

def gp__DY2d(*args):
    """
    gp__DY2d() -> gp_Dir2d

    Returns a unit vector with the combinations (0,1)

    :rtype: OCC.wrapper.gp.gp_Dir2d

    """
    return _gp.gp__DY2d(*args)

def gp__OX2d(*args):
    """
    gp__OX2d() -> gp_Ax2d

    Identifies an axis where its origin is Origin2d
    and its unit vector coordinates are: X = 1.0,  Y = 0.0

    :rtype: OCC.wrapper.gp.gp_Ax2d

    """
    return _gp.gp__OX2d(*args)

def gp__OY2d(*args):
    """
    gp__OY2d() -> gp_Ax2d

    Identifies an axis where its origin is Origin2d
    and its unit vector coordinates are Y = 1.0,  X = 0.0

    :rtype: OCC.wrapper.gp.gp_Ax2d

    """
    return _gp.gp__OY2d(*args)

class gp_Ax22d(object):
    """
    Describes a coordinate system in a plane (2D space).
    A coordinate system is defined by:
    -   its origin (also referred to as its "Location point"), and
    -   two orthogonal unit vectors, respectively, called the "X
    Direction" and the "Y Direction".
    A gp_Ax22d may be right-handed ("direct sense") or
    left-handed ("inverse" or "indirect sense").
    You use a gp_Ax22d to:
    - describe 2D geometric entities, in particular to position
    them. The local coordinate system of a geometric
    entity serves for the same purpose as the STEP
    function "axis placement two axes", or
    -   define geometric transformations.
    Note: we refer to the "X Axis" and "Y Axis" as the axes having:
    -   the origin of the coordinate system as their origin, and
    -   the unit vectors "X Direction" and "Y Direction",
    respectively, as their unit vectors.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Ax22d self) -> gp_Ax22d
        __init__(gp_Ax22d self, gp_Pnt2d P, gp_Dir2d Vx, gp_Dir2d Vy) -> gp_Ax22d
        __init__(gp_Ax22d self, gp_Pnt2d P, gp_Dir2d V, Standard_Boolean const Sense) -> gp_Ax22d
        __init__(gp_Ax22d self, gp_Ax2d A, Standard_Boolean const Sense) -> gp_Ax22d

        Creates -   a coordinate system where its origin is the origin of
        A and its "X Direction" is the unit vector of A, which   is:
        -   right-handed if Sense is true (default value), or
        -   left-handed if Sense is false.

        :type A: OCC.wrapper.gp.gp_Ax2d
        :type Sense: bool

        """
        this = _gp.new_gp_Ax22d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetAxis(self, *args):
        """
        SetAxis(gp_Ax22d self, gp_Ax22d A1)

        Assigns the origin and the two unit vectors of the
        coordinate system A1 to this coordinate system.

        :type A1: OCC.wrapper.gp.gp_Ax22d

        """
        return _gp.gp_Ax22d_SetAxis(self, *args)


    def SetXAxis(self, *args):
        """
        SetXAxis(gp_Ax22d self, gp_Ax2d A1)

        Changes the XAxis and YAxis ("Location" point and "Direction")
        of <me>.
        The "YDirection" is recomputed in the same sense as before.

        :type A1: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Ax22d_SetXAxis(self, *args)


    def SetYAxis(self, *args):
        """
        SetYAxis(gp_Ax22d self, gp_Ax2d A1)

        Changes the XAxis and YAxis ("Location" point and "Direction") of <me>.
        The "XDirection" is recomputed in the same sense as before.

        :type A1: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Ax22d_SetYAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(gp_Ax22d self, gp_Pnt2d P)

        Changes the "Location" point (origin) of <me>.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Ax22d_SetLocation(self, *args)


    def SetXDirection(self, *args):
        """
        SetXDirection(gp_Ax22d self, gp_Dir2d Vx)

        Assigns Vx to the "X Direction"  of
        this coordinate system. The other unit vector of this
        coordinate system is recomputed, normal to Vx ,
        without modifying the orientation (right-handed or
        left-handed) of this coordinate system.

        :type Vx: OCC.wrapper.gp.gp_Dir2d

        """
        return _gp.gp_Ax22d_SetXDirection(self, *args)


    def SetYDirection(self, *args):
        """
        SetYDirection(gp_Ax22d self, gp_Dir2d Vy)

        Assignsr Vy to the  "Y Direction" of
        this coordinate system. The other unit vector of this
        coordinate system is recomputed, normal to Vy,
        without modifying the orientation (right-handed or
        left-handed) of this coordinate system.

        :type Vy: OCC.wrapper.gp.gp_Dir2d

        """
        return _gp.gp_Ax22d_SetYDirection(self, *args)


    def XAxis(self, *args):
        """
        XAxis(gp_Ax22d self) -> gp_Ax2d

        Returns an axis, for which
        -   the origin is that of this coordinate system, and
        -   the unit vector is either the "X Direction"  of this coordinate system.
        Note: the result is the "X Axis" of this coordinate system.

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Ax22d_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(gp_Ax22d self) -> gp_Ax2d

        Returns an axis, for which
        -   the origin is that of this coordinate system, and
        - the unit vector is either the  "Y Direction" of this coordinate system.
        Note: the result is the "Y Axis" of this coordinate system.

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Ax22d_YAxis(self, *args)


    def Location(self, *args):
        """
        Returns the "Location" point (origin) of <me>.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _gp.gp_Ax22d_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def XDirection(self, *args):
        """
        Returns the "XDirection" of <me>.

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        res = _gp.gp_Ax22d_XDirection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def YDirection(self, *args):
        """
        Returns the "YDirection" of <me>.

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        res = _gp.gp_Ax22d_YDirection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Mirror(self, *args):
        """
        Mirror(gp_Ax22d self, gp_Pnt2d P)
        Mirror(gp_Ax22d self, gp_Ax2d A)

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Ax22d_Mirror(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(gp_Ax22d self, gp_Pnt2d P) -> gp_Ax22d
        Mirrored(gp_Ax22d self, gp_Ax2d A) -> gp_Ax22d

        Performs the symmetrical transformation of an axis
        placement with respect to an axis placement which
        is the axis of the symmetry.
        The transformation is performed on the "Location"
        point, on the "XDirection" and "YDirection".
        The resulting main "Direction" is the cross product between
        the "XDirection" and the "YDirection" after transformation.

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.gp.gp_Ax22d

        """
        return _gp.gp_Ax22d_Mirrored(self, *args)


    def Rotate(self, *args):
        """
        Rotate(gp_Ax22d self, gp_Pnt2d P, Standard_Real const Ang)

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _gp.gp_Ax22d_Rotate(self, *args)


    def Rotated(self, *args):
        """
        Rotated(gp_Ax22d self, gp_Pnt2d P, Standard_Real const Ang) -> gp_Ax22d

        Rotates an axis placement. <A1> is the axis of the
        rotation . Ang is the angular value of the rotation
        in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.gp.gp_Ax22d

        """
        return _gp.gp_Ax22d_Rotated(self, *args)


    def Scale(self, *args):
        """
        Scale(gp_Ax22d self, gp_Pnt2d P, Standard_Real const S)

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _gp.gp_Ax22d_Scale(self, *args)


    def Scaled(self, *args):
        """
        Scaled(gp_Ax22d self, gp_Pnt2d P, Standard_Real const S) -> gp_Ax22d

        Applies a scaling transformation on the axis placement.
        The "Location" point of the axisplacement is modified.
        Warnings :
        If the scale <S> is negative :
        . the main direction of the axis placement is not changed.
        . The "XDirection" and the "YDirection" are reversed.
        So the axis placement stay right handed.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.gp.gp_Ax22d

        """
        return _gp.gp_Ax22d_Scaled(self, *args)


    def Transform(self, *args):
        """
        Transform(gp_Ax22d self, gp_Trsf2d T)

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _gp.gp_Ax22d_Transform(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_Ax22d self, gp_Trsf2d T) -> gp_Ax22d

        Transforms an axis placement with a Trsf.
        The "Location" point, the "XDirection" and the
        "YDirection" are transformed with T.  The resulting
        main "Direction" of <me> is the cross product between
        the "XDirection" and the "YDirection" after transformation.

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.gp.gp_Ax22d

        """
        return _gp.gp_Ax22d_Transformed(self, *args)


    def Translate(self, *args):
        """
        Translate(gp_Ax22d self, gp_Vec2d V)
        Translate(gp_Ax22d self, gp_Pnt2d P1, gp_Pnt2d P2)

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Ax22d_Translate(self, *args)


    def Translated(self, *args):
        """
        Translated(gp_Ax22d self, gp_Vec2d V) -> gp_Ax22d
        Translated(gp_Ax22d self, gp_Pnt2d P1, gp_Pnt2d P2) -> gp_Ax22d

        Translates an axis placement from the point <P1> to the
        point <P2>.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.gp.gp_Ax22d

        """
        return _gp.gp_Ax22d_Translated(self, *args)

    __swig_destroy__ = _gp.delete_gp_Ax22d
gp_Ax22d_swigregister = _gp.gp_Ax22d_swigregister
gp_Ax22d_swigregister(gp_Ax22d)

class gp_Pnt(object):
    """Defines a 3D cartesian point."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Pnt self) -> gp_Pnt
        __init__(gp_Pnt self, gp_XYZ Coord) -> gp_Pnt
        __init__(gp_Pnt self, Standard_Real const Xp, Standard_Real const Yp, Standard_Real const Zp) -> gp_Pnt

        Creates a  point with its 3 cartesian's coordinates : Xp, Yp, Zp.

        :type Xp: float
        :type Yp: float
        :type Zp: float

        """
        this = _gp.new_gp_Pnt(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetCoord(self, *args):
        """
        SetCoord(gp_Pnt self, Standard_Integer const Index, Standard_Real const Xi)
        SetCoord(gp_Pnt self, Standard_Real const Xp, Standard_Real const Yp, Standard_Real const Zp)

        For this point, assigns  the values Xp, Yp and Zp to its three coordinates.

        :type Xp: float
        :type Yp: float
        :type Zp: float

        """
        return _gp.gp_Pnt_SetCoord(self, *args)


    def SetX(self, *args):
        """
        SetX(gp_Pnt self, Standard_Real const X)

        Assigns the given value to the X coordinate of this point.

        :type X: float

        """
        return _gp.gp_Pnt_SetX(self, *args)


    def SetY(self, *args):
        """
        SetY(gp_Pnt self, Standard_Real const Y)

        Assigns the given value to the Y coordinate of this point.

        :type Y: float

        """
        return _gp.gp_Pnt_SetY(self, *args)


    def SetZ(self, *args):
        """
        SetZ(gp_Pnt self, Standard_Real const Z)

        Assigns the given value to the Z coordinate of this point.

        :type Z: float

        """
        return _gp.gp_Pnt_SetZ(self, *args)


    def SetXYZ(self, *args):
        """
        SetXYZ(gp_Pnt self, gp_XYZ Coord)

        Assigns the three coordinates of Coord to this point.

        :type Coord: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_Pnt_SetXYZ(self, *args)


    def X(self, *args):
        """
        X(gp_Pnt self) -> Standard_Real

        For this point, returns its X coordinate.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Pnt_X(self, *args)


    def Y(self, *args):
        """
        Y(gp_Pnt self) -> Standard_Real

        For this point, returns its Y coordinate.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Pnt_Y(self, *args)


    def Z(self, *args):
        """
        Z(gp_Pnt self) -> Standard_Real

        For this point, returns its Z coordinate.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Pnt_Z(self, *args)


    def XYZ(self, *args):
        """
        For this point, returns its three coordinates as a XYZ object.

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        res = _gp.gp_Pnt_XYZ(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Coord(self, *args):
        """
        For this point, returns its three coordinates as a XYZ object.

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        res = _gp.gp_Pnt_Coord(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeCoord(self, *args):
        """
        ChangeCoord(gp_Pnt self) -> gp_XYZ

        Returns the coordinates of this point.
        Note: This syntax allows direct modification of the returned value.

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_Pnt_ChangeCoord(self, *args)


    def BaryCenter(self, *args):
        """
        BaryCenter(gp_Pnt self, Standard_Real const Alpha, gp_Pnt P, Standard_Real const Beta)

        Assigns the result of the following expression to this point
        (Alpha*this + Beta*P) / (Alpha + Beta)

        :type Alpha: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Beta: float

        """
        return _gp.gp_Pnt_BaryCenter(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(gp_Pnt self, gp_Pnt Other, Standard_Real const LinearTolerance) -> Standard_Boolean

        Comparison
        Returns True if the distance between the two points is
        lower or equal to LinearTolerance.

        :type Other: OCC.wrapper.gp.gp_Pnt
        :type LinearTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Pnt_IsEqual(self, *args)


    def Distance(self, *args):
        """
        Distance(gp_Pnt self, gp_Pnt Other) -> Standard_Real

        Computes the distance between two points.

        :type Other: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Pnt_Distance(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(gp_Pnt self, gp_Pnt Other) -> Standard_Real

        Computes the square distance between two points.

        :type Other: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Pnt_SquareDistance(self, *args)


    def Mirror(self, *args):
        """
        Mirror(gp_Pnt self, gp_Pnt P)
        Mirror(gp_Pnt self, gp_Ax1 A1)
        Mirror(gp_Pnt self, gp_Ax2 A2)

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Pnt_Mirror(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(gp_Pnt self, gp_Pnt P) -> gp_Pnt
        Mirrored(gp_Pnt self, gp_Ax1 A1) -> gp_Pnt
        Mirrored(gp_Pnt self, gp_Ax2 A2) -> gp_Pnt

        Rotates a point. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Pnt_Mirrored(self, *args)


    def Rotate(self, *args):
        """
        Rotate(gp_Pnt self, gp_Ax1 A1, Standard_Real const Ang)

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _gp.gp_Pnt_Rotate(self, *args)


    def Rotated(self, *args):
        """
        Rotated(gp_Pnt self, gp_Ax1 A1, Standard_Real const Ang) -> gp_Pnt

        Scales a point. S is the scaling value.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Pnt_Rotated(self, *args)


    def Scale(self, *args):
        """
        Scale(gp_Pnt self, gp_Pnt P, Standard_Real const S)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _gp.gp_Pnt_Scale(self, *args)


    def Scaled(self, *args):
        """
        Scaled(gp_Pnt self, gp_Pnt P, Standard_Real const S) -> gp_Pnt

        Transforms a point with the transformation T.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Pnt_Scaled(self, *args)


    def Transform(self, *args):
        """
        Transform(gp_Pnt self, gp_Trsf T)

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _gp.gp_Pnt_Transform(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_Pnt self, gp_Trsf T) -> gp_Pnt

        Translates a point in the direction of the vector V.
        The magnitude of the translation is the vector's magnitude.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Pnt_Transformed(self, *args)


    def Translate(self, *args):
        """
        Translate(gp_Pnt self, gp_Vec V)
        Translate(gp_Pnt self, gp_Pnt P1, gp_Pnt P2)

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Pnt_Translate(self, *args)


    def Translated(self, *args):
        """
        Translated(gp_Pnt self, gp_Vec V) -> gp_Pnt
        Translated(gp_Pnt self, gp_Pnt P1, gp_Pnt P2) -> gp_Pnt

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Pnt_Translated(self, *args)

    __swig_destroy__ = _gp.delete_gp_Pnt
gp_Pnt_swigregister = _gp.gp_Pnt_swigregister
gp_Pnt_swigregister(gp_Pnt)

class gp_Lin2d(object):
    """
    Describes a line in 2D space.
    A line is positioned in the plane with an axis (a gp_Ax2d
    object) which gives the line its origin and unit vector. A
    line and an axis are similar objects, thus, we can convert
    one into the other.
    A line provides direct access to the majority of the edit
    and query functions available on its positioning axis. In
    addition, however, a line has specific functions for
    computing distances and positions.
    See Also
    GccAna and Geom2dGcc packages which provide
    functions for constructing lines defined by geometric
    constraints
    gce_MakeLin2d which provides functions for more
    complex line constructions
    Geom2d_Line which provides additional functions for
    constructing lines and works, in particular, with the
    parametric equations of lines
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Lin2d self) -> gp_Lin2d
        __init__(gp_Lin2d self, gp_Ax2d A) -> gp_Lin2d
        __init__(gp_Lin2d self, gp_Pnt2d P, gp_Dir2d V) -> gp_Lin2d
        __init__(gp_Lin2d self, Standard_Real const A, Standard_Real const B, Standard_Real const C) -> gp_Lin2d

        Creates the line from the equation A*X + B*Y + C = 0.0 Raises ConstructionError if Sqrt(A*A + B*B) <= Resolution from gp.
        Raised if Sqrt(A*A + B*B) <= Resolution from gp.

        :type A: float
        :type B: float
        :type C: float

        """
        this = _gp.new_gp_Lin2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Reverse(self, *args):
        """Reverse(gp_Lin2d self)"""
        return _gp.gp_Lin2d_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(gp_Lin2d self) -> gp_Lin2d

        Reverses the positioning axis of this line.
        Note:
        -   Reverse assigns the result to this line, while
        -   Reversed creates a new one.

        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _gp.gp_Lin2d_Reversed(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(gp_Lin2d self, gp_Dir2d V)

        Changes the direction of the line.

        :type V: OCC.wrapper.gp.gp_Dir2d

        """
        return _gp.gp_Lin2d_SetDirection(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(gp_Lin2d self, gp_Pnt2d P)

        Changes the origin of the line.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Lin2d_SetLocation(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(gp_Lin2d self, gp_Ax2d A)

        Complete redefinition of the line.
        The "Location" point of <A> is the origin of the line.
        The "Direction" of <A> is  the direction of the line.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Lin2d_SetPosition(self, *args)


    def Coefficients(self, *args):
        """
        Coefficients(gp_Lin2d self)

        Returns the normalized coefficients of the line :
        A * X + B * Y + C = 0.

        :type A: float
        :type B: float
        :type C: float

        """
        return _gp.gp_Lin2d_Coefficients(self, *args)


    def Direction(self, *args):
        """
        Returns the direction of the line.

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        res = _gp.gp_Lin2d_Direction(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Location(self, *args):
        """
        Returns the location point (origin) of the line.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _gp.gp_Lin2d_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Position(self, *args):
        """
        Returns the axis placement one axis whith the same
        location and direction as <me>.

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        res = _gp.gp_Lin2d_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Angle(self, *args):
        """
        Angle(gp_Lin2d self, gp_Lin2d Other) -> Standard_Real

        Computes the angle between two lines in radians.

        :type Other: OCC.wrapper.gp.gp_Lin2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Lin2d_Angle(self, *args)


    def Contains(self, *args):
        """
        Contains(gp_Lin2d self, gp_Pnt2d P, Standard_Real const LinearTolerance) -> Standard_Boolean

        Returns true if this line contains the point P, that is, if the
        distance between point P and this line is less than or
        equal to LinearTolerance.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type LinearTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Lin2d_Contains(self, *args)


    def Distance(self, *args):
        """
        Distance(gp_Lin2d self, gp_Pnt2d P) -> Standard_Real
        Distance(gp_Lin2d self, gp_Lin2d Other) -> Standard_Real

        Computes the distance between two lines.

        :type Other: OCC.wrapper.gp.gp_Lin2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Lin2d_Distance(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(gp_Lin2d self, gp_Pnt2d P) -> Standard_Real
        SquareDistance(gp_Lin2d self, gp_Lin2d Other) -> Standard_Real

        Computes the square distance between two lines.

        :type Other: OCC.wrapper.gp.gp_Lin2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Lin2d_SquareDistance(self, *args)


    def Normal(self, *args):
        """
        Normal(gp_Lin2d self, gp_Pnt2d P) -> gp_Lin2d

        Computes the line normal to the direction of <me>,
        passing through the point <P>.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _gp.gp_Lin2d_Normal(self, *args)


    def Mirror(self, *args):
        """
        Mirror(gp_Lin2d self, gp_Pnt2d P)
        Mirror(gp_Lin2d self, gp_Ax2d A)

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Lin2d_Mirror(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(gp_Lin2d self, gp_Pnt2d P) -> gp_Lin2d
        Mirrored(gp_Lin2d self, gp_Ax2d A) -> gp_Lin2d

        Performs the symmetrical transformation of a line
        with respect to an axis placement which is the axis
        of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _gp.gp_Lin2d_Mirrored(self, *args)


    def Rotate(self, *args):
        """
        Rotate(gp_Lin2d self, gp_Pnt2d P, Standard_Real const Ang)

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _gp.gp_Lin2d_Rotate(self, *args)


    def Rotated(self, *args):
        """
        Rotated(gp_Lin2d self, gp_Pnt2d P, Standard_Real const Ang) -> gp_Lin2d

        Rotates a line. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _gp.gp_Lin2d_Rotated(self, *args)


    def Scale(self, *args):
        """
        Scale(gp_Lin2d self, gp_Pnt2d P, Standard_Real const S)

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _gp.gp_Lin2d_Scale(self, *args)


    def Scaled(self, *args):
        """
        Scaled(gp_Lin2d self, gp_Pnt2d P, Standard_Real const S) -> gp_Lin2d

        Scales a line. S is the scaling value. Only the
        origin of the line is modified.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _gp.gp_Lin2d_Scaled(self, *args)


    def Transform(self, *args):
        """
        Transform(gp_Lin2d self, gp_Trsf2d T)

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _gp.gp_Lin2d_Transform(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_Lin2d self, gp_Trsf2d T) -> gp_Lin2d

        Transforms a line with the transformation T from class Trsf2d.

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _gp.gp_Lin2d_Transformed(self, *args)


    def Translate(self, *args):
        """
        Translate(gp_Lin2d self, gp_Vec2d V)
        Translate(gp_Lin2d self, gp_Pnt2d P1, gp_Pnt2d P2)

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Lin2d_Translate(self, *args)


    def Translated(self, *args):
        """
        Translated(gp_Lin2d self, gp_Vec2d V) -> gp_Lin2d
        Translated(gp_Lin2d self, gp_Pnt2d P1, gp_Pnt2d P2) -> gp_Lin2d

        Translates a line from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _gp.gp_Lin2d_Translated(self, *args)

    __swig_destroy__ = _gp.delete_gp_Lin2d
gp_Lin2d_swigregister = _gp.gp_Lin2d_swigregister
gp_Lin2d_swigregister(gp_Lin2d)

class gp_Vec(object):
    """Defines a non-persistent vector in 3D space."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Vec self) -> gp_Vec
        __init__(gp_Vec self, gp_Dir V) -> gp_Vec
        __init__(gp_Vec self, gp_XYZ Coord) -> gp_Vec
        __init__(gp_Vec self, Standard_Real const Xv, Standard_Real const Yv, Standard_Real const Zv) -> gp_Vec
        __init__(gp_Vec self, gp_Pnt P1, gp_Pnt P2) -> gp_Vec

        Creates a vector from two points. The length of the vector
        is the distance between P1 and P2

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        this = _gp.new_gp_Vec(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetCoord(self, *args):
        """
        SetCoord(gp_Vec self, Standard_Integer const Index, Standard_Real const Xi)
        SetCoord(gp_Vec self, Standard_Real const Xv, Standard_Real const Yv, Standard_Real const Zv)

        For this vector, assigns
        -   the values Xv, Yv and Zv to its three coordinates.

        :type Xv: float
        :type Yv: float
        :type Zv: float

        """
        return _gp.gp_Vec_SetCoord(self, *args)


    def SetX(self, *args):
        """
        SetX(gp_Vec self, Standard_Real const X)

        Assigns the given value to the X coordinate of this vector.

        :type X: float

        """
        return _gp.gp_Vec_SetX(self, *args)


    def SetY(self, *args):
        """
        SetY(gp_Vec self, Standard_Real const Y)

        Assigns the given value to the X coordinate of this vector.

        :type Y: float

        """
        return _gp.gp_Vec_SetY(self, *args)


    def SetZ(self, *args):
        """
        SetZ(gp_Vec self, Standard_Real const Z)

        Assigns the given value to the X coordinate of this vector.

        :type Z: float

        """
        return _gp.gp_Vec_SetZ(self, *args)


    def SetXYZ(self, *args):
        """
        SetXYZ(gp_Vec self, gp_XYZ Coord)

        Assigns the three coordinates of Coord to this vector.

        :type Coord: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_Vec_SetXYZ(self, *args)


    def Coord(self, *args):
        """
        Coord(gp_Vec self, Standard_Integer const Index) -> Standard_Real
        Coord(gp_Vec self)

        For this vector returns its three coordinates Xv, Yv, and Zvinline

        :type Xv: float
        :type Yv: float
        :type Zv: float

        """
        return _gp.gp_Vec_Coord(self, *args)


    def X(self, *args):
        """
        X(gp_Vec self) -> Standard_Real

        For this vector, returns its X coordinate.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Vec_X(self, *args)


    def Y(self, *args):
        """
        Y(gp_Vec self) -> Standard_Real

        For this vector, returns its Y coordinate.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Vec_Y(self, *args)


    def Z(self, *args):
        """
        Z(gp_Vec self) -> Standard_Real

        For this vector, returns its Z  coordinate.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Vec_Z(self, *args)


    def XYZ(self, *args):
        """
        For this vector, returns
        -   its three coordinates as a number triple

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        res = _gp.gp_Vec_XYZ(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsEqual(self, *args):
        """
        IsEqual(gp_Vec self, gp_Vec Other, Standard_Real const LinearTolerance, Standard_Real const AngularTolerance) -> Standard_Boolean

        Returns True if the two vectors have the same magnitude value
        and the same direction. The precision values are LinearTolerance
        for the magnitude and AngularTolerance for the direction.

        :type Other: OCC.wrapper.gp.gp_Vec
        :type LinearTolerance: float
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Vec_IsEqual(self, *args)


    def IsNormal(self, *args):
        """
        IsNormal(gp_Vec self, gp_Vec Other, Standard_Real const AngularTolerance) -> Standard_Boolean

        Returns True if abs(<me>.Angle(Other) - PI/2.) <= AngularTolerance
        Raises VectorWithNullMagnitude if <me>.Magnitude() <= Resolution or
        Other.Magnitude() <= Resolution from gp

        :type Other: OCC.wrapper.gp.gp_Vec
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Vec_IsNormal(self, *args)


    def IsOpposite(self, *args):
        """
        IsOpposite(gp_Vec self, gp_Vec Other, Standard_Real const AngularTolerance) -> Standard_Boolean

        Returns True if PI - <me>.Angle(Other) <= AngularTolerance
        Raises VectorWithNullMagnitude if <me>.Magnitude() <= Resolution or
        Other.Magnitude() <= Resolution from gp

        :type Other: OCC.wrapper.gp.gp_Vec
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Vec_IsOpposite(self, *args)


    def IsParallel(self, *args):
        """
        IsParallel(gp_Vec self, gp_Vec Other, Standard_Real const AngularTolerance) -> Standard_Boolean

        Returns True if Angle(<me>, Other) <= AngularTolerance or
        PI - Angle(<me>, Other) <= AngularTolerance
        This definition means that two parallel vectors cannot define
        a plane but two vectors with opposite directions are considered
        as parallel. Raises VectorWithNullMagnitude if <me>.Magnitude() <= Resolution or
        Other.Magnitude() <= Resolution from gp

        :type Other: OCC.wrapper.gp.gp_Vec
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Vec_IsParallel(self, *args)


    def Angle(self, *args):
        """
        Angle(gp_Vec self, gp_Vec Other) -> Standard_Real

        Computes the angular value between <me> and <Other>
        Returns the angle value between 0 and PI in radian.
        Raises VectorWithNullMagnitude if <me>.Magnitude() <= Resolution from gp or
        Other.Magnitude() <= Resolution because the angular value is
        indefinite if one of the vectors has a null magnitude.

        :type Other: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Vec_Angle(self, *args)


    def AngleWithRef(self, *args):
        """
        AngleWithRef(gp_Vec self, gp_Vec Other, gp_Vec VRef) -> Standard_Real

        Computes the angle, in radians, between this vector and
        vector Other. The result is a value between -Pi and Pi.
        For this, VRef defines the positive sense of rotation: the
        angular value is positive, if the cross product this ^ Other
        has the same orientation as VRef relative to the plane
        defined by the vectors this and Other. Otherwise, the
        angular value is negative.
        Exceptions
        gp_VectorWithNullMagnitude if the magnitude of this
        vector, the vector Other, or the vector VRef is less than or
        equal to gp::Resolution().
        Standard_DomainError if this vector, the vector Other,
        and the vector VRef are coplanar, unless this vector and
        the vector Other are parallel.

        :type Other: OCC.wrapper.gp.gp_Vec
        :type VRef: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Vec_AngleWithRef(self, *args)


    def Magnitude(self, *args):
        """
        Magnitude(gp_Vec self) -> Standard_Real

        Computes the magnitude of this vector.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Vec_Magnitude(self, *args)


    def SquareMagnitude(self, *args):
        """
        SquareMagnitude(gp_Vec self) -> Standard_Real

        Computes the square magnitude of this vector.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Vec_SquareMagnitude(self, *args)


    def Add(self, *args):
        """
        Add(gp_Vec self, gp_Vec Other)

        Adds two vectors

        :type Other: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Vec_Add(self, *args)


    def __iadd__(self, *args):
        """
        __iadd__(gp_Vec self, gp_Vec Other)

        :type Other: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Vec___iadd__(self, *args)


    def Added(self, *args):
        """
        Added(gp_Vec self, gp_Vec Other) -> gp_Vec

        Adds two vectors

        :type Other: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Vec_Added(self, *args)


    def __add__(self, *args):
        """
        __add__(gp_Vec self, gp_Vec Other) -> gp_Vec

        :type Other: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Vec___add__(self, *args)


    def Subtract(self, *args):
        """
        Subtract(gp_Vec self, gp_Vec Right)

        Subtracts two vectors

        :type Right: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Vec_Subtract(self, *args)


    def __isub__(self, *args):
        """
        __isub__(gp_Vec self, gp_Vec Right)

        :type Right: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Vec___isub__(self, *args)


    def Subtracted(self, *args):
        """
        Subtracted(gp_Vec self, gp_Vec Right) -> gp_Vec

        Subtracts two vectors

        :type Right: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Vec_Subtracted(self, *args)


    def __sub__(self, *args):
        """
        __sub__(gp_Vec self, gp_Vec Right) -> gp_Vec

        :type Right: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Vec___sub__(self, *args)


    def Multiply(self, *args):
        """
        Multiply(gp_Vec self, Standard_Real const Scalar)

        Multiplies a vector by a scalar

        :type Scalar: float

        """
        return _gp.gp_Vec_Multiply(self, *args)


    def __imul__(self, *args):
        """
        __imul__(gp_Vec self, Standard_Real const Scalar)

        :type Scalar: float

        """
        return _gp.gp_Vec___imul__(self, *args)


    def Multiplied(self, *args):
        """
        Multiplied(gp_Vec self, Standard_Real const Scalar) -> gp_Vec

        Multiplies a vector by a scalar

        :type Scalar: float
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Vec_Multiplied(self, *args)


    def Divide(self, *args):
        """
        Divide(gp_Vec self, Standard_Real const Scalar)

        Divides a vector by a scalar

        :type Scalar: float

        """
        return _gp.gp_Vec_Divide(self, *args)


    def __itruediv__(self, *args):
        return _gp.gp_Vec___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def Divided(self, *args):
        """
        Divided(gp_Vec self, Standard_Real const Scalar) -> gp_Vec

        Divides a vector by a scalar

        :type Scalar: float
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Vec_Divided(self, *args)


    def __truediv__(self, *args):
        return _gp.gp_Vec___truediv__(self, *args)
    __div__ = __truediv__



    def Cross(self, *args):
        """
        Cross(gp_Vec self, gp_Vec Right)

        computes the cross product between two vectors

        :type Right: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Vec_Cross(self, *args)


    def __ixor__(self, *args):
        """
        __ixor__(gp_Vec self, gp_Vec Right)

        :type Right: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Vec___ixor__(self, *args)


    def Crossed(self, *args):
        """
        Crossed(gp_Vec self, gp_Vec Right) -> gp_Vec

        computes the cross product between two vectors

        :type Right: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Vec_Crossed(self, *args)


    def __xor__(self, *args):
        """
        __xor__(gp_Vec self, gp_Vec Right) -> gp_Vec

        :type Right: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Vec___xor__(self, *args)


    def CrossMagnitude(self, *args):
        """
        CrossMagnitude(gp_Vec self, gp_Vec Right) -> Standard_Real

        Computes the magnitude of the cross
        product between <me> and Right.
        Returns || <me> ^ Right ||

        :type Right: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Vec_CrossMagnitude(self, *args)


    def CrossSquareMagnitude(self, *args):
        """
        CrossSquareMagnitude(gp_Vec self, gp_Vec Right) -> Standard_Real

        Computes the square magnitude of
        the cross product between <me> and Right.
        Returns || <me> ^ Right ||**2

        :type Right: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Vec_CrossSquareMagnitude(self, *args)


    def CrossCross(self, *args):
        """
        CrossCross(gp_Vec self, gp_Vec V1, gp_Vec V2)

        Computes the triple vector product.
        <me> ^= (V1 ^ V2)

        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Vec_CrossCross(self, *args)


    def CrossCrossed(self, *args):
        """
        CrossCrossed(gp_Vec self, gp_Vec V1, gp_Vec V2) -> gp_Vec

        Computes the triple vector product.
        <me> ^ (V1 ^ V2)

        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Vec_CrossCrossed(self, *args)


    def Dot(self, *args):
        """
        Dot(gp_Vec self, gp_Vec Other) -> Standard_Real

        computes the scalar product

        :type Other: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Vec_Dot(self, *args)


    def __mul__(self, *args):
        """
        __mul__(gp_Vec self, Standard_Real const Scalar) -> gp_Vec
        __mul__(gp_Vec self, gp_Vec Other) -> Standard_Real

        :type Other: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Vec___mul__(self, *args)


    def DotCross(self, *args):
        """
        DotCross(gp_Vec self, gp_Vec V1, gp_Vec V2) -> Standard_Real

        Computes the triple scalar product <me> * (V1 ^ V2).

        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Vec_DotCross(self, *args)


    def Normalize(self, *args):
        """
        Normalize(gp_Vec self)

        normalizes a vector
        Raises an exception if the magnitude of the vector is
        lower or equal to Resolution from gp.


        """
        return _gp.gp_Vec_Normalize(self, *args)


    def Normalized(self, *args):
        """
        Normalized(gp_Vec self) -> gp_Vec

        normalizes a vector
        Raises an exception if the magnitude of the vector is
        lower or equal to Resolution from gp.

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Vec_Normalized(self, *args)


    def Reverse(self, *args):
        """
        Reverse(gp_Vec self)

        Reverses the direction of a vector


        """
        return _gp.gp_Vec_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(gp_Vec self) -> gp_Vec

        Reverses the direction of a vector

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Vec_Reversed(self, *args)


    def __neg__(self, *args):
        """
        __neg__(gp_Vec self) -> gp_Vec

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Vec___neg__(self, *args)


    def SetLinearForm(self, *args):
        """
        SetLinearForm(gp_Vec self, Standard_Real const A1, gp_Vec V1, Standard_Real const A2, gp_Vec V2, Standard_Real const A3, gp_Vec V3, gp_Vec V4)
        SetLinearForm(gp_Vec self, Standard_Real const A1, gp_Vec V1, Standard_Real const A2, gp_Vec V2, Standard_Real const A3, gp_Vec V3)
        SetLinearForm(gp_Vec self, Standard_Real const A1, gp_Vec V1, Standard_Real const A2, gp_Vec V2, gp_Vec V3)
        SetLinearForm(gp_Vec self, Standard_Real const A1, gp_Vec V1, Standard_Real const A2, gp_Vec V2)
        SetLinearForm(gp_Vec self, Standard_Real const A1, gp_Vec V1, gp_Vec V2)
        SetLinearForm(gp_Vec self, gp_Vec V1, gp_Vec V2)

        <me> is set to the following linear form : V1 + V2

        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Vec_SetLinearForm(self, *args)


    def Mirror(self, *args):
        """
        Mirror(gp_Vec self, gp_Vec V)
        Mirror(gp_Vec self, gp_Ax1 A1)
        Mirror(gp_Vec self, gp_Ax2 A2)

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Vec_Mirror(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(gp_Vec self, gp_Vec V) -> gp_Vec
        Mirrored(gp_Vec self, gp_Ax1 A1) -> gp_Vec
        Mirrored(gp_Vec self, gp_Ax2 A2) -> gp_Vec

        Performs the symmetrical transformation of a vector
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Vec_Mirrored(self, *args)


    def Rotate(self, *args):
        """
        Rotate(gp_Vec self, gp_Ax1 A1, Standard_Real const Ang)

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _gp.gp_Vec_Rotate(self, *args)


    def Rotated(self, *args):
        """
        Rotated(gp_Vec self, gp_Ax1 A1, Standard_Real const Ang) -> gp_Vec

        Rotates a vector. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Vec_Rotated(self, *args)


    def Scale(self, *args):
        """
        Scale(gp_Vec self, Standard_Real const S)

        :type S: float

        """
        return _gp.gp_Vec_Scale(self, *args)


    def Scaled(self, *args):
        """
        Scaled(gp_Vec self, Standard_Real const S) -> gp_Vec

        Scales a vector. S is the scaling value.

        :type S: float
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Vec_Scaled(self, *args)


    def Transform(self, *args):
        """
        Transform(gp_Vec self, gp_Trsf T)

        Transforms a vector with the transformation T.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _gp.gp_Vec_Transform(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_Vec self, gp_Trsf T) -> gp_Vec

        Transforms a vector with the transformation T.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _gp.gp_Vec_Transformed(self, *args)

    __swig_destroy__ = _gp.delete_gp_Vec
gp_Vec_swigregister = _gp.gp_Vec_swigregister
gp_Vec_swigregister(gp_Vec)

class gp_Vec2d(object):
    """Defines a non-persistent vector in 2D space."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Vec2d self) -> gp_Vec2d
        __init__(gp_Vec2d self, gp_Dir2d V) -> gp_Vec2d
        __init__(gp_Vec2d self, gp_XY Coord) -> gp_Vec2d
        __init__(gp_Vec2d self, Standard_Real const Xv, Standard_Real const Yv) -> gp_Vec2d
        __init__(gp_Vec2d self, gp_Pnt2d P1, gp_Pnt2d P2) -> gp_Vec2d

        Creates a vector from two points. The length of the vector
        is the distance between P1 and P2

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        this = _gp.new_gp_Vec2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetCoord(self, *args):
        """
        SetCoord(gp_Vec2d self, Standard_Integer const Index, Standard_Real const Xi)
        SetCoord(gp_Vec2d self, Standard_Real const Xv, Standard_Real const Yv)

        For this vector, assigns
        the values Xv and Yv to its two coordinates

        :type Xv: float
        :type Yv: float

        """
        return _gp.gp_Vec2d_SetCoord(self, *args)


    def SetX(self, *args):
        """
        SetX(gp_Vec2d self, Standard_Real const X)

        Assigns the given value to the X coordinate of this vector.

        :type X: float

        """
        return _gp.gp_Vec2d_SetX(self, *args)


    def SetY(self, *args):
        """
        SetY(gp_Vec2d self, Standard_Real const Y)

        Assigns the given value to the Y coordinate of this vector.

        :type Y: float

        """
        return _gp.gp_Vec2d_SetY(self, *args)


    def SetXY(self, *args):
        """
        SetXY(gp_Vec2d self, gp_XY Coord)

        Assigns the two coordinates of Coord to this vector.

        :type Coord: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_Vec2d_SetXY(self, *args)


    def Coord(self, *args):
        """
        Coord(gp_Vec2d self, Standard_Integer const Index) -> Standard_Real
        Coord(gp_Vec2d self)

        For this vector, returns  its two coordinates Xv and Yv

        :type Xv: float
        :type Yv: float

        """
        return _gp.gp_Vec2d_Coord(self, *args)


    def X(self, *args):
        """
        X(gp_Vec2d self) -> Standard_Real

        For this vector, returns its X  coordinate.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Vec2d_X(self, *args)


    def Y(self, *args):
        """
        Y(gp_Vec2d self) -> Standard_Real

        For this vector, returns its Y  coordinate.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Vec2d_Y(self, *args)


    def XY(self, *args):
        """
        For this vector, returns its two coordinates as a number pair

        :rtype: OCC.wrapper.gp.gp_XY

        """
        res = _gp.gp_Vec2d_XY(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsEqual(self, *args):
        """
        IsEqual(gp_Vec2d self, gp_Vec2d Other, Standard_Real const LinearTolerance, Standard_Real const AngularTolerance) -> Standard_Boolean

        Returns True if the two vectors have the same magnitude value
        and the same direction. The precision values are LinearTolerance
        for the magnitude and AngularTolerance for the direction.

        :type Other: OCC.wrapper.gp.gp_Vec2d
        :type LinearTolerance: float
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Vec2d_IsEqual(self, *args)


    def IsNormal(self, *args):
        """
        IsNormal(gp_Vec2d self, gp_Vec2d Other, Standard_Real const AngularTolerance) -> Standard_Boolean

        Returns True if abs(Abs(<me>.Angle(Other)) - PI/2.)
        <= AngularTolerance
        Raises VectorWithNullMagnitude if <me>.Magnitude() <= Resolution or
        Other.Magnitude() <= Resolution from gp.

        :type Other: OCC.wrapper.gp.gp_Vec2d
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Vec2d_IsNormal(self, *args)


    def IsOpposite(self, *args):
        """
        IsOpposite(gp_Vec2d self, gp_Vec2d Other, Standard_Real const AngularTolerance) -> Standard_Boolean

        Returns True if PI - Abs(<me>.Angle(Other)) <= AngularTolerance
        Raises VectorWithNullMagnitude if <me>.Magnitude() <= Resolution or
        Other.Magnitude() <= Resolution from gp.

        :type Other: OCC.wrapper.gp.gp_Vec2d
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Vec2d_IsOpposite(self, *args)


    def IsParallel(self, *args):
        """
        IsParallel(gp_Vec2d self, gp_Vec2d Other, Standard_Real const AngularTolerance) -> Standard_Boolean

        Returns true if Abs(Angle(<me>, Other)) <= AngularTolerance or
        PI - Abs(Angle(<me>, Other)) <= AngularTolerance
        Two vectors with opposite directions are considered as parallel.
        Raises VectorWithNullMagnitude if <me>.Magnitude() <= Resolution or
        Other.Magnitude() <= Resolution from gp

        :type Other: OCC.wrapper.gp.gp_Vec2d
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Vec2d_IsParallel(self, *args)


    def Angle(self, *args):
        """
        Angle(gp_Vec2d self, gp_Vec2d Other) -> Standard_Real

        Computes the angular value between <me> and <Other>
        returns the angle value between -PI and PI in radian.
        The orientation is from <me> to Other. The positive sense is the
        trigonometric sense.
        Raises VectorWithNullMagnitude if <me>.Magnitude() <= Resolution from gp or
        Other.Magnitude() <= Resolution because the angular value is
        indefinite if one of the vectors has a null magnitude.

        :type Other: OCC.wrapper.gp.gp_Vec2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Vec2d_Angle(self, *args)


    def Magnitude(self, *args):
        """
        Magnitude(gp_Vec2d self) -> Standard_Real

        Computes the magnitude of this vector.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Vec2d_Magnitude(self, *args)


    def SquareMagnitude(self, *args):
        """
        SquareMagnitude(gp_Vec2d self) -> Standard_Real

        Computes the square magnitude of this vector.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Vec2d_SquareMagnitude(self, *args)


    def Add(self, *args):
        """
        Add(gp_Vec2d self, gp_Vec2d Other)

        :type Other: OCC.wrapper.gp.gp_Vec2d

        """
        return _gp.gp_Vec2d_Add(self, *args)


    def __iadd__(self, *args):
        """
        __iadd__(gp_Vec2d self, gp_Vec2d Other)

        :type Other: OCC.wrapper.gp.gp_Vec2d

        """
        return _gp.gp_Vec2d___iadd__(self, *args)


    def Added(self, *args):
        """
        Added(gp_Vec2d self, gp_Vec2d Other) -> gp_Vec2d

        Adds two vectors

        :type Other: OCC.wrapper.gp.gp_Vec2d
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _gp.gp_Vec2d_Added(self, *args)


    def __add__(self, *args):
        """
        __add__(gp_Vec2d self, gp_Vec2d Other) -> gp_Vec2d

        :type Other: OCC.wrapper.gp.gp_Vec2d
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _gp.gp_Vec2d___add__(self, *args)


    def Crossed(self, *args):
        """
        Crossed(gp_Vec2d self, gp_Vec2d Right) -> Standard_Real

        Computes the crossing product between two vectors

        :type Right: OCC.wrapper.gp.gp_Vec2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Vec2d_Crossed(self, *args)


    def __xor__(self, *args):
        """
        __xor__(gp_Vec2d self, gp_Vec2d Right) -> Standard_Real

        :type Right: OCC.wrapper.gp.gp_Vec2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Vec2d___xor__(self, *args)


    def CrossMagnitude(self, *args):
        """
        CrossMagnitude(gp_Vec2d self, gp_Vec2d Right) -> Standard_Real

        Computes the magnitude of the cross product between <me> and
        Right. Returns || <me> ^ Right ||

        :type Right: OCC.wrapper.gp.gp_Vec2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Vec2d_CrossMagnitude(self, *args)


    def CrossSquareMagnitude(self, *args):
        """
        CrossSquareMagnitude(gp_Vec2d self, gp_Vec2d Right) -> Standard_Real

        Computes the square magnitude of the cross product between <me> and
        Right. Returns || <me> ^ Right ||**2

        :type Right: OCC.wrapper.gp.gp_Vec2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Vec2d_CrossSquareMagnitude(self, *args)


    def Divide(self, *args):
        """
        Divide(gp_Vec2d self, Standard_Real const Scalar)

        :type Scalar: float

        """
        return _gp.gp_Vec2d_Divide(self, *args)


    def __itruediv__(self, *args):
        return _gp.gp_Vec2d___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def Divided(self, *args):
        """
        Divided(gp_Vec2d self, Standard_Real const Scalar) -> gp_Vec2d

        divides a vector by a scalar

        :type Scalar: float
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _gp.gp_Vec2d_Divided(self, *args)


    def __truediv__(self, *args):
        return _gp.gp_Vec2d___truediv__(self, *args)
    __div__ = __truediv__



    def Dot(self, *args):
        """
        Dot(gp_Vec2d self, gp_Vec2d Other) -> Standard_Real

        Computes the scalar product

        :type Other: OCC.wrapper.gp.gp_Vec2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Vec2d_Dot(self, *args)


    def GetNormal(self, *args):
        """
        GetNormal(gp_Vec2d self) -> gp_Vec2d

        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _gp.gp_Vec2d_GetNormal(self, *args)


    def Multiply(self, *args):
        """
        Multiply(gp_Vec2d self, Standard_Real const Scalar)

        :type Scalar: float

        """
        return _gp.gp_Vec2d_Multiply(self, *args)


    def __imul__(self, *args):
        """
        __imul__(gp_Vec2d self, Standard_Real const Scalar)

        :type Scalar: float

        """
        return _gp.gp_Vec2d___imul__(self, *args)


    def Multiplied(self, *args):
        """
        Multiplied(gp_Vec2d self, Standard_Real const Scalar) -> gp_Vec2d

        Normalizes a vector
        Raises an exception if the magnitude of the vector is
        lower or equal to Resolution from package gp.

        :type Scalar: float
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _gp.gp_Vec2d_Multiplied(self, *args)


    def __mul__(self, *args):
        """
        __mul__(gp_Vec2d self, gp_Vec2d Other) -> Standard_Real
        __mul__(gp_Vec2d self, Standard_Real const Scalar) -> gp_Vec2d

        :type Scalar: float
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _gp.gp_Vec2d___mul__(self, *args)


    def Normalize(self, *args):
        """Normalize(gp_Vec2d self)"""
        return _gp.gp_Vec2d_Normalize(self, *args)


    def Normalized(self, *args):
        """
        Normalized(gp_Vec2d self) -> gp_Vec2d

        Normalizes a vector
        Raises an exception if the magnitude of the vector is
        lower or equal to Resolution from package gp.
        Reverses the direction of a vector

        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _gp.gp_Vec2d_Normalized(self, *args)


    def Reverse(self, *args):
        """Reverse(gp_Vec2d self)"""
        return _gp.gp_Vec2d_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(gp_Vec2d self) -> gp_Vec2d

        Reverses the direction of a vector

        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _gp.gp_Vec2d_Reversed(self, *args)


    def __neg__(self, *args):
        """
        __neg__(gp_Vec2d self) -> gp_Vec2d

        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _gp.gp_Vec2d___neg__(self, *args)


    def Subtract(self, *args):
        """
        Subtract(gp_Vec2d self, gp_Vec2d Right)

        Subtracts two vectors

        :type Right: OCC.wrapper.gp.gp_Vec2d

        """
        return _gp.gp_Vec2d_Subtract(self, *args)


    def __isub__(self, *args):
        """
        __isub__(gp_Vec2d self, gp_Vec2d Right)

        :type Right: OCC.wrapper.gp.gp_Vec2d

        """
        return _gp.gp_Vec2d___isub__(self, *args)


    def Subtracted(self, *args):
        """
        Subtracted(gp_Vec2d self, gp_Vec2d Right) -> gp_Vec2d

        Subtracts two vectors

        :type Right: OCC.wrapper.gp.gp_Vec2d
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _gp.gp_Vec2d_Subtracted(self, *args)


    def __sub__(self, *args):
        """
        __sub__(gp_Vec2d self, gp_Vec2d Right) -> gp_Vec2d

        :type Right: OCC.wrapper.gp.gp_Vec2d
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _gp.gp_Vec2d___sub__(self, *args)


    def SetLinearForm(self, *args):
        """
        SetLinearForm(gp_Vec2d self, Standard_Real const A1, gp_Vec2d V1, Standard_Real const A2, gp_Vec2d V2, gp_Vec2d V3)
        SetLinearForm(gp_Vec2d self, Standard_Real const A1, gp_Vec2d V1, Standard_Real const A2, gp_Vec2d V2)
        SetLinearForm(gp_Vec2d self, Standard_Real const A1, gp_Vec2d V1, gp_Vec2d V2)
        SetLinearForm(gp_Vec2d self, gp_Vec2d Left, gp_Vec2d Right)

        <me> is set to the following linear form : Left + Right

        :type Left: OCC.wrapper.gp.gp_Vec2d
        :type Right: OCC.wrapper.gp.gp_Vec2d

        """
        return _gp.gp_Vec2d_SetLinearForm(self, *args)


    def Mirror(self, *args):
        """
        Mirror(gp_Vec2d self, gp_Vec2d V)
        Mirror(gp_Vec2d self, gp_Ax2d A1)

        Performs the symmetrical transformation of a vector
        with respect to an axis placement which is the axis
        of the symmetry.

        :type A1: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Vec2d_Mirror(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(gp_Vec2d self, gp_Vec2d V) -> gp_Vec2d
        Mirrored(gp_Vec2d self, gp_Ax2d A1) -> gp_Vec2d

        Performs the symmetrical transformation of a vector
        with respect to an axis placement which is the axis
        of the symmetry.

        :type A1: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _gp.gp_Vec2d_Mirrored(self, *args)


    def Rotate(self, *args):
        """
        Rotate(gp_Vec2d self, Standard_Real const Ang)

        :type Ang: float

        """
        return _gp.gp_Vec2d_Rotate(self, *args)


    def Rotated(self, *args):
        """
        Rotated(gp_Vec2d self, Standard_Real const Ang) -> gp_Vec2d

        Rotates a vector. Ang is the angular value of the
        rotation in radians.

        :type Ang: float
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _gp.gp_Vec2d_Rotated(self, *args)


    def Scale(self, *args):
        """
        Scale(gp_Vec2d self, Standard_Real const S)

        :type S: float

        """
        return _gp.gp_Vec2d_Scale(self, *args)


    def Scaled(self, *args):
        """
        Scaled(gp_Vec2d self, Standard_Real const S) -> gp_Vec2d

        Scales a vector. S is the scaling value.

        :type S: float
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _gp.gp_Vec2d_Scaled(self, *args)


    def Transform(self, *args):
        """
        Transform(gp_Vec2d self, gp_Trsf2d T)

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _gp.gp_Vec2d_Transform(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_Vec2d self, gp_Trsf2d T) -> gp_Vec2d

        Transforms a vector with a Trsf from gp.

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _gp.gp_Vec2d_Transformed(self, *args)

    __swig_destroy__ = _gp.delete_gp_Vec2d
gp_Vec2d_swigregister = _gp.gp_Vec2d_swigregister
gp_Vec2d_swigregister(gp_Vec2d)

class gp_Ax2(object):
    """
    Describes a right-handed coordinate system in 3D space.
    A coordinate system is defined by:
    -   its origin (also referred to as its "Location point"), and
    -   three orthogonal unit vectors, termed respectively the
    "X Direction", the "Y Direction" and the "Direction" (also
    referred to as the "main Direction").
    The "Direction" of the coordinate system is called its
    "main Direction" because whenever this unit vector is
    modified, the "X Direction" and the "Y Direction" are
    recomputed. However, when we modify either the "X
    Direction" or the "Y Direction", "Direction" is not modified.
    The "main Direction" is also the "Z Direction".
    Since an Ax2 coordinate system is right-handed, its
    "main Direction" is always equal to the cross product of
    its "X Direction" and "Y Direction". (To define a
    left-handed coordinate system, use gp_Ax3.)
    A coordinate system is used:
    -   to describe geometric entities, in particular to position
    them. The local coordinate system of a geometric
    entity serves the same purpose as the STEP function
    "axis placement two axes", or
    -   to define geometric transformations.
    Note: we refer to the "X Axis", "Y Axis" and "Z Axis",
    respectively, as to axes having:
    - the origin of the coordinate system as their origin, and
    -   the unit vectors "X Direction", "Y Direction" and "main
    Direction", respectively, as their unit vectors.
    The "Z Axis" is also the "main Axis".
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Ax2 self) -> gp_Ax2
        __init__(gp_Ax2 self, gp_Pnt P, gp_Dir N, gp_Dir Vx) -> gp_Ax2
        __init__(gp_Ax2 self, gp_Pnt P, gp_Dir V) -> gp_Ax2

        Creates -   a coordinate system with an origin P, where V
        gives the "main Direction" (here, "X Direction" and "Y
        Direction" are defined automatically).

        :type P: OCC.wrapper.gp.gp_Pnt
        :type V: OCC.wrapper.gp.gp_Dir

        """
        this = _gp.new_gp_Ax2(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetAxis(self, *args):
        """
        SetAxis(gp_Ax2 self, gp_Ax1 A1)

        Assigns the origin and "main Direction" of the axis A1 to
        this coordinate system, then recomputes its "X Direction" and "Y Direction".
        Note: The new "X Direction" is computed as follows:
        new "X Direction" = V1 ^(previous "X Direction" ^ V)
        where V is the "Direction" of A1.
        Exceptions
        Standard_ConstructionError if A1 is parallel to the "X
        Direction" of this coordinate system.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Ax2_SetAxis(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(gp_Ax2 self, gp_Dir V)

        Changes the "main Direction" of this coordinate system,
        then recomputes its "X Direction" and "Y Direction".
        Note: the new "X Direction" is computed as follows:
        new "X Direction" = V ^ (previous "X Direction" ^ V)
        Exceptions
        Standard_ConstructionError if V is parallel to the "X
        Direction" of this coordinate system.

        :type V: OCC.wrapper.gp.gp_Dir

        """
        return _gp.gp_Ax2_SetDirection(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(gp_Ax2 self, gp_Pnt P)

        Changes the "Location" point (origin) of <me>.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Ax2_SetLocation(self, *args)


    def SetXDirection(self, *args):
        """
        SetXDirection(gp_Ax2 self, gp_Dir Vx)

        Changes the "Xdirection" of <me>. The main direction
        "Direction" is not modified, the "Ydirection" is modified.
        If <Vx> is not normal to the main direction then <XDirection>
        is computed as follows XDirection = Direction ^ (Vx ^ Direction).
        Exceptions
        Standard_ConstructionError if Vx or Vy is parallel to
        the "main Direction" of this coordinate system.

        :type Vx: OCC.wrapper.gp.gp_Dir

        """
        return _gp.gp_Ax2_SetXDirection(self, *args)


    def SetYDirection(self, *args):
        """
        SetYDirection(gp_Ax2 self, gp_Dir Vy)

        Changes the "Ydirection" of <me>. The main direction is not
        modified but the "Xdirection" is changed.
        If <Vy> is not normal to the main direction then "YDirection"
        is computed as  follows
        YDirection = Direction ^ (<Vy> ^ Direction).
        Exceptions
        Standard_ConstructionError if Vx or Vy is parallel to
        the "main Direction" of this coordinate system.

        :type Vy: OCC.wrapper.gp.gp_Dir

        """
        return _gp.gp_Ax2_SetYDirection(self, *args)


    def Angle(self, *args):
        """
        Angle(gp_Ax2 self, gp_Ax2 Other) -> Standard_Real

        Computes the angular value, in radians, between the main direction of
        <me> and the main direction of <Other>. Returns the angle
        between 0 and PI in radians.

        :type Other: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Ax2_Angle(self, *args)


    def Axis(self, *args):
        """
        Returns the main axis of <me>. It is the "Location" point
        and the main "Direction".

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        res = _gp.gp_Ax2_Axis(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Direction(self, *args):
        """
        Returns the main direction of <me>.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _gp.gp_Ax2_Direction(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Location(self, *args):
        """
        Returns the "Location" point (origin) of <me>.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _gp.gp_Ax2_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def XDirection(self, *args):
        """
        Returns the "XDirection" of <me>.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _gp.gp_Ax2_XDirection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def YDirection(self, *args):
        """
        Returns the "YDirection" of <me>.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _gp.gp_Ax2_YDirection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsCoplanar(self, *args):
        """
        IsCoplanar(gp_Ax2 self, gp_Ax2 Other, Standard_Real const LinearTolerance, Standard_Real const AngularTolerance) -> Standard_Boolean
        IsCoplanar(gp_Ax2 self, gp_Ax1 A1, Standard_Real const LinearTolerance, Standard_Real const AngularTolerance) -> Standard_Boolean

        Returns True if
        . the distance between <me> and the "Location" point of A1
        is lower of equal to LinearTolerance and
        . the main direction of <me> and the direction of A1 are normal.
        Note: the tolerance criterion for angular equality is given by AngularTolerance.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type LinearTolerance: float
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Ax2_IsCoplanar(self, *args)


    def Mirror(self, *args):
        """
        Mirror(gp_Ax2 self, gp_Pnt P)
        Mirror(gp_Ax2 self, gp_Ax1 A1)
        Mirror(gp_Ax2 self, gp_Ax2 A2)

        Performs a symmetrical transformation of this coordinate
        system with respect to:
        -   the plane defined by the origin, "X Direction" and "Y
        Direction" of coordinate system A2 and  assigns the result to this coordinate systeme.
        Warning
        This transformation is always performed on the origin.
        In case of a reflection with respect to a point:
        - the main direction of the coordinate system is not changed, and
        - the "X Direction" and the "Y Direction" are simply reversed
        In case of a reflection with respect to an axis or a plane:
        -   the transformation is applied to the "X Direction"
        and the "Y Direction", then
        -   the "main Direction" is recomputed as the cross
        product "X Direction" ^ "Y   Direction".
        This maintains the right-handed property of the
        coordinate system.

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Ax2_Mirror(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(gp_Ax2 self, gp_Pnt P) -> gp_Ax2
        Mirrored(gp_Ax2 self, gp_Ax1 A1) -> gp_Ax2
        Mirrored(gp_Ax2 self, gp_Ax2 A2) -> gp_Ax2

        Performs a symmetrical transformation of this coordinate
        system with respect to:
        -   the plane defined by the origin, "X Direction" and "Y
        Direction" of coordinate system A2 and creates a new one.
        Warning
        This transformation is always performed on the origin.
        In case of a reflection with respect to a point:
        - the main direction of the coordinate system is not changed, and
        - the "X Direction" and the "Y Direction" are simply reversed
        In case of a reflection with respect to an axis or a plane:
        -   the transformation is applied to the "X Direction"
        and the "Y Direction", then
        -   the "main Direction" is recomputed as the cross
        product "X Direction" ^ "Y   Direction".
        This maintains the right-handed property of the
        coordinate system.

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Ax2_Mirrored(self, *args)


    def Rotate(self, *args):
        """
        Rotate(gp_Ax2 self, gp_Ax1 A1, Standard_Real const Ang)

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _gp.gp_Ax2_Rotate(self, *args)


    def Rotated(self, *args):
        """
        Rotated(gp_Ax2 self, gp_Ax1 A1, Standard_Real const Ang) -> gp_Ax2

        Rotates an axis placement. <A1> is the axis of the
        rotation . Ang is the angular value of the rotation
        in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Ax2_Rotated(self, *args)


    def Scale(self, *args):
        """
        Scale(gp_Ax2 self, gp_Pnt P, Standard_Real const S)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _gp.gp_Ax2_Scale(self, *args)


    def Scaled(self, *args):
        """
        Scaled(gp_Ax2 self, gp_Pnt P, Standard_Real const S) -> gp_Ax2

        Applies a scaling transformation on the axis placement.
        The "Location" point of the axisplacement is modified.
        Warnings :
        If the scale <S> is negative :
        . the main direction of the axis placement is not changed.
        . The "XDirection" and the "YDirection" are reversed.
        So the axis placement stay right handed.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Ax2_Scaled(self, *args)


    def Transform(self, *args):
        """
        Transform(gp_Ax2 self, gp_Trsf T)

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _gp.gp_Ax2_Transform(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_Ax2 self, gp_Trsf T) -> gp_Ax2

        Transforms an axis placement with a Trsf.
        The "Location" point, the "XDirection" and the
        "YDirection" are transformed with T.  The resulting
        main "Direction" of <me> is the cross product between
        the "XDirection" and the "YDirection" after transformation.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Ax2_Transformed(self, *args)


    def Translate(self, *args):
        """
        Translate(gp_Ax2 self, gp_Vec V)
        Translate(gp_Ax2 self, gp_Pnt P1, gp_Pnt P2)

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Ax2_Translate(self, *args)


    def Translated(self, *args):
        """
        Translated(gp_Ax2 self, gp_Vec V) -> gp_Ax2
        Translated(gp_Ax2 self, gp_Pnt P1, gp_Pnt P2) -> gp_Ax2

        Translates an axis placement from the point <P1> to the
        point <P2>.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Ax2_Translated(self, *args)

    __swig_destroy__ = _gp.delete_gp_Ax2
gp_Ax2_swigregister = _gp.gp_Ax2_swigregister
gp_Ax2_swigregister(gp_Ax2)


try:
	gp_TrsfNLerp = NCollection_Lerp_gp_Trsf
except NameError:
	pass # does not exist, probably ignored

class gp_Elips(object):
    """
    Describes an ellipse in 3D space.
    An ellipse is defined by its major and minor radii and
    positioned in space with a coordinate system (a gp_Ax2 object) as follows:
    -   the origin of the coordinate system is the center of the ellipse,
    -   its "X Direction" defines the major axis of the ellipse, and
    - its "Y Direction" defines the minor axis of the ellipse.
    Together, the origin, "X Direction" and "Y Direction" of
    this coordinate system define the plane of the ellipse.
    This coordinate system is the "local coordinate system"
    of the ellipse. In this coordinate system, the equation of
    the ellipse is:
    X*X / (MajorRadius**2) + Y*Y / (MinorRadius**2) = 1.0
    The "main Direction" of the local coordinate system gives
    the normal vector to the plane of the ellipse. This vector
    gives an implicit orientation to the ellipse (definition of the
    trigonometric sense). We refer to the "main Axis" of the
    local coordinate system as the "Axis" of the ellipse.
    See Also
    gce_MakeElips which provides functions for more
    complex ellipse constructions
    Geom_Ellipse which provides additional functions for
    constructing ellipses and works, in particular, with the
    parametric equations of ellipses
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Elips self) -> gp_Elips
        __init__(gp_Elips self, gp_Ax2 A2, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> gp_Elips

        The major radius of the ellipse is on the "XAxis" and the
        minor radius is on the "YAxis" of the ellipse. The "XAxis"
        is defined with the "XDirection" of A2 and the "YAxis" is
        defined with the "YDirection" of A2.
        Warnings :
        It is not forbidden to create an ellipse with MajorRadius =
        MinorRadius.
        Raises ConstructionError if MajorRadius < MinorRadius or MinorRadius < 0.

        :type A2: OCC.wrapper.gp.gp_Ax2
        :type MajorRadius: float
        :type MinorRadius: float

        """
        this = _gp.new_gp_Elips(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetAxis(self, *args):
        """
        SetAxis(gp_Elips self, gp_Ax1 A1)

        Changes the axis normal to the plane of the ellipse.
        It modifies the definition of this plane.
        The "XAxis" and the "YAxis" are recomputed.
        The local coordinate system is redefined so that:
        -   its origin and "main Direction" become those of the
        axis A1 (the "X Direction" and "Y Direction" are then
        recomputed in the same way as for any gp_Ax2), or
        Raises ConstructionError if the direction of A1
        is parallel to the direction of the "XAxis" of the ellipse.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Elips_SetAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(gp_Elips self, gp_Pnt P)

        Modifies this ellipse, by redefining its local coordinate
        so that its origin becomes P.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Elips_SetLocation(self, *args)


    def SetMajorRadius(self, *args):
        """
        SetMajorRadius(gp_Elips self, Standard_Real const MajorRadius)

        The major radius of the ellipse is on the "XAxis" (major axis)
        of the ellipse.
        Raises ConstructionError if MajorRadius < MinorRadius.

        :type MajorRadius: float

        """
        return _gp.gp_Elips_SetMajorRadius(self, *args)


    def SetMinorRadius(self, *args):
        """
        SetMinorRadius(gp_Elips self, Standard_Real const MinorRadius)

        The minor radius of the ellipse is on the "YAxis" (minor axis)
        of the ellipse.
        Raises ConstructionError if MinorRadius > MajorRadius or MinorRadius < 0.

        :type MinorRadius: float

        """
        return _gp.gp_Elips_SetMinorRadius(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(gp_Elips self, gp_Ax2 A2)

        Modifies this ellipse, by redefining its local coordinate
        so that it becomes A2e.

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Elips_SetPosition(self, *args)


    def Area(self, *args):
        """
        Area(gp_Elips self) -> Standard_Real

        Computes the area of the Ellipse.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Elips_Area(self, *args)


    def Axis(self, *args):
        """
        Computes the axis normal to the plane of the ellipse.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        res = _gp.gp_Elips_Axis(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Directrix1(self, *args):
        """
        Directrix1(gp_Elips self) -> gp_Ax1

        Computes the first or second directrix of this ellipse.
        These are the lines, in the plane of the ellipse, normal to
        the major axis, at a distance equal to
        MajorRadius/e from the center of the ellipse, where
        e is the eccentricity of the ellipse.
        The first directrix (Directrix1) is on the positive side of
        the major axis. The second directrix (Directrix2) is on
        the negative side.
        The directrix is returned as an axis (gp_Ax1 object), the
        origin of which is situated on the "X Axis" of the local
        coordinate system of this ellipse.
        Exceptions
        Standard_ConstructionError if the eccentricity is null
        (the ellipse has degenerated into a circle).

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Elips_Directrix1(self, *args)


    def Directrix2(self, *args):
        """
        Directrix2(gp_Elips self) -> gp_Ax1

        This line is obtained by the symmetrical transformation
        of "Directrix1" with respect to the "YAxis" of the ellipse.
        Exceptions
        Standard_ConstructionError if the eccentricity is null
        (the ellipse has degenerated into a circle).

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Elips_Directrix2(self, *args)


    def Eccentricity(self, *args):
        """
        Eccentricity(gp_Elips self) -> Standard_Real

        Returns the eccentricity of the ellipse  between 0.0 and 1.0
        If f is the distance between the center of the ellipse and
        the Focus1 then the eccentricity e = f / MajorRadius.
        Raises ConstructionError if MajorRadius = 0.0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Elips_Eccentricity(self, *args)


    def Focal(self, *args):
        """
        Focal(gp_Elips self) -> Standard_Real

        Computes the focal distance. It is the distance between the
        two focus focus1 and focus2 of the ellipse.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Elips_Focal(self, *args)


    def Focus1(self, *args):
        """
        Focus1(gp_Elips self) -> gp_Pnt

        Returns the first focus of the ellipse. This focus is on the
        positive side of the "XAxis" of the ellipse.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Elips_Focus1(self, *args)


    def Focus2(self, *args):
        """
        Focus2(gp_Elips self) -> gp_Pnt

        Returns the second focus of the ellipse. This focus is on the
        negative side of the "XAxis" of the ellipse.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Elips_Focus2(self, *args)


    def Location(self, *args):
        """
        Returns the center of the ellipse. It is the "Location"
        point of the coordinate system of the ellipse.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _gp.gp_Elips_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MajorRadius(self, *args):
        """
        MajorRadius(gp_Elips self) -> Standard_Real

        Returns the major radius of the ellipse.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Elips_MajorRadius(self, *args)


    def MinorRadius(self, *args):
        """
        MinorRadius(gp_Elips self) -> Standard_Real

        Returns the minor radius of the ellipse.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Elips_MinorRadius(self, *args)


    def Parameter(self, *args):
        """
        Parameter(gp_Elips self) -> Standard_Real

        Returns p = (1 - e * e) * MajorRadius where e is the eccentricity
        of the ellipse.
        Returns 0 if MajorRadius = 0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Elips_Parameter(self, *args)


    def Position(self, *args):
        """
        Returns the coordinate system of the ellipse.

        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        res = _gp.gp_Elips_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def XAxis(self, *args):
        """
        XAxis(gp_Elips self) -> gp_Ax1

        Returns the "XAxis" of the ellipse whose origin
        is the center of this ellipse. It is the major axis of the
        ellipse.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Elips_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(gp_Elips self) -> gp_Ax1

        Returns the "YAxis" of the ellipse whose unit vector is the "X Direction" or the "Y Direction"
        of the local coordinate system of this ellipse.
        This is the minor axis of the ellipse.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Elips_YAxis(self, *args)


    def Mirror(self, *args):
        """
        Mirror(gp_Elips self, gp_Pnt P)
        Mirror(gp_Elips self, gp_Ax1 A1)
        Mirror(gp_Elips self, gp_Ax2 A2)

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Elips_Mirror(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(gp_Elips self, gp_Pnt P) -> gp_Elips
        Mirrored(gp_Elips self, gp_Ax1 A1) -> gp_Elips
        Mirrored(gp_Elips self, gp_Ax2 A2) -> gp_Elips

        Performs the symmetrical transformation of an ellipse with
        respect to a plane. The axis placement A2 locates the plane
        of the symmetry (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.gp.gp_Elips

        """
        return _gp.gp_Elips_Mirrored(self, *args)


    def Rotate(self, *args):
        """
        Rotate(gp_Elips self, gp_Ax1 A1, Standard_Real const Ang)

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _gp.gp_Elips_Rotate(self, *args)


    def Rotated(self, *args):
        """
        Rotated(gp_Elips self, gp_Ax1 A1, Standard_Real const Ang) -> gp_Elips

        Rotates an ellipse. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.gp.gp_Elips

        """
        return _gp.gp_Elips_Rotated(self, *args)


    def Scale(self, *args):
        """
        Scale(gp_Elips self, gp_Pnt P, Standard_Real const S)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _gp.gp_Elips_Scale(self, *args)


    def Scaled(self, *args):
        """
        Scaled(gp_Elips self, gp_Pnt P, Standard_Real const S) -> gp_Elips

        Scales an ellipse. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.gp.gp_Elips

        """
        return _gp.gp_Elips_Scaled(self, *args)


    def Transform(self, *args):
        """
        Transform(gp_Elips self, gp_Trsf T)

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _gp.gp_Elips_Transform(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_Elips self, gp_Trsf T) -> gp_Elips

        Transforms an ellipse with the transformation T from class Trsf.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_Elips

        """
        return _gp.gp_Elips_Transformed(self, *args)


    def Translate(self, *args):
        """
        Translate(gp_Elips self, gp_Vec V)
        Translate(gp_Elips self, gp_Pnt P1, gp_Pnt P2)

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Elips_Translate(self, *args)


    def Translated(self, *args):
        """
        Translated(gp_Elips self, gp_Vec V) -> gp_Elips
        Translated(gp_Elips self, gp_Pnt P1, gp_Pnt P2) -> gp_Elips

        Translates an ellipse from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.gp.gp_Elips

        """
        return _gp.gp_Elips_Translated(self, *args)

    __swig_destroy__ = _gp.delete_gp_Elips
gp_Elips_swigregister = _gp.gp_Elips_swigregister
gp_Elips_swigregister(gp_Elips)

class gp_Dir2d(object):
    """
    Describes a unit vector in the plane (2D space). This unit
    vector is also called "Direction".
    See Also
    gce_MakeDir2d which provides functions for more
    complex unit vector constructions
    Geom2d_Direction which provides additional functions
    for constructing unit vectors and works, in particular, with
    the parametric equations of unit vectors
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Dir2d self) -> gp_Dir2d
        __init__(gp_Dir2d self, gp_Vec2d V) -> gp_Dir2d
        __init__(gp_Dir2d self, gp_XY Coord) -> gp_Dir2d
        __init__(gp_Dir2d self, Standard_Real const Xv, Standard_Real const Yv) -> gp_Dir2d

        Creates a Direction with its 2 cartesian coordinates. Raises ConstructionError if Sqrt(Xv*Xv + Yv*Yv) <= Resolution from gp.

        :type Xv: float
        :type Yv: float

        """
        this = _gp.new_gp_Dir2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetCoord(self, *args):
        """
        SetCoord(gp_Dir2d self, Standard_Integer const Index, Standard_Real const Xi)
        SetCoord(gp_Dir2d self, Standard_Real const Xv, Standard_Real const Yv)

        For this unit vector, assigns:
        -   the values Xv and Yv to its two coordinates,
        Warning
        Remember that all the coordinates of a unit vector are
        implicitly modified when any single one is changed directly.
        Exceptions
        Standard_OutOfRange if Index is not 1 or 2.
        Standard_ConstructionError if either of the following
        is less than or equal to gp::Resolution():
        -   Sqrt(Xv*Xv + Yv*Yv), or
        -   the modulus of the number pair formed by the new
        value Xi and the other coordinate of this vector that
        was not directly modified.
        Raises OutOfRange if Index != {1, 2}.

        :type Xv: float
        :type Yv: float

        """
        return _gp.gp_Dir2d_SetCoord(self, *args)


    def SetX(self, *args):
        """
        SetX(gp_Dir2d self, Standard_Real const X)

        Assigns the given value to the X coordinate of this unit   vector,
        and then normalizes it.
        Warning
        Remember that all the coordinates of a unit vector are
        implicitly modified when any single one is changed directly.
        Exceptions
        Standard_ConstructionError if either of the following
        is less than or equal to gp::Resolution():
        -   the modulus of Coord, or
        -   the modulus of the number pair formed from the new
        X or Y coordinate and the other coordinate of this
        vector that was not directly modified.

        :type X: float

        """
        return _gp.gp_Dir2d_SetX(self, *args)


    def SetY(self, *args):
        """
        SetY(gp_Dir2d self, Standard_Real const Y)

        Assigns  the given value to the Y coordinate of this unit   vector,
        and then normalizes it.
        Warning
        Remember that all the coordinates of a unit vector are
        implicitly modified when any single one is changed directly.
        Exceptions
        Standard_ConstructionError if either of the following
        is less than or equal to gp::Resolution():
        -   the modulus of Coord, or
        -   the modulus of the number pair formed from the new
        X or Y coordinate and the other coordinate of this
        vector that was not directly modified.

        :type Y: float

        """
        return _gp.gp_Dir2d_SetY(self, *args)


    def SetXY(self, *args):
        """
        SetXY(gp_Dir2d self, gp_XY Coord)

        Assigns:
        -   the two coordinates of Coord to this unit vector,
        and then normalizes it.
        Warning
        Remember that all the coordinates of a unit vector are
        implicitly modified when any single one is changed directly.
        Exceptions
        Standard_ConstructionError if either of the following
        is less than or equal to gp::Resolution():
        -   the modulus of Coord, or
        -   the modulus of the number pair formed from the new
        X or Y coordinate and the other coordinate of this
        vector that was not directly modified.

        :type Coord: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_Dir2d_SetXY(self, *args)


    def Coord(self, *args):
        """
        Coord(gp_Dir2d self, Standard_Integer const Index) -> Standard_Real
        Coord(gp_Dir2d self)

        For this unit vector returns its two coordinates Xv and Yv.
        Raises OutOfRange if Index != {1, 2}.

        :type Xv: float
        :type Yv: float

        """
        return _gp.gp_Dir2d_Coord(self, *args)


    def X(self, *args):
        """
        X(gp_Dir2d self) -> Standard_Real

        For this unit vector, returns its X coordinate.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Dir2d_X(self, *args)


    def Y(self, *args):
        """
        Y(gp_Dir2d self) -> Standard_Real

        For this unit vector, returns its Y coordinate.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Dir2d_Y(self, *args)


    def XY(self, *args):
        """
        For this unit vector, returns its two coordinates as a number pair.
        Comparison between Directions
        The precision value is an input data.

        :rtype: OCC.wrapper.gp.gp_XY

        """
        res = _gp.gp_Dir2d_XY(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsEqual(self, *args):
        """
        IsEqual(gp_Dir2d self, gp_Dir2d Other, Standard_Real const AngularTolerance) -> Standard_Boolean

        Returns True if the two vectors have the same direction
        i.e. the angle between this unit vector and the
        unit vector Other is less than or equal to AngularTolerance.

        :type Other: OCC.wrapper.gp.gp_Dir2d
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Dir2d_IsEqual(self, *args)


    def IsNormal(self, *args):
        """
        IsNormal(gp_Dir2d self, gp_Dir2d Other, Standard_Real const AngularTolerance) -> Standard_Boolean

        Returns True if the angle between this unit vector and the
        unit vector Other is equal to Pi/2 or -Pi/2 (normal)
        i.e. Abs(Abs(<me>.Angle(Other)) - PI/2.) <= AngularTolerance

        :type Other: OCC.wrapper.gp.gp_Dir2d
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Dir2d_IsNormal(self, *args)


    def IsOpposite(self, *args):
        """
        IsOpposite(gp_Dir2d self, gp_Dir2d Other, Standard_Real const AngularTolerance) -> Standard_Boolean

        Returns True if the angle between this unit vector and the
        unit vector Other is equal to Pi or -Pi (opposite).
        i.e.  PI - Abs(<me>.Angle(Other)) <= AngularTolerance

        :type Other: OCC.wrapper.gp.gp_Dir2d
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Dir2d_IsOpposite(self, *args)


    def IsParallel(self, *args):
        """
        IsParallel(gp_Dir2d self, gp_Dir2d Other, Standard_Real const AngularTolerance) -> Standard_Boolean

        returns true if if the angle between this unit vector and unit
        vector Other is equal to 0, Pi or -Pi.
        i.e.  Abs(Angle(<me>, Other)) <= AngularTolerance or
        PI - Abs(Angle(<me>, Other)) <= AngularTolerance

        :type Other: OCC.wrapper.gp.gp_Dir2d
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Dir2d_IsParallel(self, *args)


    def Angle(self, *args):
        """
        Angle(gp_Dir2d self, gp_Dir2d Other) -> Standard_Real

        Computes the angular value in radians between <me> and
        <Other>. Returns the angle in the range [-PI, PI].

        :type Other: OCC.wrapper.gp.gp_Dir2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Dir2d_Angle(self, *args)


    def Crossed(self, *args):
        """
        Crossed(gp_Dir2d self, gp_Dir2d Right) -> Standard_Real

        Computes the cross product between two directions.

        :type Right: OCC.wrapper.gp.gp_Dir2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Dir2d_Crossed(self, *args)


    def __xor__(self, *args):
        """
        __xor__(gp_Dir2d self, gp_Dir2d Right) -> Standard_Real

        :type Right: OCC.wrapper.gp.gp_Dir2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Dir2d___xor__(self, *args)


    def Dot(self, *args):
        """
        Dot(gp_Dir2d self, gp_Dir2d Other) -> Standard_Real

        Computes the scalar product

        :type Other: OCC.wrapper.gp.gp_Dir2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Dir2d_Dot(self, *args)


    def __mul__(self, *args):
        """
        __mul__(gp_Dir2d self, gp_Dir2d Other) -> Standard_Real

        :type Other: OCC.wrapper.gp.gp_Dir2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Dir2d___mul__(self, *args)


    def Reverse(self, *args):
        """Reverse(gp_Dir2d self)"""
        return _gp.gp_Dir2d_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(gp_Dir2d self) -> gp_Dir2d

        Reverses the orientation of a direction

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        return _gp.gp_Dir2d_Reversed(self, *args)


    def __neg__(self, *args):
        """
        __neg__(gp_Dir2d self) -> gp_Dir2d

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        return _gp.gp_Dir2d___neg__(self, *args)


    def Mirror(self, *args):
        """
        Mirror(gp_Dir2d self, gp_Dir2d V)
        Mirror(gp_Dir2d self, gp_Ax2d A)

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Dir2d_Mirror(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(gp_Dir2d self, gp_Dir2d V) -> gp_Dir2d
        Mirrored(gp_Dir2d self, gp_Ax2d A) -> gp_Dir2d

        Performs the symmetrical transformation of a direction
        with respect to an axis placement which is the axis
        of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        return _gp.gp_Dir2d_Mirrored(self, *args)


    def Rotate(self, *args):
        """
        Rotate(gp_Dir2d self, Standard_Real const Ang)

        :type Ang: float

        """
        return _gp.gp_Dir2d_Rotate(self, *args)


    def Rotated(self, *args):
        """
        Rotated(gp_Dir2d self, Standard_Real const Ang) -> gp_Dir2d

        Rotates a direction.  Ang is the angular value of
        the rotation in radians.

        :type Ang: float
        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        return _gp.gp_Dir2d_Rotated(self, *args)


    def Transform(self, *args):
        """
        Transform(gp_Dir2d self, gp_Trsf2d T)

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _gp.gp_Dir2d_Transform(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_Dir2d self, gp_Trsf2d T) -> gp_Dir2d

        Transforms a direction with the "Trsf" T.
        Warnings :
        If the scale factor of the "Trsf" T is negative then the
        direction <me> is reversed.

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        return _gp.gp_Dir2d_Transformed(self, *args)

    __swig_destroy__ = _gp.delete_gp_Dir2d
gp_Dir2d_swigregister = _gp.gp_Dir2d_swigregister
gp_Dir2d_swigregister(gp_Dir2d)

class gp_Elips2d(object):
    """
    Describes an ellipse in the plane (2D space).
    An ellipse is defined by its major and minor radii and
    positioned in the plane with a coordinate system (a
    gp_Ax22d object) as follows:
    -   the origin of the coordinate system is the center of the ellipse,
    -   its "X Direction" defines the major axis of the ellipse, and
    -   its "Y Direction" defines the minor axis of the ellipse.
    This coordinate system is the "local coordinate system"
    of the ellipse. Its orientation (direct or indirect) gives an
    implicit orientation to the ellipse. In this coordinate
    system, the equation of the ellipse is:
    X*X / (MajorRadius**2) + Y*Y / (MinorRadius**2) = 1.0
    See Also
    gce_MakeElips2d which provides functions for more
    complex ellipse constructions
    Geom2d_Ellipse which provides additional functions for
    constructing ellipses and works, in particular, with the
    parametric equations of ellipses
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Elips2d self) -> gp_Elips2d
        __init__(gp_Elips2d self, gp_Ax2d MajorAxis, Standard_Real const MajorRadius, Standard_Real const MinorRadius, Standard_Boolean const Sense) -> gp_Elips2d
        __init__(gp_Elips2d self, gp_Ax22d A, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> gp_Elips2d

        Creates an ellipse with radii MajorRadius and
        MinorRadius, positioned in the plane by coordinate system A where:
        -   the origin of A is the center of the ellipse,
        -   the "X Direction" of A defines the major axis of
        the ellipse, that is, the major radius MajorRadius
        is measured along this axis, and
        -   the "Y Direction" of A defines the minor axis of
        the ellipse, that is, the minor radius MinorRadius
        is measured along this axis, and
        -   the orientation (direct or indirect sense) of A
        gives the orientation of the ellipse.
        Warnings :
        It is possible to create an ellipse with
        MajorRadius = MinorRadius.
        Raises ConstructionError if MajorRadius < MinorRadius or MinorRadius < 0.0

        :type A: OCC.wrapper.gp.gp_Ax22d
        :type MajorRadius: float
        :type MinorRadius: float

        """
        this = _gp.new_gp_Elips2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetLocation(self, *args):
        """
        SetLocation(gp_Elips2d self, gp_Pnt2d P)

        Modifies this ellipse, by redefining its local coordinate system so that
        -   its origin becomes P.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Elips2d_SetLocation(self, *args)


    def SetMajorRadius(self, *args):
        """
        SetMajorRadius(gp_Elips2d self, Standard_Real const MajorRadius)

        Changes the value of the major radius.
        Raises ConstructionError if MajorRadius < MinorRadius.

        :type MajorRadius: float

        """
        return _gp.gp_Elips2d_SetMajorRadius(self, *args)


    def SetMinorRadius(self, *args):
        """
        SetMinorRadius(gp_Elips2d self, Standard_Real const MinorRadius)

        Changes the value of the minor radius.
        Raises ConstructionError if MajorRadius < MinorRadius or MinorRadius < 0.0

        :type MinorRadius: float

        """
        return _gp.gp_Elips2d_SetMinorRadius(self, *args)


    def SetAxis(self, *args):
        """
        SetAxis(gp_Elips2d self, gp_Ax22d A)

        Modifies this ellipse, by redefining its local coordinate system so that
        it becomes A.

        :type A: OCC.wrapper.gp.gp_Ax22d

        """
        return _gp.gp_Elips2d_SetAxis(self, *args)


    def SetXAxis(self, *args):
        """
        SetXAxis(gp_Elips2d self, gp_Ax2d A)

        Modifies this ellipse, by redefining its local coordinate system so that
        its origin and its "X Direction"  become those
        of the axis A. The "Y  Direction"  is then
        recomputed. The orientation of the local coordinate
        system is not modified.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Elips2d_SetXAxis(self, *args)


    def SetYAxis(self, *args):
        """
        SetYAxis(gp_Elips2d self, gp_Ax2d A)

        Modifies this ellipse, by redefining its local coordinate system so that
        its origin and its "Y Direction"  become those
        of the axis A. The "X  Direction"  is then
        recomputed. The orientation of the local coordinate
        system is not modified.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Elips2d_SetYAxis(self, *args)


    def Area(self, *args):
        """
        Area(gp_Elips2d self) -> Standard_Real

        Computes the area of the ellipse.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Elips2d_Area(self, *args)


    def Coefficients(self, *args):
        """
        Coefficients(gp_Elips2d self)

        Returns the coefficients of the implicit equation of the ellipse.
        A * (X**2) + B * (Y**2) + 2*C*(X*Y) + 2*D*X + 2*E*Y + F = 0.

        :type A: float
        :type B: float
        :type C: float
        :type D: float
        :type E: float
        :type F: float

        """
        return _gp.gp_Elips2d_Coefficients(self, *args)


    def Directrix1(self, *args):
        """
        Directrix1(gp_Elips2d self) -> gp_Ax2d

        This directrix is the line normal to the XAxis of the ellipse
        in the local plane (Z = 0) at a distance d = MajorRadius / e
        from the center of the ellipse, where e is the eccentricity of
        the ellipse.
        This line is parallel to the "YAxis". The intersection point
        between directrix1 and the "XAxis" is the location point of the
        directrix1. This point is on the positive side of the "XAxis".

        Raised if Eccentricity = 0.0. (The ellipse degenerates into a
        circle)

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Elips2d_Directrix1(self, *args)


    def Directrix2(self, *args):
        """
        Directrix2(gp_Elips2d self) -> gp_Ax2d

        This line is obtained by the symmetrical transformation
        of "Directrix1" with respect to the minor axis of the ellipse.

        Raised if Eccentricity = 0.0. (The ellipse degenerates into a
        circle).

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Elips2d_Directrix2(self, *args)


    def Eccentricity(self, *args):
        """
        Eccentricity(gp_Elips2d self) -> Standard_Real

        Returns the eccentricity of the ellipse  between 0.0 and 1.0
        If f is the distance between the center of the ellipse and
        the Focus1 then the eccentricity e = f / MajorRadius.
        Returns 0 if MajorRadius = 0.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Elips2d_Eccentricity(self, *args)


    def Focal(self, *args):
        """
        Focal(gp_Elips2d self) -> Standard_Real

        Returns the distance between the center of the ellipse
        and focus1 or focus2.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Elips2d_Focal(self, *args)


    def Focus1(self, *args):
        """
        Focus1(gp_Elips2d self) -> gp_Pnt2d

        Returns the first focus of the ellipse. This focus is on the
        positive side of the major axis of the ellipse.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Elips2d_Focus1(self, *args)


    def Focus2(self, *args):
        """
        Focus2(gp_Elips2d self) -> gp_Pnt2d

        Returns the second focus of the ellipse. This focus is on the
        negative side of the major axis of the ellipse.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Elips2d_Focus2(self, *args)


    def Location(self, *args):
        """
        Returns the center of the ellipse.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _gp.gp_Elips2d_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MajorRadius(self, *args):
        """
        MajorRadius(gp_Elips2d self) -> Standard_Real

        Returns the major radius of the Ellipse.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Elips2d_MajorRadius(self, *args)


    def MinorRadius(self, *args):
        """
        MinorRadius(gp_Elips2d self) -> Standard_Real

        Returns the minor radius of the Ellipse.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Elips2d_MinorRadius(self, *args)


    def Parameter(self, *args):
        """
        Parameter(gp_Elips2d self) -> Standard_Real

        Returns p = (1 - e * e) * MajorRadius where e is the eccentricity
        of the ellipse.
        Returns 0 if MajorRadius = 0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Elips2d_Parameter(self, *args)


    def Axis(self, *args):
        """
        Returns the major axis of the ellipse.

        :rtype: OCC.wrapper.gp.gp_Ax22d

        """
        res = _gp.gp_Elips2d_Axis(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def XAxis(self, *args):
        """
        XAxis(gp_Elips2d self) -> gp_Ax2d

        Returns the major axis of the ellipse.

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Elips2d_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(gp_Elips2d self) -> gp_Ax2d

        Returns the minor axis of the ellipse.
        Reverses the direction of the circle.

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Elips2d_YAxis(self, *args)


    def Reverse(self, *args):
        """Reverse(gp_Elips2d self)"""
        return _gp.gp_Elips2d_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(gp_Elips2d self) -> gp_Elips2d

        :rtype: OCC.wrapper.gp.gp_Elips2d

        """
        return _gp.gp_Elips2d_Reversed(self, *args)


    def IsDirect(self, *args):
        """
        IsDirect(gp_Elips2d self) -> Standard_Boolean

        Returns true if the local coordinate system is direct
        and false in the other case.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Elips2d_IsDirect(self, *args)


    def Mirror(self, *args):
        """
        Mirror(gp_Elips2d self, gp_Pnt2d P)
        Mirror(gp_Elips2d self, gp_Ax2d A)

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Elips2d_Mirror(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(gp_Elips2d self, gp_Pnt2d P) -> gp_Elips2d
        Mirrored(gp_Elips2d self, gp_Ax2d A) -> gp_Elips2d

        Performs the symmetrical transformation of a ellipse with respect
        to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.gp.gp_Elips2d

        """
        return _gp.gp_Elips2d_Mirrored(self, *args)


    def Rotate(self, *args):
        """
        Rotate(gp_Elips2d self, gp_Pnt2d P, Standard_Real const Ang)

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _gp.gp_Elips2d_Rotate(self, *args)


    def Rotated(self, *args):
        """
        Rotated(gp_Elips2d self, gp_Pnt2d P, Standard_Real const Ang) -> gp_Elips2d

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.gp.gp_Elips2d

        """
        return _gp.gp_Elips2d_Rotated(self, *args)


    def Scale(self, *args):
        """
        Scale(gp_Elips2d self, gp_Pnt2d P, Standard_Real const S)

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _gp.gp_Elips2d_Scale(self, *args)


    def Scaled(self, *args):
        """
        Scaled(gp_Elips2d self, gp_Pnt2d P, Standard_Real const S) -> gp_Elips2d

        Scales a ellipse. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.gp.gp_Elips2d

        """
        return _gp.gp_Elips2d_Scaled(self, *args)


    def Transform(self, *args):
        """
        Transform(gp_Elips2d self, gp_Trsf2d T)

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _gp.gp_Elips2d_Transform(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_Elips2d self, gp_Trsf2d T) -> gp_Elips2d

        Transforms an ellipse with the transformation T from class Trsf2d.

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.gp.gp_Elips2d

        """
        return _gp.gp_Elips2d_Transformed(self, *args)


    def Translate(self, *args):
        """
        Translate(gp_Elips2d self, gp_Vec2d V)
        Translate(gp_Elips2d self, gp_Pnt2d P1, gp_Pnt2d P2)

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Elips2d_Translate(self, *args)


    def Translated(self, *args):
        """
        Translated(gp_Elips2d self, gp_Vec2d V) -> gp_Elips2d
        Translated(gp_Elips2d self, gp_Pnt2d P1, gp_Pnt2d P2) -> gp_Elips2d

        Translates a ellipse from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.gp.gp_Elips2d

        """
        return _gp.gp_Elips2d_Translated(self, *args)

    __swig_destroy__ = _gp.delete_gp_Elips2d
gp_Elips2d_swigregister = _gp.gp_Elips2d_swigregister
gp_Elips2d_swigregister(gp_Elips2d)

class gp_Hypr2d(object):
    """
    Describes a branch of a hyperbola in the plane (2D space).
    A hyperbola is defined by its major and minor radii, and
    positioned in the plane with a coordinate system (a
    gp_Ax22d object) of which:
    -   the origin is the center of the hyperbola,
    -   the "X Direction" defines the major axis of the hyperbola, and
    -   the "Y Direction" defines the minor axis of the hyperbola.
    This coordinate system is the "local coordinate system"
    of the hyperbola. The orientation of this coordinate
    system (direct or indirect) gives an implicit orientation to
    the hyperbola. In this coordinate system, the equation of
    the hyperbola is:
    X*X/(MajorRadius**2)-Y*Y/(MinorRadius**2) = 1.0
    The branch of the hyperbola described is the one located
    on the positive side of the major axis.
    The following schema shows the plane of the hyperbola,
    and in it, the respective positions of the three branches of
    hyperbolas constructed with the functions OtherBranch,
    ConjugateBranch1, and ConjugateBranch2:
    ^YAxis
    |
    FirstConjugateBranch
    |
    Other            |                Main
    --------------------- C ------------------------------>XAxis
    Branch           |                Branch
    |
    |
    SecondConjugateBranch
    |

    Warning
    The major radius can be less than the minor radius.
    See Also
    gce_MakeHypr2d which provides functions for more
    complex hyperbola constructions
    Geom2d_Hyperbola which provides additional functions
    for constructing hyperbolas and works, in particular, with
    the parametric equations of hyperbolas
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Hypr2d self) -> gp_Hypr2d
        __init__(gp_Hypr2d self, gp_Ax2d MajorAxis, Standard_Real const MajorRadius, Standard_Real const MinorRadius, Standard_Boolean const Sense) -> gp_Hypr2d
        __init__(gp_Hypr2d self, gp_Ax22d A, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> gp_Hypr2d

        a hyperbola with radii MajorRadius and
        MinorRadius, positioned in the plane by coordinate system A where:
        -   the origin of A is the center of the hyperbola,
        -   the "X Direction" of A defines the major axis of
        the hyperbola, that is, the major radius
        MajorRadius is measured along this axis, and
        -   the "Y Direction" of A defines the minor axis of
        the hyperbola, that is, the minor radius
        MinorRadius is measured along this axis, and
        -   the orientation (direct or indirect sense) of A
        gives the implicit orientation of the hyperbola.
        Warnings :
        It is yet  possible to create an Hyperbola with
        MajorRadius <= MinorRadius.
        Raises ConstructionError if MajorRadius < 0.0 or MinorRadius < 0.0

        :type A: OCC.wrapper.gp.gp_Ax22d
        :type MajorRadius: float
        :type MinorRadius: float

        """
        this = _gp.new_gp_Hypr2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetLocation(self, *args):
        """
        SetLocation(gp_Hypr2d self, gp_Pnt2d P)

        Modifies this hyperbola, by redefining its local
        coordinate system so that its origin becomes P.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Hypr2d_SetLocation(self, *args)


    def SetMajorRadius(self, *args):
        """
        SetMajorRadius(gp_Hypr2d self, Standard_Real const MajorRadius)

        Modifies the major or minor radius of this hyperbola.
        Exceptions
        Standard_ConstructionError if MajorRadius or
        MinorRadius is negative.

        :type MajorRadius: float

        """
        return _gp.gp_Hypr2d_SetMajorRadius(self, *args)


    def SetMinorRadius(self, *args):
        """
        SetMinorRadius(gp_Hypr2d self, Standard_Real const MinorRadius)

        Modifies the major or minor radius of this hyperbola.
        Exceptions
        Standard_ConstructionError if MajorRadius or
        MinorRadius is negative.

        :type MinorRadius: float

        """
        return _gp.gp_Hypr2d_SetMinorRadius(self, *args)


    def SetAxis(self, *args):
        """
        SetAxis(gp_Hypr2d self, gp_Ax22d A)

        Modifies this hyperbola, by redefining its local
        coordinate system so that it becomes A.

        :type A: OCC.wrapper.gp.gp_Ax22d

        """
        return _gp.gp_Hypr2d_SetAxis(self, *args)


    def SetXAxis(self, *args):
        """
        SetXAxis(gp_Hypr2d self, gp_Ax2d A)

        Changes the major axis of the hyperbola. The minor axis is
        recomputed and the location of the hyperbola too.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Hypr2d_SetXAxis(self, *args)


    def SetYAxis(self, *args):
        """
        SetYAxis(gp_Hypr2d self, gp_Ax2d A)

        Changes the minor axis of the hyperbola.The minor axis is
        recomputed and the location of the hyperbola too.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Hypr2d_SetYAxis(self, *args)


    def Asymptote1(self, *args):
        """
        Asymptote1(gp_Hypr2d self) -> gp_Ax2d

        In the local coordinate system of the hyperbola the equation of
        the hyperbola is (X*X)/(A*A) - (Y*Y)/(B*B) = 1.0 and the
        equation of the first asymptote is Y = (B/A)*X
        where A is the major radius of the hyperbola and B the minor
        radius of the hyperbola.
        Raises ConstructionError if MajorRadius = 0.0

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Hypr2d_Asymptote1(self, *args)


    def Asymptote2(self, *args):
        """
        Asymptote2(gp_Hypr2d self) -> gp_Ax2d

        In the local coordinate system of the hyperbola the equation of
        the hyperbola is (X*X)/(A*A) - (Y*Y)/(B*B) = 1.0 and the
        equation of the first asymptote is Y = -(B/A)*X
        where A is the major radius of the hyperbola and B the minor
        radius of the hyperbola.
        Raises ConstructionError if MajorRadius = 0.0

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Hypr2d_Asymptote2(self, *args)


    def Coefficients(self, *args):
        """
        Coefficients(gp_Hypr2d self)

        Computes the coefficients of the implicit equation of
        the hyperbola :
        A * (X**2) + B * (Y**2) + 2*C*(X*Y) + 2*D*X + 2*E*Y + F = 0.

        :type A: float
        :type B: float
        :type C: float
        :type D: float
        :type E: float
        :type F: float

        """
        return _gp.gp_Hypr2d_Coefficients(self, *args)


    def ConjugateBranch1(self, *args):
        """
        ConjugateBranch1(gp_Hypr2d self) -> gp_Hypr2d

        Computes the branch of hyperbola which is on the positive side of the
        "YAxis" of <me>.

        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _gp.gp_Hypr2d_ConjugateBranch1(self, *args)


    def ConjugateBranch2(self, *args):
        """
        ConjugateBranch2(gp_Hypr2d self) -> gp_Hypr2d

        Computes the branch of hyperbola which is on the negative side of the
        "YAxis" of <me>.

        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _gp.gp_Hypr2d_ConjugateBranch2(self, *args)


    def Directrix1(self, *args):
        """
        Directrix1(gp_Hypr2d self) -> gp_Ax2d

        Computes the directrix which is the line normal to the XAxis of the hyperbola
        in the local plane (Z = 0) at a distance d = MajorRadius / e
        from the center of the hyperbola, where e is the eccentricity of
        the hyperbola.
        This line is parallel to the "YAxis". The intersection point
        between the "Directrix1" and the "XAxis" is the "Location" point
        of the "Directrix1".
        This point is on the positive side of the "XAxis".

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Hypr2d_Directrix1(self, *args)


    def Directrix2(self, *args):
        """
        Directrix2(gp_Hypr2d self) -> gp_Ax2d

        This line is obtained by the symmetrical transformation
        of "Directrix1" with respect to the "YAxis" of the hyperbola.

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Hypr2d_Directrix2(self, *args)


    def Eccentricity(self, *args):
        """
        Eccentricity(gp_Hypr2d self) -> Standard_Real

        Returns the excentricity of the hyperbola (e > 1).
        If f is the distance between the location of the hyperbola
        and the Focus1 then the eccentricity e = f / MajorRadius. Raises DomainError if MajorRadius = 0.0.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Hypr2d_Eccentricity(self, *args)


    def Focal(self, *args):
        """
        Focal(gp_Hypr2d self) -> Standard_Real

        Computes the focal distance. It is the distance between the
        "Location" of the hyperbola and "Focus1" or "Focus2".

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Hypr2d_Focal(self, *args)


    def Focus1(self, *args):
        """
        Focus1(gp_Hypr2d self) -> gp_Pnt2d

        Returns the first focus of the hyperbola. This focus is on the
        positive side of the "XAxis" of the hyperbola.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Hypr2d_Focus1(self, *args)


    def Focus2(self, *args):
        """
        Focus2(gp_Hypr2d self) -> gp_Pnt2d

        Returns the second focus of the hyperbola. This focus is on the
        negative side of the "XAxis" of the hyperbola.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Hypr2d_Focus2(self, *args)


    def Location(self, *args):
        """
        Returns  the location point of the hyperbola.
        It is the intersection point between the "XAxis" and
        the "YAxis".

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _gp.gp_Hypr2d_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def MajorRadius(self, *args):
        """
        MajorRadius(gp_Hypr2d self) -> Standard_Real

        Returns the major radius of the hyperbola (it is the radius
        corresponding to the "XAxis" of the hyperbola).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Hypr2d_MajorRadius(self, *args)


    def MinorRadius(self, *args):
        """
        MinorRadius(gp_Hypr2d self) -> Standard_Real

        Returns the minor radius of the hyperbola (it is the radius
        corresponding to the "YAxis" of the hyperbola).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Hypr2d_MinorRadius(self, *args)


    def OtherBranch(self, *args):
        """
        OtherBranch(gp_Hypr2d self) -> gp_Hypr2d

        Returns the branch of hyperbola obtained by doing the
        symmetrical transformation of <me> with respect to the
        "YAxis" of <me>.

        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _gp.gp_Hypr2d_OtherBranch(self, *args)


    def Parameter(self, *args):
        """
        Parameter(gp_Hypr2d self) -> Standard_Real

        Returns p = (e * e - 1) * MajorRadius where e is the
        eccentricity of the hyperbola.
        Raises DomainError if MajorRadius = 0.0

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Hypr2d_Parameter(self, *args)


    def Axis(self, *args):
        """
        Returns the axisplacement of the hyperbola.

        :rtype: OCC.wrapper.gp.gp_Ax22d

        """
        res = _gp.gp_Hypr2d_Axis(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def XAxis(self, *args):
        """
        XAxis(gp_Hypr2d self) -> gp_Ax2d

        Computes an axis whose
        -   the origin is the center of this hyperbola, and
        -   the unit vector is the "X Direction" or "Y Direction"
        respectively of the local coordinate system of this hyperbola
        Returns the major axis of the hyperbola.

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Hypr2d_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(gp_Hypr2d self) -> gp_Ax2d

        Computes an axis whose
        -   the origin is the center of this hyperbola, and
        -   the unit vector is the "X Direction" or "Y Direction"
        respectively of the local coordinate system of this hyperbola
        Returns the minor axis of the hyperbola.

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Hypr2d_YAxis(self, *args)


    def Reverse(self, *args):
        """Reverse(gp_Hypr2d self)"""
        return _gp.gp_Hypr2d_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(gp_Hypr2d self) -> gp_Hypr2d

        Reverses the orientation of the local coordinate system
        of this hyperbola (the "Y Axis" is reversed). Therefore,
        the implicit orientation of this hyperbola is reversed.
        Note:
        -   Reverse assigns the result to this hyperbola, while
        -   Reversed creates a new one.

        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _gp.gp_Hypr2d_Reversed(self, *args)


    def IsDirect(self, *args):
        """
        IsDirect(gp_Hypr2d self) -> Standard_Boolean

        Returns true if the local coordinate system is direct
        and false in the other case.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Hypr2d_IsDirect(self, *args)


    def Mirror(self, *args):
        """
        Mirror(gp_Hypr2d self, gp_Pnt2d P)
        Mirror(gp_Hypr2d self, gp_Ax2d A)

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Hypr2d_Mirror(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(gp_Hypr2d self, gp_Pnt2d P) -> gp_Hypr2d
        Mirrored(gp_Hypr2d self, gp_Ax2d A) -> gp_Hypr2d

        Performs the symmetrical transformation of an hyperbola with
        respect to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _gp.gp_Hypr2d_Mirrored(self, *args)


    def Rotate(self, *args):
        """
        Rotate(gp_Hypr2d self, gp_Pnt2d P, Standard_Real const Ang)

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _gp.gp_Hypr2d_Rotate(self, *args)


    def Rotated(self, *args):
        """
        Rotated(gp_Hypr2d self, gp_Pnt2d P, Standard_Real const Ang) -> gp_Hypr2d

        Rotates an hyperbola. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _gp.gp_Hypr2d_Rotated(self, *args)


    def Scale(self, *args):
        """
        Scale(gp_Hypr2d self, gp_Pnt2d P, Standard_Real const S)

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _gp.gp_Hypr2d_Scale(self, *args)


    def Scaled(self, *args):
        """
        Scaled(gp_Hypr2d self, gp_Pnt2d P, Standard_Real const S) -> gp_Hypr2d

        Scales an hyperbola. <S> is the scaling value.
        If <S> is positive only the location point is
        modified. But if <S> is negative the "XAxis" is
        reversed and the "YAxis" too.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _gp.gp_Hypr2d_Scaled(self, *args)


    def Transform(self, *args):
        """
        Transform(gp_Hypr2d self, gp_Trsf2d T)

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _gp.gp_Hypr2d_Transform(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_Hypr2d self, gp_Trsf2d T) -> gp_Hypr2d

        Transforms an hyperbola with the transformation T from
        class Trsf2d.

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _gp.gp_Hypr2d_Transformed(self, *args)


    def Translate(self, *args):
        """
        Translate(gp_Hypr2d self, gp_Vec2d V)
        Translate(gp_Hypr2d self, gp_Pnt2d P1, gp_Pnt2d P2)

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Hypr2d_Translate(self, *args)


    def Translated(self, *args):
        """
        Translated(gp_Hypr2d self, gp_Vec2d V) -> gp_Hypr2d
        Translated(gp_Hypr2d self, gp_Pnt2d P1, gp_Pnt2d P2) -> gp_Hypr2d

        Translates an hyperbola from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _gp.gp_Hypr2d_Translated(self, *args)

    __swig_destroy__ = _gp.delete_gp_Hypr2d
gp_Hypr2d_swigregister = _gp.gp_Hypr2d_swigregister
gp_Hypr2d_swigregister(gp_Hypr2d)

class gp_Mat2d(object):
    """
    Describes a two column, two row matrix. This sort of
    object is used in various vectorial or matrix computations.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Mat2d self) -> gp_Mat2d
        __init__(gp_Mat2d self, gp_XY Col1, gp_XY Col2) -> gp_Mat2d

        Col1, Col2 are the 2 columns of the matrix.

        :type Col1: OCC.wrapper.gp.gp_XY
        :type Col2: OCC.wrapper.gp.gp_XY

        """
        this = _gp.new_gp_Mat2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetCol(self, *args):
        """
        SetCol(gp_Mat2d self, Standard_Integer const Col, gp_XY Value)

        Assigns the two coordinates of Value to the column of range
        Col of this matrix
        Raises OutOfRange if Col < 1 or Col > 2.

        :type Col: int
        :type Value: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_Mat2d_SetCol(self, *args)


    def SetCols(self, *args):
        """
        SetCols(gp_Mat2d self, gp_XY Col1, gp_XY Col2)

        Assigns the number pairs Col1, Col2 to the two columns of   this matrix

        :type Col1: OCC.wrapper.gp.gp_XY
        :type Col2: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_Mat2d_SetCols(self, *args)


    def SetDiagonal(self, *args):
        """
        SetDiagonal(gp_Mat2d self, Standard_Real const X1, Standard_Real const X2)

        Modifies the main diagonal of the matrix.
        <me>.Value (1, 1) = X1
        <me>.Value (2, 2) = X2
        The other coefficients of the matrix are not modified.

        :type X1: float
        :type X2: float

        """
        return _gp.gp_Mat2d_SetDiagonal(self, *args)


    def SetIdentity(self, *args):
        """
        SetIdentity(gp_Mat2d self)

        Modifies this matrix, so that it represents the Identity matrix.


        """
        return _gp.gp_Mat2d_SetIdentity(self, *args)


    def SetRotation(self, *args):
        """
        SetRotation(gp_Mat2d self, Standard_Real const Ang)

        Modifies this matrix, so that it representso a rotation. Ang is the angular
        value in radian of the rotation.

        :type Ang: float

        """
        return _gp.gp_Mat2d_SetRotation(self, *args)


    def SetRow(self, *args):
        """
        SetRow(gp_Mat2d self, Standard_Integer const Row, gp_XY Value)

        Assigns the two coordinates of Value to the row of index Row of this matrix.
        Raises OutOfRange if Row < 1 or Row > 2.

        :type Row: int
        :type Value: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_Mat2d_SetRow(self, *args)


    def SetRows(self, *args):
        """
        SetRows(gp_Mat2d self, gp_XY Row1, gp_XY Row2)

        Assigns the number pairs Row1, Row2 to the two rows of this matrix.

        :type Row1: OCC.wrapper.gp.gp_XY
        :type Row2: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_Mat2d_SetRows(self, *args)


    def SetScale(self, *args):
        """
        SetScale(gp_Mat2d self, Standard_Real const S)

        Modifies the matrix such that it
        represents a scaling transformation, where S is the scale   factor :
        | S    0.0 |
        <me> =  | 0.0   S  |

        :type S: float

        """
        return _gp.gp_Mat2d_SetScale(self, *args)


    def SetValue(self, *args):
        """
        SetValue(gp_Mat2d self, Standard_Integer const Row, Standard_Integer const Col, Standard_Real const Value)

        Assigns <Value> to the coefficient of row Row, column Col of this matrix.
        Raises OutOfRange if Row < 1 or Row > 2 or Col < 1 or Col > 2

        :type Row: int
        :type Col: int
        :type Value: float

        """
        return _gp.gp_Mat2d_SetValue(self, *args)


    def Column(self, *args):
        """
        Column(gp_Mat2d self, Standard_Integer const Col) -> gp_XY

        Returns the column of Col index.
        Raises OutOfRange if Col < 1 or Col > 2

        :type Col: int
        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_Mat2d_Column(self, *args)


    def Determinant(self, *args):
        """
        Determinant(gp_Mat2d self) -> Standard_Real

        Computes the determinant of the matrix.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Mat2d_Determinant(self, *args)


    def Diagonal(self, *args):
        """
        Diagonal(gp_Mat2d self) -> gp_XY

        Returns the main diagonal of the matrix.

        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_Mat2d_Diagonal(self, *args)


    def Row(self, *args):
        """
        Row(gp_Mat2d self, Standard_Integer const Row) -> gp_XY

        Returns the row of index Row.
        Raised if Row < 1 or Row > 2

        :type Row: int
        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_Mat2d_Row(self, *args)


    def Value(self, *args):
        """
        Value(gp_Mat2d self, Standard_Integer const Row, Standard_Integer const Col) -> Standard_Real const &

        Returns the coefficient of range (Row, Col)
        Raises OutOfRange
        if Row < 1 or Row > 2 or Col < 1 or Col > 2

        :type Row: int
        :type Col: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Mat2d_Value(self, *args)


    def ChangeValue(self, *args):
        """
        ChangeValue(gp_Mat2d self, Standard_Integer const Row, Standard_Integer const Col) -> Standard_Real &

        Returns the coefficient of range (Row, Col)
        Raises OutOfRange
        if Row < 1 or Row > 2 or Col < 1 or Col > 2

        :type Row: int
        :type Col: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Mat2d_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        __call__(gp_Mat2d self, Standard_Integer const Row, Standard_Integer const Col) -> Standard_Real const
        __call__(gp_Mat2d self, Standard_Integer const Row, Standard_Integer const Col) -> Standard_Real &

        :type Row: int
        :type Col: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Mat2d___call__(self, *args)


    def IsSingular(self, *args):
        """
        IsSingular(gp_Mat2d self) -> Standard_Boolean

        Returns true if this matrix is singular (and therefore, cannot be inverted).
        The Gauss LU decomposition is used to invert the matrix
        so the matrix is considered as singular if the largest
        pivot found is lower or equal to Resolution from gp.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Mat2d_IsSingular(self, *args)


    def Add(self, *args):
        """
        Add(gp_Mat2d self, gp_Mat2d Other)

        :type Other: OCC.wrapper.gp.gp_Mat2d

        """
        return _gp.gp_Mat2d_Add(self, *args)


    def __iadd__(self, *args):
        """
        __iadd__(gp_Mat2d self, gp_Mat2d Other)

        :type Other: OCC.wrapper.gp.gp_Mat2d

        """
        return _gp.gp_Mat2d___iadd__(self, *args)


    def Added(self, *args):
        """
        Added(gp_Mat2d self, gp_Mat2d Other) -> gp_Mat2d

        Computes the sum of this matrix and the matrix
        Other.for each coefficient of the matrix :
        <me>.Coef(i,j) + <Other>.Coef(i,j)
        Note:
        -   operator += assigns the result to this matrix, while
        -   operator + creates a new one.

        :type Other: OCC.wrapper.gp.gp_Mat2d
        :rtype: OCC.wrapper.gp.gp_Mat2d

        """
        return _gp.gp_Mat2d_Added(self, *args)


    def __add__(self, *args):
        """
        __add__(gp_Mat2d self, gp_Mat2d Other) -> gp_Mat2d

        :type Other: OCC.wrapper.gp.gp_Mat2d
        :rtype: OCC.wrapper.gp.gp_Mat2d

        """
        return _gp.gp_Mat2d___add__(self, *args)


    def Divide(self, *args):
        """
        Divide(gp_Mat2d self, Standard_Real const Scalar)

        :type Scalar: float

        """
        return _gp.gp_Mat2d_Divide(self, *args)


    def __itruediv__(self, *args):
        return _gp.gp_Mat2d___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def Divided(self, *args):
        """
        Divided(gp_Mat2d self, Standard_Real const Scalar) -> gp_Mat2d

        Divides all the coefficients of the matrix by a scalar.

        :type Scalar: float
        :rtype: OCC.wrapper.gp.gp_Mat2d

        """
        return _gp.gp_Mat2d_Divided(self, *args)


    def __truediv__(self, *args):
        return _gp.gp_Mat2d___truediv__(self, *args)
    __div__ = __truediv__



    def Invert(self, *args):
        """Invert(gp_Mat2d self)"""
        return _gp.gp_Mat2d_Invert(self, *args)


    def Inverted(self, *args):
        """
        Inverted(gp_Mat2d self) -> gp_Mat2d

        Inverses the matrix and raises exception if the matrix
        is singular.

        :rtype: OCC.wrapper.gp.gp_Mat2d

        """
        return _gp.gp_Mat2d_Inverted(self, *args)


    def PreMultiply(self, *args):
        """
        PreMultiply(gp_Mat2d self, gp_Mat2d Other)

        Modifies this matrix by premultiplying it by the matrix Other
        <me> = Other * <me>.

        :type Other: OCC.wrapper.gp.gp_Mat2d

        """
        return _gp.gp_Mat2d_PreMultiply(self, *args)


    def Multiplied(self, *args):
        """
        Multiplied(gp_Mat2d self, gp_Mat2d Other) -> gp_Mat2d
        Multiplied(gp_Mat2d self, Standard_Real const Scalar) -> gp_Mat2d

        :type Scalar: float
        :rtype: OCC.wrapper.gp.gp_Mat2d

        """
        return _gp.gp_Mat2d_Multiplied(self, *args)


    def __mul__(self, *args):
        """
        __mul__(gp_Mat2d self, gp_Mat2d Other) -> gp_Mat2d
        __mul__(gp_Mat2d self, Standard_Real const Scalar) -> gp_Mat2d

        :type Scalar: float
        :rtype: OCC.wrapper.gp.gp_Mat2d

        """
        return _gp.gp_Mat2d___mul__(self, *args)


    def Multiply(self, *args):
        """
        Multiply(gp_Mat2d self, gp_Mat2d Other)
        Multiply(gp_Mat2d self, Standard_Real const Scalar)

        Multiplies all the coefficients of the matrix by a scalar.

        :type Scalar: float

        """
        return _gp.gp_Mat2d_Multiply(self, *args)


    def __imul__(self, *args):
        """
        __imul__(gp_Mat2d self, Standard_Real const Scalar)

        :type Scalar: float

        """
        return _gp.gp_Mat2d___imul__(self, *args)


    def Power(self, *args):
        """
        Power(gp_Mat2d self, Standard_Integer const N)

        :type N: int

        """
        return _gp.gp_Mat2d_Power(self, *args)


    def Powered(self, *args):
        """
        Powered(gp_Mat2d self, Standard_Integer const N) -> gp_Mat2d

        computes <me> = <me> * <me> * .......* <me>, N time.
        if N = 0 <me> = Identity
        if N < 0 <me> = <me>.Invert() *...........* <me>.Invert().
        If N < 0 an exception can be raised if the matrix is not
        inversible

        :type N: int
        :rtype: OCC.wrapper.gp.gp_Mat2d

        """
        return _gp.gp_Mat2d_Powered(self, *args)


    def Subtract(self, *args):
        """
        Subtract(gp_Mat2d self, gp_Mat2d Other)

        :type Other: OCC.wrapper.gp.gp_Mat2d

        """
        return _gp.gp_Mat2d_Subtract(self, *args)


    def __isub__(self, *args):
        """
        __isub__(gp_Mat2d self, gp_Mat2d Other)

        :type Other: OCC.wrapper.gp.gp_Mat2d

        """
        return _gp.gp_Mat2d___isub__(self, *args)


    def Subtracted(self, *args):
        """
        Subtracted(gp_Mat2d self, gp_Mat2d Other) -> gp_Mat2d

        Computes for each coefficient of the matrix :
        <me>.Coef(i,j) - <Other>.Coef(i,j)

        :type Other: OCC.wrapper.gp.gp_Mat2d
        :rtype: OCC.wrapper.gp.gp_Mat2d

        """
        return _gp.gp_Mat2d_Subtracted(self, *args)


    def __sub__(self, *args):
        """
        __sub__(gp_Mat2d self, gp_Mat2d Other) -> gp_Mat2d

        :type Other: OCC.wrapper.gp.gp_Mat2d
        :rtype: OCC.wrapper.gp.gp_Mat2d

        """
        return _gp.gp_Mat2d___sub__(self, *args)


    def Transpose(self, *args):
        """Transpose(gp_Mat2d self)"""
        return _gp.gp_Mat2d_Transpose(self, *args)


    def Transposed(self, *args):
        """
        Transposed(gp_Mat2d self) -> gp_Mat2d

        Transposes the matrix. A(j, i) -> A (i, j)

        :rtype: OCC.wrapper.gp.gp_Mat2d

        """
        return _gp.gp_Mat2d_Transposed(self, *args)

    __swig_destroy__ = _gp.delete_gp_Mat2d
gp_Mat2d_swigregister = _gp.gp_Mat2d_swigregister
gp_Mat2d_swigregister(gp_Mat2d)

class gp_Cylinder(object):
    """
    Describes an infinite cylindrical surface.
    A cylinder is defined by its radius and positioned in space
    with a coordinate system (a gp_Ax3 object), the "main
    Axis" of which is the axis of the cylinder. This coordinate
    system is the "local coordinate system" of the cylinder.
    Note: when a gp_Cylinder cylinder is converted into a
    Geom_CylindricalSurface cylinder, some implicit
    properties of its local coordinate system are used explicitly:
    -   its origin, "X Direction", "Y Direction" and "main
    Direction" are used directly to define the parametric
    directions on the cylinder and the origin of the parameters,
    -   its implicit orientation (right-handed or left-handed)
    gives an orientation (direct or indirect) to the
    Geom_CylindricalSurface cylinder.
    See Also
    gce_MakeCylinder which provides functions for more
    complex cylinder constructions
    Geom_CylindricalSurface which provides additional
    functions for constructing cylinders and works, in
    particular, with the parametric equations of cylinders gp_Ax3
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Cylinder self) -> gp_Cylinder
        __init__(gp_Cylinder self, gp_Ax3 A3, Standard_Real const Radius) -> gp_Cylinder

        Creates a cylinder of radius Radius, whose axis is the "main
        Axis" of A3. A3 is the local coordinate system of the cylinder.   Raises ConstructionErrord if R < 0.0

        :type A3: OCC.wrapper.gp.gp_Ax3
        :type Radius: float

        """
        this = _gp.new_gp_Cylinder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetAxis(self, *args):
        """
        SetAxis(gp_Cylinder self, gp_Ax1 A1)

        Changes the symmetry axis of the cylinder. Raises ConstructionError if the direction of A1 is parallel to the "XDirection"
        of the coordinate system of the cylinder.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Cylinder_SetAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(gp_Cylinder self, gp_Pnt Loc)

        Changes the location of the surface.

        :type Loc: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Cylinder_SetLocation(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(gp_Cylinder self, gp_Ax3 A3)

        Change the local coordinate system of the surface.

        :type A3: OCC.wrapper.gp.gp_Ax3

        """
        return _gp.gp_Cylinder_SetPosition(self, *args)


    def SetRadius(self, *args):
        """
        SetRadius(gp_Cylinder self, Standard_Real const R)

        Modifies the radius of this cylinder.
        Exceptions
        Standard_ConstructionError if R is negative.

        :type R: float

        """
        return _gp.gp_Cylinder_SetRadius(self, *args)


    def UReverse(self, *args):
        """
        UReverse(gp_Cylinder self)

        Reverses the   U   parametrization of   the cylinder
        reversing the YAxis.


        """
        return _gp.gp_Cylinder_UReverse(self, *args)


    def VReverse(self, *args):
        """
        VReverse(gp_Cylinder self)

        Reverses the   V   parametrization of   the  plane
        reversing the Axis.


        """
        return _gp.gp_Cylinder_VReverse(self, *args)


    def Direct(self, *args):
        """
        Direct(gp_Cylinder self) -> Standard_Boolean

        Returns true if the local coordinate system of this cylinder is right-handed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Cylinder_Direct(self, *args)


    def Axis(self, *args):
        """
        Returns the symmetry axis of the cylinder.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        res = _gp.gp_Cylinder_Axis(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Coefficients(self, *args):
        """
        Coefficients(gp_Cylinder self)

        Computes the coefficients of the implicit equation of the quadric
        in the absolute cartesian coordinate system :
        A1.X**2 + A2.Y**2 + A3.Z**2 + 2.(B1.X.Y + B2.X.Z + B3.Y.Z) +
        2.(C1.X + C2.Y + C3.Z) + D = 0.0

        :type A1: float
        :type A2: float
        :type A3: float
        :type B1: float
        :type B2: float
        :type B3: float
        :type C1: float
        :type C2: float
        :type C3: float
        :type D: float

        """
        return _gp.gp_Cylinder_Coefficients(self, *args)


    def Location(self, *args):
        """
        Returns the "Location" point of the cylinder.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _gp.gp_Cylinder_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Position(self, *args):
        """
        Returns the local coordinate system of the cylinder.

        :rtype: OCC.wrapper.gp.gp_Ax3

        """
        res = _gp.gp_Cylinder_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Radius(self, *args):
        """
        Radius(gp_Cylinder self) -> Standard_Real

        Returns the radius of the cylinder.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Cylinder_Radius(self, *args)


    def XAxis(self, *args):
        """
        XAxis(gp_Cylinder self) -> gp_Ax1

        Returns the axis X of the cylinder.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Cylinder_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(gp_Cylinder self) -> gp_Ax1

        Returns the axis Y of the cylinder.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Cylinder_YAxis(self, *args)


    def Mirror(self, *args):
        """
        Mirror(gp_Cylinder self, gp_Pnt P)
        Mirror(gp_Cylinder self, gp_Ax1 A1)
        Mirror(gp_Cylinder self, gp_Ax2 A2)

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Cylinder_Mirror(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(gp_Cylinder self, gp_Pnt P) -> gp_Cylinder
        Mirrored(gp_Cylinder self, gp_Ax1 A1) -> gp_Cylinder
        Mirrored(gp_Cylinder self, gp_Ax2 A2) -> gp_Cylinder

        Performs the symmetrical transformation of a cylinder with respect
        to a plane. The axis placement A2 locates the plane of the
        of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.gp.gp_Cylinder

        """
        return _gp.gp_Cylinder_Mirrored(self, *args)


    def Rotate(self, *args):
        """
        Rotate(gp_Cylinder self, gp_Ax1 A1, Standard_Real const Ang)

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _gp.gp_Cylinder_Rotate(self, *args)


    def Rotated(self, *args):
        """
        Rotated(gp_Cylinder self, gp_Ax1 A1, Standard_Real const Ang) -> gp_Cylinder

        Rotates a cylinder. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.gp.gp_Cylinder

        """
        return _gp.gp_Cylinder_Rotated(self, *args)


    def Scale(self, *args):
        """
        Scale(gp_Cylinder self, gp_Pnt P, Standard_Real const S)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _gp.gp_Cylinder_Scale(self, *args)


    def Scaled(self, *args):
        """
        Scaled(gp_Cylinder self, gp_Pnt P, Standard_Real const S) -> gp_Cylinder

        Scales a cylinder. S is the scaling value.
        The absolute value of S is used to scale the cylinder

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.gp.gp_Cylinder

        """
        return _gp.gp_Cylinder_Scaled(self, *args)


    def Transform(self, *args):
        """
        Transform(gp_Cylinder self, gp_Trsf T)

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _gp.gp_Cylinder_Transform(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_Cylinder self, gp_Trsf T) -> gp_Cylinder

        Transforms a cylinder with the transformation T from class Trsf.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_Cylinder

        """
        return _gp.gp_Cylinder_Transformed(self, *args)


    def Translate(self, *args):
        """
        Translate(gp_Cylinder self, gp_Vec V)
        Translate(gp_Cylinder self, gp_Pnt P1, gp_Pnt P2)

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Cylinder_Translate(self, *args)


    def Translated(self, *args):
        """
        Translated(gp_Cylinder self, gp_Vec V) -> gp_Cylinder
        Translated(gp_Cylinder self, gp_Pnt P1, gp_Pnt P2) -> gp_Cylinder

        Translates a cylinder from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.gp.gp_Cylinder

        """
        return _gp.gp_Cylinder_Translated(self, *args)

    __swig_destroy__ = _gp.delete_gp_Cylinder
gp_Cylinder_swigregister = _gp.gp_Cylinder_swigregister
gp_Cylinder_swigregister(gp_Cylinder)

class gp_Pln(object):
    """
    Describes a plane.
    A plane is positioned in space with a coordinate system
    (a gp_Ax3 object), such that the plane is defined by the
    origin, "X Direction" and "Y Direction" of this coordinate
    system, which is the "local coordinate system" of the
    plane. The "main Direction" of the coordinate system is a
    vector normal to the plane. It gives the plane an implicit
    orientation such that the plane is said to be "direct", if the
    coordinate system is right-handed, or "indirect" in the other case.
    Note: when a gp_Pln plane is converted into a
    Geom_Plane plane, some implicit properties of its local
    coordinate system are used explicitly:
    -   its origin defines the origin of the two parameters of
    the planar surface,
    -   its implicit orientation is also that of the Geom_Plane.
    See Also
    gce_MakePln which provides functions for more complex
    plane constructions
    Geom_Plane which provides additional functions for
    constructing planes and works, in particular, with the
    parametric equations of planes
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Pln self) -> gp_Pln
        __init__(gp_Pln self, gp_Ax3 A3) -> gp_Pln
        __init__(gp_Pln self, gp_Pnt P, gp_Dir V) -> gp_Pln
        __init__(gp_Pln self, Standard_Real const A, Standard_Real const B, Standard_Real const C, Standard_Real const D) -> gp_Pln

        Creates a plane from its cartesian equation :
        A * X + B * Y + C * Z + D = 0.0
        Raises ConstructionError if Sqrt (A*A + B*B + C*C) <= Resolution from gp.

        :type A: float
        :type B: float
        :type C: float
        :type D: float

        """
        this = _gp.new_gp_Pln(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Coefficients(self, *args):
        """
        Coefficients(gp_Pln self)

        Returns the coefficients of the plane's cartesian equation :
        A * X + B * Y + C * Z + D = 0.

        :type A: float
        :type B: float
        :type C: float
        :type D: float

        """
        return _gp.gp_Pln_Coefficients(self, *args)


    def SetAxis(self, *args):
        """
        SetAxis(gp_Pln self, gp_Ax1 A1)

        Modifies this plane, by redefining its local coordinate system so that
        -   its origin and "main Direction" become those of the
        axis A1 (the "X Direction" and "Y Direction" are then recomputed).
        Raises ConstructionError if the A1 is parallel to the "XAxis" of the plane.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Pln_SetAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(gp_Pln self, gp_Pnt Loc)

        Changes the origin of the plane.

        :type Loc: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Pln_SetLocation(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(gp_Pln self, gp_Ax3 A3)

        Changes the local coordinate system of the plane.

        :type A3: OCC.wrapper.gp.gp_Ax3

        """
        return _gp.gp_Pln_SetPosition(self, *args)


    def UReverse(self, *args):
        """
        UReverse(gp_Pln self)

        Reverses the   U   parametrization of   the  plane
        reversing the XAxis.


        """
        return _gp.gp_Pln_UReverse(self, *args)


    def VReverse(self, *args):
        """
        VReverse(gp_Pln self)

        Reverses the   V   parametrization of   the  plane
        reversing the YAxis.


        """
        return _gp.gp_Pln_VReverse(self, *args)


    def Direct(self, *args):
        """
        Direct(gp_Pln self) -> Standard_Boolean

        returns true if the Ax3 is right handed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Pln_Direct(self, *args)


    def Axis(self, *args):
        """
        Returns the plane's normal Axis.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        res = _gp.gp_Pln_Axis(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Location(self, *args):
        """
        Returns the plane's location (origin).

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _gp.gp_Pln_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Position(self, *args):
        """
        Returns the local coordinate system of the plane .

        :rtype: OCC.wrapper.gp.gp_Ax3

        """
        res = _gp.gp_Pln_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Distance(self, *args):
        """
        Distance(gp_Pln self, gp_Pnt P) -> Standard_Real
        Distance(gp_Pln self, gp_Lin L) -> Standard_Real
        Distance(gp_Pln self, gp_Pln Other) -> Standard_Real

        Computes the distance between two planes.

        :type Other: OCC.wrapper.gp.gp_Pln
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Pln_Distance(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(gp_Pln self, gp_Pnt P) -> Standard_Real
        SquareDistance(gp_Pln self, gp_Lin L) -> Standard_Real
        SquareDistance(gp_Pln self, gp_Pln Other) -> Standard_Real

        Computes the square distance between two planes.

        :type Other: OCC.wrapper.gp.gp_Pln
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Pln_SquareDistance(self, *args)


    def XAxis(self, *args):
        """
        XAxis(gp_Pln self) -> gp_Ax1

        Returns the X axis of the plane.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Pln_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(gp_Pln self) -> gp_Ax1

        Returns the Y axis  of the plane.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Pln_YAxis(self, *args)


    def Contains(self, *args):
        """
        Contains(gp_Pln self, gp_Pnt P, Standard_Real const LinearTolerance) -> Standard_Boolean
        Contains(gp_Pln self, gp_Lin L, Standard_Real const LinearTolerance, Standard_Real const AngularTolerance) -> Standard_Boolean

        Returns true if this plane contains the line L. This means that
        -   the distance between point P and this plane is less
        than or equal to LinearTolerance, or
        -   line L is normal to the "main Axis" of the local
        coordinate system of this plane, within the tolerance
        AngularTolerance, and the distance between the origin
        of line L and this plane is less than or equal to
        LinearTolerance.

        :type L: OCC.wrapper.gp.gp_Lin
        :type LinearTolerance: float
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Pln_Contains(self, *args)


    def Mirror(self, *args):
        """
        Mirror(gp_Pln self, gp_Pnt P)
        Mirror(gp_Pln self, gp_Ax1 A1)
        Mirror(gp_Pln self, gp_Ax2 A2)

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Pln_Mirror(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(gp_Pln self, gp_Pnt P) -> gp_Pln
        Mirrored(gp_Pln self, gp_Ax1 A1) -> gp_Pln
        Mirrored(gp_Pln self, gp_Ax2 A2) -> gp_Pln

        Performs the  symmetrical transformation  of  a
        plane    with respect to    an axis  placement.   The axis
        placement  <A2> locates the plane  of  the symmetry.   The
        transformation is performed  on  the  "Location" point, on
        the  "XAxis" and  the    "YAxis".  The resulting    normal
        direction is the cross  product between   the "XDirection"
        and the "YDirection"  after  transformation if the initial
        plane was right handed, else it is the opposite.

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.gp.gp_Pln

        """
        return _gp.gp_Pln_Mirrored(self, *args)


    def Rotate(self, *args):
        """
        Rotate(gp_Pln self, gp_Ax1 A1, Standard_Real const Ang)

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _gp.gp_Pln_Rotate(self, *args)


    def Rotated(self, *args):
        """
        Rotated(gp_Pln self, gp_Ax1 A1, Standard_Real const Ang) -> gp_Pln

        rotates a plane. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.gp.gp_Pln

        """
        return _gp.gp_Pln_Rotated(self, *args)


    def Scale(self, *args):
        """
        Scale(gp_Pln self, gp_Pnt P, Standard_Real const S)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _gp.gp_Pln_Scale(self, *args)


    def Scaled(self, *args):
        """
        Scaled(gp_Pln self, gp_Pnt P, Standard_Real const S) -> gp_Pln

        Scales a plane. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.gp.gp_Pln

        """
        return _gp.gp_Pln_Scaled(self, *args)


    def Transform(self, *args):
        """
        Transform(gp_Pln self, gp_Trsf T)

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _gp.gp_Pln_Transform(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_Pln self, gp_Trsf T) -> gp_Pln

        Transforms a plane with the transformation T from class Trsf.
        The transformation is performed on the "Location"
        point, on the "XAxis" and the "YAxis".
        The resulting normal direction is the cross product between
        the "XDirection" and the "YDirection" after transformation.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_Pln

        """
        return _gp.gp_Pln_Transformed(self, *args)


    def Translate(self, *args):
        """
        Translate(gp_Pln self, gp_Vec V)
        Translate(gp_Pln self, gp_Pnt P1, gp_Pnt P2)

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Pln_Translate(self, *args)


    def Translated(self, *args):
        """
        Translated(gp_Pln self, gp_Vec V) -> gp_Pln
        Translated(gp_Pln self, gp_Pnt P1, gp_Pnt P2) -> gp_Pln

        Translates a plane from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.gp.gp_Pln

        """
        return _gp.gp_Pln_Translated(self, *args)

    __swig_destroy__ = _gp.delete_gp_Pln
gp_Pln_swigregister = _gp.gp_Pln_swigregister
gp_Pln_swigregister(gp_Pln)

class gp_Cone(object):
    """
    Defines an infinite conical surface.
    A cone is defined by its half-angle (can be negative) at the apex and
    positioned in space with a coordinate system (a gp_Ax3
    object) and a "reference radius" where:
    -   the "main Axis" of the coordinate system is the axis of   revolution of the cone,
    -   the plane defined by the origin, the "X Direction" and
    the "Y Direction" of the coordinate system is the
    reference plane of the cone; the intersection of the
    cone with this reference plane is a circle of radius
    equal to the reference radius,
    if the half-angle is positive, the apex of the cone is on
    the negative side of the "main Axis" of the coordinate
    system. If the half-angle is negative, the apex is on the   positive side.
    This coordinate system is the "local coordinate system" of the cone.
    Note: when a gp_Cone cone is converted into a
    Geom_ConicalSurface cone, some implicit properties of
    its local coordinate system are used explicitly:
    -   its origin, "X Direction", "Y Direction" and "main
    Direction" are used directly to define the parametric
    directions on the cone and the origin of the parameters,
    -   its implicit orientation (right-handed or left-handed)
    gives the orientation (direct or indirect) of the
    Geom_ConicalSurface cone.
    See Also
    gce_MakeCone which provides functions for more
    complex cone constructions
    Geom_ConicalSurface which provides additional
    functions for constructing cones and works, in particular,
    with the parametric equations of cones gp_Ax3
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Cone self) -> gp_Cone
        __init__(gp_Cone self, gp_Ax3 A3, Standard_Real const Ang, Standard_Real const Radius) -> gp_Cone

        Creates an infinite conical surface. A3 locates the cone
        in the space and defines the reference plane of the surface.
        Ang is the conical surface semi-angle. Its absolute value is in range
        ]0, PI/2[.
        Radius is the radius of the circle in the reference plane of
        the cone.
        Raises ConstructionError
        * if Radius is lower than 0.0
        * Abs(Ang) < Resolution from gp  or Abs(Ang) >= (PI/2) - Resolution.

        :type A3: OCC.wrapper.gp.gp_Ax3
        :type Ang: float
        :type Radius: float

        """
        this = _gp.new_gp_Cone(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetAxis(self, *args):
        """
        SetAxis(gp_Cone self, gp_Ax1 A1)

        Changes the symmetry axis of the cone.  Raises ConstructionError
        the direction of A1 is parallel to the "XDirection"
        of the coordinate system of the cone.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Cone_SetAxis(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(gp_Cone self, gp_Pnt Loc)

        Changes the location of the cone.

        :type Loc: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Cone_SetLocation(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(gp_Cone self, gp_Ax3 A3)

        Changes the local coordinate system of the cone.
        This coordinate system defines the reference plane of the cone.

        :type A3: OCC.wrapper.gp.gp_Ax3

        """
        return _gp.gp_Cone_SetPosition(self, *args)


    def SetRadius(self, *args):
        """
        SetRadius(gp_Cone self, Standard_Real const R)

        Changes the radius of the cone in the reference plane of
        the cone.
        Raised if R < 0.0

        :type R: float

        """
        return _gp.gp_Cone_SetRadius(self, *args)


    def SetSemiAngle(self, *args):
        """
        SetSemiAngle(gp_Cone self, Standard_Real const Ang)

        Changes the semi-angle of the cone.
        Semi-angle can be negative. Its absolute value
        Abs(Ang) is in range ]0,PI/2[.
        Raises ConstructionError if Abs(Ang) < Resolution from gp or Abs(Ang) >= PI/2 - Resolution

        :type Ang: float

        """
        return _gp.gp_Cone_SetSemiAngle(self, *args)


    def Apex(self, *args):
        """
        Apex(gp_Cone self) -> gp_Pnt

        Computes the cone's top. The Apex of the cone is on the
        negative side of the symmetry axis of the cone.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Cone_Apex(self, *args)


    def UReverse(self, *args):
        """
        UReverse(gp_Cone self)

        Reverses the   U   parametrization of   the  cone
        reversing the YAxis.


        """
        return _gp.gp_Cone_UReverse(self, *args)


    def VReverse(self, *args):
        """
        VReverse(gp_Cone self)

        Reverses the   V   parametrization of   the  cone  reversing the ZAxis.


        """
        return _gp.gp_Cone_VReverse(self, *args)


    def Direct(self, *args):
        """
        Direct(gp_Cone self) -> Standard_Boolean

        Returns true if the local coordinate system of this cone is right-handed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Cone_Direct(self, *args)


    def Axis(self, *args):
        """
        returns the symmetry axis of the cone.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        res = _gp.gp_Cone_Axis(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Coefficients(self, *args):
        """
        Coefficients(gp_Cone self)

        Computes the coefficients of the implicit equation of the quadric
        in the absolute cartesian coordinates system :
        A1.X**2 + A2.Y**2 + A3.Z**2 + 2.(B1.X.Y + B2.X.Z + B3.Y.Z) +
        2.(C1.X + C2.Y + C3.Z) + D = 0.0

        :type A1: float
        :type A2: float
        :type A3: float
        :type B1: float
        :type B2: float
        :type B3: float
        :type C1: float
        :type C2: float
        :type C3: float
        :type D: float

        """
        return _gp.gp_Cone_Coefficients(self, *args)


    def Location(self, *args):
        """
        returns the "Location" point of the cone.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _gp.gp_Cone_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Position(self, *args):
        """
        Returns the local coordinates system of the cone.

        :rtype: OCC.wrapper.gp.gp_Ax3

        """
        res = _gp.gp_Cone_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RefRadius(self, *args):
        """
        RefRadius(gp_Cone self) -> Standard_Real

        Returns the radius of the cone in the reference plane.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Cone_RefRadius(self, *args)


    def SemiAngle(self, *args):
        """
        SemiAngle(gp_Cone self) -> Standard_Real

        Returns the half-angle at the apex of this cone.
        Attention! Semi-angle can be negative.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Cone_SemiAngle(self, *args)


    def XAxis(self, *args):
        """
        XAxis(gp_Cone self) -> gp_Ax1

        Returns the XAxis of the reference plane.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Cone_XAxis(self, *args)


    def YAxis(self, *args):
        """
        YAxis(gp_Cone self) -> gp_Ax1

        Returns the YAxis of the reference plane.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Cone_YAxis(self, *args)


    def Mirror(self, *args):
        """
        Mirror(gp_Cone self, gp_Pnt P)
        Mirror(gp_Cone self, gp_Ax1 A1)
        Mirror(gp_Cone self, gp_Ax2 A2)

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Cone_Mirror(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(gp_Cone self, gp_Pnt P) -> gp_Cone
        Mirrored(gp_Cone self, gp_Ax1 A1) -> gp_Cone
        Mirrored(gp_Cone self, gp_Ax2 A2) -> gp_Cone

        Performs the symmetrical transformation of a cone with respect
        to a plane. The axis placement A2 locates the plane of the
        of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.gp.gp_Cone

        """
        return _gp.gp_Cone_Mirrored(self, *args)


    def Rotate(self, *args):
        """
        Rotate(gp_Cone self, gp_Ax1 A1, Standard_Real const Ang)

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _gp.gp_Cone_Rotate(self, *args)


    def Rotated(self, *args):
        """
        Rotated(gp_Cone self, gp_Ax1 A1, Standard_Real const Ang) -> gp_Cone

        Rotates a cone. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.gp.gp_Cone

        """
        return _gp.gp_Cone_Rotated(self, *args)


    def Scale(self, *args):
        """
        Scale(gp_Cone self, gp_Pnt P, Standard_Real const S)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _gp.gp_Cone_Scale(self, *args)


    def Scaled(self, *args):
        """
        Scaled(gp_Cone self, gp_Pnt P, Standard_Real const S) -> gp_Cone

        Scales a cone. S is the scaling value.
        The absolute value of S is used to scale the cone

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.gp.gp_Cone

        """
        return _gp.gp_Cone_Scaled(self, *args)


    def Transform(self, *args):
        """
        Transform(gp_Cone self, gp_Trsf T)

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _gp.gp_Cone_Transform(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_Cone self, gp_Trsf T) -> gp_Cone

        Transforms a cone with the transformation T from class Trsf.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_Cone

        """
        return _gp.gp_Cone_Transformed(self, *args)


    def Translate(self, *args):
        """
        Translate(gp_Cone self, gp_Vec V)
        Translate(gp_Cone self, gp_Pnt P1, gp_Pnt P2)

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Cone_Translate(self, *args)


    def Translated(self, *args):
        """
        Translated(gp_Cone self, gp_Vec V) -> gp_Cone
        Translated(gp_Cone self, gp_Pnt P1, gp_Pnt P2) -> gp_Cone

        Translates a cone from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.gp.gp_Cone

        """
        return _gp.gp_Cone_Translated(self, *args)

    __swig_destroy__ = _gp.delete_gp_Cone
gp_Cone_swigregister = _gp.gp_Cone_swigregister
gp_Cone_swigregister(gp_Cone)

class gp_Parab2d(object):
    """
    Describes a parabola in the plane (2D space).
    A parabola is defined by its focal length (that is, the
    distance between its focus and apex) and positioned in
    the plane with a coordinate system (a gp_Ax22d object) where:
    -   the origin of the coordinate system is on the apex of
    the parabola, and
    -   the "X Axis" of the coordinate system is the axis of
    symmetry; the parabola is on the positive side of this axis.
    This coordinate system is the "local coordinate system"
    of the parabola. Its orientation (direct or indirect sense)
    gives an implicit orientation to the parabola.
    In this coordinate system, the equation for the parabola is:
    Y**2 = (2*P) * X.
    where P, referred to as the parameter of the parabola, is
    the distance between the focus and the directrix (P is
    twice the focal length).
    See Also
    GCE2d_MakeParab2d which provides functions for
    more complex parabola constructions
    Geom2d_Parabola which provides additional functions
    for constructing parabolas and works, in particular, with
    the parametric equations of parabolas
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Parab2d self) -> gp_Parab2d
        __init__(gp_Parab2d self, gp_Ax2d theMirrorAxis, Standard_Real const theFocalLength, Standard_Boolean const theSense) -> gp_Parab2d
        __init__(gp_Parab2d self, gp_Ax22d theAxes, Standard_Real const theFocalLength) -> gp_Parab2d
        __init__(gp_Parab2d self, gp_Ax2d theDirectrix, gp_Pnt2d theFocus, Standard_Boolean const theSense) -> gp_Parab2d

        Creates a parabola with the directrix and the focus point.
        Y-axis of the parabola (in User Coordinate System - UCS) is
        the direction of theDirectrix. X-axis always directs from theDirectrix
        to theFocus point and always comes through theFocus.
        Apex of the parabola is a middle point between the theFocus and the
        intersection point of theDirectrix and the X-axis.
        Warnings : It is possible to have FocalLength = 0 (when theFocus lies
        in theDirectrix). In this case, X-direction of the parabola is defined 
        by theSense parameter. If theSense == TRUE (by default) then right-handed
        coordinate system is used, otherwise - left-handed. Result parabola will look
        like a line, which is perpendicular to the directrix.

        :type theDirectrix: OCC.wrapper.gp.gp_Ax2d
        :type theFocus: OCC.wrapper.gp.gp_Pnt2d
        :type theSense: bool

        """
        this = _gp.new_gp_Parab2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetFocal(self, *args):
        """
        SetFocal(gp_Parab2d self, Standard_Real const Focal)

        Changes the focal distance of the parabola
        Warnings : It is possible to have Focal = 0.
        Raises ConstructionError if Focal < 0.0

        :type Focal: float

        """
        return _gp.gp_Parab2d_SetFocal(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(gp_Parab2d self, gp_Pnt2d P)

        Changes the "Location" point of the parabola. It is the
        vertex of the parabola.

        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Parab2d_SetLocation(self, *args)


    def SetMirrorAxis(self, *args):
        """
        SetMirrorAxis(gp_Parab2d self, gp_Ax2d A)

        Modifies this parabola, by redefining its local coordinate system so that
        its origin and "X Direction" become those of the axis
        MA. The "Y Direction" of the local coordinate system is
        then recomputed. The orientation of the local
        coordinate system is not modified.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Parab2d_SetMirrorAxis(self, *args)


    def SetAxis(self, *args):
        """
        SetAxis(gp_Parab2d self, gp_Ax22d A)

        Changes the local coordinate system of the parabola.
        The "Location" point of A becomes the vertex of the parabola.

        :type A: OCC.wrapper.gp.gp_Ax22d

        """
        return _gp.gp_Parab2d_SetAxis(self, *args)


    def Coefficients(self, *args):
        """
        Coefficients(gp_Parab2d self)

        Computes the coefficients of the implicit equation of the parabola
        (in WCS - World Coordinate System).
        A * (X**2) + B * (Y**2) + 2*C*(X*Y) + 2*D*X + 2*E*Y + F = 0.

        :type A: float
        :type B: float
        :type C: float
        :type D: float
        :type E: float
        :type F: float

        """
        return _gp.gp_Parab2d_Coefficients(self, *args)


    def Directrix(self, *args):
        """
        Directrix(gp_Parab2d self) -> gp_Ax2d

        Computes the directrix of the parabola.
        The directrix is:
        -   a line parallel to the "Y Direction" of the local
        coordinate system of this parabola, and
        -   located on the negative side of the axis of symmetry,
        at a distance from the apex which is equal to the focal  length of this parabola.
        The directrix is returned as an axis (a gp_Ax2d object),
        the origin of which is situated on the "X Axis" of this parabola.

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Parab2d_Directrix(self, *args)


    def Focal(self, *args):
        """
        Focal(gp_Parab2d self) -> Standard_Real

        Returns the distance between the vertex and the focus
        of the parabola.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Parab2d_Focal(self, *args)


    def Focus(self, *args):
        """
        Focus(gp_Parab2d self) -> gp_Pnt2d

        Returns the focus of the parabola.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Parab2d_Focus(self, *args)


    def Location(self, *args):
        """
        Location(gp_Parab2d self) -> gp_Pnt2d

        Returns the vertex of the parabola.

        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Parab2d_Location(self, *args)


    def MirrorAxis(self, *args):
        """
        MirrorAxis(gp_Parab2d self) -> gp_Ax2d

        Returns the symmetry axis of the parabola.
        The "Location" point of this axis is the vertex of the parabola.

        :rtype: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Parab2d_MirrorAxis(self, *args)


    def Axis(self, *args):
        """
        Axis(gp_Parab2d self) -> gp_Ax22d

        Returns the local coordinate system of the parabola.
        The "Location" point of this axis is the vertex of the parabola.

        :rtype: OCC.wrapper.gp.gp_Ax22d

        """
        return _gp.gp_Parab2d_Axis(self, *args)


    def Parameter(self, *args):
        """
        Parameter(gp_Parab2d self) -> Standard_Real

        Returns the distance between the focus and the
        directrix of the parabola.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Parab2d_Parameter(self, *args)


    def Reverse(self, *args):
        """Reverse(gp_Parab2d self)"""
        return _gp.gp_Parab2d_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(gp_Parab2d self) -> gp_Parab2d

        Reverses the orientation of the local coordinate system
        of this parabola (the "Y Direction" is reversed).
        Therefore, the implicit orientation of this parabola is reversed.
        Note:
        -   Reverse assigns the result to this parabola, while
        -   Reversed creates a new one.

        :rtype: OCC.wrapper.gp.gp_Parab2d

        """
        return _gp.gp_Parab2d_Reversed(self, *args)


    def IsDirect(self, *args):
        """
        IsDirect(gp_Parab2d self) -> Standard_Boolean

        Returns true if the local coordinate system is direct
        and false in the other case.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Parab2d_IsDirect(self, *args)


    def Mirror(self, *args):
        """
        Mirror(gp_Parab2d self, gp_Pnt2d P)
        Mirror(gp_Parab2d self, gp_Ax2d A)

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Parab2d_Mirror(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(gp_Parab2d self, gp_Pnt2d P) -> gp_Parab2d
        Mirrored(gp_Parab2d self, gp_Ax2d A) -> gp_Parab2d

        Performs the symmetrical transformation of a parabola with respect
        to an axis placement which is the axis of the symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.gp.gp_Parab2d

        """
        return _gp.gp_Parab2d_Mirrored(self, *args)


    def Rotate(self, *args):
        """
        Rotate(gp_Parab2d self, gp_Pnt2d P, Standard_Real const Ang)

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _gp.gp_Parab2d_Rotate(self, *args)


    def Rotated(self, *args):
        """
        Rotated(gp_Parab2d self, gp_Pnt2d P, Standard_Real const Ang) -> gp_Parab2d

        Rotates a parabola. P is the center of the rotation.
        Ang is the angular value of the rotation in radians.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.gp.gp_Parab2d

        """
        return _gp.gp_Parab2d_Rotated(self, *args)


    def Scale(self, *args):
        """
        Scale(gp_Parab2d self, gp_Pnt2d P, Standard_Real const S)

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _gp.gp_Parab2d_Scale(self, *args)


    def Scaled(self, *args):
        """
        Scaled(gp_Parab2d self, gp_Pnt2d P, Standard_Real const S) -> gp_Parab2d

        Scales a parabola. S is the scaling value.
        If S is negative the direction of the symmetry axis
        "XAxis" is reversed and the direction of the "YAxis" too.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.gp.gp_Parab2d

        """
        return _gp.gp_Parab2d_Scaled(self, *args)


    def Transform(self, *args):
        """
        Transform(gp_Parab2d self, gp_Trsf2d T)

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _gp.gp_Parab2d_Transform(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_Parab2d self, gp_Trsf2d T) -> gp_Parab2d

        Transforms an parabola with the transformation T from class Trsf2d.

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.gp.gp_Parab2d

        """
        return _gp.gp_Parab2d_Transformed(self, *args)


    def Translate(self, *args):
        """
        Translate(gp_Parab2d self, gp_Vec2d V)
        Translate(gp_Parab2d self, gp_Pnt2d P1, gp_Pnt2d P2)

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Parab2d_Translate(self, *args)


    def Translated(self, *args):
        """
        Translated(gp_Parab2d self, gp_Vec2d V) -> gp_Parab2d
        Translated(gp_Parab2d self, gp_Pnt2d P1, gp_Pnt2d P2) -> gp_Parab2d

        Translates a parabola from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.gp.gp_Parab2d

        """
        return _gp.gp_Parab2d_Translated(self, *args)

    __swig_destroy__ = _gp.delete_gp_Parab2d
gp_Parab2d_swigregister = _gp.gp_Parab2d_swigregister
gp_Parab2d_swigregister(gp_Parab2d)

class gp_Trsf2d(object):
    """
    Defines a non-persistent transformation in 2D space.
    The following transformations are implemented :
    . Translation, Rotation, Scale
    . Symmetry with respect to a point and a line.
    Complex transformations can be obtained by combining the
    previous elementary transformations using the method Multiply.
    The transformations can be represented as follow :

    V1   V2   T       XY        XY
    | a11  a12  a13 |   | x |     | x'|
    | a21  a22  a23 |   | y |     | y'|
    |  0    0    1  |   | 1 |     | 1 |

    where {V1, V2} defines the vectorial part of the transformation
    and T defines the translation part of the transformation.
    This transformation never change the nature of the objects.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Trsf2d self) -> gp_Trsf2d
        __init__(gp_Trsf2d self, gp_Trsf T) -> gp_Trsf2d

        Creates a 2d transformation in the XY plane from a
        3d transformation .

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        this = _gp.new_gp_Trsf2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetMirror(self, *args):
        """
        SetMirror(gp_Trsf2d self, gp_Pnt2d P)
        SetMirror(gp_Trsf2d self, gp_Ax2d A)

        Changes the transformation into a symmetrical transformation.
        A is the center of the axial symmetry.

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Trsf2d_SetMirror(self, *args)


    def SetRotation(self, *args):
        """
        SetRotation(gp_Trsf2d self, gp_Pnt2d P, Standard_Real const Ang)

        Changes the transformation into a rotation.
        P is the rotation's center and Ang is the angular value of the
        rotation in radian.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _gp.gp_Trsf2d_SetRotation(self, *args)


    def SetScale(self, *args):
        """
        SetScale(gp_Trsf2d self, gp_Pnt2d P, Standard_Real const S)

        Changes the transformation into a scale.
        P is the center of the scale and S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _gp.gp_Trsf2d_SetScale(self, *args)


    def SetTransformation(self, *args):
        """
        SetTransformation(gp_Trsf2d self, gp_Ax2d FromSystem1, gp_Ax2d ToSystem2)
        SetTransformation(gp_Trsf2d self, gp_Ax2d ToSystem)

        Changes the transformation allowing passage from the basic
        coordinate system
        {P(0.,0.,0.), VX (1.,0.,0.), VY (0.,1.,0.)}
        to the local coordinate system defined with the Ax2d ToSystem.

        :type ToSystem: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Trsf2d_SetTransformation(self, *args)


    def SetTranslation(self, *args):
        """
        SetTranslation(gp_Trsf2d self, gp_Vec2d V)
        SetTranslation(gp_Trsf2d self, gp_Pnt2d P1, gp_Pnt2d P2)

        Makes the transformation into a translation from
        the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Trsf2d_SetTranslation(self, *args)


    def SetTranslationPart(self, *args):
        """
        SetTranslationPart(gp_Trsf2d self, gp_Vec2d V)

        Replaces the translation vector with V.

        :type V: OCC.wrapper.gp.gp_Vec2d

        """
        return _gp.gp_Trsf2d_SetTranslationPart(self, *args)


    def SetScaleFactor(self, *args):
        """
        SetScaleFactor(gp_Trsf2d self, Standard_Real const S)

        Modifies the scale factor.

        :type S: float

        """
        return _gp.gp_Trsf2d_SetScaleFactor(self, *args)


    def IsNegative(self, *args):
        """
        IsNegative(gp_Trsf2d self) -> Standard_Boolean

        Returns true if the determinant of the vectorial part of
        this transformation is negative..

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Trsf2d_IsNegative(self, *args)


    def Form(self, *args):
        """
        Form(gp_Trsf2d self) -> gp_TrsfForm

        Returns the nature of the transformation. It can be  an
        identity transformation, a rotation, a translation, a mirror
        (relative to a point or an axis), a scaling transformation,
        or a compound transformation.

        :rtype: OCC.wrapper.gp.gp_TrsfForm

        """
        return _gp.gp_Trsf2d_Form(self, *args)


    def ScaleFactor(self, *args):
        """
        ScaleFactor(gp_Trsf2d self) -> Standard_Real

        Returns the scale factor.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Trsf2d_ScaleFactor(self, *args)


    def TranslationPart(self, *args):
        """
        Returns the translation part of the transformation's matrix

        :rtype: OCC.wrapper.gp.gp_XY

        """
        res = _gp.gp_Trsf2d_TranslationPart(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VectorialPart(self, *args):
        """
        VectorialPart(gp_Trsf2d self) -> gp_Mat2d

        Returns the vectorial part of the transformation. It is a
        2*2 matrix which includes the scale factor.

        :rtype: OCC.wrapper.gp.gp_Mat2d

        """
        return _gp.gp_Trsf2d_VectorialPart(self, *args)


    def HVectorialPart(self, *args):
        """
        Returns the homogeneous vectorial part of the transformation.
        It is a 2*2 matrix which doesn't include the scale factor.
        The coefficients of this matrix must be multiplied by the
        scale factor to obtain the coefficients of the transformation.

        :rtype: OCC.wrapper.gp.gp_Mat2d

        """
        res = _gp.gp_Trsf2d_HVectorialPart(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RotationPart(self, *args):
        """
        RotationPart(gp_Trsf2d self) -> Standard_Real

        Returns the angle corresponding to the rotational component
        of the transformation matrix (operation opposite to SetRotation()).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Trsf2d_RotationPart(self, *args)


    def Value(self, *args):
        """
        Value(gp_Trsf2d self, Standard_Integer const Row, Standard_Integer const Col) -> Standard_Real

        Returns the coefficients of the transformation's matrix.
        It is a 2 rows * 3 columns matrix.
        Raises OutOfRange if Row < 1 or Row > 2 or Col < 1 or Col > 3

        :type Row: int
        :type Col: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Trsf2d_Value(self, *args)


    def Invert(self, *args):
        """Invert(gp_Trsf2d self)"""
        return _gp.gp_Trsf2d_Invert(self, *args)


    def Inverted(self, *args):
        """
        Inverted(gp_Trsf2d self) -> gp_Trsf2d

        Computes the reverse transformation.
        Raises an exception if the matrix of the transformation
        is not inversible, it means that the scale factor is lower
        or equal to Resolution from package gp.

        :rtype: OCC.wrapper.gp.gp_Trsf2d

        """
        return _gp.gp_Trsf2d_Inverted(self, *args)


    def Multiplied(self, *args):
        """
        Multiplied(gp_Trsf2d self, gp_Trsf2d T) -> gp_Trsf2d

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.gp.gp_Trsf2d

        """
        return _gp.gp_Trsf2d_Multiplied(self, *args)


    def __mul__(self, *args):
        """
        __mul__(gp_Trsf2d self, gp_Trsf2d T) -> gp_Trsf2d

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.gp.gp_Trsf2d

        """
        return _gp.gp_Trsf2d___mul__(self, *args)


    def Multiply(self, *args):
        """
        Multiply(gp_Trsf2d self, gp_Trsf2d T)

        Computes the transformation composed from <me> and T.
        <me> = <me> * T

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _gp.gp_Trsf2d_Multiply(self, *args)


    def __imul__(self, *args):
        """
        __imul__(gp_Trsf2d self, gp_Trsf2d T)

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _gp.gp_Trsf2d___imul__(self, *args)


    def PreMultiply(self, *args):
        """
        PreMultiply(gp_Trsf2d self, gp_Trsf2d T)

        Computes the transformation composed from <me> and T.
        <me> = T * <me>

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _gp.gp_Trsf2d_PreMultiply(self, *args)


    def Power(self, *args):
        """
        Power(gp_Trsf2d self, Standard_Integer const N)

        :type N: int

        """
        return _gp.gp_Trsf2d_Power(self, *args)


    def Powered(self, *args):
        """
        Powered(gp_Trsf2d self, Standard_Integer const N) -> gp_Trsf2d

        Computes the following composition of transformations
        <me> * <me> * .......* <me>,  N time.
        if N = 0 <me> = Identity
        if N < 0 <me> = <me>.Inverse() *...........* <me>.Inverse().

        Raises if N < 0 and if the matrix of the transformation not
        inversible.

        :type N: int
        :rtype: OCC.wrapper.gp.gp_Trsf2d

        """
        return _gp.gp_Trsf2d_Powered(self, *args)


    def Transforms(self, *args):
        """
        Transforms(gp_Trsf2d self)
        Transforms(gp_Trsf2d self, gp_XY Coord)

        Transforms  a doublet XY with a Trsf2d

        :type Coord: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_Trsf2d_Transforms(self, *args)


    def SetValues(self, *args):
        """
        SetValues(gp_Trsf2d self, Standard_Real const a11, Standard_Real const a12, Standard_Real const a13, Standard_Real const a21, Standard_Real const a22, Standard_Real const a23)

        Sets the coefficients  of the transformation. The
        transformation  of the  point  x,y is  the point
        x',y' with :

        x' = a11 x + a12 y + a13
        y' = a21 x + a22 y + a23

        The method Value(i,j) will return aij.
        Raises ConstructionError if the determinant of the aij is null.
        If the matrix as not a uniform scale it will be orthogonalized before future using.

        :type a11: float
        :type a12: float
        :type a13: float
        :type a21: float
        :type a22: float
        :type a23: float

        """
        return _gp.gp_Trsf2d_SetValues(self, *args)

    __swig_destroy__ = _gp.delete_gp_Trsf2d
gp_Trsf2d_swigregister = _gp.gp_Trsf2d_swigregister
gp_Trsf2d_swigregister(gp_Trsf2d)

class gp_XY(object):
    """
    This class describes a cartesian coordinate entity in 2D
    space {X,Y}. This class is non persistent. This entity used
    for algebraic calculation. An XY can be transformed with a
    Trsf2d or a  GTrsf2d from package gp.
    It is used in vectorial computations or for holding this type
    of information in data structures.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_XY self) -> gp_XY
        __init__(gp_XY self, Standard_Real const X, Standard_Real const Y) -> gp_XY

        a number pair defined by the XY coordinates

        :type X: float
        :type Y: float

        """
        this = _gp.new_gp_XY(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetCoord(self, *args):
        """
        SetCoord(gp_XY self, Standard_Integer const Index, Standard_Real const Xi)
        SetCoord(gp_XY self, Standard_Real const X, Standard_Real const Y)

        For this number pair, assigns
        the values X and Y to its coordinates

        :type X: float
        :type Y: float

        """
        return _gp.gp_XY_SetCoord(self, *args)


    def SetX(self, *args):
        """
        SetX(gp_XY self, Standard_Real const X)

        Assigns the given value to the X coordinate of this number pair.

        :type X: float

        """
        return _gp.gp_XY_SetX(self, *args)


    def SetY(self, *args):
        """
        SetY(gp_XY self, Standard_Real const Y)

        Assigns the given value to the Y  coordinate of this number pair.

        :type Y: float

        """
        return _gp.gp_XY_SetY(self, *args)


    def ChangeCoord(self, *args):
        """
        ChangeCoord(gp_XY self, Standard_Integer const theIndex) -> Standard_Real &

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_XY_ChangeCoord(self, *args)


    def Coord(self, *args):
        """
        Coord(gp_XY self, Standard_Integer const Index) -> Standard_Real
        Coord(gp_XY self)

        For this number pair, returns its coordinates X and Y.

        :type X: float
        :type Y: float

        """
        return _gp.gp_XY_Coord(self, *args)


    def X(self, *args):
        """
        X(gp_XY self) -> Standard_Real

        Returns the X coordinate of this number pair.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_XY_X(self, *args)


    def Y(self, *args):
        """
        Y(gp_XY self) -> Standard_Real

        Returns the Y coordinate of this number pair.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_XY_Y(self, *args)


    def Modulus(self, *args):
        """
        Modulus(gp_XY self) -> Standard_Real

        Computes Sqrt (X*X + Y*Y) where X and Y are the two coordinates of this number pair.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_XY_Modulus(self, *args)


    def SquareModulus(self, *args):
        """
        SquareModulus(gp_XY self) -> Standard_Real

        Computes X*X + Y*Y where X and Y are the two coordinates of this number pair.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_XY_SquareModulus(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(gp_XY self, gp_XY Other, Standard_Real const Tolerance) -> Standard_Boolean

        Returns true if the coordinates of this number pair are
        equal to the respective coordinates of the number pair
        Other, within the specified tolerance Tolerance. I.e.:
        abs(<me>.X() - Other.X()) <= Tolerance and
        abs(<me>.Y() - Other.Y()) <= Tolerance and
        computations

        :type Other: OCC.wrapper.gp.gp_XY
        :type Tolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_XY_IsEqual(self, *args)


    def Add(self, *args):
        """
        Add(gp_XY self, gp_XY Other)

        Computes the sum of this number pair and number pair Other
        <me>.X() = <me>.X() + Other.X()
        <me>.Y() = <me>.Y() + Other.Y()

        :type Other: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_XY_Add(self, *args)


    def __iadd__(self, *args):
        """
        __iadd__(gp_XY self, gp_XY Other)

        :type Other: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_XY___iadd__(self, *args)


    def Added(self, *args):
        """
        Added(gp_XY self, gp_XY Other) -> gp_XY

        Computes the sum of this number pair and number pair Other
        new.X() = <me>.X() + Other.X()
        new.Y() = <me>.Y() + Other.Y()

        :type Other: OCC.wrapper.gp.gp_XY
        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_XY_Added(self, *args)


    def __add__(self, *args):
        """
        __add__(gp_XY self, gp_XY Other) -> gp_XY

        :type Other: OCC.wrapper.gp.gp_XY
        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_XY___add__(self, *args)


    def Crossed(self, *args):
        """
        Crossed(gp_XY self, gp_XY Right) -> Standard_Real

        Real D = <me>.X() * Other.Y() - <me>.Y() * Other.X()

        :type Right: OCC.wrapper.gp.gp_XY
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_XY_Crossed(self, *args)


    def __xor__(self, *args):
        """
        __xor__(gp_XY self, gp_XY Right) -> Standard_Real

        :type Right: OCC.wrapper.gp.gp_XY
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_XY___xor__(self, *args)


    def CrossMagnitude(self, *args):
        """
        CrossMagnitude(gp_XY self, gp_XY Right) -> Standard_Real

        computes the magnitude of the cross product between <me> and
        Right. Returns || <me> ^ Right ||

        :type Right: OCC.wrapper.gp.gp_XY
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_XY_CrossMagnitude(self, *args)


    def CrossSquareMagnitude(self, *args):
        """
        CrossSquareMagnitude(gp_XY self, gp_XY Right) -> Standard_Real

        computes the square magnitude of the cross product between <me> and
        Right. Returns || <me> ^ Right ||**2

        :type Right: OCC.wrapper.gp.gp_XY
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_XY_CrossSquareMagnitude(self, *args)


    def Divide(self, *args):
        """
        Divide(gp_XY self, Standard_Real const Scalar)

        divides <me> by a real.

        :type Scalar: float

        """
        return _gp.gp_XY_Divide(self, *args)


    def __itruediv__(self, *args):
        return _gp.gp_XY___itruediv__(self, *args)
    __idiv__ = __itruediv__



    def Divided(self, *args):
        """
        Divided(gp_XY self, Standard_Real const Scalar) -> gp_XY

        Divides <me> by a real.

        :type Scalar: float
        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_XY_Divided(self, *args)


    def __truediv__(self, *args):
        return _gp.gp_XY___truediv__(self, *args)
    __div__ = __truediv__



    def Dot(self, *args):
        """
        Dot(gp_XY self, gp_XY Other) -> Standard_Real

        Computes the scalar product between <me> and Other

        :type Other: OCC.wrapper.gp.gp_XY
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_XY_Dot(self, *args)


    def Multiply(self, *args):
        """
        Multiply(gp_XY self, Standard_Real const Scalar)
        Multiply(gp_XY self, gp_XY Other)
        Multiply(gp_XY self, gp_Mat2d Matrix)

        <me> = Matrix * <me>

        :type Matrix: OCC.wrapper.gp.gp_Mat2d

        """
        return _gp.gp_XY_Multiply(self, *args)


    def __imul__(self, *args):
        """
        __imul__(gp_XY self, Standard_Real const Scalar)
        __imul__(gp_XY self, gp_XY Other)
        __imul__(gp_XY self, gp_Mat2d Matrix)

        :type Matrix: OCC.wrapper.gp.gp_Mat2d

        """
        return _gp.gp_XY___imul__(self, *args)


    def Multiplied(self, *args):
        """
        Multiplied(gp_XY self, Standard_Real const Scalar) -> gp_XY
        Multiplied(gp_XY self, gp_XY Other) -> gp_XY
        Multiplied(gp_XY self, gp_Mat2d Matrix) -> gp_XY

        New = Matrix * <me>

        :type Matrix: OCC.wrapper.gp.gp_Mat2d
        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_XY_Multiplied(self, *args)


    def __mul__(self, *args):
        """
        __mul__(gp_XY self, gp_XY Other) -> Standard_Real
        __mul__(gp_XY self, Standard_Real const Scalar) -> gp_XY
        __mul__(gp_XY self, gp_Mat2d Matrix) -> gp_XY

        :type Matrix: OCC.wrapper.gp.gp_Mat2d
        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_XY___mul__(self, *args)


    def Normalize(self, *args):
        """
        Normalize(gp_XY self)

        <me>.X() = <me>.X()/ <me>.Modulus()
        <me>.Y() = <me>.Y()/ <me>.Modulus()
        Raises ConstructionError if <me>.Modulus() <= Resolution from gp


        """
        return _gp.gp_XY_Normalize(self, *args)


    def Normalized(self, *args):
        """
        Normalized(gp_XY self) -> gp_XY

        New.X() = <me>.X()/ <me>.Modulus()
        New.Y() = <me>.Y()/ <me>.Modulus()
        Raises ConstructionError if <me>.Modulus() <= Resolution from gp

        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_XY_Normalized(self, *args)


    def Reverse(self, *args):
        """
        Reverse(gp_XY self)

        <me>.X() = -<me>.X()
        <me>.Y() = -<me>.Y()


        """
        return _gp.gp_XY_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(gp_XY self) -> gp_XY

        New.X() = -<me>.X()
        New.Y() = -<me>.Y()

        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_XY_Reversed(self, *args)


    def __neg__(self, *args):
        """
        __neg__(gp_XY self) -> gp_XY

        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_XY___neg__(self, *args)


    def SetLinearForm(self, *args):
        """
        SetLinearForm(gp_XY self, Standard_Real const A1, gp_XY XY1, Standard_Real const A2, gp_XY XY2)
        SetLinearForm(gp_XY self, Standard_Real const A1, gp_XY XY1, Standard_Real const A2, gp_XY XY2, gp_XY XY3)
        SetLinearForm(gp_XY self, Standard_Real const A1, gp_XY XY1, gp_XY XY2)
        SetLinearForm(gp_XY self, gp_XY XY1, gp_XY XY2)

        Computes  the following linear combination and
        assigns the result to this number pair:
        XY1 + XY2

        :type XY1: OCC.wrapper.gp.gp_XY
        :type XY2: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_XY_SetLinearForm(self, *args)


    def Subtract(self, *args):
        """
        Subtract(gp_XY self, gp_XY Right)

        <me>.X() = <me>.X() - Other.X()
        <me>.Y() = <me>.Y() - Other.Y()

        :type Right: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_XY_Subtract(self, *args)


    def __isub__(self, *args):
        """
        __isub__(gp_XY self, gp_XY Right)

        :type Right: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_XY___isub__(self, *args)


    def Subtracted(self, *args):
        """
        Subtracted(gp_XY self, gp_XY Right) -> gp_XY

        new.X() = <me>.X() - Other.X()
        new.Y() = <me>.Y() - Other.Y()

        :type Right: OCC.wrapper.gp.gp_XY
        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_XY_Subtracted(self, *args)


    def __sub__(self, *args):
        """
        __sub__(gp_XY self, gp_XY Right) -> gp_XY

        :type Right: OCC.wrapper.gp.gp_XY
        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_XY___sub__(self, *args)

    __swig_destroy__ = _gp.delete_gp_XY
gp_XY_swigregister = _gp.gp_XY_swigregister
gp_XY_swigregister(gp_XY)

class gp_Dir(object):
    """
    Describes a unit vector in 3D space. This unit vector is also called "Direction".
    See Also
    gce_MakeDir which provides functions for more complex
    unit vector constructions
    Geom_Direction which provides additional functions for
    constructing unit vectors and works, in particular, with the
    parametric equations of unit vectors.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Dir self) -> gp_Dir
        __init__(gp_Dir self, gp_Vec V) -> gp_Dir
        __init__(gp_Dir self, gp_XYZ Coord) -> gp_Dir
        __init__(gp_Dir self, Standard_Real const Xv, Standard_Real const Yv, Standard_Real const Zv) -> gp_Dir

        Creates a direction with its 3 cartesian coordinates. Raises ConstructionError if Sqrt(Xv*Xv + Yv*Yv + Zv*Zv) <= Resolution
        Modification of the direction's coordinates
        If Sqrt (X*X + Y*Y + Z*Z) <= Resolution from gp where
        X, Y ,Z are the new coordinates it is not possible to
        construct the direction and the method raises the
        exception ConstructionError.

        :type Xv: float
        :type Yv: float
        :type Zv: float

        """
        this = _gp.new_gp_Dir(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetCoord(self, *args):
        """
        SetCoord(gp_Dir self, Standard_Integer const Index, Standard_Real const Xi)
        SetCoord(gp_Dir self, Standard_Real const Xv, Standard_Real const Yv, Standard_Real const Zv)

        For this unit vector,  assigns the values Xv, Yv and Zv to its three coordinates.
        Remember that all the coordinates of a unit vector are
        implicitly modified when any single one is changed directly.

        :type Xv: float
        :type Yv: float
        :type Zv: float

        """
        return _gp.gp_Dir_SetCoord(self, *args)


    def SetX(self, *args):
        """
        SetX(gp_Dir self, Standard_Real const X)

        Assigns the given value to the X coordinate of this   unit vector.

        :type X: float

        """
        return _gp.gp_Dir_SetX(self, *args)


    def SetY(self, *args):
        """
        SetY(gp_Dir self, Standard_Real const Y)

        Assigns the given value to the Y coordinate of this   unit vector.

        :type Y: float

        """
        return _gp.gp_Dir_SetY(self, *args)


    def SetZ(self, *args):
        """
        SetZ(gp_Dir self, Standard_Real const Z)

        Assigns the given value to the Z  coordinate of this   unit vector.

        :type Z: float

        """
        return _gp.gp_Dir_SetZ(self, *args)


    def SetXYZ(self, *args):
        """
        SetXYZ(gp_Dir self, gp_XYZ Coord)

        Assigns the three coordinates of Coord to this unit vector.

        :type Coord: OCC.wrapper.gp.gp_XYZ

        """
        return _gp.gp_Dir_SetXYZ(self, *args)


    def Coord(self, *args):
        """
        Coord(gp_Dir self, Standard_Integer const Index) -> Standard_Real
        Coord(gp_Dir self)

        Returns for the  unit vector  its three coordinates Xv, Yv, and Zv.

        :type Xv: float
        :type Yv: float
        :type Zv: float

        """
        return _gp.gp_Dir_Coord(self, *args)


    def X(self, *args):
        """
        X(gp_Dir self) -> Standard_Real

        Returns the X coordinate for a  unit vector.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Dir_X(self, *args)


    def Y(self, *args):
        """
        Y(gp_Dir self) -> Standard_Real

        Returns the Y coordinate for a  unit vector.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Dir_Y(self, *args)


    def Z(self, *args):
        """
        Z(gp_Dir self) -> Standard_Real

        Returns the Z coordinate for a  unit vector.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Dir_Z(self, *args)


    def XYZ(self, *args):
        """
        for this unit vector, returns  its three coordinates as a number triplea.

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        res = _gp.gp_Dir_XYZ(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsEqual(self, *args):
        """
        IsEqual(gp_Dir self, gp_Dir Other, Standard_Real const AngularTolerance) -> Standard_Boolean

        Returns True if the angle between the two directions is
        lower or equal to AngularTolerance.

        :type Other: OCC.wrapper.gp.gp_Dir
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Dir_IsEqual(self, *args)


    def IsNormal(self, *args):
        """
        IsNormal(gp_Dir self, gp_Dir Other, Standard_Real const AngularTolerance) -> Standard_Boolean

        Returns True if  the angle between this unit vector and the unit vector Other is equal to Pi/2 (normal).

        :type Other: OCC.wrapper.gp.gp_Dir
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Dir_IsNormal(self, *args)


    def IsOpposite(self, *args):
        """
        IsOpposite(gp_Dir self, gp_Dir Other, Standard_Real const AngularTolerance) -> Standard_Boolean

        Returns True if  the angle between this unit vector and the unit vector Other is equal to  Pi (opposite).

        :type Other: OCC.wrapper.gp.gp_Dir
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Dir_IsOpposite(self, *args)


    def IsParallel(self, *args):
        """
        IsParallel(gp_Dir self, gp_Dir Other, Standard_Real const AngularTolerance) -> Standard_Boolean

        Returns true if the angle between this unit vector and the
        unit vector Other is equal to 0 or to Pi.
        Note: the tolerance criterion is given by AngularTolerance.

        :type Other: OCC.wrapper.gp.gp_Dir
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Dir_IsParallel(self, *args)


    def Angle(self, *args):
        """
        Angle(gp_Dir self, gp_Dir Other) -> Standard_Real

        Computes the angular value in radians between <me> and
        <Other>. This value is always positive in 3D space.
        Returns the angle in the range [0, PI]

        :type Other: OCC.wrapper.gp.gp_Dir
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Dir_Angle(self, *args)


    def AngleWithRef(self, *args):
        """
        AngleWithRef(gp_Dir self, gp_Dir Other, gp_Dir VRef) -> Standard_Real

        Computes the angular value between <me> and <Other>.
        <VRef> is the direction of reference normal to <me> and <Other>
        and its orientation gives the positive sense of rotation.
        If the cross product <me> ^ <Other> has the same orientation
        as <VRef> the angular value is positive else negative.
        Returns the angular value in the range -PI and PI (in radians). Raises  DomainError if <me> and <Other> are not parallel this exception is raised
        when <VRef> is in the same plane as <me> and <Other>
        The tolerance criterion is Resolution from package gp.

        :type Other: OCC.wrapper.gp.gp_Dir
        :type VRef: OCC.wrapper.gp.gp_Dir
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Dir_AngleWithRef(self, *args)


    def Cross(self, *args):
        """
        Cross(gp_Dir self, gp_Dir Right)

        Computes the cross product between two directions
        Raises the exception ConstructionError if the two directions
        are parallel because the computed vector cannot be normalized
        to create a direction.

        :type Right: OCC.wrapper.gp.gp_Dir

        """
        return _gp.gp_Dir_Cross(self, *args)


    def __ixor__(self, *args):
        """
        __ixor__(gp_Dir self, gp_Dir Right)

        :type Right: OCC.wrapper.gp.gp_Dir

        """
        return _gp.gp_Dir___ixor__(self, *args)


    def Crossed(self, *args):
        """
        Crossed(gp_Dir self, gp_Dir Right) -> gp_Dir

        Computes the triple vector product.
        <me> ^ (V1 ^ V2)
        Raises the exception ConstructionError if V1 and V2 are parallel
        or <me> and (V1^V2) are parallel because the computed vector
        can't be normalized to create a direction.

        :type Right: OCC.wrapper.gp.gp_Dir
        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _gp.gp_Dir_Crossed(self, *args)


    def __xor__(self, *args):
        """
        __xor__(gp_Dir self, gp_Dir Right) -> gp_Dir

        :type Right: OCC.wrapper.gp.gp_Dir
        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _gp.gp_Dir___xor__(self, *args)


    def CrossCross(self, *args):
        """
        CrossCross(gp_Dir self, gp_Dir V1, gp_Dir V2)

        :type V1: OCC.wrapper.gp.gp_Dir
        :type V2: OCC.wrapper.gp.gp_Dir

        """
        return _gp.gp_Dir_CrossCross(self, *args)


    def CrossCrossed(self, *args):
        """
        CrossCrossed(gp_Dir self, gp_Dir V1, gp_Dir V2) -> gp_Dir

        Computes the double vector product this ^ (V1 ^ V2).
        -   CrossCrossed creates a new unit vector.
        Exceptions
        Standard_ConstructionError if:
        -   V1 and V2 are parallel, or
        -   this unit vector and (V1 ^ V2) are parallel.
        This is because, in these conditions, the computed vector
        is null and cannot be normalized.

        :type V1: OCC.wrapper.gp.gp_Dir
        :type V2: OCC.wrapper.gp.gp_Dir
        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _gp.gp_Dir_CrossCrossed(self, *args)


    def Dot(self, *args):
        """
        Dot(gp_Dir self, gp_Dir Other) -> Standard_Real

        Computes the scalar product

        :type Other: OCC.wrapper.gp.gp_Dir
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Dir_Dot(self, *args)


    def __mul__(self, *args):
        """
        __mul__(gp_Dir self, gp_Dir Other) -> Standard_Real

        :type Other: OCC.wrapper.gp.gp_Dir
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Dir___mul__(self, *args)


    def DotCross(self, *args):
        """
        DotCross(gp_Dir self, gp_Dir V1, gp_Dir V2) -> Standard_Real

        Computes the triple scalar product <me> * (V1 ^ V2).
        Warnings :
        The computed vector V1' = V1 ^ V2 is not normalized
        to create a unitary vector. So this method never
        raises an exception even if V1 and V2 are parallel.

        :type V1: OCC.wrapper.gp.gp_Dir
        :type V2: OCC.wrapper.gp.gp_Dir
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Dir_DotCross(self, *args)


    def Reverse(self, *args):
        """Reverse(gp_Dir self)"""
        return _gp.gp_Dir_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(gp_Dir self) -> gp_Dir

        Reverses the orientation of a direction
        geometric transformations
        Performs the symmetrical transformation of a direction
        with respect to the direction V which is the center of
        the  symmetry.]

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _gp.gp_Dir_Reversed(self, *args)


    def __neg__(self, *args):
        """
        __neg__(gp_Dir self) -> gp_Dir

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _gp.gp_Dir___neg__(self, *args)


    def Mirror(self, *args):
        """
        Mirror(gp_Dir self, gp_Dir V)
        Mirror(gp_Dir self, gp_Ax1 A1)
        Mirror(gp_Dir self, gp_Ax2 A2)

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Dir_Mirror(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(gp_Dir self, gp_Dir V) -> gp_Dir
        Mirrored(gp_Dir self, gp_Ax1 A1) -> gp_Dir
        Mirrored(gp_Dir self, gp_Ax2 A2) -> gp_Dir

        Performs the symmetrical transformation of a direction
        with respect to a plane. The axis placement A2 locates
        the plane of the symmetry : (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _gp.gp_Dir_Mirrored(self, *args)


    def Rotate(self, *args):
        """
        Rotate(gp_Dir self, gp_Ax1 A1, Standard_Real const Ang)

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _gp.gp_Dir_Rotate(self, *args)


    def Rotated(self, *args):
        """
        Rotated(gp_Dir self, gp_Ax1 A1, Standard_Real const Ang) -> gp_Dir

        Rotates a direction. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _gp.gp_Dir_Rotated(self, *args)


    def Transform(self, *args):
        """
        Transform(gp_Dir self, gp_Trsf T)

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _gp.gp_Dir_Transform(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_Dir self, gp_Trsf T) -> gp_Dir

        Transforms a direction with a "Trsf" from gp.
        Warnings :
        If the scale factor of the "Trsf" T is negative then the
        direction <me> is reversed.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _gp.gp_Dir_Transformed(self, *args)

    __swig_destroy__ = _gp.delete_gp_Dir
gp_Dir_swigregister = _gp.gp_Dir_swigregister
gp_Dir_swigregister(gp_Dir)

class gp_Lin(object):
    """
    Describes a line in 3D space.
    A line is positioned in space with an axis (a gp_Ax1
    object) which gives it an origin and a unit vector.
    A line and an axis are similar objects, thus, we can
    convert one into the other. A line provides direct access
    to the majority of the edit and query functions available
    on its positioning axis. In addition, however, a line has
    specific functions for computing distances and positions.
    See Also
    gce_MakeLin which provides functions for more complex
    line constructions
    Geom_Line which provides additional functions for
    constructing lines and works, in particular, with the
    parametric equations of lines
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Lin self) -> gp_Lin
        __init__(gp_Lin self, gp_Ax1 A1) -> gp_Lin
        __init__(gp_Lin self, gp_Pnt P, gp_Dir V) -> gp_Lin

        Creates a line passing through point P and parallel to
        vector V (P and V are, respectively, the origin and
        the unit vector of the positioning axis of the line).

        :type P: OCC.wrapper.gp.gp_Pnt
        :type V: OCC.wrapper.gp.gp_Dir

        """
        this = _gp.new_gp_Lin(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Reverse(self, *args):
        """Reverse(gp_Lin self)"""
        return _gp.gp_Lin_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(gp_Lin self) -> gp_Lin

        Reverses the direction of the line.
        Note:
        -   Reverse assigns the result to this line, while
        -   Reversed creates a new one.

        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _gp.gp_Lin_Reversed(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(gp_Lin self, gp_Dir V)

        Changes the direction of the line.

        :type V: OCC.wrapper.gp.gp_Dir

        """
        return _gp.gp_Lin_SetDirection(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(gp_Lin self, gp_Pnt P)

        Changes the location point (origin) of the line.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Lin_SetLocation(self, *args)


    def SetPosition(self, *args):
        """
        SetPosition(gp_Lin self, gp_Ax1 A1)

        Complete redefinition of the line.
        The "Location" point of <A1> is the origin of the line.
        The "Direction" of <A1> is  the direction of the line.

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Lin_SetPosition(self, *args)


    def Direction(self, *args):
        """
        Returns the direction of the line.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _gp.gp_Lin_Direction(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Location(self, *args):
        """
        Returns the location point (origin) of the line.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _gp.gp_Lin_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Position(self, *args):
        """
        Returns the axis placement one axis whith the same
        location and direction as <me>.

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        res = _gp.gp_Lin_Position(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Angle(self, *args):
        """
        Angle(gp_Lin self, gp_Lin Other) -> Standard_Real

        Computes the angle between two lines in radians.

        :type Other: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Lin_Angle(self, *args)


    def Contains(self, *args):
        """
        Contains(gp_Lin self, gp_Pnt P, Standard_Real const LinearTolerance) -> Standard_Boolean

        Returns true if this line contains the point P, that is, if the
        distance between point P and this line is less than or
        equal to LinearTolerance..

        :type P: OCC.wrapper.gp.gp_Pnt
        :type LinearTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Lin_Contains(self, *args)


    def Distance(self, *args):
        """
        Distance(gp_Lin self, gp_Pnt P) -> Standard_Real
        Distance(gp_Lin self, gp_Lin Other) -> Standard_Real

        Computes the distance between two lines.

        :type Other: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Lin_Distance(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(gp_Lin self, gp_Pnt P) -> Standard_Real
        SquareDistance(gp_Lin self, gp_Lin Other) -> Standard_Real

        Computes the square distance between two lines.

        :type Other: OCC.wrapper.gp.gp_Lin
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Lin_SquareDistance(self, *args)


    def Normal(self, *args):
        """
        Normal(gp_Lin self, gp_Pnt P) -> gp_Lin

        Computes the line normal to the direction of <me>, passing
        through the point P.  Raises ConstructionError
        if the distance between <me> and the point P is lower
        or equal to Resolution from gp because there is an infinity of
        solutions in 3D space.

        :type P: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _gp.gp_Lin_Normal(self, *args)


    def Mirror(self, *args):
        """
        Mirror(gp_Lin self, gp_Pnt P)
        Mirror(gp_Lin self, gp_Ax1 A1)
        Mirror(gp_Lin self, gp_Ax2 A2)

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Lin_Mirror(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(gp_Lin self, gp_Pnt P) -> gp_Lin
        Mirrored(gp_Lin self, gp_Ax1 A1) -> gp_Lin
        Mirrored(gp_Lin self, gp_Ax2 A2) -> gp_Lin

        Performs the symmetrical transformation of a line
        with respect to a plane. The axis placement  <A2>
        locates the plane of the symmetry :
        (Location, XDirection, YDirection).

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _gp.gp_Lin_Mirrored(self, *args)


    def Rotate(self, *args):
        """
        Rotate(gp_Lin self, gp_Ax1 A1, Standard_Real const Ang)

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _gp.gp_Lin_Rotate(self, *args)


    def Rotated(self, *args):
        """
        Rotated(gp_Lin self, gp_Ax1 A1, Standard_Real const Ang) -> gp_Lin

        Rotates a line. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _gp.gp_Lin_Rotated(self, *args)


    def Scale(self, *args):
        """
        Scale(gp_Lin self, gp_Pnt P, Standard_Real const S)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _gp.gp_Lin_Scale(self, *args)


    def Scaled(self, *args):
        """
        Scaled(gp_Lin self, gp_Pnt P, Standard_Real const S) -> gp_Lin

        Scales a line. S is the scaling value.
        The "Location" point (origin) of the line is modified.
        The "Direction" is reversed if the scale is negative.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _gp.gp_Lin_Scaled(self, *args)


    def Transform(self, *args):
        """
        Transform(gp_Lin self, gp_Trsf T)

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _gp.gp_Lin_Transform(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_Lin self, gp_Trsf T) -> gp_Lin

        Transforms a line with the transformation T from class Trsf.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _gp.gp_Lin_Transformed(self, *args)


    def Translate(self, *args):
        """
        Translate(gp_Lin self, gp_Vec V)
        Translate(gp_Lin self, gp_Pnt P1, gp_Pnt P2)

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Lin_Translate(self, *args)


    def Translated(self, *args):
        """
        Translated(gp_Lin self, gp_Vec V) -> gp_Lin
        Translated(gp_Lin self, gp_Pnt P1, gp_Pnt P2) -> gp_Lin

        Translates a line from the point P1 to the point P2.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _gp.gp_Lin_Translated(self, *args)

    __swig_destroy__ = _gp.delete_gp_Lin
gp_Lin_swigregister = _gp.gp_Lin_swigregister
gp_Lin_swigregister(gp_Lin)

class gp_Pnt2d(object):
    """Defines  a non-persistent 2D cartesian point."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Pnt2d self) -> gp_Pnt2d
        __init__(gp_Pnt2d self, gp_XY Coord) -> gp_Pnt2d
        __init__(gp_Pnt2d self, Standard_Real const Xp, Standard_Real const Yp) -> gp_Pnt2d

        Creates a  point with its 2 cartesian's coordinates : Xp, Yp.

        :type Xp: float
        :type Yp: float

        """
        this = _gp.new_gp_Pnt2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetCoord(self, *args):
        """
        SetCoord(gp_Pnt2d self, Standard_Integer const Index, Standard_Real const Xi)
        SetCoord(gp_Pnt2d self, Standard_Real const Xp, Standard_Real const Yp)

        For this point, assigns the values Xp and Yp to its two coordinates

        :type Xp: float
        :type Yp: float

        """
        return _gp.gp_Pnt2d_SetCoord(self, *args)


    def SetX(self, *args):
        """
        SetX(gp_Pnt2d self, Standard_Real const X)

        Assigns the given value to the X  coordinate of this point.

        :type X: float

        """
        return _gp.gp_Pnt2d_SetX(self, *args)


    def SetY(self, *args):
        """
        SetY(gp_Pnt2d self, Standard_Real const Y)

        Assigns the given value to the Y  coordinate of this point.

        :type Y: float

        """
        return _gp.gp_Pnt2d_SetY(self, *args)


    def SetXY(self, *args):
        """
        SetXY(gp_Pnt2d self, gp_XY Coord)

        Assigns the two coordinates of Coord to this point.

        :type Coord: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_Pnt2d_SetXY(self, *args)


    def X(self, *args):
        """
        X(gp_Pnt2d self) -> Standard_Real

        For this point, returns its X  coordinate.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Pnt2d_X(self, *args)


    def Y(self, *args):
        """
        Y(gp_Pnt2d self) -> Standard_Real

        For this point, returns its Y coordinate.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Pnt2d_Y(self, *args)


    def XY(self, *args):
        """
        For this point, returns its two coordinates as a number pair.

        :rtype: OCC.wrapper.gp.gp_XY

        """
        res = _gp.gp_Pnt2d_XY(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Coord(self, *args):
        """
        For this point, returns its two coordinates as a number pair.

        :rtype: OCC.wrapper.gp.gp_XY

        """
        res = _gp.gp_Pnt2d_Coord(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeCoord(self, *args):
        """
        ChangeCoord(gp_Pnt2d self) -> gp_XY

        Returns the coordinates of this point.
        Note: This syntax allows direct modification of the returned value.

        :rtype: OCC.wrapper.gp.gp_XY

        """
        return _gp.gp_Pnt2d_ChangeCoord(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(gp_Pnt2d self, gp_Pnt2d Other, Standard_Real const LinearTolerance) -> Standard_Boolean

        Comparison
        Returns True if the distance between the two
        points is lower or equal to LinearTolerance.

        :type Other: OCC.wrapper.gp.gp_Pnt2d
        :type LinearTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Pnt2d_IsEqual(self, *args)


    def Distance(self, *args):
        """
        Distance(gp_Pnt2d self, gp_Pnt2d Other) -> Standard_Real

        Computes the distance between two points.

        :type Other: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Pnt2d_Distance(self, *args)


    def SquareDistance(self, *args):
        """
        SquareDistance(gp_Pnt2d self, gp_Pnt2d Other) -> Standard_Real

        Computes the square distance between two points.

        :type Other: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Pnt2d_SquareDistance(self, *args)


    def Mirror(self, *args):
        """
        Mirror(gp_Pnt2d self, gp_Pnt2d P)
        Mirror(gp_Pnt2d self, gp_Ax2d A)

        :type A: OCC.wrapper.gp.gp_Ax2d

        """
        return _gp.gp_Pnt2d_Mirror(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(gp_Pnt2d self, gp_Pnt2d P) -> gp_Pnt2d
        Mirrored(gp_Pnt2d self, gp_Ax2d A) -> gp_Pnt2d

        Rotates a point. A1 is the axis of the rotation.
        Ang is the angular value of the rotation in radians.

        :type A: OCC.wrapper.gp.gp_Ax2d
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Pnt2d_Mirrored(self, *args)


    def Rotate(self, *args):
        """
        Rotate(gp_Pnt2d self, gp_Pnt2d P, Standard_Real const Ang)

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float

        """
        return _gp.gp_Pnt2d_Rotate(self, *args)


    def Rotated(self, *args):
        """
        Rotated(gp_Pnt2d self, gp_Pnt2d P, Standard_Real const Ang) -> gp_Pnt2d

        Scales a point. S is the scaling value.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type Ang: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Pnt2d_Rotated(self, *args)


    def Scale(self, *args):
        """
        Scale(gp_Pnt2d self, gp_Pnt2d P, Standard_Real const S)

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float

        """
        return _gp.gp_Pnt2d_Scale(self, *args)


    def Scaled(self, *args):
        """
        Scaled(gp_Pnt2d self, gp_Pnt2d P, Standard_Real const S) -> gp_Pnt2d

        Transforms a point with the transformation T.

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type S: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Pnt2d_Scaled(self, *args)


    def Transform(self, *args):
        """
        Transform(gp_Pnt2d self, gp_Trsf2d T)

        :type T: OCC.wrapper.gp.gp_Trsf2d

        """
        return _gp.gp_Pnt2d_Transform(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_Pnt2d self, gp_Trsf2d T) -> gp_Pnt2d

        Translates a point in the direction of the vector V.
        The magnitude of the translation is the vector's magnitude.

        :type T: OCC.wrapper.gp.gp_Trsf2d
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Pnt2d_Transformed(self, *args)


    def Translate(self, *args):
        """
        Translate(gp_Pnt2d self, gp_Vec2d V)
        Translate(gp_Pnt2d self, gp_Pnt2d P1, gp_Pnt2d P2)

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Pnt2d_Translate(self, *args)


    def Translated(self, *args):
        """
        Translated(gp_Pnt2d self, gp_Vec2d V) -> gp_Pnt2d
        Translated(gp_Pnt2d self, gp_Pnt2d P1, gp_Pnt2d P2) -> gp_Pnt2d

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _gp.gp_Pnt2d_Translated(self, *args)

    __swig_destroy__ = _gp.delete_gp_Pnt2d
gp_Pnt2d_swigregister = _gp.gp_Pnt2d_swigregister
gp_Pnt2d_swigregister(gp_Pnt2d)

class gp_QuaternionNLerp(object):
    """
    Class perform linear interpolation (approximate rotation interpolation),
    result quaternion nonunit, its length lay between. sqrt(2)/2  and 1.0
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_QuaternionNLerp self) -> gp_QuaternionNLerp
        __init__(gp_QuaternionNLerp self, gp_Quaternion theQStart, gp_Quaternion theQEnd) -> gp_QuaternionNLerp

        Constructor with initialization.

        :type theQStart: OCC.wrapper.gp.gp_Quaternion
        :type theQEnd: OCC.wrapper.gp.gp_Quaternion

        """
        this = _gp.new_gp_QuaternionNLerp(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(gp_QuaternionNLerp self, gp_Quaternion theQStart, gp_Quaternion theQEnd)

        Initialize the tool with Start and End values.

        :type theQStart: OCC.wrapper.gp.gp_Quaternion
        :type theQEnd: OCC.wrapper.gp.gp_Quaternion

        """
        return _gp.gp_QuaternionNLerp_Init(self, *args)


    def InitFromUnit(self, *args):
        """
        InitFromUnit(gp_QuaternionNLerp self, gp_Quaternion theQStart, gp_Quaternion theQEnd)

        Initialize the tool with Start and End unit quaternions.

        :type theQStart: OCC.wrapper.gp.gp_Quaternion
        :type theQEnd: OCC.wrapper.gp.gp_Quaternion

        """
        return _gp.gp_QuaternionNLerp_InitFromUnit(self, *args)


    def Interpolate(self, *args):
        """
        Interpolate(gp_QuaternionNLerp self, gp_Quaternion theQStart, gp_Quaternion theQEnd, Standard_Real theT) -> gp_Quaternion
        Interpolate(gp_QuaternionNLerp self, Standard_Real theT, gp_Quaternion theResultQ)

        Set interpolated quaternion for theT position (from 0.0 to 1.0)

        :type theT: float
        :type theResultQ: OCC.wrapper.gp.gp_Quaternion

        """
        return _gp.gp_QuaternionNLerp_Interpolate(self, *args)

    __swig_destroy__ = _gp.delete_gp_QuaternionNLerp
gp_QuaternionNLerp_swigregister = _gp.gp_QuaternionNLerp_swigregister
gp_QuaternionNLerp_swigregister(gp_QuaternionNLerp)

class gp_Ax3(object):
    """
    Describes a coordinate system in 3D space. Unlike a
    gp_Ax2 coordinate system, a gp_Ax3 can be
    right-handed ("direct sense") or left-handed ("indirect sense").
    A coordinate system is defined by:
    -   its origin (also referred to as its "Location point"), and
    -   three orthogonal unit vectors, termed the "X
    Direction", the "Y Direction" and the "Direction" (also
    referred to as the "main Direction").
    The "Direction" of the coordinate system is called its
    "main Direction" because whenever this unit vector is
    modified, the "X Direction" and the "Y Direction" are
    recomputed. However, when we modify either the "X
    Direction" or the "Y Direction", "Direction" is not modified.
    "Direction" is also the "Z Direction".
    The "main Direction" is always parallel to the cross
    product of its "X Direction" and "Y Direction".
    If the coordinate system is right-handed, it satisfies the equation:
    "main Direction" = "X Direction" ^ "Y Direction"
    and if it is left-handed, it satisfies the equation:
    "main Direction" = -"X Direction" ^ "Y Direction"
    A coordinate system is used:
    -   to describe geometric entities, in particular to position
    them. The local coordinate system of a geometric
    entity serves the same purpose as the STEP function
    "axis placement three axes", or
    -   to define geometric transformations.
    Note:
    -   We refer to the "X Axis", "Y Axis" and "Z Axis",
    respectively, as the axes having:
    -   the origin of the coordinate system as their origin, and
    -   the unit vectors "X Direction", "Y Direction" and
    "main Direction", respectively, as their unit vectors.
    -   The "Z Axis" is also the "main Axis".
    -   gp_Ax2 is used to define a coordinate system that must be always right-handed.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gp_Ax3 self) -> gp_Ax3
        __init__(gp_Ax3 self, gp_Ax2 A) -> gp_Ax3
        __init__(gp_Ax3 self, gp_Pnt P, gp_Dir N, gp_Dir Vx) -> gp_Ax3
        __init__(gp_Ax3 self, gp_Pnt P, gp_Dir V) -> gp_Ax3

        Creates an axis placement with the  "Location" point <P>
        and the normal direction <V>.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type V: OCC.wrapper.gp.gp_Dir

        """
        this = _gp.new_gp_Ax3(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def XReverse(self, *args):
        """
        XReverse(gp_Ax3 self)

        Reverses the X direction of <me>.


        """
        return _gp.gp_Ax3_XReverse(self, *args)


    def YReverse(self, *args):
        """
        YReverse(gp_Ax3 self)

        Reverses the Y direction of <me>.


        """
        return _gp.gp_Ax3_YReverse(self, *args)


    def ZReverse(self, *args):
        """
        ZReverse(gp_Ax3 self)

        Reverses the Z direction of <me>.


        """
        return _gp.gp_Ax3_ZReverse(self, *args)


    def SetAxis(self, *args):
        """
        SetAxis(gp_Ax3 self, gp_Ax1 A1)

        Assigns the origin and "main Direction" of the axis A1 to
        this coordinate system, then recomputes its "X Direction" and "Y Direction".
        Note:
        -   The new "X Direction" is computed as follows:
        new "X Direction" = V1 ^(previous "X Direction" ^ V)
        where V is the "Direction" of A1.
        -   The orientation of this coordinate system
        (right-handed or left-handed) is not modified.
        Raises ConstructionError  if the "Direction" of <A1> and the "XDirection" of <me>
        are parallel (same or opposite orientation) because it is
        impossible to calculate the new "XDirection" and the new
        "YDirection".

        :type A1: OCC.wrapper.gp.gp_Ax1

        """
        return _gp.gp_Ax3_SetAxis(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(gp_Ax3 self, gp_Dir V)

        Changes the main direction of this coordinate system,
        then recomputes its "X Direction" and "Y Direction".
        Note:
        -   The new "X Direction" is computed as follows:
        new "X Direction" = V ^ (previous "X Direction" ^ V).
        -   The orientation of this coordinate system (left- or right-handed) is not modified.
        Raises ConstructionError if <V< and the previous "XDirection" are parallel
        because it is impossible to calculate the new "XDirection"
        and the new "YDirection".

        :type V: OCC.wrapper.gp.gp_Dir

        """
        return _gp.gp_Ax3_SetDirection(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(gp_Ax3 self, gp_Pnt P)

        Changes the "Location" point (origin) of <me>.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Ax3_SetLocation(self, *args)


    def SetXDirection(self, *args):
        """
        SetXDirection(gp_Ax3 self, gp_Dir Vx)

        Changes the "Xdirection" of <me>. The main direction
        "Direction" is not modified, the "Ydirection" is modified.
        If <Vx> is not normal to the main direction then <XDirection>
        is computed as follows XDirection = Direction ^ (Vx ^ Direction).
        Raises ConstructionError if <Vx> is parallel (same or opposite
        orientation) to the main direction of <me>

        :type Vx: OCC.wrapper.gp.gp_Dir

        """
        return _gp.gp_Ax3_SetXDirection(self, *args)


    def SetYDirection(self, *args):
        """
        SetYDirection(gp_Ax3 self, gp_Dir Vy)

        Changes the "Ydirection" of <me>. The main direction is not
        modified but the "Xdirection" is changed.
        If <Vy> is not normal to the main direction then "YDirection"
        is computed as  follows
        YDirection = Direction ^ (<Vy> ^ Direction).
        Raises ConstructionError if <Vy> is parallel to the main direction of <me>

        :type Vy: OCC.wrapper.gp.gp_Dir

        """
        return _gp.gp_Ax3_SetYDirection(self, *args)


    def Angle(self, *args):
        """
        Angle(gp_Ax3 self, gp_Ax3 Other) -> Standard_Real

        Computes the angular value between the main direction of
        <me> and the main direction of <Other>. Returns the angle
        between 0 and PI in radians.

        :type Other: OCC.wrapper.gp.gp_Ax3
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _gp.gp_Ax3_Angle(self, *args)


    def Axis(self, *args):
        """
        Returns the main axis of <me>. It is the "Location" point
        and the main "Direction".

        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        res = _gp.gp_Ax3_Axis(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Ax2(self, *args):
        """
        Ax2(gp_Ax3 self) -> gp_Ax2

        Computes a right-handed coordinate system with the
        same "X Direction" and "Y Direction" as those of this
        coordinate system, then recomputes the "main Direction".
        If this coordinate system is right-handed, the result
        returned is the same coordinate system. If this
        coordinate system is left-handed, the result is reversed.

        :rtype: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Ax3_Ax2(self, *args)


    def Direction(self, *args):
        """
        Returns the main direction of <me>.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _gp.gp_Ax3_Direction(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Location(self, *args):
        """
        Returns the "Location" point (origin) of <me>.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _gp.gp_Ax3_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def XDirection(self, *args):
        """
        Returns the "XDirection" of <me>.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _gp.gp_Ax3_XDirection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def YDirection(self, *args):
        """
        Returns the "YDirection" of <me>.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _gp.gp_Ax3_YDirection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Direct(self, *args):
        """
        Direct(gp_Ax3 self) -> Standard_Boolean

        Returns  True if  the  coordinate  system is right-handed. i.e.
        XDirection().Crossed(YDirection()).Dot(Direction()) > 0

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Ax3_Direct(self, *args)


    def IsCoplanar(self, *args):
        """
        IsCoplanar(gp_Ax3 self, gp_Ax3 Other, Standard_Real const LinearTolerance, Standard_Real const AngularTolerance) -> Standard_Boolean
        IsCoplanar(gp_Ax3 self, gp_Ax1 A1, Standard_Real const LinearTolerance, Standard_Real const AngularTolerance) -> Standard_Boolean

        Returns True if
        . the distance between <me> and the "Location" point of A1
        is lower of equal to LinearTolerance and
        . the distance between A1 and the "Location" point of <me>
        is lower or equal to LinearTolerance and
        . the main direction of <me> and the direction of A1 are normal.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type LinearTolerance: float
        :type AngularTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.gp_Ax3_IsCoplanar(self, *args)


    def Mirror(self, *args):
        """
        Mirror(gp_Ax3 self, gp_Pnt P)
        Mirror(gp_Ax3 self, gp_Ax1 A1)
        Mirror(gp_Ax3 self, gp_Ax2 A2)

        :type A2: OCC.wrapper.gp.gp_Ax2

        """
        return _gp.gp_Ax3_Mirror(self, *args)


    def Mirrored(self, *args):
        """
        Mirrored(gp_Ax3 self, gp_Pnt P) -> gp_Ax3
        Mirrored(gp_Ax3 self, gp_Ax1 A1) -> gp_Ax3
        Mirrored(gp_Ax3 self, gp_Ax2 A2) -> gp_Ax3

        Performs the symmetrical transformation of an axis
        placement with respect to a plane.
        The axis placement  <A2> locates the plane of the symmetry :
        (Location, XDirection, YDirection).
        The transformation is performed on the "Location"
        point, on the "XDirection" and "YDirection".
        The resulting main "Direction" is the cross product between
        the "XDirection" and the "YDirection" after transformation.

        :type A2: OCC.wrapper.gp.gp_Ax2
        :rtype: OCC.wrapper.gp.gp_Ax3

        """
        return _gp.gp_Ax3_Mirrored(self, *args)


    def Rotate(self, *args):
        """
        Rotate(gp_Ax3 self, gp_Ax1 A1, Standard_Real const Ang)

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float

        """
        return _gp.gp_Ax3_Rotate(self, *args)


    def Rotated(self, *args):
        """
        Rotated(gp_Ax3 self, gp_Ax1 A1, Standard_Real const Ang) -> gp_Ax3

        Rotates an axis placement. <A1> is the axis of the
        rotation . Ang is the angular value of the rotation
        in radians.

        :type A1: OCC.wrapper.gp.gp_Ax1
        :type Ang: float
        :rtype: OCC.wrapper.gp.gp_Ax3

        """
        return _gp.gp_Ax3_Rotated(self, *args)


    def Scale(self, *args):
        """
        Scale(gp_Ax3 self, gp_Pnt P, Standard_Real const S)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float

        """
        return _gp.gp_Ax3_Scale(self, *args)


    def Scaled(self, *args):
        """
        Scaled(gp_Ax3 self, gp_Pnt P, Standard_Real const S) -> gp_Ax3

        Applies a scaling transformation on the axis placement.
        The "Location" point of the axisplacement is modified.
        Warnings :
        If the scale <S> is negative :
        . the main direction of the axis placement is not changed.
        . The "XDirection" and the "YDirection" are reversed.
        So the axis placement stay right handed.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type S: float
        :rtype: OCC.wrapper.gp.gp_Ax3

        """
        return _gp.gp_Ax3_Scaled(self, *args)


    def Transform(self, *args):
        """
        Transform(gp_Ax3 self, gp_Trsf T)

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        return _gp.gp_Ax3_Transform(self, *args)


    def Transformed(self, *args):
        """
        Transformed(gp_Ax3 self, gp_Trsf T) -> gp_Ax3

        Transforms an axis placement with a Trsf.
        The "Location" point, the "XDirection" and the
        "YDirection" are transformed with T.  The resulting
        main "Direction" of <me> is the cross product between
        the "XDirection" and the "YDirection" after transformation.

        :type T: OCC.wrapper.gp.gp_Trsf
        :rtype: OCC.wrapper.gp.gp_Ax3

        """
        return _gp.gp_Ax3_Transformed(self, *args)


    def Translate(self, *args):
        """
        Translate(gp_Ax3 self, gp_Vec V)
        Translate(gp_Ax3 self, gp_Pnt P1, gp_Pnt P2)

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _gp.gp_Ax3_Translate(self, *args)


    def Translated(self, *args):
        """
        Translated(gp_Ax3 self, gp_Vec V) -> gp_Ax3
        Translated(gp_Ax3 self, gp_Pnt P1, gp_Pnt P2) -> gp_Ax3

        Translates an axis placement from the point <P1> to the
        point <P2>.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.gp.gp_Ax3

        """
        return _gp.gp_Ax3_Translated(self, *args)

    __swig_destroy__ = _gp.delete_gp_Ax3
gp_Ax3_swigregister = _gp.gp_Ax3_swigregister
gp_Ax3_swigregister(gp_Ax3)

class gp_VectorWithNullMagnitude(Standard.Standard_DomainError):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_gp_VectorWithNullMagnitude
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_gp_VectorWithNullMagnitude(self) 
            return h


    def __init__(self, *args):
        """
        __init__(gp_VectorWithNullMagnitude self) -> gp_VectorWithNullMagnitude
        __init__(gp_VectorWithNullMagnitude self, Standard_CString const theMessage) -> gp_VectorWithNullMagnitude

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _gp.new_gp_VectorWithNullMagnitude(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_gp_VectorWithNullMagnitude

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.gp.Handle_gp_VectorWithNullMagnitude

        """
        return _gp.gp_VectorWithNullMagnitude_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _gp.gp_VectorWithNullMagnitude_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _gp.gp_VectorWithNullMagnitude_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _gp.gp_VectorWithNullMagnitude_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _gp.delete_gp_VectorWithNullMagnitude
gp_VectorWithNullMagnitude_swigregister = _gp.gp_VectorWithNullMagnitude_swigregister
gp_VectorWithNullMagnitude_swigregister(gp_VectorWithNullMagnitude)

def gp_VectorWithNullMagnitude_NewInstance(*args):
    """
    gp_VectorWithNullMagnitude_NewInstance(Standard_CString const theMessage) -> Handle_gp_VectorWithNullMagnitude

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.gp.Handle_gp_VectorWithNullMagnitude

    """
    return _gp.gp_VectorWithNullMagnitude_NewInstance(*args)

def gp_VectorWithNullMagnitude_get_type_name(*args):
    """
    gp_VectorWithNullMagnitude_get_type_name() -> char const *

    :rtype: const char *

    """
    return _gp.gp_VectorWithNullMagnitude_get_type_name(*args)

def gp_VectorWithNullMagnitude_get_type_descriptor(*args):
    """
    gp_VectorWithNullMagnitude_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _gp.gp_VectorWithNullMagnitude_get_type_descriptor(*args)

class Handle_gp_VectorWithNullMagnitude(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_gp_VectorWithNullMagnitude self)

        Nullify the handle


        """
        return _gp.Handle_gp_VectorWithNullMagnitude_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_gp_VectorWithNullMagnitude self) -> bool

        Check for being null

        :rtype: bool

        """
        return _gp.Handle_gp_VectorWithNullMagnitude_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_gp_VectorWithNullMagnitude self, gp_VectorWithNullMagnitude thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _gp.Handle_gp_VectorWithNullMagnitude_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_gp_VectorWithNullMagnitude self, Handle_gp_VectorWithNullMagnitude theHandle) -> Handle_gp_VectorWithNullMagnitude
        assign(Handle_gp_VectorWithNullMagnitude self, gp_VectorWithNullMagnitude thePtr) -> Handle_gp_VectorWithNullMagnitude
        assign(Handle_gp_VectorWithNullMagnitude self, Handle_gp_VectorWithNullMagnitude theHandle) -> Handle_gp_VectorWithNullMagnitude

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _gp.Handle_gp_VectorWithNullMagnitude_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_gp_VectorWithNullMagnitude self) -> gp_VectorWithNullMagnitude

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _gp.Handle_gp_VectorWithNullMagnitude_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_gp_VectorWithNullMagnitude self) -> gp_VectorWithNullMagnitude

        Member access operator (note non-const)

        :rtype: T *

        """
        return _gp.Handle_gp_VectorWithNullMagnitude___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_gp_VectorWithNullMagnitude self) -> gp_VectorWithNullMagnitude

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _gp.Handle_gp_VectorWithNullMagnitude___ref__(self, *args)


    def __hash__(self):
        return _gp.Handle_gp_VectorWithNullMagnitude___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _gp.Handle_gp_VectorWithNullMagnitude___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _gp.new_Handle_gp_VectorWithNullMagnitude(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_gp.Handle_gp_VectorWithNullMagnitude_DownCast)
    __swig_destroy__ = _gp.delete_Handle_gp_VectorWithNullMagnitude

    def NewInstance(self, *args):
        """
        NewInstance(Handle_gp_VectorWithNullMagnitude self, Standard_CString const theMessage) -> Handle_gp_VectorWithNullMagnitude

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.gp.Handle_gp_VectorWithNullMagnitude

        """
        return _gp.Handle_gp_VectorWithNullMagnitude_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_gp_VectorWithNullMagnitude self) -> char const *

        :rtype: const char *

        """
        return _gp.Handle_gp_VectorWithNullMagnitude_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _gp.Handle_gp_VectorWithNullMagnitude_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _gp.Handle_gp_VectorWithNullMagnitude_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_gp_VectorWithNullMagnitude self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _gp.Handle_gp_VectorWithNullMagnitude_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_gp_VectorWithNullMagnitude self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _gp.Handle_gp_VectorWithNullMagnitude_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_gp_VectorWithNullMagnitude self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _gp.Handle_gp_VectorWithNullMagnitude_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_gp_VectorWithNullMagnitude self)
        Reraise(Handle_gp_VectorWithNullMagnitude self, Standard_CString const aMessage)
        Reraise(Handle_gp_VectorWithNullMagnitude self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _gp.Handle_gp_VectorWithNullMagnitude_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_gp_VectorWithNullMagnitude self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _gp.Handle_gp_VectorWithNullMagnitude_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_gp_VectorWithNullMagnitude self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _gp.Handle_gp_VectorWithNullMagnitude_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_gp_VectorWithNullMagnitude self)

        Memory deallocator for transient classes


        """
        return _gp.Handle_gp_VectorWithNullMagnitude_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_gp_VectorWithNullMagnitude self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_gp_VectorWithNullMagnitude self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.Handle_gp_VectorWithNullMagnitude_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_gp_VectorWithNullMagnitude self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_gp_VectorWithNullMagnitude self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gp.Handle_gp_VectorWithNullMagnitude_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_gp_VectorWithNullMagnitude self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _gp.Handle_gp_VectorWithNullMagnitude_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_gp_VectorWithNullMagnitude self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _gp.Handle_gp_VectorWithNullMagnitude_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_gp_VectorWithNullMagnitude self)

        Increments the reference counter of this object


        """
        return _gp.Handle_gp_VectorWithNullMagnitude_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_gp_VectorWithNullMagnitude self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _gp.Handle_gp_VectorWithNullMagnitude_DecrementRefCounter(self, *args)

Handle_gp_VectorWithNullMagnitude_swigregister = _gp.Handle_gp_VectorWithNullMagnitude_swigregister
Handle_gp_VectorWithNullMagnitude_swigregister(Handle_gp_VectorWithNullMagnitude)

def Handle_gp_VectorWithNullMagnitude_DownCast(thing):
    return _gp.Handle_gp_VectorWithNullMagnitude_DownCast(thing)
Handle_gp_VectorWithNullMagnitude_DownCast = _gp.Handle_gp_VectorWithNullMagnitude_DownCast



